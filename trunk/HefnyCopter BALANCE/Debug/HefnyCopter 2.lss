
HefnyCopter 2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000022  00800100  00007742  000077d6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00007742  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000729  00800122  00800122  000077f8  2**0
                  ALLOC
  3 .stab         00003744  00000000  00000000  000077f8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000ddf  00000000  00000000  0000af3c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000338  00000000  00000000  0000bd1b  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00003f0f  00000000  00000000  0000c053  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000d6ea  00000000  00000000  0000ff62  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000254d  00000000  00000000  0001d64c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000064ef  00000000  00000000  0001fb99  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000a40  00000000  00000000  00026088  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000019d8  00000000  00000000  00026ac8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000214f  00000000  00000000  000284a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubtypes 00000b71  00000000  00000000  0002a5ef  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000130  00000000  00000000  0002b160  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 7a 0b 	jmp	0x16f4	; 0x16f4 <__ctors_end>
       4:	0c 94 7b 0a 	jmp	0x14f6	; 0x14f6 <__vector_1>
       8:	0c 94 3d 0a 	jmp	0x147a	; 0x147a <__vector_2>
       c:	0c 94 ea 0a 	jmp	0x15d4	; 0x15d4 <__vector_3>
      10:	0c 94 97 0b 	jmp	0x172e	; 0x172e <__bad_interrupt>
      14:	0c 94 3e 0b 	jmp	0x167c	; 0x167c <__vector_5>
      18:	0c 94 a4 09 	jmp	0x1348	; 0x1348 <__vector_6>
      1c:	0c 94 b9 0a 	jmp	0x1572	; 0x1572 <__vector_7>
      20:	0c 94 97 0b 	jmp	0x172e	; 0x172e <__bad_interrupt>
      24:	0c 94 97 0b 	jmp	0x172e	; 0x172e <__bad_interrupt>
      28:	0c 94 97 0b 	jmp	0x172e	; 0x172e <__bad_interrupt>
      2c:	0c 94 2e 10 	jmp	0x205c	; 0x205c <__vector_11>
      30:	0c 94 97 0b 	jmp	0x172e	; 0x172e <__bad_interrupt>
      34:	0c 94 97 0b 	jmp	0x172e	; 0x172e <__bad_interrupt>
      38:	0c 94 97 0b 	jmp	0x172e	; 0x172e <__bad_interrupt>
      3c:	0c 94 17 10 	jmp	0x202e	; 0x202e <__vector_15>
      40:	0c 94 97 0b 	jmp	0x172e	; 0x172e <__bad_interrupt>
      44:	0c 94 97 0b 	jmp	0x172e	; 0x172e <__bad_interrupt>
      48:	0c 94 4b 09 	jmp	0x1296	; 0x1296 <__vector_18>
      4c:	0c 94 97 0b 	jmp	0x172e	; 0x172e <__bad_interrupt>
      50:	0c 94 97 0b 	jmp	0x172e	; 0x172e <__bad_interrupt>
      54:	0c 94 97 0b 	jmp	0x172e	; 0x172e <__bad_interrupt>
      58:	0c 94 97 0b 	jmp	0x172e	; 0x172e <__bad_interrupt>
      5c:	0c 94 97 0b 	jmp	0x172e	; 0x172e <__bad_interrupt>
      60:	0c 94 3d 28 	jmp	0x507a	; 0x507a <__vector_24>
      64:	0c 94 97 0b 	jmp	0x172e	; 0x172e <__bad_interrupt>
      68:	0c 94 97 0b 	jmp	0x172e	; 0x172e <__bad_interrupt>
      6c:	0c 94 97 0b 	jmp	0x172e	; 0x172e <__bad_interrupt>
      70:	0c 94 ff 10 	jmp	0x21fe	; 0x21fe <__vector_28>
      74:	0c 94 97 0b 	jmp	0x172e	; 0x172e <__bad_interrupt>
      78:	0c 94 97 0b 	jmp	0x172e	; 0x172e <__bad_interrupt>

0000007c <_initSeq>:
      7c:	a2 a0 c8 40 a6 a4 2f 24 81 20 af 00                 ...@../$. ..

00000088 <masks.1995>:
      88:	01 02 04 08 10 20 40 80                             ..... @.

00000090 <defaultConfig>:
      90:	fe 90 01 00 ff 00 00 03 00 01 00 00 00 96 08 00     ................
      a0:	19 00 64 00 00 00 00 00 fd ff 14 00 00 00 19 00     ..d.............
      b0:	64 00 00 00 00 00 fd ff 14 00 00 00 32 00 5a 00     d...........2.Z.
      c0:	32 00 5a 00 00 00 14 00 c8 00 0a 00 5a 00 14 00     2.Z.........Z...
      d0:	0f 00 fe ff 32 00 e3 03 0a 00 5a 00 14 00 0f 00     ....2.....Z.....
      e0:	fe ff 32 00 e3 03 0f 00 1e 00 00 00 00 00 00 00     ..2.............
      f0:	00 00 58 02 0f 00 19 00 00 00 00 00 00 00 00 00     ..X.............
	...
     154:	00 00 00 01 00                                      .....

00000159 <font12x16>:
     159:	0c 10 90 11                                         ....

0000015d <_font12x16map>:
	...
     17d:	7c 00 ff 33 ff 33 7c 00 00 00 00 00 00 00 00 00     |..3.3|.........
     18d:	00 00 00 00 00 00 3c 00 3c 00 00 00 00 00 3c 00     ......<.<.....<.
     19d:	3c 00 00 00 00 00 00 00 00 00 00 02 10 1e 90 1f     <...............
     1ad:	f0 03 7e 02 1e 1e 90 1f f0 03 7e 02 1e 00 10 00     ..~.......~.....
     1bd:	00 00 00 00 78 04 fc 0c cc 0c ff 3f ff 3f cc 0c     ....x......?.?..
     1cd:	cc 0f 88 07 00 00 00 00 00 00 00 30 38 38 38 1c     ...........0888.
     1dd:	38 0e 00 07 80 03 c0 01 e0 38 70 38 38 38 1c 00     8........8p888..
     1ed:	00 00 00 00 00 1f b8 3f fc 31 c6 21 e2 37 3e 1e     .......?.1.!.7>.
     1fd:	1c 1c 00 36 00 22 00 00 00 00 00 00 00 00 00 00     ...6."..........
     20d:	27 00 3f 00 1f 00 00 00 00 00 00 00 00 00 00 00     '.?.............
     21d:	00 00 00 00 00 00 f0 03 fc 0f fe 1f 07 38 01 20     .............8. 
     22d:	01 20 00 00 00 00 00 00 00 00 00 00 00 00 01 20     . ............. 
     23d:	01 20 07 38 fe 1f fc 0f f0 03 00 00 00 00 00 00     . .8............
     24d:	00 00 00 00 98 0c b8 0e e0 03 f8 0f f8 0f e0 03     ................
     25d:	b8 0e 98 0c 00 00 00 00 00 00 00 00 80 01 80 01     ................
     26d:	80 01 f0 0f f0 0f 80 01 80 01 80 01 00 00 00 00     ................
	...
     285:	00 b8 00 f8 00 78 00 00 00 00 00 00 00 00 00 00     .....x..........
     295:	00 00 00 00 80 01 80 01 80 01 80 01 80 01 80 01     ................
     2a5:	80 01 80 01 00 00 00 00 00 00 00 00 00 00 00 00     ................
     2b5:	00 38 00 38 00 38 00 00 00 00 00 00 00 00 00 00     .8.8.8..........
     2c5:	00 00 00 18 00 1c 00 0e 00 07 80 03 c0 01 e0 00     ................
     2d5:	70 00 38 00 1c 00 0e 00 00 00 f8 07 fe 1f 06 1e     p.8.............
     2e5:	03 33 83 31 c3 30 63 30 33 30 1e 18 fe 1f f8 07     .3.1.0c030......
     2f5:	00 00 00 00 00 00 0c 30 0c 30 0e 30 ff 3f ff 3f     .......0.0.0.?.?
     305:	00 30 00 30 00 30 00 00 00 00 1c 30 1e 38 07 3c     .0.0.0.....0.8.<
     315:	03 3e 03 37 83 33 c3 31 e3 30 77 30 3e 30 1c 30     .>.7.3.1.0w0>0.0
     325:	00 00 0c 0c 0e 1c 07 38 c3 30 c3 30 c3 30 c3 30     .......8.0.0.0.0
     335:	c3 30 e7 39 7e 1f 3c 0e 00 00 c0 03 e0 03 70 03     .0.9~.<.......p.
     345:	38 03 1c 03 0e 03 07 03 ff 3f ff 3f 00 03 00 03     8........?.?....
     355:	00 00 3f 0c 7f 1c 63 38 63 30 63 30 63 30 63 30     ..?...c8c0c0c0c0
     365:	63 30 e3 38 c3 1f 83 0f 00 00 c0 0f f0 1f f8 39     c0.8...........9
     375:	dc 30 ce 30 c7 30 c3 30 c3 30 c3 39 80 1f 00 0f     .0.0.0.0.0.9....
     385:	00 00 03 00 03 00 03 00 03 30 03 3c 03 0f c3 03     .........0.<....
     395:	f3 00 3f 00 0f 00 03 00 00 00 00 0f bc 1f fe 39     ..?............9
     3a5:	e7 30 c3 30 c3 30 c3 30 e7 30 fe 39 bc 1f 00 0f     .0.0.0.0.0.9....
     3b5:	00 00 3c 00 7e 00 e7 30 c3 30 c3 30 c3 38 c3 1c     ..<.~..0.0.0.8..
     3c5:	c3 0e e7 07 fe 03 fc 00 00 00 00 00 00 00 00 00     ................
     3d5:	70 1c 70 1c 70 1c 00 00 00 00 00 00 00 00 00 00     p.p.p...........
	...
     3ed:	70 9c 70 fc 70 7c 00 00 00 00 00 00 00 00 00 00     p.p.p|..........
     3fd:	00 00 00 00 c0 00 e0 01 f0 03 38 07 1c 0e 0e 1c     ..........8.....
     40d:	07 38 03 30 00 00 00 00 00 00 00 00 60 06 60 06     .8.0........`.`.
     41d:	60 06 60 06 60 06 60 06 60 06 60 06 60 06 00 00     `.`.`.`.`.`.`...
     42d:	00 00 00 00 03 30 07 38 0e 1c 1c 0e 38 07 f0 03     .....0.8....8...
     43d:	e0 01 c0 00 00 00 00 00 00 00 1c 00 1e 00 07 00     ................
     44d:	03 00 83 37 c3 37 e3 00 77 00 3e 00 1c 00 00 00     ...7.7..w.>.....
     45d:	00 00 f8 0f fe 1f 07 18 f3 33 fb 37 1b 36 fb 37     .........3.7.6.7
     46d:	fb 37 07 36 fe 03 f8 01 00 00 00 38 00 3f e0 07     .7.6.......8.?..
     47d:	fc 06 1f 06 1f 06 fc 06 e0 07 00 3f 00 38 00 00     ...........?.8..
     48d:	00 00 ff 3f ff 3f c3 30 c3 30 c3 30 c3 30 e7 30     ...?.?.0.0.0.0.0
     49d:	fe 39 bc 1f 00 0f 00 00 00 00 f0 03 fc 0f 0e 1c     .9..............
     4ad:	07 38 03 30 03 30 03 30 07 38 0e 1c 0c 0c 00 00     .8.0.0.0.8......
     4bd:	00 00 ff 3f ff 3f 03 30 03 30 03 30 03 30 07 38     ...?.?.0.0.0.0.8
     4cd:	0e 1c fc 0f f0 03 00 00 00 00 ff 3f ff 3f c3 30     ...........?.?.0
     4dd:	c3 30 c3 30 c3 30 c3 30 c3 30 03 30 03 30 00 00     .0.0.0.0.0.0.0..
     4ed:	00 00 ff 3f ff 3f c3 00 c3 00 c3 00 c3 00 c3 00     ...?.?..........
     4fd:	c3 00 03 00 03 00 00 00 00 00 f0 03 fc 0f 0e 1c     ................
     50d:	07 38 03 30 c3 30 c3 30 c3 30 c7 3f c6 3f 00 00     .8.0.0.0.0.?.?..
     51d:	00 00 ff 3f ff 3f c0 00 c0 00 c0 00 c0 00 c0 00     ...?.?..........
     52d:	c0 00 ff 3f ff 3f 00 00 00 00 00 00 00 00 03 30     ...?.?.........0
     53d:	03 30 ff 3f ff 3f 03 30 03 30 00 00 00 00 00 00     .0.?.?.0.0......
     54d:	00 00 00 0e 00 1e 00 38 00 30 00 30 00 30 00 30     .......8.0.0.0.0
     55d:	00 38 ff 1f ff 07 00 00 00 00 ff 3f ff 3f c0 00     .8.........?.?..
     56d:	e0 01 f0 03 38 07 1c 0e 0e 1c 07 38 03 30 00 00     ....8......8.0..
     57d:	00 00 ff 3f ff 3f 00 30 00 30 00 30 00 30 00 30     ...?.?.0.0.0.0.0
     58d:	00 30 00 30 00 30 00 00 00 00 ff 3f ff 3f 1e 00     .0.0.0.....?.?..
     59d:	78 00 e0 01 e0 01 78 00 1e 00 ff 3f ff 3f 00 00     x.....x....?.?..
     5ad:	00 00 ff 3f ff 3f 0e 00 38 00 f0 00 c0 03 00 07     ...?.?..8.......
     5bd:	00 1c ff 3f ff 3f 00 00 00 00 f0 03 fc 0f 0e 1c     ...?.?..........
     5cd:	07 38 03 30 03 30 07 38 0e 1c fc 0f f0 03 00 00     .8.0.0.8........
     5dd:	00 00 ff 3f ff 3f 83 01 83 01 83 01 83 01 83 01     ...?.?..........
     5ed:	c7 01 fe 00 7c 00 00 00 00 00 f0 03 fc 0f 0e 1c     ....|...........
     5fd:	07 38 03 30 03 36 07 3e 0e 1c fc 3f f0 33 00 00     .8.0.6.>...?.3..
     60d:	00 00 ff 3f ff 3f 83 01 83 01 83 03 83 07 83 0f     ...?.?..........
     61d:	c7 1d fe 38 7c 30 00 00 00 00 3c 0c 7e 1c e7 38     ...8|0....<.~..8
     62d:	c3 30 c3 30 c3 30 c3 30 c7 39 8e 1f 0c 0f 00 00     .0.0.0.0.9......
     63d:	00 00 00 00 03 00 03 00 03 00 ff 3f ff 3f 03 00     ...........?.?..
     64d:	03 00 03 00 00 00 00 00 00 00 ff 07 ff 1f 00 38     ...............8
     65d:	00 30 00 30 00 30 00 30 00 38 ff 1f ff 07 00 00     .0.0.0.0.8......
     66d:	00 00 07 00 3f 00 f8 01 c0 0f 00 3e 00 3e c0 0f     ....?......>.>..
     67d:	f8 01 3f 00 07 00 00 00 00 00 ff 3f ff 3f 00 1c     ..?........?.?..
     68d:	00 06 80 03 80 03 00 06 00 1c ff 3f ff 3f 00 00     ...........?.?..
     69d:	00 00 03 30 0f 3c 1c 0e 30 03 e0 01 e0 01 30 03     ...0.<..0.....0.
     6ad:	1c 0e 0f 3c 03 30 00 00 00 00 03 00 0f 00 3c 00     ...<.0........<.
     6bd:	f0 00 c0 3f c0 3f f0 00 3c 00 0f 00 03 00 00 00     ...?.?..<.......
     6cd:	00 00 03 30 03 3c 03 3e 03 33 c3 31 e3 30 33 30     ...0.<.>.3.1.030
     6dd:	1f 30 0f 30 03 30 00 00 00 00 00 00 00 00 ff 3f     .0.0.0.........?
     6ed:	ff 3f 03 30 03 30 03 30 03 30 00 00 00 00 00 00     .?.0.0.0.0......
     6fd:	00 00 0e 00 1c 00 38 00 70 00 e0 00 c0 01 80 03     ......8.p.......
     70d:	00 07 00 0e 00 1c 00 18 00 00 00 00 00 00 03 30     ...............0
     71d:	03 30 03 30 03 30 ff 3f ff 3f 00 00 00 00 00 00     .0.0.0.?.?......
     72d:	00 00 60 00 70 00 38 00 1c 00 0e 00 07 00 0e 00     ..`.p.8.........
     73d:	1c 00 38 00 70 00 60 00 00 00 00 c0 00 c0 00 c0     ..8.p.`.........
     74d:	00 c0 00 c0 00 c0 00 c0 00 c0 00 c0 00 c0 00 c0     ................

0000075d <font6x8>:
     75d:	06 08 a0 11                                         ....

00000761 <_font6x8map>:
	...
     769:	06 5f 06 00 00 07 03 00 07 03 00 24 7e 24 7e 24     ._.........$~$~$
     779:	00 24 2b 6a 12 00 00 63 13 08 64 63 00 36 49 56     .$+j...c..dc.6IV
     789:	20 50 00 00 07 03 00 00 00 00 3e 41 00 00 00 00      P........>A....
     799:	41 3e 00 00 00 08 3e 1c 3e 08 00 08 08 3e 08 08     A>....>.>....>..
     7a9:	00 00 e0 60 00 00 00 08 08 08 08 08 00 00 60 60     ...`..........``
     7b9:	00 00 00 20 10 08 04 02 00 3e 51 49 45 3e 00 00     ... .....>QIE>..
     7c9:	42 7f 40 00 00 62 51 49 49 46 00 22 49 49 49 36     B.@..bQIIF."III6
     7d9:	00 18 14 12 7f 10 00 2f 49 49 49 31 00 3c 4a 49     ......./III1.<JI
     7e9:	49 30 00 01 71 09 05 03 00 36 49 49 49 36 00 06     I0..q....6III6..
     7f9:	49 49 29 1e 00 00 6c 6c 00 00 00 00 ec 6c 00 00     II)...ll.....l..
     809:	00 08 14 22 41 00 00 24 24 24 24 24 00 00 41 22     ..."A..$$$$$..A"
     819:	14 08 00 02 01 59 09 06 00 3e 41 5d 55 1e 00 7e     .....Y...>A]U..~
     829:	11 11 11 7e 00 7f 49 49 49 36 00 3e 41 41 41 22     ...~..III6.>AAA"
     839:	00 7f 41 41 41 3e 00 7f 49 49 49 41 00 7f 09 09     ..AAA>..IIIA....
     849:	09 01 00 3e 41 49 49 7a 00 7f 08 08 08 7f 00 00     ...>AIIz........
     859:	41 7f 41 00 00 30 40 40 40 3f 00 7f 08 14 22 41     A.A..0@@@?...."A
     869:	00 7f 40 40 40 40 00 7f 02 04 02 7f 00 7f 02 04     ..@@@@..........
     879:	08 7f 00 3e 41 41 41 3e 00 7f 09 09 09 06 00 3e     ...>AAA>.......>
     889:	41 51 21 5e 00 7f 09 09 19 66 00 26 49 49 49 32     AQ!^.....f.&III2
     899:	00 01 01 7f 01 01 00 3f 40 40 40 3f 00 1f 20 40     .......?@@@?.. @
     8a9:	20 1f 00 3f 40 3c 40 3f 00 63 14 08 14 63 00 07      ..?@<@?.c...c..
     8b9:	08 70 08 07 00 71 49 45 43 00 00 00 7f 41 41 00     .p...qIEC....AA.
     8c9:	00 02 04 08 10 20 00 00 41 41 7f 00 00 04 02 01     ..... ..AA......
     8d9:	02 04 80 80 80 80 80 80 00 00 03 07 00 00 00 20     ............... 
     8e9:	54 54 54 78 00 7f 44 44 44 38 00 38 44 44 44 28     TTTx..DDD8.8DDD(
     8f9:	00 38 44 44 44 7f 00 38 54 54 54 08 00 08 7e 09     .8DDD..8TTT...~.
     909:	09 00 00 18 a4 a4 a4 7c 00 7f 04 04 78 00 00 00     .......|....x...
     919:	00 7d 40 00 00 40 80 84 7d 00 00 7f 10 28 44 00     .}@..@..}....(D.
     929:	00 00 00 7f 40 00 00 7c 04 18 04 78 00 7c 04 04     ....@..|...x.|..
     939:	78 00 00 38 44 44 44 38 00 fc 44 44 44 38 00 38     x..8DDD8..DDD8.8
     949:	44 44 44 fc 00 44 78 44 04 08 00 08 54 54 54 20     DDD..DxD....TTT 
     959:	00 04 3e 44 24 00 00 3c 40 20 7c 00 00 1c 20 40     ..>D$..<@ |... @
     969:	20 1c 00 3c 60 30 60 3c 00 6c 10 10 6c 00 00 9c      ..<`0`<.l..l...
     979:	a0 60 3c 00 00 64 54 54 4c 00 00 08 3e 41 41 00     .`<..dTTL...>AA.
     989:	00 00 00 77 00 00 00 00 41 41 3e 08 00 02 01 02     ...w....AA>.....
     999:	01 00 00 3c 26 23 26 3c                             ...<&#&<

000009a1 <fonts>:
     9a1:	5d 07 59 01                                         ].Y.

000009a5 <glyArrowUp>:
     9a5:	08 08 30 38 3c 3e 3e 3c 38 30                       ..08<>><80

000009af <glyArrowDown>:
     9af:	08 08 06 0e 1e 3e 3e 1e 0e 06                       .....>>...

000009b9 <glyBall>:
     9b9:	09 09 38 00 fe 00 fe 00 ff 01 ff 01 ff 01 fe 00     ..8.............
     9c9:	fe 00 38 00                                         ..8.

000009cd <glyDirCW>:
     9cd:	09 03 00 00 00 00 02 02 02 07 02                    ...........

000009d8 <glyDirCCW>:
     9d8:	05 03 02 07 02 02 02                                .......

000009df <glyLogo>:
     9df:	40 40 00 00 00 00 01 03 03 03 03 03 03 03 03 03     @@..............
     9ef:	03 03 03 03 03 03 07 0f 1f 1f 3f 3f 7f 7f 7f 7f     ..........??....
     9ff:	7f 3f 1f 0f 00 03 03 03 03 03 03 03 03 03 03 03     .?..............
     a0f:	03 03 03 03 03 07 07 07 07 07 07 07 03 03 01 00     ................
     a1f:	00 00 00 00 00 00 ff ff 00 00 00 00 00 00 00 00     ................
     a2f:	00 01 1f 7f ff ff ff ff ff e7 c3 e7 ff ff ff ff     ................
     a3f:	ff ff fe f0 00 00 00 00 00 00 00 00 00 07 0f 3f     ...............?
     a4f:	7f ff ff ff fc fc ff ff ff ff ff ff ff ff 7c c3     ..............|.
     a5f:	00 00 00 00 00 00 ff ff 00 00 00 00 00 00 00 00     ................
     a6f:	00 00 f0 f8 fc fe fe fe fe fc fc fd fb f7 f7 ef     ................
     a7f:	df 0b 00 00 00 00 00 00 00 01 03 03 ff ff ff ff     ................
     a8f:	ff ff ff ff 7f 7f ff ff ff fe fc f8 e0 80 7f ff     ................
     a9f:	00 00 00 00 00 00 ff ff 00 00 00 00 00 00 00 00     ................
	...
     ab7:	00 00 00 80 fd ff ff ff ff ff 7f 1f 3f 7f 7f fe     ............?...
     ac7:	fe fc f8 f8 f0 f0 e0 c0 c0 e0 c0 c0 c0 c0 80 80     ................
     ad7:	00 00 00 00 00 00 ff ff 00 00 00 00 00 00 ff ff     ................
     ae7:	00 00 01 01 03 03 07 07 07 0f 07 07 07 03 03 07     ................
     af7:	0f 0f 3f 7f ff ff fe fe ff ff ff ff ff af 03 00     ..?.............
	...
     b1b:	00 00 ff ff 00 00 00 00 00 00 ff ff 3f 7f ff ff     ............?...
     b2b:	fc f8 fc ff ff ff ff ff ff ff ff e8 c0 c0 80 80     ................
     b3b:	00 00 00 00 80 f9 ff ff ff ff ff 7f 7f 7f 7f ff     ................
     b4b:	7f 7f 7f 3f 1f 01 00 00 00 00 00 00 00 00 00 00     ...?............
     b5b:	00 00 ff ff 00 00 00 00 00 fe ff ff ff ff ff ff     ................
     b6b:	ff 7f ff ff ff ff fe fc f0 e0 00 00 00 00 00 00     ................
     b7b:	00 00 01 1f 7f ff ff ff ff ff c7 c7 cf ff ff ff     ................
     b8b:	ff ff ff fe f0 00 00 00 00 00 00 00 00 00 00 00     ................
     b9b:	00 00 ff ff 00 00 00 00 00 00 f0 f8 d8 d8 f8 d8     ................
     bab:	d8 d8 d8 98 18 18 18 18 18 18 18 18 18 18 18 18     ................
     bbb:	18 18 18 f8 f8 fc fc fc fe fc fc fc fc f8 f0 f0     ................
     bcb:	d8 d8 18 18 18 18 18 18 18 18 18 18 18 18 18 18     ................
     bdb:	18 18 f8 f0 00 00                                   ......

00000be1 <scrESCCal>:
     be1:	09 0e 73 0e                                         ..s.

00000be5 <lstMenu>:
     be5:	a7 0e b7 0e c5 0e d3 0e e1 0e f0 0e fc 0e 0a 0f     ................
     bf5:	1d 0f 2d 0f 3d 0f 43 0f                             ..-.=.C.

00000bfd <strAreYouSure>:
     bfd:	41 72 65 20 79 6f 75 20 73 75 72 65 3f 00           Are you sure?.

00000c0b <__c.2278>:
     c0b:	4d 65 61 73 00                                      Meas.

00000c10 <_skMENUSAVE>:
     c10:	53 41 56 45 20 55 50 20 20 20 44 4f 57 4e 20 20     SAVE UP   DOWN  
     c20:	45 4e 54 45 52 00                                   ENTER.

00000c26 <__c.2269>:
     c26:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
	...

00000c37 <_skEDIT>:
     c37:	43 41 4e 43 45 4c 20 20 44 4f 57 4e 20 20 20 55     CANCEL  DOWN   U
     c47:	50 20 20 4f 4b 00                                   P  OK.

00000c4d <__c.2259>:
     c4d:	41 43 43 2d 5a 20 64 61 6d 70 69 6e 67 00           ACC-Z damping.

00000c5b <__c.2246>:
     c5b:	54 72 69 6d 20 50 3a 20 20 20 20 52 3a 00           Trim P:    R:.

00000c69 <__c.2244>:
     c69:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
	...

00000c7a <__c.2239>:
     c7a:	52 00                                               R.

00000c7c <__c.2237>:
     c7c:	4e 00                                               N.

00000c7e <__c.2235>:
     c7e:	52 65 76 65 72 73 65 20 47 59 52 4f 00              Reverse GYRO.

00000c8b <__c.2233>:
     c8b:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
	...

00000c9c <__c.2218>:
     c9c:	6e 6f 20 00                                         no .

00000ca0 <__c.2216>:
     ca0:	79 65 73 00                                         yes.

00000ca4 <strYes>:
     ca4:	59 65 73 00                                         Yes.

00000ca8 <strNo>:
     ca8:	4e 6f 20 00                                         No .

00000cac <__c.2205>:
     cac:	41 20 54 72 69 20 00                                A Tri .

00000cb3 <__c.2203>:
     cb3:	59 20 54 72 69 20 00                                Y Tri .

00000cba <__c.2201>:
     cba:	58 20 51 75 61 64 00                                X Quad.

00000cc1 <__c.2199>:
     cc1:	2b 20 51 75 61 64 00                                + Quad.

00000cc8 <__c.2197>:
     cc8:	58 20 51 75 61 64 00                                X Quad.

00000ccf <__c.2195>:
     ccf:	2b 20 51 75 61 64 00                                + Quad.

00000cd6 <__c.2193>:
     cd6:	55 41 52 54 20 00                                   UART .

00000cdc <__c.2191>:
     cdc:	42 75 64 64 79 00                                   Buddy.

00000ce2 <__c.2189>:
     ce2:	54 52 49 20 00                                      TRI .

00000ce7 <__c.2187>:
     ce7:	51 75 61 64 00                                      Quad.

00000cec <_skBACK>:
     cec:	42 41 43 4b 20 20 20 20 20 20 20 20 20 20 20 20     BACK            
     cfc:	20 20 20 20 20 00                                        .

00000d02 <strSPC1>:
     d02:	20 00                                                .

00000d04 <strErr>:
     d04:	45 72 72 00                                         Err.

00000d08 <strSPC4>:
     d08:	20 20 20 20 00                                          .

00000d0d <__c.2160>:
     d0d:	4e 41 00                                            NA.

00000d10 <strARMED>:
     d10:	41 52 4d 45 44 00                                   ARMED.

00000d16 <strVersionInfo>:
     d16:	48 65 66 6e 79 43 6f 70 74 65 72 32 20 76 31 2e     HefnyCopter2 v1.
     d26:	30 2e 30 00                                         0.0.

00000d2a <strOK>:
     d2a:	4f 4b 20 00                                         OK .

00000d2e <str1>:
     d2e:	31 00                                               1.

00000d30 <strX>:
     d30:	58 00                                               X.

00000d32 <str2>:
     d32:	32 00                                               2.

00000d34 <__c.2127>:
     d34:	2b 00                                               +.

00000d36 <__c.2125>:
     d36:	58 00                                               X.

00000d38 <__c.2123>:
     d38:	59 00                                               Y.

00000d3a <__c.2121>:
     d3a:	2b 00                                               +.

00000d3c <__c.2119>:
     d3c:	41 00                                               A.

00000d3e <__c.2117>:
     d3e:	58 00                                               X.

00000d40 <__c.2115>:
     d40:	55 41 52 54 20 00                                   UART .

00000d46 <__c.2113>:
     d46:	42 75 64 64 79 00                                   Buddy.

00000d4c <__c.2111>:
     d4c:	54 52 49 20 00                                      TRI .

00000d51 <__c.2109>:
     d51:	51 75 61 64 00                                      Quad.

00000d56 <__c.2107>:
     d56:	41 4c 54 48 4c 44 00                                ALTHLD.

00000d5d <__c.2105>:
     d5d:	53 54 41 42 4c 45 00                                STABLE.

00000d64 <__c.2103>:
     d64:	41 43 52 4f 20 20 00                                ACRO  .

00000d6b <pages>:
     d6b:	51 0f 15 2d 67 0f 9b 0f c3 35 00 00 51 0f f9 2c     Q..-g....5..Q..,
     d7b:	b1 0f b5 0f ca 29 cb 0f b5 0f 81 28 00 10 9b 0f     .....).....(....
     d8b:	b4 31 15 10 9b 0f ad 2f 15 10 9b 0f 03 2f 15 10     .1...../...../..
     d9b:	9b 0f 51 34 5c 10 93 10 99 33 a9 10 ec 0c aa 29     ..Q4\....3.....)
     dab:	f3 10 ec 0c 60 2c 29 11 59 11 6c 29 f3 10 6f 11     ....`,).Y.l)..o.
     dbb:	d8 2a 29 11 59 11 dc 2c 09 0e ec 0c a7 28 00 00     .*).Y..,.....(..
     dcb:	85 11 cb 2c 00 00                                   ...,..

00000dd1 <__c.2036>:
     dd1:	59 41 57 20 20 20 20 20 20 20 20 20 20 00           YAW          .

00000ddf <__c.2033>:
     ddf:	52 6f 6c 6c 20 20 20 20 20 20 20 20 20 00           Roll         .

00000ded <__c.2029>:
     ded:	50 69 74 63 68 20 26 20 52 6f 6c 6c 20 00           Pitch & Roll .

00000dfb <__c.2027>:
     dfb:	50 69 74 63 68 20 20 20 20 20 20 20 20 00           Pitch        .

00000e09 <scrESCCal0>:
     e09:	2d 54 41 4b 45 20 4f 46 46 20 50 52 4f 50 45 4c     -TAKE OFF PROPEL
     e19:	4c 45 52 53 21 21 0a 2d 50 72 65 73 73 20 63 6f     LERS!!.-Press co
     e29:	6e 74 69 6e 75 65 0a 2d 54 75 72 6e 20 4f 66 66     ntinue.-Turn Off
     e39:	20 51 75 61 64 63 6f 70 74 65 72 2e 0a 0a 2d 51      Quadcopter...-Q
     e49:	75 61 64 20 77 69 6c 6c 20 73 74 61 72 74 65 64     uad will started
     e59:	0a 69 6e 20 41 52 4d 45 44 20 54 41 4b 45 43 41     .in ARMED TAKECA
     e69:	52 45 20 73 74 61 74 65 0a 00                       RE state..

00000e73 <scrESCCal1>:
     e73:	50 72 65 73 73 20 43 6f 6e 74 69 6e 75 65 20 61     Press Continue a
     e83:	66 74 65 72 20 63 61 6c 69 62 72 61 74 69 6f 6e     fter calibration
     e93:	2e 0a 0a 75 6e 70 6c 75 67 20 62 61 74 74 65 72     ...unplug batter
     ea3:	79 2e 0a 00                                         y...

00000ea7 <strStabilization>:
     ea7:	47 79 72 6f 20 50 49 44 20 45 64 69 74 6f 72 00     Gyro PID Editor.

00000eb7 <strSelflevel>:
     eb7:	53 65 6c 66 20 4c 65 76 65 6c 69 6e 67 00           Self Leveling.

00000ec5 <strAltitudeHold>:
     ec5:	41 6c 74 69 74 75 64 65 20 48 6f 6c 64 00           Altitude Hold.

00000ed3 <strModeSettings>:
     ed3:	4d 6f 64 65 20 53 65 74 74 69 6e 67 73 00           Mode Settings.

00000ee1 <strMiscSettings>:
     ee1:	4d 69 73 63 2e 20 53 65 74 74 69 6e 67 73 00        Misc. Settings.

00000ef0 <strSensorTest>:
     ef0:	53 65 6e 73 6f 72 20 54 65 73 74 00                 Sensor Test.

00000efc <strReceiverTest>:
     efc:	52 65 63 65 69 76 65 72 20 54 65 73 74 00           Receiver Test.

00000f0a <strSensorCalibration>:
     f0a:	53 65 6e 73 6f 72 20 43 61 6c 69 62 72 61 74 69     Sensor Calibrati
     f1a:	6f 6e 00                                            on.

00000f1d <strRadioCalibration>:
     f1d:	53 74 69 63 6b 20 43 65 6e 74 65 72 69 6e 67 00     Stick Centering.

00000f2d <strESCCalibration>:
     f2d:	45 53 43 20 43 61 6c 69 62 72 61 74 69 6f 6e 00     ESC Calibration.

00000f3d <strDebug>:
     f3d:	44 65 62 75 67 00                                   Debug.

00000f43 <strFactoryReset>:
     f43:	46 61 63 74 6f 72 79 20 52 65 73 65 74 00           Factory Reset.

00000f51 <_skHOME>:
     f51:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     f61:	20 4d 45 4e 55 00                                    MENU.

00000f67 <scrHomePage>:
     f67:	0a 0a 42 61 74 74 3a 20 20 20 20 20 20 20 76 0a     ..Batt:       v.
     f77:	0a 0a 52 58 3a 20 2d 20 20 53 4e 3a 20 20 20 20     ..RX: -  SN:    
     f87:	53 54 3a 20 2d 0a 46 6c 79 3a 20 20 20 42 6f 61     ST: -.Fly:   Boa
     f97:	72 64 3a 00                                         rd:.

00000f9b <_skMENU>:
     f9b:	42 41 43 4b 20 55 50 20 20 20 44 4f 57 4e 20 20     BACK UP   DOWN  
     fab:	45 4e 54 45 52 00                                   ENTER.

00000fb1 <scrHomePageArmed>:
     fb1:	0a 0a 0a 00                                         ....

00000fb5 <_skSAVE>:
     fb5:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     fc5:	20 44 4f 4e 45 00                                    DONE.

00000fcb <scrHomePageArmedESCCalibration>:
     fcb:	0a 0a 0a 4d 31 3a 20 20 20 20 20 20 20 4d 34 3a     ...M1:       M4:
     fdb:	0a 4d 32 3a 20 20 20 20 20 20 20 4d 33 3a 0a 45     .M2:       M3:.E
     feb:	53 43 20 43 61 6c 69 62 72 61 74 69 6f 6e 20 6d     SC Calibration m
     ffb:	6f 64 65 0a 00                                      ode..

00001000 <scrHomePageRestart>:
    1000:	0a 52 45 53 54 41 52 54 0a 20 20 20 20 20 20 42     .RESTART.      B
    1010:	4f 41 52 44 00                                      OARD.

00001015 <scrStabilization>:
    1015:	0a 50 3a 20 20 20 20 20 20 20 4c 69 6d 3a 0a 49     .P:       Lim:.I
    1025:	3a 20 20 20 20 20 20 20 4c 69 6d 3a 0a 44 3a 20     :       Lim:.D: 
    1035:	20 20 20 20 20 20 4c 69 6d 3a 0a 4e 6f 69 73 65           Lim:.Noise
    1045:	20 46 69 6c 74 65 72 3a 0a 54 72 69 6d 20 50 3a      Filter:.Trim P:
    1055:	20 20 20 20 52 3a 00                                    R:.

0000105c <scrModeSettings>:
    105c:	46 72 61 6d 65 20 54 79 70 65 3a 0a 42 75 64 64     Frame Type:.Budd
    106c:	79 20 53 79 73 74 65 6d 3a 0a 42 6f 61 72 64 20     y System:.Board 
    107c:	44 69 72 3a 0a 46 6c 79 20 20 20 44 69 72 3a 0a     Dir:.Fly   Dir:.
    108c:	53 6f 6e 61 72 3a 00                                Sonar:.

00001093 <_skPAGE>:
    1093:	42 41 43 4b 20 50 52 45 56 20 4e 45 58 54 20 43     BACK PREV NEXT C
    10a3:	48 41 4e 47 45 00                                   HANGE.

000010a9 <scrMiscSettings>:
    10a9:	41 75 74 6f 20 44 69 73 61 72 6d 3a 0a 56 6f 6c     Auto Disarm:.Vol
    10b9:	74 20 41 6c 61 72 6d 3a 20 20 20 20 20 20 2f 31     t Alarm:      /1
    10c9:	30 76 0a 54 68 72 6f 74 74 6c 65 20 6d 69 6e 3a     0v.Throttle min:
    10d9:	0a 53 74 69 63 6b 20 53 63 61 6c 65 3a 0a 50 2d     .Stick Scale:.P-
    10e9:	52 20 4c 69 6e 6b 65 64 3a 00                       R Linked:.

000010f3 <scrSensorTest>:
    10f3:	47 79 72 6f 20 52 3a 0a 47 79 72 6f 20 50 3a 0a     Gyro R:.Gyro P:.
    1103:	47 79 72 6f 20 59 3a 0a 41 63 63 20 20 50 3a 0a     Gyro Y:.Acc  P:.
    1113:	41 63 63 20 20 52 3a 0a 41 63 63 20 20 5a 3a 0a     Acc  R:.Acc  Z:.
    1123:	42 61 74 74 3a 00                                   Batt:.

00001129 <scrReceiverTest>:
    1129:	20 43 48 20 20 20 52 58 2d 31 20 20 20 20 52 58      CH   RX-1    RX
    1139:	2d 32 0a 41 69 6c 3a 0a 45 6c 65 3a 0a 52 75 64     -2.Ail:.Ele:.Rud
    1149:	3a 0a 54 68 72 3a 0a 41 75 78 3a 0a 52 58 3a 00     :.Thr:.Aux:.RX:.

00001159 <_skCONTINUE>:
    1159:	42 41 43 4b 20 20 20 20 20 20 20 20 20 43 4f 4e     BACK         CON
    1169:	54 49 4e 55 45 00                                   TINUE.

0000116f <_skCLRDONE>:
    116f:	42 41 43 4b 20 43 4c 52 20 20 20 20 20 20 20 20     BACK CLR        
    117f:	20 44 4f 4e 45 00                                    DONE.

00001185 <_skCANCELYES>:
    1185:	4e 4f 20 20 20 20 20 20 20 20 20 20 20 20 20 20     NO              
    1195:	20 20 59 45 53 00 00 40 7a 10 f3 5a 00 a0 72 4e       YES..@z..Z..rN
    11a5:	18 09 00 10 a5 d4 e8 00 00 e8 76 48 17 00 00 e4     ..........vH....
    11b5:	0b 54 02 00 00 ca 9a 3b 00 00 00 e1 f5 05 00 00     .T.....;........
    11c5:	80 96 98 00 00 00 40 42 0f 00 00 00 a0 86 01 00     ......@B........
    11d5:	00 00 10 27 00 00 00 00 e8 03 00 00 00 00 64 00     ...'..........d.
    11e5:	00 00 00 00 0a 00 00 00 00 00 01 00 00 00 00 00     ................
    11f5:	2c 76 d8 88 dc 67 4f 08 23 df c1 df ae 59 e1 b1     ,v...gO.#....Y..
    1205:	b7 96 e5 e3 e4 53 c6 3a e6 51 99 76 96 e8 e6 c2     .....S.:.Q.v....
    1215:	84 26 eb 89 8c 9b 62 ed 40 7c 6f fc ef bc 9c 9f     .&....b.@|o.....
    1225:	40 f2 ba a5 6f a5 f4 90 05 5a 2a f7 5c 93 6b 6c     @...o....Z*.\.kl
    1235:	f9 67 6d c1 1b fc e0 e4 0d 47 fe f5 20 e6 b5 00     .gm......G.. ...
    1245:	d0 ed 90 2e 03 00 94 35 77 05 00 80 84 1e 08 00     .......5w.......
    1255:	00 20 4e 0a 00 00 00 c8 0c 33 33 33 33 0f 98 6e     . N......3333..n
    1265:	12 83 11 41 ef 8d 21 14 89 3b e6 55 16 cf fe e6     ...A..!..;.U....
    1275:	db 18 d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb e4 24     ....K8..|......$
    1285:	20 32 84 72 5e 22 81 00 c9 f1 24 ec a1 e5 3d 27      2.r^"....$...='
	...

00001296 <__vector_18>:
	sendData(column & 0x0f, LCD_COMMAND);
}

__attribute__ ((section(".lowtext")))
ISR(TIMER0_OVF_vect, ISR_NOBLOCK)
{
    1296:	78 94       	sei
    1298:	1f 92       	push	r1
    129a:	0f 92       	push	r0
    129c:	0f b6       	in	r0, 0x3f	; 63
    129e:	0f 92       	push	r0
    12a0:	11 24       	eor	r1, r1
    12a2:	2f 93       	push	r18
    12a4:	3f 93       	push	r19
    12a6:	4f 93       	push	r20
    12a8:	5f 93       	push	r21
    12aa:	6f 93       	push	r22
    12ac:	7f 93       	push	r23
    12ae:	8f 93       	push	r24
    12b0:	9f 93       	push	r25
    12b2:	af 93       	push	r26
    12b4:	bf 93       	push	r27
    12b6:	cf 93       	push	r28
    12b8:	df 93       	push	r29
    12ba:	ef 93       	push	r30
    12bc:	ff 93       	push	r31
	TCNT0_X +=1;
    12be:	80 91 bc 05 	lds	r24, 0x05BC
    12c2:	90 91 bd 05 	lds	r25, 0x05BD
    12c6:	01 96       	adiw	r24, 0x01	; 1
    12c8:	90 93 bd 05 	sts	0x05BD, r25
    12cc:	80 93 bc 05 	sts	0x05BC, r24
	static uint16_t offset;
	
	if (offset % LCDWIDTH == 0)
    12d0:	c0 91 2b 05 	lds	r28, 0x052B
    12d4:	d0 91 2c 05 	lds	r29, 0x052C
    12d8:	ce 01       	movw	r24, r28
    12da:	8f 77       	andi	r24, 0x7F	; 127
    12dc:	90 70       	andi	r25, 0x00	; 0
    12de:	00 97       	sbiw	r24, 0x00	; 0
    12e0:	99 f4       	brne	.+38     	; 0x1308 <__vector_18+0x72>
		setPos(offset / LCDWIDTH, 0);
    12e2:	ce 01       	movw	r24, r28
    12e4:	88 0f       	add	r24, r24
    12e6:	89 2f       	mov	r24, r25
    12e8:	88 1f       	adc	r24, r24
    12ea:	99 0b       	sbc	r25, r25
    12ec:	91 95       	neg	r25
	LCD_CS = 1;
}

static void setPos(uint8_t line, uint8_t column)
{
	sendData(0xB0 | (line & 0x07), LCD_COMMAND);
    12ee:	87 70       	andi	r24, 0x07	; 7
    12f0:	80 6b       	ori	r24, 0xB0	; 176
    12f2:	60 e0       	ldi	r22, 0x00	; 0
    12f4:	0e 94 fa 0b 	call	0x17f4	; 0x17f4 <sendData>
	sendData(0x10 | (column >> 4), LCD_COMMAND);
    12f8:	80 e1       	ldi	r24, 0x10	; 16
    12fa:	60 e0       	ldi	r22, 0x00	; 0
    12fc:	0e 94 fa 0b 	call	0x17f4	; 0x17f4 <sendData>
	sendData(column & 0x0f, LCD_COMMAND);
    1300:	80 e0       	ldi	r24, 0x00	; 0
    1302:	60 e0       	ldi	r22, 0x00	; 0
    1304:	0e 94 fa 0b 	call	0x17f4	; 0x17f4 <sendData>
	static uint16_t offset;
	
	if (offset % LCDWIDTH == 0)
		setPos(offset / LCDWIDTH, 0);
		
	sendData(*(_screen + offset++), LCD_DATA);
    1308:	fe 01       	movw	r30, r28
    130a:	e5 5d       	subi	r30, 0xD5	; 213
    130c:	fe 4f       	sbci	r31, 0xFE	; 254
    130e:	80 81       	ld	r24, Z
    1310:	61 e0       	ldi	r22, 0x01	; 1
    1312:	0e 94 fa 0b 	call	0x17f4	; 0x17f4 <sendData>
    1316:	21 96       	adiw	r28, 0x01	; 1
	offset %= sizeof(_screen);
    1318:	d3 70       	andi	r29, 0x03	; 3
    131a:	d0 93 2c 05 	sts	0x052C, r29
    131e:	c0 93 2b 05 	sts	0x052B, r28
}
    1322:	ff 91       	pop	r31
    1324:	ef 91       	pop	r30
    1326:	df 91       	pop	r29
    1328:	cf 91       	pop	r28
    132a:	bf 91       	pop	r27
    132c:	af 91       	pop	r26
    132e:	9f 91       	pop	r25
    1330:	8f 91       	pop	r24
    1332:	7f 91       	pop	r23
    1334:	6f 91       	pop	r22
    1336:	5f 91       	pop	r21
    1338:	4f 91       	pop	r20
    133a:	3f 91       	pop	r19
    133c:	2f 91       	pop	r18
    133e:	0f 90       	pop	r0
    1340:	0f be       	out	0x3f, r0	; 63
    1342:	0f 90       	pop	r0
    1344:	1f 90       	pop	r1
    1346:	18 95       	reti

00001348 <__vector_6>:
 
 uint8_t OldPortCValue;

__attribute__ ((section(".lowtext")))
ISR (RX2_ALL_vect)
{
    1348:	1f 92       	push	r1
    134a:	0f 92       	push	r0
    134c:	0f b6       	in	r0, 0x3f	; 63
    134e:	0f 92       	push	r0
    1350:	11 24       	eor	r1, r1
    1352:	0f 93       	push	r16
    1354:	1f 93       	push	r17
    1356:	2f 93       	push	r18
    1358:	3f 93       	push	r19
    135a:	4f 93       	push	r20
    135c:	5f 93       	push	r21
    135e:	6f 93       	push	r22
    1360:	7f 93       	push	r23
    1362:	8f 93       	push	r24
    1364:	9f 93       	push	r25
    1366:	af 93       	push	r26
    1368:	bf 93       	push	r27
    136a:	cf 93       	push	r28
    136c:	df 93       	push	r29
    136e:	ef 93       	push	r30
    1370:	ff 93       	push	r31
	uint8_t Changes = PINC ^ OldPortCValue;  // capture changed bit
    1372:	16 b1       	in	r17, 0x06	; 6
    1374:	80 91 23 08 	lds	r24, 0x0823
    1378:	18 27       	eor	r17, r24
	OldPortCValue = PINC;
    137a:	86 b1       	in	r24, 0x06	; 6
    137c:	80 93 23 08 	sts	0x0823, r24
	uint16_t TCNT1_TEMP = TCNT1;
    1380:	c0 91 84 00 	lds	r28, 0x0084
    1384:	d0 91 85 00 	lds	r29, 0x0085
	// if there is a signal change in ROLL
	if ((Changes & RX2_ROLL_PIN)!=0)
    1388:	01 2f       	mov	r16, r17
    138a:	15 ff       	sbrs	r17, 5
    138c:	18 c0       	rjmp	.+48     	; 0x13be <__vector_6+0x76>
	{
		if (RX2_ROLL)
    138e:	86 b1       	in	r24, 0x06	; 6
    1390:	85 ff       	sbrs	r24, 5
    1392:	05 c0       	rjmp	.+10     	; 0x139e <__vector_6+0x56>
		{
			RX_raw[1][RXChannel_AIL]=TCNT1_TEMP;
    1394:	d0 93 31 08 	sts	0x0831, r29
    1398:	c0 93 30 08 	sts	0x0830, r28
    139c:	10 c0       	rjmp	.+32     	; 0x13be <__vector_6+0x76>
		}
		else
		{
			CalculateSignalLength2 (RXChannel_AIL);
    139e:	80 e0       	ldi	r24, 0x00	; 0
    13a0:	0e 94 e9 23 	call	0x47d2	; 0x47d2 <CalculateSignalLength2>
			
			RX2_LastValidSignal_timestampAux = TCNT1_X;
    13a4:	80 91 74 06 	lds	r24, 0x0674
    13a8:	90 91 75 06 	lds	r25, 0x0675
    13ac:	90 93 18 08 	sts	0x0818, r25
    13b0:	80 93 17 08 	sts	0x0817, r24
			RX_Good = TX2_FOUND_ERR;  // CLR bit 6 ---  Status = OK
    13b4:	80 91 ff 07 	lds	r24, 0x07FF
    13b8:	8f 71       	andi	r24, 0x1F	; 31
    13ba:	80 93 ff 07 	sts	0x07FF, r24
		}	
	}
	// if there is a signal change in PITCH
	if ((Changes & RX2_PITCH_PIN)!=0)
    13be:	00 ff       	sbrs	r16, 0
    13c0:	0b c0       	rjmp	.+22     	; 0x13d8 <__vector_6+0x90>
	{
		if (RX2_PITCH)
    13c2:	86 b1       	in	r24, 0x06	; 6
    13c4:	80 ff       	sbrs	r24, 0
    13c6:	05 c0       	rjmp	.+10     	; 0x13d2 <__vector_6+0x8a>
		{
			RX_raw[1][RXChannel_ELE]=TCNT1_TEMP;
    13c8:	d0 93 33 08 	sts	0x0833, r29
    13cc:	c0 93 32 08 	sts	0x0832, r28
    13d0:	03 c0       	rjmp	.+6      	; 0x13d8 <__vector_6+0x90>
		}
		else
		{
			CalculateSignalLength2 (RXChannel_ELE);
    13d2:	81 e0       	ldi	r24, 0x01	; 1
    13d4:	0e 94 e9 23 	call	0x47d2	; 0x47d2 <CalculateSignalLength2>
		}	
	}
	// if there is a signal change in THR
	if ((Changes & RX2_COLL_PIN)!=0)
    13d8:	17 ff       	sbrs	r17, 7
    13da:	2d c0       	rjmp	.+90     	; 0x1436 <__vector_6+0xee>
    13dc:	80 91 f3 06 	lds	r24, 0x06F3
	{
		if (RX2_COLL)
    13e0:	37 9b       	sbis	0x06, 7	; 6
    13e2:	0b c0       	rjmp	.+22     	; 0x13fa <__vector_6+0xb2>
		{
			RX_raw[1][RXChannel_THR]=TCNT1_TEMP;
    13e4:	d0 93 37 08 	sts	0x0837, r29
    13e8:	c0 93 36 08 	sts	0x0836, r28
			
			if (Config.IsESCCalibration==ESCCalibration_ON)
    13ec:	81 30       	cpi	r24, 0x01	; 1
    13ee:	19 f5       	brne	.+70     	; 0x1436 <__vector_6+0xee>
			{ 
				M1=1;M2=1;M3=1;M4=1;
    13f0:	46 9a       	sbi	0x08, 6	; 8
    13f2:	44 9a       	sbi	0x08, 4	; 8
    13f4:	42 9a       	sbi	0x08, 2	; 8
    13f6:	43 9a       	sbi	0x08, 3	; 8
    13f8:	1e c0       	rjmp	.+60     	; 0x1436 <__vector_6+0xee>
			}
		}
		else
		{
			if ((Config.IsESCCalibration==ESCCalibration_ON) && (IS_TX2_GOOD) && (!IS_SYS_ACT_DISARM))
    13fa:	81 30       	cpi	r24, 0x01	; 1
    13fc:	61 f4       	brne	.+24     	; 0x1416 <__vector_6+0xce>
    13fe:	80 91 ff 07 	lds	r24, 0x07FF
    1402:	80 7f       	andi	r24, 0xF0	; 240
    1404:	41 f4       	brne	.+16     	; 0x1416 <__vector_6+0xce>
    1406:	80 91 51 05 	lds	r24, 0x0551
    140a:	81 fd       	sbrc	r24, 1
    140c:	04 c0       	rjmp	.+8      	; 0x1416 <__vector_6+0xce>
			{
				M1=0;M2=0;M3=0;M4=0;
    140e:	46 98       	cbi	0x08, 6	; 8
    1410:	44 98       	cbi	0x08, 4	; 8
    1412:	42 98       	cbi	0x08, 2	; 8
    1414:	43 98       	cbi	0x08, 3	; 8
			}
				
			CalculateSignalLength2 (RXChannel_THR);
    1416:	83 e0       	ldi	r24, 0x03	; 3
    1418:	0e 94 e9 23 	call	0x47d2	; 0x47d2 <CalculateSignalLength2>
			RX2_LastValidSignal_timestamp = TCNT1_X;
    141c:	80 91 74 06 	lds	r24, 0x0674
    1420:	90 91 75 06 	lds	r25, 0x0675
    1424:	90 93 1c 08 	sts	0x081C, r25
    1428:	80 93 1b 08 	sts	0x081B, r24
			RX_Good = TX2_CONNECTED_ERR;  // CLR bit 5 ---  Status = OK
    142c:	80 91 ff 07 	lds	r24, 0x07FF
    1430:	8f 72       	andi	r24, 0x2F	; 47
    1432:	80 93 ff 07 	sts	0x07FF, r24
		}	
	}
	// if there is a signal change in YAW
	if ((Changes & RX2_YAW_PIN) !=0)
    1436:	01 ff       	sbrs	r16, 1
    1438:	0b c0       	rjmp	.+22     	; 0x1450 <__vector_6+0x108>
	{
		if (RX2_YAW)
    143a:	86 b1       	in	r24, 0x06	; 6
    143c:	81 ff       	sbrs	r24, 1
    143e:	05 c0       	rjmp	.+10     	; 0x144a <__vector_6+0x102>
		{
			RX_raw[1][RXChannel_RUD]=TCNT1_TEMP;
    1440:	d0 93 35 08 	sts	0x0835, r29
    1444:	c0 93 34 08 	sts	0x0834, r28
    1448:	03 c0       	rjmp	.+6      	; 0x1450 <__vector_6+0x108>
		}
		else
		{
			CalculateSignalLength2 (RXChannel_RUD);
    144a:	82 e0       	ldi	r24, 0x02	; 2
    144c:	0e 94 e9 23 	call	0x47d2	; 0x47d2 <CalculateSignalLength2>
			
		}	
	}
	
}
    1450:	ff 91       	pop	r31
    1452:	ef 91       	pop	r30
    1454:	df 91       	pop	r29
    1456:	cf 91       	pop	r28
    1458:	bf 91       	pop	r27
    145a:	af 91       	pop	r26
    145c:	9f 91       	pop	r25
    145e:	8f 91       	pop	r24
    1460:	7f 91       	pop	r23
    1462:	6f 91       	pop	r22
    1464:	5f 91       	pop	r21
    1466:	4f 91       	pop	r20
    1468:	3f 91       	pop	r19
    146a:	2f 91       	pop	r18
    146c:	1f 91       	pop	r17
    146e:	0f 91       	pop	r16
    1470:	0f 90       	pop	r0
    1472:	0f be       	out	0x3f, r0	; 63
    1474:	0f 90       	pop	r0
    1476:	1f 90       	pop	r1
    1478:	18 95       	reti

0000147a <__vector_2>:

#ifdef PRIMARY_INPUT_RX

__attribute__ ((section(".lowtext")))
ISR (RX1_COLL_vect)
{
    147a:	1f 92       	push	r1
    147c:	0f 92       	push	r0
    147e:	0f b6       	in	r0, 0x3f	; 63
    1480:	0f 92       	push	r0
    1482:	11 24       	eor	r1, r1
    1484:	2f 93       	push	r18
    1486:	3f 93       	push	r19
    1488:	4f 93       	push	r20
    148a:	5f 93       	push	r21
    148c:	6f 93       	push	r22
    148e:	7f 93       	push	r23
    1490:	8f 93       	push	r24
    1492:	9f 93       	push	r25
    1494:	af 93       	push	r26
    1496:	bf 93       	push	r27
    1498:	ef 93       	push	r30
    149a:	ff 93       	push	r31
	if (RX1_COLL)
    149c:	89 b1       	in	r24, 0x09	; 9
    149e:	83 ff       	sbrs	r24, 3
    14a0:	09 c0       	rjmp	.+18     	; 0x14b4 <__vector_2+0x3a>
	{
		RX_raw[0][RXChannel_THR]=TCNT1;
    14a2:	80 91 84 00 	lds	r24, 0x0084
    14a6:	90 91 85 00 	lds	r25, 0x0085
    14aa:	90 93 2d 08 	sts	0x082D, r25
    14ae:	80 93 2c 08 	sts	0x082C, r24
    14b2:	10 c0       	rjmp	.+32     	; 0x14d4 <__vector_2+0x5a>

	}
	else
	{
		CalculateSignalLength1(RXChannel_THR);
    14b4:	83 e0       	ldi	r24, 0x03	; 3
    14b6:	0e 94 c0 23 	call	0x4780	; 0x4780 <CalculateSignalLength1>
		
		RX1_LastValidSignal_timestamp = TCNT1_X;
    14ba:	80 91 74 06 	lds	r24, 0x0674
    14be:	90 91 75 06 	lds	r25, 0x0675
    14c2:	90 93 1e 08 	sts	0x081E, r25
    14c6:	80 93 1d 08 	sts	0x081D, r24
		RX_Good = TX1_CONNECTED_ERR;		// CLR bit 0 ---  Status = OK
    14ca:	80 91 ff 07 	lds	r24, 0x07FF
    14ce:	82 7f       	andi	r24, 0xF2	; 242
    14d0:	80 93 ff 07 	sts	0x07FF, r24
	}
	
}
    14d4:	ff 91       	pop	r31
    14d6:	ef 91       	pop	r30
    14d8:	bf 91       	pop	r27
    14da:	af 91       	pop	r26
    14dc:	9f 91       	pop	r25
    14de:	8f 91       	pop	r24
    14e0:	7f 91       	pop	r23
    14e2:	6f 91       	pop	r22
    14e4:	5f 91       	pop	r21
    14e6:	4f 91       	pop	r20
    14e8:	3f 91       	pop	r19
    14ea:	2f 91       	pop	r18
    14ec:	0f 90       	pop	r0
    14ee:	0f be       	out	0x3f, r0	; 63
    14f0:	0f 90       	pop	r0
    14f2:	1f 90       	pop	r1
    14f4:	18 95       	reti

000014f6 <__vector_1>:



__attribute__ ((section(".lowtext")))
ISR (RX1_ROLL_vect)
{
    14f6:	1f 92       	push	r1
    14f8:	0f 92       	push	r0
    14fa:	0f b6       	in	r0, 0x3f	; 63
    14fc:	0f 92       	push	r0
    14fe:	11 24       	eor	r1, r1
    1500:	2f 93       	push	r18
    1502:	3f 93       	push	r19
    1504:	4f 93       	push	r20
    1506:	5f 93       	push	r21
    1508:	6f 93       	push	r22
    150a:	7f 93       	push	r23
    150c:	8f 93       	push	r24
    150e:	9f 93       	push	r25
    1510:	af 93       	push	r26
    1512:	bf 93       	push	r27
    1514:	ef 93       	push	r30
    1516:	ff 93       	push	r31
	if (RX1_ROLL)
    1518:	89 b1       	in	r24, 0x09	; 9
    151a:	82 ff       	sbrs	r24, 2
    151c:	09 c0       	rjmp	.+18     	; 0x1530 <__vector_1+0x3a>
	{
		RX_raw[0][RXChannel_AIL]=TCNT1;
    151e:	80 91 84 00 	lds	r24, 0x0084
    1522:	90 91 85 00 	lds	r25, 0x0085
    1526:	90 93 27 08 	sts	0x0827, r25
    152a:	80 93 26 08 	sts	0x0826, r24
    152e:	10 c0       	rjmp	.+32     	; 0x1550 <__vector_1+0x5a>
	}
	else
	{
		CalculateSignalLength1(RXChannel_AIL);
    1530:	80 e0       	ldi	r24, 0x00	; 0
    1532:	0e 94 c0 23 	call	0x4780	; 0x4780 <CalculateSignalLength1>
		
		RX1_LastValidSignal_timestampAux = TCNT1_X;
    1536:	80 91 74 06 	lds	r24, 0x0674
    153a:	90 91 75 06 	lds	r25, 0x0675
    153e:	90 93 20 08 	sts	0x0820, r25
    1542:	80 93 1f 08 	sts	0x081F, r24
		RX_Good = TX1_FOUND_ERR;			// CLR bit 1 ---  Status = OK
    1546:	80 91 ff 07 	lds	r24, 0x07FF
    154a:	81 7f       	andi	r24, 0xF1	; 241
    154c:	80 93 ff 07 	sts	0x07FF, r24

		
	}
	
}
    1550:	ff 91       	pop	r31
    1552:	ef 91       	pop	r30
    1554:	bf 91       	pop	r27
    1556:	af 91       	pop	r26
    1558:	9f 91       	pop	r25
    155a:	8f 91       	pop	r24
    155c:	7f 91       	pop	r23
    155e:	6f 91       	pop	r22
    1560:	5f 91       	pop	r21
    1562:	4f 91       	pop	r20
    1564:	3f 91       	pop	r19
    1566:	2f 91       	pop	r18
    1568:	0f 90       	pop	r0
    156a:	0f be       	out	0x3f, r0	; 63
    156c:	0f 90       	pop	r0
    156e:	1f 90       	pop	r1
    1570:	18 95       	reti

00001572 <__vector_7>:


__attribute__ ((section(".lowtext")))
ISR (RX1_PITCH_vect)
{
    1572:	1f 92       	push	r1
    1574:	0f 92       	push	r0
    1576:	0f b6       	in	r0, 0x3f	; 63
    1578:	0f 92       	push	r0
    157a:	11 24       	eor	r1, r1
    157c:	2f 93       	push	r18
    157e:	3f 93       	push	r19
    1580:	4f 93       	push	r20
    1582:	5f 93       	push	r21
    1584:	6f 93       	push	r22
    1586:	7f 93       	push	r23
    1588:	8f 93       	push	r24
    158a:	9f 93       	push	r25
    158c:	af 93       	push	r26
    158e:	bf 93       	push	r27
    1590:	ef 93       	push	r30
    1592:	ff 93       	push	r31
	if (RX1_PITCH)
    1594:	89 b1       	in	r24, 0x09	; 9
    1596:	80 ff       	sbrs	r24, 0
    1598:	09 c0       	rjmp	.+18     	; 0x15ac <__vector_7+0x3a>
	{
		RX_raw[0][RXChannel_ELE]=TCNT1;
    159a:	80 91 84 00 	lds	r24, 0x0084
    159e:	90 91 85 00 	lds	r25, 0x0085
    15a2:	90 93 29 08 	sts	0x0829, r25
    15a6:	80 93 28 08 	sts	0x0828, r24
    15aa:	03 c0       	rjmp	.+6      	; 0x15b2 <__vector_7+0x40>
	}
	else
	{
		CalculateSignalLength1(RXChannel_ELE);
    15ac:	81 e0       	ldi	r24, 0x01	; 1
    15ae:	0e 94 c0 23 	call	0x4780	; 0x4780 <CalculateSignalLength1>
	}
}
    15b2:	ff 91       	pop	r31
    15b4:	ef 91       	pop	r30
    15b6:	bf 91       	pop	r27
    15b8:	af 91       	pop	r26
    15ba:	9f 91       	pop	r25
    15bc:	8f 91       	pop	r24
    15be:	7f 91       	pop	r23
    15c0:	6f 91       	pop	r22
    15c2:	5f 91       	pop	r21
    15c4:	4f 91       	pop	r20
    15c6:	3f 91       	pop	r19
    15c8:	2f 91       	pop	r18
    15ca:	0f 90       	pop	r0
    15cc:	0f be       	out	0x3f, r0	; 63
    15ce:	0f 90       	pop	r0
    15d0:	1f 90       	pop	r1
    15d2:	18 95       	reti

000015d4 <__vector_3>:

volatile uint16_t LongTime;
volatile uint16_t ShortTime;
__attribute__ ((section(".lowtext")))
ISR (RX1_YAW_vect)
{   
    15d4:	1f 92       	push	r1
    15d6:	0f 92       	push	r0
    15d8:	0f b6       	in	r0, 0x3f	; 63
    15da:	0f 92       	push	r0
    15dc:	11 24       	eor	r1, r1
    15de:	2f 93       	push	r18
    15e0:	3f 93       	push	r19
    15e2:	4f 93       	push	r20
    15e4:	5f 93       	push	r21
    15e6:	6f 93       	push	r22
    15e8:	7f 93       	push	r23
    15ea:	8f 93       	push	r24
    15ec:	9f 93       	push	r25
    15ee:	af 93       	push	r26
    15f0:	bf 93       	push	r27
    15f2:	ef 93       	push	r30
    15f4:	ff 93       	push	r31
	// SONAR IS HERE IN UART MODE
	// SONAR RAW VALUE = RX_Length[0][RXChannel_RUD]
	if ((Config.RX_mode==RX_mode_UARTMode) && (IS_MISC_SENSOR_SONAR_ENABLED==true))
    15f6:	80 91 ef 06 	lds	r24, 0x06EF
    15fa:	8f 3f       	cpi	r24, 0xFF	; 255
    15fc:	f9 f4       	brne	.+62     	; 0x163c <__vector_3+0x68>
    15fe:	80 91 fa 06 	lds	r24, 0x06FA
    1602:	80 ff       	sbrs	r24, 0
    1604:	1b c0       	rjmp	.+54     	; 0x163c <__vector_3+0x68>
	{
		if (RX1_YAW)
    1606:	83 b1       	in	r24, 0x03	; 3
    1608:	82 ff       	sbrs	r24, 2
    160a:	09 c0       	rjmp	.+18     	; 0x161e <__vector_3+0x4a>
		{
			//ShortTime = TCNT1;
			LongTime = TCNT0_X;
    160c:	80 91 bc 05 	lds	r24, 0x05BC
    1610:	90 91 bd 05 	lds	r25, 0x05BD
    1614:	90 93 25 08 	sts	0x0825, r25
    1618:	80 93 24 08 	sts	0x0824, r24
    161c:	1e c0       	rjmp	.+60     	; 0x165a <__vector_3+0x86>
		}
		else
		{
			RX_Length[0][RXChannel_RUD] = (TCNT0_X - LongTime) ; // * SONAR_TO_cm_Convert_BIG + (TCNT1 - ShortTime) * SONAR_TO_cm_Convert;
    161e:	80 91 bc 05 	lds	r24, 0x05BC
    1622:	90 91 bd 05 	lds	r25, 0x05BD
    1626:	20 91 24 08 	lds	r18, 0x0824
    162a:	30 91 25 08 	lds	r19, 0x0825
    162e:	82 1b       	sub	r24, r18
    1630:	93 0b       	sbc	r25, r19
    1632:	90 93 d5 05 	sts	0x05D5, r25
    1636:	80 93 d4 05 	sts	0x05D4, r24
    163a:	0f c0       	rjmp	.+30     	; 0x165a <__vector_3+0x86>

	}
	else
	{
		
		if (RX1_YAW)
    163c:	83 b1       	in	r24, 0x03	; 3
    163e:	82 ff       	sbrs	r24, 2
    1640:	09 c0       	rjmp	.+18     	; 0x1654 <__vector_3+0x80>
		{
			RX_raw[0][RXChannel_RUD]=TCNT1;
    1642:	80 91 84 00 	lds	r24, 0x0084
    1646:	90 91 85 00 	lds	r25, 0x0085
    164a:	90 93 2b 08 	sts	0x082B, r25
    164e:	80 93 2a 08 	sts	0x082A, r24
    1652:	03 c0       	rjmp	.+6      	; 0x165a <__vector_3+0x86>
		}
		else
		{
			CalculateSignalLength1(RXChannel_RUD);
    1654:	82 e0       	ldi	r24, 0x02	; 2
    1656:	0e 94 c0 23 	call	0x4780	; 0x4780 <CalculateSignalLength1>
		}
	}	
}
    165a:	ff 91       	pop	r31
    165c:	ef 91       	pop	r30
    165e:	bf 91       	pop	r27
    1660:	af 91       	pop	r26
    1662:	9f 91       	pop	r25
    1664:	8f 91       	pop	r24
    1666:	7f 91       	pop	r23
    1668:	6f 91       	pop	r22
    166a:	5f 91       	pop	r21
    166c:	4f 91       	pop	r20
    166e:	3f 91       	pop	r19
    1670:	2f 91       	pop	r18
    1672:	0f 90       	pop	r0
    1674:	0f be       	out	0x3f, r0	; 63
    1676:	0f 90       	pop	r0
    1678:	1f 90       	pop	r1
    167a:	18 95       	reti

0000167c <__vector_5>:



__attribute__ ((section(".lowtext")))
ISR (RX_AUX_vect)
{
    167c:	1f 92       	push	r1
    167e:	0f 92       	push	r0
    1680:	0f b6       	in	r0, 0x3f	; 63
    1682:	0f 92       	push	r0
    1684:	11 24       	eor	r1, r1
    1686:	2f 93       	push	r18
    1688:	3f 93       	push	r19
    168a:	4f 93       	push	r20
    168c:	5f 93       	push	r21
    168e:	6f 93       	push	r22
    1690:	7f 93       	push	r23
    1692:	8f 93       	push	r24
    1694:	9f 93       	push	r25
    1696:	af 93       	push	r26
    1698:	bf 93       	push	r27
    169a:	ef 93       	push	r30
    169c:	ff 93       	push	r31
	// There is only ONE AUX PORT - usually assigned to Secondary RX 
	if (RX_AUX)
    169e:	83 b1       	in	r24, 0x03	; 3
    16a0:	80 ff       	sbrs	r24, 0
    16a2:	0c c0       	rjmp	.+24     	; 0x16bc <__vector_5+0x40>
	{
		RX_raw[1][RXChannel_AUX]=TCNT1;
    16a4:	80 91 84 00 	lds	r24, 0x0084
    16a8:	90 91 85 00 	lds	r25, 0x0085
    16ac:	90 93 39 08 	sts	0x0839, r25
    16b0:	80 93 38 08 	sts	0x0838, r24
		UpdateServo=true;
    16b4:	81 e0       	ldi	r24, 0x01	; 1
    16b6:	80 93 e8 06 	sts	0x06E8, r24
    16ba:	0b c0       	rjmp	.+22     	; 0x16d2 <__vector_5+0x56>
	}
	else
	{
		CalculateSignalLength2(RXChannel_AUX);
    16bc:	84 e0       	ldi	r24, 0x04	; 4
    16be:	0e 94 e9 23 	call	0x47d2	; 0x47d2 <CalculateSignalLength2>
		RX_Length[0][RXChannel_AUX]=RX_Length[1][RXChannel_AUX];
    16c2:	80 91 e2 05 	lds	r24, 0x05E2
    16c6:	90 91 e3 05 	lds	r25, 0x05E3
    16ca:	90 93 d9 05 	sts	0x05D9, r25
    16ce:	80 93 d8 05 	sts	0x05D8, r24
	}

}
    16d2:	ff 91       	pop	r31
    16d4:	ef 91       	pop	r30
    16d6:	bf 91       	pop	r27
    16d8:	af 91       	pop	r26
    16da:	9f 91       	pop	r25
    16dc:	8f 91       	pop	r24
    16de:	7f 91       	pop	r23
    16e0:	6f 91       	pop	r22
    16e2:	5f 91       	pop	r21
    16e4:	4f 91       	pop	r20
    16e6:	3f 91       	pop	r19
    16e8:	2f 91       	pop	r18
    16ea:	0f 90       	pop	r0
    16ec:	0f be       	out	0x3f, r0	; 63
    16ee:	0f 90       	pop	r0
    16f0:	1f 90       	pop	r1
    16f2:	18 95       	reti

000016f4 <__ctors_end>:
    16f4:	11 24       	eor	r1, r1
    16f6:	1f be       	out	0x3f, r1	; 63
    16f8:	cf ef       	ldi	r28, 0xFF	; 255
    16fa:	d8 e0       	ldi	r29, 0x08	; 8
    16fc:	de bf       	out	0x3e, r29	; 62
    16fe:	cd bf       	out	0x3d, r28	; 61

00001700 <__do_copy_data>:
    1700:	11 e0       	ldi	r17, 0x01	; 1
    1702:	a0 e0       	ldi	r26, 0x00	; 0
    1704:	b1 e0       	ldi	r27, 0x01	; 1
    1706:	e2 e4       	ldi	r30, 0x42	; 66
    1708:	f7 e7       	ldi	r31, 0x77	; 119
    170a:	02 c0       	rjmp	.+4      	; 0x1710 <__do_copy_data+0x10>
    170c:	05 90       	lpm	r0, Z+
    170e:	0d 92       	st	X+, r0
    1710:	a2 32       	cpi	r26, 0x22	; 34
    1712:	b1 07       	cpc	r27, r17
    1714:	d9 f7       	brne	.-10     	; 0x170c <__do_copy_data+0xc>

00001716 <__do_clear_bss>:
    1716:	18 e0       	ldi	r17, 0x08	; 8
    1718:	a2 e2       	ldi	r26, 0x22	; 34
    171a:	b1 e0       	ldi	r27, 0x01	; 1
    171c:	01 c0       	rjmp	.+2      	; 0x1720 <.do_clear_bss_start>

0000171e <.do_clear_bss_loop>:
    171e:	1d 92       	st	X+, r1

00001720 <.do_clear_bss_start>:
    1720:	ab 34       	cpi	r26, 0x4B	; 75
    1722:	b1 07       	cpc	r27, r17
    1724:	e1 f7       	brne	.-8      	; 0x171e <.do_clear_bss_loop>
    1726:	0e 94 b8 18 	call	0x3170	; 0x3170 <main>
    172a:	0c 94 9f 3b 	jmp	0x773e	; 0x773e <_exit>

0000172e <__bad_interrupt>:
    172e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00001732 <Beeper_Beep>:
#include "../Include/Misc.h"
#include "../Include/IO_config.h"


void Beeper_Beep (uint16_t msDuration, uint8_t Times)
{
    1732:	ef 92       	push	r14
    1734:	ff 92       	push	r15
    1736:	0f 93       	push	r16
    1738:	1f 93       	push	r17
    173a:	cf 93       	push	r28
    173c:	df 93       	push	r29
    173e:	ec 01       	movw	r28, r24
	
	//bool CurrentBuzzer_Status = Buzzer;
	
	for (int i=0; i< Times; ++i)
    1740:	00 e0       	ldi	r16, 0x00	; 0
    1742:	10 e0       	ldi	r17, 0x00	; 0
    1744:	e6 2e       	mov	r14, r22
    1746:	ff 24       	eor	r15, r15
    1748:	0a c0       	rjmp	.+20     	; 0x175e <Beeper_Beep+0x2c>
	{
		Buzzer = ON;
    174a:	29 9a       	sbi	0x05, 1	; 5
		delay_ms(msDuration);
    174c:	ce 01       	movw	r24, r28
    174e:	0e 94 fd 0e 	call	0x1dfa	; 0x1dfa <delay_ms>
		Buzzer = OFF;
    1752:	29 98       	cbi	0x05, 1	; 5
		delay_ms(msDuration);		
    1754:	ce 01       	movw	r24, r28
    1756:	0e 94 fd 0e 	call	0x1dfa	; 0x1dfa <delay_ms>
void Beeper_Beep (uint16_t msDuration, uint8_t Times)
{
	
	//bool CurrentBuzzer_Status = Buzzer;
	
	for (int i=0; i< Times; ++i)
    175a:	0f 5f       	subi	r16, 0xFF	; 255
    175c:	1f 4f       	sbci	r17, 0xFF	; 255
    175e:	0e 15       	cp	r16, r14
    1760:	1f 05       	cpc	r17, r15
    1762:	9c f3       	brlt	.-26     	; 0x174a <Beeper_Beep+0x18>
		delay_ms(msDuration);		
	}
	
	//Buzzer = CurrentBuzzer_Status;
	
}
    1764:	df 91       	pop	r29
    1766:	cf 91       	pop	r28
    1768:	1f 91       	pop	r17
    176a:	0f 91       	pop	r16
    176c:	ff 90       	pop	r15
    176e:	ef 90       	pop	r14
    1770:	08 95       	ret

00001772 <KeyBoard_Init>:

void KeyBoard_Init (void)
{

	// key pins to input
	KEYBOARD_DDR |= ALLKEYS;
    1772:	84 b1       	in	r24, 0x04	; 4
    1774:	80 6f       	ori	r24, 0xF0	; 240
    1776:	84 b9       	out	0x04, r24	; 4

	
	// pull up resistors on
	KEYBOARD_PORT |= ALLKEYS;
    1778:	85 b1       	in	r24, 0x05	; 5
    177a:	80 6f       	ori	r24, 0xF0	; 240
    177c:	85 b9       	out	0x05, r24	; 5
	
}
    177e:	08 95       	ret

00001780 <Keyboard_Read>:

uint16_t TCNT_X_snapshot3=0;
uint8_t Keyboard_Read()
{
    1780:	0f 93       	push	r16
    1782:	1f 93       	push	r17
	uint8_t keys = ~KEYBOARD_PIN & ALLKEYS;
    1784:	13 b1       	in	r17, 0x03	; 3
    1786:	10 95       	com	r17
    1788:	10 7f       	andi	r17, 0xF0	; 240
	uint8_t newkeys = keys & ~lastKeys; // always equal to ZERO  for repeated buttons.
    178a:	00 91 c1 05 	lds	r16, 0x05C1
	_keyrepeat = KEYBOARD_NO_REPEAT;
    178e:	10 92 cf 05 	sts	0x05CF, r1
	if (keys !=0) // if any key pressed even repeated.
    1792:	11 23       	and	r17, r17
    1794:	21 f1       	breq	.+72     	; 0x17de <Keyboard_Read+0x5e>
	{
		if (IsArmed==true) Disarm(); // this is for your own safety.
    1796:	80 91 cc 07 	lds	r24, 0x07CC
    179a:	81 30       	cpi	r24, 0x01	; 1
    179c:	11 f4       	brne	.+4      	; 0x17a2 <Keyboard_Read+0x22>
    179e:	0e 94 1a 0f 	call	0x1e34	; 0x1e34 <Disarm>
		
		if ((lastKeys!=keys))
    17a2:	80 91 c1 05 	lds	r24, 0x05C1
    17a6:	81 17       	cp	r24, r17
    17a8:	59 f0       	breq	.+22     	; 0x17c0 <Keyboard_Read+0x40>
		{	// Reset Timer if not the same key.
			TCNT_X_snapshot3 = TCNT1_X+300;
    17aa:	80 91 74 06 	lds	r24, 0x0674
    17ae:	90 91 75 06 	lds	r25, 0x0675
    17b2:	84 5d       	subi	r24, 0xD4	; 212
    17b4:	9e 4f       	sbci	r25, 0xFE	; 254
    17b6:	90 93 23 01 	sts	0x0123, r25
    17ba:	80 93 22 01 	sts	0x0122, r24
    17be:	0f c0       	rjmp	.+30     	; 0x17de <Keyboard_Read+0x5e>
		}
		else
		{	// Count to measure the key press duration.
			if ((TCNT_X_snapshot3 < TCNT1_X)) // some racing condition might happen here but not a problem we  dont need an atomic read for UI btn click.
    17c0:	20 91 74 06 	lds	r18, 0x0674
    17c4:	30 91 75 06 	lds	r19, 0x0675
    17c8:	40 91 22 01 	lds	r20, 0x0122
    17cc:	50 91 23 01 	lds	r21, 0x0123
    17d0:	42 17       	cp	r20, r18
    17d2:	53 07       	cpc	r21, r19
    17d4:	20 f4       	brcc	.+8      	; 0x17de <Keyboard_Read+0x5e>
			{
				_keyrepeat = KEYBOARD_REPEAT;
    17d6:	91 e0       	ldi	r25, 0x01	; 1
    17d8:	90 93 cf 05 	sts	0x05CF, r25
				return keys; // re-press keys and set the repeated flag for more GUI handling.
    17dc:	05 c0       	rjmp	.+10     	; 0x17e8 <Keyboard_Read+0x68>

uint16_t TCNT_X_snapshot3=0;
uint8_t Keyboard_Read()
{
	uint8_t keys = ~KEYBOARD_PIN & ALLKEYS;
	uint8_t newkeys = keys & ~lastKeys; // always equal to ZERO  for repeated buttons.
    17de:	80 2f       	mov	r24, r16
    17e0:	80 95       	com	r24
				_keyrepeat = KEYBOARD_REPEAT;
				return keys; // re-press keys and set the repeated flag for more GUI handling.
			}
		}
	}	
	lastKeys = keys;
    17e2:	10 93 c1 05 	sts	0x05C1, r17
	return newkeys;
    17e6:	81 23       	and	r24, r17
}
    17e8:	1f 91       	pop	r17
    17ea:	0f 91       	pop	r16
    17ec:	08 95       	ret

000017ee <Keyboard_State>:


inline uint8_t Keyboard_State()
{
	return lastKeys;
}
    17ee:	80 91 c1 05 	lds	r24, 0x05C1
    17f2:	08 95       	ret

000017f4 <sendData>:
	//LCD_CS = 1;
//}

static void sendData(uint8_t data, uint8_t CommandorData)
{
	LCD_CS = 0;
    17f4:	5d 98       	cbi	0x0b, 5	; 11
	LCD_A0 = CommandorData;
    17f6:	67 95       	ror	r22
    17f8:	66 27       	eor	r22, r22
    17fa:	67 95       	ror	r22
    17fc:	9b b1       	in	r25, 0x0b	; 11
    17fe:	9f 77       	andi	r25, 0x7F	; 127
    1800:	96 2b       	or	r25, r22
    1802:	9b b9       	out	0x0b, r25	; 11
    1804:	98 e0       	ldi	r25, 0x08	; 8

static void sendByte(uint8_t byte)
{
	for (uint8_t i = 8; i; i--)
	{
		LCD_SCL = 0;
    1806:	5c 98       	cbi	0x0b, 4	; 11
		
		if (byte & 0x80) // read MSB [& b10000000]
    1808:	87 ff       	sbrs	r24, 7
    180a:	02 c0       	rjmp	.+4      	; 0x1810 <sendData+0x1c>
			LCD_SDA = 1;
    180c:	59 9a       	sbi	0x0b, 1	; 11
    180e:	01 c0       	rjmp	.+2      	; 0x1812 <sendData+0x1e>
		else
			LCD_SDA = 0;
    1810:	59 98       	cbi	0x0b, 1	; 11
		
		LCD_SCL = 1;
    1812:	5c 9a       	sbi	0x0b, 4	; 11
    1814:	91 50       	subi	r25, 0x01	; 1
static uint8_t _curx, _cury;
static fontdescriptor_t _font;

static void sendByte(uint8_t byte)
{
	for (uint8_t i = 8; i; i--)
    1816:	11 f0       	breq	.+4      	; 0x181c <sendData+0x28>
			LCD_SDA = 1;
		else
			LCD_SDA = 0;
		
		LCD_SCL = 1;
		byte <<= 1;
    1818:	88 0f       	add	r24, r24
    181a:	f5 cf       	rjmp	.-22     	; 0x1806 <sendData+0x12>
static void sendData(uint8_t data, uint8_t CommandorData)
{
	LCD_CS = 0;
	LCD_A0 = CommandorData;
	sendByte(data);
	LCD_CS = 1;
    181c:	5d 9a       	sbi	0x0b, 5	; 11
}
    181e:	08 95       	ret

00001820 <LCD_SetPos>:
	offset %= sizeof(_screen);
}

void LCD_SetPos(uint8_t line, uint8_t column)
{
	_curx = column % LCDWIDTH;
    1820:	6f 77       	andi	r22, 0x7F	; 127
    1822:	60 93 2a 01 	sts	0x012A, r22
	_cury = line * 8;
    1826:	88 0f       	add	r24, r24
    1828:	88 0f       	add	r24, r24
    182a:	88 0f       	add	r24, r24
    182c:	80 93 29 01 	sts	0x0129, r24
}
    1830:	08 95       	ret

00001832 <lcdXY>:

void lcdXY(uint8_t x, uint8_t y)
{
	_curx = x;
    1832:	80 93 2a 01 	sts	0x012A, r24
	_cury = y;
    1836:	60 93 29 01 	sts	0x0129, r22
}
    183a:	08 95       	ret

0000183c <lcdSetPixel>:

void lcdSetPixel(uint8_t x, uint8_t y, uint8_t on)
{
	static const prog_char masks[8] = {0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80};
	uint8_t *scr = _screen + x + (y / 8 * LCDWIDTH); 
    183c:	26 2f       	mov	r18, r22
    183e:	26 95       	lsr	r18
    1840:	26 95       	lsr	r18
    1842:	26 95       	lsr	r18
    1844:	30 e0       	ldi	r19, 0x00	; 0
    1846:	36 95       	lsr	r19
    1848:	32 2f       	mov	r19, r18
    184a:	22 27       	eor	r18, r18
    184c:	37 95       	ror	r19
    184e:	27 95       	ror	r18
    1850:	28 0f       	add	r18, r24
    1852:	31 1d       	adc	r19, r1
	uint8_t mask = pgm_read_byte(&masks[y % 8]);
    1854:	e6 2f       	mov	r30, r22
    1856:	f0 e0       	ldi	r31, 0x00	; 0
    1858:	e7 70       	andi	r30, 0x07	; 7
    185a:	f0 70       	andi	r31, 0x00	; 0
    185c:	e8 57       	subi	r30, 0x78	; 120
    185e:	ff 4f       	sbci	r31, 0xFF	; 255
    1860:	e4 91       	lpm	r30, Z+
	if ((_flags & REVERSED) ^ !on)
    1862:	91 e0       	ldi	r25, 0x01	; 1
    1864:	41 11       	cpse	r20, r1
    1866:	90 e0       	ldi	r25, 0x00	; 0
    1868:	80 91 28 01 	lds	r24, 0x0128
    186c:	81 70       	andi	r24, 0x01	; 1
    186e:	d9 01       	movw	r26, r18
    1870:	a5 5d       	subi	r26, 0xD5	; 213
    1872:	be 4f       	sbci	r27, 0xFE	; 254
    1874:	89 17       	cp	r24, r25
    1876:	29 f0       	breq	.+10     	; 0x1882 <lcdSetPixel+0x46>
		*scr = *scr & ~mask;
    1878:	e0 95       	com	r30
    187a:	8c 91       	ld	r24, X
    187c:	e8 23       	and	r30, r24
    187e:	ec 93       	st	X, r30
    1880:	08 95       	ret
	else
		*scr = *scr | mask;
    1882:	8c 91       	ld	r24, X
    1884:	8e 2b       	or	r24, r30
    1886:	8c 93       	st	X, r24
    1888:	08 95       	ret

0000188a <LCD_Line>:
			////
		////e2 = 2 * err;
		////if (e2 > dy) { err += dy; x0 += sx; } /* e_xy + e_x > 0 */
		////if (e2 < dx) { err += dx; y0 += sy; } /* e_xy + e_y < 0 */
	////}
}
    188a:	08 95       	ret

0000188c <LCD_Rectangle>:
	//for (a = y0; a <= y1; a++)
	//{
		//lcdSetPixel(x0, a, color);
		//lcdSetPixel(x1, a, color);
	//}
}
    188c:	08 95       	ret

0000188e <LCD_FillRectangle>:
	//if (x0 > x1) { a = x0; x0 = x1; x1 = a;}
	//if (y0 > y1) { a = y0; y0 = y1; y1 = a;}
	//for (a = y0; a <= y1; a++)
		//for(uint8_t i = x0; i <= x1; i++)
			//lcdSetPixel(i, a, color);
}
    188e:	08 95       	ret

00001890 <LCD_Clear>:
 
void LCD_Clear()
{
	memset(_screen, 0, sizeof(_screen));
    1890:	80 e0       	ldi	r24, 0x00	; 0
    1892:	94 e0       	ldi	r25, 0x04	; 4
    1894:	eb e2       	ldi	r30, 0x2B	; 43
    1896:	f1 e0       	ldi	r31, 0x01	; 1
    1898:	df 01       	movw	r26, r30
    189a:	9c 01       	movw	r18, r24
    189c:	1d 92       	st	X+, r1
    189e:	21 50       	subi	r18, 0x01	; 1
    18a0:	30 40       	sbci	r19, 0x00	; 0
    18a2:	e1 f7       	brne	.-8      	; 0x189c <LCD_Clear+0xc>
	LCD_SetPos(0, 0);
    18a4:	80 e0       	ldi	r24, 0x00	; 0
    18a6:	60 e0       	ldi	r22, 0x00	; 0
    18a8:	0e 94 10 0c 	call	0x1820	; 0x1820 <LCD_SetPos>
	_flags = 0;
    18ac:	10 92 28 01 	sts	0x0128, r1
}
    18b0:	08 95       	ret

000018b2 <lcdWriteSprite_P>:

void lcdWriteSprite_P(PGM_P sprite, uint8_t sizeX, uint8_t sizeY, uint8_t mode)
{
    18b2:	8f 92       	push	r8
    18b4:	9f 92       	push	r9
    18b6:	bf 92       	push	r11
    18b8:	cf 92       	push	r12
    18ba:	df 92       	push	r13
    18bc:	ef 92       	push	r14
    18be:	ff 92       	push	r15
    18c0:	0f 93       	push	r16
    18c2:	1f 93       	push	r17
    18c4:	df 93       	push	r29
    18c6:	cf 93       	push	r28
    18c8:	0f 92       	push	r0
    18ca:	cd b7       	in	r28, 0x3d	; 61
    18cc:	de b7       	in	r29, 0x3e	; 62
    18ce:	4c 01       	movw	r8, r24
    18d0:	e6 2e       	mov	r14, r22
    18d2:	f4 2e       	mov	r15, r20
    18d4:	c2 2e       	mov	r12, r18
	uint8_t b = 0;
	for (uint8_t i = 0; i < sizeX; i++)
    18d6:	dd 24       	eor	r13, r13
	_flags = 0;
}

void lcdWriteSprite_P(PGM_P sprite, uint8_t sizeX, uint8_t sizeY, uint8_t mode)
{
	uint8_t b = 0;
    18d8:	bb 24       	eor	r11, r11
			if (j % 8 == 0)
					b = pgm_read_byte(sprite++);
					
			if (mode == ROP_COPY)
			{
				if ((_cury % 8 == 0) && (sizeY - j >= 8))
    18da:	04 2f       	mov	r16, r20
    18dc:	10 e0       	ldi	r17, 0x00	; 0
}

void lcdWriteSprite_P(PGM_P sprite, uint8_t sizeX, uint8_t sizeY, uint8_t mode)
{
	uint8_t b = 0;
	for (uint8_t i = 0; i < sizeX; i++)
    18de:	4f c0       	rjmp	.+158    	; 0x197e <lcdWriteSprite_P+0xcc>
	{
		for (uint8_t j = 0; j < sizeY; j++)
		{
			if (j % 8 == 0)
    18e0:	83 2f       	mov	r24, r19
    18e2:	87 70       	andi	r24, 0x07	; 7
    18e4:	29 f4       	brne	.+10     	; 0x18f0 <lcdWriteSprite_P+0x3e>
					b = pgm_read_byte(sprite++);
    18e6:	f4 01       	movw	r30, r8
    18e8:	08 94       	sec
    18ea:	81 1c       	adc	r8, r1
    18ec:	91 1c       	adc	r9, r1
    18ee:	b4 90       	lpm	r11, Z+
					
			if (mode == ROP_COPY)
    18f0:	cc 20       	and	r12, r12
    18f2:	79 f5       	brne	.+94     	; 0x1952 <lcdWriteSprite_P+0xa0>
			{
				if ((_cury % 8 == 0) && (sizeY - j >= 8))
    18f4:	60 91 29 01 	lds	r22, 0x0129
    18f8:	86 2f       	mov	r24, r22
    18fa:	87 70       	andi	r24, 0x07	; 7
    18fc:	19 f5       	brne	.+70     	; 0x1944 <lcdWriteSprite_P+0x92>
    18fe:	c8 01       	movw	r24, r16
    1900:	83 1b       	sub	r24, r19
    1902:	91 09       	sbc	r25, r1
    1904:	88 30       	cpi	r24, 0x08	; 8
    1906:	91 05       	cpc	r25, r1
    1908:	ec f0       	brlt	.+58     	; 0x1944 <lcdWriteSprite_P+0x92>
				{
					lcdSetByte(_curx + i, _cury + j, b);
    190a:	63 0f       	add	r22, r19
		*scr = *scr | mask;
}

static void lcdSetByte(uint8_t x, uint8_t y, uint8_t b)
{
	uint8_t *scr = _screen + x + (y / 8 * LCDWIDTH); 
    190c:	66 95       	lsr	r22
    190e:	66 95       	lsr	r22
    1910:	66 95       	lsr	r22
    1912:	a6 2f       	mov	r26, r22
    1914:	b0 e0       	ldi	r27, 0x00	; 0
    1916:	b6 95       	lsr	r27
    1918:	ba 2f       	mov	r27, r26
    191a:	aa 27       	eor	r26, r26
    191c:	b7 95       	ror	r27
    191e:	a7 95       	ror	r26
					
			if (mode == ROP_COPY)
			{
				if ((_cury % 8 == 0) && (sizeY - j >= 8))
				{
					lcdSetByte(_curx + i, _cury + j, b);
    1920:	80 91 2a 01 	lds	r24, 0x012A
    1924:	8d 0d       	add	r24, r13
		*scr = *scr | mask;
}

static void lcdSetByte(uint8_t x, uint8_t y, uint8_t b)
{
	uint8_t *scr = _screen + x + (y / 8 * LCDWIDTH); 
    1926:	a8 0f       	add	r26, r24
    1928:	b1 1d       	adc	r27, r1
	if (_flags & REVERSED)
    192a:	80 91 28 01 	lds	r24, 0x0128
    192e:	a5 5d       	subi	r26, 0xD5	; 213
    1930:	be 4f       	sbci	r27, 0xFE	; 254
    1932:	80 ff       	sbrs	r24, 0
    1934:	04 c0       	rjmp	.+8      	; 0x193e <lcdWriteSprite_P+0x8c>
		*scr = ~b;
    1936:	8b 2d       	mov	r24, r11
    1938:	80 95       	com	r24
    193a:	8c 93       	st	X, r24
    193c:	01 c0       	rjmp	.+2      	; 0x1940 <lcdWriteSprite_P+0x8e>
	else
		*scr = b;
    193e:	bc 92       	st	X, r11
			if (mode == ROP_COPY)
			{
				if ((_cury % 8 == 0) && (sizeY - j >= 8))
				{
					lcdSetByte(_curx + i, _cury + j, b);
					j += 7; // just +7 b/c the loop increments anyway
    1940:	39 5f       	subi	r19, 0xF9	; 249
    1942:	17 c0       	rjmp	.+46     	; 0x1972 <lcdWriteSprite_P+0xc0>
				}
				else
					lcdSetPixel(_curx + i, _cury + j, b & 0x01);
    1944:	80 91 2a 01 	lds	r24, 0x012A
    1948:	63 0f       	add	r22, r19
    194a:	4b 2d       	mov	r20, r11
    194c:	41 70       	andi	r20, 0x01	; 1
    194e:	8d 0d       	add	r24, r13
    1950:	0c c0       	rjmp	.+24     	; 0x196a <lcdWriteSprite_P+0xb8>
			}				
			else if (mode == ROP_PAINT)
    1952:	8c 2d       	mov	r24, r12
    1954:	81 30       	cpi	r24, 0x01	; 1
    1956:	69 f4       	brne	.+26     	; 0x1972 <lcdWriteSprite_P+0xc0>
			{
				if (b & 0x01)
    1958:	b0 fe       	sbrs	r11, 0
    195a:	0b c0       	rjmp	.+22     	; 0x1972 <lcdWriteSprite_P+0xc0>
					lcdSetPixel(_curx + i, _cury + j, 1);
    195c:	80 91 2a 01 	lds	r24, 0x012A
    1960:	60 91 29 01 	lds	r22, 0x0129
    1964:	63 0f       	add	r22, r19
    1966:	8d 0d       	add	r24, r13
    1968:	41 e0       	ldi	r20, 0x01	; 1
    196a:	39 83       	std	Y+1, r19	; 0x01
    196c:	0e 94 1e 0c 	call	0x183c	; 0x183c <lcdSetPixel>
    1970:	39 81       	ldd	r19, Y+1	; 0x01
			}			
			b >>= 1;
    1972:	b6 94       	lsr	r11
void lcdWriteSprite_P(PGM_P sprite, uint8_t sizeX, uint8_t sizeY, uint8_t mode)
{
	uint8_t b = 0;
	for (uint8_t i = 0; i < sizeX; i++)
	{
		for (uint8_t j = 0; j < sizeY; j++)
    1974:	3f 5f       	subi	r19, 0xFF	; 255
    1976:	3f 15       	cp	r19, r15
    1978:	08 f4       	brcc	.+2      	; 0x197c <lcdWriteSprite_P+0xca>
    197a:	b2 cf       	rjmp	.-156    	; 0x18e0 <lcdWriteSprite_P+0x2e>
}

void lcdWriteSprite_P(PGM_P sprite, uint8_t sizeX, uint8_t sizeY, uint8_t mode)
{
	uint8_t b = 0;
	for (uint8_t i = 0; i < sizeX; i++)
    197c:	d3 94       	inc	r13
    197e:	de 14       	cp	r13, r14
    1980:	10 f4       	brcc	.+4      	; 0x1986 <lcdWriteSprite_P+0xd4>
    1982:	30 e0       	ldi	r19, 0x00	; 0
    1984:	f8 cf       	rjmp	.-16     	; 0x1976 <lcdWriteSprite_P+0xc4>
					lcdSetPixel(_curx + i, _cury + j, 1);
			}			
			b >>= 1;
		}
	}	
}
    1986:	0f 90       	pop	r0
    1988:	cf 91       	pop	r28
    198a:	df 91       	pop	r29
    198c:	1f 91       	pop	r17
    198e:	0f 91       	pop	r16
    1990:	ff 90       	pop	r15
    1992:	ef 90       	pop	r14
    1994:	df 90       	pop	r13
    1996:	cf 90       	pop	r12
    1998:	bf 90       	pop	r11
    199a:	9f 90       	pop	r9
    199c:	8f 90       	pop	r8
    199e:	08 95       	ret

000019a0 <lcdWriteGlyph_P>:

void lcdWriteGlyph_P(const glyph_t *glyph, uint8_t mode)
{
    19a0:	26 2f       	mov	r18, r22
	uint8_t sizeX = pgm_read_byte(&glyph->sizeX);
    19a2:	fc 01       	movw	r30, r24
    19a4:	64 91       	lpm	r22, Z+
	uint8_t sizeY = pgm_read_byte(&glyph->sizeY);
    19a6:	31 96       	adiw	r30, 0x01	; 1
    19a8:	44 91       	lpm	r20, Z+
	lcdWriteSprite_P((PGM_P)&glyph->glyph, sizeX, sizeY, mode);
    19aa:	02 96       	adiw	r24, 0x02	; 2
    19ac:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <lcdWriteSprite_P>
}
    19b0:	08 95       	ret

000019b2 <lcdWriteChar>:

void lcdWriteChar(char c)
{
	if (c == '\n')
    19b2:	8a 30       	cpi	r24, 0x0A	; 10
    19b4:	51 f4       	brne	.+20     	; 0x19ca <lcdWriteChar+0x18>
	{
		_cury += _font.sizeY;
    19b6:	80 91 29 01 	lds	r24, 0x0129
    19ba:	90 91 25 01 	lds	r25, 0x0125
    19be:	89 0f       	add	r24, r25
    19c0:	80 93 29 01 	sts	0x0129, r24
		_curx = 0;
    19c4:	10 92 2a 01 	sts	0x012A, r1
    19c8:	08 95       	ret
	}
	else
	{
		lcdWriteSprite_P(_font.selector(c), _font.sizeX, _font.sizeY, 0);
    19ca:	e0 91 26 01 	lds	r30, 0x0126
    19ce:	f0 91 27 01 	lds	r31, 0x0127
    19d2:	09 95       	icall
    19d4:	60 91 24 01 	lds	r22, 0x0124
    19d8:	40 91 25 01 	lds	r20, 0x0125
    19dc:	20 e0       	ldi	r18, 0x00	; 0
    19de:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <lcdWriteSprite_P>
		_curx += _font.sizeX;
    19e2:	80 91 2a 01 	lds	r24, 0x012A
    19e6:	90 91 24 01 	lds	r25, 0x0124
    19ea:	89 0f       	add	r24, r25
    19ec:	80 93 2a 01 	sts	0x012A, r24
    19f0:	08 95       	ret

000019f2 <LCD_WriteString>:
	}
}

void LCD_WriteString(char *s)
{
    19f2:	ef 92       	push	r14
    19f4:	ff 92       	push	r15
    19f6:	cf 93       	push	r28
    19f8:	df 93       	push	r29
    19fa:	e8 2e       	mov	r14, r24
    19fc:	e7 01       	movw	r28, r14
    19fe:	7e 01       	movw	r14, r28
    1a00:	f9 2e       	mov	r15, r25
    1a02:	e7 01       	movw	r28, r14
	while (*s)
    1a04:	02 c0       	rjmp	.+4      	; 0x1a0a <LCD_WriteString+0x18>
	{
		lcdWriteChar(*s);
    1a06:	0e 94 d9 0c 	call	0x19b2	; 0x19b2 <lcdWriteChar>
	}
}

void LCD_WriteString(char *s)
{
	while (*s)
    1a0a:	89 91       	ld	r24, Y+
    1a0c:	88 23       	and	r24, r24
    1a0e:	d9 f7       	brne	.-10     	; 0x1a06 <LCD_WriteString+0x14>
	{
		lcdWriteChar(*s);
		s++;
	}		
}
    1a10:	df 91       	pop	r29
    1a12:	cf 91       	pop	r28
    1a14:	ff 90       	pop	r15
    1a16:	ef 90       	pop	r14
    1a18:	08 95       	ret

00001a1a <LCD_WriteString_P>:
}



void LCD_WriteString_P(PGM_P s)
{
    1a1a:	cf 93       	push	r28
    1a1c:	df 93       	push	r29
    1a1e:	ec 01       	movw	r28, r24
	char c;
	while ((c = pgm_read_byte(s++)))
    1a20:	02 c0       	rjmp	.+4      	; 0x1a26 <LCD_WriteString_P+0xc>
		lcdWriteChar(c);
    1a22:	0e 94 d9 0c 	call	0x19b2	; 0x19b2 <lcdWriteChar>
    1a26:	fe 01       	movw	r30, r28


void LCD_WriteString_P(PGM_P s)
{
	char c;
	while ((c = pgm_read_byte(s++)))
    1a28:	21 96       	adiw	r28, 0x01	; 1
    1a2a:	84 91       	lpm	r24, Z+
    1a2c:	88 23       	and	r24, r24
    1a2e:	c9 f7       	brne	.-14     	; 0x1a22 <LCD_WriteString_P+0x8>
		lcdWriteChar(c);
}
    1a30:	df 91       	pop	r29
    1a32:	cf 91       	pop	r28
    1a34:	08 95       	ret

00001a36 <lcdReverse>:
	lcdReverse(0);
}


void lcdReverse(uint8_t reversed)
{
    1a36:	90 91 28 01 	lds	r25, 0x0128
	if (reversed)
    1a3a:	88 23       	and	r24, r24
    1a3c:	11 f0       	breq	.+4      	; 0x1a42 <lcdReverse+0xc>
		_flags |= REVERSED;
    1a3e:	91 60       	ori	r25, 0x01	; 1
    1a40:	01 c0       	rjmp	.+2      	; 0x1a44 <lcdReverse+0xe>
	else
		_flags &= ~REVERSED;
    1a42:	9e 7f       	andi	r25, 0xFE	; 254
    1a44:	90 93 28 01 	sts	0x0128, r25
    1a48:	08 95       	ret

00001a4a <LCD_WriteStringex>:
}



void LCD_WriteStringex(uint8_t x, uint8_t y, char *str, BOOL LCDReverse)
{
    1a4a:	ef 92       	push	r14
    1a4c:	ff 92       	push	r15
    1a4e:	0f 93       	push	r16
    1a50:	1f 93       	push	r17
    1a52:	df 93       	push	r29
    1a54:	cf 93       	push	r28
    1a56:	00 d0       	rcall	.+0      	; 0x1a58 <LCD_WriteStringex+0xe>
    1a58:	0f 92       	push	r0
    1a5a:	cd b7       	in	r28, 0x3d	; 61
    1a5c:	de b7       	in	r29, 0x3e	; 62
    1a5e:	18 2f       	mov	r17, r24
    1a60:	82 2f       	mov	r24, r18
	lcdReverse(LCDReverse);
    1a62:	4a 83       	std	Y+2, r20	; 0x02
    1a64:	5b 83       	std	Y+3, r21	; 0x03
    1a66:	69 83       	std	Y+1, r22	; 0x01
    1a68:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <lcdReverse>
	LCD_SetPos(x, y);
    1a6c:	81 2f       	mov	r24, r17
    1a6e:	69 81       	ldd	r22, Y+1	; 0x01
    1a70:	0e 94 10 0c 	call	0x1820	; 0x1820 <LCD_SetPos>
    1a74:	4a 81       	ldd	r20, Y+2	; 0x02
    1a76:	5b 81       	ldd	r21, Y+3	; 0x03
    1a78:	8a 01       	movw	r16, r20
	while (*str)
    1a7a:	02 c0       	rjmp	.+4      	; 0x1a80 <LCD_WriteStringex+0x36>
	{
		lcdWriteChar(*str);
    1a7c:	0e 94 d9 0c 	call	0x19b2	; 0x19b2 <lcdWriteChar>

void LCD_WriteStringex(uint8_t x, uint8_t y, char *str, BOOL LCDReverse)
{
	lcdReverse(LCDReverse);
	LCD_SetPos(x, y);
	while (*str)
    1a80:	f8 01       	movw	r30, r16
    1a82:	81 91       	ld	r24, Z+
    1a84:	8f 01       	movw	r16, r30
    1a86:	88 23       	and	r24, r24
    1a88:	c9 f7       	brne	.-14     	; 0x1a7c <LCD_WriteStringex+0x32>
	{
		lcdWriteChar(*str);
		str++;
	}		
	lcdReverse(0);
    1a8a:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <lcdReverse>
}
    1a8e:	0f 90       	pop	r0
    1a90:	0f 90       	pop	r0
    1a92:	0f 90       	pop	r0
    1a94:	cf 91       	pop	r28
    1a96:	df 91       	pop	r29
    1a98:	1f 91       	pop	r17
    1a9a:	0f 91       	pop	r16
    1a9c:	ff 90       	pop	r15
    1a9e:	ef 90       	pop	r14
    1aa0:	08 95       	ret

00001aa2 <LCD_WriteSpace>:
		_flags &= ~REVERSED;
}


void LCD_WriteSpace(uint8_t len)
{
    1aa2:	0f 93       	push	r16
    1aa4:	1f 93       	push	r17
    1aa6:	08 2f       	mov	r16, r24
	for (uint8_t i = 0; i < len; i++)
    1aa8:	10 e0       	ldi	r17, 0x00	; 0
    1aaa:	04 c0       	rjmp	.+8      	; 0x1ab4 <LCD_WriteSpace+0x12>
		lcdWriteChar(32);
    1aac:	80 e2       	ldi	r24, 0x20	; 32
    1aae:	0e 94 d9 0c 	call	0x19b2	; 0x19b2 <lcdWriteChar>
}


void LCD_WriteSpace(uint8_t len)
{
	for (uint8_t i = 0; i < len; i++)
    1ab2:	1f 5f       	subi	r17, 0xFF	; 255
    1ab4:	10 17       	cp	r17, r16
    1ab6:	d0 f3       	brcs	.-12     	; 0x1aac <LCD_WriteSpace+0xa>
		lcdWriteChar(32);
}
    1ab8:	1f 91       	pop	r17
    1aba:	0f 91       	pop	r16
    1abc:	08 95       	ret

00001abe <LCD_WritePadded>:

void LCD_WritePadded(char *s, uint8_t len)
{
    1abe:	0f 93       	push	r16
    1ac0:	1f 93       	push	r17
    1ac2:	df 93       	push	r29
    1ac4:	cf 93       	push	r28
    1ac6:	0f 92       	push	r0
    1ac8:	cd b7       	in	r28, 0x3d	; 61
    1aca:	de b7       	in	r29, 0x3e	; 62
    1acc:	8c 01       	movw	r16, r24
	LCD_WriteString(s);
    1ace:	69 83       	std	Y+1, r22	; 0x01
    1ad0:	0e 94 f9 0c 	call	0x19f2	; 0x19f2 <LCD_WriteString>
	LCD_WriteSpace(len - strlen(s));
    1ad4:	f8 01       	movw	r30, r16
    1ad6:	01 90       	ld	r0, Z+
    1ad8:	00 20       	and	r0, r0
    1ada:	e9 f7       	brne	.-6      	; 0x1ad6 <LCD_WritePadded+0x18>
    1adc:	31 97       	sbiw	r30, 0x01	; 1
    1ade:	e0 1b       	sub	r30, r16
    1ae0:	f1 0b       	sbc	r31, r17
    1ae2:	69 81       	ldd	r22, Y+1	; 0x01
    1ae4:	86 2f       	mov	r24, r22
    1ae6:	8e 1b       	sub	r24, r30
    1ae8:	0e 94 51 0d 	call	0x1aa2	; 0x1aa2 <LCD_WriteSpace>
}
    1aec:	0f 90       	pop	r0
    1aee:	cf 91       	pop	r28
    1af0:	df 91       	pop	r29
    1af2:	1f 91       	pop	r17
    1af4:	0f 91       	pop	r16
    1af6:	08 95       	ret

00001af8 <LCD_WritePadded_P>:


void LCD_WritePadded_P(const char *s, uint8_t len)
{
    1af8:	0f 93       	push	r16
    1afa:	1f 93       	push	r17
    1afc:	df 93       	push	r29
    1afe:	cf 93       	push	r28
    1b00:	0f 92       	push	r0
    1b02:	cd b7       	in	r28, 0x3d	; 61
    1b04:	de b7       	in	r29, 0x3e	; 62
    1b06:	8c 01       	movw	r16, r24
	LCD_WriteString_P(s);
    1b08:	69 83       	std	Y+1, r22	; 0x01
    1b0a:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <LCD_WriteString_P>
	LCD_WriteSpace(len - strlen_P(s));
    1b0e:	c8 01       	movw	r24, r16
    1b10:	0e 94 af 38 	call	0x715e	; 0x715e <strlen_P>
    1b14:	69 81       	ldd	r22, Y+1	; 0x01
    1b16:	68 1b       	sub	r22, r24
    1b18:	86 2f       	mov	r24, r22
    1b1a:	0e 94 51 0d 	call	0x1aa2	; 0x1aa2 <LCD_WriteSpace>
}
    1b1e:	0f 90       	pop	r0
    1b20:	cf 91       	pop	r28
    1b22:	df 91       	pop	r29
    1b24:	1f 91       	pop	r17
    1b26:	0f 91       	pop	r16
    1b28:	08 95       	ret

00001b2a <LCD_WriteString_Pex>:
		lcdWriteChar(c);
}


void LCD_WriteString_Pex(uint8_t x, uint8_t y, PGM_P str, uint8_t len, BOOL LCDReverse)
{
    1b2a:	ef 92       	push	r14
    1b2c:	ff 92       	push	r15
    1b2e:	0f 93       	push	r16
    1b30:	1f 93       	push	r17
    1b32:	df 93       	push	r29
    1b34:	cf 93       	push	r28
    1b36:	00 d0       	rcall	.+0      	; 0x1b38 <LCD_WriteString_Pex+0xe>
    1b38:	cd b7       	in	r28, 0x3d	; 61
    1b3a:	de b7       	in	r29, 0x3e	; 62
    1b3c:	18 2f       	mov	r17, r24
    1b3e:	7a 01       	movw	r14, r20
    1b40:	80 2f       	mov	r24, r16
	lcdReverse(LCDReverse);
    1b42:	2a 83       	std	Y+2, r18	; 0x02
    1b44:	69 83       	std	Y+1, r22	; 0x01
    1b46:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <lcdReverse>
	LCD_SetPos(x, y);
    1b4a:	81 2f       	mov	r24, r17
    1b4c:	69 81       	ldd	r22, Y+1	; 0x01
    1b4e:	0e 94 10 0c 	call	0x1820	; 0x1820 <LCD_SetPos>
	LCD_WritePadded_P(str, len);
    1b52:	c7 01       	movw	r24, r14
    1b54:	2a 81       	ldd	r18, Y+2	; 0x02
    1b56:	62 2f       	mov	r22, r18
    1b58:	0e 94 7c 0d 	call	0x1af8	; 0x1af8 <LCD_WritePadded_P>
	lcdReverse(0);
    1b5c:	80 e0       	ldi	r24, 0x00	; 0
    1b5e:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <lcdReverse>
}
    1b62:	0f 90       	pop	r0
    1b64:	0f 90       	pop	r0
    1b66:	cf 91       	pop	r28
    1b68:	df 91       	pop	r29
    1b6a:	1f 91       	pop	r17
    1b6c:	0f 91       	pop	r16
    1b6e:	ff 90       	pop	r15
    1b70:	ef 90       	pop	r14
    1b72:	08 95       	ret

00001b74 <LCD_WriteValue_double_ex>:
	LCD_WriteString_P(s);
	LCD_WriteSpace(len - strlen_P(s));
}

void LCD_WriteValue_double_ex(uint8_t x, uint8_t y, double value, int8_t len, BOOL LCDReverse)
{
    1b74:	bf 92       	push	r11
    1b76:	cf 92       	push	r12
    1b78:	df 92       	push	r13
    1b7a:	ef 92       	push	r14
    1b7c:	ff 92       	push	r15
    1b7e:	0f 93       	push	r16
    1b80:	1f 93       	push	r17
    1b82:	df 93       	push	r29
    1b84:	cf 93       	push	r28
    1b86:	cd b7       	in	r28, 0x3d	; 61
    1b88:	de b7       	in	r29, 0x3e	; 62
    1b8a:	62 97       	sbiw	r28, 0x12	; 18
    1b8c:	0f b6       	in	r0, 0x3f	; 63
    1b8e:	f8 94       	cli
    1b90:	de bf       	out	0x3e, r29	; 62
    1b92:	0f be       	out	0x3f, r0	; 63
    1b94:	cd bf       	out	0x3d, r28	; 61
    1b96:	f8 2e       	mov	r15, r24
    1b98:	b6 2e       	mov	r11, r22
    1b9a:	ca 01       	movw	r24, r20
    1b9c:	b9 01       	movw	r22, r18
    1b9e:	30 2f       	mov	r19, r16
	char s[17];
	dtostrf(value, len-2,2, s);
    1ba0:	32 50       	subi	r19, 0x02	; 2
    1ba2:	43 2f       	mov	r20, r19
    1ba4:	22 e0       	ldi	r18, 0x02	; 2
    1ba6:	6e 01       	movw	r12, r28
    1ba8:	08 94       	sec
    1baa:	c1 1c       	adc	r12, r1
    1bac:	d1 1c       	adc	r13, r1
    1bae:	86 01       	movw	r16, r12
    1bb0:	3a 8b       	std	Y+18, r19	; 0x12
    1bb2:	0e 94 7d 38 	call	0x70fa	; 0x70fa <dtostrf>
	//itoa(value, s, 10);
	lcdReverse(LCDReverse);
    1bb6:	8e 2d       	mov	r24, r14
    1bb8:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <lcdReverse>
	LCD_SetPos(x, y);
    1bbc:	8f 2d       	mov	r24, r15
    1bbe:	6b 2d       	mov	r22, r11
    1bc0:	0e 94 10 0c 	call	0x1820	; 0x1820 <LCD_SetPos>
	LCD_WritePadded(s, len-2);
    1bc4:	c6 01       	movw	r24, r12
    1bc6:	3a 89       	ldd	r19, Y+18	; 0x12
    1bc8:	63 2f       	mov	r22, r19
    1bca:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <LCD_WritePadded>
	lcdReverse(0);
    1bce:	80 e0       	ldi	r24, 0x00	; 0
    1bd0:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <lcdReverse>

}
    1bd4:	62 96       	adiw	r28, 0x12	; 18
    1bd6:	0f b6       	in	r0, 0x3f	; 63
    1bd8:	f8 94       	cli
    1bda:	de bf       	out	0x3e, r29	; 62
    1bdc:	0f be       	out	0x3f, r0	; 63
    1bde:	cd bf       	out	0x3d, r28	; 61
    1be0:	cf 91       	pop	r28
    1be2:	df 91       	pop	r29
    1be4:	1f 91       	pop	r17
    1be6:	0f 91       	pop	r16
    1be8:	ff 90       	pop	r15
    1bea:	ef 90       	pop	r14
    1bec:	df 90       	pop	r13
    1bee:	cf 90       	pop	r12
    1bf0:	bf 90       	pop	r11
    1bf2:	08 95       	ret

00001bf4 <LCD_WriteValue_double>:
void LCD_WriteValue_double(uint8_t x, uint8_t y, double value,  BOOL LCDReverse)
{
    1bf4:	ef 92       	push	r14
    1bf6:	0f 93       	push	r16
    1bf8:	e0 2e       	mov	r14, r16
	LCD_WriteValue_double_ex(x,y,value,5,LCDReverse);
    1bfa:	05 e0       	ldi	r16, 0x05	; 5
    1bfc:	0e 94 ba 0d 	call	0x1b74	; 0x1b74 <LCD_WriteValue_double_ex>
}
    1c00:	0f 91       	pop	r16
    1c02:	ef 90       	pop	r14
    1c04:	08 95       	ret

00001c06 <LCD_WriteValue>:

void LCD_WriteValue(uint8_t x, uint8_t y, int16_t value, uint8_t len, BOOL LCDReverse)
{
    1c06:	df 92       	push	r13
    1c08:	ef 92       	push	r14
    1c0a:	ff 92       	push	r15
    1c0c:	0f 93       	push	r16
    1c0e:	1f 93       	push	r17
    1c10:	df 93       	push	r29
    1c12:	cf 93       	push	r28
    1c14:	cd b7       	in	r28, 0x3d	; 61
    1c16:	de b7       	in	r29, 0x3e	; 62
    1c18:	28 97       	sbiw	r28, 0x08	; 8
    1c1a:	0f b6       	in	r0, 0x3f	; 63
    1c1c:	f8 94       	cli
    1c1e:	de bf       	out	0x3e, r29	; 62
    1c20:	0f be       	out	0x3f, r0	; 63
    1c22:	cd bf       	out	0x3d, r28	; 61
    1c24:	d8 2e       	mov	r13, r24
    1c26:	16 2f       	mov	r17, r22
	char s[7];
	itoa(value, s, 10);
    1c28:	ca 01       	movw	r24, r20
    1c2a:	7e 01       	movw	r14, r28
    1c2c:	08 94       	sec
    1c2e:	e1 1c       	adc	r14, r1
    1c30:	f1 1c       	adc	r15, r1
    1c32:	b7 01       	movw	r22, r14
    1c34:	4a e0       	ldi	r20, 0x0A	; 10
    1c36:	50 e0       	ldi	r21, 0x00	; 0
    1c38:	28 87       	std	Y+8, r18	; 0x08
    1c3a:	0e 94 cc 38 	call	0x7198	; 0x7198 <itoa>
	lcdReverse(LCDReverse);
    1c3e:	80 2f       	mov	r24, r16
    1c40:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <lcdReverse>
	LCD_SetPos(x, y);
    1c44:	8d 2d       	mov	r24, r13
    1c46:	61 2f       	mov	r22, r17
    1c48:	0e 94 10 0c 	call	0x1820	; 0x1820 <LCD_SetPos>
	LCD_WritePadded(s, len);
    1c4c:	c7 01       	movw	r24, r14
    1c4e:	28 85       	ldd	r18, Y+8	; 0x08
    1c50:	62 2f       	mov	r22, r18
    1c52:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <LCD_WritePadded>
	lcdReverse(0);
    1c56:	80 e0       	ldi	r24, 0x00	; 0
    1c58:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <lcdReverse>
}
    1c5c:	28 96       	adiw	r28, 0x08	; 8
    1c5e:	0f b6       	in	r0, 0x3f	; 63
    1c60:	f8 94       	cli
    1c62:	de bf       	out	0x3e, r29	; 62
    1c64:	0f be       	out	0x3f, r0	; 63
    1c66:	cd bf       	out	0x3d, r28	; 61
    1c68:	cf 91       	pop	r28
    1c6a:	df 91       	pop	r29
    1c6c:	1f 91       	pop	r17
    1c6e:	0f 91       	pop	r16
    1c70:	ff 90       	pop	r15
    1c72:	ef 90       	pop	r14
    1c74:	df 90       	pop	r13
    1c76:	08 95       	ret

00001c78 <LCD_Enable>:
}

void LCD_Enable()
{
	// reset timer0 to avoid re-entrant call of ISR b/c it is non blocking
	TCNT0 = 0;
    1c78:	16 bc       	out	0x26, r1	; 38
	TIFR0 = _BV(TOV0);
    1c7a:	81 e0       	ldi	r24, 0x01	; 1
    1c7c:	85 bb       	out	0x15, r24	; 21
	TIMSK0 |= _BV(TOIE0);	// enable interrupt on overflow
    1c7e:	ee e6       	ldi	r30, 0x6E	; 110
    1c80:	f0 e0       	ldi	r31, 0x00	; 0
    1c82:	80 81       	ld	r24, Z
    1c84:	81 60       	ori	r24, 0x01	; 1
    1c86:	80 83       	st	Z, r24
}
    1c88:	08 95       	ret

00001c8a <LCD_Disable>:

void LCD_Disable()
{
	TIMSK0 &= ~_BV(TOIE0);	// disable overflow interrupt
    1c8a:	ee e6       	ldi	r30, 0x6E	; 110
    1c8c:	f0 e0       	ldi	r31, 0x00	; 0
    1c8e:	80 81       	ld	r24, Z
    1c90:	8e 7f       	andi	r24, 0xFE	; 254
    1c92:	80 83       	st	Z, r24
}
    1c94:	08 95       	ret

00001c96 <lcdSetContrast>:
	LCD_WritePadded(s, len);
	lcdReverse(0);
}

void lcdSetContrast(uint8_t contrast)
{
    1c96:	0f 93       	push	r16
    1c98:	1f 93       	push	r17
    1c9a:	cf 93       	push	r28
    1c9c:	df 93       	push	r29
    1c9e:	08 2f       	mov	r16, r24
	uint8_t t = TIMSK0;
    1ca0:	ce e6       	ldi	r28, 0x6E	; 110
    1ca2:	d0 e0       	ldi	r29, 0x00	; 0
    1ca4:	18 81       	ld	r17, Y
	LCD_Disable();
    1ca6:	0e 94 45 0e 	call	0x1c8a	; 0x1c8a <LCD_Disable>
	sendData(0x81, LCD_COMMAND);
    1caa:	81 e8       	ldi	r24, 0x81	; 129
    1cac:	60 e0       	ldi	r22, 0x00	; 0
    1cae:	0e 94 fa 0b 	call	0x17f4	; 0x17f4 <sendData>
	sendData(contrast & 0x3F, LCD_COMMAND); 
    1cb2:	80 2f       	mov	r24, r16
    1cb4:	8f 73       	andi	r24, 0x3F	; 63
    1cb6:	60 e0       	ldi	r22, 0x00	; 0
    1cb8:	0e 94 fa 0b 	call	0x17f4	; 0x17f4 <sendData>
	TIMSK0 = t;
    1cbc:	18 83       	st	Y, r17
}
    1cbe:	df 91       	pop	r29
    1cc0:	cf 91       	pop	r28
    1cc2:	1f 91       	pop	r17
    1cc4:	0f 91       	pop	r16
    1cc6:	08 95       	ret

00001cc8 <LCD_SelectFont>:
{
	TIMSK0 &= ~_BV(TOIE0);	// disable overflow interrupt
}

void LCD_SelectFont(const fontdescriptor_t *font)
{
    1cc8:	bc 01       	movw	r22, r24
	if (font == NULL)
    1cca:	00 97       	sbiw	r24, 0x00	; 0
    1ccc:	11 f4       	brne	.+4      	; 0x1cd2 <LCD_SelectFont+0xa>
		font = &font6x8;
    1cce:	6d e5       	ldi	r22, 0x5D	; 93
    1cd0:	77 e0       	ldi	r23, 0x07	; 7
	memcpy_P(&_font, font, sizeof(_font));
    1cd2:	84 e2       	ldi	r24, 0x24	; 36
    1cd4:	91 e0       	ldi	r25, 0x01	; 1
    1cd6:	44 e0       	ldi	r20, 0x04	; 4
    1cd8:	50 e0       	ldi	r21, 0x00	; 0
    1cda:	0e 94 9f 38 	call	0x713e	; 0x713e <memcpy_P>
}
    1cde:	08 95       	ret

00001ce0 <LCD_Init>:
	0xff // end of array
	*/
};

void LCD_Init()
{
    1ce0:	cf 93       	push	r28
    1ce2:	df 93       	push	r29
	// pins
	LCD_CS_DIR = OUTPUT;
    1ce4:	55 9a       	sbi	0x0a, 5	; 10
	LCD_RST_DIR = OUTPUT;
    1ce6:	56 9a       	sbi	0x0a, 6	; 10
	LCD_A0_DIR = OUTPUT;
    1ce8:	57 9a       	sbi	0x0a, 7	; 10
	LCD_SCL_DIR = OUTPUT;
    1cea:	54 9a       	sbi	0x0a, 4	; 10
	LCD_SDA_DIR = OUTPUT;
    1cec:	51 9a       	sbi	0x0a, 1	; 10

	// init display
	LCD_RST = 0;
    1cee:	5e 98       	cbi	0x0b, 6	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1cf0:	89 ef       	ldi	r24, 0xF9	; 249
    1cf2:	90 e0       	ldi	r25, 0x00	; 0
    1cf4:	01 97       	sbiw	r24, 0x01	; 1
    1cf6:	f1 f7       	brne	.-4      	; 0x1cf4 <LCD_Init+0x14>
    1cf8:	00 c0       	rjmp	.+0      	; 0x1cfa <LCD_Init+0x1a>
    1cfa:	00 00       	nop
	_delay_ms(1);	// version 0.9.9
	LCD_RST = 1;
    1cfc:	5e 9a       	sbi	0x0b, 6	; 11
    1cfe:	89 ef       	ldi	r24, 0xF9	; 249
    1d00:	90 e0       	ldi	r25, 0x00	; 0
    1d02:	01 97       	sbiw	r24, 0x01	; 1
    1d04:	f1 f7       	brne	.-4      	; 0x1d02 <LCD_Init+0x22>
    1d06:	00 c0       	rjmp	.+0      	; 0x1d08 <LCD_Init+0x28>
    1d08:	00 00       	nop
	_delay_ms(1); // version 0.9.9
	
	const unsigned char* ptr = _initSeq;
    1d0a:	cc e7       	ldi	r28, 0x7C	; 124
    1d0c:	d0 e0       	ldi	r29, 0x00	; 0
	uint8_t c;
	while ((c = pgm_read_byte(ptr++)))
    1d0e:	03 c0       	rjmp	.+6      	; 0x1d16 <LCD_Init+0x36>
	{
		sendData(c, LCD_COMMAND);
    1d10:	60 e0       	ldi	r22, 0x00	; 0
    1d12:	0e 94 fa 0b 	call	0x17f4	; 0x17f4 <sendData>
    1d16:	fe 01       	movw	r30, r28
	LCD_RST = 1;
	_delay_ms(1); // version 0.9.9
	
	const unsigned char* ptr = _initSeq;
	uint8_t c;
	while ((c = pgm_read_byte(ptr++)))
    1d18:	21 96       	adiw	r28, 0x01	; 1
    1d1a:	84 91       	lpm	r24, Z+
    1d1c:	88 23       	and	r24, r24
    1d1e:	c1 f7       	brne	.-16     	; 0x1d10 <LCD_Init+0x30>
	{
		sendData(c, LCD_COMMAND);
	}	
	LCD_SelectFont(NULL);		// select default font
    1d20:	80 e0       	ldi	r24, 0x00	; 0
    1d22:	90 e0       	ldi	r25, 0x00	; 0
    1d24:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <LCD_SelectFont>
	
	// use timer0 with clk/8 and overflow
	// at 256 as interrupt based output of data bytes
	// ie every 1024us one byte is send to display. whole screen takes about 105ms
	TCCR0B = _BV(CS01);		// clk/8
    1d28:	82 e0       	ldi	r24, 0x02	; 2
    1d2a:	85 bd       	out	0x25, r24	; 37
	LCD_Enable();
    1d2c:	0e 94 3c 0e 	call	0x1c78	; 0x1c78 <LCD_Enable>
}
    1d30:	df 91       	pop	r29
    1d32:	cf 91       	pop	r28
    1d34:	08 95       	ret

00001d36 <LED_FlashOrangeLED>:
#include "../Include/Misc.h"
#include "../Include/IO_config.h"


void LED_FlashOrangeLED (uint16_t msDuration, uint8_t Times)
{
    1d36:	cf 92       	push	r12
    1d38:	df 92       	push	r13
    1d3a:	ef 92       	push	r14
    1d3c:	ff 92       	push	r15
    1d3e:	0f 93       	push	r16
    1d40:	1f 93       	push	r17
    1d42:	df 93       	push	r29
    1d44:	cf 93       	push	r28
    1d46:	0f 92       	push	r0
    1d48:	cd b7       	in	r28, 0x3d	; 61
    1d4a:	de b7       	in	r29, 0x3e	; 62
    1d4c:	6c 01       	movw	r12, r24
	bool CurrentLED_Status = LED_Orange;
    1d4e:	25 b1       	in	r18, 0x05	; 5
    1d50:	26 95       	lsr	r18
    1d52:	26 95       	lsr	r18
    1d54:	26 95       	lsr	r18
    1d56:	21 70       	andi	r18, 0x01	; 1
	
	for (int i=0; i< Times; ++i)
    1d58:	00 e0       	ldi	r16, 0x00	; 0
    1d5a:	10 e0       	ldi	r17, 0x00	; 0
    1d5c:	e6 2e       	mov	r14, r22
    1d5e:	ff 24       	eor	r15, r15
    1d60:	24 c0       	rjmp	.+72     	; 0x1daa <LED_FlashOrangeLED+0x74>
	{
		LED_Orange = ~LED_Orange;
    1d62:	85 b1       	in	r24, 0x05	; 5
    1d64:	86 95       	lsr	r24
    1d66:	86 95       	lsr	r24
    1d68:	86 95       	lsr	r24
    1d6a:	80 95       	com	r24
    1d6c:	81 70       	andi	r24, 0x01	; 1
    1d6e:	88 0f       	add	r24, r24
    1d70:	88 0f       	add	r24, r24
    1d72:	88 0f       	add	r24, r24
    1d74:	95 b1       	in	r25, 0x05	; 5
    1d76:	97 7f       	andi	r25, 0xF7	; 247
    1d78:	98 2b       	or	r25, r24
    1d7a:	95 b9       	out	0x05, r25	; 5
		delay_ms(msDuration);
    1d7c:	c6 01       	movw	r24, r12
    1d7e:	29 83       	std	Y+1, r18	; 0x01
    1d80:	0e 94 fd 0e 	call	0x1dfa	; 0x1dfa <delay_ms>
		LED_Orange = ~LED_Orange;
    1d84:	85 b1       	in	r24, 0x05	; 5
    1d86:	86 95       	lsr	r24
    1d88:	86 95       	lsr	r24
    1d8a:	86 95       	lsr	r24
    1d8c:	80 95       	com	r24
    1d8e:	81 70       	andi	r24, 0x01	; 1
    1d90:	88 0f       	add	r24, r24
    1d92:	88 0f       	add	r24, r24
    1d94:	88 0f       	add	r24, r24
    1d96:	95 b1       	in	r25, 0x05	; 5
    1d98:	97 7f       	andi	r25, 0xF7	; 247
    1d9a:	98 2b       	or	r25, r24
    1d9c:	95 b9       	out	0x05, r25	; 5
		delay_ms(msDuration);		
    1d9e:	c6 01       	movw	r24, r12
    1da0:	0e 94 fd 0e 	call	0x1dfa	; 0x1dfa <delay_ms>

void LED_FlashOrangeLED (uint16_t msDuration, uint8_t Times)
{
	bool CurrentLED_Status = LED_Orange;
	
	for (int i=0; i< Times; ++i)
    1da4:	0f 5f       	subi	r16, 0xFF	; 255
    1da6:	1f 4f       	sbci	r17, 0xFF	; 255
    1da8:	29 81       	ldd	r18, Y+1	; 0x01
    1daa:	0e 15       	cp	r16, r14
    1dac:	1f 05       	cpc	r17, r15
    1dae:	cc f2       	brlt	.-78     	; 0x1d62 <LED_FlashOrangeLED+0x2c>
		delay_ms(msDuration);
		LED_Orange = ~LED_Orange;
		delay_ms(msDuration);		
	}
	
	LED_Orange = CurrentLED_Status;
    1db0:	21 70       	andi	r18, 0x01	; 1
    1db2:	22 0f       	add	r18, r18
    1db4:	22 0f       	add	r18, r18
    1db6:	22 0f       	add	r18, r18
    1db8:	85 b1       	in	r24, 0x05	; 5
    1dba:	87 7f       	andi	r24, 0xF7	; 247
    1dbc:	82 2b       	or	r24, r18
    1dbe:	85 b9       	out	0x05, r24	; 5
	
    1dc0:	0f 90       	pop	r0
    1dc2:	cf 91       	pop	r28
    1dc4:	df 91       	pop	r29
    1dc6:	1f 91       	pop	r17
    1dc8:	0f 91       	pop	r16
    1dca:	ff 90       	pop	r15
    1dcc:	ef 90       	pop	r14
    1dce:	df 90       	pop	r13
    1dd0:	cf 90       	pop	r12
    1dd2:	08 95       	ret

00001dd4 <delay_us>:



void delay_us(uint16_t time)            /* time delay for us */
{ 
 while(time--)
    1dd4:	0f c0       	rjmp	.+30     	; 0x1df4 <delay_us+0x20>
	...
	asm volatile ("NOP"); asm volatile ("NOP"); 
	asm volatile ("NOP"); 
	asm volatile ("NOP"); asm volatile ("NOP"); 
	asm volatile ("NOP"); asm volatile ("NOP"); 
	asm volatile ("NOP"); asm volatile ("NOP"); 
	asm volatile ("NOP"); 
    1df2:	01 97       	sbiw	r24, 0x01	; 1



void delay_us(uint16_t time)            /* time delay for us */
{ 
 while(time--)
    1df4:	00 97       	sbiw	r24, 0x00	; 0
    1df6:	79 f7       	brne	.-34     	; 0x1dd6 <delay_us+0x2>
	asm volatile ("NOP"); asm volatile ("NOP"); 
	asm volatile ("NOP"); asm volatile ("NOP"); 
	asm volatile ("NOP"); asm volatile ("NOP"); 
	asm volatile ("NOP"); 
 }
}
    1df8:	08 95       	ret

00001dfa <delay_ms>:

void delay_ms(uint16_t time)
{
    1dfa:	1f 93       	push	r17
    1dfc:	cf 93       	push	r28
    1dfe:	df 93       	push	r29
    1e00:	ec 01       	movw	r28, r24
	uint8_t i;
	while(time--)
    1e02:	08 c0       	rjmp	.+16     	; 0x1e14 <delay_ms+0x1a>
    1e04:	1a e0       	ldi	r17, 0x0A	; 10
	{
		for(i=0;i<10;i++) delay_us(100);
    1e06:	84 e6       	ldi	r24, 0x64	; 100
    1e08:	90 e0       	ldi	r25, 0x00	; 0
    1e0a:	0e 94 ea 0e 	call	0x1dd4	; 0x1dd4 <delay_us>
    1e0e:	11 50       	subi	r17, 0x01	; 1
    1e10:	d1 f7       	brne	.-12     	; 0x1e06 <delay_ms+0xc>
    1e12:	21 97       	sbiw	r28, 0x01	; 1
}

void delay_ms(uint16_t time)
{
	uint8_t i;
	while(time--)
    1e14:	20 97       	sbiw	r28, 0x00	; 0
    1e16:	b1 f7       	brne	.-20     	; 0x1e04 <delay_ms+0xa>
	{
		for(i=0;i<10;i++) delay_us(100);
	}
}
    1e18:	df 91       	pop	r29
    1e1a:	cf 91       	pop	r28
    1e1c:	1f 91       	pop	r17
    1e1e:	08 95       	ret

00001e20 <Ultrasonic_Init>:
#include "..\Include\Ultrasonic.h"


void Ultrasonic_Init ()
{
	RX_SONAR_TRIGGER_DIR = OUTPUT;
    1e20:	50 9a       	sbi	0x0a, 0	; 10
	RX_SONAR_TRIGGER=HIGH;   // Active LOW
    1e22:	48 9a       	sbi	0x09, 0	; 9
	RX_SONAR_DIR = INPUT;
    1e24:	22 98       	cbi	0x04, 2	; 4
	
	// enable interrupts
	EICRA  = _BV(ISC20);	// any edge on INT2
    1e26:	80 e1       	ldi	r24, 0x10	; 16
    1e28:	80 93 69 00 	sts	0x0069, r24
	EIMSK  = _BV(INT2);	// enable interrupt for INT0, INT1 and INT2
    1e2c:	84 e0       	ldi	r24, 0x04	; 4
    1e2e:	8d bb       	out	0x1d, r24	; 29
	EIFR   = _BV(INTF2);	// clear interrupts
    1e30:	8c bb       	out	0x1c, r24	; 28
		
	
}
    1e32:	08 95       	ret

00001e34 <Disarm>:
#include "Include/Beeper.h"


void Disarm (void)
{
	IsArmed = false;
    1e34:	10 92 cc 07 	sts	0x07CC, r1
	//LED_FlashOrangeLED (LED_SHORT_TOGGLE,4);
	LED_Orange = OFF;
    1e38:	2b 98       	cbi	0x05, 3	; 5
	
	TCNT1_X_snapshot1 =0; // reset timer
    1e3a:	10 92 eb 05 	sts	0x05EB, r1
    1e3e:	10 92 ea 05 	sts	0x05EA, r1
	Beeper_Beep(BEEP_SHORT,2);				
    1e42:	86 e4       	ldi	r24, 0x46	; 70
    1e44:	90 e0       	ldi	r25, 0x00	; 0
    1e46:	62 e0       	ldi	r22, 0x02	; 2
    1e48:	0e 94 99 0b 	call	0x1732	; 0x1732 <Beeper_Beep>
	Menu_LoadPage (PAGE_HOME);
    1e4c:	80 e0       	ldi	r24, 0x00	; 0
    1e4e:	90 e0       	ldi	r25, 0x00	; 0
    1e50:	0e 94 b9 2c 	call	0x5972	; 0x5972 <Menu_LoadPage>
}
    1e54:	08 95       	ret

00001e56 <Arm>:


void Arm (void)
{
	if ((Config.FrameType == FRAMETYPE_TRICOPTER) && (Config.BoardOrientationMode==QuadFlyingMode_X))
    1e56:	80 91 f4 06 	lds	r24, 0x06F4
    1e5a:	82 30       	cpi	r24, 0x02	; 2
    1e5c:	39 f4       	brne	.+14     	; 0x1e6c <Arm+0x16>
    1e5e:	80 91 f5 06 	lds	r24, 0x06F5
    1e62:	81 30       	cpi	r24, 0x01	; 1
    1e64:	19 f4       	brne	.+6      	; 0x1e6c <Arm+0x16>
	{ // NOT VALID CONFIGURATION
		Disarm();
    1e66:	0e 94 1a 0f 	call	0x1e34	; 0x1e34 <Disarm>
		
		return;
    1e6a:	08 95       	ret
	}
	
			
	IsArmed = true;
    1e6c:	81 e0       	ldi	r24, 0x01	; 1
    1e6e:	80 93 cc 07 	sts	0x07CC, r24
	LED_FlashOrangeLED (LED_SHORT_TOGGLE,4);
    1e72:	8e e1       	ldi	r24, 0x1E	; 30
    1e74:	90 e0       	ldi	r25, 0x00	; 0
    1e76:	64 e0       	ldi	r22, 0x04	; 4
    1e78:	70 e0       	ldi	r23, 0x00	; 0
    1e7a:	0e 94 9b 0e 	call	0x1d36	; 0x1d36 <LED_FlashOrangeLED>
	LED_Orange = ON;
    1e7e:	2b 9a       	sbi	0x05, 3	; 5
	Beeper_Beep(BEEP_LONG,1);				
    1e80:	8c eb       	ldi	r24, 0xBC	; 188
    1e82:	92 e0       	ldi	r25, 0x02	; 2
    1e84:	61 e0       	ldi	r22, 0x01	; 1
    1e86:	0e 94 99 0b 	call	0x1732	; 0x1732 <Beeper_Beep>
	
	TCNT1_X_snapshot1 =0; // reset timer
    1e8a:	10 92 eb 05 	sts	0x05EB, r1
    1e8e:	10 92 ea 05 	sts	0x05EA, r1
	TCNT_X_snapshotAutoDisarm=0;				
    1e92:	10 92 20 06 	sts	0x0620, r1
    1e96:	10 92 1f 06 	sts	0x061F, r1
	Menu_LoadPage (PAGE_HOME_ARMED);
    1e9a:	82 e0       	ldi	r24, 0x02	; 2
    1e9c:	90 e0       	ldi	r25, 0x00	; 0
    1e9e:	0e 94 b9 2c 	call	0x5972	; 0x5972 <Menu_LoadPage>
	
	PID_GyroTerms[PITCH_INDEX].I=0;
    1ea2:	80 e0       	ldi	r24, 0x00	; 0
    1ea4:	90 e0       	ldi	r25, 0x00	; 0
    1ea6:	dc 01       	movw	r26, r24
    1ea8:	80 93 7e 06 	sts	0x067E, r24
    1eac:	90 93 7f 06 	sts	0x067F, r25
    1eb0:	a0 93 80 06 	sts	0x0680, r26
    1eb4:	b0 93 81 06 	sts	0x0681, r27
	PID_GyroTerms[ROLL_INDEX].I=0;
    1eb8:	80 93 96 06 	sts	0x0696, r24
    1ebc:	90 93 97 06 	sts	0x0697, r25
    1ec0:	a0 93 98 06 	sts	0x0698, r26
    1ec4:	b0 93 99 06 	sts	0x0699, r27
	PID_GyroTerms[YAW_INDEX].I=0;
    1ec8:	80 93 ae 06 	sts	0x06AE, r24
    1ecc:	90 93 af 06 	sts	0x06AF, r25
    1ed0:	a0 93 b0 06 	sts	0x06B0, r26
    1ed4:	b0 93 b1 06 	sts	0x06B1, r27
	PID_AccTerms [PITCH_INDEX].I=0;
    1ed8:	80 93 56 05 	sts	0x0556, r24
    1edc:	90 93 57 05 	sts	0x0557, r25
    1ee0:	a0 93 58 05 	sts	0x0558, r26
    1ee4:	b0 93 59 05 	sts	0x0559, r27
	PID_AccTerms [ROLL_INDEX].I=0;
    1ee8:	80 93 6e 05 	sts	0x056E, r24
    1eec:	90 93 6f 05 	sts	0x056F, r25
    1ef0:	a0 93 70 05 	sts	0x0570, r26
    1ef4:	b0 93 71 05 	sts	0x0571, r27
	PID_AccTerms [Z_INDEX].I=0;
    1ef8:	80 93 86 05 	sts	0x0586, r24
    1efc:	90 93 87 05 	sts	0x0587, r25
    1f00:	a0 93 88 05 	sts	0x0588, r26
    1f04:	b0 93 89 05 	sts	0x0589, r27
    1f08:	08 95       	ret

00001f0a <Set_EEPROM_Default_Config>:
	Save_Config_to_EEPROM();
}

void Set_EEPROM_Default_Config(void)
{
	memcpy_P ( &Config, &defaultConfig, sizeof(config_t));
    1f0a:	8b ee       	ldi	r24, 0xEB	; 235
    1f0c:	96 e0       	ldi	r25, 0x06	; 6
    1f0e:	60 e9       	ldi	r22, 0x90	; 144
    1f10:	70 e0       	ldi	r23, 0x00	; 0
    1f12:	49 ec       	ldi	r20, 0xC9	; 201
    1f14:	50 e0       	ldi	r21, 0x00	; 0
    1f16:	0e 94 9f 38 	call	0x713e	; 0x713e <memcpy_P>
}
    1f1a:	08 95       	ret

00001f1c <eeprom_write_byte_changed>:
	}
}


void eeprom_write_byte_changed( uint8_t * addr, uint8_t value )
{ 
    1f1c:	0f 93       	push	r16
    1f1e:	1f 93       	push	r17
    1f20:	df 93       	push	r29
    1f22:	cf 93       	push	r28
    1f24:	0f 92       	push	r0
    1f26:	cd b7       	in	r28, 0x3d	; 61
    1f28:	de b7       	in	r29, 0x3e	; 62
    1f2a:	8c 01       	movw	r16, r24
	if(eeprom_read_byte(addr) != value)
    1f2c:	69 83       	std	Y+1, r22	; 0x01
    1f2e:	0e 94 13 39 	call	0x7226	; 0x7226 <__eerd_byte_m324pa>
    1f32:	69 81       	ldd	r22, Y+1	; 0x01
    1f34:	86 17       	cp	r24, r22
    1f36:	19 f0       	breq	.+6      	; 0x1f3e <eeprom_write_byte_changed+0x22>
	{
		eeprom_write_byte( addr, value );
    1f38:	c8 01       	movw	r24, r16
    1f3a:	0e 94 1b 39 	call	0x7236	; 0x7236 <__eewr_byte_m324pa>
	}
}
    1f3e:	0f 90       	pop	r0
    1f40:	cf 91       	pop	r28
    1f42:	df 91       	pop	r29
    1f44:	1f 91       	pop	r17
    1f46:	0f 91       	pop	r16
    1f48:	08 95       	ret

00001f4a <eeprom_write_block_changes>:
	eeprom_write_block_changes( (const void*) &Config, (void*) EEPROM_DATA_START_POS, sizeof(config_t));	//current_config CONFIG_STRUCT
	
}

void eeprom_write_block_changes( const uint8_t * src, void * dest, size_t size )
{ 
    1f4a:	cf 92       	push	r12
    1f4c:	df 92       	push	r13
    1f4e:	ef 92       	push	r14
    1f50:	ff 92       	push	r15
    1f52:	0f 93       	push	r16
    1f54:	1f 93       	push	r17
    1f56:	cf 93       	push	r28
    1f58:	df 93       	push	r29
    1f5a:	ec 01       	movw	r28, r24
    1f5c:	7b 01       	movw	r14, r22
    1f5e:	6a 01       	movw	r12, r20
	size_t len;

	for(len=0;len<size;len++)
    1f60:	00 e0       	ldi	r16, 0x00	; 0
    1f62:	10 e0       	ldi	r17, 0x00	; 0
    1f64:	08 c0       	rjmp	.+16     	; 0x1f76 <eeprom_write_block_changes+0x2c>
	{
		eeprom_write_byte_changed( dest,  *src );
    1f66:	c7 01       	movw	r24, r14
    1f68:	80 0f       	add	r24, r16
    1f6a:	91 1f       	adc	r25, r17
    1f6c:	69 91       	ld	r22, Y+
    1f6e:	0e 94 8e 0f 	call	0x1f1c	; 0x1f1c <eeprom_write_byte_changed>

void eeprom_write_block_changes( const uint8_t * src, void * dest, size_t size )
{ 
	size_t len;

	for(len=0;len<size;len++)
    1f72:	0f 5f       	subi	r16, 0xFF	; 255
    1f74:	1f 4f       	sbci	r17, 0xFF	; 255
    1f76:	0c 15       	cp	r16, r12
    1f78:	1d 05       	cpc	r17, r13
    1f7a:	a8 f3       	brcs	.-22     	; 0x1f66 <eeprom_write_block_changes+0x1c>
		eeprom_write_byte_changed( dest,  *src );

		src++;
		dest++;
	}
}
    1f7c:	df 91       	pop	r29
    1f7e:	cf 91       	pop	r28
    1f80:	1f 91       	pop	r17
    1f82:	0f 91       	pop	r16
    1f84:	ff 90       	pop	r15
    1f86:	ef 90       	pop	r14
    1f88:	df 90       	pop	r13
    1f8a:	cf 90       	pop	r12
    1f8c:	08 95       	ret

00001f8e <Load_Config_from_EEPROM>:

void Load_Config_from_EEPROM(void)
{
	// write to eeProm
	
	eeprom_write_block_changes( (const void*) &Config, (void*) EEPROM_DATA_START_POS, sizeof(config_t));	//current_config CONFIG_STRUCT
    1f8e:	8b ee       	ldi	r24, 0xEB	; 235
    1f90:	96 e0       	ldi	r25, 0x06	; 6
    1f92:	60 e0       	ldi	r22, 0x00	; 0
    1f94:	70 e0       	ldi	r23, 0x00	; 0
    1f96:	49 ec       	ldi	r20, 0xC9	; 201
    1f98:	50 e0       	ldi	r21, 0x00	; 0
    1f9a:	0e 94 a5 0f 	call	0x1f4a	; 0x1f4a <eeprom_write_block_changes>
	
}
    1f9e:	08 95       	ret

00001fa0 <Save_Config_to_EEPROM>:
}

void Save_Config_to_EEPROM(void)
{
	// write to eeProm
	cli();
    1fa0:	f8 94       	cli
	eeprom_write_block_changes( (const void*) &Config, (void*) EEPROM_DATA_START_POS, sizeof(config_t));	//current_config CONFIG_STRUCT
    1fa2:	8b ee       	ldi	r24, 0xEB	; 235
    1fa4:	96 e0       	ldi	r25, 0x06	; 6
    1fa6:	60 e0       	ldi	r22, 0x00	; 0
    1fa8:	70 e0       	ldi	r23, 0x00	; 0
    1faa:	49 ec       	ldi	r20, 0xC9	; 201
    1fac:	50 e0       	ldi	r21, 0x00	; 0
    1fae:	0e 94 a5 0f 	call	0x1f4a	; 0x1f4a <eeprom_write_block_changes>
	sei();
    1fb2:	78 94       	sei
	
	Beeper_Beep(BEEP_LONG,1);	
    1fb4:	8c eb       	ldi	r24, 0xBC	; 188
    1fb6:	92 e0       	ldi	r25, 0x02	; 2
    1fb8:	61 e0       	ldi	r22, 0x01	; 1
    1fba:	0e 94 99 0b 	call	0x1732	; 0x1732 <Beeper_Beep>
}
    1fbe:	08 95       	ret

00001fc0 <Save_Default_Config_to_EEPROM>:

void Save_Default_Config_to_EEPROM (void)
{
	
	// copy default config to config.
	Set_EEPROM_Default_Config();
    1fc0:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <Set_EEPROM_Default_Config>
    1fc4:	e0 e6       	ldi	r30, 0x60	; 96
    1fc6:	f7 e0       	ldi	r31, 0x07	; 7

	// Init values.
	for (uint8_t i = 0; i < RXChannels; i++)
	{
		Config.RX_Mid[0][i] = PWM_MID;
    1fc8:	20 ef       	ldi	r18, 0xF0	; 240
    1fca:	35 e0       	ldi	r19, 0x05	; 5
		Config.RX_Min[0][i] = PWM_LOW;
    1fcc:	80 e6       	ldi	r24, 0x60	; 96
    1fce:	94 e0       	ldi	r25, 0x04	; 4
	Set_EEPROM_Default_Config();

	// Init values.
	for (uint8_t i = 0; i < RXChannels; i++)
	{
		Config.RX_Mid[0][i] = PWM_MID;
    1fd0:	21 93       	st	Z+, r18
    1fd2:	31 93       	st	Z+, r19
		Config.RX_Min[0][i] = PWM_LOW;
    1fd4:	93 8b       	std	Z+19, r25	; 0x13
    1fd6:	82 8b       	std	Z+18, r24	; 0x12
		Config.RX_Mid[1][i] = PWM_MID;
    1fd8:	31 87       	std	Z+9, r19	; 0x09
    1fda:	20 87       	std	Z+8, r18	; 0x08
		Config.RX_Min[1][i] = PWM_LOW;
    1fdc:	95 8f       	std	Z+29, r25	; 0x1d
    1fde:	84 8f       	std	Z+28, r24	; 0x1c
	
	// copy default config to config.
	Set_EEPROM_Default_Config();

	// Init values.
	for (uint8_t i = 0; i < RXChannels; i++)
    1fe0:	47 e0       	ldi	r20, 0x07	; 7
    1fe2:	ea 36       	cpi	r30, 0x6A	; 106
    1fe4:	f4 07       	cpc	r31, r20
    1fe6:	a1 f7       	brne	.-24     	; 0x1fd0 <Save_Default_Config_to_EEPROM+0x10>
		Config.RX_Min[1][i] = PWM_LOW;
	}
	
	
	// write to eeProm
	Save_Config_to_EEPROM();
    1fe8:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <Save_Config_to_EEPROM>
}
    1fec:	08 95       	ret

00001fee <Initial_EEPROM_Config_Load>:


void Initial_EEPROM_Config_Load(void)
{
	
	eeprom_read_block(&Config, (void*) EEPROM_DATA_START_POS, sizeof(config_t)); 
    1fee:	8b ee       	ldi	r24, 0xEB	; 235
    1ff0:	96 e0       	ldi	r25, 0x06	; 6
    1ff2:	60 e0       	ldi	r22, 0x00	; 0
    1ff4:	70 e0       	ldi	r23, 0x00	; 0
    1ff6:	49 ec       	ldi	r20, 0xC9	; 201
    1ff8:	50 e0       	ldi	r21, 0x00	; 0
    1ffa:	0e 94 03 39 	call	0x7206	; 0x7206 <__eerd_block_m324pa>
	
	// load up last settings from EEPROM
	if(
    1ffe:	80 91 eb 06 	lds	r24, 0x06EB
    2002:	8e 3f       	cpi	r24, 0xFE	; 254
    2004:	41 f4       	brne	.+16     	; 0x2016 <Initial_EEPROM_Config_Load+0x28>
		(Config.signature != HEFNYCOPTER2_SIGNATURE)
		#ifdef REQUIRE_FACTORY_RESET
		||		
    2006:	80 91 ec 06 	lds	r24, 0x06EC
    200a:	90 91 ed 06 	lds	r25, 0x06ED
    200e:	21 e0       	ldi	r18, 0x01	; 1
    2010:	80 39       	cpi	r24, 0x90	; 144
    2012:	92 07       	cpc	r25, r18
    2014:	19 f0       	breq	.+6      	; 0x201c <Initial_EEPROM_Config_Load+0x2e>
		(Config.Version  != VERSION_16INT)
		#endif
	  )		
	{
		Save_Default_Config_to_EEPROM();
    2016:	0e 94 e0 0f 	call	0x1fc0	; 0x1fc0 <Save_Default_Config_to_EEPROM>
    201a:	08 95       	ret
		
	} else {
		// read eeprom
		eeprom_read_block(&Config, (void*) EEPROM_DATA_START_POS, sizeof(config_t)); 
    201c:	8b ee       	ldi	r24, 0xEB	; 235
    201e:	96 e0       	ldi	r25, 0x06	; 6
    2020:	60 e0       	ldi	r22, 0x00	; 0
    2022:	70 e0       	ldi	r23, 0x00	; 0
    2024:	49 ec       	ldi	r20, 0xC9	; 201
    2026:	50 e0       	ldi	r21, 0x00	; 0
    2028:	0e 94 03 39 	call	0x7206	; 0x7206 <__eerd_block_m324pa>
    202c:	08 95       	ret

0000202e <__vector_15>:
*/

//volatile uint32_t x=0;

ISR(TIMER1_OVF_vect)
{
    202e:	1f 92       	push	r1
    2030:	0f 92       	push	r0
    2032:	0f b6       	in	r0, 0x3f	; 63
    2034:	0f 92       	push	r0
    2036:	11 24       	eor	r1, r1
    2038:	8f 93       	push	r24
    203a:	9f 93       	push	r25
	
	TCNT1_X++; // click every 0.0032768 sec [1 sec = 305.17578125 TCNT1_X] overflows every 214.7483648 sec = 3.579 min
    203c:	80 91 74 06 	lds	r24, 0x0674
    2040:	90 91 75 06 	lds	r25, 0x0675
    2044:	01 96       	adiw	r24, 0x01	; 1
    2046:	90 93 75 06 	sts	0x0675, r25
    204a:	80 93 74 06 	sts	0x0674, r24
	//TCNT1_X_GlobalTimer +=32;  // 0.0032768
}
    204e:	9f 91       	pop	r25
    2050:	8f 91       	pop	r24
    2052:	0f 90       	pop	r0
    2054:	0f be       	out	0x3f, r0	; 63
    2056:	0f 90       	pop	r0
    2058:	1f 90       	pop	r1
    205a:	18 95       	reti

0000205c <__vector_11>:


ISR(TIMER2_OVF_vect)
{
    205c:	1f 92       	push	r1
    205e:	0f 92       	push	r0
    2060:	0f b6       	in	r0, 0x3f	; 63
    2062:	0f 92       	push	r0
    2064:	11 24       	eor	r1, r1
    2066:	8f 93       	push	r24
    2068:	9f 93       	push	r25
	TCNT2_X++; 
    206a:	80 91 bf 05 	lds	r24, 0x05BF
    206e:	90 91 c0 05 	lds	r25, 0x05C0
    2072:	01 96       	adiw	r24, 0x01	; 1
    2074:	90 93 c0 05 	sts	0x05C0, r25
    2078:	80 93 bf 05 	sts	0x05BF, r24
}	
    207c:	9f 91       	pop	r25
    207e:	8f 91       	pop	r24
    2080:	0f 90       	pop	r0
    2082:	0f be       	out	0x3f, r0	; 63
    2084:	0f 90       	pop	r0
    2086:	1f 90       	pop	r1
    2088:	18 95       	reti

0000208a <Timer_Init>:
{
	
	//TIMER ZERO is RESERVED for LCD DISPLAY.	
	
	// Timer1 @20MHz with overflow interrupt
	TCCR1B = _BV(CS10);
    208a:	81 e0       	ldi	r24, 0x01	; 1
    208c:	80 93 81 00 	sts	0x0081, r24
	TIMSK1 = _BV(TOIE1);
    2090:	80 93 6f 00 	sts	0x006F, r24
	TCNT1_X =0;
    2094:	10 92 75 06 	sts	0x0675, r1
    2098:	10 92 74 06 	sts	0x0674, r1
			1 0 0		clkT2S/64 (From prescaler)
			1 0 1		clkT2S/128 (From prescaler)
			1 1 0		clkT2S/256 (From prescaler)
			1 1 1		clkT2S/1024 (From prescaler)
	*/
	TCCR2B  = (1 << CS21) | (1 << CS20);	//  div by 32	
    209c:	93 e0       	ldi	r25, 0x03	; 3
    209e:	90 93 b1 00 	sts	0x00B1, r25
	TIMSK2  = _BV(TOIE2); 
    20a2:	80 93 70 00 	sts	0x0070, r24
	TIFR2   = 0;
    20a6:	17 ba       	out	0x17, r1	; 23
	TCNT2	= 0;		// this overflows every  1.6us x 0xff = 409.6 us,  value tick 1.6us
    20a8:	10 92 b2 00 	sts	0x00B2, r1
	TCNT2_X = 0;
    20ac:	10 92 c0 05 	sts	0x05C0, r1
    20b0:	10 92 bf 05 	sts	0x05BF, r1
	/* IMPORTANT TCNT2 is used completly by motor and is reset during ESC pulse generation so you cannot depend on it for other purpose
	unless it is not time critical and no accuracy is required such as UI delays*/
	// tick: 12.8u  ov:3.2768ms	: TCNT2_X OV:  214.7483648 sec

    20b4:	08 95       	ret

000020b6 <UART_Init>:
	
}

void UART_Init( unsigned int ubrr)
{
	if (Config.RX_mode==RX_mode_UARTMode)
    20b6:	20 91 ef 06 	lds	r18, 0x06EF
    20ba:	2f 3f       	cpi	r18, 0xFF	; 255
    20bc:	61 f4       	brne	.+24     	; 0x20d6 <UART_Init+0x20>
	{
		//memcpy(DisplayBuffer,"STR",3);
		RXIndex=0;
    20be:	10 92 2d 05 	sts	0x052D, r1
		/*Set baud rate */
		UBRR1H = (unsigned char)(ubrr>>8);	
    20c2:	90 93 cd 00 	sts	0x00CD, r25
		UBRR1L = (unsigned char)ubrr;
    20c6:	80 93 cc 00 	sts	0x00CC, r24
		
		//UCSR1A = (1 << U2X1); // doubling divisor rate;
		// Set frame format to 8 data bits, no parity, 1 stop bit
		UCSR1C = (0<<USBS1)|(1<<UCSZ11)|(1<<UCSZ10);
    20ca:	86 e0       	ldi	r24, 0x06	; 6
    20cc:	80 93 ca 00 	sts	0x00CA, r24
		// Enable receiver and transmitter
		UCSR1B =  (1<<TXEN1)	// Enable USART TX
    20d0:	88 e9       	ldi	r24, 0x98	; 152
    20d2:	80 93 c9 00 	sts	0x00C9, r24
    20d6:	08 95       	ret

000020d8 <send_byte>:

void send_byte(uint8_t u8Data)
{

	// Wait if a byte is being transmitted
	while((UCSR1A & (1<<UDRE1)) == 0);
    20d8:	90 91 c8 00 	lds	r25, 0x00C8
    20dc:	95 ff       	sbrs	r25, 5
    20de:	fc cf       	rjmp	.-8      	; 0x20d8 <send_byte>
	// Transmit data
	/////////delay_ms(10);
	UDR1 = u8Data;
    20e0:	80 93 ce 00 	sts	0x00CE, r24
}
    20e4:	08 95       	ret

000020e6 <Send_Data>:


void Send_Data (void * msg, uint8_t len)
{
    20e6:	ef 92       	push	r14
    20e8:	ff 92       	push	r15
    20ea:	0f 93       	push	r16
    20ec:	1f 93       	push	r17
    20ee:	cf 93       	push	r28
    20f0:	df 93       	push	r29
	
	for (int i=0; i<len;++i)
    20f2:	08 2f       	mov	r16, r24
    20f4:	19 2f       	mov	r17, r25
    20f6:	c0 e0       	ldi	r28, 0x00	; 0
    20f8:	d0 e0       	ldi	r29, 0x00	; 0
    20fa:	e6 2e       	mov	r14, r22
    20fc:	ff 24       	eor	r15, r15
    20fe:	06 c0       	rjmp	.+12     	; 0x210c <Send_Data+0x26>
	{
		send_byte (((uint8_t *)msg)[i]);
    2100:	f8 01       	movw	r30, r16
    2102:	81 91       	ld	r24, Z+
    2104:	8f 01       	movw	r16, r30
    2106:	0e 94 6c 10 	call	0x20d8	; 0x20d8 <send_byte>


void Send_Data (void * msg, uint8_t len)
{
	
	for (int i=0; i<len;++i)
    210a:	21 96       	adiw	r28, 0x01	; 1
    210c:	ce 15       	cp	r28, r14
    210e:	df 05       	cpc	r29, r15
    2110:	bc f3       	brlt	.-18     	; 0x2100 <Send_Data+0x1a>
	{
		send_byte (((uint8_t *)msg)[i]);
	}
	
	
}
    2112:	df 91       	pop	r29
    2114:	cf 91       	pop	r28
    2116:	1f 91       	pop	r17
    2118:	0f 91       	pop	r16
    211a:	ff 90       	pop	r15
    211c:	ef 90       	pop	r14
    211e:	08 95       	ret

00002120 <ParseCommand>:
}


void ParseCommand ()
{
	if (IsArmed==true)
    2120:	80 91 cc 07 	lds	r24, 0x07CC
    2124:	81 30       	cpi	r24, 0x01	; 1
    2126:	09 f4       	brne	.+2      	; 0x212a <ParseCommand+0xa>
    2128:	69 c0       	rjmp	.+210    	; 0x21fc <ParseCommand+0xdc>
    212a:	80 e0       	ldi	r24, 0x00	; 0
    212c:	90 e0       	ldi	r25, 0x00	; 0
    212e:	20 e0       	ldi	r18, 0x00	; 0
		return ;
	}		
	int8_t CRC=0;
	for (int i=0;i < SERIAL_BUFFERSIZE_1; ++i)
	{
		CRC +=RXBuffer[i];
    2130:	fc 01       	movw	r30, r24
    2132:	e3 52       	subi	r30, 0x23	; 35
    2134:	f8 4f       	sbci	r31, 0xF8	; 248
    2136:	30 81       	ld	r19, Z
    2138:	23 0f       	add	r18, r19
	{
		//Just ignore for safty reasons....some commands generate beeps or flash led that call delay function which will crash your quadcopter if called.
		return ;
	}		
	int8_t CRC=0;
	for (int i=0;i < SERIAL_BUFFERSIZE_1; ++i)
    213a:	01 96       	adiw	r24, 0x01	; 1
    213c:	88 30       	cpi	r24, 0x08	; 8
    213e:	91 05       	cpc	r25, r1
    2140:	b9 f7       	brne	.-18     	; 0x2130 <ParseCommand+0x10>
	{
		CRC +=RXBuffer[i];
	}
	if (CRC == (int8_t)RXBuffer[SERIAL_CRC_OFFSET])
    2142:	80 91 e5 07 	lds	r24, 0x07E5
    2146:	28 17       	cp	r18, r24
    2148:	09 f0       	breq	.+2      	; 0x214c <ParseCommand+0x2c>
    214a:	58 c0       	rjmp	.+176    	; 0x21fc <ParseCommand+0xdc>
	{
		switch (RXBuffer[SERIAL_HEADER])
    214c:	80 91 dd 07 	lds	r24, 0x07DD
    2150:	83 34       	cpi	r24, 0x43	; 67
    2152:	21 f0       	breq	.+8      	; 0x215c <ParseCommand+0x3c>
    2154:	86 35       	cpi	r24, 0x56	; 86
    2156:	09 f0       	breq	.+2      	; 0x215a <ParseCommand+0x3a>
    2158:	51 c0       	rjmp	.+162    	; 0x21fc <ParseCommand+0xdc>
    215a:	37 c0       	rjmp	.+110    	; 0x21ca <ParseCommand+0xaa>
		{
			case SERIAL_HEADER_DOCMD:
				switch (RXBuffer[SERIAL_CMD_ID])
    215c:	80 91 de 07 	lds	r24, 0x07DE
    2160:	85 30       	cpi	r24, 0x05	; 5
    2162:	e9 f0       	breq	.+58     	; 0x219e <ParseCommand+0x7e>
    2164:	86 30       	cpi	r24, 0x06	; 6
    2166:	30 f4       	brcc	.+12     	; 0x2174 <ParseCommand+0x54>
    2168:	81 30       	cpi	r24, 0x01	; 1
    216a:	51 f0       	breq	.+20     	; 0x2180 <ParseCommand+0x60>
    216c:	82 30       	cpi	r24, 0x02	; 2
    216e:	09 f0       	breq	.+2      	; 0x2172 <ParseCommand+0x52>
    2170:	45 c0       	rjmp	.+138    	; 0x21fc <ParseCommand+0xdc>
    2172:	0c c0       	rjmp	.+24     	; 0x218c <ParseCommand+0x6c>
    2174:	86 30       	cpi	r24, 0x06	; 6
    2176:	19 f1       	breq	.+70     	; 0x21be <ParseCommand+0x9e>
    2178:	87 30       	cpi	r24, 0x07	; 7
    217a:	09 f0       	breq	.+2      	; 0x217e <ParseCommand+0x5e>
    217c:	3f c0       	rjmp	.+126    	; 0x21fc <ParseCommand+0xdc>
    217e:	22 c0       	rjmp	.+68     	; 0x21c4 <ParseCommand+0xa4>
				{
					case SERIAL_CMD_LED_BLINK: // never  call while ARMED .... calling delay function will affect motor speed.
						LED_FlashOrangeLED (LED_SHORT_TOGGLE,4);
    2180:	8e e1       	ldi	r24, 0x1E	; 30
    2182:	90 e0       	ldi	r25, 0x00	; 0
    2184:	64 e0       	ldi	r22, 0x04	; 4
    2186:	0e 94 9b 0e 	call	0x1d36	; 0x1d36 <LED_FlashOrangeLED>
					break;
    218a:	08 95       	ret
					case SERIAL_CMD_PID_CONFIG:
						Send_Data("C",1);
    218c:	80 e0       	ldi	r24, 0x00	; 0
    218e:	91 e0       	ldi	r25, 0x01	; 1
    2190:	61 e0       	ldi	r22, 0x01	; 1
    2192:	0e 94 73 10 	call	0x20e6	; 0x20e6 <Send_Data>
						Send_Data(&(Config.GyroParams),98);
    2196:	8b ef       	ldi	r24, 0xFB	; 251
    2198:	96 e0       	ldi	r25, 0x06	; 6
    219a:	62 e6       	ldi	r22, 0x62	; 98
    219c:	08 c0       	rjmp	.+16     	; 0x21ae <ParseCommand+0x8e>
						Send_Data("E",1);
					break;
					case SERIAL_CMD_READ_CONFIG: // BAD
						Send_Data("C",1);
    219e:	80 e0       	ldi	r24, 0x00	; 0
    21a0:	91 e0       	ldi	r25, 0x01	; 1
    21a2:	61 e0       	ldi	r22, 0x01	; 1
    21a4:	0e 94 73 10 	call	0x20e6	; 0x20e6 <Send_Data>
						Send_Data(&Config,86);
    21a8:	8b ee       	ldi	r24, 0xEB	; 235
    21aa:	96 e0       	ldi	r25, 0x06	; 6
    21ac:	66 e5       	ldi	r22, 0x56	; 86
    21ae:	0e 94 73 10 	call	0x20e6	; 0x20e6 <Send_Data>
						Send_Data("E",1);
    21b2:	82 e0       	ldi	r24, 0x02	; 2
    21b4:	91 e0       	ldi	r25, 0x01	; 1
    21b6:	61 e0       	ldi	r22, 0x01	; 1
    21b8:	0e 94 73 10 	call	0x20e6	; 0x20e6 <Send_Data>
					break;
    21bc:	08 95       	ret
					case SERIAL_CMD_SAVE_CONFIG:
						Save_Config_to_EEPROM();
    21be:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <Save_Config_to_EEPROM>
					break;
    21c2:	08 95       	ret
					case SERIAL_CMD_CALIBRATE_ACC:
						Sensors_Calibrate();								
    21c4:	0e 94 d4 26 	call	0x4da8	; 0x4da8 <Sensors_Calibrate>
					break;
    21c8:	08 95       	ret
				}
			break;
			case SERIAL_HEADER_SETVALUE:
				//LED_FlashOrangeLED (LED_SHORT_TOGGLE,4);
				memcpy ((void *)&Config + RXBuffer[SERIAL_DATA_OFFSET] + (RXBuffer[SERIAL_DATA_OFFSET+1] * 0xff),(void *) &RXBuffer[SERIAL_DATA_VALUE], (int8_t) RXBuffer[SERIAL_DATA_LENGHT]);
    21ca:	80 91 de 07 	lds	r24, 0x07DE
    21ce:	60 91 df 07 	lds	r22, 0x07DF
    21d2:	40 91 e0 07 	lds	r20, 0x07E0
    21d6:	9f ef       	ldi	r25, 0xFF	; 255
    21d8:	69 9f       	mul	r22, r25
    21da:	b0 01       	movw	r22, r0
    21dc:	11 24       	eor	r1, r1
    21de:	68 0f       	add	r22, r24
    21e0:	71 1d       	adc	r23, r1
    21e2:	65 51       	subi	r22, 0x15	; 21
    21e4:	79 4f       	sbci	r23, 0xF9	; 249
    21e6:	24 2f       	mov	r18, r20
    21e8:	33 27       	eor	r19, r19
    21ea:	27 fd       	sbrc	r18, 7
    21ec:	30 95       	com	r19
    21ee:	e1 ee       	ldi	r30, 0xE1	; 225
    21f0:	f7 e0       	ldi	r31, 0x07	; 7
    21f2:	cb 01       	movw	r24, r22
    21f4:	bf 01       	movw	r22, r30
    21f6:	53 2f       	mov	r21, r19
    21f8:	0e 94 b8 38 	call	0x7170	; 0x7170 <memcpy>
    21fc:	08 95       	ret

000021fe <__vector_28>:
  
  
void ParseCommand();

ISR (USART1_RX_vect)
{
    21fe:	1f 92       	push	r1
    2200:	0f 92       	push	r0
    2202:	0f b6       	in	r0, 0x3f	; 63
    2204:	0f 92       	push	r0
    2206:	11 24       	eor	r1, r1
    2208:	2f 93       	push	r18
    220a:	3f 93       	push	r19
    220c:	4f 93       	push	r20
    220e:	5f 93       	push	r21
    2210:	6f 93       	push	r22
    2212:	7f 93       	push	r23
    2214:	8f 93       	push	r24
    2216:	9f 93       	push	r25
    2218:	af 93       	push	r26
    221a:	bf 93       	push	r27
    221c:	ef 93       	push	r30
    221e:	ff 93       	push	r31
	 while ( !(UCSR1A & (1<<RXC1))); 
    2220:	80 91 c8 00 	lds	r24, 0x00C8
    2224:	87 ff       	sbrs	r24, 7
    2226:	fc cf       	rjmp	.-8      	; 0x2220 <__vector_28+0x22>
	 RXChar = UDR1;
    2228:	80 91 ce 00 	lds	r24, 0x00CE
    222c:	80 93 d8 07 	sts	0x07D8, r24
	 
	  if ((c_state!=IDLE) && (TCNT1_X - LastRXTime) > 20) 
    2230:	80 91 2e 05 	lds	r24, 0x052E
    2234:	88 23       	and	r24, r24
    2236:	99 f0       	breq	.+38     	; 0x225e <__vector_28+0x60>
    2238:	80 91 74 06 	lds	r24, 0x0674
    223c:	90 91 75 06 	lds	r25, 0x0675
    2240:	20 91 d9 07 	lds	r18, 0x07D9
    2244:	30 91 da 07 	lds	r19, 0x07DA
    2248:	82 1b       	sub	r24, r18
    224a:	93 0b       	sbc	r25, r19
    224c:	85 31       	cpi	r24, 0x15	; 21
    224e:	91 05       	cpc	r25, r1
    2250:	30 f0       	brcs	.+12     	; 0x225e <__vector_28+0x60>
	   {
		   // timeout ..
		   c_state = IDLE;
    2252:	10 92 2e 05 	sts	0x052E, r1
		   RXIndex =0;
    2256:	10 92 2d 05 	sts	0x052D, r1
		   DisplayBuffer[4]=0;
    225a:	10 92 d2 07 	sts	0x07D2, r1
		   //memcpy(DisplayBuffer,"OUT",3);
		   //return ;
	   }
	   RXBuffer[RXIndex]=RXChar;
    225e:	e0 91 2d 05 	lds	r30, 0x052D
    2262:	f0 e0       	ldi	r31, 0x00	; 0
    2264:	80 91 d8 07 	lds	r24, 0x07D8
    2268:	e3 52       	subi	r30, 0x23	; 35
    226a:	f8 4f       	sbci	r31, 0xF8	; 248
    226c:	80 83       	st	Z, r24
	   switch (c_state)
    226e:	80 91 2e 05 	lds	r24, 0x052E
    2272:	88 23       	and	r24, r24
    2274:	19 f0       	breq	.+6      	; 0x227c <__vector_28+0x7e>
    2276:	81 30       	cpi	r24, 0x01	; 1
    2278:	c1 f4       	brne	.+48     	; 0x22aa <__vector_28+0xac>
    227a:	06 c0       	rjmp	.+12     	; 0x2288 <__vector_28+0x8a>
	   {
		   case IDLE:
		   // Waiting for new command
			   RXIndex=0;
    227c:	10 92 2d 05 	sts	0x052D, r1
			   
			   
			   c_state = HEADER_RX;
    2280:	81 e0       	ldi	r24, 0x01	; 1
    2282:	80 93 2e 05 	sts	0x052E, r24
    2286:	07 c0       	rjmp	.+14     	; 0x2296 <__vector_28+0x98>
		   break;
		   
		   case HEADER_RX:
		   // Copy Data
				
			    if (RXIndex==SERIAL_BUFFERSIZE_1)
    2288:	80 91 2d 05 	lds	r24, 0x052D
    228c:	88 30       	cpi	r24, 0x08	; 8
    228e:	19 f4       	brne	.+6      	; 0x2296 <__vector_28+0x98>
				{
					ParseCommand();
    2290:	0e 94 90 10 	call	0x2120	; 0x2120 <ParseCommand>
    2294:	0a c0       	rjmp	.+20     	; 0x22aa <__vector_28+0xac>
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    2296:	f8 94       	cli
				}
				else
				{
					ATOMIC_BLOCK(ATOMIC_FORCEON)
				   {
					 LastRXTime = TCNT1_X;
    2298:	80 91 74 06 	lds	r24, 0x0674
    229c:	90 91 75 06 	lds	r25, 0x0675
    22a0:	90 93 da 07 	sts	0x07DA, r25
    22a4:	80 93 d9 07 	sts	0x07D9, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    22a8:	78 94       	sei
				   }
				}								
		   break;
	   }
	
	 RXIndex+=1;
    22aa:	80 91 2d 05 	lds	r24, 0x052D
    22ae:	8f 5f       	subi	r24, 0xFF	; 255
    22b0:	80 93 2d 05 	sts	0x052D, r24
	 if (RXIndex==SERIAL_BUFFERSIZE) 
    22b4:	80 91 2d 05 	lds	r24, 0x052D
    22b8:	89 30       	cpi	r24, 0x09	; 9
    22ba:	21 f4       	brne	.+8      	; 0x22c4 <__vector_28+0xc6>
	 {
		RXIndex=0;
    22bc:	10 92 2d 05 	sts	0x052D, r1
		c_state = IDLE;
    22c0:	10 92 2e 05 	sts	0x052E, r1
	 }		
}
    22c4:	ff 91       	pop	r31
    22c6:	ef 91       	pop	r30
    22c8:	bf 91       	pop	r27
    22ca:	af 91       	pop	r26
    22cc:	9f 91       	pop	r25
    22ce:	8f 91       	pop	r24
    22d0:	7f 91       	pop	r23
    22d2:	6f 91       	pop	r22
    22d4:	5f 91       	pop	r21
    22d6:	4f 91       	pop	r20
    22d8:	3f 91       	pop	r19
    22da:	2f 91       	pop	r18
    22dc:	0f 90       	pop	r0
    22de:	0f be       	out	0x3f, r0	; 63
    22e0:	0f 90       	pop	r0
    22e2:	1f 90       	pop	r1
    22e4:	18 95       	reti

000022e6 <Send_Data_TEST>:
	
	
}

void Send_Data_TEST (void * msg, uint8_t len)
{
    22e6:	ef 92       	push	r14
    22e8:	ff 92       	push	r15
    22ea:	0f 93       	push	r16
    22ec:	1f 93       	push	r17
    22ee:	cf 93       	push	r28
    22f0:	df 93       	push	r29
	for (int i=0; i<len;++i)
    22f2:	08 2f       	mov	r16, r24
    22f4:	19 2f       	mov	r17, r25
    22f6:	c0 e0       	ldi	r28, 0x00	; 0
    22f8:	d0 e0       	ldi	r29, 0x00	; 0
    22fa:	e6 2e       	mov	r14, r22
    22fc:	ff 24       	eor	r15, r15
    22fe:	06 c0       	rjmp	.+12     	; 0x230c <Send_Data_TEST+0x26>
	{
		send_byte (((uint8_t *)msg)[i]);
    2300:	f8 01       	movw	r30, r16
    2302:	81 91       	ld	r24, Z+
    2304:	8f 01       	movw	r16, r30
    2306:	0e 94 6c 10 	call	0x20d8	; 0x20d8 <send_byte>
	
}

void Send_Data_TEST (void * msg, uint8_t len)
{
	for (int i=0; i<len;++i)
    230a:	21 96       	adiw	r28, 0x01	; 1
    230c:	ce 15       	cp	r28, r14
    230e:	df 05       	cpc	r29, r15
    2310:	bc f3       	brlt	.-18     	; 0x2300 <Send_Data_TEST+0x1a>
	{
		send_byte (((uint8_t *)msg)[i]);
	}
	
    2312:	df 91       	pop	r29
    2314:	cf 91       	pop	r28
    2316:	1f 91       	pop	r17
    2318:	0f 91       	pop	r16
    231a:	ff 90       	pop	r15
    231c:	ef 90       	pop	r14
    231e:	08 95       	ret

00002320 <_font12x16selector>:
	*/
};

static PGM_P _font12x16selector(unsigned char c)
{
	return (PGM_P) _font12x16map + (c - 0x20) * BYTESPERCHAR;
    2320:	90 e0       	ldi	r25, 0x00	; 0
    2322:	80 97       	sbiw	r24, 0x20	; 32
    2324:	9c 01       	movw	r18, r24
    2326:	22 0f       	add	r18, r18
    2328:	33 1f       	adc	r19, r19
    232a:	28 0f       	add	r18, r24
    232c:	39 1f       	adc	r19, r25
    232e:	83 e0       	ldi	r24, 0x03	; 3
    2330:	22 0f       	add	r18, r18
    2332:	33 1f       	adc	r19, r19
    2334:	8a 95       	dec	r24
    2336:	e1 f7       	brne	.-8      	; 0x2330 <_font12x16selector+0x10>
    2338:	23 5a       	subi	r18, 0xA3	; 163
    233a:	3e 4f       	sbci	r19, 0xFE	; 254
}
    233c:	c9 01       	movw	r24, r18
    233e:	08 95       	ret

00002340 <_font6x8selector>:
	*/
};

static PGM_P _font6x8selector(unsigned char c)
{
	return (PGM_P) _font6x8map + (c - 0x20) * BYTESPERCHAR;
    2340:	90 e0       	ldi	r25, 0x00	; 0
    2342:	80 97       	sbiw	r24, 0x20	; 32
    2344:	9c 01       	movw	r18, r24
    2346:	22 0f       	add	r18, r18
    2348:	33 1f       	adc	r19, r19
    234a:	28 0f       	add	r18, r24
    234c:	39 1f       	adc	r19, r25
    234e:	22 0f       	add	r18, r18
    2350:	33 1f       	adc	r19, r19
    2352:	2f 59       	subi	r18, 0x9F	; 159
    2354:	38 4f       	sbci	r19, 0xF8	; 248
}
    2356:	c9 01       	movw	r24, r18
    2358:	08 95       	ret

0000235a <Setup>:
static uint8_t FlyingModesToggle;

void Setup (void)
{
	
	Menu_EnableAllItems();
    235a:	0e 94 27 36 	call	0x6c4e	; 0x6c4e <Menu_EnableAllItems>
	
	Initial_EEPROM_Config_Load();
    235e:	0e 94 f7 0f 	call	0x1fee	; 0x1fee <Initial_EEPROM_Config_Load>
	
	//Config.QuadFlyingMode = QuadFlyingMode_PLUS;
	
	RX_Init();
    2362:	0e 94 0e 24 	call	0x481c	; 0x481c <RX_Init>
	if ((Config.RX_mode==RX_mode_UARTMode) && (IS_MISC_SENSOR_SONAR_ENABLED==true))
    2366:	80 91 ef 06 	lds	r24, 0x06EF
    236a:	8f 3f       	cpi	r24, 0xFF	; 255
    236c:	31 f4       	brne	.+12     	; 0x237a <Setup+0x20>
    236e:	80 91 fa 06 	lds	r24, 0x06FA
    2372:	80 ff       	sbrs	r24, 0
    2374:	02 c0       	rjmp	.+4      	; 0x237a <Setup+0x20>
	{
		Ultrasonic_Init();
    2376:	0e 94 10 0f 	call	0x1e20	; 0x1e20 <Ultrasonic_Init>
	}		
	// Motors
	M1_DIR = OUTPUT;
    237a:	3e 9a       	sbi	0x07, 6	; 7
	M2_DIR = OUTPUT;
    237c:	3c 9a       	sbi	0x07, 4	; 7
	M3_DIR = OUTPUT;
    237e:	3a 9a       	sbi	0x07, 2	; 7
	M4_DIR = OUTPUT;
    2380:	3b 9a       	sbi	0x07, 3	; 7
	M1 = 0;
    2382:	46 98       	cbi	0x08, 6	; 8
	M2 = 0;
    2384:	44 98       	cbi	0x08, 4	; 8
	M3 = 0;
    2386:	42 98       	cbi	0x08, 2	; 8
	M4 = 0;
    2388:	43 98       	cbi	0x08, 3	; 8
	
	Buzzer_DIR = OUTPUT;
    238a:	21 9a       	sbi	0x04, 1	; 4
	LED_Orange_DIR = OUTPUT;
    238c:	23 9a       	sbi	0x04, 3	; 4
	
	
	// Sensors
	V_BAT  = INPUT;
    238e:	13 98       	cbi	0x02, 3	; 2
	
	
	
	// Timers
	TCCR1A = 0;	//Set timer 1 to run at 2.5MHz
    2390:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;
    2394:	10 92 81 00 	sts	0x0081, r1
	TCCR1C = 0;
    2398:	10 92 82 00 	sts	0x0082, r1
	

if (Config.RX_mode==RX_mode_UARTMode)
    239c:	80 91 ef 06 	lds	r24, 0x06EF
    23a0:	8f 3f       	cpi	r24, 0xFF	; 255
    23a2:	21 f4       	brne	.+8      	; 0x23ac <Setup+0x52>
{
	UART_Init(SERIAL_BAUD_RATE); //57600 = 20   115200=10
    23a4:	8a e0       	ldi	r24, 0x0A	; 10
    23a6:	90 e0       	ldi	r25, 0x00	; 0
    23a8:	0e 94 5b 10 	call	0x20b6	; 0x20b6 <UART_Init>
}	



	ADCPort_Init();
    23ac:	0e 94 6c 28 	call	0x50d8	; 0x50d8 <ADCPort_Init>
	Sensors_Init();
    23b0:	0e 94 95 26 	call	0x4d2a	; 0x4d2a <Sensors_Init>
	KeyBoard_Init();
    23b4:	0e 94 b9 0b 	call	0x1772	; 0x1772 <KeyBoard_Init>
	Timer_Init();
    23b8:	0e 94 45 10 	call	0x208a	; 0x208a <Timer_Init>
	
	LCD_Init();
    23bc:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <LCD_Init>
	LCD_Clear();
    23c0:	0e 94 48 0c 	call	0x1890	; 0x1890 <LCD_Clear>
	
	Menu_MenuInit();
    23c4:	0e 94 1f 36 	call	0x6c3e	; 0x6c3e <Menu_MenuInit>
	
		
	
	
	sei();
    23c8:	78 94       	sei
	
	delay_ms(30);
    23ca:	8e e1       	ldi	r24, 0x1E	; 30
    23cc:	90 e0       	ldi	r25, 0x00	; 0
    23ce:	0e 94 fd 0e 	call	0x1dfa	; 0x1dfa <delay_ms>
    
}
    23d2:	08 95       	ret

000023d4 <Loop>:
	We are in this loop because the system is not calibrated.
	This is the minimum functionality.
*/
void Loop(void)
{
	RX_CopyLatestReceiverValues(); // update RX_Latest also IS_TXn_GOOD
    23d4:	0e 94 45 25 	call	0x4a8a	; 0x4a8a <RX_CopyLatestReceiverValues>
	
	if (TCNT_X_snapshot2==0) TCNT_X_snapshot2 = TCNT2_X;
    23d8:	80 91 ec 05 	lds	r24, 0x05EC
    23dc:	90 91 ed 05 	lds	r25, 0x05ED
    23e0:	00 97       	sbiw	r24, 0x00	; 0
    23e2:	41 f4       	brne	.+16     	; 0x23f4 <Loop+0x20>
    23e4:	80 91 bf 05 	lds	r24, 0x05BF
    23e8:	90 91 c0 05 	lds	r25, 0x05C0
    23ec:	90 93 ed 05 	sts	0x05ED, r25
    23f0:	80 93 ec 05 	sts	0x05EC, r24
	if ( (TCNT2_X- TCNT_X_snapshot2) > LCD_RefreashRate )  
    23f4:	80 91 bf 05 	lds	r24, 0x05BF
    23f8:	90 91 c0 05 	lds	r25, 0x05C0
    23fc:	20 91 ec 05 	lds	r18, 0x05EC
    2400:	30 91 ed 05 	lds	r19, 0x05ED
    2404:	82 1b       	sub	r24, r18
    2406:	93 0b       	sbc	r25, r19
    2408:	8b 30       	cpi	r24, 0x0B	; 11
    240a:	91 05       	cpc	r25, r1
    240c:	30 f0       	brcs	.+12     	; 0x241a <Loop+0x46>
	{
		Menu_MenuShow();	
    240e:	0e 94 dc 35 	call	0x6bb8	; 0x6bb8 <Menu_MenuShow>
		TCNT_X_snapshot2=0;
    2412:	10 92 ed 05 	sts	0x05ED, r1
    2416:	10 92 ec 05 	sts	0x05EC, r1
    241a:	08 95       	ret

0000241c <LoopESCCalibration>:
}

void LoopESCCalibration (void)
{
	
	Menu_LoadPage(PAGE_HOME_ESC_CALIBRATION);
    241c:	83 e0       	ldi	r24, 0x03	; 3
    241e:	0e 94 b9 2c 	call	0x5972	; 0x5972 <Menu_LoadPage>
	while (1)
	{
		Loop();
    2422:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <Loop>
    2426:	fd cf       	rjmp	.-6      	; 0x2422 <LoopESCCalibration+0x6>

00002428 <LoopCalibration>:
// Never go to MainLoop "fly loop" unless Sensors & RX is calibrated.
// This loop to protect against any bug that might make the quad start or KB stick click
// as in this case crash is a must.
void LoopCalibration (void)
{
	menuEnabled[PAGE_STABILIZATION] =0;
    2428:	10 92 eb 07 	sts	0x07EB, r1
	menuEnabled[PAGE_SELF_LEVELING] =0;
    242c:	10 92 ec 07 	sts	0x07EC, r1
	menuEnabled[PAGE_ALT_HOLD]		=0;
    2430:	10 92 ed 07 	sts	0x07ED, r1
	menuEnabled[PAGE_MISC_SETTING]  =0;
    2434:	10 92 ef 07 	sts	0x07EF, r1
	menuEnabled[PAGE_ESC_CALIBRATION]=0; // u cannot make ESC Calibration as sticks are not ready for testing.
    2438:	10 92 f4 07 	sts	0x07F4, r1
		
	while (!(Config.IsCalibrated & CALIBRATED_SENSOR) || !(Config.IsCalibrated & CALIBRATED_Stick_SECONDARY))
    243c:	02 c0       	rjmp	.+4      	; 0x2442 <LoopCalibration+0x1a>
	{	
		Loop();
    243e:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <Loop>
	menuEnabled[PAGE_SELF_LEVELING] =0;
	menuEnabled[PAGE_ALT_HOLD]		=0;
	menuEnabled[PAGE_MISC_SETTING]  =0;
	menuEnabled[PAGE_ESC_CALIBRATION]=0; // u cannot make ESC Calibration as sticks are not ready for testing.
		
	while (!(Config.IsCalibrated & CALIBRATED_SENSOR) || !(Config.IsCalibrated & CALIBRATED_Stick_SECONDARY))
    2442:	80 91 ee 06 	lds	r24, 0x06EE
    2446:	82 ff       	sbrs	r24, 2
    2448:	fa cf       	rjmp	.-12     	; 0x243e <LoopCalibration+0x16>
    244a:	81 ff       	sbrs	r24, 1
    244c:	f8 cf       	rjmp	.-16     	; 0x243e <LoopCalibration+0x16>
	{	
		Loop();
	}
}
    244e:	08 95       	ret

00002450 <HandleSticksForArming>:
// This function is never called if there is a calibration issue.
// called in true section of if (RX_Snapshot[RXChannel_THR] < STICKThrottle_ARMING) 
void HandleSticksForArming (void)
{
	
	if ((UIEnableStickCommands==false) || (ActiveRXIndex!=1) || (!IS_TX2_GOOD)) return ; // you cannot use Primary to Arm and Disarm
    2450:	80 91 e9 05 	lds	r24, 0x05E9
    2454:	88 23       	and	r24, r24
    2456:	09 f4       	brne	.+2      	; 0x245a <HandleSticksForArming+0xa>
    2458:	6c c1       	rjmp	.+728    	; 0x2732 <HandleSticksForArming+0x2e2>
    245a:	80 91 ce 05 	lds	r24, 0x05CE
    245e:	81 30       	cpi	r24, 0x01	; 1
    2460:	09 f0       	breq	.+2      	; 0x2464 <HandleSticksForArming+0x14>
    2462:	67 c1       	rjmp	.+718    	; 0x2732 <HandleSticksForArming+0x2e2>
    2464:	80 91 ff 07 	lds	r24, 0x07FF
    2468:	80 7f       	andi	r24, 0xF0	; 240
    246a:	09 f0       	breq	.+2      	; 0x246e <HandleSticksForArming+0x1e>
    246c:	62 c1       	rjmp	.+708    	; 0x2732 <HandleSticksForArming+0x2e2>
	SystemErrorType = CLR_SYS_ERR_SIGNAL;
    246e:	80 91 db 06 	lds	r24, 0x06DB
    2472:	8e 7f       	andi	r24, 0xFE	; 254
    2474:	80 93 db 06 	sts	0x06DB, r24
	
	if (TCNT1_X_snapshot1==0)  TCNT1_X_snapshot1 = CurrentTCNT1_X; // start counting
    2478:	80 91 ea 05 	lds	r24, 0x05EA
    247c:	90 91 eb 05 	lds	r25, 0x05EB
    2480:	00 97       	sbiw	r24, 0x00	; 0
    2482:	41 f4       	brne	.+16     	; 0x2494 <HandleSticksForArming+0x44>
    2484:	80 91 6e 06 	lds	r24, 0x066E
    2488:	90 91 6f 06 	lds	r25, 0x066F
    248c:	90 93 eb 05 	sts	0x05EB, r25
    2490:	80 93 ea 05 	sts	0x05EA, r24
		
		// DisArm Check
		if (IsArmed == true) 
    2494:	80 91 cc 07 	lds	r24, 0x07CC
    2498:	81 30       	cpi	r24, 0x01	; 1
    249a:	09 f0       	breq	.+2      	; 0x249e <HandleSticksForArming+0x4e>
    249c:	54 c0       	rjmp	.+168    	; 0x2546 <HandleSticksForArming+0xf6>
		{
			if (RX_Latest[ActiveRXIndex][RXChannel_RUD] > STICK_LEFT)
    249e:	20 91 ce 05 	lds	r18, 0x05CE
    24a2:	82 2f       	mov	r24, r18
    24a4:	90 e0       	ldi	r25, 0x00	; 0
    24a6:	fc 01       	movw	r30, r24
    24a8:	ee 0f       	add	r30, r30
    24aa:	ff 1f       	adc	r31, r31
    24ac:	43 e0       	ldi	r20, 0x03	; 3
    24ae:	88 0f       	add	r24, r24
    24b0:	99 1f       	adc	r25, r25
    24b2:	4a 95       	dec	r20
    24b4:	e1 f7       	brne	.-8      	; 0x24ae <HandleSticksForArming+0x5e>
    24b6:	e8 0f       	add	r30, r24
    24b8:	f9 1f       	adc	r31, r25
    24ba:	ea 5f       	subi	r30, 0xFA	; 250
    24bc:	f9 4f       	sbci	r31, 0xF9	; 249
    24be:	84 81       	ldd	r24, Z+4	; 0x04
    24c0:	95 81       	ldd	r25, Z+5	; 0x05
    24c2:	21 e0       	ldi	r18, 0x01	; 1
    24c4:	81 39       	cpi	r24, 0x91	; 145
    24c6:	92 07       	cpc	r25, r18
    24c8:	84 f0       	brlt	.+32     	; 0x24ea <HandleSticksForArming+0x9a>
			{ // Check DisArming manually.
				bResetTCNR1_X  = false;
    24ca:	10 92 69 06 	sts	0x0669, r1
				if ( (CurrentTCNT1_X - TCNT1_X_snapshot1) > STICKPOSITION_LONG_TIME )
    24ce:	80 91 6e 06 	lds	r24, 0x066E
    24d2:	90 91 6f 06 	lds	r25, 0x066F
    24d6:	20 91 ea 05 	lds	r18, 0x05EA
    24da:	30 91 eb 05 	lds	r19, 0x05EB
    24de:	82 1b       	sub	r24, r18
    24e0:	93 0b       	sbc	r25, r19
    24e2:	21 e0       	ldi	r18, 0x01	; 1
    24e4:	82 33       	cpi	r24, 0x32	; 50
    24e6:	92 07       	cpc	r25, r18
    24e8:	58 f5       	brcc	.+86     	; 0x2540 <HandleSticksForArming+0xf0>
					Disarm();
					return ;
				}
			}
			
			if (Config.AutoDisarm!=0)
    24ea:	60 91 f2 06 	lds	r22, 0x06F2
    24ee:	66 23       	and	r22, r22
    24f0:	09 f4       	brne	.+2      	; 0x24f4 <HandleSticksForArming+0xa4>
    24f2:	1f c1       	rjmp	.+574    	; 0x2732 <HandleSticksForArming+0x2e2>
			{ // check auto disArm
				if (TCNT_X_snapshotAutoDisarm==0) TCNT_X_snapshotAutoDisarm = CurrentTCNT1_X;
    24f4:	80 91 1f 06 	lds	r24, 0x061F
    24f8:	90 91 20 06 	lds	r25, 0x0620
    24fc:	00 97       	sbiw	r24, 0x00	; 0
    24fe:	41 f4       	brne	.+16     	; 0x2510 <HandleSticksForArming+0xc0>
    2500:	80 91 6e 06 	lds	r24, 0x066E
    2504:	90 91 6f 06 	lds	r25, 0x066F
    2508:	90 93 20 06 	sts	0x0620, r25
    250c:	80 93 1f 06 	sts	0x061F, r24
				if ((CurrentTCNT1_X - TCNT_X_snapshotAutoDisarm) > (DISARM_TIME * Config.AutoDisarm))
    2510:	80 91 6e 06 	lds	r24, 0x066E
    2514:	90 91 6f 06 	lds	r25, 0x066F
    2518:	20 91 1f 06 	lds	r18, 0x061F
    251c:	30 91 20 06 	lds	r19, 0x0620
    2520:	82 1b       	sub	r24, r18
    2522:	93 0b       	sbc	r25, r19
    2524:	70 e0       	ldi	r23, 0x00	; 0
    2526:	48 ee       	ldi	r20, 0xE8	; 232
    2528:	53 e0       	ldi	r21, 0x03	; 3
    252a:	64 9f       	mul	r22, r20
    252c:	90 01       	movw	r18, r0
    252e:	65 9f       	mul	r22, r21
    2530:	30 0d       	add	r19, r0
    2532:	74 9f       	mul	r23, r20
    2534:	30 0d       	add	r19, r0
    2536:	11 24       	eor	r1, r1
    2538:	28 17       	cp	r18, r24
    253a:	39 07       	cpc	r19, r25
    253c:	08 f0       	brcs	.+2      	; 0x2540 <HandleSticksForArming+0xf0>
    253e:	f9 c0       	rjmp	.+498    	; 0x2732 <HandleSticksForArming+0x2e2>
				{
					Disarm();
    2540:	0e 94 1a 0f 	call	0x1e34	; 0x1e34 <Disarm>
					return ;
    2544:	08 95       	ret
				}
			}
			
		}			
		
		if (IsArmed == false) 
    2546:	88 23       	and	r24, r24
    2548:	09 f0       	breq	.+2      	; 0x254c <HandleSticksForArming+0xfc>
    254a:	f3 c0       	rjmp	.+486    	; 0x2732 <HandleSticksForArming+0x2e2>
		{
			//int16_t Stick = (Config.RX_Mid[ActiveRXIndex][RXChannel_RUD] + RX_Latest[ActiveRXIndex][RXChannel_RUD] * RX_Div_Factor);
			if (RX_Latest[ActiveRXIndex][RXChannel_RUD]  < STICK_RIGHT)
    254c:	20 91 ce 05 	lds	r18, 0x05CE
    2550:	82 2f       	mov	r24, r18
    2552:	90 e0       	ldi	r25, 0x00	; 0
    2554:	fc 01       	movw	r30, r24
    2556:	ee 0f       	add	r30, r30
    2558:	ff 1f       	adc	r31, r31
    255a:	23 e0       	ldi	r18, 0x03	; 3
    255c:	88 0f       	add	r24, r24
    255e:	99 1f       	adc	r25, r25
    2560:	2a 95       	dec	r18
    2562:	e1 f7       	brne	.-8      	; 0x255c <HandleSticksForArming+0x10c>
    2564:	e8 0f       	add	r30, r24
    2566:	f9 1f       	adc	r31, r25
    2568:	ea 5f       	subi	r30, 0xFA	; 250
    256a:	f9 4f       	sbci	r31, 0xF9	; 249
    256c:	84 81       	ldd	r24, Z+4	; 0x04
    256e:	95 81       	ldd	r25, Z+5	; 0x05
    2570:	2e ef       	ldi	r18, 0xFE	; 254
    2572:	80 37       	cpi	r24, 0x70	; 112
    2574:	92 07       	cpc	r25, r18
    2576:	fc f4       	brge	.+62     	; 0x25b6 <HandleSticksForArming+0x166>
			{	// Armin Check
				bResetTCNR1_X = false;
    2578:	10 92 69 06 	sts	0x0669, r1
				if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_LONG_TIME )
    257c:	80 91 6e 06 	lds	r24, 0x066E
    2580:	90 91 6f 06 	lds	r25, 0x066F
    2584:	20 91 ea 05 	lds	r18, 0x05EA
    2588:	30 91 eb 05 	lds	r19, 0x05EB
    258c:	82 1b       	sub	r24, r18
    258e:	93 0b       	sbc	r25, r19
    2590:	21 e0       	ldi	r18, 0x01	; 1
    2592:	82 33       	cpi	r24, 0x32	; 50
    2594:	92 07       	cpc	r25, r18
    2596:	78 f0       	brcs	.+30     	; 0x25b6 <HandleSticksForArming+0x166>
				{
					if ((Config.RX_mode==RX_mode_BuddyMode) && (!IS_TX1_GOOD)) return; 
    2598:	80 91 ef 06 	lds	r24, 0x06EF
    259c:	88 23       	and	r24, r24
    259e:	41 f4       	brne	.+16     	; 0x25b0 <HandleSticksForArming+0x160>
    25a0:	80 91 ff 07 	lds	r24, 0x07FF
    25a4:	90 e0       	ldi	r25, 0x00	; 0
    25a6:	8f 70       	andi	r24, 0x0F	; 15
    25a8:	90 70       	andi	r25, 0x00	; 0
    25aa:	00 97       	sbiw	r24, 0x00	; 0
    25ac:	09 f0       	breq	.+2      	; 0x25b0 <HandleSticksForArming+0x160>
    25ae:	c1 c0       	rjmp	.+386    	; 0x2732 <HandleSticksForArming+0x2e2>
					// in Buddy mode you cannot arm is there is no signal from TX1
					
					Arm();
    25b0:	0e 94 2b 0f 	call	0x1e56	; 0x1e56 <Arm>
					return ;
    25b4:	08 95       	ret
				}
			}					
		
			//set modes Quad , X-Quad
		
			if (RX_Latest[ActiveRXIndex][RXChannel_AIL]  > STICK_LEFT)
    25b6:	20 91 ce 05 	lds	r18, 0x05CE
    25ba:	82 2f       	mov	r24, r18
    25bc:	90 e0       	ldi	r25, 0x00	; 0
    25be:	fc 01       	movw	r30, r24
    25c0:	ee 0f       	add	r30, r30
    25c2:	ff 1f       	adc	r31, r31
    25c4:	a3 e0       	ldi	r26, 0x03	; 3
    25c6:	88 0f       	add	r24, r24
    25c8:	99 1f       	adc	r25, r25
    25ca:	aa 95       	dec	r26
    25cc:	e1 f7       	brne	.-8      	; 0x25c6 <HandleSticksForArming+0x176>
    25ce:	e8 0f       	add	r30, r24
    25d0:	f9 1f       	adc	r31, r25
    25d2:	ea 5f       	subi	r30, 0xFA	; 250
    25d4:	f9 4f       	sbci	r31, 0xF9	; 249
    25d6:	80 81       	ld	r24, Z
    25d8:	91 81       	ldd	r25, Z+1	; 0x01
    25da:	21 e0       	ldi	r18, 0x01	; 1
    25dc:	81 39       	cpi	r24, 0x91	; 145
    25de:	92 07       	cpc	r25, r18
    25e0:	ac f0       	brlt	.+42     	; 0x260c <HandleSticksForArming+0x1bc>
			{// X-QUAD MODE
				bResetTCNR1_X = false;
    25e2:	10 92 69 06 	sts	0x0669, r1
				if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_LONG_TIME )
    25e6:	80 91 6e 06 	lds	r24, 0x066E
    25ea:	90 91 6f 06 	lds	r25, 0x066F
    25ee:	20 91 ea 05 	lds	r18, 0x05EA
    25f2:	30 91 eb 05 	lds	r19, 0x05EB
    25f6:	82 1b       	sub	r24, r18
    25f8:	93 0b       	sbc	r25, r19
    25fa:	21 e0       	ldi	r18, 0x01	; 1
    25fc:	82 33       	cpi	r24, 0x32	; 50
    25fe:	92 07       	cpc	r25, r18
    2600:	08 f4       	brcc	.+2      	; 0x2604 <HandleSticksForArming+0x1b4>
    2602:	97 c0       	rjmp	.+302    	; 0x2732 <HandleSticksForArming+0x2e2>
				{
					Config.QuadFlyingMode=QuadFlyingMode_X;
    2604:	81 e0       	ldi	r24, 0x01	; 1
    2606:	80 93 f6 06 	sts	0x06F6, r24
    260a:	57 c0       	rjmp	.+174    	; 0x26ba <HandleSticksForArming+0x26a>
					LED_FlashOrangeLED (LED_LONG_TOGGLE,8);
					TCNT1_X_snapshot1 =0; // reset timer
				}
			}			
			else if ((RX_Latest[ActiveRXIndex][RXChannel_AIL]  < STICK_RIGHT))
    260c:	20 91 ce 05 	lds	r18, 0x05CE
    2610:	82 2f       	mov	r24, r18
    2612:	90 e0       	ldi	r25, 0x00	; 0
    2614:	fc 01       	movw	r30, r24
    2616:	ee 0f       	add	r30, r30
    2618:	ff 1f       	adc	r31, r31
    261a:	63 e0       	ldi	r22, 0x03	; 3
    261c:	88 0f       	add	r24, r24
    261e:	99 1f       	adc	r25, r25
    2620:	6a 95       	dec	r22
    2622:	e1 f7       	brne	.-8      	; 0x261c <HandleSticksForArming+0x1cc>
    2624:	e8 0f       	add	r30, r24
    2626:	f9 1f       	adc	r31, r25
    2628:	ea 5f       	subi	r30, 0xFA	; 250
    262a:	f9 4f       	sbci	r31, 0xF9	; 249
    262c:	80 81       	ld	r24, Z
    262e:	91 81       	ldd	r25, Z+1	; 0x01
    2630:	2e ef       	ldi	r18, 0xFE	; 254
    2632:	80 37       	cpi	r24, 0x70	; 112
    2634:	92 07       	cpc	r25, r18
    2636:	bc f4       	brge	.+46     	; 0x2666 <HandleSticksForArming+0x216>
				{	// QUAD COPTER MODE
					bResetTCNR1_X = false;
    2638:	10 92 69 06 	sts	0x0669, r1
					if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_LONG_TIME )
    263c:	80 91 6e 06 	lds	r24, 0x066E
    2640:	90 91 6f 06 	lds	r25, 0x066F
    2644:	20 91 ea 05 	lds	r18, 0x05EA
    2648:	30 91 eb 05 	lds	r19, 0x05EB
    264c:	82 1b       	sub	r24, r18
    264e:	93 0b       	sbc	r25, r19
    2650:	21 e0       	ldi	r18, 0x01	; 1
    2652:	82 33       	cpi	r24, 0x32	; 50
    2654:	92 07       	cpc	r25, r18
    2656:	08 f4       	brcc	.+2      	; 0x265a <HandleSticksForArming+0x20a>
    2658:	6c c0       	rjmp	.+216    	; 0x2732 <HandleSticksForArming+0x2e2>
					{
						Config.QuadFlyingMode=QuadFlyingMode_PLUS;
    265a:	10 92 f6 06 	sts	0x06F6, r1
						LED_FlashOrangeLED (LED_LONG_TOGGLE,4);
    265e:	80 e5       	ldi	r24, 0x50	; 80
    2660:	90 e0       	ldi	r25, 0x00	; 0
    2662:	64 e0       	ldi	r22, 0x04	; 4
    2664:	2d c0       	rjmp	.+90     	; 0x26c0 <HandleSticksForArming+0x270>
					}		
			
				} 
				
			// set mode ACRO , Leveling
			else if ((RX_Latest[ActiveRXIndex][RXChannel_ELE]  < STICK_RIGHT))
    2666:	20 91 ce 05 	lds	r18, 0x05CE
    266a:	82 2f       	mov	r24, r18
    266c:	90 e0       	ldi	r25, 0x00	; 0
    266e:	fc 01       	movw	r30, r24
    2670:	ee 0f       	add	r30, r30
    2672:	ff 1f       	adc	r31, r31
    2674:	43 e0       	ldi	r20, 0x03	; 3
    2676:	88 0f       	add	r24, r24
    2678:	99 1f       	adc	r25, r25
    267a:	4a 95       	dec	r20
    267c:	e1 f7       	brne	.-8      	; 0x2676 <HandleSticksForArming+0x226>
    267e:	e8 0f       	add	r30, r24
    2680:	f9 1f       	adc	r31, r25
    2682:	ea 5f       	subi	r30, 0xFA	; 250
    2684:	f9 4f       	sbci	r31, 0xF9	; 249
    2686:	82 81       	ldd	r24, Z+2	; 0x02
    2688:	93 81       	ldd	r25, Z+3	; 0x03
    268a:	2e ef       	ldi	r18, 0xFE	; 254
    268c:	80 37       	cpi	r24, 0x70	; 112
    268e:	92 07       	cpc	r25, r18
    2690:	f4 f4       	brge	.+60     	; 0x26ce <HandleSticksForArming+0x27e>
				{	//nFlyingModes = FLYINGMODE_LEVEL;
					bResetTCNR1_X = false;
    2692:	10 92 69 06 	sts	0x0669, r1
					if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_LONG_TIME )
    2696:	80 91 6e 06 	lds	r24, 0x066E
    269a:	90 91 6f 06 	lds	r25, 0x066F
    269e:	20 91 ea 05 	lds	r18, 0x05EA
    26a2:	30 91 eb 05 	lds	r19, 0x05EB
    26a6:	82 1b       	sub	r24, r18
    26a8:	93 0b       	sbc	r25, r19
    26aa:	21 e0       	ldi	r18, 0x01	; 1
    26ac:	82 33       	cpi	r24, 0x32	; 50
    26ae:	92 07       	cpc	r25, r18
    26b0:	08 f4       	brcc	.+2      	; 0x26b4 <HandleSticksForArming+0x264>
    26b2:	3f c0       	rjmp	.+126    	; 0x2732 <HandleSticksForArming+0x2e2>
					{
						nFlyingModes = FLYINGMODE_LEVEL;
    26b4:	82 e0       	ldi	r24, 0x02	; 2
    26b6:	80 93 1e 06 	sts	0x061E, r24
						LED_FlashOrangeLED (LED_LONG_TOGGLE,8);
    26ba:	80 e5       	ldi	r24, 0x50	; 80
    26bc:	90 e0       	ldi	r25, 0x00	; 0
    26be:	68 e0       	ldi	r22, 0x08	; 8
    26c0:	0e 94 9b 0e 	call	0x1d36	; 0x1d36 <LED_FlashOrangeLED>
						TCNT1_X_snapshot1 =0; // reset timer
    26c4:	10 92 eb 05 	sts	0x05EB, r1
    26c8:	10 92 ea 05 	sts	0x05EA, r1
    26cc:	08 95       	ret
					}		
			
				} 
			else if ((RX_Latest[ActiveRXIndex][RXChannel_ELE]  > STICK_LEFT))
    26ce:	20 91 ce 05 	lds	r18, 0x05CE
    26d2:	82 2f       	mov	r24, r18
    26d4:	90 e0       	ldi	r25, 0x00	; 0
    26d6:	fc 01       	movw	r30, r24
    26d8:	ee 0f       	add	r30, r30
    26da:	ff 1f       	adc	r31, r31
    26dc:	23 e0       	ldi	r18, 0x03	; 3
    26de:	88 0f       	add	r24, r24
    26e0:	99 1f       	adc	r25, r25
    26e2:	2a 95       	dec	r18
    26e4:	e1 f7       	brne	.-8      	; 0x26de <HandleSticksForArming+0x28e>
    26e6:	e8 0f       	add	r30, r24
    26e8:	f9 1f       	adc	r31, r25
    26ea:	ea 5f       	subi	r30, 0xFA	; 250
    26ec:	f9 4f       	sbci	r31, 0xF9	; 249
    26ee:	82 81       	ldd	r24, Z+2	; 0x02
    26f0:	93 81       	ldd	r25, Z+3	; 0x03
    26f2:	21 e0       	ldi	r18, 0x01	; 1
    26f4:	81 39       	cpi	r24, 0x91	; 145
    26f6:	92 07       	cpc	r25, r18
    26f8:	e4 f0       	brlt	.+56     	; 0x2732 <HandleSticksForArming+0x2e2>
				{	//nFlyingModes = FLYINGMODE_ACRO;
					bResetTCNR1_X = false;
    26fa:	10 92 69 06 	sts	0x0669, r1
					if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_LONG_TIME )
    26fe:	80 91 6e 06 	lds	r24, 0x066E
    2702:	90 91 6f 06 	lds	r25, 0x066F
    2706:	20 91 ea 05 	lds	r18, 0x05EA
    270a:	30 91 eb 05 	lds	r19, 0x05EB
    270e:	82 1b       	sub	r24, r18
    2710:	93 0b       	sbc	r25, r19
    2712:	21 e0       	ldi	r18, 0x01	; 1
    2714:	82 33       	cpi	r24, 0x32	; 50
    2716:	92 07       	cpc	r25, r18
    2718:	60 f0       	brcs	.+24     	; 0x2732 <HandleSticksForArming+0x2e2>
					{
						nFlyingModes = FLYINGMODE_ACRO;
    271a:	81 e0       	ldi	r24, 0x01	; 1
    271c:	80 93 1e 06 	sts	0x061E, r24
						LED_FlashOrangeLED (LED_LONG_TOGGLE,4);
    2720:	80 e5       	ldi	r24, 0x50	; 80
    2722:	90 e0       	ldi	r25, 0x00	; 0
    2724:	64 e0       	ldi	r22, 0x04	; 4
    2726:	0e 94 9b 0e 	call	0x1d36	; 0x1d36 <LED_FlashOrangeLED>
						TCNT1_X_snapshot1 =0; // reset timer
    272a:	10 92 eb 05 	sts	0x05EB, r1
    272e:	10 92 ea 05 	sts	0x05EA, r1
    2732:	08 95       	ret

00002734 <HandleSticksAsKeys>:

// This function is never called if there is a calibration issue.
// called in FALSE section of if (RX_Snapshot[RXChannel_THR] < STICKThrottle_ARMING) 
void HandleSticksAsKeys (void)
{
		if ((UIEnableStickCommands==false) || (!IS_TX2_GOOD))  return ; // you cannot use Primary as keys
    2734:	80 91 e9 05 	lds	r24, 0x05E9
    2738:	88 23       	and	r24, r24
    273a:	09 f4       	brne	.+2      	; 0x273e <HandleSticksAsKeys+0xa>
    273c:	87 c0       	rjmp	.+270    	; 0x284c <HandleSticksAsKeys+0x118>
    273e:	80 91 ff 07 	lds	r24, 0x07FF
    2742:	80 7f       	andi	r24, 0xF0	; 240
    2744:	09 f0       	breq	.+2      	; 0x2748 <HandleSticksAsKeys+0x14>
    2746:	82 c0       	rjmp	.+260    	; 0x284c <HandleSticksAsKeys+0x118>

		// if Throttle is high and stick are calibrated
		
		if (TCNT1_X_snapshot1==0)  TCNT1_X_snapshot1 = CurrentTCNT1_X; // start counting
    2748:	80 91 ea 05 	lds	r24, 0x05EA
    274c:	90 91 eb 05 	lds	r25, 0x05EB
    2750:	00 97       	sbiw	r24, 0x00	; 0
    2752:	41 f4       	brne	.+16     	; 0x2764 <HandleSticksAsKeys+0x30>
    2754:	80 91 6e 06 	lds	r24, 0x066E
    2758:	90 91 6f 06 	lds	r25, 0x066F
    275c:	90 93 eb 05 	sts	0x05EB, r25
    2760:	80 93 ea 05 	sts	0x05EA, r24
				
	 	if ((RX_Latest[RX_MAIN][RXChannel_ELE]) > STICK_LEFT) 
    2764:	80 91 12 06 	lds	r24, 0x0612
    2768:	90 91 13 06 	lds	r25, 0x0613
    276c:	21 e0       	ldi	r18, 0x01	; 1
    276e:	81 39       	cpi	r24, 0x91	; 145
    2770:	92 07       	cpc	r25, r18
    2772:	8c f0       	brlt	.+34     	; 0x2796 <HandleSticksAsKeys+0x62>
		{
			bResetTCNR1_X = false;
    2774:	10 92 69 06 	sts	0x0669, r1
			if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_SHORT_TIME )
    2778:	80 91 6e 06 	lds	r24, 0x066E
    277c:	90 91 6f 06 	lds	r25, 0x066F
    2780:	20 91 ea 05 	lds	r18, 0x05EA
    2784:	30 91 eb 05 	lds	r19, 0x05EB
    2788:	82 1b       	sub	r24, r18
    278a:	93 0b       	sbc	r25, r19
    278c:	81 35       	cpi	r24, 0x51	; 81
    278e:	91 05       	cpc	r25, r1
    2790:	00 f1       	brcs	.+64     	; 0x27d2 <HandleSticksAsKeys+0x9e>
			{
				_TXKeys = KEY_3;
    2792:	80 e2       	ldi	r24, 0x20	; 32
    2794:	18 c0       	rjmp	.+48     	; 0x27c6 <HandleSticksAsKeys+0x92>
				TCNT1_X_snapshot1 =0; // reset timer
			}		
		
		}
		else if ((RX_Latest[RX_MAIN][RXChannel_ELE]) < STICK_RIGHT) 
    2796:	80 91 12 06 	lds	r24, 0x0612
    279a:	90 91 13 06 	lds	r25, 0x0613
    279e:	2e ef       	ldi	r18, 0xFE	; 254
    27a0:	80 37       	cpi	r24, 0x70	; 112
    27a2:	92 07       	cpc	r25, r18
    27a4:	b4 f4       	brge	.+44     	; 0x27d2 <HandleSticksAsKeys+0x9e>
		{
			bResetTCNR1_X = false;
    27a6:	10 92 69 06 	sts	0x0669, r1
			if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_SHORT_TIME )
    27aa:	80 91 6e 06 	lds	r24, 0x066E
    27ae:	90 91 6f 06 	lds	r25, 0x066F
    27b2:	20 91 ea 05 	lds	r18, 0x05EA
    27b6:	30 91 eb 05 	lds	r19, 0x05EB
    27ba:	82 1b       	sub	r24, r18
    27bc:	93 0b       	sbc	r25, r19
    27be:	81 35       	cpi	r24, 0x51	; 81
    27c0:	91 05       	cpc	r25, r1
    27c2:	38 f0       	brcs	.+14     	; 0x27d2 <HandleSticksAsKeys+0x9e>
			{
				_TXKeys = KEY_2;
    27c4:	80 e4       	ldi	r24, 0x40	; 64
    27c6:	80 93 da 06 	sts	0x06DA, r24
				TCNT1_X_snapshot1 =0; // reset timer
    27ca:	10 92 eb 05 	sts	0x05EB, r1
    27ce:	10 92 ea 05 	sts	0x05EA, r1
			}		
		
		}		 	 
		
		if ((RX_Latest[RX_MAIN][RXChannel_AIL]) > STICK_LEFT) 
    27d2:	80 91 10 06 	lds	r24, 0x0610
    27d6:	90 91 11 06 	lds	r25, 0x0611
    27da:	21 e0       	ldi	r18, 0x01	; 1
    27dc:	81 39       	cpi	r24, 0x91	; 145
    27de:	92 07       	cpc	r25, r18
    27e0:	bc f0       	brlt	.+46     	; 0x2810 <HandleSticksAsKeys+0xdc>
		{
			bResetTCNR1_X = false;
    27e2:	10 92 69 06 	sts	0x0669, r1
			if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_SHORT_TIME )
    27e6:	80 91 6e 06 	lds	r24, 0x066E
    27ea:	90 91 6f 06 	lds	r25, 0x066F
    27ee:	20 91 ea 05 	lds	r18, 0x05EA
    27f2:	30 91 eb 05 	lds	r19, 0x05EB
    27f6:	82 1b       	sub	r24, r18
    27f8:	93 0b       	sbc	r25, r19
    27fa:	81 35       	cpi	r24, 0x51	; 81
    27fc:	91 05       	cpc	r25, r1
    27fe:	30 f1       	brcs	.+76     	; 0x284c <HandleSticksAsKeys+0x118>
			{
				_TXKeys = KEY_4;
    2800:	80 e1       	ldi	r24, 0x10	; 16
    2802:	80 93 da 06 	sts	0x06DA, r24
				TCNT1_X_snapshot1 =0; // reset timer
    2806:	10 92 eb 05 	sts	0x05EB, r1
    280a:	10 92 ea 05 	sts	0x05EA, r1
    280e:	08 95       	ret
			}		
		
		}
		else if ((RX_Latest[RX_MAIN][RXChannel_AIL]) < STICK_RIGHT) 
    2810:	80 91 10 06 	lds	r24, 0x0610
    2814:	90 91 11 06 	lds	r25, 0x0611
    2818:	2e ef       	ldi	r18, 0xFE	; 254
    281a:	80 37       	cpi	r24, 0x70	; 112
    281c:	92 07       	cpc	r25, r18
    281e:	b4 f4       	brge	.+44     	; 0x284c <HandleSticksAsKeys+0x118>
		{
			bResetTCNR1_X = false;
    2820:	10 92 69 06 	sts	0x0669, r1
			if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_SHORT_TIME )
    2824:	80 91 6e 06 	lds	r24, 0x066E
    2828:	90 91 6f 06 	lds	r25, 0x066F
    282c:	20 91 ea 05 	lds	r18, 0x05EA
    2830:	30 91 eb 05 	lds	r19, 0x05EB
    2834:	82 1b       	sub	r24, r18
    2836:	93 0b       	sbc	r25, r19
    2838:	81 35       	cpi	r24, 0x51	; 81
    283a:	91 05       	cpc	r25, r1
    283c:	38 f0       	brcs	.+14     	; 0x284c <HandleSticksAsKeys+0x118>
			{
				_TXKeys = KEY_1;
    283e:	80 e8       	ldi	r24, 0x80	; 128
    2840:	80 93 da 06 	sts	0x06DA, r24
				TCNT1_X_snapshot1 =0; // reset timer
    2844:	10 92 eb 05 	sts	0x05EB, r1
    2848:	10 92 ea 05 	sts	0x05EA, r1
    284c:	08 95       	ret

0000284e <ZEROMotors>:
/*
// STOPS MOTORS IMMEDIATLY
*/
void ZEROMotors()
{
	MotorOut[0] = 0;
    284e:	10 92 9b 05 	sts	0x059B, r1
    2852:	10 92 9a 05 	sts	0x059A, r1
	MotorOut[1] = 0;
    2856:	10 92 9d 05 	sts	0x059D, r1
    285a:	10 92 9c 05 	sts	0x059C, r1
	MotorOut[2] = 0;
    285e:	10 92 9f 05 	sts	0x059F, r1
    2862:	10 92 9e 05 	sts	0x059E, r1
	if (Config.FrameType == FRAMETYPE_TRICOPTER)
    2866:	80 91 f4 06 	lds	r24, 0x06F4
    286a:	82 30       	cpi	r24, 0x02	; 2
    286c:	39 f4       	brne	.+14     	; 0x287c <ZEROMotors+0x2e>
	{
		MotorOut[3] = SERVO_IN_MIDDLE;
    286e:	86 e2       	ldi	r24, 0x26	; 38
    2870:	92 e0       	ldi	r25, 0x02	; 2
    2872:	90 93 a1 05 	sts	0x05A1, r25
    2876:	80 93 a0 05 	sts	0x05A0, r24
    287a:	04 c0       	rjmp	.+8      	; 0x2884 <ZEROMotors+0x36>
	}	
	else
	{
		MotorOut[3] = 0;
    287c:	10 92 a1 05 	sts	0x05A1, r1
    2880:	10 92 a0 05 	sts	0x05A0, r1
	}		
		
	Motor_GenerateOutputSignal();
    2884:	0e 94 97 22 	call	0x452e	; 0x452e <Motor_GenerateOutputSignal>
    2888:	08 95       	ret

0000288a <MainLoop>:
	This is the main loop of the application.
*/

static uint16_t LowpassOutYaw;
void MainLoop(void)
{
    288a:	8f 92       	push	r8
    288c:	9f 92       	push	r9
    288e:	af 92       	push	r10
    2890:	bf 92       	push	r11
    2892:	cf 92       	push	r12
    2894:	df 92       	push	r13
    2896:	ef 92       	push	r14
    2898:	ff 92       	push	r15
    289a:	0f 93       	push	r16
    289c:	1f 93       	push	r17
    289e:	cf 93       	push	r28
    28a0:	df 93       	push	r29
	
	RX_CopyLatestReceiverValues();
    28a2:	0e 94 45 25 	call	0x4a8a	; 0x4a8a <RX_CopyLatestReceiverValues>
	//RX_Snapshot_1 [RXChannel_THR]= RX_Snapshot[RXChannel_THR];
	RX_Snapshot   [RXChannel_THR]= RX_Latest[ActiveRXIndex][RXChannel_THR];
    28a6:	20 91 ce 05 	lds	r18, 0x05CE
    28aa:	82 2f       	mov	r24, r18
    28ac:	90 e0       	ldi	r25, 0x00	; 0
    28ae:	fc 01       	movw	r30, r24
    28b0:	ee 0f       	add	r30, r30
    28b2:	ff 1f       	adc	r31, r31
    28b4:	23 e0       	ldi	r18, 0x03	; 3
    28b6:	88 0f       	add	r24, r24
    28b8:	99 1f       	adc	r25, r25
    28ba:	2a 95       	dec	r18
    28bc:	e1 f7       	brne	.-8      	; 0x28b6 <MainLoop+0x2c>
    28be:	e8 0f       	add	r30, r24
    28c0:	f9 1f       	adc	r31, r25
    28c2:	ea 5f       	subi	r30, 0xFA	; 250
    28c4:	f9 4f       	sbci	r31, 0xF9	; 249
    28c6:	86 81       	ldd	r24, Z+6	; 0x06
    28c8:	97 81       	ldd	r25, Z+7	; 0x07
    28ca:	90 93 c9 05 	sts	0x05C9, r25
    28ce:	80 93 c8 05 	sts	0x05C8, r24
	Sensors_ReadAll();	
    28d2:	0e 94 8f 27 	call	0x4f1e	; 0x4f1e <Sensors_ReadAll>
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    28d6:	f8 94       	cli
	
	
	
	ATOMIC_BLOCK(ATOMIC_FORCEON)
    {
      CurrentTCNT1_X = TCNT1_X;
    28d8:	80 91 74 06 	lds	r24, 0x0674
    28dc:	90 91 75 06 	lds	r25, 0x0675
    28e0:	90 93 6f 06 	sts	0x066F, r25
    28e4:	80 93 6e 06 	sts	0x066E, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    28e8:	78 94       	sei
    }

	IMU();
    28ea:	0e 94 b4 1c 	call	0x3968	; 0x3968 <IMU>
 
	bResetTCNR1_X = true;
    28ee:	21 e0       	ldi	r18, 0x01	; 1
    28f0:	20 93 69 06 	sts	0x0669, r18
	
	
	if (Config.RX_mode==RX_mode_BuddyMode)
    28f4:	80 91 ef 06 	lds	r24, 0x06EF
    28f8:	88 23       	and	r24, r24
    28fa:	89 f4       	brne	.+34     	; 0x291e <MainLoop+0x94>
	{   // in Buddy mode AUX channel is used for instance switching.
		if (IS_TX2_GOOD)
    28fc:	80 91 ff 07 	lds	r24, 0x07FF
    2900:	80 7f       	andi	r24, 0xF0	; 240
    2902:	69 f4       	brne	.+26     	; 0x291e <MainLoop+0x94>
		{
			if (RX_Latest[RX_MAIN][RXChannel_AUX] < STICK_RIGHT)
    2904:	80 91 18 06 	lds	r24, 0x0618
    2908:	90 91 19 06 	lds	r25, 0x0619
    290c:	3e ef       	ldi	r19, 0xFE	; 254
    290e:	80 37       	cpi	r24, 0x70	; 112
    2910:	93 07       	cpc	r25, r19
    2912:	1c f4       	brge	.+6      	; 0x291a <MainLoop+0x90>
			{
				ActiveRXIndex = 0;		// use Primary RX
    2914:	10 92 ce 05 	sts	0x05CE, r1
    2918:	02 c0       	rjmp	.+4      	; 0x291e <MainLoop+0x94>
			}
			else
			{
				ActiveRXIndex = 1;		// use Secondary RX
    291a:	20 93 ce 05 	sts	0x05CE, r18
	
		
	////////// Slow Actions inside
	// HINT: you can try to skip this if flying to save time for more useful tasks as user cannot access menu when flying
	
	if (TCNT_X_snapshot2==0) TCNT_X_snapshot2 = CurrentTCNT1_X;
    291e:	80 91 ec 05 	lds	r24, 0x05EC
    2922:	90 91 ed 05 	lds	r25, 0x05ED
    2926:	20 91 6e 06 	lds	r18, 0x066E
    292a:	30 91 6f 06 	lds	r19, 0x066F
    292e:	00 97       	sbiw	r24, 0x00	; 0
    2930:	29 f4       	brne	.+10     	; 0x293c <MainLoop+0xb2>
    2932:	30 93 ed 05 	sts	0x05ED, r19
    2936:	20 93 ec 05 	sts	0x05EC, r18
    293a:	79 c0       	rjmp	.+242    	; 0x2a2e <MainLoop+0x1a4>
	else if ( ((CurrentTCNT1_X- TCNT_X_snapshot2) > 4) )  // TCNT1_X ticks in 32.768us
    293c:	28 1b       	sub	r18, r24
    293e:	39 0b       	sbc	r19, r25
    2940:	25 30       	cpi	r18, 0x05	; 5
    2942:	31 05       	cpc	r19, r1
    2944:	08 f4       	brcc	.+2      	; 0x2948 <MainLoop+0xbe>
    2946:	73 c0       	rjmp	.+230    	; 0x2a2e <MainLoop+0x1a4>
	{
		Menu_MenuShow();
    2948:	0e 94 dc 35 	call	0x6bb8	; 0x6bb8 <Menu_MenuShow>
		
		if (Config.VoltageAlarm > 0)
    294c:	60 91 5d 07 	lds	r22, 0x075D
    2950:	66 23       	and	r22, r22
    2952:	f1 f0       	breq	.+60     	; 0x2990 <MainLoop+0x106>
		{
			//Sensor_GetBattery();
			if (Sensors_Latest[V_BAT_Index] < Config.VoltageAlarm)
    2954:	e0 90 57 06 	lds	r14, 0x0657
    2958:	f0 90 58 06 	lds	r15, 0x0658
    295c:	00 91 59 06 	lds	r16, 0x0659
    2960:	10 91 5a 06 	lds	r17, 0x065A
    2964:	70 e0       	ldi	r23, 0x00	; 0
    2966:	88 27       	eor	r24, r24
    2968:	77 fd       	sbrc	r23, 7
    296a:	80 95       	com	r24
    296c:	98 2f       	mov	r25, r24
    296e:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    2972:	9b 01       	movw	r18, r22
    2974:	ac 01       	movw	r20, r24
    2976:	c8 01       	movw	r24, r16
    2978:	b7 01       	movw	r22, r14
    297a:	0e 94 97 36 	call	0x6d2e	; 0x6d2e <__cmpsf2>
    297e:	90 91 db 06 	lds	r25, 0x06DB
    2982:	87 ff       	sbrs	r24, 7
    2984:	02 c0       	rjmp	.+4      	; 0x298a <MainLoop+0x100>
			{
				
				SystemErrorType = SET_SYS_ERR_VOLTAGE;
    2986:	92 60       	ori	r25, 0x02	; 2
    2988:	01 c0       	rjmp	.+2      	; 0x298c <MainLoop+0x102>
			}
			else
			{
				SystemErrorType = CLR_SYS_ERR_VOLTAGE;
    298a:	9d 7f       	andi	r25, 0xFD	; 253
    298c:	90 93 db 06 	sts	0x06DB, r25
				
			}
		}	
		if (SystemErrorType != SYS_ERR_NON)
    2990:	80 91 db 06 	lds	r24, 0x06DB
    2994:	88 23       	and	r24, r24
    2996:	51 f0       	breq	.+20     	; 0x29ac <MainLoop+0x122>
		{
			Buzzer =~Buzzer ;	
    2998:	85 b1       	in	r24, 0x05	; 5
    299a:	86 95       	lsr	r24
    299c:	80 95       	com	r24
    299e:	81 70       	andi	r24, 0x01	; 1
    29a0:	88 0f       	add	r24, r24
    29a2:	95 b1       	in	r25, 0x05	; 5
    29a4:	9d 7f       	andi	r25, 0xFD	; 253
    29a6:	98 2b       	or	r25, r24
    29a8:	95 b9       	out	0x05, r25	; 5
    29aa:	01 c0       	rjmp	.+2      	; 0x29ae <MainLoop+0x124>
		}
		else
		{
			Buzzer = OFF;
    29ac:	29 98       	cbi	0x05, 1	; 5
		}
		
		if (Config.RX_mode==RX_mode_UARTMode)
    29ae:	80 91 ef 06 	lds	r24, 0x06EF
    29b2:	8f 3f       	cpi	r24, 0xFF	; 255
    29b4:	c1 f5       	brne	.+112    	; 0x2a26 <MainLoop+0x19c>
		{
				if ((FlyingModesToggle != LOW) && ( RX_Latest[RX_MAIN][RXChannel_AUX] < STICK_RIGHT ))
    29b6:	20 91 2f 05 	lds	r18, 0x052F
    29ba:	22 23       	and	r18, r18
    29bc:	81 f0       	breq	.+32     	; 0x29de <MainLoop+0x154>
    29be:	80 91 18 06 	lds	r24, 0x0618
    29c2:	90 91 19 06 	lds	r25, 0x0619
    29c6:	4e ef       	ldi	r20, 0xFE	; 254
    29c8:	80 37       	cpi	r24, 0x70	; 112
    29ca:	94 07       	cpc	r25, r20
    29cc:	34 f4       	brge	.+12     	; 0x29da <MainLoop+0x150>
				{
					nFlyingModes = FLYINGMODE_ALTHOLD;
    29ce:	84 e0       	ldi	r24, 0x04	; 4
    29d0:	80 93 1e 06 	sts	0x061E, r24
					FlyingModesToggle = LOW;
    29d4:	10 92 2f 05 	sts	0x052F, r1
    29d8:	26 c0       	rjmp	.+76     	; 0x2a26 <MainLoop+0x19c>
				} else
				if ((FlyingModesToggle != HIGH) && (RX_Latest[RX_MAIN][RXChannel_AUX] > STICK_LEFT ))
    29da:	21 30       	cpi	r18, 0x01	; 1
    29dc:	71 f0       	breq	.+28     	; 0x29fa <MainLoop+0x170>
    29de:	80 91 18 06 	lds	r24, 0x0618
    29e2:	90 91 19 06 	lds	r25, 0x0619
    29e6:	51 e0       	ldi	r21, 0x01	; 1
    29e8:	81 39       	cpi	r24, 0x91	; 145
    29ea:	95 07       	cpc	r25, r21
    29ec:	24 f0       	brlt	.+8      	; 0x29f6 <MainLoop+0x16c>
				{
					//LED_Orange=ON;
					nFlyingModes = FLYINGMODE_ACRO;
    29ee:	81 e0       	ldi	r24, 0x01	; 1
    29f0:	80 93 1e 06 	sts	0x061E, r24
    29f4:	16 c0       	rjmp	.+44     	; 0x2a22 <MainLoop+0x198>
					FlyingModesToggle = HIGH;
				} else
				if ((FlyingModesToggle != MID) && (RX_Latest[RX_MAIN][RXChannel_AUX]< STICK_LEFT) && ( RX_Latest[RX_MAIN][RXChannel_AUX] > STICK_RIGHT ))
    29f6:	2b 30       	cpi	r18, 0x0B	; 11
    29f8:	b1 f0       	breq	.+44     	; 0x2a26 <MainLoop+0x19c>
    29fa:	80 91 18 06 	lds	r24, 0x0618
    29fe:	90 91 19 06 	lds	r25, 0x0619
    2a02:	21 e0       	ldi	r18, 0x01	; 1
    2a04:	80 39       	cpi	r24, 0x90	; 144
    2a06:	92 07       	cpc	r25, r18
    2a08:	74 f4       	brge	.+28     	; 0x2a26 <MainLoop+0x19c>
    2a0a:	80 91 18 06 	lds	r24, 0x0618
    2a0e:	90 91 19 06 	lds	r25, 0x0619
    2a12:	3e ef       	ldi	r19, 0xFE	; 254
    2a14:	81 37       	cpi	r24, 0x71	; 113
    2a16:	93 07       	cpc	r25, r19
    2a18:	34 f0       	brlt	.+12     	; 0x2a26 <MainLoop+0x19c>
				{
					nFlyingModes = FLYINGMODE_LEVEL;
    2a1a:	82 e0       	ldi	r24, 0x02	; 2
    2a1c:	80 93 1e 06 	sts	0x061E, r24
					FlyingModesToggle = MID;
    2a20:	8b e0       	ldi	r24, 0x0B	; 11
    2a22:	80 93 2f 05 	sts	0x052F, r24
		}		
		//if ((IsArmed == true) && (RX_Snapshot[RXChannel_THR] < STICKThrottle_ARMING+160))
		//{ // calibrate when start flying
			//DynamicCalibration();
		//}			
		TCNT_X_snapshot2=0;
    2a26:	10 92 ed 05 	sts	0x05ED, r1
    2a2a:	10 92 ec 05 	sts	0x05EC, r1
	}		
	
	//////////////// EOF Slow Loop
	
	if (RX_Snapshot[RXChannel_THR] < STICKThrottle_ARMING) 
    2a2e:	c0 91 c8 05 	lds	r28, 0x05C8
    2a32:	d0 91 c9 05 	lds	r29, 0x05C9
    2a36:	c2 33       	cpi	r28, 0x32	; 50
    2a38:	d1 05       	cpc	r29, r1
    2a3a:	2c f4       	brge	.+10     	; 0x2a46 <MainLoop+0x1bc>
	{	
		
		// Throttle is LOW
		// Here you can add code without caring about delays. As there quad is already off and on land.
		// here we test different positions of sticks to enable arm/disarm, Quad/X-Quad
		HandleSticksForArming();
    2a3c:	0e 94 28 12 	call	0x2450	; 0x2450 <HandleSticksForArming>
		
		// Stop motors if Throttle Stick is less than minimum.
		ZEROMotors();
    2a40:	0e 94 27 14 	call	0x284e	; 0x284e <ZEROMotors>
    2a44:	6b c3       	rjmp	.+1750   	; 0x311c <MainLoop+0x892>
		// DEBUG ONLY //IMU_Reset(); // reset angles for gyro [STABLE MODE]
	}
	else
	{	// Throttle stick is NOT Down .... TAKE CARE
		
		if (IsArmed==false)
    2a46:	80 91 cc 07 	lds	r24, 0x07CC
    2a4a:	88 23       	and	r24, r24
    2a4c:	29 f4       	brne	.+10     	; 0x2a58 <MainLoop+0x1ce>
		{  // However we are still DisArmed
			ZEROMotors();
    2a4e:	0e 94 27 14 	call	0x284e	; 0x284e <ZEROMotors>
			
			// Sticks as Keyboard --- we are already disarmed to reach here.
			HandleSticksAsKeys();
    2a52:	0e 94 9a 13 	call	0x2734	; 0x2734 <HandleSticksAsKeys>
    2a56:	62 c3       	rjmp	.+1732   	; 0x311c <MainLoop+0x892>
		}
		else
		{	// MOTORS ARE ON HERE .... DANGEROUS
			
			
			TCNT_X_snapshotAutoDisarm = 0; // ZERO [user may disarm then fly slowly..in this case the qud will disarm once he turned off the stick...because the counter counts once the quad is armed..e.g. if it takes n sec to disarm automatically..user took n-1 sec keeping the stick low after arming then it will take 1 sec to disarm again after lowing the stick under STICKThrottle_ARMING
    2a58:	10 92 20 06 	sts	0x0620, r1
    2a5c:	10 92 1f 06 	sts	0x061F, r1
			
			// Armed & Throttle Stick > MIN . . . We should Fly now.
			//RX_Snapshot_1 [RXChannel_AIL]= RX_Snapshot[RXChannel_AIL];
			//RX_Snapshot_1 [RXChannel_ELE]= RX_Snapshot[RXChannel_ELE];
			//RX_Snapshot_1 [RXChannel_RUD]= RX_Snapshot[RXChannel_RUD];
			RX_Snapshot	  [RXChannel_AIL] = (RX_Latest[ActiveRXIndex][RXChannel_AIL] * Config.StickScaling * 0.05 );
    2a60:	20 91 ce 05 	lds	r18, 0x05CE
    2a64:	82 2f       	mov	r24, r18
    2a66:	90 e0       	ldi	r25, 0x00	; 0
    2a68:	fc 01       	movw	r30, r24
    2a6a:	ee 0f       	add	r30, r30
    2a6c:	ff 1f       	adc	r31, r31
    2a6e:	13 e0       	ldi	r17, 0x03	; 3
    2a70:	88 0f       	add	r24, r24
    2a72:	99 1f       	adc	r25, r25
    2a74:	1a 95       	dec	r17
    2a76:	e1 f7       	brne	.-8      	; 0x2a70 <MainLoop+0x1e6>
    2a78:	e8 0f       	add	r30, r24
    2a7a:	f9 1f       	adc	r31, r25
    2a7c:	ea 5f       	subi	r30, 0xFA	; 250
    2a7e:	f9 4f       	sbci	r31, 0xF9	; 249
    2a80:	80 81       	ld	r24, Z
    2a82:	91 81       	ldd	r25, Z+1	; 0x01
    2a84:	e0 90 f9 06 	lds	r14, 0x06F9
    2a88:	ff 24       	eor	r15, r15
    2a8a:	e8 9e       	mul	r14, r24
    2a8c:	b0 01       	movw	r22, r0
    2a8e:	e9 9e       	mul	r14, r25
    2a90:	70 0d       	add	r23, r0
    2a92:	f8 9e       	mul	r15, r24
    2a94:	70 0d       	add	r23, r0
    2a96:	11 24       	eor	r1, r1
    2a98:	88 27       	eor	r24, r24
    2a9a:	77 fd       	sbrc	r23, 7
    2a9c:	80 95       	com	r24
    2a9e:	98 2f       	mov	r25, r24
    2aa0:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    2aa4:	2d ec       	ldi	r18, 0xCD	; 205
    2aa6:	3c ec       	ldi	r19, 0xCC	; 204
    2aa8:	4c e4       	ldi	r20, 0x4C	; 76
    2aaa:	5d e3       	ldi	r21, 0x3D	; 61
    2aac:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    2ab0:	0e 94 03 37 	call	0x6e06	; 0x6e06 <__fixsfsi>
    2ab4:	70 93 c3 05 	sts	0x05C3, r23
    2ab8:	60 93 c2 05 	sts	0x05C2, r22
			RX_Snapshot   [RXChannel_ELE] = (RX_Latest[ActiveRXIndex][RXChannel_ELE] * Config.StickScaling * 0.05 ); 
    2abc:	20 91 ce 05 	lds	r18, 0x05CE
    2ac0:	82 2f       	mov	r24, r18
    2ac2:	90 e0       	ldi	r25, 0x00	; 0
    2ac4:	fc 01       	movw	r30, r24
    2ac6:	ee 0f       	add	r30, r30
    2ac8:	ff 1f       	adc	r31, r31
    2aca:	a3 e0       	ldi	r26, 0x03	; 3
    2acc:	88 0f       	add	r24, r24
    2ace:	99 1f       	adc	r25, r25
    2ad0:	aa 95       	dec	r26
    2ad2:	e1 f7       	brne	.-8      	; 0x2acc <MainLoop+0x242>
    2ad4:	e8 0f       	add	r30, r24
    2ad6:	f9 1f       	adc	r31, r25
    2ad8:	ea 5f       	subi	r30, 0xFA	; 250
    2ada:	f9 4f       	sbci	r31, 0xF9	; 249
    2adc:	82 81       	ldd	r24, Z+2	; 0x02
    2ade:	93 81       	ldd	r25, Z+3	; 0x03
    2ae0:	e8 9e       	mul	r14, r24
    2ae2:	b0 01       	movw	r22, r0
    2ae4:	e9 9e       	mul	r14, r25
    2ae6:	70 0d       	add	r23, r0
    2ae8:	f8 9e       	mul	r15, r24
    2aea:	70 0d       	add	r23, r0
    2aec:	11 24       	eor	r1, r1
    2aee:	88 27       	eor	r24, r24
    2af0:	77 fd       	sbrc	r23, 7
    2af2:	80 95       	com	r24
    2af4:	98 2f       	mov	r25, r24
    2af6:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    2afa:	2d ec       	ldi	r18, 0xCD	; 205
    2afc:	3c ec       	ldi	r19, 0xCC	; 204
    2afe:	4c e4       	ldi	r20, 0x4C	; 76
    2b00:	5d e3       	ldi	r21, 0x3D	; 61
    2b02:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    2b06:	0e 94 03 37 	call	0x6e06	; 0x6e06 <__fixsfsi>
    2b0a:	70 93 c5 05 	sts	0x05C5, r23
    2b0e:	60 93 c4 05 	sts	0x05C4, r22
			RX_Snapshot   [RXChannel_RUD] = (RX_Latest[ActiveRXIndex][RXChannel_RUD] * Config.StickScaling * 0.05 ); // version 0.9.9 
    2b12:	20 91 ce 05 	lds	r18, 0x05CE
    2b16:	82 2f       	mov	r24, r18
    2b18:	90 e0       	ldi	r25, 0x00	; 0
    2b1a:	fc 01       	movw	r30, r24
    2b1c:	ee 0f       	add	r30, r30
    2b1e:	ff 1f       	adc	r31, r31
    2b20:	63 e0       	ldi	r22, 0x03	; 3
    2b22:	88 0f       	add	r24, r24
    2b24:	99 1f       	adc	r25, r25
    2b26:	6a 95       	dec	r22
    2b28:	e1 f7       	brne	.-8      	; 0x2b22 <MainLoop+0x298>
    2b2a:	e8 0f       	add	r30, r24
    2b2c:	f9 1f       	adc	r31, r25
    2b2e:	ea 5f       	subi	r30, 0xFA	; 250
    2b30:	f9 4f       	sbci	r31, 0xF9	; 249
    2b32:	84 81       	ldd	r24, Z+4	; 0x04
    2b34:	95 81       	ldd	r25, Z+5	; 0x05
    2b36:	e8 9e       	mul	r14, r24
    2b38:	b0 01       	movw	r22, r0
    2b3a:	e9 9e       	mul	r14, r25
    2b3c:	70 0d       	add	r23, r0
    2b3e:	f8 9e       	mul	r15, r24
    2b40:	70 0d       	add	r23, r0
    2b42:	11 24       	eor	r1, r1
    2b44:	88 27       	eor	r24, r24
    2b46:	77 fd       	sbrc	r23, 7
    2b48:	80 95       	com	r24
    2b4a:	98 2f       	mov	r25, r24
    2b4c:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    2b50:	2d ec       	ldi	r18, 0xCD	; 205
    2b52:	3c ec       	ldi	r19, 0xCC	; 204
    2b54:	4c e4       	ldi	r20, 0x4C	; 76
    2b56:	5d e3       	ldi	r21, 0x3D	; 61
    2b58:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    2b5c:	0e 94 03 37 	call	0x6e06	; 0x6e06 <__fixsfsi>
    2b60:	70 93 c7 05 	sts	0x05C7, r23
    2b64:	60 93 c6 05 	sts	0x05C6, r22
		
			
			// Add Throttle to Motors
			MotorOut[0] = RX_Snapshot[RXChannel_THR];
			MotorOut[1] = RX_Snapshot[RXChannel_THR];
			if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    2b68:	80 91 f4 06 	lds	r24, 0x06F4
    2b6c:	81 30       	cpi	r24, 0x01	; 1
    2b6e:	71 f4       	brne	.+28     	; 0x2b8c <MainLoop+0x302>
				* The logic below depends on board orientation i.e. sensor orientation compared to motor directions.
				* the IMU in ACHRO mode is totally independent from user sticks ... so it does not matter how the user
				* flies his quad i.e. in X or PLUS .... it does not matter because it is handled in another code lines not here.
				* here we handle board orientation only.
				*/
				if (Config.BoardOrientationMode==QuadFlyingMode_X)
    2b70:	40 91 f5 06 	lds	r20, 0x06F5
    2b74:	80 91 39 06 	lds	r24, 0x0639
    2b78:	90 91 3a 06 	lds	r25, 0x063A
    2b7c:	20 91 ba 05 	lds	r18, 0x05BA
    2b80:	30 91 bb 05 	lds	r19, 0x05BB
    2b84:	41 30       	cpi	r20, 0x01	; 1
    2b86:	09 f0       	breq	.+2      	; 0x2b8a <MainLoop+0x300>
    2b88:	57 c0       	rjmp	.+174    	; 0x2c38 <MainLoop+0x3ae>
    2b8a:	34 c0       	rjmp	.+104    	; 0x2bf4 <MainLoop+0x36a>
			}
			else
			{	// Balance Tri-Copter
				// NOT VALID if Board Orientation is X
					
				MotorOut[2] += gyroPitch; // * 1.0;
    2b8c:	60 91 39 06 	lds	r22, 0x0639
    2b90:	70 91 3a 06 	lds	r23, 0x063A
    2b94:	cb 01       	movw	r24, r22
    2b96:	8c 0f       	add	r24, r28
    2b98:	9d 1f       	adc	r25, r29
    2b9a:	90 93 9f 05 	sts	0x059F, r25
    2b9e:	80 93 9e 05 	sts	0x059E, r24
					
				gyroPitch    = gyroPitch * 0.5; // distribute pitch on two front motors .... half the effect. 
    2ba2:	88 27       	eor	r24, r24
    2ba4:	77 fd       	sbrc	r23, 7
    2ba6:	80 95       	com	r24
    2ba8:	98 2f       	mov	r25, r24
    2baa:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    2bae:	20 e0       	ldi	r18, 0x00	; 0
    2bb0:	30 e0       	ldi	r19, 0x00	; 0
    2bb2:	40 e0       	ldi	r20, 0x00	; 0
    2bb4:	5f e3       	ldi	r21, 0x3F	; 63
    2bb6:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    2bba:	0e 94 03 37 	call	0x6e06	; 0x6e06 <__fixsfsi>
    2bbe:	9b 01       	movw	r18, r22
    2bc0:	70 93 3a 06 	sts	0x063A, r23
    2bc4:	60 93 39 06 	sts	0x0639, r22
				MotorOut[0] -= gyroPitch  ;
				MotorOut[1] -= gyroPitch  ;
					
				gyroRoll = gyroRoll; // * 0.85;
    2bc8:	40 91 ba 05 	lds	r20, 0x05BA
    2bcc:	50 91 bb 05 	lds	r21, 0x05BB
				// NOT VALID if Board Orientation is X
					
				MotorOut[2] += gyroPitch; // * 1.0;
					
				gyroPitch    = gyroPitch * 0.5; // distribute pitch on two front motors .... half the effect. 
				MotorOut[0] -= gyroPitch  ;
    2bd0:	ce 01       	movw	r24, r28
    2bd2:	82 1b       	sub	r24, r18
    2bd4:	93 0b       	sbc	r25, r19
				MotorOut[1] -= gyroPitch  ;
					
				gyroRoll = gyroRoll; // * 0.85;
				MotorOut[0] -= gyroRoll  ;
    2bd6:	84 1b       	sub	r24, r20
    2bd8:	95 0b       	sbc	r25, r21
    2bda:	90 93 9b 05 	sts	0x059B, r25
    2bde:	80 93 9a 05 	sts	0x059A, r24
					
				MotorOut[2] += gyroPitch; // * 1.0;
					
				gyroPitch    = gyroPitch * 0.5; // distribute pitch on two front motors .... half the effect. 
				MotorOut[0] -= gyroPitch  ;
				MotorOut[1] -= gyroPitch  ;
    2be2:	c4 0f       	add	r28, r20
    2be4:	d5 1f       	adc	r29, r21
					
				gyroRoll = gyroRoll; // * 0.85;
				MotorOut[0] -= gyroRoll  ;
				MotorOut[1] += gyroRoll  ;
    2be6:	c2 1b       	sub	r28, r18
    2be8:	d3 0b       	sbc	r29, r19
    2bea:	d0 93 9d 05 	sts	0x059D, r29
    2bee:	c0 93 9c 05 	sts	0x059C, r28
    2bf2:	3d c0       	rjmp	.+122    	; 0x2c6e <MainLoop+0x3e4>
				if (Config.BoardOrientationMode==QuadFlyingMode_X)
				{	// Board Orientation in X-Mode
					// {-1,1,1,-1} QUAD_ROL_X
					MotorOut[0] -= gyroRoll ;
					MotorOut[3] -= gyroRoll ;
					MotorOut[1] += gyroRoll ;
    2bf4:	b9 01       	movw	r22, r18
    2bf6:	6c 0f       	add	r22, r28
    2bf8:	7d 1f       	adc	r23, r29
				* here we handle board orientation only.
				*/
				if (Config.BoardOrientationMode==QuadFlyingMode_X)
				{	// Board Orientation in X-Mode
					// {-1,1,1,-1} QUAD_ROL_X
					MotorOut[0] -= gyroRoll ;
    2bfa:	ae 01       	movw	r20, r28
    2bfc:	42 1b       	sub	r20, r18
    2bfe:	53 0b       	sbc	r21, r19
					MotorOut[3] -= gyroRoll ;
					MotorOut[1] += gyroRoll ;
					MotorOut[2] += gyroRoll ;
					
					// {-1,-1,1,1} QUAD_AIL_X
					MotorOut[0] -= gyroPitch;
    2c00:	48 1b       	sub	r20, r24
    2c02:	59 0b       	sbc	r21, r25
    2c04:	50 93 9b 05 	sts	0x059B, r21
    2c08:	40 93 9a 05 	sts	0x059A, r20
					MotorOut[1] -= gyroPitch;
    2c0c:	ab 01       	movw	r20, r22
    2c0e:	48 1b       	sub	r20, r24
    2c10:	59 0b       	sbc	r21, r25
    2c12:	50 93 9d 05 	sts	0x059D, r21
    2c16:	40 93 9c 05 	sts	0x059C, r20
					MotorOut[2] += gyroPitch;
    2c1a:	68 0f       	add	r22, r24
    2c1c:	79 1f       	adc	r23, r25
    2c1e:	70 93 9f 05 	sts	0x059F, r23
    2c22:	60 93 9e 05 	sts	0x059E, r22
				*/
				if (Config.BoardOrientationMode==QuadFlyingMode_X)
				{	// Board Orientation in X-Mode
					// {-1,1,1,-1} QUAD_ROL_X
					MotorOut[0] -= gyroRoll ;
					MotorOut[3] -= gyroRoll ;
    2c26:	c8 0f       	add	r28, r24
    2c28:	d9 1f       	adc	r29, r25
					
					// {-1,-1,1,1} QUAD_AIL_X
					MotorOut[0] -= gyroPitch;
					MotorOut[1] -= gyroPitch;
					MotorOut[2] += gyroPitch;
					MotorOut[3] += gyroPitch;
    2c2a:	c2 1b       	sub	r28, r18
    2c2c:	d3 0b       	sbc	r29, r19
    2c2e:	d0 93 a1 05 	sts	0x05A1, r29
    2c32:	c0 93 a0 05 	sts	0x05A0, r28
    2c36:	1b c0       	rjmp	.+54     	; 0x2c6e <MainLoop+0x3e4>
					
				}
				else
				{	// Board Orientation in Plus-Mode
					// {0,1,0,-1} QUAD_ROL_PLUS
					MotorOut[1] += gyroRoll  ;
    2c38:	a9 01       	movw	r20, r18
    2c3a:	4c 0f       	add	r20, r28
    2c3c:	5d 1f       	adc	r21, r29
    2c3e:	50 93 9d 05 	sts	0x059D, r21
    2c42:	40 93 9c 05 	sts	0x059C, r20
					MotorOut[3] -= gyroRoll  ;
    2c46:	ae 01       	movw	r20, r28
    2c48:	42 1b       	sub	r20, r18
    2c4a:	53 0b       	sbc	r21, r19
    2c4c:	50 93 a1 05 	sts	0x05A1, r21
    2c50:	40 93 a0 05 	sts	0x05A0, r20
				
					// {-1,0,1,0} QUAD_AIL_PLUS
					MotorOut[0] -= gyroPitch ;
    2c54:	9e 01       	movw	r18, r28
    2c56:	28 1b       	sub	r18, r24
    2c58:	39 0b       	sbc	r19, r25
    2c5a:	30 93 9b 05 	sts	0x059B, r19
    2c5e:	20 93 9a 05 	sts	0x059A, r18
					MotorOut[2] += gyroPitch ; 
    2c62:	c8 0f       	add	r28, r24
    2c64:	d9 1f       	adc	r29, r25
    2c66:	d0 93 9f 05 	sts	0x059F, r29
    2c6a:	c0 93 9e 05 	sts	0x059E, r28
			*
			*	Pilot Control Logic.
			*	Handles signals from remote control in ACRO mode.
			*	in stabilization mode controls are added in IMU logic as angles.
			*/
			if (nFlyingModes == FLYINGMODE_ACRO)
    2c6e:	80 91 1e 06 	lds	r24, 0x061E
    2c72:	81 30       	cpi	r24, 0x01	; 1
    2c74:	09 f0       	breq	.+2      	; 0x2c78 <MainLoop+0x3ee>
    2c76:	2e c1       	rjmp	.+604    	; 0x2ed4 <MainLoop+0x64a>
			{
				if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    2c78:	90 91 f4 06 	lds	r25, 0x06F4
    2c7c:	80 91 f6 06 	lds	r24, 0x06F6
    2c80:	91 30       	cpi	r25, 0x01	; 1
    2c82:	09 f0       	breq	.+2      	; 0x2c86 <MainLoop+0x3fc>
    2c84:	a3 c0       	rjmp	.+326    	; 0x2dcc <MainLoop+0x542>
    2c86:	60 91 c2 05 	lds	r22, 0x05C2
    2c8a:	70 91 c3 05 	lds	r23, 0x05C3
    2c8e:	e0 90 c4 05 	lds	r14, 0x05C4
    2c92:	f0 90 c5 05 	lds	r15, 0x05C5
    2c96:	80 90 a0 05 	lds	r8, 0x05A0
    2c9a:	90 90 a1 05 	lds	r9, 0x05A1
    2c9e:	a0 90 9c 05 	lds	r10, 0x059C
    2ca2:	b0 90 9d 05 	lds	r11, 0x059D
    2ca6:	c0 90 9e 05 	lds	r12, 0x059E
    2caa:	d0 90 9f 05 	lds	r13, 0x059F
    2cae:	00 91 9a 05 	lds	r16, 0x059A
    2cb2:	10 91 9b 05 	lds	r17, 0x059B
				{
				
					if (Config.QuadFlyingMode==QuadFlyingMode_X)
    2cb6:	81 30       	cpi	r24, 0x01	; 1
    2cb8:	09 f0       	breq	.+2      	; 0x2cbc <MainLoop+0x432>
    2cba:	49 c0       	rjmp	.+146    	; 0x2d4e <MainLoop+0x4c4>
					{
						RX_Snapshot[RXChannel_AIL] = RX_Snapshot[RXChannel_AIL] * 0.63;		// because we fly X
    2cbc:	88 27       	eor	r24, r24
    2cbe:	77 fd       	sbrc	r23, 7
    2cc0:	80 95       	com	r24
    2cc2:	98 2f       	mov	r25, r24
    2cc4:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    2cc8:	2e ea       	ldi	r18, 0xAE	; 174
    2cca:	37 e4       	ldi	r19, 0x47	; 71
    2ccc:	41 e2       	ldi	r20, 0x21	; 33
    2cce:	5f e3       	ldi	r21, 0x3F	; 63
    2cd0:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    2cd4:	0e 94 03 37 	call	0x6e06	; 0x6e06 <__fixsfsi>
    2cd8:	eb 01       	movw	r28, r22
    2cda:	70 93 c3 05 	sts	0x05C3, r23
    2cde:	60 93 c2 05 	sts	0x05C2, r22
						RX_Snapshot[RXChannel_ELE] = RX_Snapshot[RXChannel_ELE] * 0.63;
    2ce2:	b7 01       	movw	r22, r14
    2ce4:	88 27       	eor	r24, r24
    2ce6:	77 fd       	sbrc	r23, 7
    2ce8:	80 95       	com	r24
    2cea:	98 2f       	mov	r25, r24
    2cec:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    2cf0:	2e ea       	ldi	r18, 0xAE	; 174
    2cf2:	37 e4       	ldi	r19, 0x47	; 71
    2cf4:	41 e2       	ldi	r20, 0x21	; 33
    2cf6:	5f e3       	ldi	r21, 0x3F	; 63
    2cf8:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    2cfc:	0e 94 03 37 	call	0x6e06	; 0x6e06 <__fixsfsi>
    2d00:	9b 01       	movw	r18, r22
    2d02:	70 93 c5 05 	sts	0x05C5, r23
    2d06:	60 93 c4 05 	sts	0x05C4, r22
					
						// {0.63,-0.63,-0.63,0.63} QUAD_AIL_X
						MotorOut[0] += RX_Snapshot[RXChannel_AIL] ;
						MotorOut[3] += RX_Snapshot[RXChannel_AIL] ;
    2d0a:	8c 0e       	add	r8, r28
    2d0c:	9d 1e       	adc	r9, r29
						MotorOut[1] -= RX_Snapshot[RXChannel_AIL] ;
						MotorOut[2] -= RX_Snapshot[RXChannel_AIL] ;
    2d0e:	cc 1a       	sub	r12, r28
    2d10:	dd 0a       	sbc	r13, r29
					{
						RX_Snapshot[RXChannel_AIL] = RX_Snapshot[RXChannel_AIL] * 0.63;		// because we fly X
						RX_Snapshot[RXChannel_ELE] = RX_Snapshot[RXChannel_ELE] * 0.63;
					
						// {0.63,-0.63,-0.63,0.63} QUAD_AIL_X
						MotorOut[0] += RX_Snapshot[RXChannel_AIL] ;
    2d12:	ce 01       	movw	r24, r28
    2d14:	82 0f       	add	r24, r18
    2d16:	93 1f       	adc	r25, r19
						MotorOut[3] += RX_Snapshot[RXChannel_AIL] ;
						MotorOut[1] -= RX_Snapshot[RXChannel_AIL] ;
						MotorOut[2] -= RX_Snapshot[RXChannel_AIL] ;
				
						// {0.63,0.63,-0.63,-0.63} QUAD_ELE_X
						MotorOut[0] += RX_Snapshot[RXChannel_ELE];
    2d18:	80 0f       	add	r24, r16
    2d1a:	91 1f       	adc	r25, r17
    2d1c:	90 93 9b 05 	sts	0x059B, r25
    2d20:	80 93 9a 05 	sts	0x059A, r24
						RX_Snapshot[RXChannel_ELE] = RX_Snapshot[RXChannel_ELE] * 0.63;
					
						// {0.63,-0.63,-0.63,0.63} QUAD_AIL_X
						MotorOut[0] += RX_Snapshot[RXChannel_AIL] ;
						MotorOut[3] += RX_Snapshot[RXChannel_AIL] ;
						MotorOut[1] -= RX_Snapshot[RXChannel_AIL] ;
    2d24:	a2 0e       	add	r10, r18
    2d26:	b3 1e       	adc	r11, r19
						MotorOut[2] -= RX_Snapshot[RXChannel_AIL] ;
				
						// {0.63,0.63,-0.63,-0.63} QUAD_ELE_X
						MotorOut[0] += RX_Snapshot[RXChannel_ELE];
						MotorOut[1] += RX_Snapshot[RXChannel_ELE];
    2d28:	ac 1a       	sub	r10, r28
    2d2a:	bd 0a       	sbc	r11, r29
    2d2c:	b0 92 9d 05 	sts	0x059D, r11
    2d30:	a0 92 9c 05 	sts	0x059C, r10
						MotorOut[2] -= RX_Snapshot[RXChannel_ELE];
    2d34:	c2 1a       	sub	r12, r18
    2d36:	d3 0a       	sbc	r13, r19
    2d38:	d0 92 9f 05 	sts	0x059F, r13
    2d3c:	c0 92 9e 05 	sts	0x059E, r12
						MotorOut[3] -= RX_Snapshot[RXChannel_ELE];
    2d40:	82 1a       	sub	r8, r18
    2d42:	93 0a       	sbc	r9, r19
    2d44:	90 92 a1 05 	sts	0x05A1, r9
    2d48:	80 92 a0 05 	sts	0x05A0, r8
    2d4c:	2e c1       	rjmp	.+604    	; 0x2faa <MainLoop+0x720>
					
					}
					else
					{
				
						RX_Snapshot[RXChannel_AIL] = RX_Snapshot[RXChannel_AIL] * 0.9;		// 0.9: to reduce sensitivity more than STABLE mode
    2d4e:	88 27       	eor	r24, r24
    2d50:	77 fd       	sbrc	r23, 7
    2d52:	80 95       	com	r24
    2d54:	98 2f       	mov	r25, r24
    2d56:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    2d5a:	26 e6       	ldi	r18, 0x66	; 102
    2d5c:	36 e6       	ldi	r19, 0x66	; 102
    2d5e:	46 e6       	ldi	r20, 0x66	; 102
    2d60:	5f e3       	ldi	r21, 0x3F	; 63
    2d62:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    2d66:	0e 94 03 37 	call	0x6e06	; 0x6e06 <__fixsfsi>
    2d6a:	eb 01       	movw	r28, r22
    2d6c:	70 93 c3 05 	sts	0x05C3, r23
    2d70:	60 93 c2 05 	sts	0x05C2, r22
						RX_Snapshot[RXChannel_ELE] = RX_Snapshot[RXChannel_ELE] * 0.9;
    2d74:	b7 01       	movw	r22, r14
    2d76:	88 27       	eor	r24, r24
    2d78:	77 fd       	sbrc	r23, 7
    2d7a:	80 95       	com	r24
    2d7c:	98 2f       	mov	r25, r24
    2d7e:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    2d82:	26 e6       	ldi	r18, 0x66	; 102
    2d84:	36 e6       	ldi	r19, 0x66	; 102
    2d86:	46 e6       	ldi	r20, 0x66	; 102
    2d88:	5f e3       	ldi	r21, 0x3F	; 63
    2d8a:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    2d8e:	0e 94 03 37 	call	0x6e06	; 0x6e06 <__fixsfsi>
    2d92:	70 93 c5 05 	sts	0x05C5, r23
    2d96:	60 93 c4 05 	sts	0x05C4, r22
						// {0.9,0,-0.9,0} QUAD_ELE_PLUS
						MotorOut[0] += RX_Snapshot[RXChannel_ELE] ; 
    2d9a:	06 0f       	add	r16, r22
    2d9c:	17 1f       	adc	r17, r23
    2d9e:	10 93 9b 05 	sts	0x059B, r17
    2da2:	00 93 9a 05 	sts	0x059A, r16
						MotorOut[2] -= RX_Snapshot[RXChannel_ELE] ; 
    2da6:	c6 1a       	sub	r12, r22
    2da8:	d7 0a       	sbc	r13, r23
    2daa:	d0 92 9f 05 	sts	0x059F, r13
    2dae:	c0 92 9e 05 	sts	0x059E, r12
						// {0,-0.9,0,0.9} QUAD_AIL_PLUS	
						MotorOut[1] -= RX_Snapshot[RXChannel_AIL] ; 
    2db2:	ac 1a       	sub	r10, r28
    2db4:	bd 0a       	sbc	r11, r29
    2db6:	b0 92 9d 05 	sts	0x059D, r11
    2dba:	a0 92 9c 05 	sts	0x059C, r10
						MotorOut[3] += RX_Snapshot[RXChannel_AIL] ;  
    2dbe:	c8 0d       	add	r28, r8
    2dc0:	d9 1d       	adc	r29, r9
    2dc2:	d0 93 a1 05 	sts	0x05A1, r29
    2dc6:	c0 93 a0 05 	sts	0x05A0, r28
    2dca:	ef c0       	rjmp	.+478    	; 0x2faa <MainLoop+0x720>
				}
				else
				{ // TRICopter
					
						int8_t inv=1; // Flying in Y mode
						if (Config.QuadFlyingMode==QuadFlyingMode_X)
    2dcc:	81 30       	cpi	r24, 0x01	; 1
    2dce:	11 f0       	breq	.+4      	; 0x2dd4 <MainLoop+0x54a>
					}
				}
				else
				{ // TRICopter
					
						int8_t inv=1; // Flying in Y mode
    2dd0:	01 e0       	ldi	r16, 0x01	; 1
    2dd2:	01 c0       	rjmp	.+2      	; 0x2dd6 <MainLoop+0x54c>
						if (Config.QuadFlyingMode==QuadFlyingMode_X)
						{ // Flying in A mode
							inv = -1;
    2dd4:	0f ef       	ldi	r16, 0xFF	; 255
						}							
							// {0.5,0.5,1.1,X} TRI_ELE_FRONT
							MotorOut[2] -= inv * (RX_Snapshot[RXChannel_ELE] * 1.1); 
    2dd6:	c0 91 c4 05 	lds	r28, 0x05C4
    2dda:	d0 91 c5 05 	lds	r29, 0x05C5
    2dde:	60 91 9e 05 	lds	r22, 0x059E
    2de2:	70 91 9f 05 	lds	r23, 0x059F
    2de6:	88 27       	eor	r24, r24
    2de8:	77 fd       	sbrc	r23, 7
    2dea:	80 95       	com	r24
    2dec:	98 2f       	mov	r25, r24
    2dee:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    2df2:	4b 01       	movw	r8, r22
    2df4:	5c 01       	movw	r10, r24
    2df6:	60 2f       	mov	r22, r16
    2df8:	77 27       	eor	r23, r23
    2dfa:	67 fd       	sbrc	r22, 7
    2dfc:	70 95       	com	r23
    2dfe:	87 2f       	mov	r24, r23
    2e00:	97 2f       	mov	r25, r23
    2e02:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    2e06:	6b 01       	movw	r12, r22
    2e08:	7c 01       	movw	r14, r24
    2e0a:	be 01       	movw	r22, r28
    2e0c:	88 27       	eor	r24, r24
    2e0e:	77 fd       	sbrc	r23, 7
    2e10:	80 95       	com	r24
    2e12:	98 2f       	mov	r25, r24
    2e14:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    2e18:	2d ec       	ldi	r18, 0xCD	; 205
    2e1a:	3c ec       	ldi	r19, 0xCC	; 204
    2e1c:	4c e8       	ldi	r20, 0x8C	; 140
    2e1e:	5f e3       	ldi	r21, 0x3F	; 63
    2e20:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    2e24:	9b 01       	movw	r18, r22
    2e26:	ac 01       	movw	r20, r24
    2e28:	c7 01       	movw	r24, r14
    2e2a:	b6 01       	movw	r22, r12
    2e2c:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    2e30:	9b 01       	movw	r18, r22
    2e32:	ac 01       	movw	r20, r24
    2e34:	c5 01       	movw	r24, r10
    2e36:	b4 01       	movw	r22, r8
    2e38:	0e 94 32 36 	call	0x6c64	; 0x6c64 <__subsf3>
    2e3c:	0e 94 03 37 	call	0x6e06	; 0x6e06 <__fixsfsi>
    2e40:	70 93 9f 05 	sts	0x059F, r23
    2e44:	60 93 9e 05 	sts	0x059E, r22
							RX_Snapshot[RXChannel_ELE] = inv * RX_Snapshot[RXChannel_ELE] * 0.5;
    2e48:	e0 2e       	mov	r14, r16
    2e4a:	ff 24       	eor	r15, r15
    2e4c:	e7 fc       	sbrc	r14, 7
    2e4e:	f0 94       	com	r15
    2e50:	ec 9e       	mul	r14, r28
    2e52:	b0 01       	movw	r22, r0
    2e54:	ed 9e       	mul	r14, r29
    2e56:	70 0d       	add	r23, r0
    2e58:	fc 9e       	mul	r15, r28
    2e5a:	70 0d       	add	r23, r0
    2e5c:	11 24       	eor	r1, r1
    2e5e:	88 27       	eor	r24, r24
    2e60:	77 fd       	sbrc	r23, 7
    2e62:	80 95       	com	r24
    2e64:	98 2f       	mov	r25, r24
    2e66:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    2e6a:	20 e0       	ldi	r18, 0x00	; 0
    2e6c:	30 e0       	ldi	r19, 0x00	; 0
    2e6e:	40 e0       	ldi	r20, 0x00	; 0
    2e70:	5f e3       	ldi	r21, 0x3F	; 63
    2e72:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    2e76:	0e 94 03 37 	call	0x6e06	; 0x6e06 <__fixsfsi>
    2e7a:	fb 01       	movw	r30, r22
    2e7c:	70 93 c5 05 	sts	0x05C5, r23
    2e80:	60 93 c4 05 	sts	0x05C4, r22
							MotorOut[0] += RX_Snapshot[RXChannel_ELE] ; 
    2e84:	20 91 9a 05 	lds	r18, 0x059A
    2e88:	30 91 9b 05 	lds	r19, 0x059B
							MotorOut[1] += RX_Snapshot[RXChannel_ELE] ; 
    2e8c:	80 91 9c 05 	lds	r24, 0x059C
    2e90:	90 91 9d 05 	lds	r25, 0x059D
						
							// {1,-1,0,X} TRI_AIL_FRONT
							RX_Snapshot[RXChannel_AIL] = inv * RX_Snapshot[RXChannel_AIL];
    2e94:	60 91 c2 05 	lds	r22, 0x05C2
    2e98:	70 91 c3 05 	lds	r23, 0x05C3
    2e9c:	e6 9e       	mul	r14, r22
    2e9e:	a0 01       	movw	r20, r0
    2ea0:	e7 9e       	mul	r14, r23
    2ea2:	50 0d       	add	r21, r0
    2ea4:	f6 9e       	mul	r15, r22
    2ea6:	50 0d       	add	r21, r0
    2ea8:	11 24       	eor	r1, r1
    2eaa:	50 93 c3 05 	sts	0x05C3, r21
    2eae:	40 93 c2 05 	sts	0x05C2, r20
							inv = -1;
						}							
							// {0.5,0.5,1.1,X} TRI_ELE_FRONT
							MotorOut[2] -= inv * (RX_Snapshot[RXChannel_ELE] * 1.1); 
							RX_Snapshot[RXChannel_ELE] = inv * RX_Snapshot[RXChannel_ELE] * 0.5;
							MotorOut[0] += RX_Snapshot[RXChannel_ELE] ; 
    2eb2:	24 0f       	add	r18, r20
    2eb4:	35 1f       	adc	r19, r21
							MotorOut[1] += RX_Snapshot[RXChannel_ELE] ; 
						
							// {1,-1,0,X} TRI_AIL_FRONT
							RX_Snapshot[RXChannel_AIL] = inv * RX_Snapshot[RXChannel_AIL];
							MotorOut[0] += RX_Snapshot[RXChannel_AIL] ; 
    2eb6:	2e 0f       	add	r18, r30
    2eb8:	3f 1f       	adc	r19, r31
    2eba:	30 93 9b 05 	sts	0x059B, r19
    2ebe:	20 93 9a 05 	sts	0x059A, r18
						}							
							// {0.5,0.5,1.1,X} TRI_ELE_FRONT
							MotorOut[2] -= inv * (RX_Snapshot[RXChannel_ELE] * 1.1); 
							RX_Snapshot[RXChannel_ELE] = inv * RX_Snapshot[RXChannel_ELE] * 0.5;
							MotorOut[0] += RX_Snapshot[RXChannel_ELE] ; 
							MotorOut[1] += RX_Snapshot[RXChannel_ELE] ; 
    2ec2:	84 1b       	sub	r24, r20
    2ec4:	95 0b       	sbc	r25, r21
						
							// {1,-1,0,X} TRI_AIL_FRONT
							RX_Snapshot[RXChannel_AIL] = inv * RX_Snapshot[RXChannel_AIL];
							MotorOut[0] += RX_Snapshot[RXChannel_AIL] ; 
							MotorOut[1] -= RX_Snapshot[RXChannel_AIL] ;  
    2ec6:	8e 0f       	add	r24, r30
    2ec8:	9f 1f       	adc	r25, r31
    2eca:	90 93 9d 05 	sts	0x059D, r25
    2ece:	80 93 9c 05 	sts	0x059C, r24
    2ed2:	6b c0       	rjmp	.+214    	; 0x2faa <MainLoop+0x720>
			{
				// in stabilization mode ... activate Acc-Z & Sonar if enabled.
				
				double Landing;
				
				Landing = IMU_HeightKeeping();
    2ed4:	0e 94 5e 1f 	call	0x3ebc	; 0x3ebc <IMU_HeightKeeping>
    2ed8:	7b 01       	movw	r14, r22
    2eda:	8c 01       	movw	r16, r24
				MotorOut[0] += Landing;
    2edc:	60 91 9a 05 	lds	r22, 0x059A
    2ee0:	70 91 9b 05 	lds	r23, 0x059B
    2ee4:	88 27       	eor	r24, r24
    2ee6:	77 fd       	sbrc	r23, 7
    2ee8:	80 95       	com	r24
    2eea:	98 2f       	mov	r25, r24
    2eec:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    2ef0:	a8 01       	movw	r20, r16
    2ef2:	97 01       	movw	r18, r14
    2ef4:	0e 94 33 36 	call	0x6c66	; 0x6c66 <__addsf3>
    2ef8:	0e 94 03 37 	call	0x6e06	; 0x6e06 <__fixsfsi>
    2efc:	70 93 9b 05 	sts	0x059B, r23
    2f00:	60 93 9a 05 	sts	0x059A, r22
				MotorOut[1] += Landing;
    2f04:	60 91 9c 05 	lds	r22, 0x059C
    2f08:	70 91 9d 05 	lds	r23, 0x059D
    2f0c:	88 27       	eor	r24, r24
    2f0e:	77 fd       	sbrc	r23, 7
    2f10:	80 95       	com	r24
    2f12:	98 2f       	mov	r25, r24
    2f14:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    2f18:	a8 01       	movw	r20, r16
    2f1a:	97 01       	movw	r18, r14
    2f1c:	0e 94 33 36 	call	0x6c66	; 0x6c66 <__addsf3>
    2f20:	0e 94 03 37 	call	0x6e06	; 0x6e06 <__fixsfsi>
    2f24:	70 93 9d 05 	sts	0x059D, r23
    2f28:	60 93 9c 05 	sts	0x059C, r22
				if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    2f2c:	80 91 f4 06 	lds	r24, 0x06F4
    2f30:	c0 90 9e 05 	lds	r12, 0x059E
    2f34:	d0 90 9f 05 	lds	r13, 0x059F
    2f38:	81 30       	cpi	r24, 0x01	; 1
    2f3a:	31 f5       	brne	.+76     	; 0x2f88 <MainLoop+0x6fe>
				{
					
					MotorOut[2] += Landing;
    2f3c:	b6 01       	movw	r22, r12
    2f3e:	88 27       	eor	r24, r24
    2f40:	77 fd       	sbrc	r23, 7
    2f42:	80 95       	com	r24
    2f44:	98 2f       	mov	r25, r24
    2f46:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    2f4a:	a8 01       	movw	r20, r16
    2f4c:	97 01       	movw	r18, r14
    2f4e:	0e 94 33 36 	call	0x6c66	; 0x6c66 <__addsf3>
    2f52:	0e 94 03 37 	call	0x6e06	; 0x6e06 <__fixsfsi>
    2f56:	70 93 9f 05 	sts	0x059F, r23
    2f5a:	60 93 9e 05 	sts	0x059E, r22
					MotorOut[3] += Landing;		
    2f5e:	60 91 a0 05 	lds	r22, 0x05A0
    2f62:	70 91 a1 05 	lds	r23, 0x05A1
    2f66:	88 27       	eor	r24, r24
    2f68:	77 fd       	sbrc	r23, 7
    2f6a:	80 95       	com	r24
    2f6c:	98 2f       	mov	r25, r24
    2f6e:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    2f72:	a8 01       	movw	r20, r16
    2f74:	97 01       	movw	r18, r14
    2f76:	0e 94 33 36 	call	0x6c66	; 0x6c66 <__addsf3>
    2f7a:	0e 94 03 37 	call	0x6e06	; 0x6e06 <__fixsfsi>
    2f7e:	70 93 a1 05 	sts	0x05A1, r23
    2f82:	60 93 a0 05 	sts	0x05A0, r22
    2f86:	11 c0       	rjmp	.+34     	; 0x2faa <MainLoop+0x720>
				}
				else
				{
					MotorOut[2] += Landing;
    2f88:	b6 01       	movw	r22, r12
    2f8a:	88 27       	eor	r24, r24
    2f8c:	77 fd       	sbrc	r23, 7
    2f8e:	80 95       	com	r24
    2f90:	98 2f       	mov	r25, r24
    2f92:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    2f96:	a8 01       	movw	r20, r16
    2f98:	97 01       	movw	r18, r14
    2f9a:	0e 94 33 36 	call	0x6c66	; 0x6c66 <__addsf3>
    2f9e:	0e 94 03 37 	call	0x6e06	; 0x6e06 <__fixsfsi>
    2fa2:	70 93 9f 05 	sts	0x059F, r23
    2fa6:	60 93 9e 05 	sts	0x059E, r22
													
										
			}
			
									
			if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    2faa:	00 91 f4 06 	lds	r16, 0x06F4
    2fae:	80 91 e9 06 	lds	r24, 0x06E9
    2fb2:	90 91 ea 06 	lds	r25, 0x06EA
    2fb6:	01 30       	cpi	r16, 0x01	; 1
    2fb8:	49 f5       	brne	.+82     	; 0x300c <MainLoop+0x782>
			{
				MotorOut[0] -= gyroYaw;
    2fba:	20 91 9a 05 	lds	r18, 0x059A
    2fbe:	30 91 9b 05 	lds	r19, 0x059B
    2fc2:	28 1b       	sub	r18, r24
    2fc4:	39 0b       	sbc	r19, r25
    2fc6:	30 93 9b 05 	sts	0x059B, r19
    2fca:	20 93 9a 05 	sts	0x059A, r18
				MotorOut[2] -= gyroYaw;
    2fce:	20 91 9e 05 	lds	r18, 0x059E
    2fd2:	30 91 9f 05 	lds	r19, 0x059F
    2fd6:	28 1b       	sub	r18, r24
    2fd8:	39 0b       	sbc	r19, r25
    2fda:	30 93 9f 05 	sts	0x059F, r19
    2fde:	20 93 9e 05 	sts	0x059E, r18
				MotorOut[1] += gyroYaw;
    2fe2:	20 91 9c 05 	lds	r18, 0x059C
    2fe6:	30 91 9d 05 	lds	r19, 0x059D
    2fea:	28 0f       	add	r18, r24
    2fec:	39 1f       	adc	r19, r25
    2fee:	30 93 9d 05 	sts	0x059D, r19
    2ff2:	20 93 9c 05 	sts	0x059C, r18
				MotorOut[3] += gyroYaw;
    2ff6:	20 91 a0 05 	lds	r18, 0x05A0
    2ffa:	30 91 a1 05 	lds	r19, 0x05A1
    2ffe:	28 0f       	add	r18, r24
    3000:	39 1f       	adc	r19, r25
    3002:	30 93 a1 05 	sts	0x05A1, r19
    3006:	20 93 a0 05 	sts	0x05A0, r18
    300a:	3a c0       	rjmp	.+116    	; 0x3080 <MainLoop+0x7f6>
			}
			else
			{
			
				MotorOut[3]  = (Config.ReverseYAW * gyroYaw) + SERVO_IN_MIDDLE; 
    300c:	20 91 b2 07 	lds	r18, 0x07B2
    3010:	c2 2f       	mov	r28, r18
    3012:	dd 27       	eor	r29, r29
    3014:	c7 fd       	sbrc	r28, 7
    3016:	d0 95       	com	r29
    3018:	c8 9f       	mul	r28, r24
    301a:	b0 01       	movw	r22, r0
    301c:	c9 9f       	mul	r28, r25
    301e:	70 0d       	add	r23, r0
    3020:	d8 9f       	mul	r29, r24
    3022:	70 0d       	add	r23, r0
    3024:	11 24       	eor	r1, r1
    3026:	6a 5d       	subi	r22, 0xDA	; 218
    3028:	7d 4f       	sbci	r23, 0xFD	; 253
				MotorOut[3]  = MotorOut[3] - (Config.ReverseYAW * RX_Snapshot[RXChannel_RUD] * 0.2);
    302a:	88 27       	eor	r24, r24
    302c:	77 fd       	sbrc	r23, 7
    302e:	80 95       	com	r24
    3030:	98 2f       	mov	r25, r24
    3032:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    3036:	6b 01       	movw	r12, r22
    3038:	7c 01       	movw	r14, r24
    303a:	80 91 c6 05 	lds	r24, 0x05C6
    303e:	90 91 c7 05 	lds	r25, 0x05C7
    3042:	c8 9f       	mul	r28, r24
    3044:	b0 01       	movw	r22, r0
    3046:	c9 9f       	mul	r28, r25
    3048:	70 0d       	add	r23, r0
    304a:	d8 9f       	mul	r29, r24
    304c:	70 0d       	add	r23, r0
    304e:	11 24       	eor	r1, r1
    3050:	88 27       	eor	r24, r24
    3052:	77 fd       	sbrc	r23, 7
    3054:	80 95       	com	r24
    3056:	98 2f       	mov	r25, r24
    3058:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    305c:	2d ec       	ldi	r18, 0xCD	; 205
    305e:	3c ec       	ldi	r19, 0xCC	; 204
    3060:	4c e4       	ldi	r20, 0x4C	; 76
    3062:	5e e3       	ldi	r21, 0x3E	; 62
    3064:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    3068:	9b 01       	movw	r18, r22
    306a:	ac 01       	movw	r20, r24
    306c:	c7 01       	movw	r24, r14
    306e:	b6 01       	movw	r22, r12
    3070:	0e 94 32 36 	call	0x6c64	; 0x6c64 <__subsf3>
    3074:	0e 94 03 37 	call	0x6e06	; 0x6e06 <__fixsfsi>
    3078:	70 93 a1 05 	sts	0x05A1, r23
    307c:	60 93 a0 05 	sts	0x05A0, r22
			}						
			
			// Save motors from turning-off
            if (MotorOut[0]<MOTORS_IDLE_VALUE) MotorOut[0]=MOTORS_IDLE_VALUE;
    3080:	80 91 9a 05 	lds	r24, 0x059A
    3084:	90 91 9b 05 	lds	r25, 0x059B
    3088:	84 36       	cpi	r24, 0x64	; 100
    308a:	91 05       	cpc	r25, r1
    308c:	34 f4       	brge	.+12     	; 0x309a <MainLoop+0x810>
    308e:	84 e6       	ldi	r24, 0x64	; 100
    3090:	90 e0       	ldi	r25, 0x00	; 0
    3092:	90 93 9b 05 	sts	0x059B, r25
    3096:	80 93 9a 05 	sts	0x059A, r24
            if (MotorOut[1]<MOTORS_IDLE_VALUE) MotorOut[1]=MOTORS_IDLE_VALUE;
    309a:	80 91 9c 05 	lds	r24, 0x059C
    309e:	90 91 9d 05 	lds	r25, 0x059D
    30a2:	84 36       	cpi	r24, 0x64	; 100
    30a4:	91 05       	cpc	r25, r1
    30a6:	34 f4       	brge	.+12     	; 0x30b4 <MainLoop+0x82a>
    30a8:	84 e6       	ldi	r24, 0x64	; 100
    30aa:	90 e0       	ldi	r25, 0x00	; 0
    30ac:	90 93 9d 05 	sts	0x059D, r25
    30b0:	80 93 9c 05 	sts	0x059C, r24
            if (MotorOut[2]<MOTORS_IDLE_VALUE) MotorOut[2]=MOTORS_IDLE_VALUE;
    30b4:	80 91 9e 05 	lds	r24, 0x059E
    30b8:	90 91 9f 05 	lds	r25, 0x059F
    30bc:	84 36       	cpi	r24, 0x64	; 100
    30be:	91 05       	cpc	r25, r1
    30c0:	34 f4       	brge	.+12     	; 0x30ce <MainLoop+0x844>
    30c2:	84 e6       	ldi	r24, 0x64	; 100
    30c4:	90 e0       	ldi	r25, 0x00	; 0
    30c6:	90 93 9f 05 	sts	0x059F, r25
    30ca:	80 93 9e 05 	sts	0x059E, r24
            
									
			if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    30ce:	01 30       	cpi	r16, 0x01	; 1
    30d0:	69 f4       	brne	.+26     	; 0x30ec <MainLoop+0x862>
			{
				if (MotorOut[3]<MOTORS_IDLE_VALUE) MotorOut[3]=MOTORS_IDLE_VALUE;
    30d2:	80 91 a0 05 	lds	r24, 0x05A0
    30d6:	90 91 a1 05 	lds	r25, 0x05A1
    30da:	84 36       	cpi	r24, 0x64	; 100
    30dc:	91 05       	cpc	r25, r1
    30de:	34 f4       	brge	.+12     	; 0x30ec <MainLoop+0x862>
    30e0:	84 e6       	ldi	r24, 0x64	; 100
    30e2:	90 e0       	ldi	r25, 0x00	; 0
    30e4:	90 93 a1 05 	sts	0x05A1, r25
    30e8:	80 93 a0 05 	sts	0x05A0, r24
			}
			
		
			// Sending Sensors & Motor Data 
			if (Config.RX_mode==RX_mode_UARTMode)
    30ec:	80 91 ef 06 	lds	r24, 0x06EF
    30f0:	8f 3f       	cpi	r24, 0xFF	; 255
    30f2:	a1 f4       	brne	.+40     	; 0x311c <MainLoop+0x892>
			{
				//LED_Orange=~LED_Orange;
				Send_Data("S",1);
    30f4:	84 e0       	ldi	r24, 0x04	; 4
    30f6:	91 e0       	ldi	r25, 0x01	; 1
    30f8:	61 e0       	ldi	r22, 0x01	; 1
    30fa:	0e 94 73 10 	call	0x20e6	; 0x20e6 <Send_Data>
				Send_Data(Sensors_Latest,12);
    30fe:	8f e3       	ldi	r24, 0x3F	; 63
    3100:	96 e0       	ldi	r25, 0x06	; 6
    3102:	6c e0       	ldi	r22, 0x0C	; 12
    3104:	0e 94 73 10 	call	0x20e6	; 0x20e6 <Send_Data>
				Send_Data(MotorOut,8);
    3108:	8a e9       	ldi	r24, 0x9A	; 154
    310a:	95 e0       	ldi	r25, 0x05	; 5
    310c:	68 e0       	ldi	r22, 0x08	; 8
    310e:	0e 94 73 10 	call	0x20e6	; 0x20e6 <Send_Data>
				Send_Data("E",1);
    3112:	86 e0       	ldi	r24, 0x06	; 6
    3114:	91 e0       	ldi	r25, 0x01	; 1
    3116:	61 e0       	ldi	r22, 0x01	; 1
    3118:	0e 94 73 10 	call	0x20e6	; 0x20e6 <Send_Data>
		} // End of ARMED & Throttle > Minimum
				
			
	}  // End of Throttle stick is NOT Down [Armed Could be True or not]
	
	if ((!IS_TX2_GOOD)) // if no signal and there is no AutoLandingMode.
    311c:	80 91 ff 07 	lds	r24, 0x07FF
    3120:	80 7f       	andi	r24, 0xF0	; 240
    3122:	79 f0       	breq	.+30     	; 0x3142 <MainLoop+0x8b8>
	{
		ZEROMotors();
    3124:	0e 94 27 14 	call	0x284e	; 0x284e <ZEROMotors>
		if (IsArmed==true)
    3128:	80 91 cc 07 	lds	r24, 0x07CC
    312c:	81 30       	cpi	r24, 0x01	; 1
    312e:	49 f4       	brne	.+18     	; 0x3142 <MainLoop+0x8b8>
		{
			Motor_GenerateOutputSignal();	
    3130:	0e 94 97 22 	call	0x452e	; 0x452e <Motor_GenerateOutputSignal>
			Disarm();	
    3134:	0e 94 1a 0f 	call	0x1e34	; 0x1e34 <Disarm>
			SystemErrorType = SET_SYS_ERR_SIGNAL; // only error if signal lost while arming
    3138:	80 91 db 06 	lds	r24, 0x06DB
    313c:	81 60       	ori	r24, 0x01	; 1
    313e:	80 93 db 06 	sts	0x06DB, r24
		
		
		//return ; // Do nothing all below depends on TX.
	}
	
	Motor_GenerateOutputSignal();	
    3142:	0e 94 97 22 	call	0x452e	; 0x452e <Motor_GenerateOutputSignal>
	
	if (bResetTCNR1_X==true)
    3146:	80 91 69 06 	lds	r24, 0x0669
    314a:	81 30       	cpi	r24, 0x01	; 1
    314c:	21 f4       	brne	.+8      	; 0x3156 <MainLoop+0x8cc>
	{
		TCNT1_X_snapshot1= 0; // reset timeout
    314e:	10 92 eb 05 	sts	0x05EB, r1
    3152:	10 92 ea 05 	sts	0x05EA, r1
	}
	
	
}	
    3156:	df 91       	pop	r29
    3158:	cf 91       	pop	r28
    315a:	1f 91       	pop	r17
    315c:	0f 91       	pop	r16
    315e:	ff 90       	pop	r15
    3160:	ef 90       	pop	r14
    3162:	df 90       	pop	r13
    3164:	cf 90       	pop	r12
    3166:	bf 90       	pop	r11
    3168:	af 90       	pop	r10
    316a:	9f 90       	pop	r9
    316c:	8f 90       	pop	r8
    316e:	08 95       	ret

00003170 <main>:

int main(void)
{
	// Stick Commands are only available for Secondary Receiver and when Stick is calibrated.
	
	UIEnableStickCommands=false;  
    3170:	10 92 e9 05 	sts	0x05E9, r1
	Setup();
    3174:	0e 94 ad 11 	call	0x235a	; 0x235a <Setup>
	SystemActions = SYS_ACT_NON;
    3178:	10 92 51 05 	sts	0x0551, r1
    SystemErrorType = SYS_ERR_NON;
    317c:	10 92 db 06 	sts	0x06DB, r1
	nFlyingModes = FLYINGMODE_ACRO;
    3180:	81 e0       	ldi	r24, 0x01	; 1
    3182:	80 93 1e 06 	sts	0x061E, r24
	FlyingModesToggle = HIGH;
    3186:	80 93 2f 05 	sts	0x052F, r24
	
	DataPtr = (uint8_t *) (&Sensors_Latest);
    318a:	8f e3       	ldi	r24, 0x3F	; 63
    318c:	96 e0       	ldi	r25, 0x06	; 6
    318e:	90 93 dc 07 	sts	0x07DC, r25
    3192:	80 93 db 07 	sts	0x07DB, r24
	DataCounter=0;
    3196:	10 92 cd 07 	sts	0x07CD, r1
	
	
	TCNT1H_OLD = TCNT1H;
    319a:	80 91 85 00 	lds	r24, 0x0085
    319e:	90 e0       	ldi	r25, 0x00	; 0
    31a0:	90 93 e1 06 	sts	0x06E1, r25
    31a4:	80 93 e0 06 	sts	0x06E0, r24
	// Never go to MainLoop "fly loop" unless Sensors & RX is calibrated.
	// This loop to protect against any bug that might make the quad start or KB stick click
	// as in this case crash is a must.
	LoopCalibration ();
    31a8:	0e 94 14 12 	call	0x2428	; 0x2428 <LoopCalibration>

	
	
	// This loop better be under the sensor/stick loop to avoid entering this mode is sticks are not calibrated.
	// This is no longer a condition after adding menuEnabled[PAGE_ESC_CALIBRATION]=0
	if (Config.IsESCCalibration==ESCCalibration_ON)		
    31ac:	80 91 f3 06 	lds	r24, 0x06F3
    31b0:	81 30       	cpi	r24, 0x01	; 1
    31b2:	11 f4       	brne	.+4      	; 0x31b8 <main+0x48>
	{
		LoopESCCalibration ();
    31b4:	0e 94 0e 12 	call	0x241c	; 0x241c <LoopESCCalibration>
	Mixer[Mixer_Quad_PLUS].Roll[4]  = {0,-1.0,0,1.0};
//#define Mixer_Quad_X		1
//#define Mixer_TRI			2
*/

	Menu_EnableAllItems();
    31b8:	0e 94 27 36 	call	0x6c4e	; 0x6c4e <Menu_EnableAllItems>
	
	Menu_LoadPage(PAGE_DEBUG);
    31bc:	8f e0       	ldi	r24, 0x0F	; 15
    31be:	0e 94 b9 2c 	call	0x5972	; 0x5972 <Menu_LoadPage>
	
	while(1)
    {
		//LoopESCCalibration();
    	MainLoop();
    31c2:	0e 94 45 14 	call	0x288a	; 0x288a <MainLoop>
    31c6:	fd cf       	rjmp	.-6      	; 0x31c2 <main+0x52>

000031c8 <PID_Calculate_ACC>:




float PID_Calculate_ACC (const pid_param_t PID_Params, pid_terms_t *PID_Term, const double  Value)
{
    31c8:	6f 92       	push	r6
    31ca:	7f 92       	push	r7
    31cc:	8f 92       	push	r8
    31ce:	9f 92       	push	r9
    31d0:	af 92       	push	r10
    31d2:	bf 92       	push	r11
    31d4:	cf 92       	push	r12
    31d6:	df 92       	push	r13
    31d8:	ef 92       	push	r14
    31da:	ff 92       	push	r15
    31dc:	0f 93       	push	r16
    31de:	1f 93       	push	r17
    31e0:	df 93       	push	r29
    31e2:	cf 93       	push	r28
    31e4:	cd b7       	in	r28, 0x3d	; 61
    31e6:	de b7       	in	r29, 0x3e	; 62
    31e8:	2e 97       	sbiw	r28, 0x0e	; 14
    31ea:	0f b6       	in	r0, 0x3f	; 63
    31ec:	f8 94       	cli
    31ee:	de bf       	out	0x3e, r29	; 62
    31f0:	0f be       	out	0x3f, r0	; 63
    31f2:	cd bf       	out	0x3d, r28	; 61
    31f4:	c9 82       	std	Y+1, r12	; 0x01
    31f6:	da 82       	std	Y+2, r13	; 0x02
    31f8:	eb 82       	std	Y+3, r14	; 0x03
    31fa:	fc 82       	std	Y+4, r15	; 0x04
    31fc:	0d 83       	std	Y+5, r16	; 0x05
    31fe:	1e 83       	std	Y+6, r17	; 0x06
    3200:	2f 83       	std	Y+7, r18	; 0x07
    3202:	38 87       	std	Y+8, r19	; 0x08
    3204:	49 87       	std	Y+9, r20	; 0x09
    3206:	5a 87       	std	Y+10, r21	; 0x0a
    3208:	6b 87       	std	Y+11, r22	; 0x0b
    320a:	7c 87       	std	Y+12, r23	; 0x0c
    320c:	8d 87       	std	Y+13, r24	; 0x0d
    320e:	9e 87       	std	Y+14, r25	; 0x0e
    3210:	ef 8c       	ldd	r14, Y+31	; 0x1f
    3212:	f8 a0       	ldd	r15, Y+32	; 0x20
    3214:	09 a1       	ldd	r16, Y+33	; 0x21
    3216:	1a a1       	ldd	r17, Y+34	; 0x22
    3218:	6d 80       	ldd	r6, Y+5	; 0x05
    321a:	7e 80       	ldd	r7, Y+6	; 0x06
	#define ACC_I_MIN	4
		
	float Output;
		
		double AbsValue = abs (Value);
    321c:	c8 01       	movw	r24, r16
    321e:	b7 01       	movw	r22, r14
    3220:	0e 94 74 38 	call	0x70e8	; 0x70e8 <abs>
    3224:	9c 01       	movw	r18, r24
    3226:	b9 01       	movw	r22, r18
    3228:	88 27       	eor	r24, r24
    322a:	77 fd       	sbrc	r23, 7
    322c:	80 95       	com	r24
    322e:	98 2f       	mov	r25, r24
    3230:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
		// Calculate Terms 
		if (AbsValue > 1)
    3234:	20 e0       	ldi	r18, 0x00	; 0
    3236:	30 e0       	ldi	r19, 0x00	; 0
    3238:	40 e8       	ldi	r20, 0x80	; 128
    323a:	5f e3       	ldi	r21, 0x3F	; 63
    323c:	0e 94 e6 37 	call	0x6fcc	; 0x6fcc <__gesf2>
    3240:	18 16       	cp	r1, r24
    3242:	cc f4       	brge	.+50     	; 0x3276 <PID_Calculate_ACC+0xae>
	    PID_Term->P  = ((float)(Value * PID_Params._P) / 10.0f);						
    3244:	69 81       	ldd	r22, Y+1	; 0x01
    3246:	7a 81       	ldd	r23, Y+2	; 0x02
    3248:	88 27       	eor	r24, r24
    324a:	77 fd       	sbrc	r23, 7
    324c:	80 95       	com	r24
    324e:	98 2f       	mov	r25, r24
    3250:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    3254:	9b 01       	movw	r18, r22
    3256:	ac 01       	movw	r20, r24
    3258:	c8 01       	movw	r24, r16
    325a:	b7 01       	movw	r22, r14
    325c:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    3260:	20 e0       	ldi	r18, 0x00	; 0
    3262:	30 e0       	ldi	r19, 0x00	; 0
    3264:	40 e2       	ldi	r20, 0x20	; 32
    3266:	51 e4       	ldi	r21, 0x41	; 65
    3268:	0e 94 9b 36 	call	0x6d36	; 0x6d36 <__divsf3>
    326c:	f5 01       	movw	r30, r10
    326e:	60 83       	st	Z, r22
    3270:	71 83       	std	Z+1, r23	; 0x01
    3272:	82 83       	std	Z+2, r24	; 0x02
    3274:	93 83       	std	Z+3, r25	; 0x03
		//if ((abs(Value - PID_Term->Error) > AbsValue ) || (Value ==0))
		//{  // Zero I if different signs.
			//PID_Term->I =0; ..... removed because it nakes whobbles.S
		//}
		//else 
		int16_t DeltaError = (Value - PID_Term->Error);
    3276:	c8 01       	movw	r24, r16
    3278:	b7 01       	movw	r22, r14
    327a:	f5 01       	movw	r30, r10
    327c:	24 85       	ldd	r18, Z+12	; 0x0c
    327e:	35 85       	ldd	r19, Z+13	; 0x0d
    3280:	46 85       	ldd	r20, Z+14	; 0x0e
    3282:	57 85       	ldd	r21, Z+15	; 0x0f
    3284:	0e 94 32 36 	call	0x6c64	; 0x6c64 <__subsf3>
    3288:	0e 94 03 37 	call	0x6e06	; 0x6e06 <__fixsfsi>
    328c:	6b 01       	movw	r12, r22
		if (Value > ACC_I_MIN)
    328e:	c8 01       	movw	r24, r16
    3290:	b7 01       	movw	r22, r14
    3292:	20 e0       	ldi	r18, 0x00	; 0
    3294:	30 e0       	ldi	r19, 0x00	; 0
    3296:	40 e8       	ldi	r20, 0x80	; 128
    3298:	50 e4       	ldi	r21, 0x40	; 64
    329a:	0e 94 e6 37 	call	0x6fcc	; 0x6fcc <__gesf2>
    329e:	18 16       	cp	r1, r24
    32a0:	bc f4       	brge	.+46     	; 0x32d0 <PID_Calculate_ACC+0x108>
		{
			PID_Term->I += (float)(PID_Params._I / 100.0f);						    		
    32a2:	b3 01       	movw	r22, r6
    32a4:	88 27       	eor	r24, r24
    32a6:	77 fd       	sbrc	r23, 7
    32a8:	80 95       	com	r24
    32aa:	98 2f       	mov	r25, r24
    32ac:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    32b0:	20 e0       	ldi	r18, 0x00	; 0
    32b2:	30 e0       	ldi	r19, 0x00	; 0
    32b4:	48 ec       	ldi	r20, 0xC8	; 200
    32b6:	52 e4       	ldi	r21, 0x42	; 66
    32b8:	0e 94 9b 36 	call	0x6d36	; 0x6d36 <__divsf3>
    32bc:	9b 01       	movw	r18, r22
    32be:	ac 01       	movw	r20, r24
    32c0:	f5 01       	movw	r30, r10
    32c2:	64 81       	ldd	r22, Z+4	; 0x04
    32c4:	75 81       	ldd	r23, Z+5	; 0x05
    32c6:	86 81       	ldd	r24, Z+6	; 0x06
    32c8:	97 81       	ldd	r25, Z+7	; 0x07
    32ca:	0e 94 33 36 	call	0x6c66	; 0x6c66 <__addsf3>
    32ce:	32 c0       	rjmp	.+100    	; 0x3334 <PID_Calculate_ACC+0x16c>
		}
		else if (Value < -ACC_I_MIN)
    32d0:	c8 01       	movw	r24, r16
    32d2:	b7 01       	movw	r22, r14
    32d4:	20 e0       	ldi	r18, 0x00	; 0
    32d6:	30 e0       	ldi	r19, 0x00	; 0
    32d8:	40 e8       	ldi	r20, 0x80	; 128
    32da:	50 ec       	ldi	r21, 0xC0	; 192
    32dc:	0e 94 97 36 	call	0x6d2e	; 0x6d2e <__cmpsf2>
    32e0:	87 ff       	sbrs	r24, 7
    32e2:	15 c0       	rjmp	.+42     	; 0x330e <PID_Calculate_ACC+0x146>
		{	
			PID_Term->I -= (float)(PID_Params._I / 100.0f );						    		
    32e4:	b3 01       	movw	r22, r6
    32e6:	88 27       	eor	r24, r24
    32e8:	77 fd       	sbrc	r23, 7
    32ea:	80 95       	com	r24
    32ec:	98 2f       	mov	r25, r24
    32ee:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    32f2:	20 e0       	ldi	r18, 0x00	; 0
    32f4:	30 e0       	ldi	r19, 0x00	; 0
    32f6:	48 ec       	ldi	r20, 0xC8	; 200
    32f8:	52 e4       	ldi	r21, 0x42	; 66
    32fa:	0e 94 9b 36 	call	0x6d36	; 0x6d36 <__divsf3>
    32fe:	9b 01       	movw	r18, r22
    3300:	ac 01       	movw	r20, r24
    3302:	f5 01       	movw	r30, r10
    3304:	64 81       	ldd	r22, Z+4	; 0x04
    3306:	75 81       	ldd	r23, Z+5	; 0x05
    3308:	86 81       	ldd	r24, Z+6	; 0x06
    330a:	97 81       	ldd	r25, Z+7	; 0x07
    330c:	11 c0       	rjmp	.+34     	; 0x3330 <PID_Calculate_ACC+0x168>
		}
		else
		{
			PID_Term->I -= (float)(PID_Term->I * PID_I_LEAK_RATE);
    330e:	f5 01       	movw	r30, r10
    3310:	64 80       	ldd	r6, Z+4	; 0x04
    3312:	75 80       	ldd	r7, Z+5	; 0x05
    3314:	86 80       	ldd	r8, Z+6	; 0x06
    3316:	97 80       	ldd	r9, Z+7	; 0x07
    3318:	c4 01       	movw	r24, r8
    331a:	b3 01       	movw	r22, r6
    331c:	2a e0       	ldi	r18, 0x0A	; 10
    331e:	37 ed       	ldi	r19, 0xD7	; 215
    3320:	43 e2       	ldi	r20, 0x23	; 35
    3322:	5c e3       	ldi	r21, 0x3C	; 60
    3324:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    3328:	9b 01       	movw	r18, r22
    332a:	ac 01       	movw	r20, r24
    332c:	c4 01       	movw	r24, r8
    332e:	b3 01       	movw	r22, r6
    3330:	0e 94 32 36 	call	0x6c64	; 0x6c64 <__subsf3>
    3334:	f5 01       	movw	r30, r10
    3336:	64 83       	std	Z+4, r22	; 0x04
    3338:	75 83       	std	Z+5, r23	; 0x05
    333a:	86 83       	std	Z+6, r24	; 0x06
    333c:	97 83       	std	Z+7, r25	; 0x07
		}			
				
		
		PID_Term->D= (float)((float)(DeltaError) * (float)PID_Params._D) / 20.0f ;
    333e:	b6 01       	movw	r22, r12
    3340:	88 27       	eor	r24, r24
    3342:	77 fd       	sbrc	r23, 7
    3344:	80 95       	com	r24
    3346:	98 2f       	mov	r25, r24
    3348:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    334c:	3b 01       	movw	r6, r22
    334e:	4c 01       	movw	r8, r24
    3350:	69 85       	ldd	r22, Y+9	; 0x09
    3352:	7a 85       	ldd	r23, Y+10	; 0x0a
    3354:	88 27       	eor	r24, r24
    3356:	77 fd       	sbrc	r23, 7
    3358:	80 95       	com	r24
    335a:	98 2f       	mov	r25, r24
    335c:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    3360:	9b 01       	movw	r18, r22
    3362:	ac 01       	movw	r20, r24
    3364:	c4 01       	movw	r24, r8
    3366:	b3 01       	movw	r22, r6
    3368:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    336c:	20 e0       	ldi	r18, 0x00	; 0
    336e:	30 e0       	ldi	r19, 0x00	; 0
    3370:	40 ea       	ldi	r20, 0xA0	; 160
    3372:	51 e4       	ldi	r21, 0x41	; 65
    3374:	0e 94 9b 36 	call	0x6d36	; 0x6d36 <__divsf3>
    3378:	f5 01       	movw	r30, r10
    337a:	60 87       	std	Z+8, r22	; 0x08
    337c:	71 87       	std	Z+9, r23	; 0x09
    337e:	82 87       	std	Z+10, r24	; 0x0a
    3380:	93 87       	std	Z+11, r25	; 0x0b
		PID_Term->Error = Value;	
    3382:	e4 86       	std	Z+12, r14	; 0x0c
    3384:	f5 86       	std	Z+13, r15	; 0x0d
    3386:	06 87       	std	Z+14, r16	; 0x0e
    3388:	17 87       	std	Z+15, r17	; 0x0f
		
				
		// Limit boundaries to custom values defined by user.
		PID_Term->I= Limiterf(PID_Term->I, PID_Params._ILimit);
    338a:	e4 80       	ldd	r14, Z+4	; 0x04
    338c:	f5 80       	ldd	r15, Z+5	; 0x05
    338e:	06 81       	ldd	r16, Z+6	; 0x06
    3390:	17 81       	ldd	r17, Z+7	; 0x07
    3392:	6f 81       	ldd	r22, Y+7	; 0x07
    3394:	78 85       	ldd	r23, Y+8	; 0x08
    3396:	88 27       	eor	r24, r24
    3398:	77 fd       	sbrc	r23, 7
    339a:	80 95       	com	r24
    339c:	98 2f       	mov	r25, r24
    339e:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    33a2:	9b 01       	movw	r18, r22
    33a4:	ac 01       	movw	r20, r24
    33a6:	c8 01       	movw	r24, r16
    33a8:	b7 01       	movw	r22, r14
    33aa:	0e 94 54 21 	call	0x42a8	; 0x42a8 <Limiterf>
    33ae:	f5 01       	movw	r30, r10
    33b0:	64 83       	std	Z+4, r22	; 0x04
    33b2:	75 83       	std	Z+5, r23	; 0x05
    33b4:	86 83       	std	Z+6, r24	; 0x06
    33b6:	97 83       	std	Z+7, r25	; 0x07
		PID_Term->P= Limiterf(PID_Term->P, PID_Params._PLimit);
    33b8:	e0 80       	ld	r14, Z
    33ba:	f1 80       	ldd	r15, Z+1	; 0x01
    33bc:	02 81       	ldd	r16, Z+2	; 0x02
    33be:	13 81       	ldd	r17, Z+3	; 0x03
    33c0:	6b 81       	ldd	r22, Y+3	; 0x03
    33c2:	7c 81       	ldd	r23, Y+4	; 0x04
    33c4:	88 27       	eor	r24, r24
    33c6:	77 fd       	sbrc	r23, 7
    33c8:	80 95       	com	r24
    33ca:	98 2f       	mov	r25, r24
    33cc:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    33d0:	9b 01       	movw	r18, r22
    33d2:	ac 01       	movw	r20, r24
    33d4:	c8 01       	movw	r24, r16
    33d6:	b7 01       	movw	r22, r14
    33d8:	0e 94 54 21 	call	0x42a8	; 0x42a8 <Limiterf>
    33dc:	f5 01       	movw	r30, r10
    33de:	60 83       	st	Z, r22
    33e0:	71 83       	std	Z+1, r23	; 0x01
    33e2:	82 83       	std	Z+2, r24	; 0x02
    33e4:	93 83       	std	Z+3, r25	; 0x03
	    PID_Term->D= Limiterf(PID_Term->D, PID_Params._DLimit);
    33e6:	e0 84       	ldd	r14, Z+8	; 0x08
    33e8:	f1 84       	ldd	r15, Z+9	; 0x09
    33ea:	02 85       	ldd	r16, Z+10	; 0x0a
    33ec:	13 85       	ldd	r17, Z+11	; 0x0b
    33ee:	6b 85       	ldd	r22, Y+11	; 0x0b
    33f0:	7c 85       	ldd	r23, Y+12	; 0x0c
    33f2:	88 27       	eor	r24, r24
    33f4:	77 fd       	sbrc	r23, 7
    33f6:	80 95       	com	r24
    33f8:	98 2f       	mov	r25, r24
    33fa:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    33fe:	9b 01       	movw	r18, r22
    3400:	ac 01       	movw	r20, r24
    3402:	c8 01       	movw	r24, r16
    3404:	b7 01       	movw	r22, r14
    3406:	0e 94 54 21 	call	0x42a8	; 0x42a8 <Limiterf>
    340a:	7b 01       	movw	r14, r22
    340c:	8c 01       	movw	r16, r24
    340e:	f5 01       	movw	r30, r10
    3410:	60 87       	std	Z+8, r22	; 0x08
    3412:	71 87       	std	Z+9, r23	; 0x09
    3414:	82 87       	std	Z+10, r24	; 0x0a
    3416:	93 87       	std	Z+11, r25	; 0x0b
	
		Output = (PID_Term->P + PID_Term->I + PID_Term->D);	// P + I + D
    3418:	60 81       	ld	r22, Z
    341a:	71 81       	ldd	r23, Z+1	; 0x01
    341c:	82 81       	ldd	r24, Z+2	; 0x02
    341e:	93 81       	ldd	r25, Z+3	; 0x03
    3420:	24 81       	ldd	r18, Z+4	; 0x04
    3422:	35 81       	ldd	r19, Z+5	; 0x05
    3424:	46 81       	ldd	r20, Z+6	; 0x06
    3426:	57 81       	ldd	r21, Z+7	; 0x07
    3428:	0e 94 33 36 	call	0x6c66	; 0x6c66 <__addsf3>
    342c:	a8 01       	movw	r20, r16
    342e:	97 01       	movw	r18, r14
    3430:	0e 94 33 36 	call	0x6c66	; 0x6c66 <__addsf3>
		return  Output; 
}
    3434:	2e 96       	adiw	r28, 0x0e	; 14
    3436:	0f b6       	in	r0, 0x3f	; 63
    3438:	f8 94       	cli
    343a:	de bf       	out	0x3e, r29	; 62
    343c:	0f be       	out	0x3f, r0	; 63
    343e:	cd bf       	out	0x3d, r28	; 61
    3440:	cf 91       	pop	r28
    3442:	df 91       	pop	r29
    3444:	1f 91       	pop	r17
    3446:	0f 91       	pop	r16
    3448:	ff 90       	pop	r15
    344a:	ef 90       	pop	r14
    344c:	df 90       	pop	r13
    344e:	cf 90       	pop	r12
    3450:	bf 90       	pop	r11
    3452:	af 90       	pop	r10
    3454:	9f 90       	pop	r9
    3456:	8f 90       	pop	r8
    3458:	7f 90       	pop	r7
    345a:	6f 90       	pop	r6
    345c:	08 95       	ret

0000345e <PID_Calculate>:

float PID_Calculate (const pid_param_t PID_Params, pid_terms_t *PID_Term, const double  Value)
{
    345e:	af 92       	push	r10
    3460:	bf 92       	push	r11
    3462:	cf 92       	push	r12
    3464:	df 92       	push	r13
    3466:	ef 92       	push	r14
    3468:	ff 92       	push	r15
    346a:	0f 93       	push	r16
    346c:	1f 93       	push	r17
    346e:	df 93       	push	r29
    3470:	cf 93       	push	r28
    3472:	cd b7       	in	r28, 0x3d	; 61
    3474:	de b7       	in	r29, 0x3e	; 62
    3476:	2e 97       	sbiw	r28, 0x0e	; 14
    3478:	0f b6       	in	r0, 0x3f	; 63
    347a:	f8 94       	cli
    347c:	de bf       	out	0x3e, r29	; 62
    347e:	0f be       	out	0x3f, r0	; 63
    3480:	cd bf       	out	0x3d, r28	; 61
    3482:	c9 82       	std	Y+1, r12	; 0x01
    3484:	da 82       	std	Y+2, r13	; 0x02
    3486:	eb 82       	std	Y+3, r14	; 0x03
    3488:	fc 82       	std	Y+4, r15	; 0x04
    348a:	0d 83       	std	Y+5, r16	; 0x05
    348c:	1e 83       	std	Y+6, r17	; 0x06
    348e:	2f 83       	std	Y+7, r18	; 0x07
    3490:	38 87       	std	Y+8, r19	; 0x08
    3492:	49 87       	std	Y+9, r20	; 0x09
    3494:	5a 87       	std	Y+10, r21	; 0x0a
    3496:	6b 87       	std	Y+11, r22	; 0x0b
    3498:	7c 87       	std	Y+12, r23	; 0x0c
    349a:	8d 87       	std	Y+13, r24	; 0x0d
    349c:	9e 87       	std	Y+14, r25	; 0x0e
    349e:	eb 8c       	ldd	r14, Y+27	; 0x1b
    34a0:	fc 8c       	ldd	r15, Y+28	; 0x1c
    34a2:	0d 8d       	ldd	r16, Y+29	; 0x1d
    34a4:	1e 8d       	ldd	r17, Y+30	; 0x1e
		float Output;
		
		// Calculate Terms 
	    PID_Term->P  = ((float)(Value * PID_Params._P) / 20.0f);						
    34a6:	69 81       	ldd	r22, Y+1	; 0x01
    34a8:	7a 81       	ldd	r23, Y+2	; 0x02
    34aa:	88 27       	eor	r24, r24
    34ac:	77 fd       	sbrc	r23, 7
    34ae:	80 95       	com	r24
    34b0:	98 2f       	mov	r25, r24
    34b2:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    34b6:	9b 01       	movw	r18, r22
    34b8:	ac 01       	movw	r20, r24
    34ba:	c8 01       	movw	r24, r16
    34bc:	b7 01       	movw	r22, r14
    34be:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    34c2:	20 e0       	ldi	r18, 0x00	; 0
    34c4:	30 e0       	ldi	r19, 0x00	; 0
    34c6:	40 ea       	ldi	r20, 0xA0	; 160
    34c8:	51 e4       	ldi	r21, 0x41	; 65
    34ca:	0e 94 9b 36 	call	0x6d36	; 0x6d36 <__divsf3>
    34ce:	f5 01       	movw	r30, r10
    34d0:	60 83       	st	Z, r22
    34d2:	71 83       	std	Z+1, r23	; 0x01
    34d4:	82 83       	std	Z+2, r24	; 0x02
    34d6:	93 83       	std	Z+3, r25	; 0x03
		
		
		
		int16_t DeltaError = (Value - PID_Term->Error);
    34d8:	c8 01       	movw	r24, r16
    34da:	b7 01       	movw	r22, r14
    34dc:	24 85       	ldd	r18, Z+12	; 0x0c
    34de:	35 85       	ldd	r19, Z+13	; 0x0d
    34e0:	46 85       	ldd	r20, Z+14	; 0x0e
    34e2:	57 85       	ldd	r21, Z+15	; 0x0f
    34e4:	0e 94 32 36 	call	0x6c64	; 0x6c64 <__subsf3>
    34e8:	0e 94 03 37 	call	0x6e06	; 0x6e06 <__fixsfsi>
    34ec:	6b 01       	movw	r12, r22
		/*
		// I Logic here:
		// DEAD band = 2
		// Increment or Decrement by Value * PID_Params._I 
		*/
		if ((Value > 1) || (Value < -1))
    34ee:	c8 01       	movw	r24, r16
    34f0:	b7 01       	movw	r22, r14
    34f2:	20 e0       	ldi	r18, 0x00	; 0
    34f4:	30 e0       	ldi	r19, 0x00	; 0
    34f6:	40 e8       	ldi	r20, 0x80	; 128
    34f8:	5f e3       	ldi	r21, 0x3F	; 63
    34fa:	0e 94 e6 37 	call	0x6fcc	; 0x6fcc <__gesf2>
    34fe:	18 16       	cp	r1, r24
    3500:	54 f0       	brlt	.+20     	; 0x3516 <PID_Calculate+0xb8>
    3502:	c8 01       	movw	r24, r16
    3504:	b7 01       	movw	r22, r14
    3506:	20 e0       	ldi	r18, 0x00	; 0
    3508:	30 e0       	ldi	r19, 0x00	; 0
    350a:	40 e8       	ldi	r20, 0x80	; 128
    350c:	5f eb       	ldi	r21, 0xBF	; 191
    350e:	0e 94 97 36 	call	0x6d2e	; 0x6d2e <__cmpsf2>
    3512:	87 ff       	sbrs	r24, 7
    3514:	22 c0       	rjmp	.+68     	; 0x355a <PID_Calculate+0xfc>
		{	// only increment I when the Value is increasing compared to the old one, also use [-2,2] as deadband.
			PID_Term->I += (float)((float)(Value * PID_Params._I) / 200.0f) ;	// try to replace Value with DeltaError
    3516:	6d 81       	ldd	r22, Y+5	; 0x05
    3518:	7e 81       	ldd	r23, Y+6	; 0x06
    351a:	88 27       	eor	r24, r24
    351c:	77 fd       	sbrc	r23, 7
    351e:	80 95       	com	r24
    3520:	98 2f       	mov	r25, r24
    3522:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    3526:	9b 01       	movw	r18, r22
    3528:	ac 01       	movw	r20, r24
    352a:	c8 01       	movw	r24, r16
    352c:	b7 01       	movw	r22, r14
    352e:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    3532:	20 e0       	ldi	r18, 0x00	; 0
    3534:	30 e0       	ldi	r19, 0x00	; 0
    3536:	48 e4       	ldi	r20, 0x48	; 72
    3538:	53 e4       	ldi	r21, 0x43	; 67
    353a:	0e 94 9b 36 	call	0x6d36	; 0x6d36 <__divsf3>
    353e:	9b 01       	movw	r18, r22
    3540:	ac 01       	movw	r20, r24
    3542:	f5 01       	movw	r30, r10
    3544:	64 81       	ldd	r22, Z+4	; 0x04
    3546:	75 81       	ldd	r23, Z+5	; 0x05
    3548:	86 81       	ldd	r24, Z+6	; 0x06
    354a:	97 81       	ldd	r25, Z+7	; 0x07
    354c:	0e 94 33 36 	call	0x6c66	; 0x6c66 <__addsf3>
    3550:	f5 01       	movw	r30, r10
    3552:	64 83       	std	Z+4, r22	; 0x04
    3554:	75 83       	std	Z+5, r23	; 0x05
    3556:	86 83       	std	Z+6, r24	; 0x06
    3558:	97 83       	std	Z+7, r25	; 0x07
			//PID_Term->I -= (float)(PID_Term->I * PID_I_LEAK_RATE);
		//}	
		
		
		
		PID_Term->D= (float)(DeltaError * PID_Params._D) / 20.0f ;
    355a:	89 85       	ldd	r24, Y+9	; 0x09
    355c:	9a 85       	ldd	r25, Y+10	; 0x0a
    355e:	c8 9e       	mul	r12, r24
    3560:	b0 01       	movw	r22, r0
    3562:	c9 9e       	mul	r12, r25
    3564:	70 0d       	add	r23, r0
    3566:	d8 9e       	mul	r13, r24
    3568:	70 0d       	add	r23, r0
    356a:	11 24       	eor	r1, r1
    356c:	88 27       	eor	r24, r24
    356e:	77 fd       	sbrc	r23, 7
    3570:	80 95       	com	r24
    3572:	98 2f       	mov	r25, r24
    3574:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    3578:	20 e0       	ldi	r18, 0x00	; 0
    357a:	30 e0       	ldi	r19, 0x00	; 0
    357c:	40 ea       	ldi	r20, 0xA0	; 160
    357e:	51 e4       	ldi	r21, 0x41	; 65
    3580:	0e 94 9b 36 	call	0x6d36	; 0x6d36 <__divsf3>
    3584:	f5 01       	movw	r30, r10
    3586:	60 87       	std	Z+8, r22	; 0x08
    3588:	71 87       	std	Z+9, r23	; 0x09
    358a:	82 87       	std	Z+10, r24	; 0x0a
    358c:	93 87       	std	Z+11, r25	; 0x0b
		PID_Term->Error = Value;	
    358e:	e4 86       	std	Z+12, r14	; 0x0c
    3590:	f5 86       	std	Z+13, r15	; 0x0d
    3592:	06 87       	std	Z+14, r16	; 0x0e
    3594:	17 87       	std	Z+15, r17	; 0x0f
		
				
		// Limit boundaries to custom values defined by user.
		PID_Term->I= Limiterf(PID_Term->I, PID_Params._ILimit);
    3596:	e4 80       	ldd	r14, Z+4	; 0x04
    3598:	f5 80       	ldd	r15, Z+5	; 0x05
    359a:	06 81       	ldd	r16, Z+6	; 0x06
    359c:	17 81       	ldd	r17, Z+7	; 0x07
    359e:	6f 81       	ldd	r22, Y+7	; 0x07
    35a0:	78 85       	ldd	r23, Y+8	; 0x08
    35a2:	88 27       	eor	r24, r24
    35a4:	77 fd       	sbrc	r23, 7
    35a6:	80 95       	com	r24
    35a8:	98 2f       	mov	r25, r24
    35aa:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    35ae:	9b 01       	movw	r18, r22
    35b0:	ac 01       	movw	r20, r24
    35b2:	c8 01       	movw	r24, r16
    35b4:	b7 01       	movw	r22, r14
    35b6:	0e 94 54 21 	call	0x42a8	; 0x42a8 <Limiterf>
    35ba:	f5 01       	movw	r30, r10
    35bc:	64 83       	std	Z+4, r22	; 0x04
    35be:	75 83       	std	Z+5, r23	; 0x05
    35c0:	86 83       	std	Z+6, r24	; 0x06
    35c2:	97 83       	std	Z+7, r25	; 0x07
		PID_Term->P= Limiterf(PID_Term->P, PID_Params._PLimit);
    35c4:	e0 80       	ld	r14, Z
    35c6:	f1 80       	ldd	r15, Z+1	; 0x01
    35c8:	02 81       	ldd	r16, Z+2	; 0x02
    35ca:	13 81       	ldd	r17, Z+3	; 0x03
    35cc:	6b 81       	ldd	r22, Y+3	; 0x03
    35ce:	7c 81       	ldd	r23, Y+4	; 0x04
    35d0:	88 27       	eor	r24, r24
    35d2:	77 fd       	sbrc	r23, 7
    35d4:	80 95       	com	r24
    35d6:	98 2f       	mov	r25, r24
    35d8:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    35dc:	9b 01       	movw	r18, r22
    35de:	ac 01       	movw	r20, r24
    35e0:	c8 01       	movw	r24, r16
    35e2:	b7 01       	movw	r22, r14
    35e4:	0e 94 54 21 	call	0x42a8	; 0x42a8 <Limiterf>
    35e8:	f5 01       	movw	r30, r10
    35ea:	60 83       	st	Z, r22
    35ec:	71 83       	std	Z+1, r23	; 0x01
    35ee:	82 83       	std	Z+2, r24	; 0x02
    35f0:	93 83       	std	Z+3, r25	; 0x03
	    PID_Term->D= Limiterf(PID_Term->D, PID_Params._DLimit);
    35f2:	e0 84       	ldd	r14, Z+8	; 0x08
    35f4:	f1 84       	ldd	r15, Z+9	; 0x09
    35f6:	02 85       	ldd	r16, Z+10	; 0x0a
    35f8:	13 85       	ldd	r17, Z+11	; 0x0b
    35fa:	6b 85       	ldd	r22, Y+11	; 0x0b
    35fc:	7c 85       	ldd	r23, Y+12	; 0x0c
    35fe:	88 27       	eor	r24, r24
    3600:	77 fd       	sbrc	r23, 7
    3602:	80 95       	com	r24
    3604:	98 2f       	mov	r25, r24
    3606:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    360a:	9b 01       	movw	r18, r22
    360c:	ac 01       	movw	r20, r24
    360e:	c8 01       	movw	r24, r16
    3610:	b7 01       	movw	r22, r14
    3612:	0e 94 54 21 	call	0x42a8	; 0x42a8 <Limiterf>
    3616:	7b 01       	movw	r14, r22
    3618:	8c 01       	movw	r16, r24
    361a:	f5 01       	movw	r30, r10
    361c:	60 87       	std	Z+8, r22	; 0x08
    361e:	71 87       	std	Z+9, r23	; 0x09
    3620:	82 87       	std	Z+10, r24	; 0x0a
    3622:	93 87       	std	Z+11, r25	; 0x0b
	
		Output = (PID_Term->P + PID_Term->I + PID_Term->D);	// P + I + D
    3624:	60 81       	ld	r22, Z
    3626:	71 81       	ldd	r23, Z+1	; 0x01
    3628:	82 81       	ldd	r24, Z+2	; 0x02
    362a:	93 81       	ldd	r25, Z+3	; 0x03
    362c:	24 81       	ldd	r18, Z+4	; 0x04
    362e:	35 81       	ldd	r19, Z+5	; 0x05
    3630:	46 81       	ldd	r20, Z+6	; 0x06
    3632:	57 81       	ldd	r21, Z+7	; 0x07
    3634:	0e 94 33 36 	call	0x6c66	; 0x6c66 <__addsf3>
    3638:	a8 01       	movw	r20, r16
    363a:	97 01       	movw	r18, r14
    363c:	0e 94 33 36 	call	0x6c66	; 0x6c66 <__addsf3>
		//Output = Output / 10;
		return  Output; //Limiter(Output,(int16_t)300);
}		
    3640:	2e 96       	adiw	r28, 0x0e	; 14
    3642:	0f b6       	in	r0, 0x3f	; 63
    3644:	f8 94       	cli
    3646:	de bf       	out	0x3e, r29	; 62
    3648:	0f be       	out	0x3f, r0	; 63
    364a:	cd bf       	out	0x3d, r28	; 61
    364c:	cf 91       	pop	r28
    364e:	df 91       	pop	r29
    3650:	1f 91       	pop	r17
    3652:	0f 91       	pop	r16
    3654:	ff 90       	pop	r15
    3656:	ef 90       	pop	r14
    3658:	df 90       	pop	r13
    365a:	cf 90       	pop	r12
    365c:	bf 90       	pop	r11
    365e:	af 90       	pop	r10
    3660:	08 95       	ret

00003662 <ZERO_Is>:

void ZERO_Is()
{
	PID_GyroTerms[PITCH_INDEX].I=0;
    3662:	80 e0       	ldi	r24, 0x00	; 0
    3664:	90 e0       	ldi	r25, 0x00	; 0
    3666:	dc 01       	movw	r26, r24
    3668:	80 93 7e 06 	sts	0x067E, r24
    366c:	90 93 7f 06 	sts	0x067F, r25
    3670:	a0 93 80 06 	sts	0x0680, r26
    3674:	b0 93 81 06 	sts	0x0681, r27
	PID_GyroTerms[ROLL_INDEX].I=0;
    3678:	80 93 96 06 	sts	0x0696, r24
    367c:	90 93 97 06 	sts	0x0697, r25
    3680:	a0 93 98 06 	sts	0x0698, r26
    3684:	b0 93 99 06 	sts	0x0699, r27
	PID_GyroTerms[YAW_INDEX].I=0;
    3688:	80 93 ae 06 	sts	0x06AE, r24
    368c:	90 93 af 06 	sts	0x06AF, r25
    3690:	a0 93 b0 06 	sts	0x06B0, r26
    3694:	b0 93 b1 06 	sts	0x06B1, r27
	PID_AccTerms[PITCH_INDEX].I=0;
    3698:	80 93 56 05 	sts	0x0556, r24
    369c:	90 93 57 05 	sts	0x0557, r25
    36a0:	a0 93 58 05 	sts	0x0558, r26
    36a4:	b0 93 59 05 	sts	0x0559, r27
	PID_AccTerms[ROLL_INDEX].I=0;
    36a8:	80 93 6e 05 	sts	0x056E, r24
    36ac:	90 93 6f 05 	sts	0x056F, r25
    36b0:	a0 93 70 05 	sts	0x0570, r26
    36b4:	b0 93 71 05 	sts	0x0571, r27
	PID_AccTerms[Z_INDEX].I=0;
    36b8:	80 93 86 05 	sts	0x0586, r24
    36bc:	90 93 87 05 	sts	0x0587, r25
    36c0:	a0 93 88 05 	sts	0x0588, r26
    36c4:	b0 93 89 05 	sts	0x0589, r27

	PID_SonarTerms[0].I=0;
    36c8:	80 93 b8 07 	sts	0x07B8, r24
    36cc:	90 93 b9 07 	sts	0x07B9, r25
    36d0:	a0 93 ba 07 	sts	0x07BA, r26
    36d4:	b0 93 bb 07 	sts	0x07BB, r27
}
    36d8:	08 95       	ret

000036da <RotateV>:
//#include "../Include/DCM.h"


// Rotate Estimated vector(s) with small angle approximation, according to the gyro data
void RotateV() 
{
    36da:	2f 92       	push	r2
    36dc:	3f 92       	push	r3
    36de:	4f 92       	push	r4
    36e0:	5f 92       	push	r5
    36e2:	6f 92       	push	r6
    36e4:	7f 92       	push	r7
    36e6:	8f 92       	push	r8
    36e8:	9f 92       	push	r9
    36ea:	af 92       	push	r10
    36ec:	bf 92       	push	r11
    36ee:	cf 92       	push	r12
    36f0:	df 92       	push	r13
    36f2:	ef 92       	push	r14
    36f4:	ff 92       	push	r15
    36f6:	0f 93       	push	r16
    36f8:	1f 93       	push	r17
    36fa:	df 93       	push	r29
    36fc:	cf 93       	push	r28
    36fe:	cd b7       	in	r28, 0x3d	; 61
    3700:	de b7       	in	r29, 0x3e	; 62
    3702:	28 97       	sbiw	r28, 0x08	; 8
    3704:	0f b6       	in	r0, 0x3f	; 63
    3706:	f8 94       	cli
    3708:	de bf       	out	0x3e, r29	; 62
    370a:	0f be       	out	0x3f, r0	; 63
    370c:	cd bf       	out	0x3d, r28	; 61
	  //v->Y += delta[PITCH] * v_tmp.Z + delta[YAW]   * v_tmp.X; 
	//*/
	//double oAnglePitch = AnglePitch;
	//double oAngleRoll = AngleRoll;
	//double oAngleZ     = AngleZ     ;
	AngleZ     -= (CompGyroRoll  * AngleRoll )  * GYRO_RATE + ( CompGyroPitch * AnglePitch) * GYRO_RATE;
    370e:	20 90 70 06 	lds	r2, 0x0670
    3712:	30 90 71 06 	lds	r3, 0x0671
    3716:	40 90 72 06 	lds	r4, 0x0672
    371a:	50 90 73 06 	lds	r5, 0x0673
    371e:	60 90 76 06 	lds	r6, 0x0676
    3722:	70 90 77 06 	lds	r7, 0x0677
    3726:	80 90 78 06 	lds	r8, 0x0678
    372a:	90 90 79 06 	lds	r9, 0x0679
    372e:	20 91 e2 06 	lds	r18, 0x06E2
    3732:	30 91 e3 06 	lds	r19, 0x06E3
    3736:	40 91 e4 06 	lds	r20, 0x06E4
    373a:	50 91 e5 06 	lds	r21, 0x06E5
    373e:	80 91 e4 05 	lds	r24, 0x05E4
    3742:	90 91 e5 05 	lds	r25, 0x05E5
    3746:	a0 91 e6 05 	lds	r26, 0x05E6
    374a:	b0 91 e7 05 	lds	r27, 0x05E7
    374e:	89 83       	std	Y+1, r24	; 0x01
    3750:	9a 83       	std	Y+2, r25	; 0x02
    3752:	ab 83       	std	Y+3, r26	; 0x03
    3754:	bc 83       	std	Y+4, r27	; 0x04
    3756:	e0 90 1a 06 	lds	r14, 0x061A
    375a:	f0 90 1b 06 	lds	r15, 0x061B
    375e:	00 91 1c 06 	lds	r16, 0x061C
    3762:	10 91 1d 06 	lds	r17, 0x061D
    3766:	c4 01       	movw	r24, r8
    3768:	b3 01       	movw	r22, r6
    376a:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    376e:	23 ed       	ldi	r18, 0xD3	; 211
    3770:	39 ed       	ldi	r19, 0xD9	; 217
    3772:	49 e4       	ldi	r20, 0x49	; 73
    3774:	5a e3       	ldi	r21, 0x3A	; 58
    3776:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    377a:	5b 01       	movw	r10, r22
    377c:	6c 01       	movw	r12, r24
    377e:	69 81       	ldd	r22, Y+1	; 0x01
    3780:	7a 81       	ldd	r23, Y+2	; 0x02
    3782:	8b 81       	ldd	r24, Y+3	; 0x03
    3784:	9c 81       	ldd	r25, Y+4	; 0x04
    3786:	a8 01       	movw	r20, r16
    3788:	97 01       	movw	r18, r14
    378a:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    378e:	23 ed       	ldi	r18, 0xD3	; 211
    3790:	39 ed       	ldi	r19, 0xD9	; 217
    3792:	49 e4       	ldi	r20, 0x49	; 73
    3794:	5a e3       	ldi	r21, 0x3A	; 58
    3796:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    379a:	9b 01       	movw	r18, r22
    379c:	ac 01       	movw	r20, r24
    379e:	c6 01       	movw	r24, r12
    37a0:	b5 01       	movw	r22, r10
    37a2:	0e 94 33 36 	call	0x6c66	; 0x6c66 <__addsf3>
    37a6:	9b 01       	movw	r18, r22
    37a8:	ac 01       	movw	r20, r24
    37aa:	c2 01       	movw	r24, r4
    37ac:	b1 01       	movw	r22, r2
    37ae:	0e 94 32 36 	call	0x6c64	; 0x6c64 <__subsf3>
    37b2:	9b 01       	movw	r18, r22
    37b4:	ac 01       	movw	r20, r24
    37b6:	20 93 70 06 	sts	0x0670, r18
    37ba:	30 93 71 06 	sts	0x0671, r19
    37be:	40 93 72 06 	sts	0x0672, r20
    37c2:	50 93 73 06 	sts	0x0673, r21
	AngleRoll  += (CompGyroRoll  * AngleZ )     * GYRO_RATE - ( CompGyroZ     * AnglePitch) * GYRO_RATE;
    37c6:	80 91 e2 06 	lds	r24, 0x06E2
    37ca:	90 91 e3 06 	lds	r25, 0x06E3
    37ce:	a0 91 e4 06 	lds	r26, 0x06E4
    37d2:	b0 91 e5 06 	lds	r27, 0x06E5
    37d6:	8d 83       	std	Y+5, r24	; 0x05
    37d8:	9e 83       	std	Y+6, r25	; 0x06
    37da:	af 83       	std	Y+7, r26	; 0x07
    37dc:	b8 87       	std	Y+8, r27	; 0x08
    37de:	20 91 70 06 	lds	r18, 0x0670
    37e2:	30 91 71 06 	lds	r19, 0x0671
    37e6:	40 91 72 06 	lds	r20, 0x0672
    37ea:	50 91 73 06 	lds	r21, 0x0673
    37ee:	20 90 21 06 	lds	r2, 0x0621
    37f2:	30 90 22 06 	lds	r3, 0x0622
    37f6:	40 90 23 06 	lds	r4, 0x0623
    37fa:	50 90 24 06 	lds	r5, 0x0624
    37fe:	e0 90 1a 06 	lds	r14, 0x061A
    3802:	f0 90 1b 06 	lds	r15, 0x061B
    3806:	00 91 1c 06 	lds	r16, 0x061C
    380a:	10 91 1d 06 	lds	r17, 0x061D
    380e:	c4 01       	movw	r24, r8
    3810:	b3 01       	movw	r22, r6
    3812:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    3816:	23 ed       	ldi	r18, 0xD3	; 211
    3818:	39 ed       	ldi	r19, 0xD9	; 217
    381a:	49 e4       	ldi	r20, 0x49	; 73
    381c:	5a e3       	ldi	r21, 0x3A	; 58
    381e:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    3822:	5b 01       	movw	r10, r22
    3824:	6c 01       	movw	r12, r24
    3826:	c2 01       	movw	r24, r4
    3828:	b1 01       	movw	r22, r2
    382a:	a8 01       	movw	r20, r16
    382c:	97 01       	movw	r18, r14
    382e:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    3832:	23 ed       	ldi	r18, 0xD3	; 211
    3834:	39 ed       	ldi	r19, 0xD9	; 217
    3836:	49 e4       	ldi	r20, 0x49	; 73
    3838:	5a e3       	ldi	r21, 0x3A	; 58
    383a:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    383e:	9b 01       	movw	r18, r22
    3840:	ac 01       	movw	r20, r24
    3842:	c6 01       	movw	r24, r12
    3844:	b5 01       	movw	r22, r10
    3846:	0e 94 32 36 	call	0x6c64	; 0x6c64 <__subsf3>
    384a:	9b 01       	movw	r18, r22
    384c:	ac 01       	movw	r20, r24
    384e:	6d 81       	ldd	r22, Y+5	; 0x05
    3850:	7e 81       	ldd	r23, Y+6	; 0x06
    3852:	8f 81       	ldd	r24, Y+7	; 0x07
    3854:	98 85       	ldd	r25, Y+8	; 0x08
    3856:	0e 94 33 36 	call	0x6c66	; 0x6c66 <__addsf3>
    385a:	9b 01       	movw	r18, r22
    385c:	ac 01       	movw	r20, r24
    385e:	20 93 e2 06 	sts	0x06E2, r18
    3862:	30 93 e3 06 	sts	0x06E3, r19
    3866:	40 93 e4 06 	sts	0x06E4, r20
    386a:	50 93 e5 06 	sts	0x06E5, r21
	AnglePitch += (CompGyroPitch * AngleZ )		* GYRO_RATE + ( CompGyroZ     * AngleRoll ) * GYRO_RATE;
    386e:	60 90 1a 06 	lds	r6, 0x061A
    3872:	70 90 1b 06 	lds	r7, 0x061B
    3876:	80 90 1c 06 	lds	r8, 0x061C
    387a:	90 90 1d 06 	lds	r9, 0x061D
    387e:	20 91 70 06 	lds	r18, 0x0670
    3882:	30 91 71 06 	lds	r19, 0x0671
    3886:	40 91 72 06 	lds	r20, 0x0672
    388a:	50 91 73 06 	lds	r21, 0x0673
    388e:	e0 90 e2 06 	lds	r14, 0x06E2
    3892:	f0 90 e3 06 	lds	r15, 0x06E3
    3896:	00 91 e4 06 	lds	r16, 0x06E4
    389a:	10 91 e5 06 	lds	r17, 0x06E5
    389e:	69 81       	ldd	r22, Y+1	; 0x01
    38a0:	7a 81       	ldd	r23, Y+2	; 0x02
    38a2:	8b 81       	ldd	r24, Y+3	; 0x03
    38a4:	9c 81       	ldd	r25, Y+4	; 0x04
    38a6:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    38aa:	23 ed       	ldi	r18, 0xD3	; 211
    38ac:	39 ed       	ldi	r19, 0xD9	; 217
    38ae:	49 e4       	ldi	r20, 0x49	; 73
    38b0:	5a e3       	ldi	r21, 0x3A	; 58
    38b2:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    38b6:	5b 01       	movw	r10, r22
    38b8:	6c 01       	movw	r12, r24
    38ba:	c2 01       	movw	r24, r4
    38bc:	b1 01       	movw	r22, r2
    38be:	a8 01       	movw	r20, r16
    38c0:	97 01       	movw	r18, r14
    38c2:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    38c6:	23 ed       	ldi	r18, 0xD3	; 211
    38c8:	39 ed       	ldi	r19, 0xD9	; 217
    38ca:	49 e4       	ldi	r20, 0x49	; 73
    38cc:	5a e3       	ldi	r21, 0x3A	; 58
    38ce:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    38d2:	9b 01       	movw	r18, r22
    38d4:	ac 01       	movw	r20, r24
    38d6:	c6 01       	movw	r24, r12
    38d8:	b5 01       	movw	r22, r10
    38da:	0e 94 33 36 	call	0x6c66	; 0x6c66 <__addsf3>
    38de:	9b 01       	movw	r18, r22
    38e0:	ac 01       	movw	r20, r24
    38e2:	c4 01       	movw	r24, r8
    38e4:	b3 01       	movw	r22, r6
    38e6:	0e 94 33 36 	call	0x6c66	; 0x6c66 <__addsf3>
    38ea:	9b 01       	movw	r18, r22
    38ec:	ac 01       	movw	r20, r24
    38ee:	20 93 1a 06 	sts	0x061A, r18
    38f2:	30 93 1b 06 	sts	0x061B, r19
    38f6:	40 93 1c 06 	sts	0x061C, r20
    38fa:	50 93 1d 06 	sts	0x061D, r21

}
    38fe:	28 96       	adiw	r28, 0x08	; 8
    3900:	0f b6       	in	r0, 0x3f	; 63
    3902:	f8 94       	cli
    3904:	de bf       	out	0x3e, r29	; 62
    3906:	0f be       	out	0x3f, r0	; 63
    3908:	cd bf       	out	0x3d, r28	; 61
    390a:	cf 91       	pop	r28
    390c:	df 91       	pop	r29
    390e:	1f 91       	pop	r17
    3910:	0f 91       	pop	r16
    3912:	ff 90       	pop	r15
    3914:	ef 90       	pop	r14
    3916:	df 90       	pop	r13
    3918:	cf 90       	pop	r12
    391a:	bf 90       	pop	r11
    391c:	af 90       	pop	r10
    391e:	9f 90       	pop	r9
    3920:	8f 90       	pop	r8
    3922:	7f 90       	pop	r7
    3924:	6f 90       	pop	r6
    3926:	5f 90       	pop	r5
    3928:	4f 90       	pop	r4
    392a:	3f 90       	pop	r3
    392c:	2f 90       	pop	r2
    392e:	08 95       	ret

00003930 <IMU_Reset>:


void IMU_Reset()
{
	
	AnglePitch=0;
    3930:	80 e0       	ldi	r24, 0x00	; 0
    3932:	90 e0       	ldi	r25, 0x00	; 0
    3934:	dc 01       	movw	r26, r24
    3936:	80 93 1a 06 	sts	0x061A, r24
    393a:	90 93 1b 06 	sts	0x061B, r25
    393e:	a0 93 1c 06 	sts	0x061C, r26
    3942:	b0 93 1d 06 	sts	0x061D, r27
	AngleRoll=0;
    3946:	80 93 e2 06 	sts	0x06E2, r24
    394a:	90 93 e3 06 	sts	0x06E3, r25
    394e:	a0 93 e4 06 	sts	0x06E4, r26
    3952:	b0 93 e5 06 	sts	0x06E5, r27
	AngleZ=0;
    3956:	80 93 70 06 	sts	0x0670, r24
    395a:	90 93 71 06 	sts	0x0671, r25
    395e:	a0 93 72 06 	sts	0x0672, r26
    3962:	b0 93 73 06 	sts	0x0673, r27
	
}
    3966:	08 95       	ret

00003968 <IMU>:
//////////////////////////////////////////////////////////////////////////
// inspired by link: http://scolton.blogspot.com/2012/09/a-bit-more-kk20-modding.html
// Although I implement PID and super position in http://hefnycopter.net/index.php/developing-source-code/22-quadcopter-control-function-layers.html
void IMU (void)
{
    3968:	2f 92       	push	r2
    396a:	3f 92       	push	r3
    396c:	4f 92       	push	r4
    396e:	5f 92       	push	r5
    3970:	6f 92       	push	r6
    3972:	7f 92       	push	r7
    3974:	8f 92       	push	r8
    3976:	9f 92       	push	r9
    3978:	af 92       	push	r10
    397a:	bf 92       	push	r11
    397c:	cf 92       	push	r12
    397e:	df 92       	push	r13
    3980:	ef 92       	push	r14
    3982:	ff 92       	push	r15
    3984:	0f 93       	push	r16
    3986:	1f 93       	push	r17
    3988:	cf 93       	push	r28
    398a:	df 93       	push	r29
	
		double Alpha;	
		double Beta;
	
	    // calculate ACC-Z
		Alpha = Config.AccParams[Z_INDEX].ComplementaryFilterAlpha / 1000.0;
    398c:	60 91 4d 07 	lds	r22, 0x074D
    3990:	70 91 4e 07 	lds	r23, 0x074E
    3994:	88 27       	eor	r24, r24
    3996:	77 fd       	sbrc	r23, 7
    3998:	80 95       	com	r24
    399a:	98 2f       	mov	r25, r24
    399c:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    39a0:	20 e0       	ldi	r18, 0x00	; 0
    39a2:	30 e0       	ldi	r19, 0x00	; 0
    39a4:	4a e7       	ldi	r20, 0x7A	; 122
    39a6:	54 e4       	ldi	r21, 0x44	; 68
    39a8:	0e 94 9b 36 	call	0x6d36	; 0x6d36 <__divsf3>
    39ac:	7b 01       	movw	r14, r22
    39ae:	8c 01       	movw	r16, r24
		Beta = 1- Alpha; // complementary filter to remove noise
		CompAccZ = (double) (Alpha * CompAccZ) + (double) (Beta * Sensors_Latest[ACC_Z_Index]);
    39b0:	a0 90 53 06 	lds	r10, 0x0653
    39b4:	b0 90 54 06 	lds	r11, 0x0654
    39b8:	c0 90 55 06 	lds	r12, 0x0655
    39bc:	d0 90 56 06 	lds	r13, 0x0656
    39c0:	7f 2d       	mov	r23, r15
    39c2:	91 2f       	mov	r25, r17
    39c4:	20 91 3b 06 	lds	r18, 0x063B
    39c8:	30 91 3c 06 	lds	r19, 0x063C
    39cc:	40 91 3d 06 	lds	r20, 0x063D
    39d0:	50 91 3e 06 	lds	r21, 0x063E
    39d4:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    39d8:	3b 01       	movw	r6, r22
    39da:	4c 01       	movw	r8, r24
		double Alpha;	
		double Beta;
	
	    // calculate ACC-Z
		Alpha = Config.AccParams[Z_INDEX].ComplementaryFilterAlpha / 1000.0;
		Beta = 1- Alpha; // complementary filter to remove noise
    39dc:	60 e0       	ldi	r22, 0x00	; 0
    39de:	70 e0       	ldi	r23, 0x00	; 0
    39e0:	80 e8       	ldi	r24, 0x80	; 128
    39e2:	9f e3       	ldi	r25, 0x3F	; 63
    39e4:	2e 2d       	mov	r18, r14
    39e6:	3f 2d       	mov	r19, r15
    39e8:	40 2f       	mov	r20, r16
    39ea:	51 2f       	mov	r21, r17
    39ec:	0e 94 32 36 	call	0x6c64	; 0x6c64 <__subsf3>
		CompAccZ = (double) (Alpha * CompAccZ) + (double) (Beta * Sensors_Latest[ACC_Z_Index]);
    39f0:	a6 01       	movw	r20, r12
    39f2:	95 01       	movw	r18, r10
    39f4:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    39f8:	9b 01       	movw	r18, r22
    39fa:	ac 01       	movw	r20, r24
    39fc:	c4 01       	movw	r24, r8
    39fe:	b3 01       	movw	r22, r6
    3a00:	0e 94 33 36 	call	0x6c66	; 0x6c66 <__addsf3>
    3a04:	60 93 3b 06 	sts	0x063B, r22
    3a08:	70 93 3c 06 	sts	0x063C, r23
    3a0c:	80 93 3d 06 	sts	0x063D, r24
    3a10:	90 93 3e 06 	sts	0x063E, r25
		
		// calculate YAW
		Alpha = Config.GyroParams[YAW_INDEX].ComplementaryFilterAlpha / 1000.0;
    3a14:	60 91 23 07 	lds	r22, 0x0723
    3a18:	70 91 24 07 	lds	r23, 0x0724
    3a1c:	88 27       	eor	r24, r24
    3a1e:	77 fd       	sbrc	r23, 7
    3a20:	80 95       	com	r24
    3a22:	98 2f       	mov	r25, r24
    3a24:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    3a28:	20 e0       	ldi	r18, 0x00	; 0
    3a2a:	30 e0       	ldi	r19, 0x00	; 0
    3a2c:	4a e7       	ldi	r20, 0x7A	; 122
    3a2e:	54 e4       	ldi	r21, 0x44	; 68
    3a30:	0e 94 9b 36 	call	0x6d36	; 0x6d36 <__divsf3>
    3a34:	7b 01       	movw	r14, r22
    3a36:	8c 01       	movw	r16, r24
		Beta = 1- Alpha; // complementary filter to remove noise
		CompGyroZ = (double) (Alpha * CompGyroZ) + (double) (Beta * Sensors_Latest[GYRO_Z_Index]);
    3a38:	a0 90 47 06 	lds	r10, 0x0647
    3a3c:	b0 90 48 06 	lds	r11, 0x0648
    3a40:	c0 90 49 06 	lds	r12, 0x0649
    3a44:	d0 90 4a 06 	lds	r13, 0x064A
    3a48:	7f 2d       	mov	r23, r15
    3a4a:	91 2f       	mov	r25, r17
    3a4c:	20 91 21 06 	lds	r18, 0x0621
    3a50:	30 91 22 06 	lds	r19, 0x0622
    3a54:	40 91 23 06 	lds	r20, 0x0623
    3a58:	50 91 24 06 	lds	r21, 0x0624
    3a5c:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    3a60:	3b 01       	movw	r6, r22
    3a62:	4c 01       	movw	r8, r24
		Beta = 1- Alpha; // complementary filter to remove noise
		CompAccZ = (double) (Alpha * CompAccZ) + (double) (Beta * Sensors_Latest[ACC_Z_Index]);
		
		// calculate YAW
		Alpha = Config.GyroParams[YAW_INDEX].ComplementaryFilterAlpha / 1000.0;
		Beta = 1- Alpha; // complementary filter to remove noise
    3a64:	60 e0       	ldi	r22, 0x00	; 0
    3a66:	70 e0       	ldi	r23, 0x00	; 0
    3a68:	80 e8       	ldi	r24, 0x80	; 128
    3a6a:	9f e3       	ldi	r25, 0x3F	; 63
    3a6c:	2e 2d       	mov	r18, r14
    3a6e:	3f 2d       	mov	r19, r15
    3a70:	40 2f       	mov	r20, r16
    3a72:	51 2f       	mov	r21, r17
    3a74:	0e 94 32 36 	call	0x6c64	; 0x6c64 <__subsf3>
		CompGyroZ = (double) (Alpha * CompGyroZ) + (double) (Beta * Sensors_Latest[GYRO_Z_Index]);
    3a78:	a6 01       	movw	r20, r12
    3a7a:	95 01       	movw	r18, r10
    3a7c:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    3a80:	9b 01       	movw	r18, r22
    3a82:	ac 01       	movw	r20, r24
    3a84:	c4 01       	movw	r24, r8
    3a86:	b3 01       	movw	r22, r6
    3a88:	0e 94 33 36 	call	0x6c66	; 0x6c66 <__addsf3>
    3a8c:	60 93 21 06 	sts	0x0621, r22
    3a90:	70 93 22 06 	sts	0x0622, r23
    3a94:	80 93 23 06 	sts	0x0623, r24
    3a98:	90 93 24 06 	sts	0x0624, r25
		
		Alpha = Config.GyroParams[PITCH_INDEX].ComplementaryFilterAlpha / 1000.0;
    3a9c:	60 91 07 07 	lds	r22, 0x0707
    3aa0:	70 91 08 07 	lds	r23, 0x0708
    3aa4:	88 27       	eor	r24, r24
    3aa6:	77 fd       	sbrc	r23, 7
    3aa8:	80 95       	com	r24
    3aaa:	98 2f       	mov	r25, r24
    3aac:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    3ab0:	20 e0       	ldi	r18, 0x00	; 0
    3ab2:	30 e0       	ldi	r19, 0x00	; 0
    3ab4:	4a e7       	ldi	r20, 0x7A	; 122
    3ab6:	54 e4       	ldi	r21, 0x44	; 68
    3ab8:	0e 94 9b 36 	call	0x6d36	; 0x6d36 <__divsf3>
    3abc:	7b 01       	movw	r14, r22
    3abe:	8c 01       	movw	r16, r24
		Beta = 1- Alpha; // complementary filter to remove noise
		CompGyroPitch = (double) (Alpha * CompGyroPitch) + (double) (Beta * Sensors_Latest[GYRO_PITCH_Index]);
    3ac0:	a0 90 43 06 	lds	r10, 0x0643
    3ac4:	b0 90 44 06 	lds	r11, 0x0644
    3ac8:	c0 90 45 06 	lds	r12, 0x0645
    3acc:	d0 90 46 06 	lds	r13, 0x0646
    3ad0:	7f 2d       	mov	r23, r15
    3ad2:	91 2f       	mov	r25, r17
    3ad4:	20 91 e4 05 	lds	r18, 0x05E4
    3ad8:	30 91 e5 05 	lds	r19, 0x05E5
    3adc:	40 91 e6 05 	lds	r20, 0x05E6
    3ae0:	50 91 e7 05 	lds	r21, 0x05E7
    3ae4:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    3ae8:	3b 01       	movw	r6, r22
    3aea:	4c 01       	movw	r8, r24
		Alpha = Config.GyroParams[YAW_INDEX].ComplementaryFilterAlpha / 1000.0;
		Beta = 1- Alpha; // complementary filter to remove noise
		CompGyroZ = (double) (Alpha * CompGyroZ) + (double) (Beta * Sensors_Latest[GYRO_Z_Index]);
		
		Alpha = Config.GyroParams[PITCH_INDEX].ComplementaryFilterAlpha / 1000.0;
		Beta = 1- Alpha; // complementary filter to remove noise
    3aec:	60 e0       	ldi	r22, 0x00	; 0
    3aee:	70 e0       	ldi	r23, 0x00	; 0
    3af0:	80 e8       	ldi	r24, 0x80	; 128
    3af2:	9f e3       	ldi	r25, 0x3F	; 63
    3af4:	2e 2d       	mov	r18, r14
    3af6:	3f 2d       	mov	r19, r15
    3af8:	40 2f       	mov	r20, r16
    3afa:	51 2f       	mov	r21, r17
    3afc:	0e 94 32 36 	call	0x6c64	; 0x6c64 <__subsf3>
		CompGyroPitch = (double) (Alpha * CompGyroPitch) + (double) (Beta * Sensors_Latest[GYRO_PITCH_Index]);
    3b00:	a6 01       	movw	r20, r12
    3b02:	95 01       	movw	r18, r10
    3b04:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    3b08:	9b 01       	movw	r18, r22
    3b0a:	ac 01       	movw	r20, r24
    3b0c:	c4 01       	movw	r24, r8
    3b0e:	b3 01       	movw	r22, r6
    3b10:	0e 94 33 36 	call	0x6c66	; 0x6c66 <__addsf3>
    3b14:	d6 2e       	mov	r13, r22
    3b16:	c7 2e       	mov	r12, r23
    3b18:	b8 2e       	mov	r11, r24
    3b1a:	a9 2e       	mov	r10, r25
    3b1c:	a6 01       	movw	r20, r12
    3b1e:	95 01       	movw	r18, r10
    3b20:	85 2f       	mov	r24, r21
    3b22:	94 2f       	mov	r25, r20
    3b24:	a3 2f       	mov	r26, r19
    3b26:	b2 2f       	mov	r27, r18
    3b28:	80 93 e4 05 	sts	0x05E4, r24
    3b2c:	90 93 e5 05 	sts	0x05E5, r25
    3b30:	a0 93 e6 05 	sts	0x05E6, r26
    3b34:	b0 93 e7 05 	sts	0x05E7, r27
		Alpha = Config.GyroParams[ROLL_INDEX].ComplementaryFilterAlpha / 1000.0;
    3b38:	60 91 15 07 	lds	r22, 0x0715
    3b3c:	70 91 16 07 	lds	r23, 0x0716
    3b40:	88 27       	eor	r24, r24
    3b42:	77 fd       	sbrc	r23, 7
    3b44:	80 95       	com	r24
    3b46:	98 2f       	mov	r25, r24
    3b48:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    3b4c:	20 e0       	ldi	r18, 0x00	; 0
    3b4e:	30 e0       	ldi	r19, 0x00	; 0
    3b50:	4a e7       	ldi	r20, 0x7A	; 122
    3b52:	54 e4       	ldi	r21, 0x44	; 68
    3b54:	0e 94 9b 36 	call	0x6d36	; 0x6d36 <__divsf3>
    3b58:	f6 2e       	mov	r15, r22
    3b5a:	07 2f       	mov	r16, r23
    3b5c:	18 2f       	mov	r17, r24
    3b5e:	e9 2e       	mov	r14, r25
		Beta = 1- Alpha; // complementary filter to remove noise
		CompGyroRoll  = (double) (Alpha * CompGyroRoll)  + (double) (Beta * Sensors_Latest[GYRO_ROLL_Index]);
    3b60:	60 90 3f 06 	lds	r6, 0x063F
    3b64:	70 90 40 06 	lds	r7, 0x0640
    3b68:	80 90 41 06 	lds	r8, 0x0641
    3b6c:	90 90 42 06 	lds	r9, 0x0642
    3b70:	20 91 76 06 	lds	r18, 0x0676
    3b74:	30 91 77 06 	lds	r19, 0x0677
    3b78:	40 91 78 06 	lds	r20, 0x0678
    3b7c:	50 91 79 06 	lds	r21, 0x0679
    3b80:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    3b84:	1b 01       	movw	r2, r22
    3b86:	2c 01       	movw	r4, r24
		
		Alpha = Config.GyroParams[PITCH_INDEX].ComplementaryFilterAlpha / 1000.0;
		Beta = 1- Alpha; // complementary filter to remove noise
		CompGyroPitch = (double) (Alpha * CompGyroPitch) + (double) (Beta * Sensors_Latest[GYRO_PITCH_Index]);
		Alpha = Config.GyroParams[ROLL_INDEX].ComplementaryFilterAlpha / 1000.0;
		Beta = 1- Alpha; // complementary filter to remove noise
    3b88:	60 e0       	ldi	r22, 0x00	; 0
    3b8a:	70 e0       	ldi	r23, 0x00	; 0
    3b8c:	80 e8       	ldi	r24, 0x80	; 128
    3b8e:	9f e3       	ldi	r25, 0x3F	; 63
    3b90:	2f 2d       	mov	r18, r15
    3b92:	30 2f       	mov	r19, r16
    3b94:	41 2f       	mov	r20, r17
    3b96:	5e 2d       	mov	r21, r14
    3b98:	0e 94 32 36 	call	0x6c64	; 0x6c64 <__subsf3>
		CompGyroRoll  = (double) (Alpha * CompGyroRoll)  + (double) (Beta * Sensors_Latest[GYRO_ROLL_Index]);
    3b9c:	a4 01       	movw	r20, r8
    3b9e:	93 01       	movw	r18, r6
    3ba0:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    3ba4:	9b 01       	movw	r18, r22
    3ba6:	ac 01       	movw	r20, r24
    3ba8:	c2 01       	movw	r24, r4
    3baa:	b1 01       	movw	r22, r2
    3bac:	0e 94 33 36 	call	0x6c66	; 0x6c66 <__addsf3>
    3bb0:	60 93 76 06 	sts	0x0676, r22
    3bb4:	70 93 77 06 	sts	0x0677, r23
    3bb8:	80 93 78 06 	sts	0x0678, r24
    3bbc:	90 93 79 06 	sts	0x0679, r25
		
					
		// GYRO Always calculated.
		gyroPitch =	PID_Calculate (Config.GyroParams[PITCH_INDEX],	&PID_GyroTerms[PITCH_INDEX],CompGyroPitch);	
    3bc0:	00 d0       	rcall	.+0      	; 0x3bc2 <IMU+0x25a>
    3bc2:	00 d0       	rcall	.+0      	; 0x3bc4 <IMU+0x25c>
    3bc4:	a6 01       	movw	r20, r12
    3bc6:	95 01       	movw	r18, r10
    3bc8:	85 2f       	mov	r24, r21
    3bca:	94 2f       	mov	r25, r20
    3bcc:	a3 2f       	mov	r26, r19
    3bce:	b2 2f       	mov	r27, r18
    3bd0:	ed b7       	in	r30, 0x3d	; 61
    3bd2:	fe b7       	in	r31, 0x3e	; 62
    3bd4:	81 83       	std	Z+1, r24	; 0x01
    3bd6:	92 83       	std	Z+2, r25	; 0x02
    3bd8:	a3 83       	std	Z+3, r26	; 0x03
    3bda:	b4 83       	std	Z+4, r27	; 0x04
    3bdc:	c0 90 fb 06 	lds	r12, 0x06FB
    3be0:	d0 90 fc 06 	lds	r13, 0x06FC
    3be4:	e0 90 fd 06 	lds	r14, 0x06FD
    3be8:	f0 90 fe 06 	lds	r15, 0x06FE
    3bec:	00 91 ff 06 	lds	r16, 0x06FF
    3bf0:	10 91 00 07 	lds	r17, 0x0700
    3bf4:	20 91 01 07 	lds	r18, 0x0701
    3bf8:	30 91 02 07 	lds	r19, 0x0702
    3bfc:	40 91 03 07 	lds	r20, 0x0703
    3c00:	50 91 04 07 	lds	r21, 0x0704
    3c04:	60 91 05 07 	lds	r22, 0x0705
    3c08:	70 91 06 07 	lds	r23, 0x0706
    3c0c:	80 91 07 07 	lds	r24, 0x0707
    3c10:	90 91 08 07 	lds	r25, 0x0708
    3c14:	aa e7       	ldi	r26, 0x7A	; 122
    3c16:	aa 2e       	mov	r10, r26
    3c18:	a6 e0       	ldi	r26, 0x06	; 6
    3c1a:	ba 2e       	mov	r11, r26
    3c1c:	0e 94 2f 1a 	call	0x345e	; 0x345e <PID_Calculate>
    3c20:	0e 94 03 37 	call	0x6e06	; 0x6e06 <__fixsfsi>
    3c24:	70 93 3a 06 	sts	0x063A, r23
    3c28:	60 93 39 06 	sts	0x0639, r22
		gyroRoll  = PID_Calculate (Config.GyroParams[ROLL_INDEX],	&PID_GyroTerms[ROLL_INDEX],CompGyroRoll); 
    3c2c:	80 91 76 06 	lds	r24, 0x0676
    3c30:	90 91 77 06 	lds	r25, 0x0677
    3c34:	a0 91 78 06 	lds	r26, 0x0678
    3c38:	b0 91 79 06 	lds	r27, 0x0679
    3c3c:	ed b7       	in	r30, 0x3d	; 61
    3c3e:	fe b7       	in	r31, 0x3e	; 62
    3c40:	81 83       	std	Z+1, r24	; 0x01
    3c42:	92 83       	std	Z+2, r25	; 0x02
    3c44:	a3 83       	std	Z+3, r26	; 0x03
    3c46:	b4 83       	std	Z+4, r27	; 0x04
    3c48:	c0 90 09 07 	lds	r12, 0x0709
    3c4c:	d0 90 0a 07 	lds	r13, 0x070A
    3c50:	e0 90 0b 07 	lds	r14, 0x070B
    3c54:	f0 90 0c 07 	lds	r15, 0x070C
    3c58:	00 91 0d 07 	lds	r16, 0x070D
    3c5c:	10 91 0e 07 	lds	r17, 0x070E
    3c60:	20 91 0f 07 	lds	r18, 0x070F
    3c64:	30 91 10 07 	lds	r19, 0x0710
    3c68:	40 91 11 07 	lds	r20, 0x0711
    3c6c:	50 91 12 07 	lds	r21, 0x0712
    3c70:	60 91 13 07 	lds	r22, 0x0713
    3c74:	70 91 14 07 	lds	r23, 0x0714
    3c78:	80 91 15 07 	lds	r24, 0x0715
    3c7c:	90 91 16 07 	lds	r25, 0x0716
    3c80:	f2 e9       	ldi	r31, 0x92	; 146
    3c82:	af 2e       	mov	r10, r31
    3c84:	f6 e0       	ldi	r31, 0x06	; 6
    3c86:	bf 2e       	mov	r11, r31
    3c88:	0e 94 2f 1a 	call	0x345e	; 0x345e <PID_Calculate>
    3c8c:	0e 94 03 37 	call	0x6e06	; 0x6e06 <__fixsfsi>
    3c90:	70 93 bb 05 	sts	0x05BB, r23
    3c94:	60 93 ba 05 	sts	0x05BA, r22
		gyroYaw   = PID_Calculate (Config.GyroParams[YAW_INDEX],	&PID_GyroTerms[YAW_INDEX],CompGyroZ -((double)((float)RX_Snapshot[RXChannel_RUD]  * 0.5f))); 
    3c98:	cd b7       	in	r28, 0x3d	; 61
    3c9a:	de b7       	in	r29, 0x3e	; 62
    3c9c:	21 96       	adiw	r28, 0x01	; 1
    3c9e:	60 91 c6 05 	lds	r22, 0x05C6
    3ca2:	70 91 c7 05 	lds	r23, 0x05C7
    3ca6:	88 27       	eor	r24, r24
    3ca8:	77 fd       	sbrc	r23, 7
    3caa:	80 95       	com	r24
    3cac:	98 2f       	mov	r25, r24
    3cae:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    3cb2:	20 e0       	ldi	r18, 0x00	; 0
    3cb4:	30 e0       	ldi	r19, 0x00	; 0
    3cb6:	40 e0       	ldi	r20, 0x00	; 0
    3cb8:	5f e3       	ldi	r21, 0x3F	; 63
    3cba:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    3cbe:	9b 01       	movw	r18, r22
    3cc0:	ac 01       	movw	r20, r24
    3cc2:	60 91 21 06 	lds	r22, 0x0621
    3cc6:	70 91 22 06 	lds	r23, 0x0622
    3cca:	80 91 23 06 	lds	r24, 0x0623
    3cce:	90 91 24 06 	lds	r25, 0x0624
    3cd2:	0e 94 32 36 	call	0x6c64	; 0x6c64 <__subsf3>
    3cd6:	68 83       	st	Y, r22
    3cd8:	79 83       	std	Y+1, r23	; 0x01
    3cda:	8a 83       	std	Y+2, r24	; 0x02
    3cdc:	9b 83       	std	Y+3, r25	; 0x03
    3cde:	c0 90 17 07 	lds	r12, 0x0717
    3ce2:	d0 90 18 07 	lds	r13, 0x0718
    3ce6:	e0 90 19 07 	lds	r14, 0x0719
    3cea:	f0 90 1a 07 	lds	r15, 0x071A
    3cee:	00 91 1b 07 	lds	r16, 0x071B
    3cf2:	10 91 1c 07 	lds	r17, 0x071C
    3cf6:	20 91 1d 07 	lds	r18, 0x071D
    3cfa:	30 91 1e 07 	lds	r19, 0x071E
    3cfe:	40 91 1f 07 	lds	r20, 0x071F
    3d02:	50 91 20 07 	lds	r21, 0x0720
    3d06:	60 91 21 07 	lds	r22, 0x0721
    3d0a:	70 91 22 07 	lds	r23, 0x0722
    3d0e:	80 91 23 07 	lds	r24, 0x0723
    3d12:	90 91 24 07 	lds	r25, 0x0724
    3d16:	ea ea       	ldi	r30, 0xAA	; 170
    3d18:	ae 2e       	mov	r10, r30
    3d1a:	e6 e0       	ldi	r30, 0x06	; 6
    3d1c:	be 2e       	mov	r11, r30
    3d1e:	0e 94 2f 1a 	call	0x345e	; 0x345e <PID_Calculate>
    3d22:	0e 94 03 37 	call	0x6e06	; 0x6e06 <__fixsfsi>
    3d26:	70 93 ea 06 	sts	0x06EA, r23
    3d2a:	60 93 e9 06 	sts	0x06E9, r22
	
			
		// Read ACC and Trims
		// ACC directions are same as GYRO direction [we added "-" for this purpose] 
		double APitch = - Sensors_Latest[ACC_PITCH_Index] - Config.Acc_Pitch_Trim;
    3d2e:	80 91 4b 06 	lds	r24, 0x064B
    3d32:	90 91 4c 06 	lds	r25, 0x064C
    3d36:	a0 91 4d 06 	lds	r26, 0x064D
    3d3a:	b0 91 4e 06 	lds	r27, 0x064E
		double ARoll  = - Sensors_Latest[ACC_ROLL_Index]  - Config.Acc_Roll_Trim;
    3d3e:	80 91 4f 06 	lds	r24, 0x064F
    3d42:	90 91 50 06 	lds	r25, 0x0650
    3d46:	a0 91 51 06 	lds	r26, 0x0651
    3d4a:	b0 91 52 06 	lds	r27, 0x0652
		double DT_YAW =  (double)Sensors_Latest[GYRO_Z_Index] * GYRO_RATE * TimeDef * 0.001; 
    3d4e:	80 91 47 06 	lds	r24, 0x0647
    3d52:	90 91 48 06 	lds	r25, 0x0648
    3d56:	a0 91 49 06 	lds	r26, 0x0649
    3d5a:	b0 91 4a 06 	lds	r27, 0x064A
		
		if ( TCNT1H > TCNT1H_OLD) 
    3d5e:	20 91 85 00 	lds	r18, 0x0085
    3d62:	80 91 e0 06 	lds	r24, 0x06E0
    3d66:	90 91 e1 06 	lds	r25, 0x06E1
    3d6a:	30 e0       	ldi	r19, 0x00	; 0
    3d6c:	0f 90       	pop	r0
    3d6e:	0f 90       	pop	r0
    3d70:	0f 90       	pop	r0
    3d72:	0f 90       	pop	r0
    3d74:	82 17       	cp	r24, r18
    3d76:	93 07       	cpc	r25, r19
    3d78:	50 f4       	brcc	.+20     	; 0x3d8e <IMU+0x426>
		{
			TimeDef = TCNT1H - TCNT1H_OLD;
    3d7a:	80 91 85 00 	lds	r24, 0x0085
    3d7e:	20 91 e0 06 	lds	r18, 0x06E0
    3d82:	30 91 e1 06 	lds	r19, 0x06E1
    3d86:	90 e0       	ldi	r25, 0x00	; 0
    3d88:	82 1b       	sub	r24, r18
    3d8a:	93 0b       	sbc	r25, r19
    3d8c:	0a c0       	rjmp	.+20     	; 0x3da2 <IMU+0x43a>
		}
		else
		{
			TimeDef = 0xffff - TCNT1H_OLD + TCNT1H ;
    3d8e:	80 91 e0 06 	lds	r24, 0x06E0
    3d92:	90 91 e1 06 	lds	r25, 0x06E1
    3d96:	20 91 85 00 	lds	r18, 0x0085
    3d9a:	80 95       	com	r24
    3d9c:	90 95       	com	r25
    3d9e:	82 0f       	add	r24, r18
    3da0:	91 1d       	adc	r25, r1
    3da2:	90 93 e7 06 	sts	0x06E7, r25
    3da6:	80 93 e6 06 	sts	0x06E6, r24
		}
		TCNT1H_OLD += TimeDef;
    3daa:	80 91 e0 06 	lds	r24, 0x06E0
    3dae:	90 91 e1 06 	lds	r25, 0x06E1
    3db2:	60 91 e6 06 	lds	r22, 0x06E6
    3db6:	70 91 e7 06 	lds	r23, 0x06E7
    3dba:	86 0f       	add	r24, r22
    3dbc:	97 1f       	adc	r25, r23
    3dbe:	90 93 e1 06 	sts	0x06E1, r25
    3dc2:	80 93 e0 06 	sts	0x06E0, r24
		
		//// Do the Magic of IMU LEVELING here
		//// check also : http://scolton.blogspot.com/2012/09/fun-with-complementary-filter-multiwii.html
		AnglePitch = AnglePitch
				   + (double)Sensors_Latest[GYRO_PITCH_Index] * GYRO_RATE * TimeDef * 0.001
    3dc6:	60 90 1a 06 	lds	r6, 0x061A
    3dca:	70 90 1b 06 	lds	r7, 0x061B
    3dce:	80 90 1c 06 	lds	r8, 0x061C
    3dd2:	90 90 1d 06 	lds	r9, 0x061D
    3dd6:	e0 90 43 06 	lds	r14, 0x0643
    3dda:	f0 90 44 06 	lds	r15, 0x0644
    3dde:	00 91 45 06 	lds	r16, 0x0645
    3de2:	10 91 46 06 	lds	r17, 0x0646
    3de6:	80 e0       	ldi	r24, 0x00	; 0
    3de8:	90 e0       	ldi	r25, 0x00	; 0
    3dea:	0e 94 34 37 	call	0x6e68	; 0x6e68 <__floatunsisf>
    3dee:	5b 01       	movw	r10, r22
    3df0:	6c 01       	movw	r12, r24
    3df2:	c8 01       	movw	r24, r16
    3df4:	b7 01       	movw	r22, r14
    3df6:	23 ed       	ldi	r18, 0xD3	; 211
    3df8:	39 ed       	ldi	r19, 0xD9	; 217
    3dfa:	49 e4       	ldi	r20, 0x49	; 73
    3dfc:	5a e3       	ldi	r21, 0x3A	; 58
    3dfe:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    3e02:	a6 01       	movw	r20, r12
    3e04:	95 01       	movw	r18, r10
    3e06:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    3e0a:	2f e6       	ldi	r18, 0x6F	; 111
    3e0c:	32 e1       	ldi	r19, 0x12	; 18
    3e0e:	43 e8       	ldi	r20, 0x83	; 131
    3e10:	5a e3       	ldi	r21, 0x3A	; 58
    3e12:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    3e16:	9b 01       	movw	r18, r22
    3e18:	ac 01       	movw	r20, r24
    3e1a:	c4 01       	movw	r24, r8
    3e1c:	b3 01       	movw	r22, r6
    3e1e:	0e 94 33 36 	call	0x6c66	; 0x6c66 <__addsf3>
    3e22:	9b 01       	movw	r18, r22
    3e24:	ac 01       	movw	r20, r24
		}
		TCNT1H_OLD += TimeDef;
		
		//// Do the Magic of IMU LEVELING here
		//// check also : http://scolton.blogspot.com/2012/09/fun-with-complementary-filter-multiwii.html
		AnglePitch = AnglePitch
    3e26:	20 93 1a 06 	sts	0x061A, r18
    3e2a:	30 93 1b 06 	sts	0x061B, r19
    3e2e:	40 93 1c 06 	sts	0x061C, r20
    3e32:	50 93 1d 06 	sts	0x061D, r21
				   + (double)Sensors_Latest[GYRO_PITCH_Index] * GYRO_RATE * TimeDef * 0.001
					  // + (sin(AngleRoll * DEG_TO_RAD) * DT_YAW)  // integrate component of yaw rate into pitch angle
						;
		AngleRoll = AngleRoll  
				  + (double)Sensors_Latest[GYRO_ROLL_Index]  * GYRO_RATE * TimeDef * 0.001
    3e36:	e0 90 e2 06 	lds	r14, 0x06E2
    3e3a:	f0 90 e3 06 	lds	r15, 0x06E3
    3e3e:	00 91 e4 06 	lds	r16, 0x06E4
    3e42:	10 91 e5 06 	lds	r17, 0x06E5
    3e46:	60 91 3f 06 	lds	r22, 0x063F
    3e4a:	70 91 40 06 	lds	r23, 0x0640
    3e4e:	80 91 41 06 	lds	r24, 0x0641
    3e52:	90 91 42 06 	lds	r25, 0x0642
    3e56:	23 ed       	ldi	r18, 0xD3	; 211
    3e58:	39 ed       	ldi	r19, 0xD9	; 217
    3e5a:	49 e4       	ldi	r20, 0x49	; 73
    3e5c:	5a e3       	ldi	r21, 0x3A	; 58
    3e5e:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    3e62:	a6 01       	movw	r20, r12
    3e64:	95 01       	movw	r18, r10
    3e66:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    3e6a:	2f e6       	ldi	r18, 0x6F	; 111
    3e6c:	32 e1       	ldi	r19, 0x12	; 18
    3e6e:	43 e8       	ldi	r20, 0x83	; 131
    3e70:	5a e3       	ldi	r21, 0x3A	; 58
    3e72:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    3e76:	9b 01       	movw	r18, r22
    3e78:	ac 01       	movw	r20, r24
    3e7a:	c8 01       	movw	r24, r16
    3e7c:	b7 01       	movw	r22, r14
    3e7e:	0e 94 33 36 	call	0x6c66	; 0x6c66 <__addsf3>
    3e82:	9b 01       	movw	r18, r22
    3e84:	ac 01       	movw	r20, r24
		//// check also : http://scolton.blogspot.com/2012/09/fun-with-complementary-filter-multiwii.html
		AnglePitch = AnglePitch
				   + (double)Sensors_Latest[GYRO_PITCH_Index] * GYRO_RATE * TimeDef * 0.001
					  // + (sin(AngleRoll * DEG_TO_RAD) * DT_YAW)  // integrate component of yaw rate into pitch angle
						;
		AngleRoll = AngleRoll  
    3e86:	20 93 e2 06 	sts	0x06E2, r18
    3e8a:	30 93 e3 06 	sts	0x06E3, r19
    3e8e:	40 93 e4 06 	sts	0x06E4, r20
    3e92:	50 93 e5 06 	sts	0x06E5, r21
			gyroRoll += PID_Calculate_ACC (Config.AccParams[ROLL_INDEX], &PID_AccTerms[ROLL_INDEX],NavX); //AngleRoll); 
		 
		}
		
	
}
    3e96:	df 91       	pop	r29
    3e98:	cf 91       	pop	r28
    3e9a:	1f 91       	pop	r17
    3e9c:	0f 91       	pop	r16
    3e9e:	ff 90       	pop	r15
    3ea0:	ef 90       	pop	r14
    3ea2:	df 90       	pop	r13
    3ea4:	cf 90       	pop	r12
    3ea6:	bf 90       	pop	r11
    3ea8:	af 90       	pop	r10
    3eaa:	9f 90       	pop	r9
    3eac:	8f 90       	pop	r8
    3eae:	7f 90       	pop	r7
    3eb0:	6f 90       	pop	r6
    3eb2:	5f 90       	pop	r5
    3eb4:	4f 90       	pop	r4
    3eb6:	3f 90       	pop	r3
    3eb8:	2f 90       	pop	r2
    3eba:	08 95       	ret

00003ebc <IMU_HeightKeeping>:

	

	
double IMU_HeightKeeping ()
{
    3ebc:	af 92       	push	r10
    3ebe:	bf 92       	push	r11
    3ec0:	cf 92       	push	r12
    3ec2:	df 92       	push	r13
    3ec4:	ef 92       	push	r14
    3ec6:	ff 92       	push	r15
    3ec8:	0f 93       	push	r16
    3eca:	1f 93       	push	r17
	double Temp;
//	ThrottleTemp = RX_Snapshot[RXChannel_THR];
	
	// calculate damping
	
	Landing = PID_Calculate (Config.AccParams[Z_INDEX], &PID_AccTerms[Z_INDEX],-CompAccZ) ;
    3ecc:	00 d0       	rcall	.+0      	; 0x3ece <IMU_HeightKeeping+0x12>
    3ece:	00 d0       	rcall	.+0      	; 0x3ed0 <IMU_HeightKeeping+0x14>
    3ed0:	80 91 3b 06 	lds	r24, 0x063B
    3ed4:	90 91 3c 06 	lds	r25, 0x063C
    3ed8:	a0 91 3d 06 	lds	r26, 0x063D
    3edc:	b0 91 3e 06 	lds	r27, 0x063E
    3ee0:	b0 58       	subi	r27, 0x80	; 128
    3ee2:	ed b7       	in	r30, 0x3d	; 61
    3ee4:	fe b7       	in	r31, 0x3e	; 62
    3ee6:	81 83       	std	Z+1, r24	; 0x01
    3ee8:	92 83       	std	Z+2, r25	; 0x02
    3eea:	a3 83       	std	Z+3, r26	; 0x03
    3eec:	b4 83       	std	Z+4, r27	; 0x04
    3eee:	c0 90 41 07 	lds	r12, 0x0741
    3ef2:	d0 90 42 07 	lds	r13, 0x0742
    3ef6:	e0 90 43 07 	lds	r14, 0x0743
    3efa:	f0 90 44 07 	lds	r15, 0x0744
    3efe:	00 91 45 07 	lds	r16, 0x0745
    3f02:	10 91 46 07 	lds	r17, 0x0746
    3f06:	20 91 47 07 	lds	r18, 0x0747
    3f0a:	30 91 48 07 	lds	r19, 0x0748
    3f0e:	40 91 49 07 	lds	r20, 0x0749
    3f12:	50 91 4a 07 	lds	r21, 0x074A
    3f16:	60 91 4b 07 	lds	r22, 0x074B
    3f1a:	70 91 4c 07 	lds	r23, 0x074C
    3f1e:	80 91 4d 07 	lds	r24, 0x074D
    3f22:	90 91 4e 07 	lds	r25, 0x074E
    3f26:	e2 e8       	ldi	r30, 0x82	; 130
    3f28:	ae 2e       	mov	r10, r30
    3f2a:	e5 e0       	ldi	r30, 0x05	; 5
    3f2c:	be 2e       	mov	r11, r30
    3f2e:	0e 94 2f 1a 	call	0x345e	; 0x345e <PID_Calculate>
    3f32:	60 93 6a 06 	sts	0x066A, r22
    3f36:	70 93 6b 06 	sts	0x066B, r23
    3f3a:	80 93 6c 06 	sts	0x066C, r24
    3f3e:	90 93 6d 06 	sts	0x066D, r25
			
			
	// Calculate Altitude Hold
	if ((Config.RX_mode==RX_mode_UARTMode) && (IS_MISC_SENSOR_SONAR_ENABLED==true) && (nFlyingModes == FLYINGMODE_ALTHOLD))
    3f42:	0f 90       	pop	r0
    3f44:	0f 90       	pop	r0
    3f46:	0f 90       	pop	r0
    3f48:	0f 90       	pop	r0
    3f4a:	80 91 ef 06 	lds	r24, 0x06EF
    3f4e:	8f 3f       	cpi	r24, 0xFF	; 255
    3f50:	09 f0       	breq	.+2      	; 0x3f54 <IMU_HeightKeeping+0x98>
    3f52:	f4 c0       	rjmp	.+488    	; 0x413c <IMU_HeightKeeping+0x280>
    3f54:	80 91 fa 06 	lds	r24, 0x06FA
    3f58:	80 ff       	sbrs	r24, 0
    3f5a:	f0 c0       	rjmp	.+480    	; 0x413c <IMU_HeightKeeping+0x280>
    3f5c:	80 91 1e 06 	lds	r24, 0x061E
    3f60:	84 30       	cpi	r24, 0x04	; 4
    3f62:	09 f0       	breq	.+2      	; 0x3f66 <IMU_HeightKeeping+0xaa>
    3f64:	eb c0       	rjmp	.+470    	; 0x413c <IMU_HeightKeeping+0x280>
	{
		RX_SONAR_TRIGGER = HIGH;
    3f66:	48 9a       	sbi	0x09, 0	; 9
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    3f68:	f8 94       	cli
		ATOMIC_BLOCK(ATOMIC_FORCEON)
		{	
			Temp = RX_SONAR_RAW; 
    3f6a:	60 91 d4 05 	lds	r22, 0x05D4
    3f6e:	70 91 d5 05 	lds	r23, 0x05D5
    3f72:	80 e0       	ldi	r24, 0x00	; 0
    3f74:	90 e0       	ldi	r25, 0x00	; 0
    3f76:	0e 94 34 37 	call	0x6e68	; 0x6e68 <__floatunsisf>
    3f7a:	7b 01       	movw	r14, r22
    3f7c:	8c 01       	movw	r16, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    3f7e:	78 94       	sei
		}
	
		if (Temp < 550) // if SONAR Reading is VALID - not BEYOND maximum range
    3f80:	7f 2d       	mov	r23, r15
    3f82:	91 2f       	mov	r25, r17
    3f84:	20 e0       	ldi	r18, 0x00	; 0
    3f86:	30 e8       	ldi	r19, 0x80	; 128
    3f88:	49 e0       	ldi	r20, 0x09	; 9
    3f8a:	54 e4       	ldi	r21, 0x44	; 68
    3f8c:	0e 94 97 36 	call	0x6d2e	; 0x6d2e <__cmpsf2>
    3f90:	87 ff       	sbrs	r24, 7
    3f92:	b4 c0       	rjmp	.+360    	; 0x40fc <IMU_HeightKeeping+0x240>
		{
			
			if ((bALTHOLD == false))
    3f94:	80 91 35 05 	lds	r24, 0x0535
    3f98:	88 23       	and	r24, r24
    3f9a:	29 f5       	brne	.+74     	; 0x3fe6 <IMU_HeightKeeping+0x12a>
			{   
				if (ThrottleTemp<3)
    3f9c:	80 91 33 05 	lds	r24, 0x0533
    3fa0:	90 91 34 05 	lds	r25, 0x0534
    3fa4:	83 30       	cpi	r24, 0x03	; 3
    3fa6:	91 05       	cpc	r25, r1
    3fa8:	34 f4       	brge	.+12     	; 0x3fb6 <IMU_HeightKeeping+0xfa>
				{ // current altitude is the old one so skip readings till update.
					ThrottleTemp+=1;
    3faa:	01 96       	adiw	r24, 0x01	; 1
    3fac:	90 93 34 05 	sts	0x0534, r25
    3fb0:	80 93 33 05 	sts	0x0533, r24
    3fb4:	c9 c0       	rjmp	.+402    	; 0x4148 <IMU_HeightKeeping+0x28c>
					return Landing ;
				}
				// first time to switch to ALTHOLD
				LastAltitudeHold = Temp; // measure Altitude
    3fb6:	6e 2d       	mov	r22, r14
    3fb8:	7f 2d       	mov	r23, r15
    3fba:	80 2f       	mov	r24, r16
    3fbc:	91 2f       	mov	r25, r17
    3fbe:	0e 94 08 37 	call	0x6e10	; 0x6e10 <__fixunssfsi>
    3fc2:	70 93 df 06 	sts	0x06DF, r23
    3fc6:	60 93 de 06 	sts	0x06DE, r22
				PID_SonarTerms[0].I=0;   // ZERO I
    3fca:	80 e0       	ldi	r24, 0x00	; 0
    3fcc:	90 e0       	ldi	r25, 0x00	; 0
    3fce:	dc 01       	movw	r26, r24
    3fd0:	80 93 b8 07 	sts	0x07B8, r24
    3fd4:	90 93 b9 07 	sts	0x07B9, r25
    3fd8:	a0 93 ba 07 	sts	0x07BA, r26
    3fdc:	b0 93 bb 07 	sts	0x07BB, r27
				bALTHOLD = true;
    3fe0:	81 e0       	ldi	r24, 0x01	; 1
    3fe2:	80 93 35 05 	sts	0x0535, r24
			}
			
			AltDiff = LastAltitudeHold - Temp;
    3fe6:	60 91 de 06 	lds	r22, 0x06DE
    3fea:	70 91 df 06 	lds	r23, 0x06DF
    3fee:	80 e0       	ldi	r24, 0x00	; 0
    3ff0:	90 e0       	ldi	r25, 0x00	; 0
    3ff2:	0e 94 34 37 	call	0x6e68	; 0x6e68 <__floatunsisf>
    3ff6:	2e 2d       	mov	r18, r14
    3ff8:	3f 2d       	mov	r19, r15
    3ffa:	40 2f       	mov	r20, r16
    3ffc:	51 2f       	mov	r21, r17
    3ffe:	0e 94 32 36 	call	0x6c64	; 0x6c64 <__subsf3>
    4002:	f6 2e       	mov	r15, r22
    4004:	07 2f       	mov	r16, r23
    4006:	18 2f       	mov	r17, r24
    4008:	e9 2e       	mov	r14, r25
    400a:	86 2f       	mov	r24, r22
    400c:	90 2f       	mov	r25, r16
    400e:	a1 2f       	mov	r26, r17
    4010:	be 2d       	mov	r27, r14
    4012:	80 93 c2 06 	sts	0x06C2, r24
    4016:	90 93 c3 06 	sts	0x06C3, r25
    401a:	a0 93 c4 06 	sts	0x06C4, r26
    401e:	b0 93 c5 06 	sts	0x06C5, r27
			if ((AltDiff<50) && (AltDiff>-50)) // no sudden change or false read
    4022:	6f 2d       	mov	r22, r15
    4024:	70 2f       	mov	r23, r16
    4026:	81 2f       	mov	r24, r17
    4028:	9e 2d       	mov	r25, r14
    402a:	20 e0       	ldi	r18, 0x00	; 0
    402c:	30 e0       	ldi	r19, 0x00	; 0
    402e:	48 e4       	ldi	r20, 0x48	; 72
    4030:	52 e4       	ldi	r21, 0x42	; 66
    4032:	0e 94 97 36 	call	0x6d2e	; 0x6d2e <__cmpsf2>
    4036:	87 ff       	sbrs	r24, 7
    4038:	5c c0       	rjmp	.+184    	; 0x40f2 <IMU_HeightKeeping+0x236>
    403a:	6f 2d       	mov	r22, r15
    403c:	70 2f       	mov	r23, r16
    403e:	81 2f       	mov	r24, r17
    4040:	9e 2d       	mov	r25, r14
    4042:	20 e0       	ldi	r18, 0x00	; 0
    4044:	30 e0       	ldi	r19, 0x00	; 0
    4046:	48 e4       	ldi	r20, 0x48	; 72
    4048:	52 ec       	ldi	r21, 0xC2	; 194
    404a:	0e 94 e6 37 	call	0x6fcc	; 0x6fcc <__gesf2>
    404e:	18 16       	cp	r1, r24
    4050:	0c f0       	brlt	.+2      	; 0x4054 <IMU_HeightKeeping+0x198>
    4052:	4f c0       	rjmp	.+158    	; 0x40f2 <IMU_HeightKeeping+0x236>
			{
				IgnoreTimeOut=0;
    4054:	10 92 30 05 	sts	0x0530, r1
				ThrottleTemp = PID_Calculate (Config.SonarParams[0], &PID_SonarTerms[0],AltDiff) ;	
    4058:	00 d0       	rcall	.+0      	; 0x405a <IMU_HeightKeeping+0x19e>
    405a:	00 d0       	rcall	.+0      	; 0x405c <IMU_HeightKeeping+0x1a0>
    405c:	8f 2d       	mov	r24, r15
    405e:	90 2f       	mov	r25, r16
    4060:	a1 2f       	mov	r26, r17
    4062:	be 2d       	mov	r27, r14
    4064:	ed b7       	in	r30, 0x3d	; 61
    4066:	fe b7       	in	r31, 0x3e	; 62
    4068:	81 83       	std	Z+1, r24	; 0x01
    406a:	92 83       	std	Z+2, r25	; 0x02
    406c:	a3 83       	std	Z+3, r26	; 0x03
    406e:	b4 83       	std	Z+4, r27	; 0x04
    4070:	c0 90 4f 07 	lds	r12, 0x074F
    4074:	d0 90 50 07 	lds	r13, 0x0750
    4078:	e0 90 51 07 	lds	r14, 0x0751
    407c:	f0 90 52 07 	lds	r15, 0x0752
    4080:	00 91 53 07 	lds	r16, 0x0753
    4084:	10 91 54 07 	lds	r17, 0x0754
    4088:	20 91 55 07 	lds	r18, 0x0755
    408c:	30 91 56 07 	lds	r19, 0x0756
    4090:	40 91 57 07 	lds	r20, 0x0757
    4094:	50 91 58 07 	lds	r21, 0x0758
    4098:	60 91 59 07 	lds	r22, 0x0759
    409c:	70 91 5a 07 	lds	r23, 0x075A
    40a0:	80 91 5b 07 	lds	r24, 0x075B
    40a4:	90 91 5c 07 	lds	r25, 0x075C
    40a8:	b4 eb       	ldi	r27, 0xB4	; 180
    40aa:	ab 2e       	mov	r10, r27
    40ac:	b7 e0       	ldi	r27, 0x07	; 7
    40ae:	bb 2e       	mov	r11, r27
    40b0:	0e 94 2f 1a 	call	0x345e	; 0x345e <PID_Calculate>
    40b4:	0e 94 03 37 	call	0x6e06	; 0x6e06 <__fixsfsi>
    40b8:	7b 01       	movw	r14, r22
    40ba:	8c 01       	movw	r16, r24
    40bc:	70 93 34 05 	sts	0x0534, r23
    40c0:	60 93 33 05 	sts	0x0533, r22
				if (AltDiff==0) 
    40c4:	0f 90       	pop	r0
    40c6:	0f 90       	pop	r0
    40c8:	0f 90       	pop	r0
    40ca:	0f 90       	pop	r0
    40cc:	60 91 c2 06 	lds	r22, 0x06C2
    40d0:	70 91 c3 06 	lds	r23, 0x06C3
    40d4:	80 91 c4 06 	lds	r24, 0x06C4
    40d8:	90 91 c5 06 	lds	r25, 0x06C5
    40dc:	20 e0       	ldi	r18, 0x00	; 0
    40de:	30 e0       	ldi	r19, 0x00	; 0
    40e0:	a9 01       	movw	r20, r18
    40e2:	0e 94 97 36 	call	0x6d2e	; 0x6d2e <__cmpsf2>
    40e6:	88 23       	and	r24, r24
    40e8:	21 f4       	brne	.+8      	; 0x40f2 <IMU_HeightKeeping+0x236>
				{
					ThrottleZERO = ThrottleTemp;
    40ea:	f0 92 32 05 	sts	0x0532, r15
    40ee:	e0 92 31 05 	sts	0x0531, r14
						
				}
			}
										
			Landing += ThrottleTemp;
    40f2:	60 91 33 05 	lds	r22, 0x0533
    40f6:	70 91 34 05 	lds	r23, 0x0534
    40fa:	04 c0       	rjmp	.+8      	; 0x4104 <IMU_HeightKeeping+0x248>
		}
		else
		{
			Landing += ThrottleZERO;
    40fc:	60 91 31 05 	lds	r22, 0x0531
    4100:	70 91 32 05 	lds	r23, 0x0532
    4104:	88 27       	eor	r24, r24
    4106:	77 fd       	sbrc	r23, 7
    4108:	80 95       	com	r24
    410a:	98 2f       	mov	r25, r24
    410c:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    4110:	9b 01       	movw	r18, r22
    4112:	ac 01       	movw	r20, r24
    4114:	60 91 6a 06 	lds	r22, 0x066A
    4118:	70 91 6b 06 	lds	r23, 0x066B
    411c:	80 91 6c 06 	lds	r24, 0x066C
    4120:	90 91 6d 06 	lds	r25, 0x066D
    4124:	0e 94 33 36 	call	0x6c66	; 0x6c66 <__addsf3>
    4128:	60 93 6a 06 	sts	0x066A, r22
    412c:	70 93 6b 06 	sts	0x066B, r23
    4130:	80 93 6c 06 	sts	0x066C, r24
    4134:	90 93 6d 06 	sts	0x066D, r25
		}
		
		RX_SONAR_TRIGGER = LOW;
    4138:	48 98       	cbi	0x09, 0	; 9
    413a:	06 c0       	rjmp	.+12     	; 0x4148 <IMU_HeightKeeping+0x28c>
	}
	else
	{
			ThrottleTemp=0;
    413c:	10 92 34 05 	sts	0x0534, r1
    4140:	10 92 33 05 	sts	0x0533, r1
			bALTHOLD=false;
    4144:	10 92 35 05 	sts	0x0535, r1
	}
	
	
	return Landing;
    4148:	70 91 6a 06 	lds	r23, 0x066A
    414c:	60 91 6b 06 	lds	r22, 0x066B
    4150:	90 91 6c 06 	lds	r25, 0x066C
    4154:	80 91 6d 06 	lds	r24, 0x066D
    4158:	ab 01       	movw	r20, r22
    415a:	9c 01       	movw	r18, r24
    415c:	65 2f       	mov	r22, r21
    415e:	74 2f       	mov	r23, r20
    4160:	83 2f       	mov	r24, r19
    4162:	92 2f       	mov	r25, r18
    4164:	1f 91       	pop	r17
    4166:	0f 91       	pop	r16
    4168:	ff 90       	pop	r15
    416a:	ef 90       	pop	r14
    416c:	df 90       	pop	r13
    416e:	cf 90       	pop	r12
    4170:	bf 90       	pop	r11
    4172:	af 90       	pop	r10
    4174:	08 95       	ret

00004176 <arctan2>:
  //}
  //z *= (180.0f / PI * 10); 
  //return z;
//}

int arctan2(int y, int x) {                                    // http://www.dspguru.com/comp.dsp/tricks/alg/fxdatan2.htm
    4176:	6f 92       	push	r6
    4178:	7f 92       	push	r7
    417a:	8f 92       	push	r8
    417c:	9f 92       	push	r9
    417e:	af 92       	push	r10
    4180:	bf 92       	push	r11
    4182:	cf 92       	push	r12
    4184:	df 92       	push	r13
    4186:	ef 92       	push	r14
    4188:	ff 92       	push	r15
    418a:	0f 93       	push	r16
    418c:	1f 93       	push	r17
    418e:	cf 93       	push	r28
    4190:	df 93       	push	r29
    4192:	ec 01       	movw	r28, r24
    4194:	6b 01       	movw	r12, r22
   int coeff_1 = 128;                                          // angle in Quids (1024 Quids=360) <<<<<<<<<<<<<<
   int coeff_2 = 3*coeff_1;
   float abs_y = abs(y)+1e-10;
    4196:	bc 01       	movw	r22, r24
    4198:	97 ff       	sbrs	r25, 7
    419a:	04 c0       	rjmp	.+8      	; 0x41a4 <arctan2+0x2e>
    419c:	66 27       	eor	r22, r22
    419e:	77 27       	eor	r23, r23
    41a0:	68 1b       	sub	r22, r24
    41a2:	79 0b       	sbc	r23, r25
    41a4:	88 27       	eor	r24, r24
    41a6:	77 fd       	sbrc	r23, 7
    41a8:	80 95       	com	r24
    41aa:	98 2f       	mov	r25, r24
    41ac:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    41b0:	2f ef       	ldi	r18, 0xFF	; 255
    41b2:	36 ee       	ldi	r19, 0xE6	; 230
    41b4:	4b ed       	ldi	r20, 0xDB	; 219
    41b6:	5e e2       	ldi	r21, 0x2E	; 46
    41b8:	0e 94 33 36 	call	0x6c66	; 0x6c66 <__addsf3>
    41bc:	16 2f       	mov	r17, r22
    41be:	07 2f       	mov	r16, r23
    41c0:	f8 2e       	mov	r15, r24
    41c2:	e9 2e       	mov	r14, r25
    41c4:	b6 01       	movw	r22, r12
    41c6:	88 27       	eor	r24, r24
    41c8:	77 fd       	sbrc	r23, 7
    41ca:	80 95       	com	r24
    41cc:	98 2f       	mov	r25, r24
   float r, angle;

   if (x >= 0) {
    41ce:	d7 fc       	sbrc	r13, 7
    41d0:	2b c0       	rjmp	.+86     	; 0x4228 <arctan2+0xb2>
     r = (x - abs_y) / (x + abs_y);
    41d2:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    41d6:	5b 01       	movw	r10, r22
    41d8:	6c 01       	movw	r12, r24
    41da:	d8 01       	movw	r26, r16
    41dc:	f7 01       	movw	r30, r14
    41de:	2b 2f       	mov	r18, r27
    41e0:	3a 2f       	mov	r19, r26
    41e2:	4f 2f       	mov	r20, r31
    41e4:	5e 2f       	mov	r21, r30
    41e6:	0e 94 32 36 	call	0x6c64	; 0x6c64 <__subsf3>
    41ea:	3b 01       	movw	r6, r22
    41ec:	4c 01       	movw	r8, r24
    41ee:	c6 01       	movw	r24, r12
    41f0:	b5 01       	movw	r22, r10
    41f2:	d8 01       	movw	r26, r16
    41f4:	f7 01       	movw	r30, r14
    41f6:	2b 2f       	mov	r18, r27
    41f8:	3a 2f       	mov	r19, r26
    41fa:	4f 2f       	mov	r20, r31
    41fc:	5e 2f       	mov	r21, r30
    41fe:	0e 94 33 36 	call	0x6c66	; 0x6c66 <__addsf3>
    4202:	9b 01       	movw	r18, r22
    4204:	ac 01       	movw	r20, r24
    4206:	c4 01       	movw	r24, r8
    4208:	b3 01       	movw	r22, r6
    420a:	0e 94 9b 36 	call	0x6d36	; 0x6d36 <__divsf3>
     angle = coeff_1 - coeff_1 * r;
    420e:	20 e0       	ldi	r18, 0x00	; 0
    4210:	30 e0       	ldi	r19, 0x00	; 0
    4212:	40 e0       	ldi	r20, 0x00	; 0
    4214:	53 e4       	ldi	r21, 0x43	; 67
    4216:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    421a:	9b 01       	movw	r18, r22
    421c:	ac 01       	movw	r20, r24
    421e:	60 e0       	ldi	r22, 0x00	; 0
    4220:	70 e0       	ldi	r23, 0x00	; 0
    4222:	80 e0       	ldi	r24, 0x00	; 0
    4224:	93 e4       	ldi	r25, 0x43	; 67
    4226:	2a c0       	rjmp	.+84     	; 0x427c <arctan2+0x106>
   }  else {
     r = (x + abs_y) / (abs_y - x);
    4228:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    422c:	5b 01       	movw	r10, r22
    422e:	6c 01       	movw	r12, r24
    4230:	d8 01       	movw	r26, r16
    4232:	f7 01       	movw	r30, r14
    4234:	2b 2f       	mov	r18, r27
    4236:	3a 2f       	mov	r19, r26
    4238:	4f 2f       	mov	r20, r31
    423a:	5e 2f       	mov	r21, r30
    423c:	0e 94 33 36 	call	0x6c66	; 0x6c66 <__addsf3>
    4240:	3b 01       	movw	r6, r22
    4242:	4c 01       	movw	r8, r24
    4244:	a8 01       	movw	r20, r16
    4246:	97 01       	movw	r18, r14
    4248:	65 2f       	mov	r22, r21
    424a:	74 2f       	mov	r23, r20
    424c:	83 2f       	mov	r24, r19
    424e:	92 2f       	mov	r25, r18
    4250:	a6 01       	movw	r20, r12
    4252:	95 01       	movw	r18, r10
    4254:	0e 94 32 36 	call	0x6c64	; 0x6c64 <__subsf3>
    4258:	9b 01       	movw	r18, r22
    425a:	ac 01       	movw	r20, r24
    425c:	c4 01       	movw	r24, r8
    425e:	b3 01       	movw	r22, r6
    4260:	0e 94 9b 36 	call	0x6d36	; 0x6d36 <__divsf3>
     angle = coeff_2 - coeff_1 * r;
    4264:	20 e0       	ldi	r18, 0x00	; 0
    4266:	30 e0       	ldi	r19, 0x00	; 0
    4268:	40 e0       	ldi	r20, 0x00	; 0
    426a:	53 e4       	ldi	r21, 0x43	; 67
    426c:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    4270:	9b 01       	movw	r18, r22
    4272:	ac 01       	movw	r20, r24
    4274:	60 e0       	ldi	r22, 0x00	; 0
    4276:	70 e0       	ldi	r23, 0x00	; 0
    4278:	80 ec       	ldi	r24, 0xC0	; 192
    427a:	93 e4       	ldi	r25, 0x43	; 67
    427c:	0e 94 32 36 	call	0x6c64	; 0x6c64 <__subsf3>
   }
   if (y < 0)      return (int)(-angle);
    4280:	d7 fd       	sbrc	r29, 7
    4282:	90 58       	subi	r25, 0x80	; 128
   else            return (int)(angle);
    4284:	0e 94 03 37 	call	0x6e06	; 0x6e06 <__fixsfsi>
}
    4288:	cb 01       	movw	r24, r22
    428a:	df 91       	pop	r29
    428c:	cf 91       	pop	r28
    428e:	1f 91       	pop	r17
    4290:	0f 91       	pop	r16
    4292:	ff 90       	pop	r15
    4294:	ef 90       	pop	r14
    4296:	df 90       	pop	r13
    4298:	cf 90       	pop	r12
    429a:	bf 90       	pop	r11
    429c:	af 90       	pop	r10
    429e:	9f 90       	pop	r9
    42a0:	8f 90       	pop	r8
    42a2:	7f 90       	pop	r7
    42a4:	6f 90       	pop	r6
    42a6:	08 95       	ret

000042a8 <Limiterf>:


float Limiterf (float Value, float Limit)
{
    42a8:	af 92       	push	r10
    42aa:	bf 92       	push	r11
    42ac:	cf 92       	push	r12
    42ae:	df 92       	push	r13
    42b0:	ef 92       	push	r14
    42b2:	ff 92       	push	r15
    42b4:	0f 93       	push	r16
    42b6:	1f 93       	push	r17
    42b8:	d6 2e       	mov	r13, r22
    42ba:	c7 2e       	mov	r12, r23
    42bc:	b8 2e       	mov	r11, r24
    42be:	a9 2e       	mov	r10, r25
    42c0:	79 01       	movw	r14, r18
    42c2:	8a 01       	movw	r16, r20
	if (Value > Limit) return   Limit;
    42c4:	a6 01       	movw	r20, r12
    42c6:	95 01       	movw	r18, r10
    42c8:	65 2f       	mov	r22, r21
    42ca:	74 2f       	mov	r23, r20
    42cc:	83 2f       	mov	r24, r19
    42ce:	92 2f       	mov	r25, r18
    42d0:	a8 01       	movw	r20, r16
    42d2:	97 01       	movw	r18, r14
    42d4:	0e 94 e6 37 	call	0x6fcc	; 0x6fcc <__gesf2>
    42d8:	18 16       	cp	r1, r24
    42da:	b4 f0       	brlt	.+44     	; 0x4308 <Limiterf+0x60>
	if (Value < -Limit) return -Limit;
    42dc:	17 fb       	bst	r17, 7
    42de:	10 95       	com	r17
    42e0:	17 f9       	bld	r17, 7
    42e2:	10 95       	com	r17
    42e4:	a6 01       	movw	r20, r12
    42e6:	95 01       	movw	r18, r10
    42e8:	65 2f       	mov	r22, r21
    42ea:	74 2f       	mov	r23, r20
    42ec:	83 2f       	mov	r24, r19
    42ee:	92 2f       	mov	r25, r18
    42f0:	a8 01       	movw	r20, r16
    42f2:	97 01       	movw	r18, r14
    42f4:	0e 94 97 36 	call	0x6d2e	; 0x6d2e <__cmpsf2>
    42f8:	87 fd       	sbrc	r24, 7
    42fa:	06 c0       	rjmp	.+12     	; 0x4308 <Limiterf+0x60>
	
	return Value;
    42fc:	96 01       	movw	r18, r12
    42fe:	c5 01       	movw	r24, r10
    4300:	e3 2e       	mov	r14, r19
    4302:	f2 2e       	mov	r15, r18
    4304:	09 2f       	mov	r16, r25
    4306:	18 2f       	mov	r17, r24
}
    4308:	6e 2d       	mov	r22, r14
    430a:	7f 2d       	mov	r23, r15
    430c:	80 2f       	mov	r24, r16
    430e:	91 2f       	mov	r25, r17
    4310:	1f 91       	pop	r17
    4312:	0f 91       	pop	r16
    4314:	ff 90       	pop	r15
    4316:	ef 90       	pop	r14
    4318:	df 90       	pop	r13
    431a:	cf 90       	pop	r12
    431c:	bf 90       	pop	r11
    431e:	af 90       	pop	r10
    4320:	08 95       	ret

00004322 <Limiter>:

int16_t Limiter (int16_t Value, int16_t Limit)
{
	if (Value > Limit) return   Limit;
    4322:	68 17       	cp	r22, r24
    4324:	79 07       	cpc	r23, r25
    4326:	3c f0       	brlt	.+14     	; 0x4336 <Limiter+0x14>
	if (Value < -Limit) return -Limit;
    4328:	70 95       	com	r23
    432a:	61 95       	neg	r22
    432c:	7f 4f       	sbci	r23, 0xFF	; 255
    432e:	68 17       	cp	r22, r24
    4330:	79 07       	cpc	r23, r25
    4332:	0c f4       	brge	.+2      	; 0x4336 <Limiter+0x14>
    4334:	bc 01       	movw	r22, r24
	
	return Value;
}
    4336:	cb 01       	movw	r24, r22
    4338:	08 95       	ret

0000433a <ScaleSensor>:
			 return (int16_t) y;
		}
	   }	
		*/
	return 0;	
}
    433a:	80 e0       	ldi	r24, 0x00	; 0
    433c:	90 e0       	ldi	r25, 0x00	; 0
    433e:	08 95       	ret

00004340 <_atan2>:



int16_t _atan2(int32_t y, int32_t x)
{
    4340:	2f 92       	push	r2
    4342:	3f 92       	push	r3
    4344:	4f 92       	push	r4
    4346:	5f 92       	push	r5
    4348:	6f 92       	push	r6
    434a:	7f 92       	push	r7
    434c:	8f 92       	push	r8
    434e:	9f 92       	push	r9
    4350:	af 92       	push	r10
    4352:	bf 92       	push	r11
    4354:	cf 92       	push	r12
    4356:	df 92       	push	r13
    4358:	ef 92       	push	r14
    435a:	ff 92       	push	r15
    435c:	0f 93       	push	r16
    435e:	1f 93       	push	r17
    4360:	5b 01       	movw	r10, r22
    4362:	6c 01       	movw	r12, r24
    4364:	39 01       	movw	r6, r18
    4366:	4a 01       	movw	r8, r20
	float z = (float)y / x;
    4368:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    436c:	7b 01       	movw	r14, r22
    436e:	8c 01       	movw	r16, r24
    4370:	c4 01       	movw	r24, r8
    4372:	b3 01       	movw	r22, r6
    4374:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    4378:	9b 01       	movw	r18, r22
    437a:	ac 01       	movw	r20, r24
    437c:	c8 01       	movw	r24, r16
    437e:	b7 01       	movw	r22, r14
    4380:	0e 94 9b 36 	call	0x6d36	; 0x6d36 <__divsf3>
    4384:	f6 2e       	mov	r15, r22
    4386:	07 2f       	mov	r16, r23
    4388:	18 2f       	mov	r17, r24
    438a:	e9 2e       	mov	r14, r25
	int16_t a;
	if ( abs(y) < abs(x) ){
    438c:	95 01       	movw	r18, r10
    438e:	b7 fe       	sbrs	r11, 7
    4390:	03 c0       	rjmp	.+6      	; 0x4398 <_atan2+0x58>
    4392:	30 95       	com	r19
    4394:	21 95       	neg	r18
    4396:	3f 4f       	sbci	r19, 0xFF	; 255
    4398:	c3 01       	movw	r24, r6
    439a:	77 fe       	sbrs	r7, 7
    439c:	03 c0       	rjmp	.+6      	; 0x43a4 <_atan2+0x64>
    439e:	90 95       	com	r25
    43a0:	81 95       	neg	r24
    43a2:	9f 4f       	sbci	r25, 0xFF	; 255
    43a4:	28 17       	cp	r18, r24
    43a6:	39 07       	cpc	r19, r25
    43a8:	8c f5       	brge	.+98     	; 0x440c <_atan2+0xcc>
		a = 573 * z / (1.0f + 0.28f * z * z);
    43aa:	6f 2d       	mov	r22, r15
    43ac:	70 2f       	mov	r23, r16
    43ae:	81 2f       	mov	r24, r17
    43b0:	9e 2d       	mov	r25, r14
    43b2:	20 e0       	ldi	r18, 0x00	; 0
    43b4:	30 e4       	ldi	r19, 0x40	; 64
    43b6:	4f e0       	ldi	r20, 0x0F	; 15
    43b8:	54 e4       	ldi	r21, 0x44	; 68
    43ba:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    43be:	1b 01       	movw	r2, r22
    43c0:	2c 01       	movw	r4, r24
    43c2:	6f 2d       	mov	r22, r15
    43c4:	70 2f       	mov	r23, r16
    43c6:	81 2f       	mov	r24, r17
    43c8:	9e 2d       	mov	r25, r14
    43ca:	29 e2       	ldi	r18, 0x29	; 41
    43cc:	3c e5       	ldi	r19, 0x5C	; 92
    43ce:	4f e8       	ldi	r20, 0x8F	; 143
    43d0:	5e e3       	ldi	r21, 0x3E	; 62
    43d2:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    43d6:	2f 2d       	mov	r18, r15
    43d8:	30 2f       	mov	r19, r16
    43da:	41 2f       	mov	r20, r17
    43dc:	5e 2d       	mov	r21, r14
    43de:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    43e2:	20 e0       	ldi	r18, 0x00	; 0
    43e4:	30 e0       	ldi	r19, 0x00	; 0
    43e6:	40 e8       	ldi	r20, 0x80	; 128
    43e8:	5f e3       	ldi	r21, 0x3F	; 63
    43ea:	0e 94 33 36 	call	0x6c66	; 0x6c66 <__addsf3>
    43ee:	9b 01       	movw	r18, r22
    43f0:	ac 01       	movw	r20, r24
    43f2:	c2 01       	movw	r24, r4
    43f4:	b1 01       	movw	r22, r2
    43f6:	0e 94 9b 36 	call	0x6d36	; 0x6d36 <__divsf3>
    43fa:	0e 94 03 37 	call	0x6e06	; 0x6e06 <__fixsfsi>
		if (x<0) {
    43fe:	97 fe       	sbrs	r9, 7
    4400:	35 c0       	rjmp	.+106    	; 0x446c <_atan2+0x12c>
			if (y<0) a -= 1800;
    4402:	d7 fc       	sbrc	r13, 7
    4404:	31 c0       	rjmp	.+98     	; 0x4468 <_atan2+0x128>
			else a += 1800;
    4406:	68 5f       	subi	r22, 0xF8	; 248
    4408:	78 4f       	sbci	r23, 0xF8	; 248
    440a:	30 c0       	rjmp	.+96     	; 0x446c <_atan2+0x12c>
		}
	} else {
		a = 900 - 573 * z / (z * z + 0.28f);
    440c:	6f 2d       	mov	r22, r15
    440e:	70 2f       	mov	r23, r16
    4410:	81 2f       	mov	r24, r17
    4412:	9e 2d       	mov	r25, r14
    4414:	20 e0       	ldi	r18, 0x00	; 0
    4416:	30 e4       	ldi	r19, 0x40	; 64
    4418:	4f e0       	ldi	r20, 0x0F	; 15
    441a:	54 e4       	ldi	r21, 0x44	; 68
    441c:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    4420:	3b 01       	movw	r6, r22
    4422:	4c 01       	movw	r8, r24
    4424:	6f 2d       	mov	r22, r15
    4426:	70 2f       	mov	r23, r16
    4428:	81 2f       	mov	r24, r17
    442a:	9e 2d       	mov	r25, r14
    442c:	2f 2d       	mov	r18, r15
    442e:	30 2f       	mov	r19, r16
    4430:	41 2f       	mov	r20, r17
    4432:	5e 2d       	mov	r21, r14
    4434:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    4438:	29 e2       	ldi	r18, 0x29	; 41
    443a:	3c e5       	ldi	r19, 0x5C	; 92
    443c:	4f e8       	ldi	r20, 0x8F	; 143
    443e:	5e e3       	ldi	r21, 0x3E	; 62
    4440:	0e 94 33 36 	call	0x6c66	; 0x6c66 <__addsf3>
    4444:	9b 01       	movw	r18, r22
    4446:	ac 01       	movw	r20, r24
    4448:	c4 01       	movw	r24, r8
    444a:	b3 01       	movw	r22, r6
    444c:	0e 94 9b 36 	call	0x6d36	; 0x6d36 <__divsf3>
    4450:	9b 01       	movw	r18, r22
    4452:	ac 01       	movw	r20, r24
    4454:	60 e0       	ldi	r22, 0x00	; 0
    4456:	70 e0       	ldi	r23, 0x00	; 0
    4458:	81 e6       	ldi	r24, 0x61	; 97
    445a:	94 e4       	ldi	r25, 0x44	; 68
    445c:	0e 94 32 36 	call	0x6c64	; 0x6c64 <__subsf3>
    4460:	0e 94 03 37 	call	0x6e06	; 0x6e06 <__fixsfsi>
		if (y<0) a -= 1800;
    4464:	d7 fe       	sbrs	r13, 7
    4466:	02 c0       	rjmp	.+4      	; 0x446c <_atan2+0x12c>
    4468:	68 50       	subi	r22, 0x08	; 8
    446a:	77 40       	sbci	r23, 0x07	; 7
	}
	return a;
}
    446c:	cb 01       	movw	r24, r22
    446e:	1f 91       	pop	r17
    4470:	0f 91       	pop	r16
    4472:	ff 90       	pop	r15
    4474:	ef 90       	pop	r14
    4476:	df 90       	pop	r13
    4478:	cf 90       	pop	r12
    447a:	bf 90       	pop	r11
    447c:	af 90       	pop	r10
    447e:	9f 90       	pop	r9
    4480:	8f 90       	pop	r8
    4482:	7f 90       	pop	r7
    4484:	6f 90       	pop	r6
    4486:	5f 90       	pop	r5
    4488:	4f 90       	pop	r4
    448a:	3f 90       	pop	r3
    448c:	2f 90       	pop	r2
    448e:	08 95       	ret

00004490 <InvSqrt>:

float InvSqrt (float x)
{
    4490:	6f 92       	push	r6
    4492:	7f 92       	push	r7
    4494:	8f 92       	push	r8
    4496:	9f 92       	push	r9
    4498:	af 92       	push	r10
    449a:	bf 92       	push	r11
    449c:	cf 92       	push	r12
    449e:	df 92       	push	r13
    44a0:	ef 92       	push	r14
    44a2:	ff 92       	push	r15
    44a4:	0f 93       	push	r16
    44a6:	1f 93       	push	r17
    44a8:	5b 01       	movw	r10, r22
    44aa:	6c 01       	movw	r12, r24
	union{
		int32_t i;
		float   f;
	} conv;
	conv.f = x;
	conv.i = 0x5f3759df - (conv.i >> 1);
    44ac:	dc 01       	movw	r26, r24
    44ae:	cb 01       	movw	r24, r22
    44b0:	b5 95       	asr	r27
    44b2:	a7 95       	ror	r26
    44b4:	97 95       	ror	r25
    44b6:	87 95       	ror	r24
    44b8:	2f ed       	ldi	r18, 0xDF	; 223
    44ba:	e2 2e       	mov	r14, r18
    44bc:	29 e5       	ldi	r18, 0x59	; 89
    44be:	f2 2e       	mov	r15, r18
    44c0:	27 e3       	ldi	r18, 0x37	; 55
    44c2:	02 2f       	mov	r16, r18
    44c4:	2f e5       	ldi	r18, 0x5F	; 95
    44c6:	12 2f       	mov	r17, r18
    44c8:	e8 1a       	sub	r14, r24
    44ca:	f9 0a       	sbc	r15, r25
    44cc:	0a 0b       	sbc	r16, r26
    44ce:	1b 0b       	sbc	r17, r27
	return 0.5f * conv.f * (3.0f - x * conv.f * conv.f);
    44d0:	c8 01       	movw	r24, r16
    44d2:	b7 01       	movw	r22, r14
    44d4:	20 e0       	ldi	r18, 0x00	; 0
    44d6:	30 e0       	ldi	r19, 0x00	; 0
    44d8:	40 e0       	ldi	r20, 0x00	; 0
    44da:	5f e3       	ldi	r21, 0x3F	; 63
    44dc:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    44e0:	3b 01       	movw	r6, r22
    44e2:	4c 01       	movw	r8, r24
    44e4:	c6 01       	movw	r24, r12
    44e6:	b5 01       	movw	r22, r10
    44e8:	a8 01       	movw	r20, r16
    44ea:	97 01       	movw	r18, r14
    44ec:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    44f0:	a8 01       	movw	r20, r16
    44f2:	97 01       	movw	r18, r14
    44f4:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
    44f8:	9b 01       	movw	r18, r22
    44fa:	ac 01       	movw	r20, r24
    44fc:	60 e0       	ldi	r22, 0x00	; 0
    44fe:	70 e0       	ldi	r23, 0x00	; 0
    4500:	80 e4       	ldi	r24, 0x40	; 64
    4502:	90 e4       	ldi	r25, 0x40	; 64
    4504:	0e 94 32 36 	call	0x6c64	; 0x6c64 <__subsf3>
    4508:	9b 01       	movw	r18, r22
    450a:	ac 01       	movw	r20, r24
    450c:	c4 01       	movw	r24, r8
    450e:	b3 01       	movw	r22, r6
    4510:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <__mulsf3>
}
    4514:	1f 91       	pop	r17
    4516:	0f 91       	pop	r16
    4518:	ff 90       	pop	r15
    451a:	ef 90       	pop	r14
    451c:	df 90       	pop	r13
    451e:	cf 90       	pop	r12
    4520:	bf 90       	pop	r11
    4522:	af 90       	pop	r10
    4524:	9f 90       	pop	r9
    4526:	8f 90       	pop	r8
    4528:	7f 90       	pop	r7
    452a:	6f 90       	pop	r6
    452c:	08 95       	ret

0000452e <Motor_GenerateOutputSignal>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    452e:	f8 94       	cli
	
	// Make sure we have spent enough time between pulses
	// Also, handle the odd case where the TCNT2_X rolls over and TCNT2_X < ElapsedTCNT2
	ATOMIC_BLOCK(ATOMIC_FORCEON)
   {
      CurrentTCNT2 = TCNT2_X;
    4530:	80 91 bf 05 	lds	r24, 0x05BF
    4534:	90 91 c0 05 	lds	r25, 0x05C0
    4538:	90 93 16 08 	sts	0x0816, r25
    453c:	80 93 15 08 	sts	0x0815, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    4540:	78 94       	sei
   }

   if (CurrentTCNT2 >= MotorStartTCNT) 
    4542:	20 91 15 08 	lds	r18, 0x0815
    4546:	30 91 16 08 	lds	r19, 0x0816
    454a:	80 91 08 08 	lds	r24, 0x0808
    454e:	90 91 09 08 	lds	r25, 0x0809
    4552:	28 17       	cp	r18, r24
    4554:	39 07       	cpc	r19, r25
    4556:	38 f0       	brcs	.+14     	; 0x4566 <Motor_GenerateOutputSignal+0x38>
   {
		ElapsedTCNT2 = CurrentTCNT2 - MotorStartTCNT;
    4558:	28 1b       	sub	r18, r24
    455a:	39 0b       	sbc	r19, r25
    455c:	30 93 03 08 	sts	0x0803, r19
    4560:	20 93 02 08 	sts	0x0802, r18
    4564:	08 c0       	rjmp	.+16     	; 0x4576 <Motor_GenerateOutputSignal+0x48>
   }
   else 
   {
		ElapsedTCNT2 = (0xffff - MotorStartTCNT) + CurrentTCNT2;
    4566:	80 95       	com	r24
    4568:	90 95       	com	r25
    456a:	82 0f       	add	r24, r18
    456c:	93 1f       	adc	r25, r19
    456e:	90 93 03 08 	sts	0x0803, r25
    4572:	80 93 02 08 	sts	0x0802, r24
	
	// If period less than 1/ESC_RATE, pad it out.
	// check Timer.c for timing table
	
	//interval in us
	PMW_Pulse_Interval = (PWM_LOW_PULSE_INTERVAL - ( ElapsedTCNT2 * 409)); // 409 = OV time of TCNT2
    4576:	40 91 02 08 	lds	r20, 0x0802
    457a:	50 91 03 08 	lds	r21, 0x0803
    457e:	89 e9       	ldi	r24, 0x99	; 153
    4580:	91 e0       	ldi	r25, 0x01	; 1
    4582:	48 9f       	mul	r20, r24
    4584:	90 01       	movw	r18, r0
    4586:	49 9f       	mul	r20, r25
    4588:	30 0d       	add	r19, r0
    458a:	58 9f       	mul	r21, r24
    458c:	30 0d       	add	r19, r0
    458e:	11 24       	eor	r1, r1
    4590:	80 ea       	ldi	r24, 0xA0	; 160
    4592:	9f e0       	ldi	r25, 0x0F	; 15
    4594:	82 1b       	sub	r24, r18
    4596:	93 0b       	sbc	r25, r19
    4598:	0d c0       	rjmp	.+26     	; 0x45b4 <Motor_GenerateOutputSignal+0x86>
	while (PMW_Pulse_Interval > 0)
	{
		//LED_Orange=~LED_Orange;
			TCNT2 =0;
    459a:	10 92 b2 00 	sts	0x00B2, r1
			if (PMW_Pulse_Interval>100)
    459e:	85 36       	cpi	r24, 0x65	; 101
    45a0:	91 05       	cpc	r25, r1
    45a2:	3c f0       	brlt	.+14     	; 0x45b2 <Motor_GenerateOutputSignal+0x84>
			{   // make big jumps if PWM_Low_Pulse_Interval is high
				// [more accurate to decrease the % between the while loop and the PWM_Low_Pulse_Interval -=80 execution time.]
				while (TCNT2 < 40); //=8us 1.50
    45a4:	20 91 b2 00 	lds	r18, 0x00B2
    45a8:	28 32       	cpi	r18, 0x28	; 40
    45aa:	e0 f3       	brcs	.-8      	; 0x45a4 <Motor_GenerateOutputSignal+0x76>
				PMW_Pulse_Interval -=80;	
    45ac:	80 55       	subi	r24, 0x50	; 80
    45ae:	90 40       	sbci	r25, 0x00	; 0
    45b0:	01 c0       	rjmp	.+2      	; 0x45b4 <Motor_GenerateOutputSignal+0x86>
			}
			else
			{   //
				///////////while (TCNT2 < 5); //=8us
				PMW_Pulse_Interval -=1;
    45b2:	01 97       	sbiw	r24, 0x01	; 1
    45b4:	90 93 0e 08 	sts	0x080E, r25
    45b8:	80 93 0d 08 	sts	0x080D, r24
	// If period less than 1/ESC_RATE, pad it out.
	// check Timer.c for timing table
	
	//interval in us
	PMW_Pulse_Interval = (PWM_LOW_PULSE_INTERVAL - ( ElapsedTCNT2 * 409)); // 409 = OV time of TCNT2
	while (PMW_Pulse_Interval > 0)
    45bc:	80 91 0d 08 	lds	r24, 0x080D
    45c0:	90 91 0e 08 	lds	r25, 0x080E
    45c4:	18 16       	cp	r1, r24
    45c6:	19 06       	cpc	r1, r25
    45c8:	44 f3       	brlt	.-48     	; 0x459a <Motor_GenerateOutputSignal+0x6c>
				PMW_Pulse_Interval -=1;
			}
			
	}
	
	times+=1;
    45ca:	80 91 36 05 	lds	r24, 0x0536
    45ce:	8f 5f       	subi	r24, 0xFF	; 255
    45d0:	80 93 36 05 	sts	0x0536, r24
	
	// Set motor limits (0 -> MOTORS_HIGH_VALUE)
	if ( MotorOut[0] < 0 ) m1 = 0;
    45d4:	80 91 9a 05 	lds	r24, 0x059A
    45d8:	90 91 9b 05 	lds	r25, 0x059B
    45dc:	97 ff       	sbrs	r25, 7
    45de:	05 c0       	rjmp	.+10     	; 0x45ea <Motor_GenerateOutputSignal+0xbc>
    45e0:	10 92 10 08 	sts	0x0810, r1
    45e4:	10 92 0f 08 	sts	0x080F, r1
    45e8:	0a c0       	rjmp	.+20     	; 0x45fe <Motor_GenerateOutputSignal+0xd0>
	else if ( MotorOut[0] > MOTORS_HIGH_VALUE ) m1 = MOTORS_HIGH_VALUE;
    45ea:	24 e0       	ldi	r18, 0x04	; 4
    45ec:	8f 37       	cpi	r24, 0x7F	; 127
    45ee:	92 07       	cpc	r25, r18
    45f0:	14 f0       	brlt	.+4      	; 0x45f6 <Motor_GenerateOutputSignal+0xc8>
    45f2:	8e e7       	ldi	r24, 0x7E	; 126
    45f4:	94 e0       	ldi	r25, 0x04	; 4
	else m1 = MotorOut[0];
    45f6:	90 93 10 08 	sts	0x0810, r25
    45fa:	80 93 0f 08 	sts	0x080F, r24
	
	if ( MotorOut[1] < 0 ) m2 = 0;
    45fe:	80 91 9c 05 	lds	r24, 0x059C
    4602:	90 91 9d 05 	lds	r25, 0x059D
    4606:	97 ff       	sbrs	r25, 7
    4608:	05 c0       	rjmp	.+10     	; 0x4614 <Motor_GenerateOutputSignal+0xe6>
    460a:	10 92 07 08 	sts	0x0807, r1
    460e:	10 92 06 08 	sts	0x0806, r1
    4612:	0a c0       	rjmp	.+20     	; 0x4628 <Motor_GenerateOutputSignal+0xfa>
	else if ( MotorOut[1] > MOTORS_HIGH_VALUE ) m2 = MOTORS_HIGH_VALUE;
    4614:	24 e0       	ldi	r18, 0x04	; 4
    4616:	8f 37       	cpi	r24, 0x7F	; 127
    4618:	92 07       	cpc	r25, r18
    461a:	14 f0       	brlt	.+4      	; 0x4620 <Motor_GenerateOutputSignal+0xf2>
    461c:	8e e7       	ldi	r24, 0x7E	; 126
    461e:	94 e0       	ldi	r25, 0x04	; 4
	else m2 = MotorOut[1];
    4620:	90 93 07 08 	sts	0x0807, r25
    4624:	80 93 06 08 	sts	0x0806, r24

	if ( MotorOut[2] < 0 ) m3 = 0;
    4628:	80 91 9e 05 	lds	r24, 0x059E
    462c:	90 91 9f 05 	lds	r25, 0x059F
    4630:	97 ff       	sbrs	r25, 7
    4632:	05 c0       	rjmp	.+10     	; 0x463e <Motor_GenerateOutputSignal+0x110>
    4634:	10 92 14 08 	sts	0x0814, r1
    4638:	10 92 13 08 	sts	0x0813, r1
    463c:	0a c0       	rjmp	.+20     	; 0x4652 <Motor_GenerateOutputSignal+0x124>
	else if ( MotorOut[2] > MOTORS_HIGH_VALUE ) m3 = MOTORS_HIGH_VALUE;
    463e:	24 e0       	ldi	r18, 0x04	; 4
    4640:	8f 37       	cpi	r24, 0x7F	; 127
    4642:	92 07       	cpc	r25, r18
    4644:	14 f0       	brlt	.+4      	; 0x464a <Motor_GenerateOutputSignal+0x11c>
    4646:	8e e7       	ldi	r24, 0x7E	; 126
    4648:	94 e0       	ldi	r25, 0x04	; 4
	else m3 = MotorOut[2];
    464a:	90 93 14 08 	sts	0x0814, r25
    464e:	80 93 13 08 	sts	0x0813, r24

	if ( MotorOut[3] < 0 ) m4 = 0;
    4652:	80 91 a0 05 	lds	r24, 0x05A0
    4656:	90 91 a1 05 	lds	r25, 0x05A1
    465a:	97 ff       	sbrs	r25, 7
    465c:	05 c0       	rjmp	.+10     	; 0x4668 <Motor_GenerateOutputSignal+0x13a>
    465e:	10 92 05 08 	sts	0x0805, r1
    4662:	10 92 04 08 	sts	0x0804, r1
    4666:	0a c0       	rjmp	.+20     	; 0x467c <Motor_GenerateOutputSignal+0x14e>
	else if ( MotorOut[3] > MOTORS_HIGH_VALUE ) m4 = MOTORS_HIGH_VALUE;
    4668:	24 e0       	ldi	r18, 0x04	; 4
    466a:	8f 37       	cpi	r24, 0x7F	; 127
    466c:	92 07       	cpc	r25, r18
    466e:	14 f0       	brlt	.+4      	; 0x4674 <Motor_GenerateOutputSignal+0x146>
    4670:	8e e7       	ldi	r24, 0x7E	; 126
    4672:	94 e0       	ldi	r25, 0x04	; 4
	else m4 = MotorOut[3];
    4674:	90 93 05 08 	sts	0x0805, r25
    4678:	80 93 04 08 	sts	0x0804, r24
	
	
	// Minimum pulse we want to make is 1ms, max is 2ms
	// So to start, let's make the 1ms base pulse.
	// First, we switch on the motor outputs
	M1 = 1;
    467c:	46 9a       	sbi	0x08, 6	; 8
	M2 = 1;
    467e:	44 9a       	sbi	0x08, 4	; 8
	M3 = 1;
    4680:	42 9a       	sbi	0x08, 2	; 8
	if (Config.FrameType== FRAMETYPE_QUADCOPTER) 
    4682:	80 91 f4 06 	lds	r24, 0x06F4
    4686:	81 30       	cpi	r24, 0x01	; 1
    4688:	11 f4       	brne	.+4      	; 0x468e <Motor_GenerateOutputSignal+0x160>
	{
		M4 =1;
    468a:	43 9a       	sbi	0x08, 3	; 8
    468c:	09 c0       	rjmp	.+18     	; 0x46a0 <Motor_GenerateOutputSignal+0x172>
	}
	else if (Config.FrameType== FRAMETYPE_TRICOPTER)
    468e:	82 30       	cpi	r24, 0x02	; 2
    4690:	39 f4       	brne	.+14     	; 0x46a0 <Motor_GenerateOutputSignal+0x172>
	{
		if (times==5)
    4692:	80 91 36 05 	lds	r24, 0x0536
    4696:	85 30       	cpi	r24, 0x05	; 5
    4698:	19 f4       	brne	.+6      	; 0x46a0 <Motor_GenerateOutputSignal+0x172>
		{
			M4 = 1;		// time to update servo
    469a:	43 9a       	sbi	0x08, 3	; 8
			//UpdateServo = FALSE;
			times=0;	// reset time divider
    469c:	10 92 36 05 	sts	0x0536, r1
		} // else keep it zero.			
	} 
	
	
	// Minimum pulse width we want to make is 1ms, max is 2ms
	PMW_Pulse_Interval = BASE_PULSE + Config.ThrottleMin;
    46a0:	80 91 f8 06 	lds	r24, 0x06F8
    46a4:	90 e0       	ldi	r25, 0x00	; 0
    46a6:	80 5e       	subi	r24, 0xE0	; 224
    46a8:	9c 4f       	sbci	r25, 0xFC	; 252
    46aa:	0d c0       	rjmp	.+26     	; 0x46c6 <Motor_GenerateOutputSignal+0x198>
	while (PMW_Pulse_Interval > 0)
	{
			TCNT2 =0;
    46ac:	10 92 b2 00 	sts	0x00B2, r1
			if (PMW_Pulse_Interval>100)
    46b0:	85 36       	cpi	r24, 0x65	; 101
    46b2:	91 05       	cpc	r25, r1
    46b4:	3c f0       	brlt	.+14     	; 0x46c4 <Motor_GenerateOutputSignal+0x196>
			{   // make big jumps if PWM_Low_Pulse_Interval is high
				// [more accurate to decrease the % between the while loop and the PWM_Low_Pulse_Interval -=80 execution time.]
				while (TCNT2 < 45); //=8us //1. 50
    46b6:	20 91 b2 00 	lds	r18, 0x00B2
    46ba:	2d 32       	cpi	r18, 0x2D	; 45
    46bc:	e0 f3       	brcs	.-8      	; 0x46b6 <Motor_GenerateOutputSignal+0x188>
				PMW_Pulse_Interval -=80;	
    46be:	80 55       	subi	r24, 0x50	; 80
    46c0:	90 40       	sbci	r25, 0x00	; 0
    46c2:	01 c0       	rjmp	.+2      	; 0x46c6 <Motor_GenerateOutputSignal+0x198>
			}
			else
			{   //
				//////while (TCNT2 < 5); //=8us
				PMW_Pulse_Interval -=1;
    46c4:	01 97       	sbiw	r24, 0x01	; 1
    46c6:	90 93 0e 08 	sts	0x080E, r25
    46ca:	80 93 0d 08 	sts	0x080D, r24
	} 
	
	
	// Minimum pulse width we want to make is 1ms, max is 2ms
	PMW_Pulse_Interval = BASE_PULSE + Config.ThrottleMin;
	while (PMW_Pulse_Interval > 0)
    46ce:	80 91 0d 08 	lds	r24, 0x080D
    46d2:	90 91 0e 08 	lds	r25, 0x080E
    46d6:	18 16       	cp	r1, r24
    46d8:	19 06       	cpc	r1, r25
    46da:	44 f3       	brlt	.-48     	; 0x46ac <Motor_GenerateOutputSignal+0x17e>
				PMW_Pulse_Interval -=1;
			}
	}
		
	
	for (i=0;i<MOTORS_HIGH_VALUE+4;i+=4)			// 1000 gives a max of 2200us 
    46dc:	10 92 0c 08 	sts	0x080C, r1
    46e0:	10 92 0b 08 	sts	0x080B, r1
    46e4:	39 c0       	rjmp	.+114    	; 0x4758 <Motor_GenerateOutputSignal+0x22a>
		/*
		MOTORS_HIGH_VALUE+4
		in order to guarantee that all Ms are zeros when getting out of this loop.
		*/
		
		if (i>=m1) M1 = 0;
    46e6:	20 91 0b 08 	lds	r18, 0x080B
    46ea:	30 91 0c 08 	lds	r19, 0x080C
    46ee:	80 91 0f 08 	lds	r24, 0x080F
    46f2:	90 91 10 08 	lds	r25, 0x0810
    46f6:	28 17       	cp	r18, r24
    46f8:	39 07       	cpc	r19, r25
    46fa:	08 f0       	brcs	.+2      	; 0x46fe <Motor_GenerateOutputSignal+0x1d0>
    46fc:	46 98       	cbi	0x08, 6	; 8
		if (i>=m2) M2 = 0;
    46fe:	20 91 0b 08 	lds	r18, 0x080B
    4702:	30 91 0c 08 	lds	r19, 0x080C
    4706:	80 91 06 08 	lds	r24, 0x0806
    470a:	90 91 07 08 	lds	r25, 0x0807
    470e:	28 17       	cp	r18, r24
    4710:	39 07       	cpc	r19, r25
    4712:	08 f0       	brcs	.+2      	; 0x4716 <Motor_GenerateOutputSignal+0x1e8>
    4714:	44 98       	cbi	0x08, 4	; 8
		if (i>=m3) M3 = 0;
    4716:	20 91 0b 08 	lds	r18, 0x080B
    471a:	30 91 0c 08 	lds	r19, 0x080C
    471e:	80 91 13 08 	lds	r24, 0x0813
    4722:	90 91 14 08 	lds	r25, 0x0814
    4726:	28 17       	cp	r18, r24
    4728:	39 07       	cpc	r19, r25
    472a:	08 f0       	brcs	.+2      	; 0x472e <Motor_GenerateOutputSignal+0x200>
    472c:	42 98       	cbi	0x08, 2	; 8
		if (i>=m4) M4 = 0;
    472e:	20 91 0b 08 	lds	r18, 0x080B
    4732:	30 91 0c 08 	lds	r19, 0x080C
    4736:	80 91 04 08 	lds	r24, 0x0804
    473a:	90 91 05 08 	lds	r25, 0x0805
    473e:	28 17       	cp	r18, r24
    4740:	39 07       	cpc	r19, r25
    4742:	08 f0       	brcs	.+2      	; 0x4746 <Motor_GenerateOutputSignal+0x218>
    4744:	43 98       	cbi	0x08, 3	; 8
				PMW_Pulse_Interval -=1;
			}
	}
		
	
	for (i=0;i<MOTORS_HIGH_VALUE+4;i+=4)			// 1000 gives a max of 2200us 
    4746:	80 91 0b 08 	lds	r24, 0x080B
    474a:	90 91 0c 08 	lds	r25, 0x080C
    474e:	04 96       	adiw	r24, 0x04	; 4
    4750:	90 93 0c 08 	sts	0x080C, r25
    4754:	80 93 0b 08 	sts	0x080B, r24
    4758:	80 91 0b 08 	lds	r24, 0x080B
    475c:	90 91 0c 08 	lds	r25, 0x080C
    4760:	24 e0       	ldi	r18, 0x04	; 4
    4762:	82 38       	cpi	r24, 0x82	; 130
    4764:	92 07       	cpc	r25, r18
    4766:	08 f4       	brcc	.+2      	; 0x476a <Motor_GenerateOutputSignal+0x23c>
    4768:	be cf       	rjmp	.-132    	; 0x46e6 <Motor_GenerateOutputSignal+0x1b8>
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    476a:	f8 94       	cli
		if (i>=m4) M4 = 0;
	}
	// Measure period of ESC rate from here
    ATOMIC_BLOCK(ATOMIC_FORCEON)
    {
      MotorStartTCNT = TCNT2_X;
    476c:	80 91 bf 05 	lds	r24, 0x05BF
    4770:	90 91 c0 05 	lds	r25, 0x05C0
    4774:	90 93 09 08 	sts	0x0809, r25
    4778:	80 93 08 08 	sts	0x0808, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    477c:	78 94       	sei
    }
	
	
 }
    477e:	08 95       	ret

00004780 <CalculateSignalLength1>:



void CalculateSignalLength1(uint8_t ChannelIndex)
{
	if (TCNT1 > RX_raw[0][ChannelIndex] )
    4780:	20 91 84 00 	lds	r18, 0x0084
    4784:	30 91 85 00 	lds	r19, 0x0085
    4788:	90 e0       	ldi	r25, 0x00	; 0
    478a:	88 0f       	add	r24, r24
    478c:	99 1f       	adc	r25, r25
    478e:	fc 01       	movw	r30, r24
    4790:	ea 5d       	subi	r30, 0xDA	; 218
    4792:	f7 4f       	sbci	r31, 0xF7	; 247
    4794:	40 81       	ld	r20, Z
    4796:	51 81       	ldd	r21, Z+1	; 0x01
    4798:	dc 01       	movw	r26, r24
    479a:	a0 53       	subi	r26, 0x30	; 48
    479c:	ba 4f       	sbci	r27, 0xFA	; 250
    479e:	42 17       	cp	r20, r18
    47a0:	53 07       	cpc	r21, r19
    47a2:	48 f4       	brcc	.+18     	; 0x47b6 <CalculateSignalLength1+0x36>
	{
		RX_Length[0][ChannelIndex] = TCNT1 - RX_raw[0][ChannelIndex] ;	
    47a4:	20 91 84 00 	lds	r18, 0x0084
    47a8:	30 91 85 00 	lds	r19, 0x0085
    47ac:	80 81       	ld	r24, Z
    47ae:	91 81       	ldd	r25, Z+1	; 0x01
    47b0:	28 1b       	sub	r18, r24
    47b2:	39 0b       	sbc	r19, r25
    47b4:	0a c0       	rjmp	.+20     	; 0x47ca <CalculateSignalLength1+0x4a>
	}
	else
	{
		RX_Length[0][ChannelIndex] = (0xffff - RX_raw[0][ChannelIndex] + TCNT1 );	
    47b6:	20 81       	ld	r18, Z
    47b8:	31 81       	ldd	r19, Z+1	; 0x01
    47ba:	80 91 84 00 	lds	r24, 0x0084
    47be:	90 91 85 00 	lds	r25, 0x0085
    47c2:	20 95       	com	r18
    47c4:	30 95       	com	r19
    47c6:	28 0f       	add	r18, r24
    47c8:	39 1f       	adc	r19, r25
    47ca:	11 96       	adiw	r26, 0x01	; 1
    47cc:	3c 93       	st	X, r19
    47ce:	2e 93       	st	-X, r18
    47d0:	08 95       	ret

000047d2 <CalculateSignalLength2>:
	}
	
}
void CalculateSignalLength2(uint8_t ChannelIndex)
{
	uint16_t TCNT1_TEMP = TCNT1;
    47d2:	20 91 84 00 	lds	r18, 0x0084
    47d6:	30 91 85 00 	lds	r19, 0x0085
	if (TCNT1_TEMP > RX_raw[1][ChannelIndex] )
    47da:	90 e0       	ldi	r25, 0x00	; 0
    47dc:	05 96       	adiw	r24, 0x05	; 5
    47de:	88 0f       	add	r24, r24
    47e0:	99 1f       	adc	r25, r25
    47e2:	fc 01       	movw	r30, r24
    47e4:	ea 5d       	subi	r30, 0xDA	; 218
    47e6:	f7 4f       	sbci	r31, 0xF7	; 247
    47e8:	40 81       	ld	r20, Z
    47ea:	51 81       	ldd	r21, Z+1	; 0x01
    47ec:	dc 01       	movw	r26, r24
    47ee:	a0 53       	subi	r26, 0x30	; 48
    47f0:	ba 4f       	sbci	r27, 0xFA	; 250
    47f2:	42 17       	cp	r20, r18
    47f4:	53 07       	cpc	r21, r19
    47f6:	40 f4       	brcc	.+16     	; 0x4808 <CalculateSignalLength2+0x36>
	{
		RX_Length[1][ChannelIndex] = TCNT1_TEMP - RX_raw[1][ChannelIndex] ;	
    47f8:	80 81       	ld	r24, Z
    47fa:	91 81       	ldd	r25, Z+1	; 0x01
    47fc:	28 1b       	sub	r18, r24
    47fe:	39 0b       	sbc	r19, r25
    4800:	11 96       	adiw	r26, 0x01	; 1
    4802:	3c 93       	st	X, r19
    4804:	2e 93       	st	-X, r18
    4806:	08 95       	ret
	}
	else
	{
		RX_Length[1][ChannelIndex] = (0xffff - RX_raw[1][ChannelIndex] + TCNT1_TEMP);	
    4808:	40 81       	ld	r20, Z
    480a:	51 81       	ldd	r21, Z+1	; 0x01
    480c:	40 95       	com	r20
    480e:	50 95       	com	r21
    4810:	42 0f       	add	r20, r18
    4812:	53 1f       	adc	r21, r19
    4814:	11 96       	adiw	r26, 0x01	; 1
    4816:	5c 93       	st	X, r21
    4818:	4e 93       	st	-X, r20
    481a:	08 95       	ret

0000481c <RX_Init>:


void RX_Init(void)
{
	
	RX_AUX_DIR   	 	= INPUT;
    481c:	20 98       	cbi	0x04, 0	; 4

#ifdef PRIMARY_INPUT_RX

	if (Config.RX_mode==RX_mode_BuddyMode)
    481e:	80 91 ef 06 	lds	r24, 0x06EF
    4822:	88 23       	and	r24, r24
    4824:	f1 f4       	brne	.+60     	; 0x4862 <RX_Init+0x46>
	{
	
		ActiveRXIndex=0;
    4826:	10 92 ce 05 	sts	0x05CE, r1
		RX1_ROLL_DIR 		= INPUT;
    482a:	52 98       	cbi	0x0a, 2	; 10
		RX1_PITCH_DIR 		= INPUT;
    482c:	50 98       	cbi	0x0a, 0	; 10
		RX1_COLL_DIR   		= INPUT;
    482e:	53 98       	cbi	0x0a, 3	; 10
		RX1_YAW_DIR   	 	= INPUT;
    4830:	22 98       	cbi	0x04, 2	; 4

		// enable interrupts
		EICRA  = _BV(ISC00) | _BV(ISC10) | _BV(ISC20);	// any edge on INT0, INT1 and INT2
    4832:	85 e1       	ldi	r24, 0x15	; 21
    4834:	80 93 69 00 	sts	0x0069, r24
		EIMSK  = _BV(INT0)  | _BV(INT1)  | _BV(INT2);	// enable interrupt for INT0, INT1 and INT2
    4838:	87 e0       	ldi	r24, 0x07	; 7
    483a:	8d bb       	out	0x1d, r24	; 29
		EIFR   = _BV(INTF0) | _BV(INTF1) | _BV(INTF2);	// clear interrupts
    483c:	8c bb       	out	0x1c, r24	; 28
		
		PCICR  |= _BV(PCIE1) | _BV(PCIE3);				// enable PCI1 and PCI3
    483e:	80 91 68 00 	lds	r24, 0x0068
    4842:	8a 60       	ori	r24, 0x0A	; 10
    4844:	80 93 68 00 	sts	0x0068, r24
		PCMSK1 |= _BV(PCINT8);							// enable PCINT8 (AUX) -> PCI1
    4848:	80 91 6c 00 	lds	r24, 0x006C
    484c:	81 60       	ori	r24, 0x01	; 1
    484e:	80 93 6c 00 	sts	0x006C, r24
		PCMSK3 |= _BV(PCINT24);							// enable PCINT24 (THR) -> PCI3
    4852:	80 91 73 00 	lds	r24, 0x0073
    4856:	81 60       	ori	r24, 0x01	; 1
    4858:	80 93 73 00 	sts	0x0073, r24
		PCIFR  |= _BV(PCIF1) | _BV(PCIF3);
    485c:	8b b3       	in	r24, 0x1b	; 27
    485e:	8a 60       	ori	r24, 0x0A	; 10
    4860:	8b bb       	out	0x1b, r24	; 27
#endif

	
#ifdef SECONDARY_INPUT_RX

	ActiveRXIndex=1;
    4862:	81 e0       	ldi	r24, 0x01	; 1
    4864:	80 93 ce 05 	sts	0x05CE, r24
	RX2_ROLL_DIR 		= INPUT;
    4868:	3d 98       	cbi	0x07, 5	; 7
	RX2_PITCH_DIR 		= INPUT;
    486a:	38 98       	cbi	0x07, 0	; 7
	RX2_COLL_DIR   		= INPUT;
    486c:	3f 98       	cbi	0x07, 7	; 7
	RX2_YAW_DIR   	 	= INPUT;
    486e:	39 98       	cbi	0x07, 1	; 7
	PCINT16 - PC0 - OUTPUT 6
	PCINT17 - PC1 - OUTPUT 5 
	PCINT21 - PC5 - OUTPUT 7
	PCINT23 - PC7 - OUTPUT 8 
	*/
	PCICR  |= _BV(PCIE1)   | _BV(PCIE2);														// enable PCI1 and PCI2
    4870:	80 91 68 00 	lds	r24, 0x0068
    4874:	86 60       	ori	r24, 0x06	; 6
    4876:	80 93 68 00 	sts	0x0068, r24
	PCMSK1 |= _BV(PCINT8);																		// enable PCINT8 (AUX) -> PCI1
    487a:	80 91 6c 00 	lds	r24, 0x006C
    487e:	81 60       	ori	r24, 0x01	; 1
    4880:	80 93 6c 00 	sts	0x006C, r24
	PCMSK2 |= _BV(PCINT16) | _BV(PCINT17) | _BV(PCINT21) |_BV(PCINT23);							// enable PCINT24 (THR) -> PCI3
    4884:	80 91 6d 00 	lds	r24, 0x006D
    4888:	83 6a       	ori	r24, 0xA3	; 163
    488a:	80 93 6d 00 	sts	0x006D, r24
	PCIFR  |= _BV(PCIF1)   | _BV(PCIF2);														// clear interrupts
    488e:	8b b3       	in	r24, 0x1b	; 27
    4890:	86 60       	ori	r24, 0x06	; 6
    4892:	8b bb       	out	0x1b, r24	; 27
#endif
	

		
	
	RX_Good =TX1_NOT_FOUND;
    4894:	80 91 ff 07 	lds	r24, 0x07FF
    4898:	81 60       	ori	r24, 0x01	; 1
    489a:	80 93 ff 07 	sts	0x07FF, r24
	RX_Good =TX2_NOT_FOUND;
    489e:	80 91 ff 07 	lds	r24, 0x07FF
    48a2:	80 61       	ori	r24, 0x10	; 16
    48a4:	80 93 ff 07 	sts	0x07FF, r24
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    48a8:	f8 94       	cli
	
	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		RX1_LastValidSignal_timestamp= TCNT1_X;
    48aa:	80 91 74 06 	lds	r24, 0x0674
    48ae:	90 91 75 06 	lds	r25, 0x0675
    48b2:	90 93 1e 08 	sts	0x081E, r25
    48b6:	80 93 1d 08 	sts	0x081D, r24
		RX1_LastValidSignal_timestampAux= TCNT1_X;
    48ba:	80 91 74 06 	lds	r24, 0x0674
    48be:	90 91 75 06 	lds	r25, 0x0675
    48c2:	90 93 20 08 	sts	0x0820, r25
    48c6:	80 93 1f 08 	sts	0x081F, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    48ca:	78 94       	sei
	}	
	
	RX2_LastValidSignal_timestamp= RX2_LastValidSignal_timestamp;
    48cc:	80 91 1b 08 	lds	r24, 0x081B
    48d0:	90 91 1c 08 	lds	r25, 0x081C
    48d4:	90 93 1c 08 	sts	0x081C, r25
    48d8:	80 93 1b 08 	sts	0x081B, r24
	RX2_LastValidSignal_timestampAux= RX2_LastValidSignal_timestampAux;	
    48dc:	80 91 17 08 	lds	r24, 0x0817
    48e0:	90 91 18 08 	lds	r25, 0x0818
    48e4:	90 93 18 08 	sts	0x0818, r25
    48e8:	80 93 17 08 	sts	0x0817, r24
}
    48ec:	08 95       	ret

000048ee <RX_raw_GetReceiverValues>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    48ee:	f8 94       	cli
  uint16_t RX_raw_GetReceiverValues (uint8_t RXIndex, uint8_t Channel)
{
	uint16_t _t;
	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		_t = RX_Length[RXIndex][Channel];
    48f0:	90 e0       	ldi	r25, 0x00	; 0
    48f2:	fc 01       	movw	r30, r24
    48f4:	ee 0f       	add	r30, r30
    48f6:	ff 1f       	adc	r31, r31
    48f8:	ee 0f       	add	r30, r30
    48fa:	ff 1f       	adc	r31, r31
    48fc:	e8 0f       	add	r30, r24
    48fe:	f9 1f       	adc	r31, r25
    4900:	e6 0f       	add	r30, r22
    4902:	f1 1d       	adc	r31, r1
    4904:	ee 0f       	add	r30, r30
    4906:	ff 1f       	adc	r31, r31
    4908:	e0 53       	subi	r30, 0x30	; 48
    490a:	fa 4f       	sbci	r31, 0xFA	; 250
    490c:	20 81       	ld	r18, Z
    490e:	31 81       	ldd	r19, Z+1	; 0x01
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    4910:	78 94       	sei
	}		
	return _t;
}
    4912:	c9 01       	movw	r24, r18
    4914:	08 95       	ret

00004916 <RX_GetReceiverValues>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    4916:	f8 94       	cli
{
	int16_t _t;
	//////if (RX_Good != TX_GOOD) return 0;
	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		_t = ((int)(RX_Length[RXIndex][Channel]));
    4918:	90 e0       	ldi	r25, 0x00	; 0
    491a:	70 e0       	ldi	r23, 0x00	; 0
    491c:	9c 01       	movw	r18, r24
    491e:	22 0f       	add	r18, r18
    4920:	33 1f       	adc	r19, r19
    4922:	22 0f       	add	r18, r18
    4924:	33 1f       	adc	r19, r19
    4926:	28 0f       	add	r18, r24
    4928:	39 1f       	adc	r19, r25
    492a:	a9 01       	movw	r20, r18
    492c:	46 0f       	add	r20, r22
    492e:	57 1f       	adc	r21, r23
    4930:	44 0f       	add	r20, r20
    4932:	55 1f       	adc	r21, r21
    4934:	fa 01       	movw	r30, r20
    4936:	e0 53       	subi	r30, 0x30	; 48
    4938:	fa 4f       	sbci	r31, 0xFA	; 250
    493a:	80 81       	ld	r24, Z
    493c:	91 81       	ldd	r25, Z+1	; 0x01
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    493e:	78 94       	sei
	}		
	_t -= Config.RX_Mid[RXIndex][Channel];
    4940:	40 5a       	subi	r20, 0xA0	; 160
    4942:	58 4f       	sbci	r21, 0xF8	; 248
    4944:	fa 01       	movw	r30, r20
    4946:	40 81       	ld	r20, Z
    4948:	51 81       	ldd	r21, Z+1	; 0x01
    494a:	84 1b       	sub	r24, r20
    494c:	95 0b       	sbc	r25, r21
	_t /=Config.RX_DiV_Value[RXIndex][Channel]; //RX_Div_Factor;
    494e:	26 0f       	add	r18, r22
    4950:	37 1f       	adc	r19, r23
    4952:	28 55       	subi	r18, 0x58	; 88
    4954:	38 4f       	sbci	r19, 0xF8	; 248
    4956:	f9 01       	movw	r30, r18
    4958:	60 81       	ld	r22, Z
    495a:	77 27       	eor	r23, r23
    495c:	67 fd       	sbrc	r22, 7
    495e:	70 95       	com	r23
    4960:	0e 94 61 38 	call	0x70c2	; 0x70c2 <__divmodhi4>
	return _t;
}
    4964:	cb 01       	movw	r24, r22
    4966:	08 95       	ret

00004968 <RX_GetReceiverThrottleValue>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    4968:	f8 94       	cli
	
	///if (RX_Good != TX_GOOD) return 0;
	
	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		if (RXIndex==0)
    496a:	88 23       	and	r24, r24
    496c:	11 f5       	brne	.+68     	; 0x49b2 <RX_GetReceiverThrottleValue+0x4a>
		{
			if ( (TCNT1_X - RX1_LastValidSignal_timestamp) > RX_SIGNAL_LOST_DURATION)
    496e:	40 91 74 06 	lds	r20, 0x0674
    4972:	50 91 75 06 	lds	r21, 0x0675
    4976:	60 91 1d 08 	lds	r22, 0x081D
    497a:	70 91 1e 08 	lds	r23, 0x081E
    497e:	46 1b       	sub	r20, r22
    4980:	57 0b       	sbc	r21, r23
    4982:	45 31       	cpi	r20, 0x15	; 21
    4984:	51 05       	cpc	r21, r1
    4986:	20 f0       	brcs	.+8      	; 0x4990 <RX_GetReceiverThrottleValue+0x28>
			{
				RX_Good =TX1_NOT_FOUND;
    4988:	80 91 ff 07 	lds	r24, 0x07FF
    498c:	81 60       	ori	r24, 0x01	; 1
    498e:	34 c0       	rjmp	.+104    	; 0x49f8 <RX_GetReceiverThrottleValue+0x90>
				return 0;
			}	
		
			if ( (TCNT1_X - RX1_LastValidSignal_timestampAux) > RX_SIGNAL_LOST_DURATION)
    4990:	40 91 74 06 	lds	r20, 0x0674
    4994:	50 91 75 06 	lds	r21, 0x0675
    4998:	60 91 1f 08 	lds	r22, 0x081F
    499c:	70 91 20 08 	lds	r23, 0x0820
    49a0:	46 1b       	sub	r20, r22
    49a2:	57 0b       	sbc	r21, r23
    49a4:	45 31       	cpi	r20, 0x15	; 21
    49a6:	51 05       	cpc	r21, r1
    49a8:	68 f1       	brcs	.+90     	; 0x4a04 <RX_GetReceiverThrottleValue+0x9c>
			{
				RX_Good =TX1_DISCONNECTED;
    49aa:	80 91 ff 07 	lds	r24, 0x07FF
    49ae:	82 60       	ori	r24, 0x02	; 2
    49b0:	23 c0       	rjmp	.+70     	; 0x49f8 <RX_GetReceiverThrottleValue+0x90>
				return 0;
			}
		}	
		if (RXIndex==1)
    49b2:	81 30       	cpi	r24, 0x01	; 1
    49b4:	39 f5       	brne	.+78     	; 0x4a04 <RX_GetReceiverThrottleValue+0x9c>
		{
			if ( (TCNT1_X - RX2_LastValidSignal_timestamp) > RX_SIGNAL_LOST_DURATION)
    49b6:	40 91 74 06 	lds	r20, 0x0674
    49ba:	50 91 75 06 	lds	r21, 0x0675
    49be:	60 91 1b 08 	lds	r22, 0x081B
    49c2:	70 91 1c 08 	lds	r23, 0x081C
    49c6:	46 1b       	sub	r20, r22
    49c8:	57 0b       	sbc	r21, r23
    49ca:	45 31       	cpi	r20, 0x15	; 21
    49cc:	51 05       	cpc	r21, r1
    49ce:	20 f0       	brcs	.+8      	; 0x49d8 <RX_GetReceiverThrottleValue+0x70>
			{
				RX_Good =TX2_NOT_FOUND;
    49d0:	80 91 ff 07 	lds	r24, 0x07FF
    49d4:	80 61       	ori	r24, 0x10	; 16
    49d6:	10 c0       	rjmp	.+32     	; 0x49f8 <RX_GetReceiverThrottleValue+0x90>
				return 0;
			}	
		
			if ( (TCNT1_X - RX2_LastValidSignal_timestampAux) > RX_SIGNAL_LOST_DURATION)
    49d8:	40 91 74 06 	lds	r20, 0x0674
    49dc:	50 91 75 06 	lds	r21, 0x0675
    49e0:	60 91 17 08 	lds	r22, 0x0817
    49e4:	70 91 18 08 	lds	r23, 0x0818
    49e8:	46 1b       	sub	r20, r22
    49ea:	57 0b       	sbc	r21, r23
    49ec:	45 31       	cpi	r20, 0x15	; 21
    49ee:	51 05       	cpc	r21, r1
    49f0:	48 f0       	brcs	.+18     	; 0x4a04 <RX_GetReceiverThrottleValue+0x9c>
			{
				RX_Good =TX2_DISCONNECTED;
    49f2:	80 91 ff 07 	lds	r24, 0x07FF
    49f6:	80 62       	ori	r24, 0x20	; 32
    49f8:	80 93 ff 07 	sts	0x07FF, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    49fc:	78 94       	sei
    __asm__ volatile ("" ::: "memory");
    49fe:	20 e0       	ldi	r18, 0x00	; 0
    4a00:	30 e0       	ldi	r19, 0x00	; 0
    4a02:	41 c0       	rjmp	.+130    	; 0x4a86 <RX_GetReceiverThrottleValue+0x11e>
				return 0;
			}
		}			
		
		
		iTemp16 = ((int)(RX_Length[RXIndex][RXChannel_THR]));
    4a04:	28 2f       	mov	r18, r24
    4a06:	30 e0       	ldi	r19, 0x00	; 0
    4a08:	c9 01       	movw	r24, r18
    4a0a:	88 0f       	add	r24, r24
    4a0c:	99 1f       	adc	r25, r25
    4a0e:	a9 01       	movw	r20, r18
    4a10:	b3 e0       	ldi	r27, 0x03	; 3
    4a12:	44 0f       	add	r20, r20
    4a14:	55 1f       	adc	r21, r21
    4a16:	ba 95       	dec	r27
    4a18:	e1 f7       	brne	.-8      	; 0x4a12 <RX_GetReceiverThrottleValue+0xaa>
    4a1a:	84 0f       	add	r24, r20
    4a1c:	95 1f       	adc	r25, r21
    4a1e:	fc 01       	movw	r30, r24
    4a20:	e0 53       	subi	r30, 0x30	; 48
    4a22:	fa 4f       	sbci	r31, 0xFA	; 250
    4a24:	46 81       	ldd	r20, Z+6	; 0x06
    4a26:	57 81       	ldd	r21, Z+7	; 0x07
    4a28:	50 93 22 08 	sts	0x0822, r21
    4a2c:	40 93 21 08 	sts	0x0821, r20
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    4a30:	78 94       	sei
	}		
	
	iTemp16 -= Config.RX_Min[RXIndex][RXChannel_THR];
    4a32:	40 91 21 08 	lds	r20, 0x0821
    4a36:	50 91 22 08 	lds	r21, 0x0822
    4a3a:	86 58       	subi	r24, 0x86	; 134
    4a3c:	98 4f       	sbci	r25, 0xF8	; 248
    4a3e:	fc 01       	movw	r30, r24
    4a40:	80 81       	ld	r24, Z
    4a42:	91 81       	ldd	r25, Z+1	; 0x01
    4a44:	48 1b       	sub	r20, r24
    4a46:	59 0b       	sbc	r21, r25
    4a48:	50 93 22 08 	sts	0x0822, r21
    4a4c:	40 93 21 08 	sts	0x0821, r20
	iTemp16 /= Config.RX_DiV_Value[RXIndex][RXChannel_THR]; //RX_Div_Factor;
    4a50:	80 91 21 08 	lds	r24, 0x0821
    4a54:	90 91 22 08 	lds	r25, 0x0822
    4a58:	f9 01       	movw	r30, r18
    4a5a:	ee 0f       	add	r30, r30
    4a5c:	ff 1f       	adc	r31, r31
    4a5e:	ee 0f       	add	r30, r30
    4a60:	ff 1f       	adc	r31, r31
    4a62:	e2 0f       	add	r30, r18
    4a64:	f3 1f       	adc	r31, r19
    4a66:	e5 55       	subi	r30, 0x55	; 85
    4a68:	f8 4f       	sbci	r31, 0xF8	; 248
    4a6a:	60 81       	ld	r22, Z
    4a6c:	77 27       	eor	r23, r23
    4a6e:	67 fd       	sbrc	r22, 7
    4a70:	70 95       	com	r23
    4a72:	0e 94 61 38 	call	0x70c2	; 0x70c2 <__divmodhi4>
    4a76:	70 93 22 08 	sts	0x0822, r23
    4a7a:	60 93 21 08 	sts	0x0821, r22
	 
	return iTemp16;
    4a7e:	20 91 21 08 	lds	r18, 0x0821
    4a82:	30 91 22 08 	lds	r19, 0x0822
}
    4a86:	c9 01       	movw	r24, r18
    4a88:	08 95       	ret

00004a8a <RX_CopyLatestReceiverValues>:
 
void RX_CopyLatestReceiverValues (void)
{
    4a8a:	cf 92       	push	r12
    4a8c:	df 92       	push	r13
    4a8e:	ef 92       	push	r14
    4a90:	ff 92       	push	r15
    4a92:	0f 93       	push	r16
    4a94:	1f 93       	push	r17
    4a96:	cf 93       	push	r28
    4a98:	df 93       	push	r29
	for (int ch=0;ch<2;++ch)
    4a9a:	c0 e0       	ldi	r28, 0x00	; 0
    4a9c:	d0 e0       	ldi	r29, 0x00	; 0
    4a9e:	2d c0       	rjmp	.+90     	; 0x4afa <RX_CopyLatestReceiverValues+0x70>
	{
		for (int i=0;i<RXChannels;++i)
		{
			if (i == RXChannel_THR)
    4aa0:	03 30       	cpi	r16, 0x03	; 3
    4aa2:	11 05       	cpc	r17, r1
    4aa4:	39 f4       	brne	.+14     	; 0x4ab4 <RX_CopyLatestReceiverValues+0x2a>
			{
				RX_Latest[ch][i]= RX_GetReceiverThrottleValue(ch);	 
    4aa6:	8c 2f       	mov	r24, r28
    4aa8:	0e 94 b4 24 	call	0x4968	; 0x4968 <RX_GetReceiverThrottleValue>
    4aac:	f7 01       	movw	r30, r14
    4aae:	91 83       	std	Z+1, r25	; 0x01
    4ab0:	80 83       	st	Z, r24
    4ab2:	1a c0       	rjmp	.+52     	; 0x4ae8 <RX_CopyLatestReceiverValues+0x5e>
			}
			else
			{
				RX_Latest[ch][i]= RX_GetReceiverValues(ch,i);	 
    4ab4:	8c 2f       	mov	r24, r28
    4ab6:	60 2f       	mov	r22, r16
    4ab8:	0e 94 8b 24 	call	0x4916	; 0x4916 <RX_GetReceiverValues>
    4abc:	f6 01       	movw	r30, r12
    4abe:	e0 0f       	add	r30, r16
    4ac0:	f1 1f       	adc	r31, r17
    4ac2:	ee 0f       	add	r30, r30
    4ac4:	ff 1f       	adc	r31, r31
    4ac6:	ea 5f       	subi	r30, 0xFA	; 250
    4ac8:	f9 4f       	sbci	r31, 0xF9	; 249
    4aca:	91 83       	std	Z+1, r25	; 0x01
    4acc:	80 83       	st	Z, r24
				if ((RX_Latest[ch][i]<STICK_DEADBAND) && (RX_Latest[ch][i]>-STICK_DEADBAND)) RX_Latest[ch][i]=0;
    4ace:	80 81       	ld	r24, Z
    4ad0:	91 81       	ldd	r25, Z+1	; 0x01
    4ad2:	8f 30       	cpi	r24, 0x0F	; 15
    4ad4:	91 05       	cpc	r25, r1
    4ad6:	44 f4       	brge	.+16     	; 0x4ae8 <RX_CopyLatestReceiverValues+0x5e>
    4ad8:	80 81       	ld	r24, Z
    4ada:	91 81       	ldd	r25, Z+1	; 0x01
    4adc:	3f ef       	ldi	r19, 0xFF	; 255
    4ade:	82 3f       	cpi	r24, 0xF2	; 242
    4ae0:	93 07       	cpc	r25, r19
    4ae2:	14 f0       	brlt	.+4      	; 0x4ae8 <RX_CopyLatestReceiverValues+0x5e>
    4ae4:	11 82       	std	Z+1, r1	; 0x01
    4ae6:	10 82       	st	Z, r1
 
void RX_CopyLatestReceiverValues (void)
{
	for (int ch=0;ch<2;++ch)
	{
		for (int i=0;i<RXChannels;++i)
    4ae8:	0f 5f       	subi	r16, 0xFF	; 255
    4aea:	1f 4f       	sbci	r17, 0xFF	; 255
    4aec:	05 30       	cpi	r16, 0x05	; 5
    4aee:	11 05       	cpc	r17, r1
    4af0:	b9 f6       	brne	.-82     	; 0x4aa0 <RX_CopyLatestReceiverValues+0x16>
	return iTemp16;
}
 
void RX_CopyLatestReceiverValues (void)
{
	for (int ch=0;ch<2;++ch)
    4af2:	21 96       	adiw	r28, 0x01	; 1
    4af4:	c2 30       	cpi	r28, 0x02	; 2
    4af6:	d1 05       	cpc	r29, r1
    4af8:	c9 f0       	breq	.+50     	; 0x4b2c <RX_CopyLatestReceiverValues+0xa2>
	 
	return iTemp16;
}
 
void RX_CopyLatestReceiverValues (void)
{
    4afa:	00 e0       	ldi	r16, 0x00	; 0
    4afc:	10 e0       	ldi	r17, 0x00	; 0
			{
				RX_Latest[ch][i]= RX_GetReceiverThrottleValue(ch);	 
			}
			else
			{
				RX_Latest[ch][i]= RX_GetReceiverValues(ch,i);	 
    4afe:	6e 01       	movw	r12, r28
    4b00:	cc 0c       	add	r12, r12
    4b02:	dd 1c       	adc	r13, r13
    4b04:	cc 0c       	add	r12, r12
    4b06:	dd 1c       	adc	r13, r13
    4b08:	cc 0e       	add	r12, r28
    4b0a:	dd 1e       	adc	r13, r29
	{
		for (int i=0;i<RXChannels;++i)
		{
			if (i == RXChannel_THR)
			{
				RX_Latest[ch][i]= RX_GetReceiverThrottleValue(ch);	 
    4b0c:	7e 01       	movw	r14, r28
    4b0e:	ee 0c       	add	r14, r14
    4b10:	ff 1c       	adc	r15, r15
    4b12:	ce 01       	movw	r24, r28
    4b14:	53 e0       	ldi	r21, 0x03	; 3
    4b16:	88 0f       	add	r24, r24
    4b18:	99 1f       	adc	r25, r25
    4b1a:	5a 95       	dec	r21
    4b1c:	e1 f7       	brne	.-8      	; 0x4b16 <RX_CopyLatestReceiverValues+0x8c>
    4b1e:	e8 0e       	add	r14, r24
    4b20:	f9 1e       	adc	r15, r25
    4b22:	8c e0       	ldi	r24, 0x0C	; 12
    4b24:	96 e0       	ldi	r25, 0x06	; 6
    4b26:	e8 0e       	add	r14, r24
    4b28:	f9 1e       	adc	r15, r25
    4b2a:	ba cf       	rjmp	.-140    	; 0x4aa0 <RX_CopyLatestReceiverValues+0x16>
				if ((RX_Latest[ch][i]<STICK_DEADBAND) && (RX_Latest[ch][i]>-STICK_DEADBAND)) RX_Latest[ch][i]=0;
			}
		}	
	}
				
}
    4b2c:	df 91       	pop	r29
    4b2e:	cf 91       	pop	r28
    4b30:	1f 91       	pop	r17
    4b32:	0f 91       	pop	r16
    4b34:	ff 90       	pop	r15
    4b36:	ef 90       	pop	r14
    4b38:	df 90       	pop	r13
    4b3a:	cf 90       	pop	r12
    4b3c:	08 95       	ret

00004b3e <RX_StickCenterCalibrationInit>:

void RX_StickCenterCalibrationInit(uint8_t RXIndex)
{
	for (int i=0; i<RXChannels; ++i)
	{
		RX_MAX_raw[RXIndex][i]=0;
    4b3e:	65 e2       	ldi	r22, 0x25	; 37
    4b40:	76 e0       	ldi	r23, 0x06	; 6
    4b42:	28 2f       	mov	r18, r24
    4b44:	30 e0       	ldi	r19, 0x00	; 0
    4b46:	f9 01       	movw	r30, r18
    4b48:	ee 0f       	add	r30, r30
    4b4a:	ff 1f       	adc	r31, r31
    4b4c:	93 e0       	ldi	r25, 0x03	; 3
    4b4e:	22 0f       	add	r18, r18
    4b50:	33 1f       	adc	r19, r19
    4b52:	9a 95       	dec	r25
    4b54:	e1 f7       	brne	.-8      	; 0x4b4e <RX_StickCenterCalibrationInit+0x10>
    4b56:	e2 0f       	add	r30, r18
    4b58:	f3 1f       	adc	r31, r19
    4b5a:	e6 0f       	add	r30, r22
    4b5c:	f7 1f       	adc	r31, r23
    4b5e:	11 82       	std	Z+1, r1	; 0x01
    4b60:	10 82       	st	Z, r1
		RX_MIN_raw[RXIndex][i]=0xfffe;
    4b62:	46 ec       	ldi	r20, 0xC6	; 198
    4b64:	56 e0       	ldi	r21, 0x06	; 6
    4b66:	28 2f       	mov	r18, r24
    4b68:	30 e0       	ldi	r19, 0x00	; 0
    4b6a:	f9 01       	movw	r30, r18
    4b6c:	ee 0f       	add	r30, r30
    4b6e:	ff 1f       	adc	r31, r31
    4b70:	a3 e0       	ldi	r26, 0x03	; 3
    4b72:	22 0f       	add	r18, r18
    4b74:	33 1f       	adc	r19, r19
    4b76:	aa 95       	dec	r26
    4b78:	e1 f7       	brne	.-8      	; 0x4b72 <RX_StickCenterCalibrationInit+0x34>
    4b7a:	e2 0f       	add	r30, r18
    4b7c:	f3 1f       	adc	r31, r19
    4b7e:	e4 0f       	add	r30, r20
    4b80:	f5 1f       	adc	r31, r21
    4b82:	2e ef       	ldi	r18, 0xFE	; 254
    4b84:	3f ef       	ldi	r19, 0xFF	; 255
    4b86:	31 83       	std	Z+1, r19	; 0x01
    4b88:	20 83       	st	Z, r18

void RX_StickCenterCalibrationInit(uint8_t RXIndex)
{
	for (int i=0; i<RXChannels; ++i)
	{
		RX_MAX_raw[RXIndex][i]=0;
    4b8a:	a8 2f       	mov	r26, r24
    4b8c:	b0 e0       	ldi	r27, 0x00	; 0
    4b8e:	fd 01       	movw	r30, r26
    4b90:	ee 0f       	add	r30, r30
    4b92:	ff 1f       	adc	r31, r31
    4b94:	93 e0       	ldi	r25, 0x03	; 3
    4b96:	aa 0f       	add	r26, r26
    4b98:	bb 1f       	adc	r27, r27
    4b9a:	9a 95       	dec	r25
    4b9c:	e1 f7       	brne	.-8      	; 0x4b96 <RX_StickCenterCalibrationInit+0x58>
    4b9e:	ea 0f       	add	r30, r26
    4ba0:	fb 1f       	adc	r31, r27
    4ba2:	e6 0f       	add	r30, r22
    4ba4:	f7 1f       	adc	r31, r23
    4ba6:	13 82       	std	Z+3, r1	; 0x03
    4ba8:	12 82       	std	Z+2, r1	; 0x02
		RX_MIN_raw[RXIndex][i]=0xfffe;
    4baa:	a8 2f       	mov	r26, r24
    4bac:	b0 e0       	ldi	r27, 0x00	; 0
    4bae:	fd 01       	movw	r30, r26
    4bb0:	ee 0f       	add	r30, r30
    4bb2:	ff 1f       	adc	r31, r31
    4bb4:	93 e0       	ldi	r25, 0x03	; 3
    4bb6:	aa 0f       	add	r26, r26
    4bb8:	bb 1f       	adc	r27, r27
    4bba:	9a 95       	dec	r25
    4bbc:	e1 f7       	brne	.-8      	; 0x4bb6 <RX_StickCenterCalibrationInit+0x78>
    4bbe:	ea 0f       	add	r30, r26
    4bc0:	fb 1f       	adc	r31, r27
    4bc2:	e4 0f       	add	r30, r20
    4bc4:	f5 1f       	adc	r31, r21
    4bc6:	33 83       	std	Z+3, r19	; 0x03
    4bc8:	22 83       	std	Z+2, r18	; 0x02

void RX_StickCenterCalibrationInit(uint8_t RXIndex)
{
	for (int i=0; i<RXChannels; ++i)
	{
		RX_MAX_raw[RXIndex][i]=0;
    4bca:	a8 2f       	mov	r26, r24
    4bcc:	b0 e0       	ldi	r27, 0x00	; 0
    4bce:	fd 01       	movw	r30, r26
    4bd0:	ee 0f       	add	r30, r30
    4bd2:	ff 1f       	adc	r31, r31
    4bd4:	93 e0       	ldi	r25, 0x03	; 3
    4bd6:	aa 0f       	add	r26, r26
    4bd8:	bb 1f       	adc	r27, r27
    4bda:	9a 95       	dec	r25
    4bdc:	e1 f7       	brne	.-8      	; 0x4bd6 <RX_StickCenterCalibrationInit+0x98>
    4bde:	ea 0f       	add	r30, r26
    4be0:	fb 1f       	adc	r31, r27
    4be2:	e6 0f       	add	r30, r22
    4be4:	f7 1f       	adc	r31, r23
    4be6:	15 82       	std	Z+5, r1	; 0x05
    4be8:	14 82       	std	Z+4, r1	; 0x04
		RX_MIN_raw[RXIndex][i]=0xfffe;
    4bea:	a8 2f       	mov	r26, r24
    4bec:	b0 e0       	ldi	r27, 0x00	; 0
    4bee:	fd 01       	movw	r30, r26
    4bf0:	ee 0f       	add	r30, r30
    4bf2:	ff 1f       	adc	r31, r31
    4bf4:	93 e0       	ldi	r25, 0x03	; 3
    4bf6:	aa 0f       	add	r26, r26
    4bf8:	bb 1f       	adc	r27, r27
    4bfa:	9a 95       	dec	r25
    4bfc:	e1 f7       	brne	.-8      	; 0x4bf6 <RX_StickCenterCalibrationInit+0xb8>
    4bfe:	ea 0f       	add	r30, r26
    4c00:	fb 1f       	adc	r31, r27
    4c02:	e4 0f       	add	r30, r20
    4c04:	f5 1f       	adc	r31, r21
    4c06:	35 83       	std	Z+5, r19	; 0x05
    4c08:	24 83       	std	Z+4, r18	; 0x04

void RX_StickCenterCalibrationInit(uint8_t RXIndex)
{
	for (int i=0; i<RXChannels; ++i)
	{
		RX_MAX_raw[RXIndex][i]=0;
    4c0a:	a8 2f       	mov	r26, r24
    4c0c:	b0 e0       	ldi	r27, 0x00	; 0
    4c0e:	fd 01       	movw	r30, r26
    4c10:	ee 0f       	add	r30, r30
    4c12:	ff 1f       	adc	r31, r31
    4c14:	93 e0       	ldi	r25, 0x03	; 3
    4c16:	aa 0f       	add	r26, r26
    4c18:	bb 1f       	adc	r27, r27
    4c1a:	9a 95       	dec	r25
    4c1c:	e1 f7       	brne	.-8      	; 0x4c16 <RX_StickCenterCalibrationInit+0xd8>
    4c1e:	ea 0f       	add	r30, r26
    4c20:	fb 1f       	adc	r31, r27
    4c22:	e6 0f       	add	r30, r22
    4c24:	f7 1f       	adc	r31, r23
    4c26:	17 82       	std	Z+7, r1	; 0x07
    4c28:	16 82       	std	Z+6, r1	; 0x06
		RX_MIN_raw[RXIndex][i]=0xfffe;
    4c2a:	a8 2f       	mov	r26, r24
    4c2c:	b0 e0       	ldi	r27, 0x00	; 0
    4c2e:	fd 01       	movw	r30, r26
    4c30:	ee 0f       	add	r30, r30
    4c32:	ff 1f       	adc	r31, r31
    4c34:	93 e0       	ldi	r25, 0x03	; 3
    4c36:	aa 0f       	add	r26, r26
    4c38:	bb 1f       	adc	r27, r27
    4c3a:	9a 95       	dec	r25
    4c3c:	e1 f7       	brne	.-8      	; 0x4c36 <RX_StickCenterCalibrationInit+0xf8>
    4c3e:	ea 0f       	add	r30, r26
    4c40:	fb 1f       	adc	r31, r27
    4c42:	e4 0f       	add	r30, r20
    4c44:	f5 1f       	adc	r31, r21
    4c46:	37 83       	std	Z+7, r19	; 0x07
    4c48:	26 83       	std	Z+6, r18	; 0x06

void RX_StickCenterCalibrationInit(uint8_t RXIndex)
{
	for (int i=0; i<RXChannels; ++i)
	{
		RX_MAX_raw[RXIndex][i]=0;
    4c4a:	a8 2f       	mov	r26, r24
    4c4c:	b0 e0       	ldi	r27, 0x00	; 0
    4c4e:	fd 01       	movw	r30, r26
    4c50:	ee 0f       	add	r30, r30
    4c52:	ff 1f       	adc	r31, r31
    4c54:	93 e0       	ldi	r25, 0x03	; 3
    4c56:	aa 0f       	add	r26, r26
    4c58:	bb 1f       	adc	r27, r27
    4c5a:	9a 95       	dec	r25
    4c5c:	e1 f7       	brne	.-8      	; 0x4c56 <RX_StickCenterCalibrationInit+0x118>
    4c5e:	ea 0f       	add	r30, r26
    4c60:	fb 1f       	adc	r31, r27
    4c62:	e6 0f       	add	r30, r22
    4c64:	f7 1f       	adc	r31, r23
    4c66:	11 86       	std	Z+9, r1	; 0x09
    4c68:	10 86       	std	Z+8, r1	; 0x08
		RX_MIN_raw[RXIndex][i]=0xfffe;
    4c6a:	68 2f       	mov	r22, r24
    4c6c:	70 e0       	ldi	r23, 0x00	; 0
    4c6e:	fb 01       	movw	r30, r22
    4c70:	ee 0f       	add	r30, r30
    4c72:	ff 1f       	adc	r31, r31
    4c74:	b3 e0       	ldi	r27, 0x03	; 3
    4c76:	66 0f       	add	r22, r22
    4c78:	77 1f       	adc	r23, r23
    4c7a:	ba 95       	dec	r27
    4c7c:	e1 f7       	brne	.-8      	; 0x4c76 <RX_StickCenterCalibrationInit+0x138>
    4c7e:	e6 0f       	add	r30, r22
    4c80:	f7 1f       	adc	r31, r23
    4c82:	e4 0f       	add	r30, r20
    4c84:	f5 1f       	adc	r31, r21
    4c86:	31 87       	std	Z+9, r19	; 0x09
    4c88:	20 87       	std	Z+8, r18	; 0x08
	}
}
    4c8a:	08 95       	ret

00004c8c <RX_StickCenterCalibration>:


void RX_StickCenterCalibration (uint8_t RXIndex)
{
    4c8c:	df 92       	push	r13
    4c8e:	ef 92       	push	r14
    4c90:	ff 92       	push	r15
    4c92:	0f 93       	push	r16
    4c94:	1f 93       	push	r17
    4c96:	cf 93       	push	r28
    4c98:	df 93       	push	r29
    4c9a:	d8 2e       	mov	r13, r24
		RX_MIN_raw[RXIndex][i]=0xfffe;
	}
}


void RX_StickCenterCalibration (uint8_t RXIndex)
    4c9c:	28 2f       	mov	r18, r24
    4c9e:	30 e0       	ldi	r19, 0x00	; 0
    4ca0:	89 01       	movw	r16, r18
    4ca2:	00 0f       	add	r16, r16
    4ca4:	11 1f       	adc	r17, r17
    4ca6:	73 e0       	ldi	r23, 0x03	; 3
    4ca8:	22 0f       	add	r18, r18
    4caa:	33 1f       	adc	r19, r19
    4cac:	7a 95       	dec	r23
    4cae:	e1 f7       	brne	.-8      	; 0x4ca8 <RX_StickCenterCalibration+0x1c>
    4cb0:	02 0f       	add	r16, r18
    4cb2:	13 1f       	adc	r17, r19
    4cb4:	0b 5d       	subi	r16, 0xDB	; 219
    4cb6:	19 4f       	sbci	r17, 0xF9	; 249
    4cb8:	28 2f       	mov	r18, r24
    4cba:	30 e0       	ldi	r19, 0x00	; 0
    4cbc:	e9 01       	movw	r28, r18
    4cbe:	cc 0f       	add	r28, r28
    4cc0:	dd 1f       	adc	r29, r29
    4cc2:	53 e0       	ldi	r21, 0x03	; 3
    4cc4:	22 0f       	add	r18, r18
    4cc6:	33 1f       	adc	r19, r19
    4cc8:	5a 95       	dec	r21
    4cca:	e1 f7       	brne	.-8      	; 0x4cc4 <RX_StickCenterCalibration+0x38>
    4ccc:	c2 0f       	add	r28, r18
    4cce:	d3 1f       	adc	r29, r19
    4cd0:	ca 53       	subi	r28, 0x3A	; 58
    4cd2:	d9 4f       	sbci	r29, 0xF9	; 249
{
	
	uint16_t tempRX;
	for (int i=0;i<RXChannels;++i)
    4cd4:	ee 24       	eor	r14, r14
    4cd6:	ff 24       	eor	r15, r15
	{
		tempRX = RX_raw_GetReceiverValues(RXIndex,i);
    4cd8:	8d 2d       	mov	r24, r13
    4cda:	6e 2d       	mov	r22, r14
    4cdc:	0e 94 77 24 	call	0x48ee	; 0x48ee <RX_raw_GetReceiverValues>
    4ce0:	9c 01       	movw	r18, r24
		if (tempRX!=0)
    4ce2:	00 97       	sbiw	r24, 0x00	; 0
    4ce4:	81 f0       	breq	.+32     	; 0x4d06 <RX_StickCenterCalibration+0x7a>
		{
			
			if ( tempRX > RX_MAX_raw[RXIndex][i]) 
    4ce6:	f8 01       	movw	r30, r16
    4ce8:	80 81       	ld	r24, Z
    4cea:	91 81       	ldd	r25, Z+1	; 0x01
    4cec:	82 17       	cp	r24, r18
    4cee:	93 07       	cpc	r25, r19
    4cf0:	18 f4       	brcc	.+6      	; 0x4cf8 <RX_StickCenterCalibration+0x6c>
			{
				RX_MAX_raw[RXIndex][i] = tempRX;
    4cf2:	31 83       	std	Z+1, r19	; 0x01
    4cf4:	20 83       	st	Z, r18
    4cf6:	07 c0       	rjmp	.+14     	; 0x4d06 <RX_StickCenterCalibration+0x7a>
			}
			else if (tempRX < RX_MIN_raw[RXIndex][i]) 
    4cf8:	88 81       	ld	r24, Y
    4cfa:	99 81       	ldd	r25, Y+1	; 0x01
    4cfc:	28 17       	cp	r18, r24
    4cfe:	39 07       	cpc	r19, r25
    4d00:	10 f4       	brcc	.+4      	; 0x4d06 <RX_StickCenterCalibration+0x7a>
			{
				RX_MIN_raw[RXIndex][i] = tempRX;
    4d02:	39 83       	std	Y+1, r19	; 0x01
    4d04:	28 83       	st	Y, r18

void RX_StickCenterCalibration (uint8_t RXIndex)
{
	
	uint16_t tempRX;
	for (int i=0;i<RXChannels;++i)
    4d06:	08 94       	sec
    4d08:	e1 1c       	adc	r14, r1
    4d0a:	f1 1c       	adc	r15, r1
    4d0c:	0e 5f       	subi	r16, 0xFE	; 254
    4d0e:	1f 4f       	sbci	r17, 0xFF	; 255
    4d10:	22 96       	adiw	r28, 0x02	; 2
    4d12:	f5 e0       	ldi	r31, 0x05	; 5
    4d14:	ef 16       	cp	r14, r31
    4d16:	f1 04       	cpc	r15, r1
    4d18:	f9 f6       	brne	.-66     	; 0x4cd8 <RX_StickCenterCalibration+0x4c>
			{
				RX_MIN_raw[RXIndex][i] = tempRX;
			}
		}
	}				
    4d1a:	df 91       	pop	r29
    4d1c:	cf 91       	pop	r28
    4d1e:	1f 91       	pop	r17
    4d20:	0f 91       	pop	r16
    4d22:	ff 90       	pop	r15
    4d24:	ef 90       	pop	r14
    4d26:	df 90       	pop	r13
    4d28:	08 95       	ret

00004d2a <Sensors_Init>:
P_STR strOK[] ="OK  ";
P_STR strFail[] ="Fail";

void Sensors_Init(void)
{
	ACC_PITCH  = INPUT;
    4d2a:	15 98       	cbi	0x02, 5	; 2
	ACC_ROLL  = INPUT;
    4d2c:	16 98       	cbi	0x02, 6	; 2
	ACC_Z  = INPUT;
    4d2e:	17 98       	cbi	0x02, 7	; 2
	
	GYRO_ROLL = INPUT;
    4d30:	11 98       	cbi	0x02, 1	; 2
	GYRO_PITCH = INPUT;
    4d32:	14 98       	cbi	0x02, 4	; 2
	GYRO_Z = INPUT;
    4d34:	12 98       	cbi	0x02, 2	; 2
	//{
		//
		//StabilityMatrix_GX[i]=0;
		//StabilityMatrix_GY[i]=0;
	//}
}
    4d36:	08 95       	ret

00004d38 <Sensors_Test>:

/*
// This function Test if sensors are working OK or not.
*/
char *Sensors_Test(uint8_t channel, uint16_t LowLimit ,uint16_t HighLimit)
{
    4d38:	ef 92       	push	r14
    4d3a:	ff 92       	push	r15
    4d3c:	0f 93       	push	r16
    4d3e:	1f 93       	push	r17
    4d40:	cf 93       	push	r28
    4d42:	df 93       	push	r29
    4d44:	8b 01       	movw	r16, r22
    4d46:	7a 01       	movw	r14, r20
	
	nResult[channel] = ADCPort_Get(channel);
    4d48:	c8 2f       	mov	r28, r24
    4d4a:	d0 e0       	ldi	r29, 0x00	; 0
    4d4c:	0e 94 75 28 	call	0x50ea	; 0x50ea <ADCPort_Get>
    4d50:	cc 0f       	add	r28, r28
    4d52:	dd 1f       	adc	r29, r29
    4d54:	ce 55       	subi	r28, 0x5E	; 94
    4d56:	da 4f       	sbci	r29, 0xFA	; 250
    4d58:	99 83       	std	Y+1, r25	; 0x01
    4d5a:	88 83       	st	Y, r24
	  
	utoa (nResult[channel],Result,10);
    4d5c:	88 81       	ld	r24, Y
    4d5e:	99 81       	ldd	r25, Y+1	; 0x01
    4d60:	62 eb       	ldi	r22, 0xB2	; 178
    4d62:	75 e0       	ldi	r23, 0x05	; 5
    4d64:	4a e0       	ldi	r20, 0x0A	; 10
    4d66:	50 e0       	ldi	r21, 0x00	; 0
    4d68:	0e 94 ed 38 	call	0x71da	; 0x71da <utoa>
	
	if ((nResult[channel]  >= LowLimit)  
    4d6c:	88 81       	ld	r24, Y
    4d6e:	99 81       	ldd	r25, Y+1	; 0x01
    4d70:	80 17       	cp	r24, r16
    4d72:	91 07       	cpc	r25, r17
    4d74:	50 f0       	brcs	.+20     	; 0x4d8a <Sensors_Test+0x52>
	 && (nResult[channel]  <= HighLimit))
    4d76:	88 81       	ld	r24, Y
    4d78:	99 81       	ldd	r25, Y+1	; 0x01
    4d7a:	e8 16       	cp	r14, r24
    4d7c:	f9 06       	cpc	r15, r25
    4d7e:	28 f0       	brcs	.+10     	; 0x4d8a <Sensors_Test+0x52>
	{
		strcat (Result, ("  "));  
    4d80:	82 eb       	ldi	r24, 0xB2	; 178
    4d82:	95 e0       	ldi	r25, 0x05	; 5
    4d84:	68 e0       	ldi	r22, 0x08	; 8
    4d86:	71 e0       	ldi	r23, 0x01	; 1
    4d88:	04 c0       	rjmp	.+8      	; 0x4d92 <Sensors_Test+0x5a>
	}
	else
	{
		strcat (Result, (" X"));  
    4d8a:	82 eb       	ldi	r24, 0xB2	; 178
    4d8c:	95 e0       	ldi	r25, 0x05	; 5
    4d8e:	6b e0       	ldi	r22, 0x0B	; 11
    4d90:	71 e0       	ldi	r23, 0x01	; 1
    4d92:	0e 94 c1 38 	call	0x7182	; 0x7182 <strcat>
	}
	  
	return Result;
}
    4d96:	82 eb       	ldi	r24, 0xB2	; 178
    4d98:	95 e0       	ldi	r25, 0x05	; 5
    4d9a:	df 91       	pop	r29
    4d9c:	cf 91       	pop	r28
    4d9e:	1f 91       	pop	r17
    4da0:	0f 91       	pop	r16
    4da2:	ff 90       	pop	r15
    4da4:	ef 90       	pop	r14
    4da6:	08 95       	ret

00004da8 <Sensors_Calibrate>:

/*
// Calibrate Sensors and return result in nResult global variable.
*/
void Sensors_Calibrate (void)
{
    4da8:	8f 92       	push	r8
    4daa:	9f 92       	push	r9
    4dac:	af 92       	push	r10
    4dae:	bf 92       	push	r11
    4db0:	cf 92       	push	r12
    4db2:	df 92       	push	r13
    4db4:	ef 92       	push	r14
    4db6:	ff 92       	push	r15
    4db8:	0f 93       	push	r16
    4dba:	1f 93       	push	r17
    4dbc:	df 93       	push	r29
    4dbe:	cf 93       	push	r28
    4dc0:	0f 92       	push	r0
    4dc2:	cd b7       	in	r28, 0x3d	; 61
    4dc4:	de b7       	in	r29, 0x3e	; 62
	
	BOOL LEDOLD = LED_Orange;
    4dc6:	25 b1       	in	r18, 0x05	; 5
    4dc8:	26 95       	lsr	r18
    4dca:	26 95       	lsr	r18
    4dcc:	26 95       	lsr	r18
    4dce:	21 70       	andi	r18, 0x01	; 1
	int i;
	for (i=0;i<6;++i)
	{
		nResult [i]=0;
    4dd0:	10 92 a3 05 	sts	0x05A3, r1
    4dd4:	10 92 a2 05 	sts	0x05A2, r1
    4dd8:	10 92 a5 05 	sts	0x05A5, r1
    4ddc:	10 92 a4 05 	sts	0x05A4, r1
    4de0:	10 92 a7 05 	sts	0x05A7, r1
    4de4:	10 92 a6 05 	sts	0x05A6, r1
    4de8:	10 92 a9 05 	sts	0x05A9, r1
    4dec:	10 92 a8 05 	sts	0x05A8, r1
    4df0:	10 92 ab 05 	sts	0x05AB, r1
    4df4:	10 92 aa 05 	sts	0x05AA, r1
    4df8:	10 92 ad 05 	sts	0x05AD, r1
    4dfc:	10 92 ac 05 	sts	0x05AC, r1
    4e00:	69 e1       	ldi	r22, 0x19	; 25
    4e02:	c6 2e       	mov	r12, r22
    4e04:	d1 2c       	mov	r13, r1
    4e06:	34 c0       	rjmp	.+104    	; 0x4e70 <Sensors_Calibrate+0xc8>
		// check: http://www.x-firm.com/?page_id=191
		for (i=0;i<25;++i)
		{
			for (int s=0;s<SENSORS_ALL;++s)
			{
				nResult[s] += ADCPort_Get(SensorsIndex[s]);		
    4e08:	84 01       	movw	r16, r8
    4e0a:	00 0f       	add	r16, r16
    4e0c:	11 1f       	adc	r17, r17
    4e0e:	0e 55       	subi	r16, 0x5E	; 94
    4e10:	1a 4f       	sbci	r17, 0xFA	; 250
    4e12:	f8 01       	movw	r30, r16
    4e14:	e0 80       	ld	r14, Z
    4e16:	f1 80       	ldd	r15, Z+1	; 0x01
    4e18:	f5 01       	movw	r30, r10
    4e1a:	81 91       	ld	r24, Z+
    4e1c:	5f 01       	movw	r10, r30
    4e1e:	29 83       	std	Y+1, r18	; 0x01
    4e20:	0e 94 75 28 	call	0x50ea	; 0x50ea <ADCPort_Get>
    4e24:	e8 0e       	add	r14, r24
    4e26:	f9 1e       	adc	r15, r25
    4e28:	f8 01       	movw	r30, r16
    4e2a:	f1 82       	std	Z+1, r15	; 0x01
    4e2c:	e0 82       	st	Z, r14
	
		
		// check: http://www.x-firm.com/?page_id=191
		for (i=0;i<25;++i)
		{
			for (int s=0;s<SENSORS_ALL;++s)
    4e2e:	08 94       	sec
    4e30:	81 1c       	adc	r8, r1
    4e32:	91 1c       	adc	r9, r1
    4e34:	29 81       	ldd	r18, Y+1	; 0x01
    4e36:	f7 e0       	ldi	r31, 0x07	; 7
    4e38:	8f 16       	cp	r8, r31
    4e3a:	91 04       	cpc	r9, r1
    4e3c:	29 f7       	brne	.-54     	; 0x4e08 <Sensors_Calibrate+0x60>
    4e3e:	8f e0       	ldi	r24, 0x0F	; 15
    4e40:	97 e2       	ldi	r25, 0x27	; 39
    4e42:	01 97       	sbiw	r24, 0x01	; 1
    4e44:	f1 f7       	brne	.-4      	; 0x4e42 <Sensors_Calibrate+0x9a>
    4e46:	00 c0       	rjmp	.+0      	; 0x4e48 <Sensors_Calibrate+0xa0>
    4e48:	00 00       	nop
			{
				nResult[s] += ADCPort_Get(SensorsIndex[s]);		
			}
			_delay_ms(40);
			LED_Orange =~LED_Orange;
    4e4a:	85 b1       	in	r24, 0x05	; 5
    4e4c:	86 95       	lsr	r24
    4e4e:	86 95       	lsr	r24
    4e50:	86 95       	lsr	r24
    4e52:	80 95       	com	r24
    4e54:	81 70       	andi	r24, 0x01	; 1
    4e56:	88 0f       	add	r24, r24
    4e58:	88 0f       	add	r24, r24
    4e5a:	88 0f       	add	r24, r24
    4e5c:	95 b1       	in	r25, 0x05	; 5
    4e5e:	97 7f       	andi	r25, 0xF7	; 247
    4e60:	98 2b       	or	r25, r24
    4e62:	95 b9       	out	0x05, r25	; 5
    4e64:	08 94       	sec
    4e66:	c1 08       	sbc	r12, r1
    4e68:	d1 08       	sbc	r13, r1
		nResult [i]=0;
	}
	
		
		// check: http://www.x-firm.com/?page_id=191
		for (i=0;i<25;++i)
    4e6a:	c1 14       	cp	r12, r1
    4e6c:	d1 04       	cpc	r13, r1
    4e6e:	39 f0       	breq	.+14     	; 0x4e7e <Sensors_Calibrate+0xd6>
    4e70:	4e e0       	ldi	r20, 0x0E	; 14
    4e72:	a4 2e       	mov	r10, r20
    4e74:	41 e0       	ldi	r20, 0x01	; 1
    4e76:	b4 2e       	mov	r11, r20

/*
// Calibrate Sensors and return result in nResult global variable.
*/
void Sensors_Calibrate (void)
{
    4e78:	88 24       	eor	r8, r8
    4e7a:	99 24       	eor	r9, r9
    4e7c:	c5 cf       	rjmp	.-118    	; 0x4e08 <Sensors_Calibrate+0x60>
			}
			_delay_ms(40);
			LED_Orange =~LED_Orange;
		}
	
		LED_Orange = LEDOLD;
    4e7e:	21 70       	andi	r18, 0x01	; 1
    4e80:	22 0f       	add	r18, r18
    4e82:	22 0f       	add	r18, r18
    4e84:	22 0f       	add	r18, r18
    4e86:	85 b1       	in	r24, 0x05	; 5
    4e88:	87 7f       	andi	r24, 0xF7	; 247
    4e8a:	82 2b       	or	r24, r18
    4e8c:	85 b9       	out	0x05, r24	; 5
    4e8e:	0c e8       	ldi	r16, 0x8C	; 140
    4e90:	17 e0       	ldi	r17, 0x07	; 7
	
		for (i=0;i<6;++i)
    4e92:	ee 24       	eor	r14, r14
    4e94:	ff 24       	eor	r15, r15
		{
			Config.Sensor_zero[i]  = (double)nResult[i] /25.0;
    4e96:	f7 01       	movw	r30, r14
    4e98:	ee 0f       	add	r30, r30
    4e9a:	ff 1f       	adc	r31, r31
    4e9c:	ee 55       	subi	r30, 0x5E	; 94
    4e9e:	fa 4f       	sbci	r31, 0xFA	; 250
    4ea0:	60 81       	ld	r22, Z
    4ea2:	71 81       	ldd	r23, Z+1	; 0x01
    4ea4:	80 e0       	ldi	r24, 0x00	; 0
    4ea6:	90 e0       	ldi	r25, 0x00	; 0
    4ea8:	0e 94 34 37 	call	0x6e68	; 0x6e68 <__floatunsisf>
    4eac:	20 e0       	ldi	r18, 0x00	; 0
    4eae:	30 e0       	ldi	r19, 0x00	; 0
    4eb0:	48 ec       	ldi	r20, 0xC8	; 200
    4eb2:	51 e4       	ldi	r21, 0x41	; 65
    4eb4:	0e 94 9b 36 	call	0x6d36	; 0x6d36 <__divsf3>
    4eb8:	f8 01       	movw	r30, r16
    4eba:	61 93       	st	Z+, r22
    4ebc:	71 93       	st	Z+, r23
    4ebe:	81 93       	st	Z+, r24
    4ec0:	91 93       	st	Z+, r25
    4ec2:	8f 01       	movw	r16, r30
			LED_Orange =~LED_Orange;
		}
	
		LED_Orange = LEDOLD;
	
		for (i=0;i<6;++i)
    4ec4:	08 94       	sec
    4ec6:	e1 1c       	adc	r14, r1
    4ec8:	f1 1c       	adc	r15, r1
    4eca:	f6 e0       	ldi	r31, 0x06	; 6
    4ecc:	ef 16       	cp	r14, r31
    4ece:	f1 04       	cpc	r15, r1
    4ed0:	11 f7       	brne	.-60     	; 0x4e96 <Sensors_Calibrate+0xee>
		
	
	
			
	
	Config.IsCalibrated = (Config.IsCalibrated | CALIBRATED_SENSOR);
    4ed2:	80 91 ee 06 	lds	r24, 0x06EE
    4ed6:	84 60       	ori	r24, 0x04	; 4
    4ed8:	80 93 ee 06 	sts	0x06EE, r24
		
	
	//nResult[ACC_Z_Index]-=100; // Sensor: horizontal, upward ... the caller of this function is responsible for updating Config.Sensor_zero[i] = nResult[i];
		
}
    4edc:	0f 90       	pop	r0
    4ede:	cf 91       	pop	r28
    4ee0:	df 91       	pop	r29
    4ee2:	1f 91       	pop	r17
    4ee4:	0f 91       	pop	r16
    4ee6:	ff 90       	pop	r15
    4ee8:	ef 90       	pop	r14
    4eea:	df 90       	pop	r13
    4eec:	cf 90       	pop	r12
    4eee:	bf 90       	pop	r11
    4ef0:	af 90       	pop	r10
    4ef2:	9f 90       	pop	r9
    4ef4:	8f 90       	pop	r8
    4ef6:	08 95       	ret

00004ef8 <Sensor_GetBattery>:
}*/

int16_t  Sensor_GetBattery(void)
{
	 // because the V_BAT is connected to a voltage divider R1 & R2
	return (ADCPort_Get(V_BAT_PNUM) *  BAT_VOLT_RATIO);
    4ef8:	83 e0       	ldi	r24, 0x03	; 3
    4efa:	0e 94 75 28 	call	0x50ea	; 0x50ea <ADCPort_Get>
    4efe:	24 e6       	ldi	r18, 0x64	; 100
    4f00:	30 e0       	ldi	r19, 0x00	; 0
    4f02:	ac 01       	movw	r20, r24
    4f04:	42 9f       	mul	r20, r18
    4f06:	c0 01       	movw	r24, r0
    4f08:	43 9f       	mul	r20, r19
    4f0a:	90 0d       	add	r25, r0
    4f0c:	52 9f       	mul	r21, r18
    4f0e:	90 0d       	add	r25, r0
    4f10:	11 24       	eor	r1, r1
    4f12:	64 e7       	ldi	r22, 0x74	; 116
    4f14:	71 e0       	ldi	r23, 0x01	; 1
    4f16:	0e 94 4d 38 	call	0x709a	; 0x709a <__udivmodhi4>
} 
    4f1a:	cb 01       	movw	r24, r22
    4f1c:	08 95       	ret

00004f1e <Sensors_ReadAll>:

#define DEAD_BAND_GYRO	4
//uint32_t LastLoopTime[2];
//uint16_t TX,TX1,TX2;
void Sensors_ReadAll (void)
{
    4f1e:	6f 92       	push	r6
    4f20:	7f 92       	push	r7
    4f22:	8f 92       	push	r8
    4f24:	9f 92       	push	r9
    4f26:	af 92       	push	r10
    4f28:	bf 92       	push	r11
    4f2a:	cf 92       	push	r12
    4f2c:	df 92       	push	r13
    4f2e:	ef 92       	push	r14
    4f30:	ff 92       	push	r15
    4f32:	0f 93       	push	r16
    4f34:	1f 93       	push	r17
    4f36:	cf 93       	push	r28
    4f38:	df 93       	push	r29
		//TX1= TCNT1;
		//TX= TCNT1_X;
   //}   
	//
	
	for (int i=0;i<3;++i)  // gyro
    4f3a:	0e e0       	ldi	r16, 0x0E	; 14
    4f3c:	11 e0       	ldi	r17, 0x01	; 1
    4f3e:	8c e8       	ldi	r24, 0x8C	; 140
    4f40:	e8 2e       	mov	r14, r24
    4f42:	87 e0       	ldi	r24, 0x07	; 7
    4f44:	f8 2e       	mov	r15, r24
    4f46:	c0 e0       	ldi	r28, 0x00	; 0
    4f48:	d0 e0       	ldi	r29, 0x00	; 0
	{
		Sensors_Latest[i] = ADCPort_Get(SensorsIndex[i])-Config.Sensor_zero[i]; 
		if (abs(Sensors_Latest[i]) <= DEAD_BAND_GYRO) Sensors_Latest[i]=0;
    4f4a:	0f 2e       	mov	r0, r31
    4f4c:	f0 e0       	ldi	r31, 0x00	; 0
    4f4e:	6f 2e       	mov	r6, r31
    4f50:	f0 e0       	ldi	r31, 0x00	; 0
    4f52:	7f 2e       	mov	r7, r31
    4f54:	f0 e0       	ldi	r31, 0x00	; 0
    4f56:	8f 2e       	mov	r8, r31
    4f58:	f0 e0       	ldi	r31, 0x00	; 0
    4f5a:	9f 2e       	mov	r9, r31
    4f5c:	f0 2d       	mov	r31, r0
   //}   
	//
	
	for (int i=0;i<3;++i)  // gyro
	{
		Sensors_Latest[i] = ADCPort_Get(SensorsIndex[i])-Config.Sensor_zero[i]; 
    4f5e:	f8 01       	movw	r30, r16
    4f60:	81 91       	ld	r24, Z+
    4f62:	8f 01       	movw	r16, r30
    4f64:	0e 94 75 28 	call	0x50ea	; 0x50ea <ADCPort_Get>
    4f68:	f7 01       	movw	r30, r14
    4f6a:	a1 90       	ld	r10, Z+
    4f6c:	b1 90       	ld	r11, Z+
    4f6e:	c1 90       	ld	r12, Z+
    4f70:	d1 90       	ld	r13, Z+
    4f72:	7f 01       	movw	r14, r30
    4f74:	bc 01       	movw	r22, r24
    4f76:	80 e0       	ldi	r24, 0x00	; 0
    4f78:	90 e0       	ldi	r25, 0x00	; 0
    4f7a:	0e 94 34 37 	call	0x6e68	; 0x6e68 <__floatunsisf>
    4f7e:	a6 01       	movw	r20, r12
    4f80:	95 01       	movw	r18, r10
    4f82:	0e 94 32 36 	call	0x6c64	; 0x6c64 <__subsf3>
    4f86:	9b 01       	movw	r18, r22
    4f88:	ac 01       	movw	r20, r24
    4f8a:	fe 01       	movw	r30, r28
    4f8c:	ee 0f       	add	r30, r30
    4f8e:	ff 1f       	adc	r31, r31
    4f90:	ee 0f       	add	r30, r30
    4f92:	ff 1f       	adc	r31, r31
    4f94:	e1 5c       	subi	r30, 0xC1	; 193
    4f96:	f9 4f       	sbci	r31, 0xF9	; 249
    4f98:	20 83       	st	Z, r18
    4f9a:	31 83       	std	Z+1, r19	; 0x01
    4f9c:	42 83       	std	Z+2, r20	; 0x02
    4f9e:	53 83       	std	Z+3, r21	; 0x03
		if (abs(Sensors_Latest[i]) <= DEAD_BAND_GYRO) Sensors_Latest[i]=0;
    4fa0:	60 81       	ld	r22, Z
    4fa2:	71 81       	ldd	r23, Z+1	; 0x01
    4fa4:	82 81       	ldd	r24, Z+2	; 0x02
    4fa6:	93 81       	ldd	r25, Z+3	; 0x03
    4fa8:	0e 94 03 37 	call	0x6e06	; 0x6e06 <__fixsfsi>
    4fac:	27 2f       	mov	r18, r23
    4fae:	86 2f       	mov	r24, r22
    4fb0:	92 2f       	mov	r25, r18
    4fb2:	97 ff       	sbrs	r25, 7
    4fb4:	03 c0       	rjmp	.+6      	; 0x4fbc <Sensors_ReadAll+0x9e>
    4fb6:	90 95       	com	r25
    4fb8:	81 95       	neg	r24
    4fba:	9f 4f       	sbci	r25, 0xFF	; 255
    4fbc:	85 30       	cpi	r24, 0x05	; 5
    4fbe:	91 05       	cpc	r25, r1
    4fc0:	5c f4       	brge	.+22     	; 0x4fd8 <Sensors_ReadAll+0xba>
    4fc2:	fe 01       	movw	r30, r28
    4fc4:	ee 0f       	add	r30, r30
    4fc6:	ff 1f       	adc	r31, r31
    4fc8:	ee 0f       	add	r30, r30
    4fca:	ff 1f       	adc	r31, r31
    4fcc:	e1 5c       	subi	r30, 0xC1	; 193
    4fce:	f9 4f       	sbci	r31, 0xF9	; 249
    4fd0:	60 82       	st	Z, r6
    4fd2:	71 82       	std	Z+1, r7	; 0x01
    4fd4:	82 82       	std	Z+2, r8	; 0x02
    4fd6:	93 82       	std	Z+3, r9	; 0x03
		//TX1= TCNT1;
		//TX= TCNT1_X;
   //}   
	//
	
	for (int i=0;i<3;++i)  // gyro
    4fd8:	21 96       	adiw	r28, 0x01	; 1
    4fda:	c3 30       	cpi	r28, 0x03	; 3
    4fdc:	d1 05       	cpc	r29, r1
    4fde:	09 f0       	breq	.+2      	; 0x4fe2 <Sensors_ReadAll+0xc4>
    4fe0:	be cf       	rjmp	.-132    	; 0x4f5e <Sensors_ReadAll+0x40>
    4fe2:	01 e1       	ldi	r16, 0x11	; 17
    4fe4:	11 e0       	ldi	r17, 0x01	; 1
    4fe6:	e8 e9       	ldi	r30, 0x98	; 152
    4fe8:	ee 2e       	mov	r14, r30
    4fea:	e7 e0       	ldi	r30, 0x07	; 7
    4fec:	fe 2e       	mov	r15, r30
    4fee:	c3 e0       	ldi	r28, 0x03	; 3
    4ff0:	d0 e0       	ldi	r29, 0x00	; 0
		if (abs(Sensors_Latest[i]) <= DEAD_BAND_GYRO) Sensors_Latest[i]=0;
	}
	
	for (int i=3;i<6;++i)  //ACC
	{
		Sensors_Latest[i] = ADCPort_Get(SensorsIndex[i])-Config.Sensor_zero[i]; 
    4ff2:	f8 01       	movw	r30, r16
    4ff4:	81 91       	ld	r24, Z+
    4ff6:	8f 01       	movw	r16, r30
    4ff8:	0e 94 75 28 	call	0x50ea	; 0x50ea <ADCPort_Get>
    4ffc:	f7 01       	movw	r30, r14
    4ffe:	a1 90       	ld	r10, Z+
    5000:	b1 90       	ld	r11, Z+
    5002:	c1 90       	ld	r12, Z+
    5004:	d1 90       	ld	r13, Z+
    5006:	7f 01       	movw	r14, r30
    5008:	bc 01       	movw	r22, r24
    500a:	80 e0       	ldi	r24, 0x00	; 0
    500c:	90 e0       	ldi	r25, 0x00	; 0
    500e:	0e 94 34 37 	call	0x6e68	; 0x6e68 <__floatunsisf>
    5012:	a6 01       	movw	r20, r12
    5014:	95 01       	movw	r18, r10
    5016:	0e 94 32 36 	call	0x6c64	; 0x6c64 <__subsf3>
    501a:	9b 01       	movw	r18, r22
    501c:	ac 01       	movw	r20, r24
    501e:	fe 01       	movw	r30, r28
    5020:	ee 0f       	add	r30, r30
    5022:	ff 1f       	adc	r31, r31
    5024:	ee 0f       	add	r30, r30
    5026:	ff 1f       	adc	r31, r31
    5028:	e1 5c       	subi	r30, 0xC1	; 193
    502a:	f9 4f       	sbci	r31, 0xF9	; 249
    502c:	20 83       	st	Z, r18
    502e:	31 83       	std	Z+1, r19	; 0x01
    5030:	42 83       	std	Z+2, r20	; 0x02
    5032:	53 83       	std	Z+3, r21	; 0x03
	{
		Sensors_Latest[i] = ADCPort_Get(SensorsIndex[i])-Config.Sensor_zero[i]; 
		if (abs(Sensors_Latest[i]) <= DEAD_BAND_GYRO) Sensors_Latest[i]=0;
	}
	
	for (int i=3;i<6;++i)  //ACC
    5034:	21 96       	adiw	r28, 0x01	; 1
    5036:	c6 30       	cpi	r28, 0x06	; 6
    5038:	d1 05       	cpc	r29, r1
    503a:	d9 f6       	brne	.-74     	; 0x4ff2 <Sensors_ReadAll+0xd4>
		Sensors_Latest[i] = ADCPort_Get(SensorsIndex[i])-Config.Sensor_zero[i]; 
		//if (abs(Sensors_Latest[i]) <= DEAD_BAND_GYRO) Sensors_Latest[i]=0;
	}
	
	
	Sensors_Latest[V_BAT_Index] = Sensor_GetBattery(); 
    503c:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <Sensor_GetBattery>
    5040:	9c 01       	movw	r18, r24
    5042:	b9 01       	movw	r22, r18
    5044:	88 27       	eor	r24, r24
    5046:	77 fd       	sbrc	r23, 7
    5048:	80 95       	com	r24
    504a:	98 2f       	mov	r25, r24
    504c:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    5050:	ef e3       	ldi	r30, 0x3F	; 63
    5052:	f6 e0       	ldi	r31, 0x06	; 6
    5054:	60 8f       	std	Z+24, r22	; 0x18
    5056:	71 8f       	std	Z+25, r23	; 0x19
    5058:	82 8f       	std	Z+26, r24	; 0x1a
    505a:	93 8f       	std	Z+27, r25	; 0x1b
	//else
	//{
		//Sensors_dt = TX1 - TX2;
	//}
	//TX2=TX1;
}
    505c:	df 91       	pop	r29
    505e:	cf 91       	pop	r28
    5060:	1f 91       	pop	r17
    5062:	0f 91       	pop	r16
    5064:	ff 90       	pop	r15
    5066:	ef 90       	pop	r14
    5068:	df 90       	pop	r13
    506a:	cf 90       	pop	r12
    506c:	bf 90       	pop	r11
    506e:	af 90       	pop	r10
    5070:	9f 90       	pop	r9
    5072:	8f 90       	pop	r8
    5074:	7f 90       	pop	r7
    5076:	6f 90       	pop	r6
    5078:	08 95       	ret

0000507a <__vector_24>:
 * 
 *  8.913kHz on mega128 16MHz 1kHz/channel ??
 ***** I used 20 MHz 13 - 260 us conv average = (260-13)/2 + 13 = 136.5 us = 7.326 KHz
*/
ISR(ADC_vect, ISR_NOBLOCK)
{
    507a:	78 94       	sei
    507c:	1f 92       	push	r1
    507e:	0f 92       	push	r0
    5080:	0f b6       	in	r0, 0x3f	; 63
    5082:	0f 92       	push	r0
    5084:	11 24       	eor	r1, r1
    5086:	2f 93       	push	r18
    5088:	8f 93       	push	r24
    508a:	9f 93       	push	r25
    508c:	ef 93       	push	r30
    508e:	ff 93       	push	r31
	static uint8_t _index;
	ADCValues[_index] = ADC;
    5090:	20 91 37 05 	lds	r18, 0x0537
    5094:	e2 2f       	mov	r30, r18
    5096:	f0 e0       	ldi	r31, 0x00	; 0
    5098:	80 91 78 00 	lds	r24, 0x0078
    509c:	90 91 79 00 	lds	r25, 0x0079
    50a0:	ee 0f       	add	r30, r30
    50a2:	ff 1f       	adc	r31, r31
    50a4:	e6 5c       	subi	r30, 0xC6	; 198
    50a6:	f7 4f       	sbci	r31, 0xF7	; 247
    50a8:	91 83       	std	Z+1, r25	; 0x01
    50aa:	80 83       	st	Z, r24
	_index = (_index + 1) % 8U;
    50ac:	82 2f       	mov	r24, r18
    50ae:	8f 5f       	subi	r24, 0xFF	; 255
    50b0:	87 70       	andi	r24, 0x07	; 7
    50b2:	80 93 37 05 	sts	0x0537, r24
	ADMUX = _index;
    50b6:	80 93 7c 00 	sts	0x007C, r24
	ADCSRA |= _BV(ADSC);
    50ba:	ea e7       	ldi	r30, 0x7A	; 122
    50bc:	f0 e0       	ldi	r31, 0x00	; 0
    50be:	80 81       	ld	r24, Z
    50c0:	80 64       	ori	r24, 0x40	; 64
    50c2:	80 83       	st	Z, r24
	
	
}
    50c4:	ff 91       	pop	r31
    50c6:	ef 91       	pop	r30
    50c8:	9f 91       	pop	r25
    50ca:	8f 91       	pop	r24
    50cc:	2f 91       	pop	r18
    50ce:	0f 90       	pop	r0
    50d0:	0f be       	out	0x3f, r0	; 63
    50d2:	0f 90       	pop	r0
    50d4:	1f 90       	pop	r1
    50d6:	18 95       	reti

000050d8 <ADCPort_Init>:

void ADCPort_Init ()
{
	DIDR0 = 0xFF;	// disable all digital inputs on Port A
    50d8:	8f ef       	ldi	r24, 0xFF	; 255
    50da:	80 93 7e 00 	sts	0x007E, r24
	ADMUX = 0;
    50de:	10 92 7c 00 	sts	0x007C, r1
	ADCSRA = 0b11011111;	// ADEN, ADSC, ADIE, 
    50e2:	8f ed       	ldi	r24, 0xDF	; 223
    50e4:	80 93 7a 00 	sts	0x007A, r24
		
}
    50e8:	08 95       	ret

000050ea <ADCPort_Get>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    50ea:	f8 94       	cli
inline uint16_t ADCPort_Get(uint8_t channel)
{
	uint16_t _t;
	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		_t = ADCValues[channel];
    50ec:	e8 2f       	mov	r30, r24
    50ee:	f0 e0       	ldi	r31, 0x00	; 0
    50f0:	ee 0f       	add	r30, r30
    50f2:	ff 1f       	adc	r31, r31
    50f4:	e6 5c       	subi	r30, 0xC6	; 198
    50f6:	f7 4f       	sbci	r31, 0xF7	; 247
    50f8:	20 81       	ld	r18, Z
    50fa:	31 81       	ldd	r19, Z+1	; 0x01
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    50fc:	78 94       	sei
	}		
	return _t;
    50fe:	c9 01       	movw	r24, r18
    5100:	08 95       	ret

00005102 <_hHomeRestart>:
}


void _hHomeRestart (void)
{
	NOKEYRETURN
    5102:	80 91 be 05 	lds	r24, 0x05BE
    5106:	88 23       	and	r24, r24
    5108:	11 f0       	breq	.+4      	; 0x510e <_hHomeRestart+0xc>
	
	if (KEY4)
    510a:	84 fd       	sbrc	r24, 4
    510c:	ff cf       	rjmp	.-2      	; 0x510c <_hHomeRestart+0xa>
    510e:	08 95       	ret

00005110 <tsmMain>:
	Menu_LoadPage(PAGE_HOME);
}

PGM_P tsmMain(uint8_t index)
{
	return (PGM_P)pgm_read_word(&lstMenu[index]);
    5110:	90 e0       	ldi	r25, 0x00	; 0
    5112:	88 0f       	add	r24, r24
    5114:	99 1f       	adc	r25, r25
    5116:	8b 51       	subi	r24, 0x1B	; 27
    5118:	94 4f       	sbci	r25, 0xF4	; 244
    511a:	fc 01       	movw	r30, r24
    511c:	25 91       	lpm	r18, Z+
    511e:	34 91       	lpm	r19, Z+
}
    5120:	c9 01       	movw	r24, r18
    5122:	08 95       	ret

00005124 <writeSoftkeys>:
		//LCD_WriteString_P(e.text);
	//}
//}

static void writeSoftkeys(const char* sk)
{
    5124:	cf 93       	push	r28
    5126:	df 93       	push	r29
    5128:	ec 01       	movw	r28, r24
	if (!sk)
    512a:	00 97       	sbiw	r24, 0x00	; 0
    512c:	31 f4       	brne	.+12     	; 0x513a <writeSoftkeys+0x16>
		sk = currentPage.softkeys;
    512e:	c0 91 46 05 	lds	r28, 0x0546
    5132:	d0 91 47 05 	lds	r29, 0x0547
	if (sk)
    5136:	20 97       	sbiw	r28, 0x00	; 0
    5138:	39 f0       	breq	.+14     	; 0x5148 <writeSoftkeys+0x24>
	{
		LCD_SetPos(7, 0);
    513a:	87 e0       	ldi	r24, 0x07	; 7
    513c:	60 e0       	ldi	r22, 0x00	; 0
    513e:	0e 94 10 0c 	call	0x1820	; 0x1820 <LCD_SetPos>
		LCD_WriteString_P(sk);
    5142:	ce 01       	movw	r24, r28
    5144:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <LCD_WriteString_P>
	}
}
    5148:	df 91       	pop	r29
    514a:	cf 91       	pop	r28
    514c:	08 95       	ret

0000514e <_hDebug>:

	static double YAWAngle;
static double OldAngle;
	static double YAWAngle2;
void _hDebug()
{
    514e:	cf 92       	push	r12
    5150:	df 92       	push	r13
    5152:	ef 92       	push	r14
    5154:	ff 92       	push	r15
    5156:	0f 93       	push	r16
    5158:	1f 93       	push	r17
    515a:	cf 93       	push	r28
    515c:	df 93       	push	r29

	if (IS_INIT)
    515e:	80 91 be 05 	lds	r24, 0x05BE
    5162:	80 fd       	sbrc	r24, 0
    5164:	b0 c0       	rjmp	.+352    	; 0x52c6 <_hDebug+0x178>
			//send_byte(0x01);
			//send_byte(0x01);send_byte(0x00);send_byte(0x00);send_byte(0x00);
			//send_byte(98);
	
		}
		if (KEY3)
    5166:	85 ff       	sbrs	r24, 5
    5168:	1b c0       	rjmp	.+54     	; 0x51a0 <_hDebug+0x52>
		{
			//gyroZangle=0;
			//gyroYangle=0;
			//gyroXangle=0;
			AnglePitch=0;
    516a:	80 e0       	ldi	r24, 0x00	; 0
    516c:	90 e0       	ldi	r25, 0x00	; 0
    516e:	dc 01       	movw	r26, r24
    5170:	80 93 1a 06 	sts	0x061A, r24
    5174:	90 93 1b 06 	sts	0x061B, r25
    5178:	a0 93 1c 06 	sts	0x061C, r26
    517c:	b0 93 1d 06 	sts	0x061D, r27
			AngleRoll=0;
    5180:	80 93 e2 06 	sts	0x06E2, r24
    5184:	90 93 e3 06 	sts	0x06E3, r25
    5188:	a0 93 e4 06 	sts	0x06E4, r26
    518c:	b0 93 e5 06 	sts	0x06E5, r27
			AngleZ =0;
    5190:	80 93 70 06 	sts	0x0670, r24
    5194:	90 93 71 06 	sts	0x0671, r25
    5198:	a0 93 72 06 	sts	0x0672, r26
    519c:	b0 93 73 06 	sts	0x0673, r27
		}	
		static double lastGyro=0;
		static double maxdiff=0;
		LCD_SetPos(0, 18);
    51a0:	80 e0       	ldi	r24, 0x00	; 0
    51a2:	62 e1       	ldi	r22, 0x12	; 18
    51a4:	0e 94 10 0c 	call	0x1820	; 0x1820 <LCD_SetPos>
		LCD_WriteString_P(PSTR("Meas"));
    51a8:	8b e0       	ldi	r24, 0x0B	; 11
    51aa:	9c e0       	ldi	r25, 0x0C	; 12
    51ac:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <LCD_WriteString_P>
		LCD_WriteValue_double_ex(1,48, AnglePitch,9,false);
    51b0:	20 91 1a 06 	lds	r18, 0x061A
    51b4:	30 91 1b 06 	lds	r19, 0x061B
    51b8:	40 91 1c 06 	lds	r20, 0x061C
    51bc:	50 91 1d 06 	lds	r21, 0x061D
    51c0:	81 e0       	ldi	r24, 0x01	; 1
    51c2:	60 e3       	ldi	r22, 0x30	; 48
    51c4:	09 e0       	ldi	r16, 0x09	; 9
    51c6:	ee 24       	eor	r14, r14
    51c8:	0e 94 ba 0d 	call	0x1b74	; 0x1b74 <LCD_WriteValue_double_ex>
		LCD_WriteValue_double_ex(2,48, AngleRoll,9,false);
    51cc:	20 91 e2 06 	lds	r18, 0x06E2
    51d0:	30 91 e3 06 	lds	r19, 0x06E3
    51d4:	40 91 e4 06 	lds	r20, 0x06E4
    51d8:	50 91 e5 06 	lds	r21, 0x06E5
    51dc:	82 e0       	ldi	r24, 0x02	; 2
    51de:	60 e3       	ldi	r22, 0x30	; 48
    51e0:	0e 94 ba 0d 	call	0x1b74	; 0x1b74 <LCD_WriteValue_double_ex>
		LCD_WriteValue_double_ex(3,48, AngleZ,9,false);
    51e4:	20 91 70 06 	lds	r18, 0x0670
    51e8:	30 91 71 06 	lds	r19, 0x0671
    51ec:	40 91 72 06 	lds	r20, 0x0672
    51f0:	50 91 73 06 	lds	r21, 0x0673
    51f4:	83 e0       	ldi	r24, 0x03	; 3
    51f6:	60 e3       	ldi	r22, 0x30	; 48
    51f8:	0e 94 ba 0d 	call	0x1b74	; 0x1b74 <LCD_WriteValue_double_ex>
		LCD_WriteValue_double_ex(4,48, NavX,9,false);
    51fc:	20 91 4c 05 	lds	r18, 0x054C
    5200:	30 91 4d 05 	lds	r19, 0x054D
    5204:	40 91 4e 05 	lds	r20, 0x054E
    5208:	50 91 4f 05 	lds	r21, 0x054F
    520c:	84 e0       	ldi	r24, 0x04	; 4
    520e:	60 e3       	ldi	r22, 0x30	; 48
    5210:	0e 94 ba 0d 	call	0x1b74	; 0x1b74 <LCD_WriteValue_double_ex>
		lastGyro = Sensors_Latest[GYRO_ROLL_Index];
    5214:	e0 90 3f 06 	lds	r14, 0x063F
    5218:	f0 90 40 06 	lds	r15, 0x0640
    521c:	00 91 41 06 	lds	r16, 0x0641
    5220:	10 91 42 06 	lds	r17, 0x0642
    5224:	e0 92 42 05 	sts	0x0542, r14
    5228:	f0 92 43 05 	sts	0x0543, r15
    522c:	00 93 44 05 	sts	0x0544, r16
    5230:	10 93 45 05 	sts	0x0545, r17
		if (abs(maxdiff) < abs(lastGyro)) maxdiff = lastGyro;
    5234:	60 91 3e 05 	lds	r22, 0x053E
    5238:	70 91 3f 05 	lds	r23, 0x053F
    523c:	80 91 40 05 	lds	r24, 0x0540
    5240:	90 91 41 05 	lds	r25, 0x0541
    5244:	0e 94 03 37 	call	0x6e06	; 0x6e06 <__fixsfsi>
    5248:	c6 2e       	mov	r12, r22
    524a:	e6 01       	movw	r28, r12
    524c:	6e 01       	movw	r12, r28
    524e:	d7 2e       	mov	r13, r23
    5250:	e6 01       	movw	r28, r12
    5252:	d7 fe       	sbrs	r13, 7
    5254:	03 c0       	rjmp	.+6      	; 0x525c <_hDebug+0x10e>
    5256:	d0 95       	com	r29
    5258:	c1 95       	neg	r28
    525a:	df 4f       	sbci	r29, 0xFF	; 255
    525c:	c8 01       	movw	r24, r16
    525e:	b7 01       	movw	r22, r14
    5260:	0e 94 03 37 	call	0x6e06	; 0x6e06 <__fixsfsi>
    5264:	27 2f       	mov	r18, r23
    5266:	86 2f       	mov	r24, r22
    5268:	92 2f       	mov	r25, r18
    526a:	97 ff       	sbrs	r25, 7
    526c:	03 c0       	rjmp	.+6      	; 0x5274 <_hDebug+0x126>
    526e:	90 95       	com	r25
    5270:	81 95       	neg	r24
    5272:	9f 4f       	sbci	r25, 0xFF	; 255
    5274:	c8 17       	cp	r28, r24
    5276:	d9 07       	cpc	r29, r25
    5278:	44 f4       	brge	.+16     	; 0x528a <_hDebug+0x13c>
    527a:	e0 92 3e 05 	sts	0x053E, r14
    527e:	f0 92 3f 05 	sts	0x053F, r15
    5282:	00 93 40 05 	sts	0x0540, r16
    5286:	10 93 41 05 	sts	0x0541, r17
		LCD_WriteValue_double_ex(5,48,maxdiff,9,true);
    528a:	20 91 3e 05 	lds	r18, 0x053E
    528e:	30 91 3f 05 	lds	r19, 0x053F
    5292:	40 91 40 05 	lds	r20, 0x0540
    5296:	50 91 41 05 	lds	r21, 0x0541
    529a:	85 e0       	ldi	r24, 0x05	; 5
    529c:	60 e3       	ldi	r22, 0x30	; 48
    529e:	09 e0       	ldi	r16, 0x09	; 9
    52a0:	ee 24       	eor	r14, r14
    52a2:	e3 94       	inc	r14
    52a4:	0e 94 ba 0d 	call	0x1b74	; 0x1b74 <LCD_WriteValue_double_ex>
		LCD_WriteValue_double_ex(6,48,TimeDef,9,false);
    52a8:	60 91 e6 06 	lds	r22, 0x06E6
    52ac:	70 91 e7 06 	lds	r23, 0x06E7
    52b0:	80 e0       	ldi	r24, 0x00	; 0
    52b2:	90 e0       	ldi	r25, 0x00	; 0
    52b4:	0e 94 34 37 	call	0x6e68	; 0x6e68 <__floatunsisf>
    52b8:	9b 01       	movw	r18, r22
    52ba:	ac 01       	movw	r20, r24
    52bc:	86 e0       	ldi	r24, 0x06	; 6
    52be:	60 e3       	ldi	r22, 0x30	; 48
    52c0:	ee 24       	eor	r14, r14
    52c2:	0e 94 ba 0d 	call	0x1b74	; 0x1b74 <LCD_WriteValue_double_ex>
		
		//LCD_WriteValue(4,48, MotorOut[3],9,false);
	}
}
    52c6:	df 91       	pop	r29
    52c8:	cf 91       	pop	r28
    52ca:	1f 91       	pop	r17
    52cc:	0f 91       	pop	r16
    52ce:	ff 90       	pop	r15
    52d0:	ef 90       	pop	r14
    52d2:	df 90       	pop	r13
    52d4:	cf 90       	pop	r12
    52d6:	08 95       	ret

000052d8 <_hSensorCalibration>:

	_helper_DisplayRXStatus(6);
}

void _hSensorCalibration()
{
    52d8:	ef 92       	push	r14
    52da:	0f 93       	push	r16
    52dc:	1f 93       	push	r17
    52de:	cf 93       	push	r28
    52e0:	df 93       	push	r29
	NOKEYRETURN;
    52e2:	80 91 be 05 	lds	r24, 0x05BE
    52e6:	88 23       	and	r24, r24
    52e8:	79 f1       	breq	.+94     	; 0x5348 <_hSensorCalibration+0x70>
	uint8_t i;
		
	if (KEY4)
    52ea:	84 ff       	sbrs	r24, 4
    52ec:	19 c0       	rjmp	.+50     	; 0x5320 <_hSensorCalibration+0x48>
    52ee:	15 e0       	ldi	r17, 0x05	; 5
	{
		// Delay to allow not touching the board.		
		for (i=0; i<5;++i)
		{
			LED_FlashOrangeLED (200,2);
    52f0:	88 ec       	ldi	r24, 0xC8	; 200
    52f2:	90 e0       	ldi	r25, 0x00	; 0
    52f4:	62 e0       	ldi	r22, 0x02	; 2
    52f6:	0e 94 9b 0e 	call	0x1d36	; 0x1d36 <LED_FlashOrangeLED>
			Beeper_Beep(BEEP_SHORT,1);
    52fa:	86 e4       	ldi	r24, 0x46	; 70
    52fc:	90 e0       	ldi	r25, 0x00	; 0
    52fe:	61 e0       	ldi	r22, 0x01	; 1
    5300:	0e 94 99 0b 	call	0x1732	; 0x1732 <Beeper_Beep>
    5304:	11 50       	subi	r17, 0x01	; 1
	uint8_t i;
		
	if (KEY4)
	{
		// Delay to allow not touching the board.		
		for (i=0; i<5;++i)
    5306:	a1 f7       	brne	.-24     	; 0x52f0 <_hSensorCalibration+0x18>
		{
			LED_FlashOrangeLED (200,2);
			Beeper_Beep(BEEP_SHORT,1);
		}
	
		Sensors_Calibrate ();
    5308:	0e 94 d4 26 	call	0x4da8	; 0x4da8 <Sensors_Calibrate>
		
		Save_Config_to_EEPROM();
    530c:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <Save_Config_to_EEPROM>
		currentPage.softkeys = _skBACK;
    5310:	8c ee       	ldi	r24, 0xEC	; 236
    5312:	9c e0       	ldi	r25, 0x0C	; 12
    5314:	90 93 47 05 	sts	0x0547, r25
    5318:	80 93 46 05 	sts	0x0546, r24
		writeSoftkeys(currentPage.softkeys);
    531c:	0e 94 92 28 	call	0x5124	; 0x5124 <writeSoftkeys>
    5320:	cc e8       	ldi	r28, 0x8C	; 140
    5322:	d7 e0       	ldi	r29, 0x07	; 7
void _hSensorCalibration()
{
	NOKEYRETURN;
	uint8_t i;
		
	if (KEY4)
    5324:	10 e0       	ldi	r17, 0x00	; 0
	}
	
	
	for (i=0; i<6;++i)
	{ // order is aligned with ACC_PITCH_Index & GYRO_ROLL_Index
		LCD_SetPos(i, 48);
    5326:	81 2f       	mov	r24, r17
    5328:	60 e3       	ldi	r22, 0x30	; 48
    532a:	0e 94 10 0c 	call	0x1820	; 0x1820 <LCD_SetPos>
		LCD_WriteValue_double_ex(i,48,Config.Sensor_zero[i],9,false);
    532e:	29 91       	ld	r18, Y+
    5330:	39 91       	ld	r19, Y+
    5332:	49 91       	ld	r20, Y+
    5334:	59 91       	ld	r21, Y+
    5336:	81 2f       	mov	r24, r17
    5338:	60 e3       	ldi	r22, 0x30	; 48
    533a:	09 e0       	ldi	r16, 0x09	; 9
    533c:	ee 24       	eor	r14, r14
    533e:	0e 94 ba 0d 	call	0x1b74	; 0x1b74 <LCD_WriteValue_double_ex>
		currentPage.softkeys = _skBACK;
		writeSoftkeys(currentPage.softkeys);
	}
	
	
	for (i=0; i<6;++i)
    5342:	1f 5f       	subi	r17, 0xFF	; 255
    5344:	16 30       	cpi	r17, 0x06	; 6
    5346:	79 f7       	brne	.-34     	; 0x5326 <_hSensorCalibration+0x4e>
	{ // order is aligned with ACC_PITCH_Index & GYRO_ROLL_Index
		LCD_SetPos(i, 48);
		LCD_WriteValue_double_ex(i,48,Config.Sensor_zero[i],9,false);
	}	
	
}
    5348:	df 91       	pop	r29
    534a:	cf 91       	pop	r28
    534c:	1f 91       	pop	r17
    534e:	0f 91       	pop	r16
    5350:	ef 90       	pop	r14
    5352:	08 95       	ret

00005354 <_hSensorTest>:
	}
}


void _hSensorTest()
{
    5354:	0f 93       	push	r16
    5356:	1f 93       	push	r17
    5358:	cf 93       	push	r28
    535a:	df 93       	push	r29
	#define AccLowLimit			450
	#define AccHighLimit		850
	#define GyroLowLimit		450 //500		
	#define GyroHighLimit		850 //630
	
	for (int i=0; i<6;++i)
    535c:	05 e1       	ldi	r16, 0x15	; 21
    535e:	11 e0       	ldi	r17, 0x01	; 1
    5360:	c0 e0       	ldi	r28, 0x00	; 0
    5362:	d0 e0       	ldi	r29, 0x00	; 0
	{
		LCD_SetPos(i, 48);
    5364:	8c 2f       	mov	r24, r28
    5366:	60 e3       	ldi	r22, 0x30	; 48
    5368:	0e 94 10 0c 	call	0x1820	; 0x1820 <LCD_SetPos>
		LCD_WriteString(Sensors_Test(SensorsIndex[i],GyroLowLimit,GyroHighLimit));
    536c:	f8 01       	movw	r30, r16
    536e:	81 91       	ld	r24, Z+
    5370:	8f 01       	movw	r16, r30
    5372:	62 ec       	ldi	r22, 0xC2	; 194
    5374:	71 e0       	ldi	r23, 0x01	; 1
    5376:	42 e5       	ldi	r20, 0x52	; 82
    5378:	53 e0       	ldi	r21, 0x03	; 3
    537a:	0e 94 9c 26 	call	0x4d38	; 0x4d38 <Sensors_Test>
    537e:	0e 94 f9 0c 	call	0x19f2	; 0x19f2 <LCD_WriteString>
	#define AccLowLimit			450
	#define AccHighLimit		850
	#define GyroLowLimit		450 //500		
	#define GyroHighLimit		850 //630
	
	for (int i=0; i<6;++i)
    5382:	21 96       	adiw	r28, 0x01	; 1
    5384:	c6 30       	cpi	r28, 0x06	; 6
    5386:	d1 05       	cpc	r29, r1
    5388:	69 f7       	brne	.-38     	; 0x5364 <_hSensorTest+0x10>
	//LCD_WriteString(Sensors_Test(ACC_ROLL_PNUM,AccLowLimit,AccHighLimit));
	//LCD_SetPos(5, 48);
	//LCD_WriteString(Sensors_Test(ACC_Z_PNUM,AccLowLimit,AccHighLimit));
	//LCD_SetPos(6, 48);
	//LCD_WriteValue_double(6,48,Sensor_GetBattery(),false);
}
    538a:	df 91       	pop	r29
    538c:	cf 91       	pop	r28
    538e:	1f 91       	pop	r17
    5390:	0f 91       	pop	r16
    5392:	08 95       	ret

00005394 <_hHomeArmedESC>:


void _hHomeArmedESC (void)
{
	
	if (IS_INIT)	
    5394:	80 91 be 05 	lds	r24, 0x05BE
    5398:	80 ff       	sbrs	r24, 0
    539a:	10 c0       	rjmp	.+32     	; 0x53bc <_hHomeArmedESC+0x28>
	{
		LCD_SelectFont (&font12x16);
    539c:	89 e5       	ldi	r24, 0x59	; 89
    539e:	91 e0       	ldi	r25, 0x01	; 1
    53a0:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <LCD_SelectFont>
		LCD_SetPos(0,0);
    53a4:	80 e0       	ldi	r24, 0x00	; 0
    53a6:	60 e0       	ldi	r22, 0x00	; 0
    53a8:	0e 94 10 0c 	call	0x1820	; 0x1820 <LCD_SetPos>
		LCD_WriteString_P(strARMED);
    53ac:	80 e1       	ldi	r24, 0x10	; 16
    53ae:	9d e0       	ldi	r25, 0x0D	; 13
    53b0:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <LCD_WriteString_P>
		LCD_SelectFont (NULL);
    53b4:	80 e0       	ldi	r24, 0x00	; 0
    53b6:	90 e0       	ldi	r25, 0x00	; 0
    53b8:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <LCD_SelectFont>
	}
	
	if (KEY4)
    53bc:	80 91 be 05 	lds	r24, 0x05BE
    53c0:	84 ff       	sbrs	r24, 4
    53c2:	04 c0       	rjmp	.+8      	; 0x53cc <_hHomeArmedESC+0x38>
	{
		//reset ESC Calibration mode.
		Config.IsESCCalibration=ESCCalibration_OFF;
    53c4:	10 92 f3 06 	sts	0x06F3, r1
		Save_Config_to_EEPROM();
    53c8:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <Save_Config_to_EEPROM>
	}
	
	LCD_SetPos(3,18);
    53cc:	83 e0       	ldi	r24, 0x03	; 3
    53ce:	62 e1       	ldi	r22, 0x12	; 18
    53d0:	0e 94 10 0c 	call	0x1820	; 0x1820 <LCD_SetPos>
	itoa(MotorOut[0],sXDeg,10);
    53d4:	80 91 9a 05 	lds	r24, 0x059A
    53d8:	90 91 9b 05 	lds	r25, 0x059B
    53dc:	6e ee       	ldi	r22, 0xEE	; 238
    53de:	75 e0       	ldi	r23, 0x05	; 5
    53e0:	4a e0       	ldi	r20, 0x0A	; 10
    53e2:	50 e0       	ldi	r21, 0x00	; 0
    53e4:	0e 94 cc 38 	call	0x7198	; 0x7198 <itoa>
	LCD_WritePadded(sXDeg,5);
    53e8:	8e ee       	ldi	r24, 0xEE	; 238
    53ea:	95 e0       	ldi	r25, 0x05	; 5
    53ec:	65 e0       	ldi	r22, 0x05	; 5
    53ee:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <LCD_WritePadded>
	
	LCD_SetPos(3,78);
    53f2:	83 e0       	ldi	r24, 0x03	; 3
    53f4:	6e e4       	ldi	r22, 0x4E	; 78
    53f6:	0e 94 10 0c 	call	0x1820	; 0x1820 <LCD_SetPos>
	itoa(MotorOut[3],sXDeg,10);
    53fa:	80 91 a0 05 	lds	r24, 0x05A0
    53fe:	90 91 a1 05 	lds	r25, 0x05A1
    5402:	6e ee       	ldi	r22, 0xEE	; 238
    5404:	75 e0       	ldi	r23, 0x05	; 5
    5406:	4a e0       	ldi	r20, 0x0A	; 10
    5408:	50 e0       	ldi	r21, 0x00	; 0
    540a:	0e 94 cc 38 	call	0x7198	; 0x7198 <itoa>
	LCD_WritePadded(sXDeg,5);
    540e:	8e ee       	ldi	r24, 0xEE	; 238
    5410:	95 e0       	ldi	r25, 0x05	; 5
    5412:	65 e0       	ldi	r22, 0x05	; 5
    5414:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <LCD_WritePadded>
	
	LCD_SetPos(4,18);
    5418:	84 e0       	ldi	r24, 0x04	; 4
    541a:	62 e1       	ldi	r22, 0x12	; 18
    541c:	0e 94 10 0c 	call	0x1820	; 0x1820 <LCD_SetPos>
	itoa(MotorOut[1],sXDeg,10);
    5420:	80 91 9c 05 	lds	r24, 0x059C
    5424:	90 91 9d 05 	lds	r25, 0x059D
    5428:	6e ee       	ldi	r22, 0xEE	; 238
    542a:	75 e0       	ldi	r23, 0x05	; 5
    542c:	4a e0       	ldi	r20, 0x0A	; 10
    542e:	50 e0       	ldi	r21, 0x00	; 0
    5430:	0e 94 cc 38 	call	0x7198	; 0x7198 <itoa>
	LCD_WritePadded(sXDeg,5);
    5434:	8e ee       	ldi	r24, 0xEE	; 238
    5436:	95 e0       	ldi	r25, 0x05	; 5
    5438:	65 e0       	ldi	r22, 0x05	; 5
    543a:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <LCD_WritePadded>
	
	LCD_SetPos(4,78);
    543e:	84 e0       	ldi	r24, 0x04	; 4
    5440:	6e e4       	ldi	r22, 0x4E	; 78
    5442:	0e 94 10 0c 	call	0x1820	; 0x1820 <LCD_SetPos>
	itoa(MotorOut[2],sXDeg,10);
    5446:	80 91 9e 05 	lds	r24, 0x059E
    544a:	90 91 9f 05 	lds	r25, 0x059F
    544e:	6e ee       	ldi	r22, 0xEE	; 238
    5450:	75 e0       	ldi	r23, 0x05	; 5
    5452:	4a e0       	ldi	r20, 0x0A	; 10
    5454:	50 e0       	ldi	r21, 0x00	; 0
    5456:	0e 94 cc 38 	call	0x7198	; 0x7198 <itoa>
	LCD_WritePadded(sXDeg,5);
    545a:	8e ee       	ldi	r24, 0xEE	; 238
    545c:	95 e0       	ldi	r25, 0x05	; 5
    545e:	65 e0       	ldi	r22, 0x05	; 5
    5460:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <LCD_WritePadded>
	
}
    5464:	08 95       	ret

00005466 <_helper_DisplayPitchRollYaw>:
	};
//////////////////////////////////////////////////////////////////////////

void _helper_DisplayPitchRollYaw (const uint8_t subindex)
{
	switch (subindex)
    5466:	81 30       	cpi	r24, 0x01	; 1
    5468:	99 f0       	breq	.+38     	; 0x5490 <_helper_DisplayPitchRollYaw+0x2a>
    546a:	81 30       	cpi	r24, 0x01	; 1
    546c:	18 f0       	brcs	.+6      	; 0x5474 <_helper_DisplayPitchRollYaw+0xe>
    546e:	82 30       	cpi	r24, 0x02	; 2
    5470:	e1 f4       	brne	.+56     	; 0x54aa <_helper_DisplayPitchRollYaw+0x44>
    5472:	15 c0       	rjmp	.+42     	; 0x549e <_helper_DisplayPitchRollYaw+0x38>
	{
		case 0:	
			if (Config.PitchRollLinked==0)
    5474:	80 91 b3 07 	lds	r24, 0x07B3
    5478:	88 23       	and	r24, r24
    547a:	29 f4       	brne	.+10     	; 0x5486 <_helper_DisplayPitchRollYaw+0x20>
			{				   
				strcpy_P(sXDeg,PSTR("Pitch        "));
    547c:	8e ee       	ldi	r24, 0xEE	; 238
    547e:	95 e0       	ldi	r25, 0x05	; 5
    5480:	6b ef       	ldi	r22, 0xFB	; 251
    5482:	7d e0       	ldi	r23, 0x0D	; 13
    5484:	09 c0       	rjmp	.+18     	; 0x5498 <_helper_DisplayPitchRollYaw+0x32>
			}
			else
			{
				strcpy_P(sXDeg,PSTR("Pitch & Roll "));
    5486:	8e ee       	ldi	r24, 0xEE	; 238
    5488:	95 e0       	ldi	r25, 0x05	; 5
    548a:	6d ee       	ldi	r22, 0xED	; 237
    548c:	7d e0       	ldi	r23, 0x0D	; 13
    548e:	04 c0       	rjmp	.+8      	; 0x5498 <_helper_DisplayPitchRollYaw+0x32>
			}
			break;
		case 1:	
				strcpy_P(sXDeg,PSTR("Roll         "));
    5490:	8e ee       	ldi	r24, 0xEE	; 238
    5492:	95 e0       	ldi	r25, 0x05	; 5
    5494:	6f ed       	ldi	r22, 0xDF	; 223
    5496:	7d e0       	ldi	r23, 0x0D	; 13
    5498:	0e 94 a8 38 	call	0x7150	; 0x7150 <strcpy_P>
			break;
    549c:	08 95       	ret
		case 2:	
				strcpy_P(sXDeg,PSTR("YAW          "));
    549e:	8e ee       	ldi	r24, 0xEE	; 238
    54a0:	95 e0       	ldi	r25, 0x05	; 5
    54a2:	61 ed       	ldi	r22, 0xD1	; 209
    54a4:	7d e0       	ldi	r23, 0x0D	; 13
    54a6:	0e 94 a8 38 	call	0x7150	; 0x7150 <strcpy_P>
    54aa:	08 95       	ret

000054ac <_helper_SwitchPitchRollYaw>:
			break;
	}
}

void _helper_SwitchPitchRollYaw (uint8_t *subindex)
{
    54ac:	fc 01       	movw	r30, r24
	switch (subindex[0])
    54ae:	80 81       	ld	r24, Z
    54b0:	81 30       	cpi	r24, 0x01	; 1
    54b2:	59 f0       	breq	.+22     	; 0x54ca <_helper_SwitchPitchRollYaw+0x1e>
    54b4:	81 30       	cpi	r24, 0x01	; 1
    54b6:	18 f0       	brcs	.+6      	; 0x54be <_helper_SwitchPitchRollYaw+0x12>
    54b8:	82 30       	cpi	r24, 0x02	; 2
    54ba:	59 f4       	brne	.+22     	; 0x54d2 <_helper_SwitchPitchRollYaw+0x26>
    54bc:	09 c0       	rjmp	.+18     	; 0x54d0 <_helper_SwitchPitchRollYaw+0x24>
	{
		case 0:	if (Config.PitchRollLinked==0) subindex[0]=1; else subindex[0]=2;
    54be:	80 91 b3 07 	lds	r24, 0x07B3
    54c2:	88 23       	and	r24, r24
    54c4:	11 f4       	brne	.+4      	; 0x54ca <_helper_SwitchPitchRollYaw+0x1e>
    54c6:	81 e0       	ldi	r24, 0x01	; 1
    54c8:	01 c0       	rjmp	.+2      	; 0x54cc <_helper_SwitchPitchRollYaw+0x20>
		break;
		case 1:	subindex[0] +=1;
    54ca:	82 e0       	ldi	r24, 0x02	; 2
    54cc:	80 83       	st	Z, r24
		break;
    54ce:	08 95       	ret
		case 2: subindex[0]=0;
    54d0:	10 82       	st	Z, r1
    54d2:	08 95       	ret

000054d4 <_helper_DisplayBiStateText>:

	return;	
}	

void _helper_DisplayBiStateText(const uint8_t Row, const uint8_t Col, PGM_P strTrue, PGM_P strFalse, const bool Condition, const BOOL LCDReverse )
{
    54d4:	af 92       	push	r10
    54d6:	bf 92       	push	r11
    54d8:	cf 92       	push	r12
    54da:	df 92       	push	r13
    54dc:	ef 92       	push	r14
    54de:	0f 93       	push	r16
    54e0:	1f 93       	push	r17
    54e2:	df 93       	push	r29
    54e4:	cf 93       	push	r28
    54e6:	0f 92       	push	r0
    54e8:	cd b7       	in	r28, 0x3d	; 61
    54ea:	de b7       	in	r29, 0x3e	; 62
    54ec:	18 2f       	mov	r17, r24
    54ee:	6a 01       	movw	r12, r20
    54f0:	59 01       	movw	r10, r18
    54f2:	8e 2d       	mov	r24, r14
		lcdReverse(LCDReverse);
    54f4:	69 83       	std	Y+1, r22	; 0x01
    54f6:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <lcdReverse>
		LCD_SetPos(Row, Col);
    54fa:	81 2f       	mov	r24, r17
    54fc:	69 81       	ldd	r22, Y+1	; 0x01
    54fe:	0e 94 10 0c 	call	0x1820	; 0x1820 <LCD_SetPos>
		if (Condition==true) 
    5502:	00 23       	and	r16, r16
    5504:	11 f0       	breq	.+4      	; 0x550a <_helper_DisplayBiStateText+0x36>
		{
			LCD_WriteString_P(strTrue);
    5506:	c6 01       	movw	r24, r12
    5508:	01 c0       	rjmp	.+2      	; 0x550c <_helper_DisplayBiStateText+0x38>
		}
		else
		{
			LCD_WriteString_P(strFalse);
    550a:	c5 01       	movw	r24, r10
    550c:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <LCD_WriteString_P>
		}	
		lcdReverse(false);
    5510:	80 e0       	ldi	r24, 0x00	; 0
    5512:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <lcdReverse>
}
    5516:	0f 90       	pop	r0
    5518:	cf 91       	pop	r28
    551a:	df 91       	pop	r29
    551c:	1f 91       	pop	r17
    551e:	0f 91       	pop	r16
    5520:	ef 90       	pop	r14
    5522:	df 90       	pop	r13
    5524:	cf 90       	pop	r12
    5526:	bf 90       	pop	r11
    5528:	af 90       	pop	r10
    552a:	08 95       	ret

0000552c <_helper_SaveinEEPROM_ifChanged>:


void _helper_SaveinEEPROM_ifChanged()
{
	if (bValueChanged==true)
    552c:	80 91 38 05 	lds	r24, 0x0538
    5530:	81 30       	cpi	r24, 0x01	; 1
    5532:	21 f4       	brne	.+8      	; 0x553c <_helper_SaveinEEPROM_ifChanged+0x10>
		{
			Save_Config_to_EEPROM();
    5534:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <Save_Config_to_EEPROM>
			bValueChanged = false;
    5538:	10 92 38 05 	sts	0x0538, r1
    553c:	08 95       	ret

0000553e <_helper_DisplayRXStatus>:
			return ;
	}
}

void _helper_DisplayRXStatus(const uint8_t Row)
{
    553e:	ef 92       	push	r14
    5540:	0f 93       	push	r16
    5542:	1f 93       	push	r17
    5544:	18 2f       	mov	r17, r24
	// Write RX Status
	// FIX: highlighted is the selected one.
	_helper_DisplayBiStateText(Row,18,str1,strX,IS_TX1_GOOD,(ActiveRXIndex!=1));
    5546:	20 91 ff 07 	lds	r18, 0x07FF
    554a:	80 91 ce 05 	lds	r24, 0x05CE
    554e:	30 e0       	ldi	r19, 0x00	; 0
    5550:	2f 70       	andi	r18, 0x0F	; 15
    5552:	30 70       	andi	r19, 0x00	; 0
    5554:	01 e0       	ldi	r16, 0x01	; 1
    5556:	21 15       	cp	r18, r1
    5558:	31 05       	cpc	r19, r1
    555a:	09 f0       	breq	.+2      	; 0x555e <_helper_DisplayRXStatus+0x20>
    555c:	00 e0       	ldi	r16, 0x00	; 0
    555e:	91 e0       	ldi	r25, 0x01	; 1
    5560:	81 30       	cpi	r24, 0x01	; 1
    5562:	09 f4       	brne	.+2      	; 0x5566 <_helper_DisplayRXStatus+0x28>
    5564:	90 e0       	ldi	r25, 0x00	; 0
    5566:	81 2f       	mov	r24, r17
    5568:	62 e1       	ldi	r22, 0x12	; 18
    556a:	4e e2       	ldi	r20, 0x2E	; 46
    556c:	5d e0       	ldi	r21, 0x0D	; 13
    556e:	20 e3       	ldi	r18, 0x30	; 48
    5570:	3d e0       	ldi	r19, 0x0D	; 13
    5572:	e9 2e       	mov	r14, r25
    5574:	0e 94 6a 2a 	call	0x54d4	; 0x54d4 <_helper_DisplayBiStateText>
	
	_helper_DisplayBiStateText(Row,30,str2,strX,IS_TX2_GOOD,(ActiveRXIndex!=0));
    5578:	80 91 ff 07 	lds	r24, 0x07FF
    557c:	20 91 ce 05 	lds	r18, 0x05CE
    5580:	80 7f       	andi	r24, 0xF0	; 240
    5582:	01 e0       	ldi	r16, 0x01	; 1
    5584:	09 f0       	breq	.+2      	; 0x5588 <_helper_DisplayRXStatus+0x4a>
    5586:	00 e0       	ldi	r16, 0x00	; 0
    5588:	91 e0       	ldi	r25, 0x01	; 1
    558a:	22 23       	and	r18, r18
    558c:	09 f4       	brne	.+2      	; 0x5590 <_helper_DisplayRXStatus+0x52>
    558e:	90 e0       	ldi	r25, 0x00	; 0
    5590:	81 2f       	mov	r24, r17
    5592:	6e e1       	ldi	r22, 0x1E	; 30
    5594:	42 e3       	ldi	r20, 0x32	; 50
    5596:	5d e0       	ldi	r21, 0x0D	; 13
    5598:	20 e3       	ldi	r18, 0x30	; 48
    559a:	3d e0       	ldi	r19, 0x0D	; 13
    559c:	e9 2e       	mov	r14, r25
    559e:	0e 94 6a 2a 	call	0x54d4	; 0x54d4 <_helper_DisplayBiStateText>
	
	lcdReverse(false);
    55a2:	80 e0       	ldi	r24, 0x00	; 0
    55a4:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <lcdReverse>
	
}
    55a8:	1f 91       	pop	r17
    55aa:	0f 91       	pop	r16
    55ac:	ef 90       	pop	r14
    55ae:	08 95       	ret

000055b0 <_hStickCentering>:



BOOL bError; 
void _hStickCentering()
{
    55b0:	0f 93       	push	r16
    55b2:	1f 93       	push	r17
    55b4:	cf 93       	push	r28
    55b6:	df 93       	push	r29
	uint8_t i ;
	UIEnableStickCommands=false; // you cannot use sticks here. for arming or as buttons.
    55b8:	10 92 e9 05 	sts	0x05E9, r1
	
	if (IS_INIT)
    55bc:	80 91 be 05 	lds	r24, 0x05BE
    55c0:	80 ff       	sbrs	r24, 0
    55c2:	0c c0       	rjmp	.+24     	; 0x55dc <_hStickCentering+0x2c>
	{
		RX_StickCenterCalibrationInit(ActiveRXIndex);
    55c4:	80 91 ce 05 	lds	r24, 0x05CE
    55c8:	0e 94 9f 25 	call	0x4b3e	; 0x4b3e <RX_StickCenterCalibrationInit>
		LCD_WriteString_Pex(0,0,strSPC1,18,false); // clear the header
    55cc:	80 e0       	ldi	r24, 0x00	; 0
    55ce:	60 e0       	ldi	r22, 0x00	; 0
    55d0:	42 e0       	ldi	r20, 0x02	; 2
    55d2:	5d e0       	ldi	r21, 0x0D	; 13
    55d4:	22 e1       	ldi	r18, 0x12	; 18
    55d6:	00 e0       	ldi	r16, 0x00	; 0
    55d8:	0e 94 95 0d 	call	0x1b2a	; 0x1b2a <LCD_WriteString_Pex>
	}
	
	if (KEY4)
    55dc:	80 91 be 05 	lds	r24, 0x05BE
    55e0:	84 ff       	sbrs	r24, 4
    55e2:	bf c0       	rjmp	.+382    	; 0x5762 <_hStickCentering+0x1b2>
	{
		if (!bError)
    55e4:	80 91 4a 08 	lds	r24, 0x084A
    55e8:	88 23       	and	r24, r24
    55ea:	09 f0       	breq	.+2      	; 0x55ee <_hStickCentering+0x3e>
    55ec:	b5 c0       	rjmp	.+362    	; 0x5758 <_hStickCentering+0x1a8>
    55ee:	20 e0       	ldi	r18, 0x00	; 0
    55f0:	30 e0       	ldi	r19, 0x00	; 0
			// Save config
			for (i = 0; i < RXChannels; i++)
			{
				Config.RX_Mid[ActiveRXIndex][i] = (RX_MAX_raw[ActiveRXIndex][i]+RX_MIN_raw[ActiveRXIndex][i])/2;
				Config.RX_Min[ActiveRXIndex][i] = RX_MIN_raw[ActiveRXIndex][i];
				Config.RX_DiV_Value[ActiveRXIndex][i] = ((RX_MAX_raw[ActiveRXIndex][i] - RX_MIN_raw[ActiveRXIndex][i]) / 1000);
    55f2:	08 ee       	ldi	r16, 0xE8	; 232
    55f4:	13 e0       	ldi	r17, 0x03	; 3
		if (!bError)
		{
			// Save config
			for (i = 0; i < RXChannels; i++)
			{
				Config.RX_Mid[ActiveRXIndex][i] = (RX_MAX_raw[ActiveRXIndex][i]+RX_MIN_raw[ActiveRXIndex][i])/2;
    55f6:	80 91 ce 05 	lds	r24, 0x05CE
    55fa:	40 91 ce 05 	lds	r20, 0x05CE
    55fe:	60 91 ce 05 	lds	r22, 0x05CE
    5602:	90 e0       	ldi	r25, 0x00	; 0
    5604:	fc 01       	movw	r30, r24
    5606:	ee 0f       	add	r30, r30
    5608:	ff 1f       	adc	r31, r31
    560a:	ee 0f       	add	r30, r30
    560c:	ff 1f       	adc	r31, r31
    560e:	e8 0f       	add	r30, r24
    5610:	f9 1f       	adc	r31, r25
    5612:	e2 0f       	add	r30, r18
    5614:	f3 1f       	adc	r31, r19
    5616:	ee 0f       	add	r30, r30
    5618:	ff 1f       	adc	r31, r31
    561a:	e0 5a       	subi	r30, 0xA0	; 160
    561c:	f8 4f       	sbci	r31, 0xF8	; 248
    561e:	70 e0       	ldi	r23, 0x00	; 0
    5620:	cb 01       	movw	r24, r22
    5622:	88 0f       	add	r24, r24
    5624:	99 1f       	adc	r25, r25
    5626:	88 0f       	add	r24, r24
    5628:	99 1f       	adc	r25, r25
    562a:	86 0f       	add	r24, r22
    562c:	97 1f       	adc	r25, r23
    562e:	82 0f       	add	r24, r18
    5630:	93 1f       	adc	r25, r19
    5632:	88 0f       	add	r24, r24
    5634:	99 1f       	adc	r25, r25
    5636:	8a 53       	subi	r24, 0x3A	; 58
    5638:	99 4f       	sbci	r25, 0xF9	; 249
    563a:	50 e0       	ldi	r21, 0x00	; 0
    563c:	da 01       	movw	r26, r20
    563e:	aa 0f       	add	r26, r26
    5640:	bb 1f       	adc	r27, r27
    5642:	aa 0f       	add	r26, r26
    5644:	bb 1f       	adc	r27, r27
    5646:	a4 0f       	add	r26, r20
    5648:	b5 1f       	adc	r27, r21
    564a:	a2 0f       	add	r26, r18
    564c:	b3 1f       	adc	r27, r19
    564e:	aa 0f       	add	r26, r26
    5650:	bb 1f       	adc	r27, r27
    5652:	ab 5d       	subi	r26, 0xDB	; 219
    5654:	b9 4f       	sbci	r27, 0xF9	; 249
    5656:	ec 01       	movw	r28, r24
    5658:	88 81       	ld	r24, Y
    565a:	99 81       	ldd	r25, Y+1	; 0x01
    565c:	4d 91       	ld	r20, X+
    565e:	5c 91       	ld	r21, X
    5660:	84 0f       	add	r24, r20
    5662:	95 1f       	adc	r25, r21
    5664:	96 95       	lsr	r25
    5666:	87 95       	ror	r24
    5668:	91 83       	std	Z+1, r25	; 0x01
    566a:	80 83       	st	Z, r24
				Config.RX_Min[ActiveRXIndex][i] = RX_MIN_raw[ActiveRXIndex][i];
    566c:	40 91 ce 05 	lds	r20, 0x05CE
    5670:	80 91 ce 05 	lds	r24, 0x05CE
    5674:	50 e0       	ldi	r21, 0x00	; 0
    5676:	fa 01       	movw	r30, r20
    5678:	ee 0f       	add	r30, r30
    567a:	ff 1f       	adc	r31, r31
    567c:	ee 0f       	add	r30, r30
    567e:	ff 1f       	adc	r31, r31
    5680:	e4 0f       	add	r30, r20
    5682:	f5 1f       	adc	r31, r21
    5684:	e2 0f       	add	r30, r18
    5686:	f3 1f       	adc	r31, r19
    5688:	ee 0f       	add	r30, r30
    568a:	ff 1f       	adc	r31, r31
    568c:	ec 58       	subi	r30, 0x8C	; 140
    568e:	f8 4f       	sbci	r31, 0xF8	; 248
    5690:	90 e0       	ldi	r25, 0x00	; 0
    5692:	dc 01       	movw	r26, r24
    5694:	aa 0f       	add	r26, r26
    5696:	bb 1f       	adc	r27, r27
    5698:	aa 0f       	add	r26, r26
    569a:	bb 1f       	adc	r27, r27
    569c:	a8 0f       	add	r26, r24
    569e:	b9 1f       	adc	r27, r25
    56a0:	a2 0f       	add	r26, r18
    56a2:	b3 1f       	adc	r27, r19
    56a4:	aa 0f       	add	r26, r26
    56a6:	bb 1f       	adc	r27, r27
    56a8:	aa 53       	subi	r26, 0x3A	; 58
    56aa:	b9 4f       	sbci	r27, 0xF9	; 249
    56ac:	8d 91       	ld	r24, X+
    56ae:	9c 91       	ld	r25, X
    56b0:	91 83       	std	Z+1, r25	; 0x01
    56b2:	80 83       	st	Z, r24
				Config.RX_DiV_Value[ActiveRXIndex][i] = ((RX_MAX_raw[ActiveRXIndex][i] - RX_MIN_raw[ActiveRXIndex][i]) / 1000);
    56b4:	80 91 ce 05 	lds	r24, 0x05CE
    56b8:	60 91 ce 05 	lds	r22, 0x05CE
    56bc:	40 91 ce 05 	lds	r20, 0x05CE
    56c0:	90 e0       	ldi	r25, 0x00	; 0
    56c2:	fc 01       	movw	r30, r24
    56c4:	ee 0f       	add	r30, r30
    56c6:	ff 1f       	adc	r31, r31
    56c8:	ee 0f       	add	r30, r30
    56ca:	ff 1f       	adc	r31, r31
    56cc:	e8 0f       	add	r30, r24
    56ce:	f9 1f       	adc	r31, r25
    56d0:	e2 0f       	add	r30, r18
    56d2:	f3 1f       	adc	r31, r19
    56d4:	e8 55       	subi	r30, 0x58	; 88
    56d6:	f8 4f       	sbci	r31, 0xF8	; 248
    56d8:	70 e0       	ldi	r23, 0x00	; 0
    56da:	cb 01       	movw	r24, r22
    56dc:	88 0f       	add	r24, r24
    56de:	99 1f       	adc	r25, r25
    56e0:	88 0f       	add	r24, r24
    56e2:	99 1f       	adc	r25, r25
    56e4:	86 0f       	add	r24, r22
    56e6:	97 1f       	adc	r25, r23
    56e8:	82 0f       	add	r24, r18
    56ea:	93 1f       	adc	r25, r19
    56ec:	88 0f       	add	r24, r24
    56ee:	99 1f       	adc	r25, r25
    56f0:	8b 5d       	subi	r24, 0xDB	; 219
    56f2:	99 4f       	sbci	r25, 0xF9	; 249
    56f4:	50 e0       	ldi	r21, 0x00	; 0
    56f6:	da 01       	movw	r26, r20
    56f8:	aa 0f       	add	r26, r26
    56fa:	bb 1f       	adc	r27, r27
    56fc:	aa 0f       	add	r26, r26
    56fe:	bb 1f       	adc	r27, r27
    5700:	a4 0f       	add	r26, r20
    5702:	b5 1f       	adc	r27, r21
    5704:	a2 0f       	add	r26, r18
    5706:	b3 1f       	adc	r27, r19
    5708:	aa 0f       	add	r26, r26
    570a:	bb 1f       	adc	r27, r27
    570c:	aa 53       	subi	r26, 0x3A	; 58
    570e:	b9 4f       	sbci	r27, 0xF9	; 249
    5710:	ec 01       	movw	r28, r24
    5712:	88 81       	ld	r24, Y
    5714:	99 81       	ldd	r25, Y+1	; 0x01
    5716:	4d 91       	ld	r20, X+
    5718:	5c 91       	ld	r21, X
    571a:	11 97       	sbiw	r26, 0x01	; 1
    571c:	84 1b       	sub	r24, r20
    571e:	95 0b       	sbc	r25, r21
    5720:	b8 01       	movw	r22, r16
    5722:	0e 94 4d 38 	call	0x709a	; 0x709a <__udivmodhi4>
    5726:	60 83       	st	Z, r22
    5728:	2f 5f       	subi	r18, 0xFF	; 255
    572a:	3f 4f       	sbci	r19, 0xFF	; 255
	if (KEY4)
	{
		if (!bError)
		{
			// Save config
			for (i = 0; i < RXChannels; i++)
    572c:	25 30       	cpi	r18, 0x05	; 5
    572e:	31 05       	cpc	r19, r1
    5730:	09 f0       	breq	.+2      	; 0x5734 <_hStickCentering+0x184>
    5732:	61 cf       	rjmp	.-318    	; 0x55f6 <_hStickCentering+0x46>
				Config.RX_Min[ActiveRXIndex][i] = RX_MIN_raw[ActiveRXIndex][i];
				Config.RX_DiV_Value[ActiveRXIndex][i] = ((RX_MAX_raw[ActiveRXIndex][i] - RX_MIN_raw[ActiveRXIndex][i]) / 1000);
				
			}		
			
			Config.IsCalibrated= (Config.IsCalibrated | (1 << ActiveRXIndex));	// either 0b00000001 or 0b00000010
    5734:	20 91 ce 05 	lds	r18, 0x05CE
    5738:	81 e0       	ldi	r24, 0x01	; 1
    573a:	90 e0       	ldi	r25, 0x00	; 0
    573c:	02 c0       	rjmp	.+4      	; 0x5742 <_hStickCentering+0x192>
    573e:	88 0f       	add	r24, r24
    5740:	99 1f       	adc	r25, r25
    5742:	2a 95       	dec	r18
    5744:	e2 f7       	brpl	.-8      	; 0x573e <_hStickCentering+0x18e>
    5746:	20 91 ee 06 	lds	r18, 0x06EE
    574a:	28 2b       	or	r18, r24
    574c:	eb ee       	ldi	r30, 0xEB	; 235
    574e:	f6 e0       	ldi	r31, 0x06	; 6
    5750:	23 83       	std	Z+3, r18	; 0x03
			Save_Config_to_EEPROM();
    5752:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <Save_Config_to_EEPROM>
    5756:	05 c0       	rjmp	.+10     	; 0x5762 <_hStickCentering+0x1b2>
		}
		else
		{
			Beeper_Beep(BEEP_ERROR,3);	
    5758:	88 ec       	ldi	r24, 0xC8	; 200
    575a:	90 e0       	ldi	r25, 0x00	; 0
    575c:	63 e0       	ldi	r22, 0x03	; 3
    575e:	0e 94 99 0b 	call	0x1732	; 0x1732 <Beeper_Beep>
		}
		
	}
	
	if (KEY2)
    5762:	80 91 be 05 	lds	r24, 0x05BE
    5766:	86 ff       	sbrs	r24, 6
    5768:	04 c0       	rjmp	.+8      	; 0x5772 <_hStickCentering+0x1c2>
	{
		RX_StickCenterCalibrationInit(ActiveRXIndex);				
    576a:	80 91 ce 05 	lds	r24, 0x05CE
    576e:	0e 94 9f 25 	call	0x4b3e	; 0x4b3e <RX_StickCenterCalibrationInit>
	}
	
	bError = false;
    5772:	10 92 4a 08 	sts	0x084A, r1
	RX_StickCenterCalibration(ActiveRXIndex);
    5776:	80 91 ce 05 	lds	r24, 0x05CE
    577a:	0e 94 46 26 	call	0x4c8c	; 0x4c8c <RX_StickCenterCalibration>
    577e:	c0 e0       	ldi	r28, 0x00	; 0
    5780:	d0 e0       	ldi	r29, 0x00	; 0
		else
		{
			if ((RX_MAX_raw[ActiveRXIndex][i]< RX_MIN_raw[ActiveRXIndex][i]) || (RX_MIN_raw[ActiveRXIndex][i]==0))  // RX_MIN_raw[i]=0 if the Remote is OFF when entering the test
			{
				LCD_WriteString_P(strErr);	
				bError = TRUE;
    5782:	11 e0       	ldi	r17, 0x01	; 1
}



BOOL bError; 
void _hStickCentering()
    5784:	ce 01       	movw	r24, r28
	
	bError = false;
	RX_StickCenterCalibration(ActiveRXIndex);
	for (uint8_t i = 0; i < RXChannels; i++)
	{
		LCD_SetPos(i+1, 30);
    5786:	8f 5f       	subi	r24, 0xFF	; 255
    5788:	6e e1       	ldi	r22, 0x1E	; 30
    578a:	0e 94 10 0c 	call	0x1820	; 0x1820 <LCD_SetPos>
		utoa(RX_MAX_raw[ActiveRXIndex][i], sXDeg, 10);
    578e:	80 91 ce 05 	lds	r24, 0x05CE
    5792:	90 e0       	ldi	r25, 0x00	; 0
    5794:	fc 01       	movw	r30, r24
    5796:	ee 0f       	add	r30, r30
    5798:	ff 1f       	adc	r31, r31
    579a:	ee 0f       	add	r30, r30
    579c:	ff 1f       	adc	r31, r31
    579e:	e8 0f       	add	r30, r24
    57a0:	f9 1f       	adc	r31, r25
    57a2:	ec 0f       	add	r30, r28
    57a4:	fd 1f       	adc	r31, r29
    57a6:	ee 0f       	add	r30, r30
    57a8:	ff 1f       	adc	r31, r31
    57aa:	eb 5d       	subi	r30, 0xDB	; 219
    57ac:	f9 4f       	sbci	r31, 0xF9	; 249
    57ae:	80 81       	ld	r24, Z
    57b0:	91 81       	ldd	r25, Z+1	; 0x01
    57b2:	6e ee       	ldi	r22, 0xEE	; 238
    57b4:	75 e0       	ldi	r23, 0x05	; 5
    57b6:	4a e0       	ldi	r20, 0x0A	; 10
    57b8:	50 e0       	ldi	r21, 0x00	; 0
    57ba:	0e 94 ed 38 	call	0x71da	; 0x71da <utoa>
		LCD_WriteString(sXDeg);
    57be:	8e ee       	ldi	r24, 0xEE	; 238
    57c0:	95 e0       	ldi	r25, 0x05	; 5
    57c2:	0e 94 f9 0c 	call	0x19f2	; 0x19f2 <LCD_WriteString>
		LCD_WriteString_P(strSPC1);
    57c6:	82 e0       	ldi	r24, 0x02	; 2
    57c8:	9d e0       	ldi	r25, 0x0D	; 13
    57ca:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <LCD_WriteString_P>
		utoa(RX_MIN_raw[ActiveRXIndex][i], sXDeg, 10);
    57ce:	80 91 ce 05 	lds	r24, 0x05CE
    57d2:	90 e0       	ldi	r25, 0x00	; 0
    57d4:	fc 01       	movw	r30, r24
    57d6:	ee 0f       	add	r30, r30
    57d8:	ff 1f       	adc	r31, r31
    57da:	ee 0f       	add	r30, r30
    57dc:	ff 1f       	adc	r31, r31
    57de:	e8 0f       	add	r30, r24
    57e0:	f9 1f       	adc	r31, r25
    57e2:	ec 0f       	add	r30, r28
    57e4:	fd 1f       	adc	r31, r29
    57e6:	ee 0f       	add	r30, r30
    57e8:	ff 1f       	adc	r31, r31
    57ea:	ea 53       	subi	r30, 0x3A	; 58
    57ec:	f9 4f       	sbci	r31, 0xF9	; 249
    57ee:	80 81       	ld	r24, Z
    57f0:	91 81       	ldd	r25, Z+1	; 0x01
    57f2:	6e ee       	ldi	r22, 0xEE	; 238
    57f4:	75 e0       	ldi	r23, 0x05	; 5
    57f6:	4a e0       	ldi	r20, 0x0A	; 10
    57f8:	50 e0       	ldi	r21, 0x00	; 0
    57fa:	0e 94 ed 38 	call	0x71da	; 0x71da <utoa>
		LCD_WriteString(sXDeg);
    57fe:	8e ee       	ldi	r24, 0xEE	; 238
    5800:	95 e0       	ldi	r25, 0x05	; 5
    5802:	0e 94 f9 0c 	call	0x19f2	; 0x19f2 <LCD_WriteString>
		if ((ActiveRXIndex==0) && (i == RXChannel_AUX))
    5806:	80 91 ce 05 	lds	r24, 0x05CE
    580a:	88 23       	and	r24, r24
    580c:	29 f4       	brne	.+10     	; 0x5818 <_hStickCentering+0x268>
    580e:	c4 30       	cpi	r28, 0x04	; 4
    5810:	19 f4       	brne	.+6      	; 0x5818 <_hStickCentering+0x268>
		{
			LCD_WriteString_P(PSTR("NA"));
    5812:	8d e0       	ldi	r24, 0x0D	; 13
    5814:	9d e0       	ldi	r25, 0x0D	; 13
    5816:	45 c0       	rjmp	.+138    	; 0x58a2 <_hStickCentering+0x2f2>
		}
		else
		{
			if ((RX_MAX_raw[ActiveRXIndex][i]< RX_MIN_raw[ActiveRXIndex][i]) || (RX_MIN_raw[ActiveRXIndex][i]==0))  // RX_MIN_raw[i]=0 if the Remote is OFF when entering the test
    5818:	20 91 ce 05 	lds	r18, 0x05CE
    581c:	80 91 ce 05 	lds	r24, 0x05CE
    5820:	30 e0       	ldi	r19, 0x00	; 0
    5822:	d9 01       	movw	r26, r18
    5824:	aa 0f       	add	r26, r26
    5826:	bb 1f       	adc	r27, r27
    5828:	aa 0f       	add	r26, r26
    582a:	bb 1f       	adc	r27, r27
    582c:	a2 0f       	add	r26, r18
    582e:	b3 1f       	adc	r27, r19
    5830:	ac 0f       	add	r26, r28
    5832:	bd 1f       	adc	r27, r29
    5834:	aa 0f       	add	r26, r26
    5836:	bb 1f       	adc	r27, r27
    5838:	ab 5d       	subi	r26, 0xDB	; 219
    583a:	b9 4f       	sbci	r27, 0xF9	; 249
    583c:	90 e0       	ldi	r25, 0x00	; 0
    583e:	fc 01       	movw	r30, r24
    5840:	ee 0f       	add	r30, r30
    5842:	ff 1f       	adc	r31, r31
    5844:	ee 0f       	add	r30, r30
    5846:	ff 1f       	adc	r31, r31
    5848:	e8 0f       	add	r30, r24
    584a:	f9 1f       	adc	r31, r25
    584c:	ec 0f       	add	r30, r28
    584e:	fd 1f       	adc	r31, r29
    5850:	ee 0f       	add	r30, r30
    5852:	ff 1f       	adc	r31, r31
    5854:	ea 53       	subi	r30, 0x3A	; 58
    5856:	f9 4f       	sbci	r31, 0xF9	; 249
    5858:	2d 91       	ld	r18, X+
    585a:	3c 91       	ld	r19, X
    585c:	11 97       	sbiw	r26, 0x01	; 1
    585e:	80 81       	ld	r24, Z
    5860:	91 81       	ldd	r25, Z+1	; 0x01
    5862:	28 17       	cp	r18, r24
    5864:	39 07       	cpc	r19, r25
    5866:	a0 f0       	brcs	.+40     	; 0x5890 <_hStickCentering+0x2e0>
    5868:	80 91 ce 05 	lds	r24, 0x05CE
    586c:	90 e0       	ldi	r25, 0x00	; 0
    586e:	fc 01       	movw	r30, r24
    5870:	ee 0f       	add	r30, r30
    5872:	ff 1f       	adc	r31, r31
    5874:	ee 0f       	add	r30, r30
    5876:	ff 1f       	adc	r31, r31
    5878:	e8 0f       	add	r30, r24
    587a:	f9 1f       	adc	r31, r25
    587c:	ec 0f       	add	r30, r28
    587e:	fd 1f       	adc	r31, r29
    5880:	ee 0f       	add	r30, r30
    5882:	ff 1f       	adc	r31, r31
    5884:	ea 53       	subi	r30, 0x3A	; 58
    5886:	f9 4f       	sbci	r31, 0xF9	; 249
    5888:	80 81       	ld	r24, Z
    588a:	91 81       	ldd	r25, Z+1	; 0x01
    588c:	00 97       	sbiw	r24, 0x00	; 0
    588e:	39 f4       	brne	.+14     	; 0x589e <_hStickCentering+0x2ee>
			{
				LCD_WriteString_P(strErr);	
    5890:	84 e0       	ldi	r24, 0x04	; 4
    5892:	9d e0       	ldi	r25, 0x0D	; 13
    5894:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <LCD_WriteString_P>
				bError = TRUE;
    5898:	10 93 4a 08 	sts	0x084A, r17
    589c:	04 c0       	rjmp	.+8      	; 0x58a6 <_hStickCentering+0x2f6>
			}
			else
			{
				LCD_WriteString_P(strSPC4);	
    589e:	88 e0       	ldi	r24, 0x08	; 8
    58a0:	9d e0       	ldi	r25, 0x0D	; 13
    58a2:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <LCD_WriteString_P>
    58a6:	21 96       	adiw	r28, 0x01	; 1
		RX_StickCenterCalibrationInit(ActiveRXIndex);				
	}
	
	bError = false;
	RX_StickCenterCalibration(ActiveRXIndex);
	for (uint8_t i = 0; i < RXChannels; i++)
    58a8:	c5 30       	cpi	r28, 0x05	; 5
    58aa:	d1 05       	cpc	r29, r1
    58ac:	09 f0       	breq	.+2      	; 0x58b0 <_hStickCentering+0x300>
    58ae:	6a cf       	rjmp	.-300    	; 0x5784 <_hStickCentering+0x1d4>
			}
		}	
	}
	

	_helper_DisplayRXStatus(6);
    58b0:	86 e0       	ldi	r24, 0x06	; 6
    58b2:	0e 94 9f 2a 	call	0x553e	; 0x553e <_helper_DisplayRXStatus>
}
    58b6:	df 91       	pop	r29
    58b8:	cf 91       	pop	r28
    58ba:	1f 91       	pop	r17
    58bc:	0f 91       	pop	r16
    58be:	08 95       	ret

000058c0 <_hReceiverTest>:
	//LCD_SetPos(6, 48);
	//LCD_WriteValue_double(6,48,Sensor_GetBattery(),false);
}

void _hReceiverTest()
{
    58c0:	0f 93       	push	r16
    58c2:	1f 93       	push	r17
    58c4:	cf 93       	push	r28
    58c6:	df 93       	push	r29
	UIEnableStickCommands=false; // you cannot use sticks here. for arming or as buttons.
    58c8:	10 92 e9 05 	sts	0x05E9, r1
	
	RX_CopyLatestReceiverValues();
    58cc:	0e 94 45 25 	call	0x4a8a	; 0x4a8a <RX_CopyLatestReceiverValues>
    58d0:	c0 e0       	ldi	r28, 0x00	; 0
    58d2:	d0 e0       	ldi	r29, 0x00	; 0
    58d4:	ce 01       	movw	r24, r28
    58d6:	8f 5f       	subi	r24, 0xFF	; 255
    58d8:	18 2f       	mov	r17, r24
		
		
	for (uint8_t i = 0; i < RXChannels; i++)
	{
		LCD_SetPos(i+1, 24);
    58da:	68 e1       	ldi	r22, 0x18	; 24
    58dc:	0e 94 10 0c 	call	0x1820	; 0x1820 <LCD_SetPos>
			
		//itoa(RX_Latest[ActiveRXIndex][i], sXDeg, 10);
		LCD_WriteValue(i+1,36,RX_Latest[0][i],5,(!IS_TX1_GOOD));
    58e0:	fe 01       	movw	r30, r28
    58e2:	ee 0f       	add	r30, r30
    58e4:	ff 1f       	adc	r31, r31
    58e6:	ea 5f       	subi	r30, 0xFA	; 250
    58e8:	f9 4f       	sbci	r31, 0xF9	; 249
    58ea:	40 81       	ld	r20, Z
    58ec:	51 81       	ldd	r21, Z+1	; 0x01
    58ee:	80 91 ff 07 	lds	r24, 0x07FF
    58f2:	90 e0       	ldi	r25, 0x00	; 0
    58f4:	8f 70       	andi	r24, 0x0F	; 15
    58f6:	90 70       	andi	r25, 0x00	; 0
    58f8:	01 e0       	ldi	r16, 0x01	; 1
    58fa:	00 97       	sbiw	r24, 0x00	; 0
    58fc:	09 f4       	brne	.+2      	; 0x5900 <_hReceiverTest+0x40>
    58fe:	00 e0       	ldi	r16, 0x00	; 0
    5900:	81 2f       	mov	r24, r17
    5902:	64 e2       	ldi	r22, 0x24	; 36
    5904:	25 e0       	ldi	r18, 0x05	; 5
    5906:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <LCD_WriteValue>
		LCD_WriteValue(i+1,84,RX_Latest[1][i],5,(!IS_TX2_GOOD));
    590a:	fe 01       	movw	r30, r28
    590c:	ee 0f       	add	r30, r30
    590e:	ff 1f       	adc	r31, r31
    5910:	e0 5f       	subi	r30, 0xF0	; 240
    5912:	f9 4f       	sbci	r31, 0xF9	; 249
    5914:	40 81       	ld	r20, Z
    5916:	51 81       	ldd	r21, Z+1	; 0x01
    5918:	80 91 ff 07 	lds	r24, 0x07FF
    591c:	80 7f       	andi	r24, 0xF0	; 240
    591e:	01 e0       	ldi	r16, 0x01	; 1
    5920:	09 f4       	brne	.+2      	; 0x5924 <_hReceiverTest+0x64>
    5922:	00 e0       	ldi	r16, 0x00	; 0
    5924:	81 2f       	mov	r24, r17
    5926:	64 e5       	ldi	r22, 0x54	; 84
    5928:	25 e0       	ldi	r18, 0x05	; 5
    592a:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <LCD_WriteValue>
    592e:	21 96       	adiw	r28, 0x01	; 1
	UIEnableStickCommands=false; // you cannot use sticks here. for arming or as buttons.
	
	RX_CopyLatestReceiverValues();
		
		
	for (uint8_t i = 0; i < RXChannels; i++)
    5930:	c5 30       	cpi	r28, 0x05	; 5
    5932:	d1 05       	cpc	r29, r1
    5934:	79 f6       	brne	.-98     	; 0x58d4 <_hReceiverTest+0x14>
		LCD_WriteValue(i+1,84,RX_Latest[1][i],5,(!IS_TX2_GOOD));
		
	}			
	
	
	_helper_DisplayRXStatus(6);
    5936:	86 e0       	ldi	r24, 0x06	; 6
    5938:	0e 94 9f 2a 	call	0x553e	; 0x553e <_helper_DisplayRXStatus>
	
}
    593c:	df 91       	pop	r29
    593e:	cf 91       	pop	r28
    5940:	1f 91       	pop	r17
    5942:	0f 91       	pop	r16
    5944:	08 95       	ret

00005946 <_helper_Words>:
	
}


void _helper_Words (const int8_t row, const int8_t col,  const BOOL LCDReverse, const bool Condition, PGM_P TrueString, PGM_P FalseString, int8_t Len)
{
    5946:	cf 92       	push	r12
    5948:	ef 92       	push	r14
    594a:	ff 92       	push	r15
    594c:	0f 93       	push	r16
    594e:	1f 93       	push	r17
    5950:	94 2f       	mov	r25, r20
    5952:	32 2f       	mov	r19, r18
    5954:	2c 2d       	mov	r18, r12
	if (Condition== TRUE)
    5956:	33 23       	and	r19, r19
    5958:	11 f0       	breq	.+4      	; 0x595e <_helper_Words+0x18>
	{
		LCD_WriteString_Pex(row,col,TrueString,Len,LCDReverse);
    595a:	a8 01       	movw	r20, r16
    595c:	01 c0       	rjmp	.+2      	; 0x5960 <_helper_Words+0x1a>
	}
	else
	{
		LCD_WriteString_Pex(row,col,FalseString,Len,LCDReverse);
    595e:	a7 01       	movw	r20, r14
    5960:	09 2f       	mov	r16, r25
    5962:	0e 94 95 0d 	call	0x1b2a	; 0x1b2a <LCD_WriteString_Pex>
	}
}
    5966:	1f 91       	pop	r17
    5968:	0f 91       	pop	r16
    596a:	ff 90       	pop	r15
    596c:	ef 90       	pop	r14
    596e:	cf 90       	pop	r12
    5970:	08 95       	ret

00005972 <Menu_LoadPage>:

/*
//	Put screen into CurrentPage ==> MemoryScreen
*/
void Menu_LoadPage(const uint8_t pageIndex)
{
    5972:	1f 93       	push	r17
    5974:	18 2f       	mov	r17, r24
	memcpy_P(&currentPage, &pages[pageIndex], sizeof(currentPage));
    5976:	66 e0       	ldi	r22, 0x06	; 6
    5978:	86 9f       	mul	r24, r22
    597a:	b0 01       	movw	r22, r0
    597c:	11 24       	eor	r1, r1
    597e:	65 59       	subi	r22, 0x95	; 149
    5980:	72 4f       	sbci	r23, 0xF2	; 242
    5982:	86 e4       	ldi	r24, 0x46	; 70
    5984:	95 e0       	ldi	r25, 0x05	; 5
    5986:	46 e0       	ldi	r20, 0x06	; 6
    5988:	50 e0       	ldi	r21, 0x00	; 0
    598a:	0e 94 9f 38 	call	0x713e	; 0x713e <memcpy_P>
	page = pageIndex;
    598e:	10 93 3b 05 	sts	0x053B, r17
}
    5992:	1f 91       	pop	r17
    5994:	08 95       	ret

00005996 <_hFactoryReset>:
		//LCD_WriteValue(4,48, MotorOut[3],9,false);
	}
}
void _hFactoryReset()
{
	if (IS_INIT)
    5996:	80 91 be 05 	lds	r24, 0x05BE
    599a:	80 ff       	sbrs	r24, 0
    599c:	05 c0       	rjmp	.+10     	; 0x59a8 <_hFactoryReset+0x12>
	{
		;
		LCD_WriteString_P(strAreYouSure);
    599e:	8d ef       	ldi	r24, 0xFD	; 253
    59a0:	9b e0       	ldi	r25, 0x0B	; 11
    59a2:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <LCD_WriteString_P>
    59a6:	08 95       	ret
	}
	else if (KEY4)	// Yes
    59a8:	84 ff       	sbrs	r24, 4
    59aa:	05 c0       	rjmp	.+10     	; 0x59b6 <_hFactoryReset+0x20>
	{
		Save_Default_Config_to_EEPROM();
    59ac:	0e 94 e0 0f 	call	0x1fc0	; 0x1fc0 <Save_Default_Config_to_EEPROM>
		//RST_CTRL
		Menu_LoadPage(PAGE_RESTART);
    59b0:	84 e0       	ldi	r24, 0x04	; 4
    59b2:	0e 94 b9 2c 	call	0x5972	; 0x5972 <Menu_LoadPage>
    59b6:	08 95       	ret

000059b8 <_hESCCalibration>:
	
}

void _hESCCalibration()
{
	NOKEYRETURN
    59b8:	80 91 be 05 	lds	r24, 0x05BE
    59bc:	88 23       	and	r24, r24
    59be:	c1 f0       	breq	.+48     	; 0x59f0 <_hESCCalibration+0x38>
	
	if (KEY4)
    59c0:	84 ff       	sbrs	r24, 4
    59c2:	16 c0       	rjmp	.+44     	; 0x59f0 <_hESCCalibration+0x38>
	{
		if ((Config.IsCalibrated & CALIBRATED_SENSOR) && ((Config.IsCalibrated & CALIBRATED_Stick_SECONDARY)==CALIBRATED_Stick_SECONDARY))
    59c4:	80 91 ee 06 	lds	r24, 0x06EE
		LCD_WriteValue_double_ex(i,48,Config.Sensor_zero[i],9,false);
	}	
	
}

void _hESCCalibration()
    59c8:	86 70       	andi	r24, 0x06	; 6
{
	NOKEYRETURN
	
	if (KEY4)
	{
		if ((Config.IsCalibrated & CALIBRATED_SENSOR) && ((Config.IsCalibrated & CALIBRATED_Stick_SECONDARY)==CALIBRATED_Stick_SECONDARY))
    59ca:	86 30       	cpi	r24, 0x06	; 6
    59cc:	61 f4       	brne	.+24     	; 0x59e6 <_hESCCalibration+0x2e>
		{
			SystemActions = SYS_ACT_DISARM;
    59ce:	82 e0       	ldi	r24, 0x02	; 2
    59d0:	80 93 51 05 	sts	0x0551, r24
			Config.IsESCCalibration=ESCCalibration_ON;
    59d4:	81 e0       	ldi	r24, 0x01	; 1
    59d6:	80 93 f3 06 	sts	0x06F3, r24
			Save_Config_to_EEPROM();
    59da:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <Save_Config_to_EEPROM>
			Menu_LoadPage(PAGE_RESTART);
    59de:	84 e0       	ldi	r24, 0x04	; 4
    59e0:	0e 94 b9 2c 	call	0x5972	; 0x5972 <Menu_LoadPage>
			return;
    59e4:	08 95       	ret
		}
		else
		{ //...flash as error
			LED_FlashOrangeLED(LED_SHORT_TOGGLE,2);
    59e6:	8e e1       	ldi	r24, 0x1E	; 30
    59e8:	90 e0       	ldi	r25, 0x00	; 0
    59ea:	62 e0       	ldi	r22, 0x02	; 2
    59ec:	0e 94 9b 0e 	call	0x1d36	; 0x1d36 <LED_FlashOrangeLED>
    59f0:	08 95       	ret

000059f2 <_hHomeArmed>:
}

void _hHomeArmed()
{
	
	if (IS_INIT)	
    59f2:	80 91 be 05 	lds	r24, 0x05BE
    59f6:	80 ff       	sbrs	r24, 0
    59f8:	10 c0       	rjmp	.+32     	; 0x5a1a <_hHomeArmed+0x28>
	{
		LCD_SelectFont (&font12x16);
    59fa:	89 e5       	ldi	r24, 0x59	; 89
    59fc:	91 e0       	ldi	r25, 0x01	; 1
    59fe:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <LCD_SelectFont>
		LCD_SetPos(0,0);
    5a02:	80 e0       	ldi	r24, 0x00	; 0
    5a04:	60 e0       	ldi	r22, 0x00	; 0
    5a06:	0e 94 10 0c 	call	0x1820	; 0x1820 <LCD_SetPos>
		LCD_WriteString_P(strARMED);
    5a0a:	80 e1       	ldi	r24, 0x10	; 16
    5a0c:	9d e0       	ldi	r25, 0x0D	; 13
    5a0e:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <LCD_WriteString_P>
		LCD_SelectFont (NULL);
    5a12:	80 e0       	ldi	r24, 0x00	; 0
    5a14:	90 e0       	ldi	r25, 0x00	; 0
    5a16:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <LCD_SelectFont>
	}
	
	
	if (KEY4)	// MENU
    5a1a:	80 91 be 05 	lds	r24, 0x05BE
    5a1e:	84 ff       	sbrs	r24, 4
    5a20:	03 c0       	rjmp	.+6      	; 0x5a28 <_hHomeArmed+0x36>
	{
		Menu_LoadPage(PAGE_MENU);
    5a22:	81 e0       	ldi	r24, 0x01	; 1
    5a24:	0e 94 b9 2c 	call	0x5972	; 0x5972 <Menu_LoadPage>
    5a28:	08 95       	ret

00005a2a <_hHomePage>:
}



void _hHomePage()
{
    5a2a:	cf 92       	push	r12
    5a2c:	ef 92       	push	r14
    5a2e:	ff 92       	push	r15
    5a30:	0f 93       	push	r16
    5a32:	1f 93       	push	r17
	
	if (IS_INIT)
    5a34:	80 91 be 05 	lds	r24, 0x05BE
    5a38:	80 ff       	sbrs	r24, 0
    5a3a:	31 c0       	rjmp	.+98     	; 0x5a9e <_hHomePage+0x74>
	{
		// Version
		LCD_SetPos(0,0);
    5a3c:	80 e0       	ldi	r24, 0x00	; 0
    5a3e:	60 e0       	ldi	r22, 0x00	; 0
    5a40:	0e 94 10 0c 	call	0x1820	; 0x1820 <LCD_SetPos>
		LCD_WriteString_P(strVersionInfo);
    5a44:	86 e1       	ldi	r24, 0x16	; 22
    5a46:	9d e0       	ldi	r25, 0x0D	; 13
    5a48:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <LCD_WriteString_P>
		// Sensors
		_helper_DisplayBiStateText(5, 60, strOK, strErr, (Config.IsCalibrated & CALIBRATED_SENSOR),false);
    5a4c:	80 91 ee 06 	lds	r24, 0x06EE
    5a50:	01 e0       	ldi	r16, 0x01	; 1
    5a52:	82 ff       	sbrs	r24, 2
    5a54:	00 e0       	ldi	r16, 0x00	; 0
    5a56:	85 e0       	ldi	r24, 0x05	; 5
    5a58:	6c e3       	ldi	r22, 0x3C	; 60
    5a5a:	4a e2       	ldi	r20, 0x2A	; 42
    5a5c:	5d e0       	ldi	r21, 0x0D	; 13
    5a5e:	24 e0       	ldi	r18, 0x04	; 4
    5a60:	3d e0       	ldi	r19, 0x0D	; 13
    5a62:	ee 24       	eor	r14, r14
    5a64:	0e 94 6a 2a 	call	0x54d4	; 0x54d4 <_helper_DisplayBiStateText>
		
		//Stick Centering & Calibration
		_helper_DisplayBiStateText(5, 102, str1, strX, (Config.IsCalibrated & CALIBRATED_Stick_PRIMARY),false);
    5a68:	00 91 ee 06 	lds	r16, 0x06EE
    5a6c:	10 e0       	ldi	r17, 0x00	; 0
    5a6e:	01 70       	andi	r16, 0x01	; 1
    5a70:	10 70       	andi	r17, 0x00	; 0
    5a72:	85 e0       	ldi	r24, 0x05	; 5
    5a74:	66 e6       	ldi	r22, 0x66	; 102
    5a76:	4e e2       	ldi	r20, 0x2E	; 46
    5a78:	5d e0       	ldi	r21, 0x0D	; 13
    5a7a:	20 e3       	ldi	r18, 0x30	; 48
    5a7c:	3d e0       	ldi	r19, 0x0D	; 13
    5a7e:	0e 94 6a 2a 	call	0x54d4	; 0x54d4 <_helper_DisplayBiStateText>
		
		_helper_DisplayBiStateText(5, 114, str2, strX, (Config.IsCalibrated & CALIBRATED_Stick_SECONDARY),false);
    5a82:	80 91 ee 06 	lds	r24, 0x06EE
    5a86:	01 e0       	ldi	r16, 0x01	; 1
    5a88:	81 ff       	sbrs	r24, 1
    5a8a:	00 e0       	ldi	r16, 0x00	; 0
    5a8c:	85 e0       	ldi	r24, 0x05	; 5
    5a8e:	62 e7       	ldi	r22, 0x72	; 114
    5a90:	42 e3       	ldi	r20, 0x32	; 50
    5a92:	5d e0       	ldi	r21, 0x0D	; 13
    5a94:	20 e3       	ldi	r18, 0x30	; 48
    5a96:	3d e0       	ldi	r19, 0x0D	; 13
    5a98:	ee 24       	eor	r14, r14
    5a9a:	0e 94 6a 2a 	call	0x54d4	; 0x54d4 <_helper_DisplayBiStateText>
		
		
	}
	
	if (KEY4)	// MENU
    5a9e:	80 91 be 05 	lds	r24, 0x05BE
    5aa2:	84 ff       	sbrs	r24, 4
    5aa4:	04 c0       	rjmp	.+8      	; 0x5aae <_hHomePage+0x84>
	{
		Menu_LoadPage(PAGE_MENU);
    5aa6:	81 e0       	ldi	r24, 0x01	; 1
    5aa8:	0e 94 b9 2c 	call	0x5972	; 0x5972 <Menu_LoadPage>
		return;
    5aac:	94 c0       	rjmp	.+296    	; 0x5bd6 <_hHomePage+0x1ac>
	}
	
	// Write Voltage
	//LCD_SetPos(2, 30);
	double volt = (double)(Sensor_GetBattery()/10.0f);
    5aae:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <Sensor_GetBattery>
    5ab2:	9c 01       	movw	r18, r24
    5ab4:	b9 01       	movw	r22, r18
    5ab6:	88 27       	eor	r24, r24
    5ab8:	77 fd       	sbrc	r23, 7
    5aba:	80 95       	com	r24
    5abc:	98 2f       	mov	r25, r24
    5abe:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    5ac2:	20 e0       	ldi	r18, 0x00	; 0
    5ac4:	30 e0       	ldi	r19, 0x00	; 0
    5ac6:	40 e2       	ldi	r20, 0x20	; 32
    5ac8:	51 e4       	ldi	r21, 0x41	; 65
    5aca:	0e 94 9b 36 	call	0x6d36	; 0x6d36 <__divsf3>
    5ace:	9b 01       	movw	r18, r22
    5ad0:	ac 01       	movw	r20, r24
	LCD_WriteValue_double_ex(2,36,volt,8,IS_SYS_ERR_VOLTAGE); // FIX: 8 to display 2 digits volt besides floating point
    5ad2:	90 91 db 06 	lds	r25, 0x06DB
    5ad6:	92 70       	andi	r25, 0x02	; 2
    5ad8:	82 e0       	ldi	r24, 0x02	; 2
    5ada:	64 e2       	ldi	r22, 0x24	; 36
    5adc:	08 e0       	ldi	r16, 0x08	; 8
    5ade:	e9 2e       	mov	r14, r25
    5ae0:	0e 94 ba 0d 	call	0x1b74	; 0x1b74 <LCD_WriteValue_double_ex>
	//LCD_WriteValue(2,36,Sensor_GetBattery(),4,IS_SYS_ERR_VOLTAGE);
	LCD_SetPos (3,6);
    5ae4:	83 e0       	ldi	r24, 0x03	; 3
    5ae6:	66 e0       	ldi	r22, 0x06	; 6
    5ae8:	0e 94 10 0c 	call	0x1820	; 0x1820 <LCD_SetPos>
	if (nFlyingModes == FLYINGMODE_ACRO)
    5aec:	80 91 1e 06 	lds	r24, 0x061E
    5af0:	81 30       	cpi	r24, 0x01	; 1
    5af2:	19 f4       	brne	.+6      	; 0x5afa <_hHomePage+0xd0>
	{
		LCD_WriteString_P(PSTR("ACRO  "));
    5af4:	84 e6       	ldi	r24, 0x64	; 100
    5af6:	9d e0       	ldi	r25, 0x0D	; 13
    5af8:	09 c0       	rjmp	.+18     	; 0x5b0c <_hHomePage+0xe2>
	}
	else if (nFlyingModes == FLYINGMODE_LEVEL)
    5afa:	82 30       	cpi	r24, 0x02	; 2
    5afc:	19 f4       	brne	.+6      	; 0x5b04 <_hHomePage+0xda>
	{
		LCD_WriteString_P(PSTR("STABLE"));
    5afe:	8d e5       	ldi	r24, 0x5D	; 93
    5b00:	9d e0       	ldi	r25, 0x0D	; 13
    5b02:	04 c0       	rjmp	.+8      	; 0x5b0c <_hHomePage+0xe2>
	}
	else if (nFlyingModes == FLYINGMODE_ALTHOLD)
    5b04:	84 30       	cpi	r24, 0x04	; 4
    5b06:	21 f4       	brne	.+8      	; 0x5b10 <_hHomePage+0xe6>
	{
		LCD_WriteString_P(PSTR("ALTHLD"));
    5b08:	86 e5       	ldi	r24, 0x56	; 86
    5b0a:	9d e0       	ldi	r25, 0x0D	; 13
    5b0c:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <LCD_WriteString_P>
	}
	
	_helper_Words (3,48,  0,(Config.FrameType== FRAMETYPE_QUADCOPTER),PSTR("Quad"),PSTR("TRI "),5);
    5b10:	21 e0       	ldi	r18, 0x01	; 1
    5b12:	80 91 f4 06 	lds	r24, 0x06F4
    5b16:	81 30       	cpi	r24, 0x01	; 1
    5b18:	09 f0       	breq	.+2      	; 0x5b1c <_hHomePage+0xf2>
    5b1a:	20 e0       	ldi	r18, 0x00	; 0
    5b1c:	83 e0       	ldi	r24, 0x03	; 3
    5b1e:	60 e3       	ldi	r22, 0x30	; 48
    5b20:	40 e0       	ldi	r20, 0x00	; 0
    5b22:	01 e5       	ldi	r16, 0x51	; 81
    5b24:	1d e0       	ldi	r17, 0x0D	; 13
    5b26:	bc e4       	ldi	r27, 0x4C	; 76
    5b28:	eb 2e       	mov	r14, r27
    5b2a:	bd e0       	ldi	r27, 0x0D	; 13
    5b2c:	fb 2e       	mov	r15, r27
    5b2e:	a5 e0       	ldi	r26, 0x05	; 5
    5b30:	ca 2e       	mov	r12, r26
    5b32:	0e 94 a3 2c 	call	0x5946	; 0x5946 <_helper_Words>
	_helper_Words (3,84,0,(Config.RX_mode == RX_mode_BuddyMode),PSTR("Buddy"),PSTR("UART "),5);
    5b36:	21 e0       	ldi	r18, 0x01	; 1
    5b38:	80 91 ef 06 	lds	r24, 0x06EF
    5b3c:	81 11       	cpse	r24, r1
    5b3e:	20 e0       	ldi	r18, 0x00	; 0
    5b40:	83 e0       	ldi	r24, 0x03	; 3
    5b42:	64 e5       	ldi	r22, 0x54	; 84
    5b44:	40 e0       	ldi	r20, 0x00	; 0
    5b46:	06 e4       	ldi	r16, 0x46	; 70
    5b48:	1d e0       	ldi	r17, 0x0D	; 13
    5b4a:	f0 e4       	ldi	r31, 0x40	; 64
    5b4c:	ef 2e       	mov	r14, r31
    5b4e:	fd e0       	ldi	r31, 0x0D	; 13
    5b50:	ff 2e       	mov	r15, r31
    5b52:	e5 e0       	ldi	r30, 0x05	; 5
    5b54:	ce 2e       	mov	r12, r30
    5b56:	0e 94 a3 2c 	call	0x5946	; 0x5946 <_helper_Words>
	
	_helper_DisplayRXStatus(5);
    5b5a:	85 e0       	ldi	r24, 0x05	; 5
    5b5c:	0e 94 9f 2a 	call	0x553e	; 0x553e <_helper_DisplayRXStatus>
	
		
	///////// Flying Mode
	LCD_SetPos (6,24);
    5b60:	86 e0       	ldi	r24, 0x06	; 6
    5b62:	68 e1       	ldi	r22, 0x18	; 24
    5b64:	0e 94 10 0c 	call	0x1820	; 0x1820 <LCD_SetPos>
	LCD_SelectFont (&font12x16);
    5b68:	89 e5       	ldi	r24, 0x59	; 89
    5b6a:	91 e0       	ldi	r25, 0x01	; 1
    5b6c:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <LCD_SelectFont>
	
	if (Config.QuadFlyingMode==QuadFlyingMode_X)
    5b70:	80 91 f6 06 	lds	r24, 0x06F6
    5b74:	81 30       	cpi	r24, 0x01	; 1
    5b76:	51 f4       	brne	.+20     	; 0x5b8c <_hHomePage+0x162>
	{
		if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    5b78:	80 91 f4 06 	lds	r24, 0x06F4
    5b7c:	81 30       	cpi	r24, 0x01	; 1
    5b7e:	19 f4       	brne	.+6      	; 0x5b86 <_hHomePage+0x15c>
		{
			LCD_WriteString_P(PSTR ("X"));
    5b80:	8e e3       	ldi	r24, 0x3E	; 62
    5b82:	9d e0       	ldi	r25, 0x0D	; 13
    5b84:	0c c0       	rjmp	.+24     	; 0x5b9e <_hHomePage+0x174>
		}
		else
		{
			LCD_WriteString_P(PSTR ("A"));
    5b86:	8c e3       	ldi	r24, 0x3C	; 60
    5b88:	9d e0       	ldi	r25, 0x0D	; 13
    5b8a:	09 c0       	rjmp	.+18     	; 0x5b9e <_hHomePage+0x174>
		}			
	}
	else
	{
		if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    5b8c:	80 91 f4 06 	lds	r24, 0x06F4
    5b90:	81 30       	cpi	r24, 0x01	; 1
    5b92:	19 f4       	brne	.+6      	; 0x5b9a <_hHomePage+0x170>
		{
			LCD_WriteString_P(PSTR ("+"));
    5b94:	8a e3       	ldi	r24, 0x3A	; 58
    5b96:	9d e0       	ldi	r25, 0x0D	; 13
    5b98:	02 c0       	rjmp	.+4      	; 0x5b9e <_hHomePage+0x174>
		}
		else
		{
			LCD_WriteString_P(PSTR ("Y"));
    5b9a:	88 e3       	ldi	r24, 0x38	; 56
    5b9c:	9d e0       	ldi	r25, 0x0D	; 13
    5b9e:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <LCD_WriteString_P>
		}			
	}
	
	LCD_SetPos (6,80);
    5ba2:	86 e0       	ldi	r24, 0x06	; 6
    5ba4:	60 e5       	ldi	r22, 0x50	; 80
    5ba6:	0e 94 10 0c 	call	0x1820	; 0x1820 <LCD_SetPos>
	LCD_SelectFont (&font12x16);
    5baa:	89 e5       	ldi	r24, 0x59	; 89
    5bac:	91 e0       	ldi	r25, 0x01	; 1
    5bae:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <LCD_SelectFont>
	if (Config.BoardOrientationMode==QuadFlyingMode_X)
    5bb2:	80 91 f5 06 	lds	r24, 0x06F5
    5bb6:	81 30       	cpi	r24, 0x01	; 1
    5bb8:	19 f4       	brne	.+6      	; 0x5bc0 <_hHomePage+0x196>
	{
		LCD_WriteString_P(PSTR ("X"));
    5bba:	86 e3       	ldi	r24, 0x36	; 54
    5bbc:	9d e0       	ldi	r25, 0x0D	; 13
    5bbe:	02 c0       	rjmp	.+4      	; 0x5bc4 <_hHomePage+0x19a>
	}
	else
	{
		LCD_WriteString_P(PSTR ("+"));
    5bc0:	84 e3       	ldi	r24, 0x34	; 52
    5bc2:	9d e0       	ldi	r25, 0x0D	; 13
    5bc4:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <LCD_WriteString_P>
	}
	LCD_SelectFont (NULL);
    5bc8:	80 e0       	ldi	r24, 0x00	; 0
    5bca:	90 e0       	ldi	r25, 0x00	; 0
    5bcc:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <LCD_SelectFont>
	///////
	UIEnableStickCommands=true;
    5bd0:	81 e0       	ldi	r24, 0x01	; 1
    5bd2:	80 93 e9 05 	sts	0x05E9, r24
	
}
    5bd6:	1f 91       	pop	r17
    5bd8:	0f 91       	pop	r16
    5bda:	ff 90       	pop	r15
    5bdc:	ef 90       	pop	r14
    5bde:	cf 90       	pop	r12
    5be0:	08 95       	ret

00005be2 <defaultHandler>:


void defaultHandler()
{
	
	if (editMode==true)
    5be2:	80 91 fc 07 	lds	r24, 0x07FC
    5be6:	81 30       	cpi	r24, 0x01	; 1
    5be8:	19 f4       	brne	.+6      	; 0x5bf0 <defaultHandler+0xe>
	{		// edit mode?
		editModeHandler();
    5bea:	0e 94 17 2e 	call	0x5c2e	; 0x5c2e <editModeHandler>
    5bee:	08 95       	ret
	}
	else
	{
		if (IS_INIT | IS_KEYREFRESH) 
    5bf0:	80 91 be 05 	lds	r24, 0x05BE
    5bf4:	90 e0       	ldi	r25, 0x00	; 0
    5bf6:	83 70       	andi	r24, 0x03	; 3
    5bf8:	90 70       	andi	r25, 0x00	; 0
    5bfa:	00 97       	sbiw	r24, 0x00	; 0
    5bfc:	81 f0       	breq	.+32     	; 0x5c1e <defaultHandler+0x3c>
		{
			LCD_Clear();
    5bfe:	0e 94 48 0c 	call	0x1890	; 0x1890 <LCD_Clear>
			// 1- display screen content
			if (currentPage.screen)
    5c02:	80 91 4a 05 	lds	r24, 0x054A
    5c06:	90 91 4b 05 	lds	r25, 0x054B
    5c0a:	00 97       	sbiw	r24, 0x00	; 0
    5c0c:	11 f0       	breq	.+4      	; 0x5c12 <defaultHandler+0x30>
				LCD_WriteString_P(currentPage.screen);
    5c0e:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <LCD_WriteString_P>
			// 2- Display control buttons... always be last to overwrite any graphics on it.
			writeSoftkeys(currentPage.softkeys);
    5c12:	80 91 46 05 	lds	r24, 0x0546
    5c16:	90 91 47 05 	lds	r25, 0x0547
    5c1a:	0e 94 92 28 	call	0x5124	; 0x5124 <writeSoftkeys>
			//LCD_SetPos(0, 0);
		}
		
		if (currentPage.handler)
    5c1e:	e0 91 48 05 	lds	r30, 0x0548
    5c22:	f0 91 49 05 	lds	r31, 0x0549
    5c26:	30 97       	sbiw	r30, 0x00	; 0
    5c28:	09 f0       	breq	.+2      	; 0x5c2c <defaultHandler+0x4a>
		{
			currentPage.handler();
    5c2a:	09 95       	icall
    5c2c:	08 95       	ret

00005c2e <editModeHandler>:
		subpage = (subpage + 1) % num;
}


void editModeHandler()
{
    5c2e:	0f 93       	push	r16
	if (KEY4)	// DONE;
    5c30:	80 91 be 05 	lds	r24, 0x05BE
    5c34:	84 ff       	sbrs	r24, 4
    5c36:	23 c0       	rjmp	.+70     	; 0x5c7e <editModeHandler+0x50>
	{
		editMode = false;
    5c38:	10 92 fc 07 	sts	0x07FC, r1
		_mykey = KEY_REFRESH;
    5c3c:	82 e0       	ldi	r24, 0x02	; 2
    5c3e:	80 93 be 05 	sts	0x05BE, r24
		
		if (editValueType == TYPE_UINT8)
    5c42:	80 91 fb 07 	lds	r24, 0x07FB
    5c46:	82 30       	cpi	r24, 0x02	; 2
    5c48:	11 f0       	breq	.+4      	; 0x5c4e <editModeHandler+0x20>
			*((uint8_t*)editValuePtr) = (uint8_t) editValue;
		else if (editValueType == TYPE_INT8)
    5c4a:	81 30       	cpi	r24, 0x01	; 1
    5c4c:	41 f4       	brne	.+16     	; 0x5c5e <editModeHandler+0x30>
			*((int8_t*)editValuePtr) = (int8_t) editValue;
    5c4e:	e0 91 f9 07 	lds	r30, 0x07F9
    5c52:	f0 91 fa 07 	lds	r31, 0x07FA
    5c56:	80 91 00 08 	lds	r24, 0x0800
    5c5a:	80 83       	st	Z, r24
    5c5c:	58 c0       	rjmp	.+176    	; 0x5d0e <editModeHandler+0xe0>
		else if (editValueType == TYPE_INT16)
    5c5e:	83 30       	cpi	r24, 0x03	; 3
    5c60:	19 f0       	breq	.+6      	; 0x5c68 <editModeHandler+0x3a>
			*(int16_t*)editValuePtr = (int16_t) editValue;
		else if (editValueType == TYPE_UINT16)
    5c62:	84 30       	cpi	r24, 0x04	; 4
    5c64:	09 f0       	breq	.+2      	; 0x5c68 <editModeHandler+0x3a>
    5c66:	53 c0       	rjmp	.+166    	; 0x5d0e <editModeHandler+0xe0>
			*(uint16_t*)editValuePtr =(uint16_t) editValue;
    5c68:	e0 91 f9 07 	lds	r30, 0x07F9
    5c6c:	f0 91 fa 07 	lds	r31, 0x07FA
    5c70:	80 91 00 08 	lds	r24, 0x0800
    5c74:	90 91 01 08 	lds	r25, 0x0801
    5c78:	91 83       	std	Z+1, r25	; 0x01
    5c7a:	80 83       	st	Z, r24
    5c7c:	48 c0       	rjmp	.+144    	; 0x5d0e <editModeHandler+0xe0>
		
		LCD_SelectFont(NULL);
		defaultHandler();
		return;
	}
	if (ANYKEY)
    5c7e:	88 23       	and	r24, r24
    5c80:	09 f4       	brne	.+2      	; 0x5c84 <editModeHandler+0x56>
    5c82:	56 c0       	rjmp	.+172    	; 0x5d30 <editModeHandler+0x102>
	{
		if (KEY2)	// DOWN?
    5c84:	86 ff       	sbrs	r24, 6
    5c86:	1b c0       	rjmp	.+54     	; 0x5cbe <editModeHandler+0x90>
		{
			
				if (_keyrepeat == KEYBOARD_REPEAT)
    5c88:	20 91 cf 05 	lds	r18, 0x05CF
    5c8c:	80 91 00 08 	lds	r24, 0x0800
    5c90:	90 91 01 08 	lds	r25, 0x0801
    5c94:	21 30       	cpi	r18, 0x01	; 1
    5c96:	11 f4       	brne	.+4      	; 0x5c9c <editModeHandler+0x6e>
				{
					editValue-=10;
    5c98:	0a 97       	sbiw	r24, 0x0a	; 10
    5c9a:	01 c0       	rjmp	.+2      	; 0x5c9e <editModeHandler+0x70>
				}
				else
				{
					editValue--;	
    5c9c:	01 97       	sbiw	r24, 0x01	; 1
    5c9e:	90 93 01 08 	sts	0x0801, r25
    5ca2:	80 93 00 08 	sts	0x0800, r24
				}
				
				if (editValue < editLoLimit)				
    5ca6:	80 91 fd 07 	lds	r24, 0x07FD
    5caa:	90 91 fe 07 	lds	r25, 0x07FE
    5cae:	20 91 00 08 	lds	r18, 0x0800
    5cb2:	30 91 01 08 	lds	r19, 0x0801
    5cb6:	28 17       	cp	r18, r24
    5cb8:	39 07       	cpc	r19, r25
    5cba:	84 f5       	brge	.+96     	; 0x5d1c <editModeHandler+0xee>
    5cbc:	1c c0       	rjmp	.+56     	; 0x5cf6 <editModeHandler+0xc8>
				{
					editValue = editLoLimit;
				}
		}
		else if (KEY3)	// UP?
    5cbe:	85 ff       	sbrs	r24, 5
    5cc0:	1f c0       	rjmp	.+62     	; 0x5d00 <editModeHandler+0xd2>
		{
				if (_keyrepeat == KEYBOARD_REPEAT)
    5cc2:	20 91 cf 05 	lds	r18, 0x05CF
    5cc6:	80 91 00 08 	lds	r24, 0x0800
    5cca:	90 91 01 08 	lds	r25, 0x0801
    5cce:	21 30       	cpi	r18, 0x01	; 1
    5cd0:	11 f4       	brne	.+4      	; 0x5cd6 <editModeHandler+0xa8>
				{
					editValue+=10;
    5cd2:	0a 96       	adiw	r24, 0x0a	; 10
    5cd4:	01 c0       	rjmp	.+2      	; 0x5cd8 <editModeHandler+0xaa>
				}
				else
				{
					editValue++;	
    5cd6:	01 96       	adiw	r24, 0x01	; 1
    5cd8:	90 93 01 08 	sts	0x0801, r25
    5cdc:	80 93 00 08 	sts	0x0800, r24
				}
				
				if (editValue > editHiLimit)
    5ce0:	80 91 f7 07 	lds	r24, 0x07F7
    5ce4:	90 91 f8 07 	lds	r25, 0x07F8
    5ce8:	20 91 00 08 	lds	r18, 0x0800
    5cec:	30 91 01 08 	lds	r19, 0x0801
    5cf0:	82 17       	cp	r24, r18
    5cf2:	93 07       	cpc	r25, r19
    5cf4:	9c f4       	brge	.+38     	; 0x5d1c <editModeHandler+0xee>
				{
					editValue=editHiLimit;
    5cf6:	90 93 01 08 	sts	0x0801, r25
    5cfa:	80 93 00 08 	sts	0x0800, r24
    5cfe:	0e c0       	rjmp	.+28     	; 0x5d1c <editModeHandler+0xee>
				}					
		}
		else if (KEY1)	// CLR?
    5d00:	87 ff       	sbrs	r24, 7
    5d02:	0c c0       	rjmp	.+24     	; 0x5d1c <editModeHandler+0xee>
		{
			editMode = false;
    5d04:	10 92 fc 07 	sts	0x07FC, r1
			_mykey = KEY_REFRESH;
    5d08:	82 e0       	ldi	r24, 0x02	; 2
    5d0a:	80 93 be 05 	sts	0x05BE, r24
	
			LCD_SelectFont(NULL);
    5d0e:	80 e0       	ldi	r24, 0x00	; 0
    5d10:	90 e0       	ldi	r25, 0x00	; 0
    5d12:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <LCD_SelectFont>
			defaultHandler();
    5d16:	0e 94 f1 2d 	call	0x5be2	; 0x5be2 <defaultHandler>
			return;	
    5d1a:	0a c0       	rjmp	.+20     	; 0x5d30 <editModeHandler+0x102>
		}
			
		LCD_WriteValue(2, 34, editValue, 5, -1);
    5d1c:	40 91 00 08 	lds	r20, 0x0800
    5d20:	50 91 01 08 	lds	r21, 0x0801
    5d24:	82 e0       	ldi	r24, 0x02	; 2
    5d26:	62 e2       	ldi	r22, 0x22	; 34
    5d28:	25 e0       	ldi	r18, 0x05	; 5
    5d2a:	0f ef       	ldi	r16, 0xFF	; 255
    5d2c:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <LCD_WriteValue>
	}
}
    5d30:	0f 91       	pop	r16
    5d32:	08 95       	ret

00005d34 <startEditMode>:

static void startEditMode(void* valuePtr, int16_t loLimit, int16_t hiLimit, uint8_t valueType)
{
    5d34:	0f 93       	push	r16
    5d36:	fc 01       	movw	r30, r24
	editMode = true;
    5d38:	81 e0       	ldi	r24, 0x01	; 1
    5d3a:	80 93 fc 07 	sts	0x07FC, r24
	_mykey = KEY_INIT;
    5d3e:	80 93 be 05 	sts	0x05BE, r24
	editValuePtr = valuePtr;
    5d42:	f0 93 fa 07 	sts	0x07FA, r31
    5d46:	e0 93 f9 07 	sts	0x07F9, r30
	editValueType = valueType;
    5d4a:	20 93 fb 07 	sts	0x07FB, r18
	
	if (valueType == TYPE_UINT8)
    5d4e:	22 30       	cpi	r18, 0x02	; 2
    5d50:	31 f4       	brne	.+12     	; 0x5d5e <startEditMode+0x2a>
		editValue = *(uint8_t*)valuePtr;
    5d52:	80 81       	ld	r24, Z
    5d54:	80 93 00 08 	sts	0x0800, r24
    5d58:	10 92 01 08 	sts	0x0801, r1
    5d5c:	11 c0       	rjmp	.+34     	; 0x5d80 <startEditMode+0x4c>
	else if (valueType == TYPE_INT8)
    5d5e:	21 30       	cpi	r18, 0x01	; 1
    5d60:	29 f4       	brne	.+10     	; 0x5d6c <startEditMode+0x38>
		editValue = *(int8_t*)valuePtr;
    5d62:	80 81       	ld	r24, Z
    5d64:	99 27       	eor	r25, r25
    5d66:	87 fd       	sbrc	r24, 7
    5d68:	90 95       	com	r25
    5d6a:	06 c0       	rjmp	.+12     	; 0x5d78 <startEditMode+0x44>
	else if (valueType == TYPE_INT16)
    5d6c:	23 30       	cpi	r18, 0x03	; 3
    5d6e:	11 f0       	breq	.+4      	; 0x5d74 <startEditMode+0x40>
 		editValue = *(int16_t*)valuePtr;
	else if (valueType == TYPE_UINT16)
    5d70:	24 30       	cpi	r18, 0x04	; 4
    5d72:	31 f4       	brne	.+12     	; 0x5d80 <startEditMode+0x4c>
 		editValue = *(uint16_t*)valuePtr;
    5d74:	80 81       	ld	r24, Z
    5d76:	91 81       	ldd	r25, Z+1	; 0x01
    5d78:	90 93 01 08 	sts	0x0801, r25
    5d7c:	80 93 00 08 	sts	0x0800, r24
	
	editLoLimit = loLimit;
    5d80:	70 93 fe 07 	sts	0x07FE, r23
    5d84:	60 93 fd 07 	sts	0x07FD, r22
	editHiLimit = hiLimit;
    5d88:	50 93 f8 07 	sts	0x07F8, r21
    5d8c:	40 93 f7 07 	sts	0x07F7, r20
	
	LCD_FillRectangle(30, 11, 98, 34, 0);
    5d90:	8e e1       	ldi	r24, 0x1E	; 30
    5d92:	6b e0       	ldi	r22, 0x0B	; 11
    5d94:	42 e6       	ldi	r20, 0x62	; 98
    5d96:	22 e2       	ldi	r18, 0x22	; 34
    5d98:	00 e0       	ldi	r16, 0x00	; 0
    5d9a:	0e 94 47 0c 	call	0x188e	; 0x188e <LCD_FillRectangle>
	LCD_Rectangle(30, 11, 98, 34, 1);
    5d9e:	8e e1       	ldi	r24, 0x1E	; 30
    5da0:	6b e0       	ldi	r22, 0x0B	; 11
    5da2:	42 e6       	ldi	r20, 0x62	; 98
    5da4:	22 e2       	ldi	r18, 0x22	; 34
    5da6:	01 e0       	ldi	r16, 0x01	; 1
    5da8:	0e 94 46 0c 	call	0x188c	; 0x188c <LCD_Rectangle>
	LCD_Rectangle(31, 12, 97, 33, 1);
    5dac:	8f e1       	ldi	r24, 0x1F	; 31
    5dae:	6c e0       	ldi	r22, 0x0C	; 12
    5db0:	41 e6       	ldi	r20, 0x61	; 97
    5db2:	21 e2       	ldi	r18, 0x21	; 33
    5db4:	0e 94 46 0c 	call	0x188c	; 0x188c <LCD_Rectangle>
	writeSoftkeys(_skEDIT);
    5db8:	87 e3       	ldi	r24, 0x37	; 55
    5dba:	9c e0       	ldi	r25, 0x0C	; 12
    5dbc:	0e 94 92 28 	call	0x5124	; 0x5124 <writeSoftkeys>
	LCD_SelectFont(&font12x16);
    5dc0:	89 e5       	ldi	r24, 0x59	; 89
    5dc2:	91 e0       	ldi	r25, 0x01	; 1
    5dc4:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <LCD_SelectFont>
	editModeHandler();
    5dc8:	0e 94 17 2e 	call	0x5c2e	; 0x5c2e <editModeHandler>
}
    5dcc:	0f 91       	pop	r16
    5dce:	08 95       	ret

00005dd0 <PageKey>:
}


void PageKey(const uint8_t num)
{
	if (KEY2)	// PREV
    5dd0:	90 91 be 05 	lds	r25, 0x05BE
    5dd4:	96 ff       	sbrs	r25, 6
    5dd6:	08 c0       	rjmp	.+16     	; 0x5de8 <PageKey+0x18>
		subpage = subpage == 0 ? num - 1 : subpage - 1;
    5dd8:	60 91 3c 05 	lds	r22, 0x053C
    5ddc:	61 11       	cpse	r22, r1
    5dde:	86 2f       	mov	r24, r22
    5de0:	81 50       	subi	r24, 0x01	; 1
    5de2:	80 93 3c 05 	sts	0x053C, r24
    5de6:	08 95       	ret
	else if (KEY3) // NEXT
    5de8:	95 ff       	sbrs	r25, 5
    5dea:	0c c0       	rjmp	.+24     	; 0x5e04 <PageKey+0x34>
		subpage = (subpage + 1) % num;
    5dec:	20 91 3c 05 	lds	r18, 0x053C
    5df0:	30 e0       	ldi	r19, 0x00	; 0
    5df2:	2f 5f       	subi	r18, 0xFF	; 255
    5df4:	3f 4f       	sbci	r19, 0xFF	; 255
    5df6:	68 2f       	mov	r22, r24
    5df8:	c9 01       	movw	r24, r18
    5dfa:	70 e0       	ldi	r23, 0x00	; 0
    5dfc:	0e 94 61 38 	call	0x70c2	; 0x70c2 <__divmodhi4>
    5e00:	80 93 3c 05 	sts	0x053C, r24
    5e04:	08 95       	ret

00005e06 <_hAltitudeHold>:




void _hAltitudeHold()
{
    5e06:	0f 93       	push	r16
	
	NOKEYRETURN;
    5e08:	80 91 be 05 	lds	r24, 0x05BE
    5e0c:	88 23       	and	r24, r24
    5e0e:	09 f4       	brne	.+2      	; 0x5e12 <_hAltitudeHold+0xc>
    5e10:	a2 c0       	rjmp	.+324    	; 0x5f56 <_hAltitudeHold+0x150>
	PageKey(6);
    5e12:	86 e0       	ldi	r24, 0x06	; 6
    5e14:	0e 94 e8 2e 	call	0x5dd0	; 0x5dd0 <PageKey>
	
	
	if (KEY4)
    5e18:	20 91 be 05 	lds	r18, 0x05BE
    5e1c:	24 ff       	sbrs	r18, 4
    5e1e:	36 c0       	rjmp	.+108    	; 0x5e8c <_hAltitudeHold+0x86>
	{
		bValueChanged = true;
    5e20:	81 e0       	ldi	r24, 0x01	; 1
    5e22:	80 93 38 05 	sts	0x0538, r24
		currentPage.softkeys = _skMENUSAVE;
    5e26:	80 e1       	ldi	r24, 0x10	; 16
    5e28:	9c e0       	ldi	r25, 0x0C	; 12
    5e2a:	90 93 47 05 	sts	0x0547, r25
    5e2e:	80 93 46 05 	sts	0x0546, r24
		switch (subpage)
    5e32:	80 91 3c 05 	lds	r24, 0x053C
    5e36:	82 30       	cpi	r24, 0x02	; 2
    5e38:	a1 f0       	breq	.+40     	; 0x5e62 <_hAltitudeHold+0x5c>
    5e3a:	83 30       	cpi	r24, 0x03	; 3
    5e3c:	28 f4       	brcc	.+10     	; 0x5e48 <_hAltitudeHold+0x42>
    5e3e:	88 23       	and	r24, r24
    5e40:	51 f0       	breq	.+20     	; 0x5e56 <_hAltitudeHold+0x50>
    5e42:	81 30       	cpi	r24, 0x01	; 1
    5e44:	19 f5       	brne	.+70     	; 0x5e8c <_hAltitudeHold+0x86>
    5e46:	0a c0       	rjmp	.+20     	; 0x5e5c <_hAltitudeHold+0x56>
    5e48:	84 30       	cpi	r24, 0x04	; 4
    5e4a:	89 f0       	breq	.+34     	; 0x5e6e <_hAltitudeHold+0x68>
    5e4c:	84 30       	cpi	r24, 0x04	; 4
    5e4e:	60 f0       	brcs	.+24     	; 0x5e68 <_hAltitudeHold+0x62>
    5e50:	85 30       	cpi	r24, 0x05	; 5
    5e52:	e1 f4       	brne	.+56     	; 0x5e8c <_hAltitudeHold+0x86>
    5e54:	11 c0       	rjmp	.+34     	; 0x5e78 <_hAltitudeHold+0x72>
		{
			case 0: startEditMode(&(Config.SonarParams[0]._P),-500,500,TYPE_INT16); return ;
    5e56:	8f e4       	ldi	r24, 0x4F	; 79
    5e58:	97 e0       	ldi	r25, 0x07	; 7
    5e5a:	0b c0       	rjmp	.+22     	; 0x5e72 <_hAltitudeHold+0x6c>
			case 1: startEditMode(&(Config.SonarParams[0]._PLimit),0,500,TYPE_INT16); return ;
    5e5c:	81 e5       	ldi	r24, 0x51	; 81
    5e5e:	97 e0       	ldi	r25, 0x07	; 7
    5e60:	0d c0       	rjmp	.+26     	; 0x5e7c <_hAltitudeHold+0x76>
			case 2: startEditMode(&(Config.SonarParams[0]._I),-500,500,TYPE_INT16);  return ;
    5e62:	83 e5       	ldi	r24, 0x53	; 83
    5e64:	97 e0       	ldi	r25, 0x07	; 7
    5e66:	05 c0       	rjmp	.+10     	; 0x5e72 <_hAltitudeHold+0x6c>
			case 3: startEditMode(&(Config.SonarParams[0]._ILimit),0,500,TYPE_INT16); return ;
    5e68:	85 e5       	ldi	r24, 0x55	; 85
    5e6a:	97 e0       	ldi	r25, 0x07	; 7
    5e6c:	07 c0       	rjmp	.+14     	; 0x5e7c <_hAltitudeHold+0x76>
			case 4: startEditMode(&(Config.SonarParams[0]._D),-500,500,TYPE_INT16);  return ; // negative D
    5e6e:	87 e5       	ldi	r24, 0x57	; 87
    5e70:	97 e0       	ldi	r25, 0x07	; 7
    5e72:	6c e0       	ldi	r22, 0x0C	; 12
    5e74:	7e ef       	ldi	r23, 0xFE	; 254
    5e76:	04 c0       	rjmp	.+8      	; 0x5e80 <_hAltitudeHold+0x7a>
			case 5: startEditMode(&(Config.SonarParams[0]._DLimit),0,500,TYPE_INT16); return ;
    5e78:	89 e5       	ldi	r24, 0x59	; 89
    5e7a:	97 e0       	ldi	r25, 0x07	; 7
    5e7c:	60 e0       	ldi	r22, 0x00	; 0
    5e7e:	70 e0       	ldi	r23, 0x00	; 0
    5e80:	44 ef       	ldi	r20, 0xF4	; 244
    5e82:	51 e0       	ldi	r21, 0x01	; 1
    5e84:	23 e0       	ldi	r18, 0x03	; 3
    5e86:	0e 94 9a 2e 	call	0x5d34	; 0x5d34 <startEditMode>
    5e8a:	65 c0       	rjmp	.+202    	; 0x5f56 <_hAltitudeHold+0x150>
		}
	}
	
	if (KEY1)
    5e8c:	27 ff       	sbrs	r18, 7
    5e8e:	02 c0       	rjmp	.+4      	; 0x5e94 <_hAltitudeHold+0x8e>
	{
		_helper_SaveinEEPROM_ifChanged();
    5e90:	0e 94 96 2a 	call	0x552c	; 0x552c <_helper_SaveinEEPROM_ifChanged>
	}
	
	LCD_WriteValue(1,30,Config.SonarParams[0]._P,3,0==subpage);
    5e94:	40 91 4f 07 	lds	r20, 0x074F
    5e98:	50 91 50 07 	lds	r21, 0x0750
    5e9c:	01 e0       	ldi	r16, 0x01	; 1
    5e9e:	80 91 3c 05 	lds	r24, 0x053C
    5ea2:	81 11       	cpse	r24, r1
    5ea4:	00 e0       	ldi	r16, 0x00	; 0
    5ea6:	81 e0       	ldi	r24, 0x01	; 1
    5ea8:	6e e1       	ldi	r22, 0x1E	; 30
    5eaa:	23 e0       	ldi	r18, 0x03	; 3
    5eac:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <LCD_WriteValue>
	LCD_WriteValue(1,84,Config.SonarParams[0]._PLimit,3,1==subpage);
    5eb0:	40 91 51 07 	lds	r20, 0x0751
    5eb4:	50 91 52 07 	lds	r21, 0x0752
    5eb8:	01 e0       	ldi	r16, 0x01	; 1
    5eba:	80 91 3c 05 	lds	r24, 0x053C
    5ebe:	81 30       	cpi	r24, 0x01	; 1
    5ec0:	09 f0       	breq	.+2      	; 0x5ec4 <_hAltitudeHold+0xbe>
    5ec2:	00 e0       	ldi	r16, 0x00	; 0
    5ec4:	81 e0       	ldi	r24, 0x01	; 1
    5ec6:	64 e5       	ldi	r22, 0x54	; 84
    5ec8:	23 e0       	ldi	r18, 0x03	; 3
    5eca:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <LCD_WriteValue>
	LCD_WriteValue(2,30,Config.SonarParams[0]._I,3,2==subpage);
    5ece:	40 91 53 07 	lds	r20, 0x0753
    5ed2:	50 91 54 07 	lds	r21, 0x0754
    5ed6:	01 e0       	ldi	r16, 0x01	; 1
    5ed8:	80 91 3c 05 	lds	r24, 0x053C
    5edc:	82 30       	cpi	r24, 0x02	; 2
    5ede:	09 f0       	breq	.+2      	; 0x5ee2 <_hAltitudeHold+0xdc>
    5ee0:	00 e0       	ldi	r16, 0x00	; 0
    5ee2:	82 e0       	ldi	r24, 0x02	; 2
    5ee4:	6e e1       	ldi	r22, 0x1E	; 30
    5ee6:	23 e0       	ldi	r18, 0x03	; 3
    5ee8:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <LCD_WriteValue>
	LCD_WriteValue(2,84,Config.SonarParams[0]._ILimit,3,3==subpage);
    5eec:	40 91 55 07 	lds	r20, 0x0755
    5ef0:	50 91 56 07 	lds	r21, 0x0756
    5ef4:	01 e0       	ldi	r16, 0x01	; 1
    5ef6:	80 91 3c 05 	lds	r24, 0x053C
    5efa:	83 30       	cpi	r24, 0x03	; 3
    5efc:	09 f0       	breq	.+2      	; 0x5f00 <_hAltitudeHold+0xfa>
    5efe:	00 e0       	ldi	r16, 0x00	; 0
    5f00:	82 e0       	ldi	r24, 0x02	; 2
    5f02:	64 e5       	ldi	r22, 0x54	; 84
    5f04:	23 e0       	ldi	r18, 0x03	; 3
    5f06:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <LCD_WriteValue>
	LCD_WriteValue(3,30,Config.SonarParams[0]._D,3,4==subpage);
    5f0a:	40 91 57 07 	lds	r20, 0x0757
    5f0e:	50 91 58 07 	lds	r21, 0x0758
    5f12:	01 e0       	ldi	r16, 0x01	; 1
    5f14:	80 91 3c 05 	lds	r24, 0x053C
    5f18:	84 30       	cpi	r24, 0x04	; 4
    5f1a:	09 f0       	breq	.+2      	; 0x5f1e <_hAltitudeHold+0x118>
    5f1c:	00 e0       	ldi	r16, 0x00	; 0
    5f1e:	83 e0       	ldi	r24, 0x03	; 3
    5f20:	6e e1       	ldi	r22, 0x1E	; 30
    5f22:	23 e0       	ldi	r18, 0x03	; 3
    5f24:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <LCD_WriteValue>
	LCD_WriteValue(3,84,Config.SonarParams[0]._DLimit,3,5==subpage);
    5f28:	40 91 59 07 	lds	r20, 0x0759
    5f2c:	50 91 5a 07 	lds	r21, 0x075A
    5f30:	01 e0       	ldi	r16, 0x01	; 1
    5f32:	80 91 3c 05 	lds	r24, 0x053C
    5f36:	85 30       	cpi	r24, 0x05	; 5
    5f38:	09 f0       	breq	.+2      	; 0x5f3c <_hAltitudeHold+0x136>
    5f3a:	00 e0       	ldi	r16, 0x00	; 0
    5f3c:	83 e0       	ldi	r24, 0x03	; 3
    5f3e:	64 e5       	ldi	r22, 0x54	; 84
    5f40:	23 e0       	ldi	r18, 0x03	; 3
    5f42:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <LCD_WriteValue>
	LCD_WriteString_Pex(5,0,PSTR("                "),16,false);    
    5f46:	85 e0       	ldi	r24, 0x05	; 5
    5f48:	60 e0       	ldi	r22, 0x00	; 0
    5f4a:	46 e2       	ldi	r20, 0x26	; 38
    5f4c:	5c e0       	ldi	r21, 0x0C	; 12
    5f4e:	20 e1       	ldi	r18, 0x10	; 16
    5f50:	00 e0       	ldi	r16, 0x00	; 0
    5f52:	0e 94 95 0d 	call	0x1b2a	; 0x1b2a <LCD_WriteString_Pex>
				
}
    5f56:	0f 91       	pop	r16
    5f58:	08 95       	ret

00005f5a <_hSelfLeveling>:
}



void _hSelfLeveling()
{
    5f5a:	0f 93       	push	r16
	NOKEYRETURN;
    5f5c:	80 91 be 05 	lds	r24, 0x05BE
    5f60:	88 23       	and	r24, r24
    5f62:	09 f4       	brne	.+2      	; 0x5f66 <_hSelfLeveling+0xc>
    5f64:	ff c1       	rjmp	.+1022   	; 0x6364 <_hSelfLeveling+0x40a>
	PageKey(10);
    5f66:	8a e0       	ldi	r24, 0x0A	; 10
    5f68:	0e 94 e8 2e 	call	0x5dd0	; 0x5dd0 <PageKey>
	
	if ((subindex==2) && (subpage>7)) subpage=0;
    5f6c:	80 91 3d 05 	lds	r24, 0x053D
    5f70:	82 30       	cpi	r24, 0x02	; 2
    5f72:	31 f4       	brne	.+12     	; 0x5f80 <_hSelfLeveling+0x26>
    5f74:	80 91 3c 05 	lds	r24, 0x053C
    5f78:	88 30       	cpi	r24, 0x08	; 8
    5f7a:	10 f0       	brcs	.+4      	; 0x5f80 <_hSelfLeveling+0x26>
    5f7c:	10 92 3c 05 	sts	0x053C, r1
		
	
	
	if (KEY4)
    5f80:	80 91 be 05 	lds	r24, 0x05BE
    5f84:	84 ff       	sbrs	r24, 4
    5f86:	d6 c0       	rjmp	.+428    	; 0x6134 <_hSelfLeveling+0x1da>
	{
		if (subpage!=0) bValueChanged = true;
    5f88:	20 91 3c 05 	lds	r18, 0x053C
    5f8c:	22 23       	and	r18, r18
    5f8e:	19 f0       	breq	.+6      	; 0x5f96 <_hSelfLeveling+0x3c>
    5f90:	81 e0       	ldi	r24, 0x01	; 1
    5f92:	80 93 38 05 	sts	0x0538, r24
		currentPage.softkeys = _skMENUSAVE;
    5f96:	80 e1       	ldi	r24, 0x10	; 16
    5f98:	9c e0       	ldi	r25, 0x0C	; 12
    5f9a:	90 93 47 05 	sts	0x0547, r25
    5f9e:	80 93 46 05 	sts	0x0546, r24
		
		switch (subpage)
    5fa2:	24 30       	cpi	r18, 0x04	; 4
    5fa4:	09 f4       	brne	.+2      	; 0x5fa8 <_hSelfLeveling+0x4e>
    5fa6:	6e c0       	rjmp	.+220    	; 0x6084 <_hSelfLeveling+0x12a>
    5fa8:	25 30       	cpi	r18, 0x05	; 5
    5faa:	58 f4       	brcc	.+22     	; 0x5fc2 <_hSelfLeveling+0x68>
    5fac:	21 30       	cpi	r18, 0x01	; 1
    5fae:	99 f1       	breq	.+102    	; 0x6016 <_hSelfLeveling+0xbc>
    5fb0:	21 30       	cpi	r18, 0x01	; 1
    5fb2:	d0 f0       	brcs	.+52     	; 0x5fe8 <_hSelfLeveling+0x8e>
    5fb4:	22 30       	cpi	r18, 0x02	; 2
    5fb6:	09 f4       	brne	.+2      	; 0x5fba <_hSelfLeveling+0x60>
    5fb8:	3f c0       	rjmp	.+126    	; 0x6038 <_hSelfLeveling+0xde>
    5fba:	23 30       	cpi	r18, 0x03	; 3
    5fbc:	09 f0       	breq	.+2      	; 0x5fc0 <_hSelfLeveling+0x66>
    5fbe:	ba c0       	rjmp	.+372    	; 0x6134 <_hSelfLeveling+0x1da>
    5fc0:	50 c0       	rjmp	.+160    	; 0x6062 <_hSelfLeveling+0x108>
    5fc2:	27 30       	cpi	r18, 0x07	; 7
    5fc4:	09 f4       	brne	.+2      	; 0x5fc8 <_hSelfLeveling+0x6e>
    5fc6:	93 c0       	rjmp	.+294    	; 0x60ee <_hSelfLeveling+0x194>
    5fc8:	28 30       	cpi	r18, 0x08	; 8
    5fca:	38 f4       	brcc	.+14     	; 0x5fda <_hSelfLeveling+0x80>
    5fcc:	25 30       	cpi	r18, 0x05	; 5
    5fce:	09 f4       	brne	.+2      	; 0x5fd2 <_hSelfLeveling+0x78>
    5fd0:	6a c0       	rjmp	.+212    	; 0x60a6 <_hSelfLeveling+0x14c>
    5fd2:	26 30       	cpi	r18, 0x06	; 6
    5fd4:	09 f0       	breq	.+2      	; 0x5fd8 <_hSelfLeveling+0x7e>
    5fd6:	ae c0       	rjmp	.+348    	; 0x6134 <_hSelfLeveling+0x1da>
    5fd8:	79 c0       	rjmp	.+242    	; 0x60cc <_hSelfLeveling+0x172>
    5fda:	28 30       	cpi	r18, 0x08	; 8
    5fdc:	09 f4       	brne	.+2      	; 0x5fe0 <_hSelfLeveling+0x86>
    5fde:	9d c0       	rjmp	.+314    	; 0x611a <_hSelfLeveling+0x1c0>
    5fe0:	29 30       	cpi	r18, 0x09	; 9
    5fe2:	09 f0       	breq	.+2      	; 0x5fe6 <_hSelfLeveling+0x8c>
    5fe4:	a7 c0       	rjmp	.+334    	; 0x6134 <_hSelfLeveling+0x1da>
    5fe6:	9c c0       	rjmp	.+312    	; 0x6120 <_hSelfLeveling+0x1c6>
		{
			case 0: _helper_SwitchPitchRollYaw(&subindex); 
    5fe8:	8d e3       	ldi	r24, 0x3D	; 61
    5fea:	95 e0       	ldi	r25, 0x05	; 5
    5fec:	0e 94 56 2a 	call	0x54ac	; 0x54ac <_helper_SwitchPitchRollYaw>
					if (subindex==2) 
    5ff0:	80 91 3d 05 	lds	r24, 0x053D
    5ff4:	82 30       	cpi	r24, 0x02	; 2
    5ff6:	31 f4       	brne	.+12     	; 0x6004 <_hSelfLeveling+0xaa>
					{
						LCD_WriteString_Pex(5,0,PSTR("                "),16,false);    
    5ff8:	85 e0       	ldi	r24, 0x05	; 5
    5ffa:	60 e0       	ldi	r22, 0x00	; 0
    5ffc:	49 e6       	ldi	r20, 0x69	; 105
    5ffe:	5c e0       	ldi	r21, 0x0C	; 12
    6000:	20 e1       	ldi	r18, 0x10	; 16
    6002:	05 c0       	rjmp	.+10     	; 0x600e <_hSelfLeveling+0xb4>
					}
					else
					{
						LCD_WriteString_Pex(5,0,PSTR("Trim P:    R:"),13,false);
    6004:	85 e0       	ldi	r24, 0x05	; 5
    6006:	60 e0       	ldi	r22, 0x00	; 0
    6008:	4b e5       	ldi	r20, 0x5B	; 91
    600a:	5c e0       	ldi	r21, 0x0C	; 12
    600c:	2d e0       	ldi	r18, 0x0D	; 13
    600e:	00 e0       	ldi	r16, 0x00	; 0
    6010:	0e 94 95 0d 	call	0x1b2a	; 0x1b2a <LCD_WriteString_Pex>
    6014:	8f c0       	rjmp	.+286    	; 0x6134 <_hSelfLeveling+0x1da>
					}				
					break;		
			case 1: startEditMode(&(Config.AccParams[subindex]._P),-500,500,TYPE_INT16); return ;
    6016:	80 91 3d 05 	lds	r24, 0x053D
    601a:	90 e0       	ldi	r25, 0x00	; 0
    601c:	9c 01       	movw	r18, r24
    601e:	22 0f       	add	r18, r18
    6020:	33 1f       	adc	r19, r19
    6022:	c9 01       	movw	r24, r18
    6024:	e3 e0       	ldi	r30, 0x03	; 3
    6026:	88 0f       	add	r24, r24
    6028:	99 1f       	adc	r25, r25
    602a:	ea 95       	dec	r30
    602c:	e1 f7       	brne	.-8      	; 0x6026 <_hSelfLeveling+0xcc>
    602e:	82 1b       	sub	r24, r18
    6030:	93 0b       	sbc	r25, r19
    6032:	8b 5d       	subi	r24, 0xDB	; 219
    6034:	98 4f       	sbci	r25, 0xF8	; 248
    6036:	47 c0       	rjmp	.+142    	; 0x60c6 <_hSelfLeveling+0x16c>
			case 2: startEditMode(&(Config.AccParams[subindex]._PLimit),0,500,TYPE_INT16); return ;
    6038:	80 91 3d 05 	lds	r24, 0x053D
    603c:	90 e0       	ldi	r25, 0x00	; 0
    603e:	9c 01       	movw	r18, r24
    6040:	22 0f       	add	r18, r18
    6042:	33 1f       	adc	r19, r19
    6044:	c9 01       	movw	r24, r18
    6046:	63 e0       	ldi	r22, 0x03	; 3
    6048:	88 0f       	add	r24, r24
    604a:	99 1f       	adc	r25, r25
    604c:	6a 95       	dec	r22
    604e:	e1 f7       	brne	.-8      	; 0x6048 <_hSelfLeveling+0xee>
    6050:	82 1b       	sub	r24, r18
    6052:	93 0b       	sbc	r25, r19
    6054:	89 5d       	subi	r24, 0xD9	; 217
    6056:	98 4f       	sbci	r25, 0xF8	; 248
    6058:	60 e0       	ldi	r22, 0x00	; 0
    605a:	70 e0       	ldi	r23, 0x00	; 0
    605c:	44 ef       	ldi	r20, 0xF4	; 244
    605e:	51 e0       	ldi	r21, 0x01	; 1
    6060:	5a c0       	rjmp	.+180    	; 0x6116 <_hSelfLeveling+0x1bc>
			case 3: startEditMode(&(Config.AccParams[subindex]._I),-500,500,TYPE_INT16);  return ;
    6062:	80 91 3d 05 	lds	r24, 0x053D
    6066:	90 e0       	ldi	r25, 0x00	; 0
    6068:	9c 01       	movw	r18, r24
    606a:	22 0f       	add	r18, r18
    606c:	33 1f       	adc	r19, r19
    606e:	c9 01       	movw	r24, r18
    6070:	43 e0       	ldi	r20, 0x03	; 3
    6072:	88 0f       	add	r24, r24
    6074:	99 1f       	adc	r25, r25
    6076:	4a 95       	dec	r20
    6078:	e1 f7       	brne	.-8      	; 0x6072 <_hSelfLeveling+0x118>
    607a:	82 1b       	sub	r24, r18
    607c:	93 0b       	sbc	r25, r19
    607e:	87 5d       	subi	r24, 0xD7	; 215
    6080:	98 4f       	sbci	r25, 0xF8	; 248
    6082:	21 c0       	rjmp	.+66     	; 0x60c6 <_hSelfLeveling+0x16c>
			case 4: startEditMode(&(Config.AccParams[subindex]._ILimit),0,500,TYPE_INT16); return ;
    6084:	80 91 3d 05 	lds	r24, 0x053D
    6088:	90 e0       	ldi	r25, 0x00	; 0
    608a:	9c 01       	movw	r18, r24
    608c:	22 0f       	add	r18, r18
    608e:	33 1f       	adc	r19, r19
    6090:	c9 01       	movw	r24, r18
    6092:	b3 e0       	ldi	r27, 0x03	; 3
    6094:	88 0f       	add	r24, r24
    6096:	99 1f       	adc	r25, r25
    6098:	ba 95       	dec	r27
    609a:	e1 f7       	brne	.-8      	; 0x6094 <_hSelfLeveling+0x13a>
    609c:	82 1b       	sub	r24, r18
    609e:	93 0b       	sbc	r25, r19
    60a0:	85 5d       	subi	r24, 0xD5	; 213
    60a2:	98 4f       	sbci	r25, 0xF8	; 248
    60a4:	d9 cf       	rjmp	.-78     	; 0x6058 <_hSelfLeveling+0xfe>
			case 5: startEditMode(&(Config.AccParams[subindex]._D),-500,500,TYPE_INT16);  return ; // negative D
    60a6:	80 91 3d 05 	lds	r24, 0x053D
    60aa:	90 e0       	ldi	r25, 0x00	; 0
    60ac:	9c 01       	movw	r18, r24
    60ae:	22 0f       	add	r18, r18
    60b0:	33 1f       	adc	r19, r19
    60b2:	c9 01       	movw	r24, r18
    60b4:	f3 e0       	ldi	r31, 0x03	; 3
    60b6:	88 0f       	add	r24, r24
    60b8:	99 1f       	adc	r25, r25
    60ba:	fa 95       	dec	r31
    60bc:	e1 f7       	brne	.-8      	; 0x60b6 <_hSelfLeveling+0x15c>
    60be:	82 1b       	sub	r24, r18
    60c0:	93 0b       	sbc	r25, r19
    60c2:	83 5d       	subi	r24, 0xD3	; 211
    60c4:	98 4f       	sbci	r25, 0xF8	; 248
    60c6:	6c e0       	ldi	r22, 0x0C	; 12
    60c8:	7e ef       	ldi	r23, 0xFE	; 254
    60ca:	c8 cf       	rjmp	.-112    	; 0x605c <_hSelfLeveling+0x102>
			case 6: startEditMode(&(Config.AccParams[subindex]._DLimit),0,500,TYPE_INT16); return ;
    60cc:	80 91 3d 05 	lds	r24, 0x053D
    60d0:	90 e0       	ldi	r25, 0x00	; 0
    60d2:	9c 01       	movw	r18, r24
    60d4:	22 0f       	add	r18, r18
    60d6:	33 1f       	adc	r19, r19
    60d8:	c9 01       	movw	r24, r18
    60da:	73 e0       	ldi	r23, 0x03	; 3
    60dc:	88 0f       	add	r24, r24
    60de:	99 1f       	adc	r25, r25
    60e0:	7a 95       	dec	r23
    60e2:	e1 f7       	brne	.-8      	; 0x60dc <_hSelfLeveling+0x182>
    60e4:	82 1b       	sub	r24, r18
    60e6:	93 0b       	sbc	r25, r19
    60e8:	81 5d       	subi	r24, 0xD1	; 209
    60ea:	98 4f       	sbci	r25, 0xF8	; 248
    60ec:	b5 cf       	rjmp	.-150    	; 0x6058 <_hSelfLeveling+0xfe>
			case 7: startEditMode(&(Config.AccParams[subindex].ComplementaryFilterAlpha),0,999,TYPE_INT16); return ;
    60ee:	80 91 3d 05 	lds	r24, 0x053D
    60f2:	90 e0       	ldi	r25, 0x00	; 0
    60f4:	9c 01       	movw	r18, r24
    60f6:	22 0f       	add	r18, r18
    60f8:	33 1f       	adc	r19, r19
    60fa:	c9 01       	movw	r24, r18
    60fc:	53 e0       	ldi	r21, 0x03	; 3
    60fe:	88 0f       	add	r24, r24
    6100:	99 1f       	adc	r25, r25
    6102:	5a 95       	dec	r21
    6104:	e1 f7       	brne	.-8      	; 0x60fe <_hSelfLeveling+0x1a4>
    6106:	82 1b       	sub	r24, r18
    6108:	93 0b       	sbc	r25, r19
    610a:	8f 5c       	subi	r24, 0xCF	; 207
    610c:	98 4f       	sbci	r25, 0xF8	; 248
    610e:	60 e0       	ldi	r22, 0x00	; 0
    6110:	70 e0       	ldi	r23, 0x00	; 0
    6112:	47 ee       	ldi	r20, 0xE7	; 231
    6114:	53 e0       	ldi	r21, 0x03	; 3
    6116:	23 e0       	ldi	r18, 0x03	; 3
    6118:	0a c0       	rjmp	.+20     	; 0x612e <_hSelfLeveling+0x1d4>
			case 8: startEditMode(&(Config.Acc_Pitch_Trim),-25,25,TYPE_INT8);  return ; 
    611a:	8e e5       	ldi	r24, 0x5E	; 94
    611c:	97 e0       	ldi	r25, 0x07	; 7
    611e:	02 c0       	rjmp	.+4      	; 0x6124 <_hSelfLeveling+0x1ca>
			case 9: startEditMode(&(Config.Acc_Roll_Trim),-25,25,TYPE_INT8); return ;
    6120:	8f e5       	ldi	r24, 0x5F	; 95
    6122:	97 e0       	ldi	r25, 0x07	; 7
    6124:	67 ee       	ldi	r22, 0xE7	; 231
    6126:	7f ef       	ldi	r23, 0xFF	; 255
    6128:	49 e1       	ldi	r20, 0x19	; 25
    612a:	50 e0       	ldi	r21, 0x00	; 0
    612c:	21 e0       	ldi	r18, 0x01	; 1
    612e:	0e 94 9a 2e 	call	0x5d34	; 0x5d34 <startEditMode>
    6132:	18 c1       	rjmp	.+560    	; 0x6364 <_hSelfLeveling+0x40a>
		}
	}
	
	if (KEY1)
    6134:	80 91 be 05 	lds	r24, 0x05BE
    6138:	87 ff       	sbrs	r24, 7
    613a:	0f c0       	rjmp	.+30     	; 0x615a <_hSelfLeveling+0x200>
	{
		if (Config.PitchRollLinked==1)
    613c:	80 91 b3 07 	lds	r24, 0x07B3
    6140:	81 30       	cpi	r24, 0x01	; 1
    6142:	49 f4       	brne	.+18     	; 0x6156 <_hSelfLeveling+0x1fc>
		{ 
			memcpy(&(Config.AccParams[ROLL_INDEX]),&(Config.AccParams[PITCH_INDEX]), sizeof(pid_param_t));
    6144:	e3 e3       	ldi	r30, 0x33	; 51
    6146:	f7 e0       	ldi	r31, 0x07	; 7
    6148:	df 01       	movw	r26, r30
    614a:	1e 97       	sbiw	r26, 0x0e	; 14
    614c:	8e e0       	ldi	r24, 0x0E	; 14
    614e:	0d 90       	ld	r0, X+
    6150:	01 92       	st	Z+, r0
    6152:	81 50       	subi	r24, 0x01	; 1
    6154:	e1 f7       	brne	.-8      	; 0x614e <_hSelfLeveling+0x1f4>
		}
		
		_helper_SaveinEEPROM_ifChanged();
    6156:	0e 94 96 2a 	call	0x552c	; 0x552c <_helper_SaveinEEPROM_ifChanged>
	}
	
	lcdReverse(subpage == 0);
    615a:	81 e0       	ldi	r24, 0x01	; 1
    615c:	90 91 3c 05 	lds	r25, 0x053C
    6160:	91 11       	cpse	r25, r1
    6162:	80 e0       	ldi	r24, 0x00	; 0
    6164:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <lcdReverse>
	_helper_DisplayPitchRollYaw(subindex);
    6168:	80 91 3d 05 	lds	r24, 0x053D
    616c:	0e 94 33 2a 	call	0x5466	; 0x5466 <_helper_DisplayPitchRollYaw>
	if (subindex<2)
    6170:	80 91 3d 05 	lds	r24, 0x053D
    6174:	82 30       	cpi	r24, 0x02	; 2
    6176:	08 f5       	brcc	.+66     	; 0x61ba <_hSelfLeveling+0x260>
	{
		LCD_WriteValue(5,42,Config.Acc_Pitch_Trim,3,8==subpage);
    6178:	40 91 5e 07 	lds	r20, 0x075E
    617c:	55 27       	eor	r21, r21
    617e:	47 fd       	sbrc	r20, 7
    6180:	50 95       	com	r21
    6182:	01 e0       	ldi	r16, 0x01	; 1
    6184:	80 91 3c 05 	lds	r24, 0x053C
    6188:	88 30       	cpi	r24, 0x08	; 8
    618a:	09 f0       	breq	.+2      	; 0x618e <_hSelfLeveling+0x234>
    618c:	00 e0       	ldi	r16, 0x00	; 0
    618e:	85 e0       	ldi	r24, 0x05	; 5
    6190:	6a e2       	ldi	r22, 0x2A	; 42
    6192:	23 e0       	ldi	r18, 0x03	; 3
    6194:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <LCD_WriteValue>
		LCD_WriteValue(5,78,Config.Acc_Roll_Trim,3,9==subpage);
    6198:	40 91 5f 07 	lds	r20, 0x075F
    619c:	55 27       	eor	r21, r21
    619e:	47 fd       	sbrc	r20, 7
    61a0:	50 95       	com	r21
    61a2:	01 e0       	ldi	r16, 0x01	; 1
    61a4:	80 91 3c 05 	lds	r24, 0x053C
    61a8:	89 30       	cpi	r24, 0x09	; 9
    61aa:	09 f0       	breq	.+2      	; 0x61ae <_hSelfLeveling+0x254>
    61ac:	00 e0       	ldi	r16, 0x00	; 0
    61ae:	85 e0       	ldi	r24, 0x05	; 5
    61b0:	6e e4       	ldi	r22, 0x4E	; 78
    61b2:	23 e0       	ldi	r18, 0x03	; 3
    61b4:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <LCD_WriteValue>
    61b8:	06 c0       	rjmp	.+12     	; 0x61c6 <_hSelfLeveling+0x26c>
	}
	else
	{
		strcpy_P(sXDeg,PSTR("ACC-Z damping"));
    61ba:	8e ee       	ldi	r24, 0xEE	; 238
    61bc:	95 e0       	ldi	r25, 0x05	; 5
    61be:	6d e4       	ldi	r22, 0x4D	; 77
    61c0:	7c e0       	ldi	r23, 0x0C	; 12
    61c2:	0e 94 a8 38 	call	0x7150	; 0x7150 <strcpy_P>
	}
	
	LCD_WriteStringex (0,0,sXDeg,0==subpage);
    61c6:	21 e0       	ldi	r18, 0x01	; 1
    61c8:	80 91 3c 05 	lds	r24, 0x053C
    61cc:	81 11       	cpse	r24, r1
    61ce:	20 e0       	ldi	r18, 0x00	; 0
    61d0:	80 e0       	ldi	r24, 0x00	; 0
    61d2:	60 e0       	ldi	r22, 0x00	; 0
    61d4:	4e ee       	ldi	r20, 0xEE	; 238
    61d6:	55 e0       	ldi	r21, 0x05	; 5
    61d8:	0e 94 25 0d 	call	0x1a4a	; 0x1a4a <LCD_WriteStringex>
	LCD_WriteValue(1,30,Config.AccParams[subindex]._P,3,1==subpage);
    61dc:	80 91 3d 05 	lds	r24, 0x053D
    61e0:	90 e0       	ldi	r25, 0x00	; 0
    61e2:	88 0f       	add	r24, r24
    61e4:	99 1f       	adc	r25, r25
    61e6:	fc 01       	movw	r30, r24
    61e8:	33 e0       	ldi	r19, 0x03	; 3
    61ea:	ee 0f       	add	r30, r30
    61ec:	ff 1f       	adc	r31, r31
    61ee:	3a 95       	dec	r19
    61f0:	e1 f7       	brne	.-8      	; 0x61ea <_hSelfLeveling+0x290>
    61f2:	e8 1b       	sub	r30, r24
    61f4:	f9 0b       	sbc	r31, r25
    61f6:	e5 51       	subi	r30, 0x15	; 21
    61f8:	f9 4f       	sbci	r31, 0xF9	; 249
    61fa:	42 ad       	ldd	r20, Z+58	; 0x3a
    61fc:	53 ad       	ldd	r21, Z+59	; 0x3b
    61fe:	01 e0       	ldi	r16, 0x01	; 1
    6200:	80 91 3c 05 	lds	r24, 0x053C
    6204:	81 30       	cpi	r24, 0x01	; 1
    6206:	09 f0       	breq	.+2      	; 0x620a <_hSelfLeveling+0x2b0>
    6208:	00 e0       	ldi	r16, 0x00	; 0
    620a:	81 e0       	ldi	r24, 0x01	; 1
    620c:	6e e1       	ldi	r22, 0x1E	; 30
    620e:	23 e0       	ldi	r18, 0x03	; 3
    6210:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <LCD_WriteValue>
	LCD_WriteValue(1,84,Config.AccParams[subindex]._PLimit,3,2==subpage);
    6214:	80 91 3d 05 	lds	r24, 0x053D
    6218:	90 e0       	ldi	r25, 0x00	; 0
    621a:	88 0f       	add	r24, r24
    621c:	99 1f       	adc	r25, r25
    621e:	fc 01       	movw	r30, r24
    6220:	03 e0       	ldi	r16, 0x03	; 3
    6222:	ee 0f       	add	r30, r30
    6224:	ff 1f       	adc	r31, r31
    6226:	0a 95       	dec	r16
    6228:	e1 f7       	brne	.-8      	; 0x6222 <_hSelfLeveling+0x2c8>
    622a:	e8 1b       	sub	r30, r24
    622c:	f9 0b       	sbc	r31, r25
    622e:	e5 51       	subi	r30, 0x15	; 21
    6230:	f9 4f       	sbci	r31, 0xF9	; 249
    6232:	44 ad       	ldd	r20, Z+60	; 0x3c
    6234:	55 ad       	ldd	r21, Z+61	; 0x3d
    6236:	01 e0       	ldi	r16, 0x01	; 1
    6238:	80 91 3c 05 	lds	r24, 0x053C
    623c:	82 30       	cpi	r24, 0x02	; 2
    623e:	09 f0       	breq	.+2      	; 0x6242 <_hSelfLeveling+0x2e8>
    6240:	00 e0       	ldi	r16, 0x00	; 0
    6242:	81 e0       	ldi	r24, 0x01	; 1
    6244:	64 e5       	ldi	r22, 0x54	; 84
    6246:	23 e0       	ldi	r18, 0x03	; 3
    6248:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <LCD_WriteValue>
	LCD_WriteValue(2,30,Config.AccParams[subindex]._I,3,3==subpage);
    624c:	80 91 3d 05 	lds	r24, 0x053D
    6250:	90 e0       	ldi	r25, 0x00	; 0
    6252:	88 0f       	add	r24, r24
    6254:	99 1f       	adc	r25, r25
    6256:	fc 01       	movw	r30, r24
    6258:	a3 e0       	ldi	r26, 0x03	; 3
    625a:	ee 0f       	add	r30, r30
    625c:	ff 1f       	adc	r31, r31
    625e:	aa 95       	dec	r26
    6260:	e1 f7       	brne	.-8      	; 0x625a <_hSelfLeveling+0x300>
    6262:	e8 1b       	sub	r30, r24
    6264:	f9 0b       	sbc	r31, r25
    6266:	e7 5d       	subi	r30, 0xD7	; 215
    6268:	f8 4f       	sbci	r31, 0xF8	; 248
    626a:	40 81       	ld	r20, Z
    626c:	51 81       	ldd	r21, Z+1	; 0x01
    626e:	01 e0       	ldi	r16, 0x01	; 1
    6270:	80 91 3c 05 	lds	r24, 0x053C
    6274:	83 30       	cpi	r24, 0x03	; 3
    6276:	09 f0       	breq	.+2      	; 0x627a <_hSelfLeveling+0x320>
    6278:	00 e0       	ldi	r16, 0x00	; 0
    627a:	82 e0       	ldi	r24, 0x02	; 2
    627c:	6e e1       	ldi	r22, 0x1E	; 30
    627e:	23 e0       	ldi	r18, 0x03	; 3
    6280:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <LCD_WriteValue>
	LCD_WriteValue(2,84,Config.AccParams[subindex]._ILimit,3,4==subpage);
    6284:	80 91 3d 05 	lds	r24, 0x053D
    6288:	90 e0       	ldi	r25, 0x00	; 0
    628a:	88 0f       	add	r24, r24
    628c:	99 1f       	adc	r25, r25
    628e:	fc 01       	movw	r30, r24
    6290:	73 e0       	ldi	r23, 0x03	; 3
    6292:	ee 0f       	add	r30, r30
    6294:	ff 1f       	adc	r31, r31
    6296:	7a 95       	dec	r23
    6298:	e1 f7       	brne	.-8      	; 0x6292 <_hSelfLeveling+0x338>
    629a:	e8 1b       	sub	r30, r24
    629c:	f9 0b       	sbc	r31, r25
    629e:	e5 5d       	subi	r30, 0xD5	; 213
    62a0:	f8 4f       	sbci	r31, 0xF8	; 248
    62a2:	40 81       	ld	r20, Z
    62a4:	51 81       	ldd	r21, Z+1	; 0x01
    62a6:	01 e0       	ldi	r16, 0x01	; 1
    62a8:	80 91 3c 05 	lds	r24, 0x053C
    62ac:	84 30       	cpi	r24, 0x04	; 4
    62ae:	09 f0       	breq	.+2      	; 0x62b2 <_hSelfLeveling+0x358>
    62b0:	00 e0       	ldi	r16, 0x00	; 0
    62b2:	82 e0       	ldi	r24, 0x02	; 2
    62b4:	64 e5       	ldi	r22, 0x54	; 84
    62b6:	23 e0       	ldi	r18, 0x03	; 3
    62b8:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <LCD_WriteValue>
	LCD_WriteValue(3,30,Config.AccParams[subindex]._D,3,5==subpage);
    62bc:	80 91 3d 05 	lds	r24, 0x053D
    62c0:	90 e0       	ldi	r25, 0x00	; 0
    62c2:	88 0f       	add	r24, r24
    62c4:	99 1f       	adc	r25, r25
    62c6:	fc 01       	movw	r30, r24
    62c8:	53 e0       	ldi	r21, 0x03	; 3
    62ca:	ee 0f       	add	r30, r30
    62cc:	ff 1f       	adc	r31, r31
    62ce:	5a 95       	dec	r21
    62d0:	e1 f7       	brne	.-8      	; 0x62ca <_hSelfLeveling+0x370>
    62d2:	e8 1b       	sub	r30, r24
    62d4:	f9 0b       	sbc	r31, r25
    62d6:	e3 5d       	subi	r30, 0xD3	; 211
    62d8:	f8 4f       	sbci	r31, 0xF8	; 248
    62da:	40 81       	ld	r20, Z
    62dc:	51 81       	ldd	r21, Z+1	; 0x01
    62de:	01 e0       	ldi	r16, 0x01	; 1
    62e0:	80 91 3c 05 	lds	r24, 0x053C
    62e4:	85 30       	cpi	r24, 0x05	; 5
    62e6:	09 f0       	breq	.+2      	; 0x62ea <_hSelfLeveling+0x390>
    62e8:	00 e0       	ldi	r16, 0x00	; 0
    62ea:	83 e0       	ldi	r24, 0x03	; 3
    62ec:	6e e1       	ldi	r22, 0x1E	; 30
    62ee:	23 e0       	ldi	r18, 0x03	; 3
    62f0:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <LCD_WriteValue>
	LCD_WriteValue(3,84,Config.AccParams[subindex]._DLimit,3,6==subpage);
    62f4:	80 91 3d 05 	lds	r24, 0x053D
    62f8:	90 e0       	ldi	r25, 0x00	; 0
    62fa:	88 0f       	add	r24, r24
    62fc:	99 1f       	adc	r25, r25
    62fe:	fc 01       	movw	r30, r24
    6300:	33 e0       	ldi	r19, 0x03	; 3
    6302:	ee 0f       	add	r30, r30
    6304:	ff 1f       	adc	r31, r31
    6306:	3a 95       	dec	r19
    6308:	e1 f7       	brne	.-8      	; 0x6302 <_hSelfLeveling+0x3a8>
    630a:	e8 1b       	sub	r30, r24
    630c:	f9 0b       	sbc	r31, r25
    630e:	e1 5d       	subi	r30, 0xD1	; 209
    6310:	f8 4f       	sbci	r31, 0xF8	; 248
    6312:	40 81       	ld	r20, Z
    6314:	51 81       	ldd	r21, Z+1	; 0x01
    6316:	01 e0       	ldi	r16, 0x01	; 1
    6318:	80 91 3c 05 	lds	r24, 0x053C
    631c:	86 30       	cpi	r24, 0x06	; 6
    631e:	09 f0       	breq	.+2      	; 0x6322 <_hSelfLeveling+0x3c8>
    6320:	00 e0       	ldi	r16, 0x00	; 0
    6322:	83 e0       	ldi	r24, 0x03	; 3
    6324:	64 e5       	ldi	r22, 0x54	; 84
    6326:	23 e0       	ldi	r18, 0x03	; 3
    6328:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <LCD_WriteValue>
	LCD_WriteValue(4,84,Config.AccParams[subindex].ComplementaryFilterAlpha,3,7==subpage);
    632c:	80 91 3d 05 	lds	r24, 0x053D
    6330:	90 e0       	ldi	r25, 0x00	; 0
    6332:	88 0f       	add	r24, r24
    6334:	99 1f       	adc	r25, r25
    6336:	fc 01       	movw	r30, r24
    6338:	03 e0       	ldi	r16, 0x03	; 3
    633a:	ee 0f       	add	r30, r30
    633c:	ff 1f       	adc	r31, r31
    633e:	0a 95       	dec	r16
    6340:	e1 f7       	brne	.-8      	; 0x633a <_hSelfLeveling+0x3e0>
    6342:	e8 1b       	sub	r30, r24
    6344:	f9 0b       	sbc	r31, r25
    6346:	ef 5c       	subi	r30, 0xCF	; 207
    6348:	f8 4f       	sbci	r31, 0xF8	; 248
    634a:	40 81       	ld	r20, Z
    634c:	51 81       	ldd	r21, Z+1	; 0x01
    634e:	01 e0       	ldi	r16, 0x01	; 1
    6350:	80 91 3c 05 	lds	r24, 0x053C
    6354:	87 30       	cpi	r24, 0x07	; 7
    6356:	09 f0       	breq	.+2      	; 0x635a <_hSelfLeveling+0x400>
    6358:	00 e0       	ldi	r16, 0x00	; 0
    635a:	84 e0       	ldi	r24, 0x04	; 4
    635c:	64 e5       	ldi	r22, 0x54	; 84
    635e:	23 e0       	ldi	r18, 0x03	; 3
    6360:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <LCD_WriteValue>
	
}
    6364:	0f 91       	pop	r16
    6366:	08 95       	ret

00006368 <_hStabilization>:

/*
* check : http://code.google.com/p/ardupirates/wiki/PID_Setting_SuperStable_Code
*/ 
void _hStabilization()
{
    6368:	ef 92       	push	r14
    636a:	0f 93       	push	r16
	NOKEYRETURN;
    636c:	80 91 be 05 	lds	r24, 0x05BE
    6370:	88 23       	and	r24, r24
    6372:	09 f4       	brne	.+2      	; 0x6376 <_hStabilization+0xe>
    6374:	db c1       	rjmp	.+950    	; 0x672c <_hStabilization+0x3c4>
	PageKey(9);
    6376:	89 e0       	ldi	r24, 0x09	; 9
    6378:	0e 94 e8 2e 	call	0x5dd0	; 0x5dd0 <PageKey>
	
	if (KEY4)
    637c:	80 91 be 05 	lds	r24, 0x05BE
    6380:	84 ff       	sbrs	r24, 4
    6382:	bb c0       	rjmp	.+374    	; 0x64fa <_hStabilization+0x192>
	{
		if (subpage!=0) bValueChanged = true;
    6384:	20 91 3c 05 	lds	r18, 0x053C
    6388:	22 23       	and	r18, r18
    638a:	19 f0       	breq	.+6      	; 0x6392 <_hStabilization+0x2a>
    638c:	81 e0       	ldi	r24, 0x01	; 1
    638e:	80 93 38 05 	sts	0x0538, r24
		currentPage.softkeys = _skMENUSAVE;
    6392:	80 e1       	ldi	r24, 0x10	; 16
    6394:	9c e0       	ldi	r25, 0x0C	; 12
    6396:	90 93 47 05 	sts	0x0547, r25
    639a:	80 93 46 05 	sts	0x0546, r24
		
		switch (subpage)
    639e:	24 30       	cpi	r18, 0x04	; 4
    63a0:	09 f4       	brne	.+2      	; 0x63a4 <_hStabilization+0x3c>
    63a2:	53 c0       	rjmp	.+166    	; 0x644a <_hStabilization+0xe2>
    63a4:	25 30       	cpi	r18, 0x05	; 5
    63a6:	50 f4       	brcc	.+20     	; 0x63bc <_hStabilization+0x54>
    63a8:	21 30       	cpi	r18, 0x01	; 1
    63aa:	d1 f0       	breq	.+52     	; 0x63e0 <_hStabilization+0x78>
    63ac:	21 30       	cpi	r18, 0x01	; 1
    63ae:	98 f0       	brcs	.+38     	; 0x63d6 <_hStabilization+0x6e>
    63b0:	22 30       	cpi	r18, 0x02	; 2
    63b2:	39 f1       	breq	.+78     	; 0x6402 <_hStabilization+0x9a>
    63b4:	23 30       	cpi	r18, 0x03	; 3
    63b6:	09 f0       	breq	.+2      	; 0x63ba <_hStabilization+0x52>
    63b8:	a0 c0       	rjmp	.+320    	; 0x64fa <_hStabilization+0x192>
    63ba:	34 c0       	rjmp	.+104    	; 0x6424 <_hStabilization+0xbc>
    63bc:	26 30       	cpi	r18, 0x06	; 6
    63be:	09 f4       	brne	.+2      	; 0x63c2 <_hStabilization+0x5a>
    63c0:	66 c0       	rjmp	.+204    	; 0x648e <_hStabilization+0x126>
    63c2:	26 30       	cpi	r18, 0x06	; 6
    63c4:	08 f4       	brcc	.+2      	; 0x63c8 <_hStabilization+0x60>
    63c6:	52 c0       	rjmp	.+164    	; 0x646c <_hStabilization+0x104>
    63c8:	27 30       	cpi	r18, 0x07	; 7
    63ca:	09 f4       	brne	.+2      	; 0x63ce <_hStabilization+0x66>
    63cc:	75 c0       	rjmp	.+234    	; 0x64b8 <_hStabilization+0x150>
    63ce:	28 30       	cpi	r18, 0x08	; 8
    63d0:	09 f0       	breq	.+2      	; 0x63d4 <_hStabilization+0x6c>
    63d2:	93 c0       	rjmp	.+294    	; 0x64fa <_hStabilization+0x192>
    63d4:	89 c0       	rjmp	.+274    	; 0x64e8 <_hStabilization+0x180>
		{
			case 0: _helper_SwitchPitchRollYaw(&subindex); break;
    63d6:	8d e3       	ldi	r24, 0x3D	; 61
    63d8:	95 e0       	ldi	r25, 0x05	; 5
    63da:	0e 94 56 2a 	call	0x54ac	; 0x54ac <_helper_SwitchPitchRollYaw>
    63de:	8d c0       	rjmp	.+282    	; 0x64fa <_hStabilization+0x192>
			case 1: startEditMode(&(Config.GyroParams[subindex]._P),-500,500,TYPE_INT16); return ;
    63e0:	80 91 3d 05 	lds	r24, 0x053D
    63e4:	90 e0       	ldi	r25, 0x00	; 0
    63e6:	9c 01       	movw	r18, r24
    63e8:	22 0f       	add	r18, r18
    63ea:	33 1f       	adc	r19, r19
    63ec:	c9 01       	movw	r24, r18
    63ee:	63 e0       	ldi	r22, 0x03	; 3
    63f0:	88 0f       	add	r24, r24
    63f2:	99 1f       	adc	r25, r25
    63f4:	6a 95       	dec	r22
    63f6:	e1 f7       	brne	.-8      	; 0x63f0 <_hStabilization+0x88>
    63f8:	82 1b       	sub	r24, r18
    63fa:	93 0b       	sbc	r25, r19
    63fc:	85 50       	subi	r24, 0x05	; 5
    63fe:	99 4f       	sbci	r25, 0xF9	; 249
    6400:	21 c0       	rjmp	.+66     	; 0x6444 <_hStabilization+0xdc>
			case 2: startEditMode(&(Config.GyroParams[subindex]._PLimit),0,500,TYPE_INT16); return ;
    6402:	80 91 3d 05 	lds	r24, 0x053D
    6406:	90 e0       	ldi	r25, 0x00	; 0
    6408:	9c 01       	movw	r18, r24
    640a:	22 0f       	add	r18, r18
    640c:	33 1f       	adc	r19, r19
    640e:	c9 01       	movw	r24, r18
    6410:	43 e0       	ldi	r20, 0x03	; 3
    6412:	88 0f       	add	r24, r24
    6414:	99 1f       	adc	r25, r25
    6416:	4a 95       	dec	r20
    6418:	e1 f7       	brne	.-8      	; 0x6412 <_hStabilization+0xaa>
    641a:	82 1b       	sub	r24, r18
    641c:	93 0b       	sbc	r25, r19
    641e:	83 50       	subi	r24, 0x03	; 3
    6420:	99 4f       	sbci	r25, 0xF9	; 249
    6422:	45 c0       	rjmp	.+138    	; 0x64ae <_hStabilization+0x146>
			case 3: startEditMode(&(Config.GyroParams[subindex]._I),-500,500,TYPE_INT16);  return ;
    6424:	80 91 3d 05 	lds	r24, 0x053D
    6428:	90 e0       	ldi	r25, 0x00	; 0
    642a:	9c 01       	movw	r18, r24
    642c:	22 0f       	add	r18, r18
    642e:	33 1f       	adc	r19, r19
    6430:	c9 01       	movw	r24, r18
    6432:	03 e0       	ldi	r16, 0x03	; 3
    6434:	88 0f       	add	r24, r24
    6436:	99 1f       	adc	r25, r25
    6438:	0a 95       	dec	r16
    643a:	e1 f7       	brne	.-8      	; 0x6434 <_hStabilization+0xcc>
    643c:	82 1b       	sub	r24, r18
    643e:	93 0b       	sbc	r25, r19
    6440:	81 50       	subi	r24, 0x01	; 1
    6442:	99 4f       	sbci	r25, 0xF9	; 249
    6444:	6c e0       	ldi	r22, 0x0C	; 12
    6446:	7e ef       	ldi	r23, 0xFE	; 254
    6448:	34 c0       	rjmp	.+104    	; 0x64b2 <_hStabilization+0x14a>
			case 4: startEditMode(&(Config.GyroParams[subindex]._ILimit),0,500,TYPE_INT16); return ;
    644a:	80 91 3d 05 	lds	r24, 0x053D
    644e:	90 e0       	ldi	r25, 0x00	; 0
    6450:	9c 01       	movw	r18, r24
    6452:	22 0f       	add	r18, r18
    6454:	33 1f       	adc	r19, r19
    6456:	c9 01       	movw	r24, r18
    6458:	a3 e0       	ldi	r26, 0x03	; 3
    645a:	88 0f       	add	r24, r24
    645c:	99 1f       	adc	r25, r25
    645e:	aa 95       	dec	r26
    6460:	e1 f7       	brne	.-8      	; 0x645a <_hStabilization+0xf2>
    6462:	82 1b       	sub	r24, r18
    6464:	93 0b       	sbc	r25, r19
    6466:	8f 5f       	subi	r24, 0xFF	; 255
    6468:	98 4f       	sbci	r25, 0xF8	; 248
    646a:	21 c0       	rjmp	.+66     	; 0x64ae <_hStabilization+0x146>
			case 5: startEditMode(&(Config.GyroParams[subindex]._D),-500,500,TYPE_INT16);  return ; 
    646c:	80 91 3d 05 	lds	r24, 0x053D
    6470:	90 e0       	ldi	r25, 0x00	; 0
    6472:	9c 01       	movw	r18, r24
    6474:	22 0f       	add	r18, r18
    6476:	33 1f       	adc	r19, r19
    6478:	c9 01       	movw	r24, r18
    647a:	e3 e0       	ldi	r30, 0x03	; 3
    647c:	88 0f       	add	r24, r24
    647e:	99 1f       	adc	r25, r25
    6480:	ea 95       	dec	r30
    6482:	e1 f7       	brne	.-8      	; 0x647c <_hStabilization+0x114>
    6484:	82 1b       	sub	r24, r18
    6486:	93 0b       	sbc	r25, r19
    6488:	8d 5f       	subi	r24, 0xFD	; 253
    648a:	98 4f       	sbci	r25, 0xF8	; 248
    648c:	db cf       	rjmp	.-74     	; 0x6444 <_hStabilization+0xdc>
			case 6: startEditMode(&(Config.GyroParams[subindex]._DLimit),0,500,TYPE_INT16); return ;
    648e:	80 91 3d 05 	lds	r24, 0x053D
    6492:	90 e0       	ldi	r25, 0x00	; 0
    6494:	9c 01       	movw	r18, r24
    6496:	22 0f       	add	r18, r18
    6498:	33 1f       	adc	r19, r19
    649a:	c9 01       	movw	r24, r18
    649c:	63 e0       	ldi	r22, 0x03	; 3
    649e:	88 0f       	add	r24, r24
    64a0:	99 1f       	adc	r25, r25
    64a2:	6a 95       	dec	r22
    64a4:	e1 f7       	brne	.-8      	; 0x649e <_hStabilization+0x136>
    64a6:	82 1b       	sub	r24, r18
    64a8:	93 0b       	sbc	r25, r19
    64aa:	8b 5f       	subi	r24, 0xFB	; 251
    64ac:	98 4f       	sbci	r25, 0xF8	; 248
    64ae:	60 e0       	ldi	r22, 0x00	; 0
    64b0:	70 e0       	ldi	r23, 0x00	; 0
    64b2:	44 ef       	ldi	r20, 0xF4	; 244
    64b4:	51 e0       	ldi	r21, 0x01	; 1
    64b6:	14 c0       	rjmp	.+40     	; 0x64e0 <_hStabilization+0x178>
			case 7: startEditMode(&(Config.GyroParams[subindex].ComplementaryFilterAlpha),0,999,TYPE_INT16); return ;
    64b8:	80 91 3d 05 	lds	r24, 0x053D
    64bc:	90 e0       	ldi	r25, 0x00	; 0
    64be:	9c 01       	movw	r18, r24
    64c0:	22 0f       	add	r18, r18
    64c2:	33 1f       	adc	r19, r19
    64c4:	c9 01       	movw	r24, r18
    64c6:	43 e0       	ldi	r20, 0x03	; 3
    64c8:	88 0f       	add	r24, r24
    64ca:	99 1f       	adc	r25, r25
    64cc:	4a 95       	dec	r20
    64ce:	e1 f7       	brne	.-8      	; 0x64c8 <_hStabilization+0x160>
    64d0:	82 1b       	sub	r24, r18
    64d2:	93 0b       	sbc	r25, r19
    64d4:	89 5f       	subi	r24, 0xF9	; 249
    64d6:	98 4f       	sbci	r25, 0xF8	; 248
    64d8:	60 e0       	ldi	r22, 0x00	; 0
    64da:	70 e0       	ldi	r23, 0x00	; 0
    64dc:	47 ee       	ldi	r20, 0xE7	; 231
    64de:	53 e0       	ldi	r21, 0x03	; 3
    64e0:	23 e0       	ldi	r18, 0x03	; 3
    64e2:	0e 94 9a 2e 	call	0x5d34	; 0x5d34 <startEditMode>
    64e6:	22 c1       	rjmp	.+580    	; 0x672c <_hStabilization+0x3c4>
			case 8: if (Config.ReverseYAW==GYRO_NORMAL) Config.ReverseYAW =GYRO_REVERSE; else Config.ReverseYAW = GYRO_NORMAL; break; // update the UI
    64e8:	80 91 b2 07 	lds	r24, 0x07B2
    64ec:	81 30       	cpi	r24, 0x01	; 1
    64ee:	11 f4       	brne	.+4      	; 0x64f4 <_hStabilization+0x18c>
    64f0:	8f ef       	ldi	r24, 0xFF	; 255
    64f2:	01 c0       	rjmp	.+2      	; 0x64f6 <_hStabilization+0x18e>
    64f4:	81 e0       	ldi	r24, 0x01	; 1
    64f6:	80 93 b2 07 	sts	0x07B2, r24
		}
		
		
	}
	
	if (KEY1)
    64fa:	80 91 be 05 	lds	r24, 0x05BE
    64fe:	87 ff       	sbrs	r24, 7
    6500:	0f c0       	rjmp	.+30     	; 0x6520 <_hStabilization+0x1b8>
	{
		if (Config.PitchRollLinked==1)
    6502:	80 91 b3 07 	lds	r24, 0x07B3
    6506:	81 30       	cpi	r24, 0x01	; 1
    6508:	49 f4       	brne	.+18     	; 0x651c <_hStabilization+0x1b4>
		{
			memcpy(&(Config.GyroParams[ROLL_INDEX]),&(Config.GyroParams[PITCH_INDEX]), sizeof(pid_param_t));
    650a:	e9 e0       	ldi	r30, 0x09	; 9
    650c:	f7 e0       	ldi	r31, 0x07	; 7
    650e:	df 01       	movw	r26, r30
    6510:	1e 97       	sbiw	r26, 0x0e	; 14
    6512:	8e e0       	ldi	r24, 0x0E	; 14
    6514:	0d 90       	ld	r0, X+
    6516:	01 92       	st	Z+, r0
    6518:	81 50       	subi	r24, 0x01	; 1
    651a:	e1 f7       	brne	.-8      	; 0x6514 <_hStabilization+0x1ac>
		}
		
		_helper_SaveinEEPROM_ifChanged();
    651c:	0e 94 96 2a 	call	0x552c	; 0x552c <_helper_SaveinEEPROM_ifChanged>
	}
	
	lcdReverse(subpage == 0);
    6520:	81 e0       	ldi	r24, 0x01	; 1
    6522:	90 91 3c 05 	lds	r25, 0x053C
    6526:	91 11       	cpse	r25, r1
    6528:	80 e0       	ldi	r24, 0x00	; 0
    652a:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <lcdReverse>
	_helper_DisplayPitchRollYaw(subindex);
    652e:	80 91 3d 05 	lds	r24, 0x053D
    6532:	0e 94 33 2a 	call	0x5466	; 0x5466 <_helper_DisplayPitchRollYaw>
	LCD_WriteString_Pex(5,0,PSTR("                "),16,false);    
    6536:	85 e0       	ldi	r24, 0x05	; 5
    6538:	60 e0       	ldi	r22, 0x00	; 0
    653a:	4b e8       	ldi	r20, 0x8B	; 139
    653c:	5c e0       	ldi	r21, 0x0C	; 12
    653e:	20 e1       	ldi	r18, 0x10	; 16
    6540:	00 e0       	ldi	r16, 0x00	; 0
    6542:	0e 94 95 0d 	call	0x1b2a	; 0x1b2a <LCD_WriteString_Pex>
	
	if ((subindex==2) && (Config.FrameType == FRAMETYPE_TRICOPTER))
    6546:	80 91 3d 05 	lds	r24, 0x053D
    654a:	82 30       	cpi	r24, 0x02	; 2
    654c:	01 f5       	brne	.+64     	; 0x658e <_hStabilization+0x226>
    654e:	80 91 f4 06 	lds	r24, 0x06F4
    6552:	82 30       	cpi	r24, 0x02	; 2
    6554:	e1 f4       	brne	.+56     	; 0x658e <_hStabilization+0x226>
	{
		LCD_WriteString_Pex(5,0,PSTR("Reverse GYRO"),12,false);    
    6556:	85 e0       	ldi	r24, 0x05	; 5
    6558:	60 e0       	ldi	r22, 0x00	; 0
    655a:	4e e7       	ldi	r20, 0x7E	; 126
    655c:	5c e0       	ldi	r21, 0x0C	; 12
    655e:	2c e0       	ldi	r18, 0x0C	; 12
    6560:	0e 94 95 0d 	call	0x1b2a	; 0x1b2a <LCD_WriteString_Pex>
		_helper_DisplayBiStateText(5,84 ,PSTR("N"), PSTR("R"), Config.ReverseYAW==GYRO_NORMAL, 8==subpage);
    6564:	01 e0       	ldi	r16, 0x01	; 1
    6566:	80 91 b2 07 	lds	r24, 0x07B2
    656a:	81 30       	cpi	r24, 0x01	; 1
    656c:	09 f0       	breq	.+2      	; 0x6570 <_hStabilization+0x208>
    656e:	00 e0       	ldi	r16, 0x00	; 0
    6570:	91 e0       	ldi	r25, 0x01	; 1
    6572:	80 91 3c 05 	lds	r24, 0x053C
    6576:	88 30       	cpi	r24, 0x08	; 8
    6578:	09 f0       	breq	.+2      	; 0x657c <_hStabilization+0x214>
    657a:	90 e0       	ldi	r25, 0x00	; 0
    657c:	85 e0       	ldi	r24, 0x05	; 5
    657e:	64 e5       	ldi	r22, 0x54	; 84
    6580:	4c e7       	ldi	r20, 0x7C	; 124
    6582:	5c e0       	ldi	r21, 0x0C	; 12
    6584:	2a e7       	ldi	r18, 0x7A	; 122
    6586:	3c e0       	ldi	r19, 0x0C	; 12
    6588:	e9 2e       	mov	r14, r25
    658a:	0e 94 6a 2a 	call	0x54d4	; 0x54d4 <_helper_DisplayBiStateText>
	}		

	
	LCD_WriteStringex (0,0,sXDeg,0==subpage);
    658e:	21 e0       	ldi	r18, 0x01	; 1
    6590:	80 91 3c 05 	lds	r24, 0x053C
    6594:	81 11       	cpse	r24, r1
    6596:	20 e0       	ldi	r18, 0x00	; 0
    6598:	80 e0       	ldi	r24, 0x00	; 0
    659a:	60 e0       	ldi	r22, 0x00	; 0
    659c:	4e ee       	ldi	r20, 0xEE	; 238
    659e:	55 e0       	ldi	r21, 0x05	; 5
    65a0:	0e 94 25 0d 	call	0x1a4a	; 0x1a4a <LCD_WriteStringex>
	LCD_WriteValue(1,30,Config.GyroParams[subindex]._P,3,1==subpage);
    65a4:	80 91 3d 05 	lds	r24, 0x053D
    65a8:	90 e0       	ldi	r25, 0x00	; 0
    65aa:	88 0f       	add	r24, r24
    65ac:	99 1f       	adc	r25, r25
    65ae:	fc 01       	movw	r30, r24
    65b0:	03 e0       	ldi	r16, 0x03	; 3
    65b2:	ee 0f       	add	r30, r30
    65b4:	ff 1f       	adc	r31, r31
    65b6:	0a 95       	dec	r16
    65b8:	e1 f7       	brne	.-8      	; 0x65b2 <_hStabilization+0x24a>
    65ba:	e8 1b       	sub	r30, r24
    65bc:	f9 0b       	sbc	r31, r25
    65be:	e5 51       	subi	r30, 0x15	; 21
    65c0:	f9 4f       	sbci	r31, 0xF9	; 249
    65c2:	40 89       	ldd	r20, Z+16	; 0x10
    65c4:	51 89       	ldd	r21, Z+17	; 0x11
    65c6:	01 e0       	ldi	r16, 0x01	; 1
    65c8:	80 91 3c 05 	lds	r24, 0x053C
    65cc:	81 30       	cpi	r24, 0x01	; 1
    65ce:	09 f0       	breq	.+2      	; 0x65d2 <_hStabilization+0x26a>
    65d0:	00 e0       	ldi	r16, 0x00	; 0
    65d2:	81 e0       	ldi	r24, 0x01	; 1
    65d4:	6e e1       	ldi	r22, 0x1E	; 30
    65d6:	23 e0       	ldi	r18, 0x03	; 3
    65d8:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <LCD_WriteValue>
	LCD_WriteValue(1,84,Config.GyroParams[subindex]._PLimit,3,2==subpage);
    65dc:	80 91 3d 05 	lds	r24, 0x053D
    65e0:	90 e0       	ldi	r25, 0x00	; 0
    65e2:	88 0f       	add	r24, r24
    65e4:	99 1f       	adc	r25, r25
    65e6:	fc 01       	movw	r30, r24
    65e8:	a3 e0       	ldi	r26, 0x03	; 3
    65ea:	ee 0f       	add	r30, r30
    65ec:	ff 1f       	adc	r31, r31
    65ee:	aa 95       	dec	r26
    65f0:	e1 f7       	brne	.-8      	; 0x65ea <_hStabilization+0x282>
    65f2:	e8 1b       	sub	r30, r24
    65f4:	f9 0b       	sbc	r31, r25
    65f6:	e5 51       	subi	r30, 0x15	; 21
    65f8:	f9 4f       	sbci	r31, 0xF9	; 249
    65fa:	42 89       	ldd	r20, Z+18	; 0x12
    65fc:	53 89       	ldd	r21, Z+19	; 0x13
    65fe:	01 e0       	ldi	r16, 0x01	; 1
    6600:	80 91 3c 05 	lds	r24, 0x053C
    6604:	82 30       	cpi	r24, 0x02	; 2
    6606:	09 f0       	breq	.+2      	; 0x660a <_hStabilization+0x2a2>
    6608:	00 e0       	ldi	r16, 0x00	; 0
    660a:	81 e0       	ldi	r24, 0x01	; 1
    660c:	64 e5       	ldi	r22, 0x54	; 84
    660e:	23 e0       	ldi	r18, 0x03	; 3
    6610:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <LCD_WriteValue>
	LCD_WriteValue(2,30,Config.GyroParams[subindex]._I,3,3==subpage);
    6614:	80 91 3d 05 	lds	r24, 0x053D
    6618:	90 e0       	ldi	r25, 0x00	; 0
    661a:	88 0f       	add	r24, r24
    661c:	99 1f       	adc	r25, r25
    661e:	fc 01       	movw	r30, r24
    6620:	73 e0       	ldi	r23, 0x03	; 3
    6622:	ee 0f       	add	r30, r30
    6624:	ff 1f       	adc	r31, r31
    6626:	7a 95       	dec	r23
    6628:	e1 f7       	brne	.-8      	; 0x6622 <_hStabilization+0x2ba>
    662a:	e8 1b       	sub	r30, r24
    662c:	f9 0b       	sbc	r31, r25
    662e:	e5 51       	subi	r30, 0x15	; 21
    6630:	f9 4f       	sbci	r31, 0xF9	; 249
    6632:	44 89       	ldd	r20, Z+20	; 0x14
    6634:	55 89       	ldd	r21, Z+21	; 0x15
    6636:	01 e0       	ldi	r16, 0x01	; 1
    6638:	80 91 3c 05 	lds	r24, 0x053C
    663c:	83 30       	cpi	r24, 0x03	; 3
    663e:	09 f0       	breq	.+2      	; 0x6642 <_hStabilization+0x2da>
    6640:	00 e0       	ldi	r16, 0x00	; 0
    6642:	82 e0       	ldi	r24, 0x02	; 2
    6644:	6e e1       	ldi	r22, 0x1E	; 30
    6646:	23 e0       	ldi	r18, 0x03	; 3
    6648:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <LCD_WriteValue>
	LCD_WriteValue(2,84,Config.GyroParams[subindex]._ILimit,3,4==subpage);
    664c:	80 91 3d 05 	lds	r24, 0x053D
    6650:	90 e0       	ldi	r25, 0x00	; 0
    6652:	88 0f       	add	r24, r24
    6654:	99 1f       	adc	r25, r25
    6656:	fc 01       	movw	r30, r24
    6658:	53 e0       	ldi	r21, 0x03	; 3
    665a:	ee 0f       	add	r30, r30
    665c:	ff 1f       	adc	r31, r31
    665e:	5a 95       	dec	r21
    6660:	e1 f7       	brne	.-8      	; 0x665a <_hStabilization+0x2f2>
    6662:	e8 1b       	sub	r30, r24
    6664:	f9 0b       	sbc	r31, r25
    6666:	e5 51       	subi	r30, 0x15	; 21
    6668:	f9 4f       	sbci	r31, 0xF9	; 249
    666a:	46 89       	ldd	r20, Z+22	; 0x16
    666c:	57 89       	ldd	r21, Z+23	; 0x17
    666e:	01 e0       	ldi	r16, 0x01	; 1
    6670:	80 91 3c 05 	lds	r24, 0x053C
    6674:	84 30       	cpi	r24, 0x04	; 4
    6676:	09 f0       	breq	.+2      	; 0x667a <_hStabilization+0x312>
    6678:	00 e0       	ldi	r16, 0x00	; 0
    667a:	82 e0       	ldi	r24, 0x02	; 2
    667c:	64 e5       	ldi	r22, 0x54	; 84
    667e:	23 e0       	ldi	r18, 0x03	; 3
    6680:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <LCD_WriteValue>
	LCD_WriteValue(3,30,Config.GyroParams[subindex]._D,3,5==subpage);
    6684:	80 91 3d 05 	lds	r24, 0x053D
    6688:	90 e0       	ldi	r25, 0x00	; 0
    668a:	88 0f       	add	r24, r24
    668c:	99 1f       	adc	r25, r25
    668e:	fc 01       	movw	r30, r24
    6690:	33 e0       	ldi	r19, 0x03	; 3
    6692:	ee 0f       	add	r30, r30
    6694:	ff 1f       	adc	r31, r31
    6696:	3a 95       	dec	r19
    6698:	e1 f7       	brne	.-8      	; 0x6692 <_hStabilization+0x32a>
    669a:	e8 1b       	sub	r30, r24
    669c:	f9 0b       	sbc	r31, r25
    669e:	e5 51       	subi	r30, 0x15	; 21
    66a0:	f9 4f       	sbci	r31, 0xF9	; 249
    66a2:	40 8d       	ldd	r20, Z+24	; 0x18
    66a4:	51 8d       	ldd	r21, Z+25	; 0x19
    66a6:	01 e0       	ldi	r16, 0x01	; 1
    66a8:	80 91 3c 05 	lds	r24, 0x053C
    66ac:	85 30       	cpi	r24, 0x05	; 5
    66ae:	09 f0       	breq	.+2      	; 0x66b2 <_hStabilization+0x34a>
    66b0:	00 e0       	ldi	r16, 0x00	; 0
    66b2:	83 e0       	ldi	r24, 0x03	; 3
    66b4:	6e e1       	ldi	r22, 0x1E	; 30
    66b6:	23 e0       	ldi	r18, 0x03	; 3
    66b8:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <LCD_WriteValue>
	LCD_WriteValue(3,84,Config.GyroParams[subindex]._DLimit,3,6==subpage);
    66bc:	80 91 3d 05 	lds	r24, 0x053D
    66c0:	90 e0       	ldi	r25, 0x00	; 0
    66c2:	88 0f       	add	r24, r24
    66c4:	99 1f       	adc	r25, r25
    66c6:	fc 01       	movw	r30, r24
    66c8:	03 e0       	ldi	r16, 0x03	; 3
    66ca:	ee 0f       	add	r30, r30
    66cc:	ff 1f       	adc	r31, r31
    66ce:	0a 95       	dec	r16
    66d0:	e1 f7       	brne	.-8      	; 0x66ca <_hStabilization+0x362>
    66d2:	e8 1b       	sub	r30, r24
    66d4:	f9 0b       	sbc	r31, r25
    66d6:	e5 51       	subi	r30, 0x15	; 21
    66d8:	f9 4f       	sbci	r31, 0xF9	; 249
    66da:	42 8d       	ldd	r20, Z+26	; 0x1a
    66dc:	53 8d       	ldd	r21, Z+27	; 0x1b
    66de:	01 e0       	ldi	r16, 0x01	; 1
    66e0:	80 91 3c 05 	lds	r24, 0x053C
    66e4:	86 30       	cpi	r24, 0x06	; 6
    66e6:	09 f0       	breq	.+2      	; 0x66ea <_hStabilization+0x382>
    66e8:	00 e0       	ldi	r16, 0x00	; 0
    66ea:	83 e0       	ldi	r24, 0x03	; 3
    66ec:	64 e5       	ldi	r22, 0x54	; 84
    66ee:	23 e0       	ldi	r18, 0x03	; 3
    66f0:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <LCD_WriteValue>
	LCD_WriteValue(4,84,Config.GyroParams[subindex].ComplementaryFilterAlpha,3,7==subpage);
    66f4:	80 91 3d 05 	lds	r24, 0x053D
    66f8:	90 e0       	ldi	r25, 0x00	; 0
    66fa:	88 0f       	add	r24, r24
    66fc:	99 1f       	adc	r25, r25
    66fe:	fc 01       	movw	r30, r24
    6700:	a3 e0       	ldi	r26, 0x03	; 3
    6702:	ee 0f       	add	r30, r30
    6704:	ff 1f       	adc	r31, r31
    6706:	aa 95       	dec	r26
    6708:	e1 f7       	brne	.-8      	; 0x6702 <_hStabilization+0x39a>
    670a:	e8 1b       	sub	r30, r24
    670c:	f9 0b       	sbc	r31, r25
    670e:	e5 51       	subi	r30, 0x15	; 21
    6710:	f9 4f       	sbci	r31, 0xF9	; 249
    6712:	44 8d       	ldd	r20, Z+28	; 0x1c
    6714:	55 8d       	ldd	r21, Z+29	; 0x1d
    6716:	01 e0       	ldi	r16, 0x01	; 1
    6718:	80 91 3c 05 	lds	r24, 0x053C
    671c:	87 30       	cpi	r24, 0x07	; 7
    671e:	09 f0       	breq	.+2      	; 0x6722 <_hStabilization+0x3ba>
    6720:	00 e0       	ldi	r16, 0x00	; 0
    6722:	84 e0       	ldi	r24, 0x04	; 4
    6724:	64 e5       	ldi	r22, 0x54	; 84
    6726:	23 e0       	ldi	r18, 0x03	; 3
    6728:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <LCD_WriteValue>
	
	
}
    672c:	0f 91       	pop	r16
    672e:	ef 90       	pop	r14
    6730:	08 95       	ret

00006732 <_hMiscSettings>:
	_helper_DisplayBiStateText(4,84, strYes, strNo, (IS_MISC_SENSOR_SONAR_ENABLED ==true),(subpage==4));
}


void _hMiscSettings()
{
    6732:	cf 92       	push	r12
    6734:	ef 92       	push	r14
    6736:	ff 92       	push	r15
    6738:	0f 93       	push	r16
    673a:	1f 93       	push	r17
	NOKEYRETURN;
    673c:	80 91 be 05 	lds	r24, 0x05BE
    6740:	88 23       	and	r24, r24
    6742:	09 f4       	brne	.+2      	; 0x6746 <_hMiscSettings+0x14>
    6744:	a8 c0       	rjmp	.+336    	; 0x6896 <_hMiscSettings+0x164>
	PageKey(5);
    6746:	85 e0       	ldi	r24, 0x05	; 5
    6748:	0e 94 e8 2e 	call	0x5dd0	; 0x5dd0 <PageKey>
	
		
	if (KEY4)
    674c:	20 91 be 05 	lds	r18, 0x05BE
    6750:	24 ff       	sbrs	r18, 4
    6752:	3f c0       	rjmp	.+126    	; 0x67d2 <_hMiscSettings+0xa0>
	{
		bValueChanged = true;
    6754:	81 e0       	ldi	r24, 0x01	; 1
    6756:	80 93 38 05 	sts	0x0538, r24
		currentPage.softkeys = _skMENUSAVE;
    675a:	80 e1       	ldi	r24, 0x10	; 16
    675c:	9c e0       	ldi	r25, 0x0C	; 12
    675e:	90 93 47 05 	sts	0x0547, r25
    6762:	80 93 46 05 	sts	0x0546, r24
		
		switch (subpage)
    6766:	80 91 3c 05 	lds	r24, 0x053C
    676a:	82 30       	cpi	r24, 0x02	; 2
    676c:	d1 f0       	breq	.+52     	; 0x67a2 <_hMiscSettings+0x70>
    676e:	83 30       	cpi	r24, 0x03	; 3
    6770:	28 f4       	brcc	.+10     	; 0x677c <_hMiscSettings+0x4a>
    6772:	88 23       	and	r24, r24
    6774:	41 f0       	breq	.+16     	; 0x6786 <_hMiscSettings+0x54>
    6776:	81 30       	cpi	r24, 0x01	; 1
    6778:	61 f5       	brne	.+88     	; 0x67d2 <_hMiscSettings+0xa0>
    677a:	0c c0       	rjmp	.+24     	; 0x6794 <_hMiscSettings+0x62>
    677c:	83 30       	cpi	r24, 0x03	; 3
    677e:	c1 f0       	breq	.+48     	; 0x67b0 <_hMiscSettings+0x7e>
    6780:	84 30       	cpi	r24, 0x04	; 4
    6782:	39 f5       	brne	.+78     	; 0x67d2 <_hMiscSettings+0xa0>
    6784:	1f c0       	rjmp	.+62     	; 0x67c4 <_hMiscSettings+0x92>
		{
			case 0: startEditMode(&(Config.AutoDisarm),0,10,TYPE_UINT8); return ;
    6786:	82 ef       	ldi	r24, 0xF2	; 242
    6788:	96 e0       	ldi	r25, 0x06	; 6
    678a:	60 e0       	ldi	r22, 0x00	; 0
    678c:	70 e0       	ldi	r23, 0x00	; 0
    678e:	4a e0       	ldi	r20, 0x0A	; 10
    6790:	50 e0       	ldi	r21, 0x00	; 0
    6792:	14 c0       	rjmp	.+40     	; 0x67bc <_hMiscSettings+0x8a>
			case 1: startEditMode(&(Config.VoltageAlarm),0,120,TYPE_UINT8);  return ;
    6794:	8d e5       	ldi	r24, 0x5D	; 93
    6796:	97 e0       	ldi	r25, 0x07	; 7
    6798:	60 e0       	ldi	r22, 0x00	; 0
    679a:	70 e0       	ldi	r23, 0x00	; 0
    679c:	48 e7       	ldi	r20, 0x78	; 120
    679e:	50 e0       	ldi	r21, 0x00	; 0
    67a0:	0d c0       	rjmp	.+26     	; 0x67bc <_hMiscSettings+0x8a>
			case 2: startEditMode(&(Config.ThrottleMin),0,255,TYPE_UINT8);  return ;
    67a2:	88 ef       	ldi	r24, 0xF8	; 248
    67a4:	96 e0       	ldi	r25, 0x06	; 6
    67a6:	60 e0       	ldi	r22, 0x00	; 0
    67a8:	70 e0       	ldi	r23, 0x00	; 0
    67aa:	4f ef       	ldi	r20, 0xFF	; 255
    67ac:	50 e0       	ldi	r21, 0x00	; 0
    67ae:	06 c0       	rjmp	.+12     	; 0x67bc <_hMiscSettings+0x8a>
			case 3: startEditMode(&(Config.StickScaling),1,20,TYPE_UINT8);  return ;
    67b0:	89 ef       	ldi	r24, 0xF9	; 249
    67b2:	96 e0       	ldi	r25, 0x06	; 6
    67b4:	61 e0       	ldi	r22, 0x01	; 1
    67b6:	70 e0       	ldi	r23, 0x00	; 0
    67b8:	44 e1       	ldi	r20, 0x14	; 20
    67ba:	50 e0       	ldi	r21, 0x00	; 0
    67bc:	22 e0       	ldi	r18, 0x02	; 2
    67be:	0e 94 9a 2e 	call	0x5d34	; 0x5d34 <startEditMode>
    67c2:	69 c0       	rjmp	.+210    	; 0x6896 <_hMiscSettings+0x164>
			case 4:	Config.PitchRollLinked=  ((~Config.PitchRollLinked) & 0x01); break; 
    67c4:	90 91 b3 07 	lds	r25, 0x07B3
    67c8:	81 e0       	ldi	r24, 0x01	; 1
    67ca:	90 fd       	sbrc	r25, 0
    67cc:	80 e0       	ldi	r24, 0x00	; 0
    67ce:	80 93 b3 07 	sts	0x07B3, r24
		}
		
	}
	
	if (KEY1)
    67d2:	27 ff       	sbrs	r18, 7
    67d4:	02 c0       	rjmp	.+4      	; 0x67da <_hMiscSettings+0xa8>
	{
		_helper_SaveinEEPROM_ifChanged();
    67d6:	0e 94 96 2a 	call	0x552c	; 0x552c <_helper_SaveinEEPROM_ifChanged>
	}
	
	LCD_WriteValue(0,84,Config.AutoDisarm,3,0==subpage);
    67da:	40 91 f2 06 	lds	r20, 0x06F2
    67de:	01 e0       	ldi	r16, 0x01	; 1
    67e0:	80 91 3c 05 	lds	r24, 0x053C
    67e4:	81 11       	cpse	r24, r1
    67e6:	00 e0       	ldi	r16, 0x00	; 0
    67e8:	80 e0       	ldi	r24, 0x00	; 0
    67ea:	64 e5       	ldi	r22, 0x54	; 84
    67ec:	50 e0       	ldi	r21, 0x00	; 0
    67ee:	23 e0       	ldi	r18, 0x03	; 3
    67f0:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <LCD_WriteValue>
	double volt = (double)(Config.VoltageAlarm/10.0f);
    67f4:	60 91 5d 07 	lds	r22, 0x075D
    67f8:	70 e0       	ldi	r23, 0x00	; 0
    67fa:	88 27       	eor	r24, r24
    67fc:	77 fd       	sbrc	r23, 7
    67fe:	80 95       	com	r24
    6800:	98 2f       	mov	r25, r24
    6802:	0e 94 36 37 	call	0x6e6c	; 0x6e6c <__floatsisf>
    6806:	20 e0       	ldi	r18, 0x00	; 0
    6808:	30 e0       	ldi	r19, 0x00	; 0
    680a:	40 e2       	ldi	r20, 0x20	; 32
    680c:	51 e4       	ldi	r21, 0x41	; 65
    680e:	0e 94 9b 36 	call	0x6d36	; 0x6d36 <__divsf3>
    6812:	9b 01       	movw	r18, r22
    6814:	ac 01       	movw	r20, r24
	LCD_WriteValue_double_ex(1,84,volt,8,1==subpage); 
    6816:	91 e0       	ldi	r25, 0x01	; 1
    6818:	80 91 3c 05 	lds	r24, 0x053C
    681c:	81 30       	cpi	r24, 0x01	; 1
    681e:	09 f0       	breq	.+2      	; 0x6822 <_hMiscSettings+0xf0>
    6820:	90 e0       	ldi	r25, 0x00	; 0
    6822:	81 e0       	ldi	r24, 0x01	; 1
    6824:	64 e5       	ldi	r22, 0x54	; 84
    6826:	08 e0       	ldi	r16, 0x08	; 8
    6828:	e9 2e       	mov	r14, r25
    682a:	0e 94 ba 0d 	call	0x1b74	; 0x1b74 <LCD_WriteValue_double_ex>
	//LCD_WriteValue(1,84,Config.VoltageAlarm,3,1==subpage);
	LCD_WriteValue(2,84,Config.ThrottleMin,3,2==subpage);
    682e:	40 91 f8 06 	lds	r20, 0x06F8
    6832:	01 e0       	ldi	r16, 0x01	; 1
    6834:	80 91 3c 05 	lds	r24, 0x053C
    6838:	82 30       	cpi	r24, 0x02	; 2
    683a:	09 f0       	breq	.+2      	; 0x683e <_hMiscSettings+0x10c>
    683c:	00 e0       	ldi	r16, 0x00	; 0
    683e:	82 e0       	ldi	r24, 0x02	; 2
    6840:	64 e5       	ldi	r22, 0x54	; 84
    6842:	50 e0       	ldi	r21, 0x00	; 0
    6844:	23 e0       	ldi	r18, 0x03	; 3
    6846:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <LCD_WriteValue>
	LCD_WriteValue(3,84,Config.StickScaling,3,3==subpage);
    684a:	40 91 f9 06 	lds	r20, 0x06F9
    684e:	01 e0       	ldi	r16, 0x01	; 1
    6850:	80 91 3c 05 	lds	r24, 0x053C
    6854:	83 30       	cpi	r24, 0x03	; 3
    6856:	09 f0       	breq	.+2      	; 0x685a <_hMiscSettings+0x128>
    6858:	00 e0       	ldi	r16, 0x00	; 0
    685a:	83 e0       	ldi	r24, 0x03	; 3
    685c:	64 e5       	ldi	r22, 0x54	; 84
    685e:	50 e0       	ldi	r21, 0x00	; 0
    6860:	23 e0       	ldi	r18, 0x03	; 3
    6862:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <LCD_WriteValue>
	_helper_Words (4,84,(4==subpage),(Config.PitchRollLinked),PSTR("yes"),PSTR("no "),5);
    6866:	41 e0       	ldi	r20, 0x01	; 1
    6868:	80 91 3c 05 	lds	r24, 0x053C
    686c:	84 30       	cpi	r24, 0x04	; 4
    686e:	09 f0       	breq	.+2      	; 0x6872 <_hMiscSettings+0x140>
    6870:	40 e0       	ldi	r20, 0x00	; 0
    6872:	21 e0       	ldi	r18, 0x01	; 1
    6874:	80 91 b3 07 	lds	r24, 0x07B3
    6878:	88 23       	and	r24, r24
    687a:	09 f4       	brne	.+2      	; 0x687e <_hMiscSettings+0x14c>
    687c:	20 e0       	ldi	r18, 0x00	; 0
    687e:	84 e0       	ldi	r24, 0x04	; 4
    6880:	64 e5       	ldi	r22, 0x54	; 84
    6882:	00 ea       	ldi	r16, 0xA0	; 160
    6884:	1c e0       	ldi	r17, 0x0C	; 12
    6886:	fc e9       	ldi	r31, 0x9C	; 156
    6888:	ef 2e       	mov	r14, r31
    688a:	fc e0       	ldi	r31, 0x0C	; 12
    688c:	ff 2e       	mov	r15, r31
    688e:	e5 e0       	ldi	r30, 0x05	; 5
    6890:	ce 2e       	mov	r12, r30
    6892:	0e 94 a3 2c 	call	0x5946	; 0x5946 <_helper_Words>
	
		
}
    6896:	1f 91       	pop	r17
    6898:	0f 91       	pop	r16
    689a:	ff 90       	pop	r15
    689c:	ef 90       	pop	r14
    689e:	cf 90       	pop	r12
    68a0:	08 95       	ret

000068a2 <_hModeSettings>:
	
}

bool bNeedRestart=false;
void _hModeSettings ()
{
    68a2:	cf 92       	push	r12
    68a4:	ef 92       	push	r14
    68a6:	ff 92       	push	r15
    68a8:	0f 93       	push	r16
    68aa:	1f 93       	push	r17
	NOKEYRETURN;
    68ac:	80 91 be 05 	lds	r24, 0x05BE
    68b0:	88 23       	and	r24, r24
    68b2:	09 f4       	brne	.+2      	; 0x68b6 <_hModeSettings+0x14>
    68b4:	db c0       	rjmp	.+438    	; 0x6a6c <_hModeSettings+0x1ca>
	PageKey(5);
    68b6:	85 e0       	ldi	r24, 0x05	; 5
    68b8:	0e 94 e8 2e 	call	0x5dd0	; 0x5dd0 <PageKey>
	
	if ((KEY1) && (bValueChanged==true))
    68bc:	80 91 be 05 	lds	r24, 0x05BE
    68c0:	87 ff       	sbrs	r24, 7
    68c2:	0f c0       	rjmp	.+30     	; 0x68e2 <_hModeSettings+0x40>
    68c4:	90 91 38 05 	lds	r25, 0x0538
    68c8:	91 30       	cpi	r25, 0x01	; 1
    68ca:	59 f4       	brne	.+22     	; 0x68e2 <_hModeSettings+0x40>
	{
		_helper_SaveinEEPROM_ifChanged();
    68cc:	0e 94 96 2a 	call	0x552c	; 0x552c <_helper_SaveinEEPROM_ifChanged>
		if (bNeedRestart==true) Menu_LoadPage(PAGE_RESTART);
    68d0:	80 91 39 05 	lds	r24, 0x0539
    68d4:	88 23       	and	r24, r24
    68d6:	09 f4       	brne	.+2      	; 0x68da <_hModeSettings+0x38>
    68d8:	c9 c0       	rjmp	.+402    	; 0x6a6c <_hModeSettings+0x1ca>
    68da:	84 e0       	ldi	r24, 0x04	; 4
    68dc:	0e 94 b9 2c 	call	0x5972	; 0x5972 <Menu_LoadPage>
    68e0:	c5 c0       	rjmp	.+394    	; 0x6a6c <_hModeSettings+0x1ca>
		return;
	}
	
	if (KEY4)
    68e2:	84 ff       	sbrs	r24, 4
    68e4:	3d c0       	rjmp	.+122    	; 0x6960 <_hModeSettings+0xbe>
	{
		bValueChanged = true;
    68e6:	91 e0       	ldi	r25, 0x01	; 1
    68e8:	90 93 38 05 	sts	0x0538, r25
		//currentPage.softkeys = _skMENUSAVE;
		switch (subpage)
    68ec:	80 91 3c 05 	lds	r24, 0x053C
    68f0:	82 30       	cpi	r24, 0x02	; 2
    68f2:	f9 f0       	breq	.+62     	; 0x6932 <_hModeSettings+0x90>
    68f4:	83 30       	cpi	r24, 0x03	; 3
    68f6:	28 f4       	brcc	.+10     	; 0x6902 <_hModeSettings+0x60>
    68f8:	88 23       	and	r24, r24
    68fa:	41 f0       	breq	.+16     	; 0x690c <_hModeSettings+0x6a>
    68fc:	81 30       	cpi	r24, 0x01	; 1
    68fe:	81 f5       	brne	.+96     	; 0x6960 <_hModeSettings+0xbe>
    6900:	10 c0       	rjmp	.+32     	; 0x6922 <_hModeSettings+0x80>
    6902:	83 30       	cpi	r24, 0x03	; 3
    6904:	f1 f0       	breq	.+60     	; 0x6942 <_hModeSettings+0xa0>
    6906:	84 30       	cpi	r24, 0x04	; 4
    6908:	59 f5       	brne	.+86     	; 0x6960 <_hModeSettings+0xbe>
    690a:	23 c0       	rjmp	.+70     	; 0x6952 <_hModeSettings+0xb0>
		{
			case 0: if (Config.FrameType==FRAMETYPE_QUADCOPTER) Config.FrameType=FRAMETYPE_TRICOPTER; else Config.FrameType=FRAMETYPE_QUADCOPTER; break;
    690c:	80 91 f4 06 	lds	r24, 0x06F4
    6910:	81 30       	cpi	r24, 0x01	; 1
    6912:	21 f4       	brne	.+8      	; 0x691c <_hModeSettings+0x7a>
    6914:	82 e0       	ldi	r24, 0x02	; 2
    6916:	80 93 f4 06 	sts	0x06F4, r24
    691a:	22 c0       	rjmp	.+68     	; 0x6960 <_hModeSettings+0xbe>
    691c:	90 93 f4 06 	sts	0x06F4, r25
    6920:	1f c0       	rjmp	.+62     	; 0x6960 <_hModeSettings+0xbe>
			case 1: Config.RX_mode=~Config.RX_mode; bNeedRestart = true; break;
    6922:	90 91 ef 06 	lds	r25, 0x06EF
    6926:	90 95       	com	r25
    6928:	90 93 ef 06 	sts	0x06EF, r25
    692c:	80 93 39 05 	sts	0x0539, r24
    6930:	17 c0       	rjmp	.+46     	; 0x6960 <_hModeSettings+0xbe>
			case 2: Config.BoardOrientationMode=((~Config.BoardOrientationMode) & 0x01); /* value either 0 or 1*/break;
    6932:	90 91 f5 06 	lds	r25, 0x06F5
    6936:	81 e0       	ldi	r24, 0x01	; 1
    6938:	90 fd       	sbrc	r25, 0
    693a:	80 e0       	ldi	r24, 0x00	; 0
    693c:	80 93 f5 06 	sts	0x06F5, r24
    6940:	0f c0       	rjmp	.+30     	; 0x6960 <_hModeSettings+0xbe>
			case 3: Config.QuadFlyingMode = ((~Config.QuadFlyingMode) & 0x01); /* value either 0 or 1*/break;
    6942:	90 91 f6 06 	lds	r25, 0x06F6
    6946:	81 e0       	ldi	r24, 0x01	; 1
    6948:	90 fd       	sbrc	r25, 0
    694a:	80 e0       	ldi	r24, 0x00	; 0
    694c:	80 93 f6 06 	sts	0x06F6, r24
    6950:	07 c0       	rjmp	.+14     	; 0x6960 <_hModeSettings+0xbe>
			case 4: Config.MiscSensors =  ((~Config.MiscSensors) & 0x01); break; // this condition should be rewritten if another sensor is added.
    6952:	90 91 fa 06 	lds	r25, 0x06FA
    6956:	81 e0       	ldi	r24, 0x01	; 1
    6958:	90 fd       	sbrc	r25, 0
    695a:	80 e0       	ldi	r24, 0x00	; 0
    695c:	80 93 fa 06 	sts	0x06FA, r24
		}
	}
	
	_helper_Words  (0,84,(subpage==0),(Config.FrameType== FRAMETYPE_QUADCOPTER),PSTR("Quad"),PSTR("TRI "),5);
    6960:	41 e0       	ldi	r20, 0x01	; 1
    6962:	80 91 3c 05 	lds	r24, 0x053C
    6966:	81 11       	cpse	r24, r1
    6968:	40 e0       	ldi	r20, 0x00	; 0
    696a:	21 e0       	ldi	r18, 0x01	; 1
    696c:	80 91 f4 06 	lds	r24, 0x06F4
    6970:	81 30       	cpi	r24, 0x01	; 1
    6972:	09 f0       	breq	.+2      	; 0x6976 <_hModeSettings+0xd4>
    6974:	20 e0       	ldi	r18, 0x00	; 0
    6976:	80 e0       	ldi	r24, 0x00	; 0
    6978:	64 e5       	ldi	r22, 0x54	; 84
    697a:	07 ee       	ldi	r16, 0xE7	; 231
    697c:	1c e0       	ldi	r17, 0x0C	; 12
    697e:	a2 ee       	ldi	r26, 0xE2	; 226
    6980:	ea 2e       	mov	r14, r26
    6982:	ac e0       	ldi	r26, 0x0C	; 12
    6984:	fa 2e       	mov	r15, r26
    6986:	f5 e0       	ldi	r31, 0x05	; 5
    6988:	cf 2e       	mov	r12, r31
    698a:	0e 94 a3 2c 	call	0x5946	; 0x5946 <_helper_Words>
	_helper_Words  (1,84,(subpage==1),(Config.RX_mode== RX_mode_BuddyMode),PSTR("Buddy"),PSTR("UART "),5);
    698e:	41 e0       	ldi	r20, 0x01	; 1
    6990:	80 91 3c 05 	lds	r24, 0x053C
    6994:	81 30       	cpi	r24, 0x01	; 1
    6996:	09 f0       	breq	.+2      	; 0x699a <_hModeSettings+0xf8>
    6998:	40 e0       	ldi	r20, 0x00	; 0
    699a:	21 e0       	ldi	r18, 0x01	; 1
    699c:	80 91 ef 06 	lds	r24, 0x06EF
    69a0:	81 11       	cpse	r24, r1
    69a2:	20 e0       	ldi	r18, 0x00	; 0
    69a4:	81 e0       	ldi	r24, 0x01	; 1
    69a6:	64 e5       	ldi	r22, 0x54	; 84
    69a8:	0c ed       	ldi	r16, 0xDC	; 220
    69aa:	1c e0       	ldi	r17, 0x0C	; 12
    69ac:	e6 ed       	ldi	r30, 0xD6	; 214
    69ae:	ee 2e       	mov	r14, r30
    69b0:	ec e0       	ldi	r30, 0x0C	; 12
    69b2:	fe 2e       	mov	r15, r30
    69b4:	75 e0       	ldi	r23, 0x05	; 5
    69b6:	c7 2e       	mov	r12, r23
    69b8:	0e 94 a3 2c 	call	0x5946	; 0x5946 <_helper_Words>
	_helper_Words (2,84,(subpage==2),(Config.BoardOrientationMode == QuadFlyingMode_PLUS),PSTR("+ Quad"),PSTR("X Quad"),6);
    69bc:	41 e0       	ldi	r20, 0x01	; 1
    69be:	80 91 3c 05 	lds	r24, 0x053C
    69c2:	82 30       	cpi	r24, 0x02	; 2
    69c4:	09 f0       	breq	.+2      	; 0x69c8 <_hModeSettings+0x126>
    69c6:	40 e0       	ldi	r20, 0x00	; 0
    69c8:	21 e0       	ldi	r18, 0x01	; 1
    69ca:	80 91 f5 06 	lds	r24, 0x06F5
    69ce:	81 11       	cpse	r24, r1
    69d0:	20 e0       	ldi	r18, 0x00	; 0
    69d2:	82 e0       	ldi	r24, 0x02	; 2
    69d4:	64 e5       	ldi	r22, 0x54	; 84
    69d6:	0f ec       	ldi	r16, 0xCF	; 207
    69d8:	1c e0       	ldi	r17, 0x0C	; 12
    69da:	58 ec       	ldi	r21, 0xC8	; 200
    69dc:	e5 2e       	mov	r14, r21
    69de:	5c e0       	ldi	r21, 0x0C	; 12
    69e0:	f5 2e       	mov	r15, r21
    69e2:	36 e0       	ldi	r19, 0x06	; 6
    69e4:	c3 2e       	mov	r12, r19
    69e6:	0e 94 a3 2c 	call	0x5946	; 0x5946 <_helper_Words>
	if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    69ea:	90 91 f4 06 	lds	r25, 0x06F4
    69ee:	80 91 3c 05 	lds	r24, 0x053C
    69f2:	91 30       	cpi	r25, 0x01	; 1
    69f4:	91 f4       	brne	.+36     	; 0x6a1a <_hModeSettings+0x178>
	{
		_helper_Words (3,84,(subpage==3),(Config.QuadFlyingMode == QuadFlyingMode_PLUS),PSTR("+ Quad"),PSTR("X Quad"),6);
    69f6:	41 e0       	ldi	r20, 0x01	; 1
    69f8:	83 30       	cpi	r24, 0x03	; 3
    69fa:	09 f0       	breq	.+2      	; 0x69fe <_hModeSettings+0x15c>
    69fc:	40 e0       	ldi	r20, 0x00	; 0
    69fe:	21 e0       	ldi	r18, 0x01	; 1
    6a00:	80 91 f6 06 	lds	r24, 0x06F6
    6a04:	81 11       	cpse	r24, r1
    6a06:	20 e0       	ldi	r18, 0x00	; 0
    6a08:	83 e0       	ldi	r24, 0x03	; 3
    6a0a:	64 e5       	ldi	r22, 0x54	; 84
    6a0c:	01 ec       	ldi	r16, 0xC1	; 193
    6a0e:	1c e0       	ldi	r17, 0x0C	; 12
    6a10:	9a eb       	ldi	r25, 0xBA	; 186
    6a12:	e9 2e       	mov	r14, r25
    6a14:	9c e0       	ldi	r25, 0x0C	; 12
    6a16:	f9 2e       	mov	r15, r25
    6a18:	11 c0       	rjmp	.+34     	; 0x6a3c <_hModeSettings+0x19a>
	}
	else
	{
		_helper_Words (3,84,(subpage==3),(Config.QuadFlyingMode == QuadFlyingMode_PLUS),PSTR("Y Tri "),PSTR("A Tri "),6);
    6a1a:	41 e0       	ldi	r20, 0x01	; 1
    6a1c:	83 30       	cpi	r24, 0x03	; 3
    6a1e:	09 f0       	breq	.+2      	; 0x6a22 <_hModeSettings+0x180>
    6a20:	40 e0       	ldi	r20, 0x00	; 0
    6a22:	21 e0       	ldi	r18, 0x01	; 1
    6a24:	80 91 f6 06 	lds	r24, 0x06F6
    6a28:	81 11       	cpse	r24, r1
    6a2a:	20 e0       	ldi	r18, 0x00	; 0
    6a2c:	83 e0       	ldi	r24, 0x03	; 3
    6a2e:	64 e5       	ldi	r22, 0x54	; 84
    6a30:	03 eb       	ldi	r16, 0xB3	; 179
    6a32:	1c e0       	ldi	r17, 0x0C	; 12
    6a34:	bc ea       	ldi	r27, 0xAC	; 172
    6a36:	eb 2e       	mov	r14, r27
    6a38:	bc e0       	ldi	r27, 0x0C	; 12
    6a3a:	fb 2e       	mov	r15, r27
    6a3c:	a6 e0       	ldi	r26, 0x06	; 6
    6a3e:	ca 2e       	mov	r12, r26
    6a40:	0e 94 a3 2c 	call	0x5946	; 0x5946 <_helper_Words>
	}	
	_helper_DisplayBiStateText(4,84, strYes, strNo, (IS_MISC_SENSOR_SONAR_ENABLED ==true),(subpage==4));
    6a44:	00 91 fa 06 	lds	r16, 0x06FA
    6a48:	10 e0       	ldi	r17, 0x00	; 0
    6a4a:	01 70       	andi	r16, 0x01	; 1
    6a4c:	10 70       	andi	r17, 0x00	; 0
    6a4e:	91 e0       	ldi	r25, 0x01	; 1
    6a50:	80 91 3c 05 	lds	r24, 0x053C
    6a54:	84 30       	cpi	r24, 0x04	; 4
    6a56:	09 f0       	breq	.+2      	; 0x6a5a <_hModeSettings+0x1b8>
    6a58:	90 e0       	ldi	r25, 0x00	; 0
    6a5a:	84 e0       	ldi	r24, 0x04	; 4
    6a5c:	64 e5       	ldi	r22, 0x54	; 84
    6a5e:	44 ea       	ldi	r20, 0xA4	; 164
    6a60:	5c e0       	ldi	r21, 0x0C	; 12
    6a62:	28 ea       	ldi	r18, 0xA8	; 168
    6a64:	3c e0       	ldi	r19, 0x0C	; 12
    6a66:	e9 2e       	mov	r14, r25
    6a68:	0e 94 6a 2a 	call	0x54d4	; 0x54d4 <_helper_DisplayBiStateText>
}
    6a6c:	1f 91       	pop	r17
    6a6e:	0f 91       	pop	r16
    6a70:	ff 90       	pop	r15
    6a72:	ef 90       	pop	r14
    6a74:	cf 90       	pop	r12
    6a76:	08 95       	ret

00006a78 <doMenu>:

/*
//	Draw the menu
*/
uint8_t doMenu(menu_t *menu)
{
    6a78:	ef 92       	push	r14
    6a7a:	ff 92       	push	r15
    6a7c:	0f 93       	push	r16
    6a7e:	1f 93       	push	r17
    6a80:	cf 93       	push	r28
    6a82:	df 93       	push	r29
    6a84:	ec 01       	movw	r28, r24
	UIEnableStickCommands=true;
    6a86:	81 e0       	ldi	r24, 0x01	; 1
    6a88:	80 93 e9 05 	sts	0x05E9, r24
	
	if (!_mykey) return 0;
    6a8c:	80 91 be 05 	lds	r24, 0x05BE
    6a90:	88 23       	and	r24, r24
    6a92:	09 f4       	brne	.+2      	; 0x6a96 <doMenu+0x1e>
    6a94:	70 c0       	rjmp	.+224    	; 0x6b76 <doMenu+0xfe>
	
	// key handling
	if (KEY2)		// UP
    6a96:	86 ff       	sbrs	r24, 6
    6a98:	06 c0       	rjmp	.+12     	; 0x6aa6 <doMenu+0x2e>
	{
		if (menu->marked > 0) 
    6a9a:	8c 81       	ldd	r24, Y+4	; 0x04
    6a9c:	88 23       	and	r24, r24
    6a9e:	99 f0       	breq	.+38     	; 0x6ac6 <doMenu+0x4e>
			menu->marked--;
    6aa0:	81 50       	subi	r24, 0x01	; 1
    6aa2:	8c 83       	std	Y+4, r24	; 0x04
    6aa4:	10 c0       	rjmp	.+32     	; 0x6ac6 <doMenu+0x4e>
	}
	else if (KEY3)		// DOWN
    6aa6:	85 ff       	sbrs	r24, 5
    6aa8:	0c c0       	rjmp	.+24     	; 0x6ac2 <doMenu+0x4a>
	{
		if (menu->marked < menu->len - 1) 
    6aaa:	4c 81       	ldd	r20, Y+4	; 0x04
    6aac:	24 2f       	mov	r18, r20
    6aae:	30 e0       	ldi	r19, 0x00	; 0
    6ab0:	88 81       	ld	r24, Y
    6ab2:	90 e0       	ldi	r25, 0x00	; 0
    6ab4:	01 97       	sbiw	r24, 0x01	; 1
    6ab6:	28 17       	cp	r18, r24
    6ab8:	39 07       	cpc	r19, r25
    6aba:	2c f4       	brge	.+10     	; 0x6ac6 <doMenu+0x4e>
			menu->marked++;
    6abc:	4f 5f       	subi	r20, 0xFF	; 255
    6abe:	4c 83       	std	Y+4, r20	; 0x04
    6ac0:	02 c0       	rjmp	.+4      	; 0x6ac6 <doMenu+0x4e>
	}
	else if (KEY4)		// ENTER
    6ac2:	84 fd       	sbrc	r24, 4
    6ac4:	56 c0       	rjmp	.+172    	; 0x6b72 <doMenu+0xfa>
		return 1;

	if (menu->marked < menu->top)
    6ac6:	2c 81       	ldd	r18, Y+4	; 0x04
    6ac8:	3b 81       	ldd	r19, Y+3	; 0x03
    6aca:	23 17       	cp	r18, r19
    6acc:	40 f0       	brcs	.+16     	; 0x6ade <doMenu+0x66>
		menu->top = menu->marked;
	else if (menu->marked - menu->top >= 5)
    6ace:	82 2f       	mov	r24, r18
    6ad0:	90 e0       	ldi	r25, 0x00	; 0
    6ad2:	83 1b       	sub	r24, r19
    6ad4:	91 09       	sbc	r25, r1
    6ad6:	85 30       	cpi	r24, 0x05	; 5
    6ad8:	91 05       	cpc	r25, r1
    6ada:	14 f0       	brlt	.+4      	; 0x6ae0 <doMenu+0x68>
		menu->top = menu->marked - 4;
    6adc:	24 50       	subi	r18, 0x04	; 4
    6ade:	2b 83       	std	Y+3, r18	; 0x03
	
	// text output
	LCD_SetPos(0, 58);
    6ae0:	80 e0       	ldi	r24, 0x00	; 0
    6ae2:	6a e3       	ldi	r22, 0x3A	; 58
    6ae4:	0e 94 10 0c 	call	0x1820	; 0x1820 <LCD_SetPos>
	if (menu->top > 0)
    6ae8:	8b 81       	ldd	r24, Y+3	; 0x03
    6aea:	88 23       	and	r24, r24
    6aec:	29 f0       	breq	.+10     	; 0x6af8 <doMenu+0x80>
		lcdWriteGlyph_P(&glyArrowUp, 0);
    6aee:	85 ea       	ldi	r24, 0xA5	; 165
    6af0:	99 e0       	ldi	r25, 0x09	; 9
    6af2:	60 e0       	ldi	r22, 0x00	; 0
    6af4:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <lcdWriteGlyph_P>

/*
//	Draw the menu
*/
uint8_t doMenu(menu_t *menu)
{
    6af8:	00 e0       	ldi	r16, 0x00	; 0
    6afa:	10 e0       	ldi	r17, 0x00	; 0
    6afc:	21 c0       	rjmp	.+66     	; 0x6b40 <doMenu+0xc8>
	if (menu->top > 0)
		lcdWriteGlyph_P(&glyArrowUp, 0);
		
	for (uint8_t i = 0; i < 5 && i < menu->len; i++)
	{
		LCD_SetPos(i + 1, 0);
    6afe:	8e 2d       	mov	r24, r14
    6b00:	8f 5f       	subi	r24, 0xFF	; 255
    6b02:	60 e0       	ldi	r22, 0x00	; 0
    6b04:	0e 94 10 0c 	call	0x1820	; 0x1820 <LCD_SetPos>
		PGM_P item = menu->textSelector(menu->top + i);
    6b08:	8b 81       	ldd	r24, Y+3	; 0x03
    6b0a:	e9 81       	ldd	r30, Y+1	; 0x01
    6b0c:	fa 81       	ldd	r31, Y+2	; 0x02
    6b0e:	8e 0d       	add	r24, r14
    6b10:	09 95       	icall
    6b12:	7c 01       	movw	r14, r24
		lcdReverse(menu->top + i == menu->marked);
    6b14:	8b 81       	ldd	r24, Y+3	; 0x03
    6b16:	a8 01       	movw	r20, r16
    6b18:	48 0f       	add	r20, r24
    6b1a:	51 1d       	adc	r21, r1
    6b1c:	2c 81       	ldd	r18, Y+4	; 0x04
    6b1e:	30 e0       	ldi	r19, 0x00	; 0
    6b20:	81 e0       	ldi	r24, 0x01	; 1
    6b22:	42 17       	cp	r20, r18
    6b24:	53 07       	cpc	r21, r19
    6b26:	09 f0       	breq	.+2      	; 0x6b2a <doMenu+0xb2>
    6b28:	80 e0       	ldi	r24, 0x00	; 0
    6b2a:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <lcdReverse>
		LCD_WritePadded_P(item, 21);
    6b2e:	c7 01       	movw	r24, r14
    6b30:	65 e1       	ldi	r22, 0x15	; 21
    6b32:	0e 94 7c 0d 	call	0x1af8	; 0x1af8 <LCD_WritePadded_P>
    6b36:	0f 5f       	subi	r16, 0xFF	; 255
    6b38:	1f 4f       	sbci	r17, 0xFF	; 255
	// text output
	LCD_SetPos(0, 58);
	if (menu->top > 0)
		lcdWriteGlyph_P(&glyArrowUp, 0);
		
	for (uint8_t i = 0; i < 5 && i < menu->len; i++)
    6b3a:	05 30       	cpi	r16, 0x05	; 5
    6b3c:	11 05       	cpc	r17, r1
    6b3e:	21 f0       	breq	.+8      	; 0x6b48 <doMenu+0xd0>
    6b40:	e0 2e       	mov	r14, r16
    6b42:	88 81       	ld	r24, Y
    6b44:	08 17       	cp	r16, r24
    6b46:	d8 f2       	brcs	.-74     	; 0x6afe <doMenu+0x86>
		PGM_P item = menu->textSelector(menu->top + i);
		lcdReverse(menu->top + i == menu->marked);
		LCD_WritePadded_P(item, 21);
	}

	lcdReverse(0);
    6b48:	80 e0       	ldi	r24, 0x00	; 0
    6b4a:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <lcdReverse>


	LCD_SetPos(6, 58);
    6b4e:	86 e0       	ldi	r24, 0x06	; 6
    6b50:	6a e3       	ldi	r22, 0x3A	; 58
    6b52:	0e 94 10 0c 	call	0x1820	; 0x1820 <LCD_SetPos>
	if (menu->top < menu->len - 5)
    6b56:	2b 81       	ldd	r18, Y+3	; 0x03
    6b58:	30 e0       	ldi	r19, 0x00	; 0
    6b5a:	88 81       	ld	r24, Y
    6b5c:	90 e0       	ldi	r25, 0x00	; 0
    6b5e:	05 97       	sbiw	r24, 0x05	; 5
    6b60:	28 17       	cp	r18, r24
    6b62:	39 07       	cpc	r19, r25
    6b64:	44 f4       	brge	.+16     	; 0x6b76 <doMenu+0xfe>
		lcdWriteGlyph_P(&glyArrowDown, 0);
    6b66:	8f ea       	ldi	r24, 0xAF	; 175
    6b68:	99 e0       	ldi	r25, 0x09	; 9
    6b6a:	60 e0       	ldi	r22, 0x00	; 0
    6b6c:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <lcdWriteGlyph_P>
    6b70:	02 c0       	rjmp	.+4      	; 0x6b76 <doMenu+0xfe>
	{
		if (menu->marked < menu->len - 1) 
			menu->marked++;
	}
	else if (KEY4)		// ENTER
		return 1;
    6b72:	81 e0       	ldi	r24, 0x01	; 1
    6b74:	01 c0       	rjmp	.+2      	; 0x6b78 <doMenu+0x100>

	LCD_SetPos(6, 58);
	if (menu->top < menu->len - 5)
		lcdWriteGlyph_P(&glyArrowDown, 0);
	
	return 0;
    6b76:	80 e0       	ldi	r24, 0x00	; 0
}
    6b78:	df 91       	pop	r29
    6b7a:	cf 91       	pop	r28
    6b7c:	1f 91       	pop	r17
    6b7e:	0f 91       	pop	r16
    6b80:	ff 90       	pop	r15
    6b82:	ef 90       	pop	r14
    6b84:	08 95       	ret

00006b86 <_hMenu>:


void _hMenu()
{
	if (doMenu(&mnuMain))
    6b86:	8c e1       	ldi	r24, 0x1C	; 28
    6b88:	91 e0       	ldi	r25, 0x01	; 1
    6b8a:	0e 94 3c 35 	call	0x6a78	; 0x6a78 <doMenu>
    6b8e:	88 23       	and	r24, r24
    6b90:	91 f0       	breq	.+36     	; 0x6bb6 <_hMenu+0x30>
	{	// if menu item selected then open it if...
		if (menuEnabled[mnuMain.marked + MENU_START_INDEX]==1)
    6b92:	80 91 20 01 	lds	r24, 0x0120
    6b96:	e8 2f       	mov	r30, r24
    6b98:	f0 e0       	ldi	r31, 0x00	; 0
    6b9a:	ea 51       	subi	r30, 0x1A	; 26
    6b9c:	f8 4f       	sbci	r31, 0xF8	; 248
    6b9e:	95 81       	ldd	r25, Z+5	; 0x05
    6ba0:	91 30       	cpi	r25, 0x01	; 1
    6ba2:	21 f4       	brne	.+8      	; 0x6bac <_hMenu+0x26>
		{ //... the menu item is enabled 
			Menu_LoadPage(mnuMain.marked + MENU_START_INDEX);
    6ba4:	8b 5f       	subi	r24, 0xFB	; 251
    6ba6:	0e 94 b9 2c 	call	0x5972	; 0x5972 <Menu_LoadPage>
    6baa:	08 95       	ret
		}
		else
		{ //... else flash light and ignore command
			LED_FlashOrangeLED(LED_SHORT_TOGGLE,2);
    6bac:	8e e1       	ldi	r24, 0x1E	; 30
    6bae:	90 e0       	ldi	r25, 0x00	; 0
    6bb0:	62 e0       	ldi	r22, 0x02	; 2
    6bb2:	0e 94 9b 0e 	call	0x1d36	; 0x1d36 <LED_FlashOrangeLED>
    6bb6:	08 95       	ret

00006bb8 <Menu_MenuShow>:

void Menu_MenuShow()
{
	
	
	_mykey = Keyboard_Read();
    6bb8:	0e 94 c0 0b 	call	0x1780	; 0x1780 <Keyboard_Read>
	_mykey = _mykey | _TXKeys;
    6bbc:	90 91 da 06 	lds	r25, 0x06DA
    6bc0:	98 2b       	or	r25, r24
    6bc2:	90 93 be 05 	sts	0x05BE, r25

	
	LCD_Disable();
    6bc6:	0e 94 45 0e 	call	0x1c8a	; 0x1c8a <LCD_Disable>
	if (oldPage != page)
    6bca:	90 91 3b 05 	lds	r25, 0x053B
    6bce:	80 91 3a 05 	lds	r24, 0x053A
    6bd2:	89 17       	cp	r24, r25
    6bd4:	59 f0       	breq	.+22     	; 0x6bec <Menu_MenuShow+0x34>
	{	// if this is a new page then KEY_INIT = true
		_mykey |= KEY_INIT;
    6bd6:	80 91 be 05 	lds	r24, 0x05BE
    6bda:	81 60       	ori	r24, 0x01	; 1
    6bdc:	80 93 be 05 	sts	0x05BE, r24
		subpage = 0;
    6be0:	10 92 3c 05 	sts	0x053C, r1
		subindex = 0;
    6be4:	10 92 3d 05 	sts	0x053D, r1
		oldPage = page;
    6be8:	90 93 3a 05 	sts	0x053A, r25
	}
	defaultHandler();
    6bec:	0e 94 f1 2d 	call	0x5be2	; 0x5be2 <defaultHandler>
	LCD_Enable();
    6bf0:	0e 94 3c 0e 	call	0x1c78	; 0x1c78 <LCD_Enable>

	
	
	if (KEY1 && !editMode)	// BACK
    6bf4:	80 91 be 05 	lds	r24, 0x05BE
    6bf8:	87 ff       	sbrs	r24, 7
    6bfa:	15 c0       	rjmp	.+42     	; 0x6c26 <Menu_MenuShow+0x6e>
    6bfc:	80 91 fc 07 	lds	r24, 0x07FC
    6c00:	88 23       	and	r24, r24
    6c02:	89 f4       	brne	.+34     	; 0x6c26 <Menu_MenuShow+0x6e>
	{
		if (page > PAGE_MENU) // if any page then go to main menu
    6c04:	80 91 3b 05 	lds	r24, 0x053B
    6c08:	82 30       	cpi	r24, 0x02	; 2
    6c0a:	10 f0       	brcs	.+4      	; 0x6c10 <Menu_MenuShow+0x58>
			Menu_LoadPage(PAGE_MENU);
    6c0c:	81 e0       	ldi	r24, 0x01	; 1
    6c0e:	09 c0       	rjmp	.+18     	; 0x6c22 <Menu_MenuShow+0x6a>
		else if (page == PAGE_MENU)  // if menu page then goto HomePage
    6c10:	81 30       	cpi	r24, 0x01	; 1
    6c12:	49 f4       	brne	.+18     	; 0x6c26 <Menu_MenuShow+0x6e>
			{
				if (IsArmed == true)
    6c14:	80 91 cc 07 	lds	r24, 0x07CC
    6c18:	81 30       	cpi	r24, 0x01	; 1
    6c1a:	11 f4       	brne	.+4      	; 0x6c20 <Menu_MenuShow+0x68>
				{
					Menu_LoadPage(PAGE_HOME_ARMED);
    6c1c:	82 e0       	ldi	r24, 0x02	; 2
    6c1e:	01 c0       	rjmp	.+2      	; 0x6c22 <Menu_MenuShow+0x6a>
				}
				else
				{
					Menu_LoadPage(PAGE_HOME);
    6c20:	80 e0       	ldi	r24, 0x00	; 0
    6c22:	0e 94 b9 2c 	call	0x5972	; 0x5972 <Menu_LoadPage>
				}
			}							
	}
	
	
	if (KEYPRESS)
    6c26:	80 91 be 05 	lds	r24, 0x05BE
    6c2a:	80 7f       	andi	r24, 0xF0	; 240
    6c2c:	29 f0       	breq	.+10     	; 0x6c38 <Menu_MenuShow+0x80>
		Beeper_Beep(BEEP_KEY,1);
    6c2e:	86 e4       	ldi	r24, 0x46	; 70
    6c30:	90 e0       	ldi	r25, 0x00	; 0
    6c32:	61 e0       	ldi	r22, 0x01	; 1
    6c34:	0e 94 99 0b 	call	0x1732	; 0x1732 <Beeper_Beep>
		
	_TXKeys = 0; // No Key Pressed
    6c38:	10 92 da 06 	sts	0x06DA, r1
}
    6c3c:	08 95       	ret

00006c3e <Menu_MenuInit>:

void Menu_MenuInit()
{
	oldPage=0xff;
    6c3e:	8f ef       	ldi	r24, 0xFF	; 255
    6c40:	80 93 3a 05 	sts	0x053A, r24
	Menu_LoadPage(PAGE_HOME);
    6c44:	80 e0       	ldi	r24, 0x00	; 0
    6c46:	0e 94 b9 2c 	call	0x5972	; 0x5972 <Menu_LoadPage>
}
    6c4a:	08 95       	ret

00006c4c <tsmLoadModelLayout>:
}

PGM_P tsmLoadModelLayout(uint8_t index)
{
	//return (PGM_P)pgm_read_word(&mixerTable[index].Name);
}
    6c4c:	08 95       	ret

00006c4e <Menu_EnableAllItems>:


void Menu_EnableAllItems ()
{
    6c4e:	e6 ee       	ldi	r30, 0xE6	; 230
    6c50:	f7 e0       	ldi	r31, 0x07	; 7
	
	for (int i=0;i <MENU_ITEMS_COUNT;++i)
	{
		
		menuEnabled[i]=1;
    6c52:	81 e0       	ldi	r24, 0x01	; 1
    6c54:	81 93       	st	Z+, r24


void Menu_EnableAllItems ()
{
	
	for (int i=0;i <MENU_ITEMS_COUNT;++i)
    6c56:	97 e0       	ldi	r25, 0x07	; 7
    6c58:	e7 3f       	cpi	r30, 0xF7	; 247
    6c5a:	f9 07       	cpc	r31, r25
    6c5c:	d9 f7       	brne	.-10     	; 0x6c54 <Menu_EnableAllItems+0x6>
	{
		
		menuEnabled[i]=1;
	}
	menuEnabled[PAGE_DEBUG]=1;
    6c5e:	80 93 f5 07 	sts	0x07F5, r24
	
    6c62:	08 95       	ret

00006c64 <__subsf3>:
    6c64:	50 58       	subi	r21, 0x80	; 128

00006c66 <__addsf3>:
    6c66:	bb 27       	eor	r27, r27
    6c68:	aa 27       	eor	r26, r26
    6c6a:	0e d0       	rcall	.+28     	; 0x6c88 <__addsf3x>
    6c6c:	75 c1       	rjmp	.+746    	; 0x6f58 <__fp_round>
    6c6e:	66 d1       	rcall	.+716    	; 0x6f3c <__fp_pscA>
    6c70:	30 f0       	brcs	.+12     	; 0x6c7e <__addsf3+0x18>
    6c72:	6b d1       	rcall	.+726    	; 0x6f4a <__fp_pscB>
    6c74:	20 f0       	brcs	.+8      	; 0x6c7e <__addsf3+0x18>
    6c76:	31 f4       	brne	.+12     	; 0x6c84 <__addsf3+0x1e>
    6c78:	9f 3f       	cpi	r25, 0xFF	; 255
    6c7a:	11 f4       	brne	.+4      	; 0x6c80 <__addsf3+0x1a>
    6c7c:	1e f4       	brtc	.+6      	; 0x6c84 <__addsf3+0x1e>
    6c7e:	5b c1       	rjmp	.+694    	; 0x6f36 <__fp_nan>
    6c80:	0e f4       	brtc	.+2      	; 0x6c84 <__addsf3+0x1e>
    6c82:	e0 95       	com	r30
    6c84:	e7 fb       	bst	r30, 7
    6c86:	51 c1       	rjmp	.+674    	; 0x6f2a <__fp_inf>

00006c88 <__addsf3x>:
    6c88:	e9 2f       	mov	r30, r25
    6c8a:	77 d1       	rcall	.+750    	; 0x6f7a <__fp_split3>
    6c8c:	80 f3       	brcs	.-32     	; 0x6c6e <__addsf3+0x8>
    6c8e:	ba 17       	cp	r27, r26
    6c90:	62 07       	cpc	r22, r18
    6c92:	73 07       	cpc	r23, r19
    6c94:	84 07       	cpc	r24, r20
    6c96:	95 07       	cpc	r25, r21
    6c98:	18 f0       	brcs	.+6      	; 0x6ca0 <__addsf3x+0x18>
    6c9a:	71 f4       	brne	.+28     	; 0x6cb8 <__addsf3x+0x30>
    6c9c:	9e f5       	brtc	.+102    	; 0x6d04 <__addsf3x+0x7c>
    6c9e:	8f c1       	rjmp	.+798    	; 0x6fbe <__fp_zero>
    6ca0:	0e f4       	brtc	.+2      	; 0x6ca4 <__addsf3x+0x1c>
    6ca2:	e0 95       	com	r30
    6ca4:	0b 2e       	mov	r0, r27
    6ca6:	ba 2f       	mov	r27, r26
    6ca8:	a0 2d       	mov	r26, r0
    6caa:	0b 01       	movw	r0, r22
    6cac:	b9 01       	movw	r22, r18
    6cae:	90 01       	movw	r18, r0
    6cb0:	0c 01       	movw	r0, r24
    6cb2:	ca 01       	movw	r24, r20
    6cb4:	a0 01       	movw	r20, r0
    6cb6:	11 24       	eor	r1, r1
    6cb8:	ff 27       	eor	r31, r31
    6cba:	59 1b       	sub	r21, r25
    6cbc:	99 f0       	breq	.+38     	; 0x6ce4 <__addsf3x+0x5c>
    6cbe:	59 3f       	cpi	r21, 0xF9	; 249
    6cc0:	50 f4       	brcc	.+20     	; 0x6cd6 <__addsf3x+0x4e>
    6cc2:	50 3e       	cpi	r21, 0xE0	; 224
    6cc4:	68 f1       	brcs	.+90     	; 0x6d20 <__addsf3x+0x98>
    6cc6:	1a 16       	cp	r1, r26
    6cc8:	f0 40       	sbci	r31, 0x00	; 0
    6cca:	a2 2f       	mov	r26, r18
    6ccc:	23 2f       	mov	r18, r19
    6cce:	34 2f       	mov	r19, r20
    6cd0:	44 27       	eor	r20, r20
    6cd2:	58 5f       	subi	r21, 0xF8	; 248
    6cd4:	f3 cf       	rjmp	.-26     	; 0x6cbc <__addsf3x+0x34>
    6cd6:	46 95       	lsr	r20
    6cd8:	37 95       	ror	r19
    6cda:	27 95       	ror	r18
    6cdc:	a7 95       	ror	r26
    6cde:	f0 40       	sbci	r31, 0x00	; 0
    6ce0:	53 95       	inc	r21
    6ce2:	c9 f7       	brne	.-14     	; 0x6cd6 <__addsf3x+0x4e>
    6ce4:	7e f4       	brtc	.+30     	; 0x6d04 <__addsf3x+0x7c>
    6ce6:	1f 16       	cp	r1, r31
    6ce8:	ba 0b       	sbc	r27, r26
    6cea:	62 0b       	sbc	r22, r18
    6cec:	73 0b       	sbc	r23, r19
    6cee:	84 0b       	sbc	r24, r20
    6cf0:	ba f0       	brmi	.+46     	; 0x6d20 <__addsf3x+0x98>
    6cf2:	91 50       	subi	r25, 0x01	; 1
    6cf4:	a1 f0       	breq	.+40     	; 0x6d1e <__addsf3x+0x96>
    6cf6:	ff 0f       	add	r31, r31
    6cf8:	bb 1f       	adc	r27, r27
    6cfa:	66 1f       	adc	r22, r22
    6cfc:	77 1f       	adc	r23, r23
    6cfe:	88 1f       	adc	r24, r24
    6d00:	c2 f7       	brpl	.-16     	; 0x6cf2 <__addsf3x+0x6a>
    6d02:	0e c0       	rjmp	.+28     	; 0x6d20 <__addsf3x+0x98>
    6d04:	ba 0f       	add	r27, r26
    6d06:	62 1f       	adc	r22, r18
    6d08:	73 1f       	adc	r23, r19
    6d0a:	84 1f       	adc	r24, r20
    6d0c:	48 f4       	brcc	.+18     	; 0x6d20 <__addsf3x+0x98>
    6d0e:	87 95       	ror	r24
    6d10:	77 95       	ror	r23
    6d12:	67 95       	ror	r22
    6d14:	b7 95       	ror	r27
    6d16:	f7 95       	ror	r31
    6d18:	9e 3f       	cpi	r25, 0xFE	; 254
    6d1a:	08 f0       	brcs	.+2      	; 0x6d1e <__addsf3x+0x96>
    6d1c:	b3 cf       	rjmp	.-154    	; 0x6c84 <__addsf3+0x1e>
    6d1e:	93 95       	inc	r25
    6d20:	88 0f       	add	r24, r24
    6d22:	08 f0       	brcs	.+2      	; 0x6d26 <__addsf3x+0x9e>
    6d24:	99 27       	eor	r25, r25
    6d26:	ee 0f       	add	r30, r30
    6d28:	97 95       	ror	r25
    6d2a:	87 95       	ror	r24
    6d2c:	08 95       	ret

00006d2e <__cmpsf2>:
    6d2e:	d9 d0       	rcall	.+434    	; 0x6ee2 <__fp_cmp>
    6d30:	08 f4       	brcc	.+2      	; 0x6d34 <__cmpsf2+0x6>
    6d32:	81 e0       	ldi	r24, 0x01	; 1
    6d34:	08 95       	ret

00006d36 <__divsf3>:
    6d36:	0c d0       	rcall	.+24     	; 0x6d50 <__divsf3x>
    6d38:	0f c1       	rjmp	.+542    	; 0x6f58 <__fp_round>
    6d3a:	07 d1       	rcall	.+526    	; 0x6f4a <__fp_pscB>
    6d3c:	40 f0       	brcs	.+16     	; 0x6d4e <__divsf3+0x18>
    6d3e:	fe d0       	rcall	.+508    	; 0x6f3c <__fp_pscA>
    6d40:	30 f0       	brcs	.+12     	; 0x6d4e <__divsf3+0x18>
    6d42:	21 f4       	brne	.+8      	; 0x6d4c <__divsf3+0x16>
    6d44:	5f 3f       	cpi	r21, 0xFF	; 255
    6d46:	19 f0       	breq	.+6      	; 0x6d4e <__divsf3+0x18>
    6d48:	f0 c0       	rjmp	.+480    	; 0x6f2a <__fp_inf>
    6d4a:	51 11       	cpse	r21, r1
    6d4c:	39 c1       	rjmp	.+626    	; 0x6fc0 <__fp_szero>
    6d4e:	f3 c0       	rjmp	.+486    	; 0x6f36 <__fp_nan>

00006d50 <__divsf3x>:
    6d50:	14 d1       	rcall	.+552    	; 0x6f7a <__fp_split3>
    6d52:	98 f3       	brcs	.-26     	; 0x6d3a <__divsf3+0x4>

00006d54 <__divsf3_pse>:
    6d54:	99 23       	and	r25, r25
    6d56:	c9 f3       	breq	.-14     	; 0x6d4a <__divsf3+0x14>
    6d58:	55 23       	and	r21, r21
    6d5a:	b1 f3       	breq	.-20     	; 0x6d48 <__divsf3+0x12>
    6d5c:	95 1b       	sub	r25, r21
    6d5e:	55 0b       	sbc	r21, r21
    6d60:	bb 27       	eor	r27, r27
    6d62:	aa 27       	eor	r26, r26
    6d64:	62 17       	cp	r22, r18
    6d66:	73 07       	cpc	r23, r19
    6d68:	84 07       	cpc	r24, r20
    6d6a:	38 f0       	brcs	.+14     	; 0x6d7a <__divsf3_pse+0x26>
    6d6c:	9f 5f       	subi	r25, 0xFF	; 255
    6d6e:	5f 4f       	sbci	r21, 0xFF	; 255
    6d70:	22 0f       	add	r18, r18
    6d72:	33 1f       	adc	r19, r19
    6d74:	44 1f       	adc	r20, r20
    6d76:	aa 1f       	adc	r26, r26
    6d78:	a9 f3       	breq	.-22     	; 0x6d64 <__divsf3_pse+0x10>
    6d7a:	33 d0       	rcall	.+102    	; 0x6de2 <__divsf3_pse+0x8e>
    6d7c:	0e 2e       	mov	r0, r30
    6d7e:	3a f0       	brmi	.+14     	; 0x6d8e <__divsf3_pse+0x3a>
    6d80:	e0 e8       	ldi	r30, 0x80	; 128
    6d82:	30 d0       	rcall	.+96     	; 0x6de4 <__divsf3_pse+0x90>
    6d84:	91 50       	subi	r25, 0x01	; 1
    6d86:	50 40       	sbci	r21, 0x00	; 0
    6d88:	e6 95       	lsr	r30
    6d8a:	00 1c       	adc	r0, r0
    6d8c:	ca f7       	brpl	.-14     	; 0x6d80 <__divsf3_pse+0x2c>
    6d8e:	29 d0       	rcall	.+82     	; 0x6de2 <__divsf3_pse+0x8e>
    6d90:	fe 2f       	mov	r31, r30
    6d92:	27 d0       	rcall	.+78     	; 0x6de2 <__divsf3_pse+0x8e>
    6d94:	66 0f       	add	r22, r22
    6d96:	77 1f       	adc	r23, r23
    6d98:	88 1f       	adc	r24, r24
    6d9a:	bb 1f       	adc	r27, r27
    6d9c:	26 17       	cp	r18, r22
    6d9e:	37 07       	cpc	r19, r23
    6da0:	48 07       	cpc	r20, r24
    6da2:	ab 07       	cpc	r26, r27
    6da4:	b0 e8       	ldi	r27, 0x80	; 128
    6da6:	09 f0       	breq	.+2      	; 0x6daa <__divsf3_pse+0x56>
    6da8:	bb 0b       	sbc	r27, r27
    6daa:	80 2d       	mov	r24, r0
    6dac:	bf 01       	movw	r22, r30
    6dae:	ff 27       	eor	r31, r31
    6db0:	93 58       	subi	r25, 0x83	; 131
    6db2:	5f 4f       	sbci	r21, 0xFF	; 255
    6db4:	2a f0       	brmi	.+10     	; 0x6dc0 <__divsf3_pse+0x6c>
    6db6:	9e 3f       	cpi	r25, 0xFE	; 254
    6db8:	51 05       	cpc	r21, r1
    6dba:	68 f0       	brcs	.+26     	; 0x6dd6 <__divsf3_pse+0x82>
    6dbc:	b6 c0       	rjmp	.+364    	; 0x6f2a <__fp_inf>
    6dbe:	00 c1       	rjmp	.+512    	; 0x6fc0 <__fp_szero>
    6dc0:	5f 3f       	cpi	r21, 0xFF	; 255
    6dc2:	ec f3       	brlt	.-6      	; 0x6dbe <__divsf3_pse+0x6a>
    6dc4:	98 3e       	cpi	r25, 0xE8	; 232
    6dc6:	dc f3       	brlt	.-10     	; 0x6dbe <__divsf3_pse+0x6a>
    6dc8:	86 95       	lsr	r24
    6dca:	77 95       	ror	r23
    6dcc:	67 95       	ror	r22
    6dce:	b7 95       	ror	r27
    6dd0:	f7 95       	ror	r31
    6dd2:	9f 5f       	subi	r25, 0xFF	; 255
    6dd4:	c9 f7       	brne	.-14     	; 0x6dc8 <__divsf3_pse+0x74>
    6dd6:	88 0f       	add	r24, r24
    6dd8:	91 1d       	adc	r25, r1
    6dda:	96 95       	lsr	r25
    6ddc:	87 95       	ror	r24
    6dde:	97 f9       	bld	r25, 7
    6de0:	08 95       	ret
    6de2:	e1 e0       	ldi	r30, 0x01	; 1
    6de4:	66 0f       	add	r22, r22
    6de6:	77 1f       	adc	r23, r23
    6de8:	88 1f       	adc	r24, r24
    6dea:	bb 1f       	adc	r27, r27
    6dec:	62 17       	cp	r22, r18
    6dee:	73 07       	cpc	r23, r19
    6df0:	84 07       	cpc	r24, r20
    6df2:	ba 07       	cpc	r27, r26
    6df4:	20 f0       	brcs	.+8      	; 0x6dfe <__divsf3_pse+0xaa>
    6df6:	62 1b       	sub	r22, r18
    6df8:	73 0b       	sbc	r23, r19
    6dfa:	84 0b       	sbc	r24, r20
    6dfc:	ba 0b       	sbc	r27, r26
    6dfe:	ee 1f       	adc	r30, r30
    6e00:	88 f7       	brcc	.-30     	; 0x6de4 <__divsf3_pse+0x90>
    6e02:	e0 95       	com	r30
    6e04:	08 95       	ret

00006e06 <__fixsfsi>:
    6e06:	04 d0       	rcall	.+8      	; 0x6e10 <__fixunssfsi>
    6e08:	68 94       	set
    6e0a:	b1 11       	cpse	r27, r1
    6e0c:	d9 c0       	rjmp	.+434    	; 0x6fc0 <__fp_szero>
    6e0e:	08 95       	ret

00006e10 <__fixunssfsi>:
    6e10:	bc d0       	rcall	.+376    	; 0x6f8a <__fp_splitA>
    6e12:	88 f0       	brcs	.+34     	; 0x6e36 <__fixunssfsi+0x26>
    6e14:	9f 57       	subi	r25, 0x7F	; 127
    6e16:	90 f0       	brcs	.+36     	; 0x6e3c <__fixunssfsi+0x2c>
    6e18:	b9 2f       	mov	r27, r25
    6e1a:	99 27       	eor	r25, r25
    6e1c:	b7 51       	subi	r27, 0x17	; 23
    6e1e:	a0 f0       	brcs	.+40     	; 0x6e48 <__fixunssfsi+0x38>
    6e20:	d1 f0       	breq	.+52     	; 0x6e56 <__fixunssfsi+0x46>
    6e22:	66 0f       	add	r22, r22
    6e24:	77 1f       	adc	r23, r23
    6e26:	88 1f       	adc	r24, r24
    6e28:	99 1f       	adc	r25, r25
    6e2a:	1a f0       	brmi	.+6      	; 0x6e32 <__fixunssfsi+0x22>
    6e2c:	ba 95       	dec	r27
    6e2e:	c9 f7       	brne	.-14     	; 0x6e22 <__fixunssfsi+0x12>
    6e30:	12 c0       	rjmp	.+36     	; 0x6e56 <__fixunssfsi+0x46>
    6e32:	b1 30       	cpi	r27, 0x01	; 1
    6e34:	81 f0       	breq	.+32     	; 0x6e56 <__fixunssfsi+0x46>
    6e36:	c3 d0       	rcall	.+390    	; 0x6fbe <__fp_zero>
    6e38:	b1 e0       	ldi	r27, 0x01	; 1
    6e3a:	08 95       	ret
    6e3c:	c0 c0       	rjmp	.+384    	; 0x6fbe <__fp_zero>
    6e3e:	67 2f       	mov	r22, r23
    6e40:	78 2f       	mov	r23, r24
    6e42:	88 27       	eor	r24, r24
    6e44:	b8 5f       	subi	r27, 0xF8	; 248
    6e46:	39 f0       	breq	.+14     	; 0x6e56 <__fixunssfsi+0x46>
    6e48:	b9 3f       	cpi	r27, 0xF9	; 249
    6e4a:	cc f3       	brlt	.-14     	; 0x6e3e <__fixunssfsi+0x2e>
    6e4c:	86 95       	lsr	r24
    6e4e:	77 95       	ror	r23
    6e50:	67 95       	ror	r22
    6e52:	b3 95       	inc	r27
    6e54:	d9 f7       	brne	.-10     	; 0x6e4c <__fixunssfsi+0x3c>
    6e56:	3e f4       	brtc	.+14     	; 0x6e66 <__fixunssfsi+0x56>
    6e58:	90 95       	com	r25
    6e5a:	80 95       	com	r24
    6e5c:	70 95       	com	r23
    6e5e:	61 95       	neg	r22
    6e60:	7f 4f       	sbci	r23, 0xFF	; 255
    6e62:	8f 4f       	sbci	r24, 0xFF	; 255
    6e64:	9f 4f       	sbci	r25, 0xFF	; 255
    6e66:	08 95       	ret

00006e68 <__floatunsisf>:
    6e68:	e8 94       	clt
    6e6a:	09 c0       	rjmp	.+18     	; 0x6e7e <__floatsisf+0x12>

00006e6c <__floatsisf>:
    6e6c:	97 fb       	bst	r25, 7
    6e6e:	3e f4       	brtc	.+14     	; 0x6e7e <__floatsisf+0x12>
    6e70:	90 95       	com	r25
    6e72:	80 95       	com	r24
    6e74:	70 95       	com	r23
    6e76:	61 95       	neg	r22
    6e78:	7f 4f       	sbci	r23, 0xFF	; 255
    6e7a:	8f 4f       	sbci	r24, 0xFF	; 255
    6e7c:	9f 4f       	sbci	r25, 0xFF	; 255
    6e7e:	99 23       	and	r25, r25
    6e80:	a9 f0       	breq	.+42     	; 0x6eac <__floatsisf+0x40>
    6e82:	f9 2f       	mov	r31, r25
    6e84:	96 e9       	ldi	r25, 0x96	; 150
    6e86:	bb 27       	eor	r27, r27
    6e88:	93 95       	inc	r25
    6e8a:	f6 95       	lsr	r31
    6e8c:	87 95       	ror	r24
    6e8e:	77 95       	ror	r23
    6e90:	67 95       	ror	r22
    6e92:	b7 95       	ror	r27
    6e94:	f1 11       	cpse	r31, r1
    6e96:	f8 cf       	rjmp	.-16     	; 0x6e88 <__floatsisf+0x1c>
    6e98:	fa f4       	brpl	.+62     	; 0x6ed8 <__floatsisf+0x6c>
    6e9a:	bb 0f       	add	r27, r27
    6e9c:	11 f4       	brne	.+4      	; 0x6ea2 <__floatsisf+0x36>
    6e9e:	60 ff       	sbrs	r22, 0
    6ea0:	1b c0       	rjmp	.+54     	; 0x6ed8 <__floatsisf+0x6c>
    6ea2:	6f 5f       	subi	r22, 0xFF	; 255
    6ea4:	7f 4f       	sbci	r23, 0xFF	; 255
    6ea6:	8f 4f       	sbci	r24, 0xFF	; 255
    6ea8:	9f 4f       	sbci	r25, 0xFF	; 255
    6eaa:	16 c0       	rjmp	.+44     	; 0x6ed8 <__floatsisf+0x6c>
    6eac:	88 23       	and	r24, r24
    6eae:	11 f0       	breq	.+4      	; 0x6eb4 <__floatsisf+0x48>
    6eb0:	96 e9       	ldi	r25, 0x96	; 150
    6eb2:	11 c0       	rjmp	.+34     	; 0x6ed6 <__floatsisf+0x6a>
    6eb4:	77 23       	and	r23, r23
    6eb6:	21 f0       	breq	.+8      	; 0x6ec0 <__floatsisf+0x54>
    6eb8:	9e e8       	ldi	r25, 0x8E	; 142
    6eba:	87 2f       	mov	r24, r23
    6ebc:	76 2f       	mov	r23, r22
    6ebe:	05 c0       	rjmp	.+10     	; 0x6eca <__floatsisf+0x5e>
    6ec0:	66 23       	and	r22, r22
    6ec2:	71 f0       	breq	.+28     	; 0x6ee0 <__floatsisf+0x74>
    6ec4:	96 e8       	ldi	r25, 0x86	; 134
    6ec6:	86 2f       	mov	r24, r22
    6ec8:	70 e0       	ldi	r23, 0x00	; 0
    6eca:	60 e0       	ldi	r22, 0x00	; 0
    6ecc:	2a f0       	brmi	.+10     	; 0x6ed8 <__floatsisf+0x6c>
    6ece:	9a 95       	dec	r25
    6ed0:	66 0f       	add	r22, r22
    6ed2:	77 1f       	adc	r23, r23
    6ed4:	88 1f       	adc	r24, r24
    6ed6:	da f7       	brpl	.-10     	; 0x6ece <__floatsisf+0x62>
    6ed8:	88 0f       	add	r24, r24
    6eda:	96 95       	lsr	r25
    6edc:	87 95       	ror	r24
    6ede:	97 f9       	bld	r25, 7
    6ee0:	08 95       	ret

00006ee2 <__fp_cmp>:
    6ee2:	99 0f       	add	r25, r25
    6ee4:	00 08       	sbc	r0, r0
    6ee6:	55 0f       	add	r21, r21
    6ee8:	aa 0b       	sbc	r26, r26
    6eea:	e0 e8       	ldi	r30, 0x80	; 128
    6eec:	fe ef       	ldi	r31, 0xFE	; 254
    6eee:	16 16       	cp	r1, r22
    6ef0:	17 06       	cpc	r1, r23
    6ef2:	e8 07       	cpc	r30, r24
    6ef4:	f9 07       	cpc	r31, r25
    6ef6:	c0 f0       	brcs	.+48     	; 0x6f28 <__fp_cmp+0x46>
    6ef8:	12 16       	cp	r1, r18
    6efa:	13 06       	cpc	r1, r19
    6efc:	e4 07       	cpc	r30, r20
    6efe:	f5 07       	cpc	r31, r21
    6f00:	98 f0       	brcs	.+38     	; 0x6f28 <__fp_cmp+0x46>
    6f02:	62 1b       	sub	r22, r18
    6f04:	73 0b       	sbc	r23, r19
    6f06:	84 0b       	sbc	r24, r20
    6f08:	95 0b       	sbc	r25, r21
    6f0a:	39 f4       	brne	.+14     	; 0x6f1a <__fp_cmp+0x38>
    6f0c:	0a 26       	eor	r0, r26
    6f0e:	61 f0       	breq	.+24     	; 0x6f28 <__fp_cmp+0x46>
    6f10:	23 2b       	or	r18, r19
    6f12:	24 2b       	or	r18, r20
    6f14:	25 2b       	or	r18, r21
    6f16:	21 f4       	brne	.+8      	; 0x6f20 <__fp_cmp+0x3e>
    6f18:	08 95       	ret
    6f1a:	0a 26       	eor	r0, r26
    6f1c:	09 f4       	brne	.+2      	; 0x6f20 <__fp_cmp+0x3e>
    6f1e:	a1 40       	sbci	r26, 0x01	; 1
    6f20:	a6 95       	lsr	r26
    6f22:	8f ef       	ldi	r24, 0xFF	; 255
    6f24:	81 1d       	adc	r24, r1
    6f26:	81 1d       	adc	r24, r1
    6f28:	08 95       	ret

00006f2a <__fp_inf>:
    6f2a:	97 f9       	bld	r25, 7
    6f2c:	9f 67       	ori	r25, 0x7F	; 127
    6f2e:	80 e8       	ldi	r24, 0x80	; 128
    6f30:	70 e0       	ldi	r23, 0x00	; 0
    6f32:	60 e0       	ldi	r22, 0x00	; 0
    6f34:	08 95       	ret

00006f36 <__fp_nan>:
    6f36:	9f ef       	ldi	r25, 0xFF	; 255
    6f38:	80 ec       	ldi	r24, 0xC0	; 192
    6f3a:	08 95       	ret

00006f3c <__fp_pscA>:
    6f3c:	00 24       	eor	r0, r0
    6f3e:	0a 94       	dec	r0
    6f40:	16 16       	cp	r1, r22
    6f42:	17 06       	cpc	r1, r23
    6f44:	18 06       	cpc	r1, r24
    6f46:	09 06       	cpc	r0, r25
    6f48:	08 95       	ret

00006f4a <__fp_pscB>:
    6f4a:	00 24       	eor	r0, r0
    6f4c:	0a 94       	dec	r0
    6f4e:	12 16       	cp	r1, r18
    6f50:	13 06       	cpc	r1, r19
    6f52:	14 06       	cpc	r1, r20
    6f54:	05 06       	cpc	r0, r21
    6f56:	08 95       	ret

00006f58 <__fp_round>:
    6f58:	09 2e       	mov	r0, r25
    6f5a:	03 94       	inc	r0
    6f5c:	00 0c       	add	r0, r0
    6f5e:	11 f4       	brne	.+4      	; 0x6f64 <__fp_round+0xc>
    6f60:	88 23       	and	r24, r24
    6f62:	52 f0       	brmi	.+20     	; 0x6f78 <__fp_round+0x20>
    6f64:	bb 0f       	add	r27, r27
    6f66:	40 f4       	brcc	.+16     	; 0x6f78 <__fp_round+0x20>
    6f68:	bf 2b       	or	r27, r31
    6f6a:	11 f4       	brne	.+4      	; 0x6f70 <__fp_round+0x18>
    6f6c:	60 ff       	sbrs	r22, 0
    6f6e:	04 c0       	rjmp	.+8      	; 0x6f78 <__fp_round+0x20>
    6f70:	6f 5f       	subi	r22, 0xFF	; 255
    6f72:	7f 4f       	sbci	r23, 0xFF	; 255
    6f74:	8f 4f       	sbci	r24, 0xFF	; 255
    6f76:	9f 4f       	sbci	r25, 0xFF	; 255
    6f78:	08 95       	ret

00006f7a <__fp_split3>:
    6f7a:	57 fd       	sbrc	r21, 7
    6f7c:	90 58       	subi	r25, 0x80	; 128
    6f7e:	44 0f       	add	r20, r20
    6f80:	55 1f       	adc	r21, r21
    6f82:	59 f0       	breq	.+22     	; 0x6f9a <__fp_splitA+0x10>
    6f84:	5f 3f       	cpi	r21, 0xFF	; 255
    6f86:	71 f0       	breq	.+28     	; 0x6fa4 <__fp_splitA+0x1a>
    6f88:	47 95       	ror	r20

00006f8a <__fp_splitA>:
    6f8a:	88 0f       	add	r24, r24
    6f8c:	97 fb       	bst	r25, 7
    6f8e:	99 1f       	adc	r25, r25
    6f90:	61 f0       	breq	.+24     	; 0x6faa <__fp_splitA+0x20>
    6f92:	9f 3f       	cpi	r25, 0xFF	; 255
    6f94:	79 f0       	breq	.+30     	; 0x6fb4 <__fp_splitA+0x2a>
    6f96:	87 95       	ror	r24
    6f98:	08 95       	ret
    6f9a:	12 16       	cp	r1, r18
    6f9c:	13 06       	cpc	r1, r19
    6f9e:	14 06       	cpc	r1, r20
    6fa0:	55 1f       	adc	r21, r21
    6fa2:	f2 cf       	rjmp	.-28     	; 0x6f88 <__fp_split3+0xe>
    6fa4:	46 95       	lsr	r20
    6fa6:	f1 df       	rcall	.-30     	; 0x6f8a <__fp_splitA>
    6fa8:	08 c0       	rjmp	.+16     	; 0x6fba <__fp_splitA+0x30>
    6faa:	16 16       	cp	r1, r22
    6fac:	17 06       	cpc	r1, r23
    6fae:	18 06       	cpc	r1, r24
    6fb0:	99 1f       	adc	r25, r25
    6fb2:	f1 cf       	rjmp	.-30     	; 0x6f96 <__fp_splitA+0xc>
    6fb4:	86 95       	lsr	r24
    6fb6:	71 05       	cpc	r23, r1
    6fb8:	61 05       	cpc	r22, r1
    6fba:	08 94       	sec
    6fbc:	08 95       	ret

00006fbe <__fp_zero>:
    6fbe:	e8 94       	clt

00006fc0 <__fp_szero>:
    6fc0:	bb 27       	eor	r27, r27
    6fc2:	66 27       	eor	r22, r22
    6fc4:	77 27       	eor	r23, r23
    6fc6:	cb 01       	movw	r24, r22
    6fc8:	97 f9       	bld	r25, 7
    6fca:	08 95       	ret

00006fcc <__gesf2>:
    6fcc:	8a df       	rcall	.-236    	; 0x6ee2 <__fp_cmp>
    6fce:	08 f4       	brcc	.+2      	; 0x6fd2 <__gesf2+0x6>
    6fd0:	8f ef       	ldi	r24, 0xFF	; 255
    6fd2:	08 95       	ret

00006fd4 <__mulsf3>:
    6fd4:	0b d0       	rcall	.+22     	; 0x6fec <__mulsf3x>
    6fd6:	c0 cf       	rjmp	.-128    	; 0x6f58 <__fp_round>
    6fd8:	b1 df       	rcall	.-158    	; 0x6f3c <__fp_pscA>
    6fda:	28 f0       	brcs	.+10     	; 0x6fe6 <__mulsf3+0x12>
    6fdc:	b6 df       	rcall	.-148    	; 0x6f4a <__fp_pscB>
    6fde:	18 f0       	brcs	.+6      	; 0x6fe6 <__mulsf3+0x12>
    6fe0:	95 23       	and	r25, r21
    6fe2:	09 f0       	breq	.+2      	; 0x6fe6 <__mulsf3+0x12>
    6fe4:	a2 cf       	rjmp	.-188    	; 0x6f2a <__fp_inf>
    6fe6:	a7 cf       	rjmp	.-178    	; 0x6f36 <__fp_nan>
    6fe8:	11 24       	eor	r1, r1
    6fea:	ea cf       	rjmp	.-44     	; 0x6fc0 <__fp_szero>

00006fec <__mulsf3x>:
    6fec:	c6 df       	rcall	.-116    	; 0x6f7a <__fp_split3>
    6fee:	a0 f3       	brcs	.-24     	; 0x6fd8 <__mulsf3+0x4>

00006ff0 <__mulsf3_pse>:
    6ff0:	95 9f       	mul	r25, r21
    6ff2:	d1 f3       	breq	.-12     	; 0x6fe8 <__mulsf3+0x14>
    6ff4:	95 0f       	add	r25, r21
    6ff6:	50 e0       	ldi	r21, 0x00	; 0
    6ff8:	55 1f       	adc	r21, r21
    6ffa:	62 9f       	mul	r22, r18
    6ffc:	f0 01       	movw	r30, r0
    6ffe:	72 9f       	mul	r23, r18
    7000:	bb 27       	eor	r27, r27
    7002:	f0 0d       	add	r31, r0
    7004:	b1 1d       	adc	r27, r1
    7006:	63 9f       	mul	r22, r19
    7008:	aa 27       	eor	r26, r26
    700a:	f0 0d       	add	r31, r0
    700c:	b1 1d       	adc	r27, r1
    700e:	aa 1f       	adc	r26, r26
    7010:	64 9f       	mul	r22, r20
    7012:	66 27       	eor	r22, r22
    7014:	b0 0d       	add	r27, r0
    7016:	a1 1d       	adc	r26, r1
    7018:	66 1f       	adc	r22, r22
    701a:	82 9f       	mul	r24, r18
    701c:	22 27       	eor	r18, r18
    701e:	b0 0d       	add	r27, r0
    7020:	a1 1d       	adc	r26, r1
    7022:	62 1f       	adc	r22, r18
    7024:	73 9f       	mul	r23, r19
    7026:	b0 0d       	add	r27, r0
    7028:	a1 1d       	adc	r26, r1
    702a:	62 1f       	adc	r22, r18
    702c:	83 9f       	mul	r24, r19
    702e:	a0 0d       	add	r26, r0
    7030:	61 1d       	adc	r22, r1
    7032:	22 1f       	adc	r18, r18
    7034:	74 9f       	mul	r23, r20
    7036:	33 27       	eor	r19, r19
    7038:	a0 0d       	add	r26, r0
    703a:	61 1d       	adc	r22, r1
    703c:	23 1f       	adc	r18, r19
    703e:	84 9f       	mul	r24, r20
    7040:	60 0d       	add	r22, r0
    7042:	21 1d       	adc	r18, r1
    7044:	82 2f       	mov	r24, r18
    7046:	76 2f       	mov	r23, r22
    7048:	6a 2f       	mov	r22, r26
    704a:	11 24       	eor	r1, r1
    704c:	9f 57       	subi	r25, 0x7F	; 127
    704e:	50 40       	sbci	r21, 0x00	; 0
    7050:	8a f0       	brmi	.+34     	; 0x7074 <__mulsf3_pse+0x84>
    7052:	e1 f0       	breq	.+56     	; 0x708c <__mulsf3_pse+0x9c>
    7054:	88 23       	and	r24, r24
    7056:	4a f0       	brmi	.+18     	; 0x706a <__mulsf3_pse+0x7a>
    7058:	ee 0f       	add	r30, r30
    705a:	ff 1f       	adc	r31, r31
    705c:	bb 1f       	adc	r27, r27
    705e:	66 1f       	adc	r22, r22
    7060:	77 1f       	adc	r23, r23
    7062:	88 1f       	adc	r24, r24
    7064:	91 50       	subi	r25, 0x01	; 1
    7066:	50 40       	sbci	r21, 0x00	; 0
    7068:	a9 f7       	brne	.-22     	; 0x7054 <__mulsf3_pse+0x64>
    706a:	9e 3f       	cpi	r25, 0xFE	; 254
    706c:	51 05       	cpc	r21, r1
    706e:	70 f0       	brcs	.+28     	; 0x708c <__mulsf3_pse+0x9c>
    7070:	5c cf       	rjmp	.-328    	; 0x6f2a <__fp_inf>
    7072:	a6 cf       	rjmp	.-180    	; 0x6fc0 <__fp_szero>
    7074:	5f 3f       	cpi	r21, 0xFF	; 255
    7076:	ec f3       	brlt	.-6      	; 0x7072 <__mulsf3_pse+0x82>
    7078:	98 3e       	cpi	r25, 0xE8	; 232
    707a:	dc f3       	brlt	.-10     	; 0x7072 <__mulsf3_pse+0x82>
    707c:	86 95       	lsr	r24
    707e:	77 95       	ror	r23
    7080:	67 95       	ror	r22
    7082:	b7 95       	ror	r27
    7084:	f7 95       	ror	r31
    7086:	e7 95       	ror	r30
    7088:	9f 5f       	subi	r25, 0xFF	; 255
    708a:	c1 f7       	brne	.-16     	; 0x707c <__mulsf3_pse+0x8c>
    708c:	fe 2b       	or	r31, r30
    708e:	88 0f       	add	r24, r24
    7090:	91 1d       	adc	r25, r1
    7092:	96 95       	lsr	r25
    7094:	87 95       	ror	r24
    7096:	97 f9       	bld	r25, 7
    7098:	08 95       	ret

0000709a <__udivmodhi4>:
    709a:	aa 1b       	sub	r26, r26
    709c:	bb 1b       	sub	r27, r27
    709e:	51 e1       	ldi	r21, 0x11	; 17
    70a0:	07 c0       	rjmp	.+14     	; 0x70b0 <__udivmodhi4_ep>

000070a2 <__udivmodhi4_loop>:
    70a2:	aa 1f       	adc	r26, r26
    70a4:	bb 1f       	adc	r27, r27
    70a6:	a6 17       	cp	r26, r22
    70a8:	b7 07       	cpc	r27, r23
    70aa:	10 f0       	brcs	.+4      	; 0x70b0 <__udivmodhi4_ep>
    70ac:	a6 1b       	sub	r26, r22
    70ae:	b7 0b       	sbc	r27, r23

000070b0 <__udivmodhi4_ep>:
    70b0:	88 1f       	adc	r24, r24
    70b2:	99 1f       	adc	r25, r25
    70b4:	5a 95       	dec	r21
    70b6:	a9 f7       	brne	.-22     	; 0x70a2 <__udivmodhi4_loop>
    70b8:	80 95       	com	r24
    70ba:	90 95       	com	r25
    70bc:	bc 01       	movw	r22, r24
    70be:	cd 01       	movw	r24, r26
    70c0:	08 95       	ret

000070c2 <__divmodhi4>:
    70c2:	97 fb       	bst	r25, 7
    70c4:	09 2e       	mov	r0, r25
    70c6:	07 26       	eor	r0, r23
    70c8:	0a d0       	rcall	.+20     	; 0x70de <__divmodhi4_neg1>
    70ca:	77 fd       	sbrc	r23, 7
    70cc:	04 d0       	rcall	.+8      	; 0x70d6 <__divmodhi4_neg2>
    70ce:	e5 df       	rcall	.-54     	; 0x709a <__udivmodhi4>
    70d0:	06 d0       	rcall	.+12     	; 0x70de <__divmodhi4_neg1>
    70d2:	00 20       	and	r0, r0
    70d4:	1a f4       	brpl	.+6      	; 0x70dc <__divmodhi4_exit>

000070d6 <__divmodhi4_neg2>:
    70d6:	70 95       	com	r23
    70d8:	61 95       	neg	r22
    70da:	7f 4f       	sbci	r23, 0xFF	; 255

000070dc <__divmodhi4_exit>:
    70dc:	08 95       	ret

000070de <__divmodhi4_neg1>:
    70de:	f6 f7       	brtc	.-4      	; 0x70dc <__divmodhi4_exit>
    70e0:	90 95       	com	r25
    70e2:	81 95       	neg	r24
    70e4:	9f 4f       	sbci	r25, 0xFF	; 255
    70e6:	08 95       	ret

000070e8 <abs>:
    70e8:	28 2f       	mov	r18, r24
    70ea:	39 2f       	mov	r19, r25
    70ec:	37 ff       	sbrs	r19, 7
    70ee:	03 c0       	rjmp	.+6      	; 0x70f6 <abs+0xe>
    70f0:	30 95       	com	r19
    70f2:	21 95       	neg	r18
    70f4:	3f 4f       	sbci	r19, 0xFF	; 255
    70f6:	c9 01       	movw	r24, r18
    70f8:	08 95       	ret

000070fa <dtostrf>:
    70fa:	ef 92       	push	r14
    70fc:	ff 92       	push	r15
    70fe:	0f 93       	push	r16
    7100:	1f 93       	push	r17
    7102:	32 2f       	mov	r19, r18
    7104:	f0 2e       	mov	r15, r16
    7106:	47 ff       	sbrs	r20, 7
    7108:	02 c0       	rjmp	.+4      	; 0x710e <dtostrf+0x14>
    710a:	a4 e1       	ldi	r26, 0x14	; 20
    710c:	01 c0       	rjmp	.+2      	; 0x7110 <dtostrf+0x16>
    710e:	a4 e0       	ldi	r26, 0x04	; 4
    7110:	e4 2f       	mov	r30, r20
    7112:	ff 27       	eor	r31, r31
    7114:	e7 fd       	sbrc	r30, 7
    7116:	f0 95       	com	r31
    7118:	f7 ff       	sbrs	r31, 7
    711a:	03 c0       	rjmp	.+6      	; 0x7122 <dtostrf+0x28>
    711c:	f0 95       	com	r31
    711e:	e1 95       	neg	r30
    7120:	ff 4f       	sbci	r31, 0xFF	; 255
    7122:	4f 2d       	mov	r20, r15
    7124:	51 2f       	mov	r21, r17
    7126:	2e 2f       	mov	r18, r30
    7128:	03 2f       	mov	r16, r19
    712a:	ea 2e       	mov	r14, r26
    712c:	0e 94 29 39 	call	0x7252	; 0x7252 <dtoa_prf>
    7130:	8f 2d       	mov	r24, r15
    7132:	91 2f       	mov	r25, r17
    7134:	1f 91       	pop	r17
    7136:	0f 91       	pop	r16
    7138:	ff 90       	pop	r15
    713a:	ef 90       	pop	r14
    713c:	08 95       	ret

0000713e <memcpy_P>:
    713e:	fb 01       	movw	r30, r22
    7140:	dc 01       	movw	r26, r24
    7142:	02 c0       	rjmp	.+4      	; 0x7148 <memcpy_P+0xa>
    7144:	05 90       	lpm	r0, Z+
    7146:	0d 92       	st	X+, r0
    7148:	41 50       	subi	r20, 0x01	; 1
    714a:	50 40       	sbci	r21, 0x00	; 0
    714c:	d8 f7       	brcc	.-10     	; 0x7144 <memcpy_P+0x6>
    714e:	08 95       	ret

00007150 <strcpy_P>:
    7150:	fb 01       	movw	r30, r22
    7152:	dc 01       	movw	r26, r24
    7154:	05 90       	lpm	r0, Z+
    7156:	0d 92       	st	X+, r0
    7158:	00 20       	and	r0, r0
    715a:	e1 f7       	brne	.-8      	; 0x7154 <strcpy_P+0x4>
    715c:	08 95       	ret

0000715e <strlen_P>:
    715e:	fc 01       	movw	r30, r24
    7160:	05 90       	lpm	r0, Z+
    7162:	00 20       	and	r0, r0
    7164:	e9 f7       	brne	.-6      	; 0x7160 <strlen_P+0x2>
    7166:	80 95       	com	r24
    7168:	90 95       	com	r25
    716a:	8e 0f       	add	r24, r30
    716c:	9f 1f       	adc	r25, r31
    716e:	08 95       	ret

00007170 <memcpy>:
    7170:	fb 01       	movw	r30, r22
    7172:	dc 01       	movw	r26, r24
    7174:	02 c0       	rjmp	.+4      	; 0x717a <memcpy+0xa>
    7176:	01 90       	ld	r0, Z+
    7178:	0d 92       	st	X+, r0
    717a:	41 50       	subi	r20, 0x01	; 1
    717c:	50 40       	sbci	r21, 0x00	; 0
    717e:	d8 f7       	brcc	.-10     	; 0x7176 <memcpy+0x6>
    7180:	08 95       	ret

00007182 <strcat>:
    7182:	fb 01       	movw	r30, r22
    7184:	dc 01       	movw	r26, r24
    7186:	0d 90       	ld	r0, X+
    7188:	00 20       	and	r0, r0
    718a:	e9 f7       	brne	.-6      	; 0x7186 <strcat+0x4>
    718c:	11 97       	sbiw	r26, 0x01	; 1
    718e:	01 90       	ld	r0, Z+
    7190:	0d 92       	st	X+, r0
    7192:	00 20       	and	r0, r0
    7194:	e1 f7       	brne	.-8      	; 0x718e <strcat+0xc>
    7196:	08 95       	ret

00007198 <itoa>:
    7198:	fb 01       	movw	r30, r22
    719a:	9f 01       	movw	r18, r30
    719c:	e8 94       	clt
    719e:	42 30       	cpi	r20, 0x02	; 2
    71a0:	c4 f0       	brlt	.+48     	; 0x71d2 <itoa+0x3a>
    71a2:	45 32       	cpi	r20, 0x25	; 37
    71a4:	b4 f4       	brge	.+44     	; 0x71d2 <itoa+0x3a>
    71a6:	4a 30       	cpi	r20, 0x0A	; 10
    71a8:	29 f4       	brne	.+10     	; 0x71b4 <itoa+0x1c>
    71aa:	97 fb       	bst	r25, 7
    71ac:	1e f4       	brtc	.+6      	; 0x71b4 <itoa+0x1c>
    71ae:	90 95       	com	r25
    71b0:	81 95       	neg	r24
    71b2:	9f 4f       	sbci	r25, 0xFF	; 255
    71b4:	64 2f       	mov	r22, r20
    71b6:	77 27       	eor	r23, r23
    71b8:	0e 94 4d 38 	call	0x709a	; 0x709a <__udivmodhi4>
    71bc:	80 5d       	subi	r24, 0xD0	; 208
    71be:	8a 33       	cpi	r24, 0x3A	; 58
    71c0:	0c f0       	brlt	.+2      	; 0x71c4 <itoa+0x2c>
    71c2:	89 5d       	subi	r24, 0xD9	; 217
    71c4:	81 93       	st	Z+, r24
    71c6:	cb 01       	movw	r24, r22
    71c8:	00 97       	sbiw	r24, 0x00	; 0
    71ca:	a1 f7       	brne	.-24     	; 0x71b4 <itoa+0x1c>
    71cc:	16 f4       	brtc	.+4      	; 0x71d2 <itoa+0x3a>
    71ce:	5d e2       	ldi	r21, 0x2D	; 45
    71d0:	51 93       	st	Z+, r21
    71d2:	10 82       	st	Z, r1
    71d4:	c9 01       	movw	r24, r18
    71d6:	0c 94 58 3b 	jmp	0x76b0	; 0x76b0 <strrev>

000071da <utoa>:
    71da:	fb 01       	movw	r30, r22
    71dc:	9f 01       	movw	r18, r30
    71de:	42 30       	cpi	r20, 0x02	; 2
    71e0:	74 f0       	brlt	.+28     	; 0x71fe <utoa+0x24>
    71e2:	45 32       	cpi	r20, 0x25	; 37
    71e4:	64 f4       	brge	.+24     	; 0x71fe <utoa+0x24>
    71e6:	64 2f       	mov	r22, r20
    71e8:	77 27       	eor	r23, r23
    71ea:	0e 94 4d 38 	call	0x709a	; 0x709a <__udivmodhi4>
    71ee:	80 5d       	subi	r24, 0xD0	; 208
    71f0:	8a 33       	cpi	r24, 0x3A	; 58
    71f2:	0c f0       	brlt	.+2      	; 0x71f6 <utoa+0x1c>
    71f4:	89 5d       	subi	r24, 0xD9	; 217
    71f6:	81 93       	st	Z+, r24
    71f8:	cb 01       	movw	r24, r22
    71fa:	00 97       	sbiw	r24, 0x00	; 0
    71fc:	a1 f7       	brne	.-24     	; 0x71e6 <utoa+0xc>
    71fe:	10 82       	st	Z, r1
    7200:	c9 01       	movw	r24, r18
    7202:	0c 94 58 3b 	jmp	0x76b0	; 0x76b0 <strrev>

00007206 <__eerd_block_m324pa>:
    7206:	dc 01       	movw	r26, r24
    7208:	cb 01       	movw	r24, r22

0000720a <__eerd_blraw_m324pa>:
    720a:	fc 01       	movw	r30, r24
    720c:	f9 99       	sbic	0x1f, 1	; 31
    720e:	fe cf       	rjmp	.-4      	; 0x720c <__eerd_blraw_m324pa+0x2>
    7210:	06 c0       	rjmp	.+12     	; 0x721e <__eerd_blraw_m324pa+0x14>
    7212:	f2 bd       	out	0x22, r31	; 34
    7214:	e1 bd       	out	0x21, r30	; 33
    7216:	f8 9a       	sbi	0x1f, 0	; 31
    7218:	31 96       	adiw	r30, 0x01	; 1
    721a:	00 b4       	in	r0, 0x20	; 32
    721c:	0d 92       	st	X+, r0
    721e:	41 50       	subi	r20, 0x01	; 1
    7220:	50 40       	sbci	r21, 0x00	; 0
    7222:	b8 f7       	brcc	.-18     	; 0x7212 <__eerd_blraw_m324pa+0x8>
    7224:	08 95       	ret

00007226 <__eerd_byte_m324pa>:
    7226:	f9 99       	sbic	0x1f, 1	; 31
    7228:	fe cf       	rjmp	.-4      	; 0x7226 <__eerd_byte_m324pa>
    722a:	92 bd       	out	0x22, r25	; 34
    722c:	81 bd       	out	0x21, r24	; 33
    722e:	f8 9a       	sbi	0x1f, 0	; 31
    7230:	99 27       	eor	r25, r25
    7232:	80 b5       	in	r24, 0x20	; 32
    7234:	08 95       	ret

00007236 <__eewr_byte_m324pa>:
    7236:	26 2f       	mov	r18, r22

00007238 <__eewr_r18_m324pa>:
    7238:	f9 99       	sbic	0x1f, 1	; 31
    723a:	fe cf       	rjmp	.-4      	; 0x7238 <__eewr_r18_m324pa>
    723c:	1f ba       	out	0x1f, r1	; 31
    723e:	92 bd       	out	0x22, r25	; 34
    7240:	81 bd       	out	0x21, r24	; 33
    7242:	20 bd       	out	0x20, r18	; 32
    7244:	0f b6       	in	r0, 0x3f	; 63
    7246:	f8 94       	cli
    7248:	fa 9a       	sbi	0x1f, 2	; 31
    724a:	f9 9a       	sbi	0x1f, 1	; 31
    724c:	0f be       	out	0x3f, r0	; 63
    724e:	01 96       	adiw	r24, 0x01	; 1
    7250:	08 95       	ret

00007252 <dtoa_prf>:
    7252:	a9 e0       	ldi	r26, 0x09	; 9
    7254:	b0 e0       	ldi	r27, 0x00	; 0
    7256:	ef e2       	ldi	r30, 0x2F	; 47
    7258:	f9 e3       	ldi	r31, 0x39	; 57
    725a:	0c 94 70 3b 	jmp	0x76e0	; 0x76e0 <__prologue_saves__+0x10>
    725e:	6a 01       	movw	r12, r20
    7260:	f2 2e       	mov	r15, r18
    7262:	10 2f       	mov	r17, r16
    7264:	0c 33       	cpi	r16, 0x3C	; 60
    7266:	18 f4       	brcc	.+6      	; 0x726e <dtoa_prf+0x1c>
    7268:	b0 2e       	mov	r11, r16
    726a:	b3 94       	inc	r11
    726c:	02 c0       	rjmp	.+4      	; 0x7272 <dtoa_prf+0x20>
    726e:	ec e3       	ldi	r30, 0x3C	; 60
    7270:	be 2e       	mov	r11, r30
    7272:	ae 01       	movw	r20, r28
    7274:	4f 5f       	subi	r20, 0xFF	; 255
    7276:	5f 4f       	sbci	r21, 0xFF	; 255
    7278:	27 e0       	ldi	r18, 0x07	; 7
    727a:	0b 2d       	mov	r16, r11
    727c:	0e 94 80 3a 	call	0x7500	; 0x7500 <__ftoa_engine>
    7280:	29 81       	ldd	r18, Y+1	; 0x01
    7282:	30 e0       	ldi	r19, 0x00	; 0
    7284:	a9 01       	movw	r20, r18
    7286:	49 70       	andi	r20, 0x09	; 9
    7288:	50 70       	andi	r21, 0x00	; 0
    728a:	41 30       	cpi	r20, 0x01	; 1
    728c:	51 05       	cpc	r21, r1
    728e:	31 f0       	breq	.+12     	; 0x729c <dtoa_prf+0x4a>
    7290:	e1 fc       	sbrc	r14, 1
    7292:	06 c0       	rjmp	.+12     	; 0x72a0 <dtoa_prf+0x4e>
    7294:	e0 fe       	sbrs	r14, 0
    7296:	06 c0       	rjmp	.+12     	; 0x72a4 <dtoa_prf+0x52>
    7298:	e0 e2       	ldi	r30, 0x20	; 32
    729a:	05 c0       	rjmp	.+10     	; 0x72a6 <dtoa_prf+0x54>
    729c:	ed e2       	ldi	r30, 0x2D	; 45
    729e:	03 c0       	rjmp	.+6      	; 0x72a6 <dtoa_prf+0x54>
    72a0:	eb e2       	ldi	r30, 0x2B	; 43
    72a2:	01 c0       	rjmp	.+2      	; 0x72a6 <dtoa_prf+0x54>
    72a4:	e0 e0       	ldi	r30, 0x00	; 0
    72a6:	23 ff       	sbrs	r18, 3
    72a8:	37 c0       	rjmp	.+110    	; 0x7318 <dtoa_prf+0xc6>
    72aa:	ee 23       	and	r30, r30
    72ac:	11 f0       	breq	.+4      	; 0x72b2 <dtoa_prf+0x60>
    72ae:	84 e0       	ldi	r24, 0x04	; 4
    72b0:	01 c0       	rjmp	.+2      	; 0x72b4 <dtoa_prf+0x62>
    72b2:	83 e0       	ldi	r24, 0x03	; 3
    72b4:	8f 15       	cp	r24, r15
    72b6:	18 f4       	brcc	.+6      	; 0x72be <dtoa_prf+0x6c>
    72b8:	f8 1a       	sub	r15, r24
    72ba:	8f 2d       	mov	r24, r15
    72bc:	01 c0       	rjmp	.+2      	; 0x72c0 <dtoa_prf+0x6e>
    72be:	80 e0       	ldi	r24, 0x00	; 0
    72c0:	e4 fc       	sbrc	r14, 4
    72c2:	0b c0       	rjmp	.+22     	; 0x72da <dtoa_prf+0x88>
    72c4:	98 2f       	mov	r25, r24
    72c6:	d6 01       	movw	r26, r12
    72c8:	20 e2       	ldi	r18, 0x20	; 32
    72ca:	02 c0       	rjmp	.+4      	; 0x72d0 <dtoa_prf+0x7e>
    72cc:	2d 93       	st	X+, r18
    72ce:	91 50       	subi	r25, 0x01	; 1
    72d0:	99 23       	and	r25, r25
    72d2:	e1 f7       	brne	.-8      	; 0x72cc <dtoa_prf+0x7a>
    72d4:	c8 0e       	add	r12, r24
    72d6:	d1 1c       	adc	r13, r1
    72d8:	80 e0       	ldi	r24, 0x00	; 0
    72da:	ee 23       	and	r30, r30
    72dc:	19 f0       	breq	.+6      	; 0x72e4 <dtoa_prf+0x92>
    72de:	d6 01       	movw	r26, r12
    72e0:	ed 93       	st	X+, r30
    72e2:	6d 01       	movw	r12, r26
    72e4:	f6 01       	movw	r30, r12
    72e6:	31 96       	adiw	r30, 0x01	; 1
    72e8:	e2 fe       	sbrs	r14, 2
    72ea:	05 c0       	rjmp	.+10     	; 0x72f6 <dtoa_prf+0xa4>
    72ec:	9e e4       	ldi	r25, 0x4E	; 78
    72ee:	d6 01       	movw	r26, r12
    72f0:	9c 93       	st	X, r25
    72f2:	21 e4       	ldi	r18, 0x41	; 65
    72f4:	04 c0       	rjmp	.+8      	; 0x72fe <dtoa_prf+0xac>
    72f6:	9e e6       	ldi	r25, 0x6E	; 110
    72f8:	d6 01       	movw	r26, r12
    72fa:	9c 93       	st	X, r25
    72fc:	21 e6       	ldi	r18, 0x61	; 97
    72fe:	11 96       	adiw	r26, 0x01	; 1
    7300:	2c 93       	st	X, r18
    7302:	91 83       	std	Z+1, r25	; 0x01
    7304:	32 96       	adiw	r30, 0x02	; 2
    7306:	98 2f       	mov	r25, r24
    7308:	df 01       	movw	r26, r30
    730a:	20 e2       	ldi	r18, 0x20	; 32
    730c:	02 c0       	rjmp	.+4      	; 0x7312 <dtoa_prf+0xc0>
    730e:	2d 93       	st	X+, r18
    7310:	91 50       	subi	r25, 0x01	; 1
    7312:	99 23       	and	r25, r25
    7314:	e1 f7       	brne	.-8      	; 0x730e <dtoa_prf+0xbc>
    7316:	3d c0       	rjmp	.+122    	; 0x7392 <dtoa_prf+0x140>
    7318:	22 ff       	sbrs	r18, 2
    731a:	41 c0       	rjmp	.+130    	; 0x739e <dtoa_prf+0x14c>
    731c:	ee 23       	and	r30, r30
    731e:	11 f0       	breq	.+4      	; 0x7324 <dtoa_prf+0xd2>
    7320:	84 e0       	ldi	r24, 0x04	; 4
    7322:	01 c0       	rjmp	.+2      	; 0x7326 <dtoa_prf+0xd4>
    7324:	83 e0       	ldi	r24, 0x03	; 3
    7326:	8f 15       	cp	r24, r15
    7328:	18 f4       	brcc	.+6      	; 0x7330 <dtoa_prf+0xde>
    732a:	f8 1a       	sub	r15, r24
    732c:	8f 2d       	mov	r24, r15
    732e:	01 c0       	rjmp	.+2      	; 0x7332 <dtoa_prf+0xe0>
    7330:	80 e0       	ldi	r24, 0x00	; 0
    7332:	e4 fc       	sbrc	r14, 4
    7334:	0b c0       	rjmp	.+22     	; 0x734c <dtoa_prf+0xfa>
    7336:	98 2f       	mov	r25, r24
    7338:	d6 01       	movw	r26, r12
    733a:	20 e2       	ldi	r18, 0x20	; 32
    733c:	02 c0       	rjmp	.+4      	; 0x7342 <dtoa_prf+0xf0>
    733e:	2d 93       	st	X+, r18
    7340:	91 50       	subi	r25, 0x01	; 1
    7342:	99 23       	and	r25, r25
    7344:	e1 f7       	brne	.-8      	; 0x733e <dtoa_prf+0xec>
    7346:	c8 0e       	add	r12, r24
    7348:	d1 1c       	adc	r13, r1
    734a:	80 e0       	ldi	r24, 0x00	; 0
    734c:	ee 23       	and	r30, r30
    734e:	19 f0       	breq	.+6      	; 0x7356 <dtoa_prf+0x104>
    7350:	d6 01       	movw	r26, r12
    7352:	ed 93       	st	X+, r30
    7354:	6d 01       	movw	r12, r26
    7356:	f6 01       	movw	r30, r12
    7358:	31 96       	adiw	r30, 0x01	; 1
    735a:	e2 fe       	sbrs	r14, 2
    735c:	09 c0       	rjmp	.+18     	; 0x7370 <dtoa_prf+0x11e>
    735e:	99 e4       	ldi	r25, 0x49	; 73
    7360:	d6 01       	movw	r26, r12
    7362:	9c 93       	st	X, r25
    7364:	9e e4       	ldi	r25, 0x4E	; 78
    7366:	11 96       	adiw	r26, 0x01	; 1
    7368:	9c 93       	st	X, r25
    736a:	11 97       	sbiw	r26, 0x01	; 1
    736c:	96 e4       	ldi	r25, 0x46	; 70
    736e:	07 c0       	rjmp	.+14     	; 0x737e <dtoa_prf+0x12c>
    7370:	99 e6       	ldi	r25, 0x69	; 105
    7372:	d6 01       	movw	r26, r12
    7374:	9c 93       	st	X, r25
    7376:	9e e6       	ldi	r25, 0x6E	; 110
    7378:	11 96       	adiw	r26, 0x01	; 1
    737a:	9c 93       	st	X, r25
    737c:	96 e6       	ldi	r25, 0x66	; 102
    737e:	91 83       	std	Z+1, r25	; 0x01
    7380:	32 96       	adiw	r30, 0x02	; 2
    7382:	98 2f       	mov	r25, r24
    7384:	df 01       	movw	r26, r30
    7386:	20 e2       	ldi	r18, 0x20	; 32
    7388:	02 c0       	rjmp	.+4      	; 0x738e <dtoa_prf+0x13c>
    738a:	2d 93       	st	X+, r18
    738c:	91 50       	subi	r25, 0x01	; 1
    738e:	99 23       	and	r25, r25
    7390:	e1 f7       	brne	.-8      	; 0x738a <dtoa_prf+0x138>
    7392:	e8 0f       	add	r30, r24
    7394:	f1 1d       	adc	r31, r1
    7396:	10 82       	st	Z, r1
    7398:	2e ef       	ldi	r18, 0xFE	; 254
    739a:	3f ef       	ldi	r19, 0xFF	; 255
    739c:	ac c0       	rjmp	.+344    	; 0x74f6 <dtoa_prf+0x2a4>
    739e:	41 e0       	ldi	r20, 0x01	; 1
    73a0:	50 e0       	ldi	r21, 0x00	; 0
    73a2:	ee 23       	and	r30, r30
    73a4:	11 f4       	brne	.+4      	; 0x73aa <dtoa_prf+0x158>
    73a6:	40 e0       	ldi	r20, 0x00	; 0
    73a8:	50 e0       	ldi	r21, 0x00	; 0
    73aa:	18 16       	cp	r1, r24
    73ac:	19 06       	cpc	r1, r25
    73ae:	24 f4       	brge	.+8      	; 0x73b8 <dtoa_prf+0x166>
    73b0:	bc 01       	movw	r22, r24
    73b2:	6f 5f       	subi	r22, 0xFF	; 255
    73b4:	7f 4f       	sbci	r23, 0xFF	; 255
    73b6:	02 c0       	rjmp	.+4      	; 0x73bc <dtoa_prf+0x16a>
    73b8:	61 e0       	ldi	r22, 0x01	; 1
    73ba:	70 e0       	ldi	r23, 0x00	; 0
    73bc:	64 0f       	add	r22, r20
    73be:	75 1f       	adc	r23, r21
    73c0:	11 23       	and	r17, r17
    73c2:	29 f0       	breq	.+10     	; 0x73ce <dtoa_prf+0x17c>
    73c4:	41 2f       	mov	r20, r17
    73c6:	50 e0       	ldi	r21, 0x00	; 0
    73c8:	4f 5f       	subi	r20, 0xFF	; 255
    73ca:	5f 4f       	sbci	r21, 0xFF	; 255
    73cc:	02 c0       	rjmp	.+4      	; 0x73d2 <dtoa_prf+0x180>
    73ce:	40 e0       	ldi	r20, 0x00	; 0
    73d0:	50 e0       	ldi	r21, 0x00	; 0
    73d2:	46 0f       	add	r20, r22
    73d4:	57 1f       	adc	r21, r23
    73d6:	6f 2d       	mov	r22, r15
    73d8:	70 e0       	ldi	r23, 0x00	; 0
    73da:	46 17       	cp	r20, r22
    73dc:	57 07       	cpc	r21, r23
    73de:	1c f4       	brge	.+6      	; 0x73e6 <dtoa_prf+0x194>
    73e0:	0f 2d       	mov	r16, r15
    73e2:	04 1b       	sub	r16, r20
    73e4:	01 c0       	rjmp	.+2      	; 0x73e8 <dtoa_prf+0x196>
    73e6:	00 e0       	ldi	r16, 0x00	; 0
    73e8:	ff 24       	eor	r15, r15
    73ea:	a7 01       	movw	r20, r14
    73ec:	40 71       	andi	r20, 0x10	; 16
    73ee:	50 70       	andi	r21, 0x00	; 0
    73f0:	e4 fc       	sbrc	r14, 4
    73f2:	0d c0       	rjmp	.+26     	; 0x740e <dtoa_prf+0x1bc>
    73f4:	e3 fc       	sbrc	r14, 3
    73f6:	0b c0       	rjmp	.+22     	; 0x740e <dtoa_prf+0x1bc>
    73f8:	60 2f       	mov	r22, r16
    73fa:	d6 01       	movw	r26, r12
    73fc:	70 e2       	ldi	r23, 0x20	; 32
    73fe:	02 c0       	rjmp	.+4      	; 0x7404 <dtoa_prf+0x1b2>
    7400:	7d 93       	st	X+, r23
    7402:	61 50       	subi	r22, 0x01	; 1
    7404:	66 23       	and	r22, r22
    7406:	e1 f7       	brne	.-8      	; 0x7400 <dtoa_prf+0x1ae>
    7408:	c0 0e       	add	r12, r16
    740a:	d1 1c       	adc	r13, r1
    740c:	00 e0       	ldi	r16, 0x00	; 0
    740e:	ee 23       	and	r30, r30
    7410:	19 f0       	breq	.+6      	; 0x7418 <dtoa_prf+0x1c6>
    7412:	d6 01       	movw	r26, r12
    7414:	ed 93       	st	X+, r30
    7416:	6d 01       	movw	r12, r26
    7418:	41 15       	cp	r20, r1
    741a:	51 05       	cpc	r21, r1
    741c:	59 f4       	brne	.+22     	; 0x7434 <dtoa_prf+0x1e2>
    741e:	40 2f       	mov	r20, r16
    7420:	f6 01       	movw	r30, r12
    7422:	50 e3       	ldi	r21, 0x30	; 48
    7424:	02 c0       	rjmp	.+4      	; 0x742a <dtoa_prf+0x1d8>
    7426:	51 93       	st	Z+, r21
    7428:	41 50       	subi	r20, 0x01	; 1
    742a:	44 23       	and	r20, r20
    742c:	e1 f7       	brne	.-8      	; 0x7426 <dtoa_prf+0x1d4>
    742e:	c0 0e       	add	r12, r16
    7430:	d1 1c       	adc	r13, r1
    7432:	00 e0       	ldi	r16, 0x00	; 0
    7434:	b8 0e       	add	r11, r24
    7436:	fa 80       	ldd	r15, Y+2	; 0x02
    7438:	a9 01       	movw	r20, r18
    743a:	40 71       	andi	r20, 0x10	; 16
    743c:	50 70       	andi	r21, 0x00	; 0
    743e:	24 ff       	sbrs	r18, 4
    7440:	04 c0       	rjmp	.+8      	; 0x744a <dtoa_prf+0x1f8>
    7442:	bf 2d       	mov	r27, r15
    7444:	b1 33       	cpi	r27, 0x31	; 49
    7446:	09 f4       	brne	.+2      	; 0x744a <dtoa_prf+0x1f8>
    7448:	ba 94       	dec	r11
    744a:	1b 14       	cp	r1, r11
    744c:	2c f4       	brge	.+10     	; 0x7458 <dtoa_prf+0x206>
    744e:	ab 2d       	mov	r26, r11
    7450:	a9 30       	cpi	r26, 0x09	; 9
    7452:	18 f0       	brcs	.+6      	; 0x745a <dtoa_prf+0x208>
    7454:	a8 e0       	ldi	r26, 0x08	; 8
    7456:	01 c0       	rjmp	.+2      	; 0x745a <dtoa_prf+0x208>
    7458:	a1 e0       	ldi	r26, 0x01	; 1
    745a:	9c 01       	movw	r18, r24
    745c:	97 ff       	sbrs	r25, 7
    745e:	02 c0       	rjmp	.+4      	; 0x7464 <dtoa_prf+0x212>
    7460:	20 e0       	ldi	r18, 0x00	; 0
    7462:	30 e0       	ldi	r19, 0x00	; 0
    7464:	bc 01       	movw	r22, r24
    7466:	6f 5f       	subi	r22, 0xFF	; 255
    7468:	7f 4f       	sbci	r23, 0xFF	; 255
    746a:	62 1b       	sub	r22, r18
    746c:	73 0b       	sbc	r23, r19
    746e:	fe 01       	movw	r30, r28
    7470:	31 96       	adiw	r30, 0x01	; 1
    7472:	e6 0f       	add	r30, r22
    7474:	f7 1f       	adc	r31, r23
    7476:	6e e2       	ldi	r22, 0x2E	; 46
    7478:	e6 2e       	mov	r14, r22
    747a:	bc 01       	movw	r22, r24
    747c:	6a 1b       	sub	r22, r26
    747e:	71 09       	sbc	r23, r1
    7480:	a1 2f       	mov	r26, r17
    7482:	b0 e0       	ldi	r27, 0x00	; 0
    7484:	aa 24       	eor	r10, r10
    7486:	bb 24       	eor	r11, r11
    7488:	aa 1a       	sub	r10, r26
    748a:	bb 0a       	sbc	r11, r27
    748c:	1f ef       	ldi	r17, 0xFF	; 255
    748e:	2f 3f       	cpi	r18, 0xFF	; 255
    7490:	31 07       	cpc	r19, r17
    7492:	19 f4       	brne	.+6      	; 0x749a <dtoa_prf+0x248>
    7494:	d6 01       	movw	r26, r12
    7496:	ed 92       	st	X+, r14
    7498:	6d 01       	movw	r12, r26
    749a:	82 17       	cp	r24, r18
    749c:	93 07       	cpc	r25, r19
    749e:	2c f0       	brlt	.+10     	; 0x74aa <dtoa_prf+0x258>
    74a0:	62 17       	cp	r22, r18
    74a2:	73 07       	cpc	r23, r19
    74a4:	14 f4       	brge	.+4      	; 0x74aa <dtoa_prf+0x258>
    74a6:	10 81       	ld	r17, Z
    74a8:	01 c0       	rjmp	.+2      	; 0x74ac <dtoa_prf+0x25a>
    74aa:	10 e3       	ldi	r17, 0x30	; 48
    74ac:	21 50       	subi	r18, 0x01	; 1
    74ae:	30 40       	sbci	r19, 0x00	; 0
    74b0:	31 96       	adiw	r30, 0x01	; 1
    74b2:	2a 15       	cp	r18, r10
    74b4:	3b 05       	cpc	r19, r11
    74b6:	24 f0       	brlt	.+8      	; 0x74c0 <dtoa_prf+0x26e>
    74b8:	d6 01       	movw	r26, r12
    74ba:	1d 93       	st	X+, r17
    74bc:	6d 01       	movw	r12, r26
    74be:	e6 cf       	rjmp	.-52     	; 0x748c <dtoa_prf+0x23a>
    74c0:	28 17       	cp	r18, r24
    74c2:	39 07       	cpc	r19, r25
    74c4:	49 f4       	brne	.+18     	; 0x74d8 <dtoa_prf+0x286>
    74c6:	bf 2d       	mov	r27, r15
    74c8:	b6 33       	cpi	r27, 0x36	; 54
    74ca:	28 f4       	brcc	.+10     	; 0x74d6 <dtoa_prf+0x284>
    74cc:	b5 33       	cpi	r27, 0x35	; 53
    74ce:	21 f4       	brne	.+8      	; 0x74d8 <dtoa_prf+0x286>
    74d0:	41 15       	cp	r20, r1
    74d2:	51 05       	cpc	r21, r1
    74d4:	09 f4       	brne	.+2      	; 0x74d8 <dtoa_prf+0x286>
    74d6:	11 e3       	ldi	r17, 0x31	; 49
    74d8:	f6 01       	movw	r30, r12
    74da:	11 93       	st	Z+, r17
    74dc:	80 2f       	mov	r24, r16
    74de:	df 01       	movw	r26, r30
    74e0:	90 e2       	ldi	r25, 0x20	; 32
    74e2:	02 c0       	rjmp	.+4      	; 0x74e8 <dtoa_prf+0x296>
    74e4:	9d 93       	st	X+, r25
    74e6:	81 50       	subi	r24, 0x01	; 1
    74e8:	88 23       	and	r24, r24
    74ea:	e1 f7       	brne	.-8      	; 0x74e4 <dtoa_prf+0x292>
    74ec:	e0 0f       	add	r30, r16
    74ee:	f1 1d       	adc	r31, r1
    74f0:	10 82       	st	Z, r1
    74f2:	20 e0       	ldi	r18, 0x00	; 0
    74f4:	30 e0       	ldi	r19, 0x00	; 0
    74f6:	c9 01       	movw	r24, r18
    74f8:	29 96       	adiw	r28, 0x09	; 9
    74fa:	ea e0       	ldi	r30, 0x0A	; 10
    74fc:	0c 94 8c 3b 	jmp	0x7718	; 0x7718 <__epilogue_restores__+0x10>

00007500 <__ftoa_engine>:
    7500:	28 30       	cpi	r18, 0x08	; 8
    7502:	08 f0       	brcs	.+2      	; 0x7506 <__ftoa_engine+0x6>
    7504:	27 e0       	ldi	r18, 0x07	; 7
    7506:	33 27       	eor	r19, r19
    7508:	da 01       	movw	r26, r20
    750a:	99 0f       	add	r25, r25
    750c:	31 1d       	adc	r19, r1
    750e:	87 fd       	sbrc	r24, 7
    7510:	91 60       	ori	r25, 0x01	; 1
    7512:	00 96       	adiw	r24, 0x00	; 0
    7514:	61 05       	cpc	r22, r1
    7516:	71 05       	cpc	r23, r1
    7518:	39 f4       	brne	.+14     	; 0x7528 <__ftoa_engine+0x28>
    751a:	32 60       	ori	r19, 0x02	; 2
    751c:	2e 5f       	subi	r18, 0xFE	; 254
    751e:	3d 93       	st	X+, r19
    7520:	30 e3       	ldi	r19, 0x30	; 48
    7522:	2a 95       	dec	r18
    7524:	e1 f7       	brne	.-8      	; 0x751e <__ftoa_engine+0x1e>
    7526:	08 95       	ret
    7528:	9f 3f       	cpi	r25, 0xFF	; 255
    752a:	30 f0       	brcs	.+12     	; 0x7538 <__ftoa_engine+0x38>
    752c:	80 38       	cpi	r24, 0x80	; 128
    752e:	71 05       	cpc	r23, r1
    7530:	61 05       	cpc	r22, r1
    7532:	09 f0       	breq	.+2      	; 0x7536 <__ftoa_engine+0x36>
    7534:	3c 5f       	subi	r19, 0xFC	; 252
    7536:	3c 5f       	subi	r19, 0xFC	; 252
    7538:	3d 93       	st	X+, r19
    753a:	91 30       	cpi	r25, 0x01	; 1
    753c:	08 f0       	brcs	.+2      	; 0x7540 <__ftoa_engine+0x40>
    753e:	80 68       	ori	r24, 0x80	; 128
    7540:	91 1d       	adc	r25, r1
    7542:	df 93       	push	r29
    7544:	cf 93       	push	r28
    7546:	1f 93       	push	r17
    7548:	0f 93       	push	r16
    754a:	ff 92       	push	r15
    754c:	ef 92       	push	r14
    754e:	19 2f       	mov	r17, r25
    7550:	98 7f       	andi	r25, 0xF8	; 248
    7552:	96 95       	lsr	r25
    7554:	e9 2f       	mov	r30, r25
    7556:	96 95       	lsr	r25
    7558:	96 95       	lsr	r25
    755a:	e9 0f       	add	r30, r25
    755c:	ff 27       	eor	r31, r31
    755e:	eb 50       	subi	r30, 0x0B	; 11
    7560:	fe 4e       	sbci	r31, 0xEE	; 238
    7562:	99 27       	eor	r25, r25
    7564:	33 27       	eor	r19, r19
    7566:	ee 24       	eor	r14, r14
    7568:	ff 24       	eor	r15, r15
    756a:	a7 01       	movw	r20, r14
    756c:	e7 01       	movw	r28, r14
    756e:	05 90       	lpm	r0, Z+
    7570:	08 94       	sec
    7572:	07 94       	ror	r0
    7574:	28 f4       	brcc	.+10     	; 0x7580 <__ftoa_engine+0x80>
    7576:	36 0f       	add	r19, r22
    7578:	e7 1e       	adc	r14, r23
    757a:	f8 1e       	adc	r15, r24
    757c:	49 1f       	adc	r20, r25
    757e:	51 1d       	adc	r21, r1
    7580:	66 0f       	add	r22, r22
    7582:	77 1f       	adc	r23, r23
    7584:	88 1f       	adc	r24, r24
    7586:	99 1f       	adc	r25, r25
    7588:	06 94       	lsr	r0
    758a:	a1 f7       	brne	.-24     	; 0x7574 <__ftoa_engine+0x74>
    758c:	05 90       	lpm	r0, Z+
    758e:	07 94       	ror	r0
    7590:	28 f4       	brcc	.+10     	; 0x759c <__ftoa_engine+0x9c>
    7592:	e7 0e       	add	r14, r23
    7594:	f8 1e       	adc	r15, r24
    7596:	49 1f       	adc	r20, r25
    7598:	56 1f       	adc	r21, r22
    759a:	c1 1d       	adc	r28, r1
    759c:	77 0f       	add	r23, r23
    759e:	88 1f       	adc	r24, r24
    75a0:	99 1f       	adc	r25, r25
    75a2:	66 1f       	adc	r22, r22
    75a4:	06 94       	lsr	r0
    75a6:	a1 f7       	brne	.-24     	; 0x7590 <__ftoa_engine+0x90>
    75a8:	05 90       	lpm	r0, Z+
    75aa:	07 94       	ror	r0
    75ac:	28 f4       	brcc	.+10     	; 0x75b8 <__ftoa_engine+0xb8>
    75ae:	f8 0e       	add	r15, r24
    75b0:	49 1f       	adc	r20, r25
    75b2:	56 1f       	adc	r21, r22
    75b4:	c7 1f       	adc	r28, r23
    75b6:	d1 1d       	adc	r29, r1
    75b8:	88 0f       	add	r24, r24
    75ba:	99 1f       	adc	r25, r25
    75bc:	66 1f       	adc	r22, r22
    75be:	77 1f       	adc	r23, r23
    75c0:	06 94       	lsr	r0
    75c2:	a1 f7       	brne	.-24     	; 0x75ac <__ftoa_engine+0xac>
    75c4:	05 90       	lpm	r0, Z+
    75c6:	07 94       	ror	r0
    75c8:	20 f4       	brcc	.+8      	; 0x75d2 <__ftoa_engine+0xd2>
    75ca:	49 0f       	add	r20, r25
    75cc:	56 1f       	adc	r21, r22
    75ce:	c7 1f       	adc	r28, r23
    75d0:	d8 1f       	adc	r29, r24
    75d2:	99 0f       	add	r25, r25
    75d4:	66 1f       	adc	r22, r22
    75d6:	77 1f       	adc	r23, r23
    75d8:	88 1f       	adc	r24, r24
    75da:	06 94       	lsr	r0
    75dc:	a9 f7       	brne	.-22     	; 0x75c8 <__ftoa_engine+0xc8>
    75de:	84 91       	lpm	r24, Z+
    75e0:	10 95       	com	r17
    75e2:	17 70       	andi	r17, 0x07	; 7
    75e4:	41 f0       	breq	.+16     	; 0x75f6 <__ftoa_engine+0xf6>
    75e6:	d6 95       	lsr	r29
    75e8:	c7 95       	ror	r28
    75ea:	57 95       	ror	r21
    75ec:	47 95       	ror	r20
    75ee:	f7 94       	ror	r15
    75f0:	e7 94       	ror	r14
    75f2:	1a 95       	dec	r17
    75f4:	c1 f7       	brne	.-16     	; 0x75e6 <__ftoa_engine+0xe6>
    75f6:	eb e9       	ldi	r30, 0x9B	; 155
    75f8:	f1 e1       	ldi	r31, 0x11	; 17
    75fa:	68 94       	set
    75fc:	15 90       	lpm	r1, Z+
    75fe:	15 91       	lpm	r17, Z+
    7600:	35 91       	lpm	r19, Z+
    7602:	65 91       	lpm	r22, Z+
    7604:	95 91       	lpm	r25, Z+
    7606:	05 90       	lpm	r0, Z+
    7608:	7f e2       	ldi	r23, 0x2F	; 47
    760a:	73 95       	inc	r23
    760c:	e1 18       	sub	r14, r1
    760e:	f1 0a       	sbc	r15, r17
    7610:	43 0b       	sbc	r20, r19
    7612:	56 0b       	sbc	r21, r22
    7614:	c9 0b       	sbc	r28, r25
    7616:	d0 09       	sbc	r29, r0
    7618:	c0 f7       	brcc	.-16     	; 0x760a <__ftoa_engine+0x10a>
    761a:	e1 0c       	add	r14, r1
    761c:	f1 1e       	adc	r15, r17
    761e:	43 1f       	adc	r20, r19
    7620:	56 1f       	adc	r21, r22
    7622:	c9 1f       	adc	r28, r25
    7624:	d0 1d       	adc	r29, r0
    7626:	7e f4       	brtc	.+30     	; 0x7646 <__ftoa_engine+0x146>
    7628:	70 33       	cpi	r23, 0x30	; 48
    762a:	11 f4       	brne	.+4      	; 0x7630 <__ftoa_engine+0x130>
    762c:	8a 95       	dec	r24
    762e:	e6 cf       	rjmp	.-52     	; 0x75fc <__ftoa_engine+0xfc>
    7630:	e8 94       	clt
    7632:	01 50       	subi	r16, 0x01	; 1
    7634:	30 f0       	brcs	.+12     	; 0x7642 <__ftoa_engine+0x142>
    7636:	08 0f       	add	r16, r24
    7638:	0a f4       	brpl	.+2      	; 0x763c <__ftoa_engine+0x13c>
    763a:	00 27       	eor	r16, r16
    763c:	02 17       	cp	r16, r18
    763e:	08 f4       	brcc	.+2      	; 0x7642 <__ftoa_engine+0x142>
    7640:	20 2f       	mov	r18, r16
    7642:	23 95       	inc	r18
    7644:	02 2f       	mov	r16, r18
    7646:	7a 33       	cpi	r23, 0x3A	; 58
    7648:	28 f0       	brcs	.+10     	; 0x7654 <__ftoa_engine+0x154>
    764a:	79 e3       	ldi	r23, 0x39	; 57
    764c:	7d 93       	st	X+, r23
    764e:	2a 95       	dec	r18
    7650:	e9 f7       	brne	.-6      	; 0x764c <__ftoa_engine+0x14c>
    7652:	10 c0       	rjmp	.+32     	; 0x7674 <__ftoa_engine+0x174>
    7654:	7d 93       	st	X+, r23
    7656:	2a 95       	dec	r18
    7658:	89 f6       	brne	.-94     	; 0x75fc <__ftoa_engine+0xfc>
    765a:	06 94       	lsr	r0
    765c:	97 95       	ror	r25
    765e:	67 95       	ror	r22
    7660:	37 95       	ror	r19
    7662:	17 95       	ror	r17
    7664:	17 94       	ror	r1
    7666:	e1 18       	sub	r14, r1
    7668:	f1 0a       	sbc	r15, r17
    766a:	43 0b       	sbc	r20, r19
    766c:	56 0b       	sbc	r21, r22
    766e:	c9 0b       	sbc	r28, r25
    7670:	d0 09       	sbc	r29, r0
    7672:	98 f0       	brcs	.+38     	; 0x769a <__ftoa_engine+0x19a>
    7674:	23 95       	inc	r18
    7676:	7e 91       	ld	r23, -X
    7678:	73 95       	inc	r23
    767a:	7a 33       	cpi	r23, 0x3A	; 58
    767c:	08 f0       	brcs	.+2      	; 0x7680 <__ftoa_engine+0x180>
    767e:	70 e3       	ldi	r23, 0x30	; 48
    7680:	7c 93       	st	X, r23
    7682:	20 13       	cpse	r18, r16
    7684:	b8 f7       	brcc	.-18     	; 0x7674 <__ftoa_engine+0x174>
    7686:	7e 91       	ld	r23, -X
    7688:	70 61       	ori	r23, 0x10	; 16
    768a:	7d 93       	st	X+, r23
    768c:	30 f0       	brcs	.+12     	; 0x769a <__ftoa_engine+0x19a>
    768e:	83 95       	inc	r24
    7690:	71 e3       	ldi	r23, 0x31	; 49
    7692:	7d 93       	st	X+, r23
    7694:	70 e3       	ldi	r23, 0x30	; 48
    7696:	2a 95       	dec	r18
    7698:	e1 f7       	brne	.-8      	; 0x7692 <__ftoa_engine+0x192>
    769a:	11 24       	eor	r1, r1
    769c:	ef 90       	pop	r14
    769e:	ff 90       	pop	r15
    76a0:	0f 91       	pop	r16
    76a2:	1f 91       	pop	r17
    76a4:	cf 91       	pop	r28
    76a6:	df 91       	pop	r29
    76a8:	99 27       	eor	r25, r25
    76aa:	87 fd       	sbrc	r24, 7
    76ac:	90 95       	com	r25
    76ae:	08 95       	ret

000076b0 <strrev>:
    76b0:	dc 01       	movw	r26, r24
    76b2:	fc 01       	movw	r30, r24
    76b4:	67 2f       	mov	r22, r23
    76b6:	71 91       	ld	r23, Z+
    76b8:	77 23       	and	r23, r23
    76ba:	e1 f7       	brne	.-8      	; 0x76b4 <strrev+0x4>
    76bc:	32 97       	sbiw	r30, 0x02	; 2
    76be:	04 c0       	rjmp	.+8      	; 0x76c8 <strrev+0x18>
    76c0:	7c 91       	ld	r23, X
    76c2:	6d 93       	st	X+, r22
    76c4:	70 83       	st	Z, r23
    76c6:	62 91       	ld	r22, -Z
    76c8:	ae 17       	cp	r26, r30
    76ca:	bf 07       	cpc	r27, r31
    76cc:	c8 f3       	brcs	.-14     	; 0x76c0 <strrev+0x10>
    76ce:	08 95       	ret

000076d0 <__prologue_saves__>:
    76d0:	2f 92       	push	r2
    76d2:	3f 92       	push	r3
    76d4:	4f 92       	push	r4
    76d6:	5f 92       	push	r5
    76d8:	6f 92       	push	r6
    76da:	7f 92       	push	r7
    76dc:	8f 92       	push	r8
    76de:	9f 92       	push	r9
    76e0:	af 92       	push	r10
    76e2:	bf 92       	push	r11
    76e4:	cf 92       	push	r12
    76e6:	df 92       	push	r13
    76e8:	ef 92       	push	r14
    76ea:	ff 92       	push	r15
    76ec:	0f 93       	push	r16
    76ee:	1f 93       	push	r17
    76f0:	cf 93       	push	r28
    76f2:	df 93       	push	r29
    76f4:	cd b7       	in	r28, 0x3d	; 61
    76f6:	de b7       	in	r29, 0x3e	; 62
    76f8:	ca 1b       	sub	r28, r26
    76fa:	db 0b       	sbc	r29, r27
    76fc:	0f b6       	in	r0, 0x3f	; 63
    76fe:	f8 94       	cli
    7700:	de bf       	out	0x3e, r29	; 62
    7702:	0f be       	out	0x3f, r0	; 63
    7704:	cd bf       	out	0x3d, r28	; 61
    7706:	09 94       	ijmp

00007708 <__epilogue_restores__>:
    7708:	2a 88       	ldd	r2, Y+18	; 0x12
    770a:	39 88       	ldd	r3, Y+17	; 0x11
    770c:	48 88       	ldd	r4, Y+16	; 0x10
    770e:	5f 84       	ldd	r5, Y+15	; 0x0f
    7710:	6e 84       	ldd	r6, Y+14	; 0x0e
    7712:	7d 84       	ldd	r7, Y+13	; 0x0d
    7714:	8c 84       	ldd	r8, Y+12	; 0x0c
    7716:	9b 84       	ldd	r9, Y+11	; 0x0b
    7718:	aa 84       	ldd	r10, Y+10	; 0x0a
    771a:	b9 84       	ldd	r11, Y+9	; 0x09
    771c:	c8 84       	ldd	r12, Y+8	; 0x08
    771e:	df 80       	ldd	r13, Y+7	; 0x07
    7720:	ee 80       	ldd	r14, Y+6	; 0x06
    7722:	fd 80       	ldd	r15, Y+5	; 0x05
    7724:	0c 81       	ldd	r16, Y+4	; 0x04
    7726:	1b 81       	ldd	r17, Y+3	; 0x03
    7728:	aa 81       	ldd	r26, Y+2	; 0x02
    772a:	b9 81       	ldd	r27, Y+1	; 0x01
    772c:	ce 0f       	add	r28, r30
    772e:	d1 1d       	adc	r29, r1
    7730:	0f b6       	in	r0, 0x3f	; 63
    7732:	f8 94       	cli
    7734:	de bf       	out	0x3e, r29	; 62
    7736:	0f be       	out	0x3f, r0	; 63
    7738:	cd bf       	out	0x3d, r28	; 61
    773a:	ed 01       	movw	r28, r26
    773c:	08 95       	ret

0000773e <_exit>:
    773e:	f8 94       	cli

00007740 <__stop_program>:
    7740:	ff cf       	rjmp	.-2      	; 0x7740 <__stop_program>
