
HefnyCopter 2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000014  00800100  00007bd4  00007c68  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00007bd4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000006f0  00800114  00800114  00007c7c  2**0
                  ALLOC
  3 .stab         00003c00  00000000  00000000  00007c7c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000f25  00000000  00000000  0000b87c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000358  00000000  00000000  0000c7a1  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00003d19  00000000  00000000  0000caf9  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000cf99  00000000  00000000  00010812  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00002506  00000000  00000000  0001d7ab  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000661b  00000000  00000000  0001fcb1  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000a70  00000000  00000000  000262cc  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000019fb  00000000  00000000  00026d3c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00002256  00000000  00000000  00028737  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubtypes 00000b57  00000000  00000000  0002a98d  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000118  00000000  00000000  0002b4e4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 51 0b 	jmp	0x16a2	; 0x16a2 <__ctors_end>
       4:	0c 94 52 0a 	jmp	0x14a4	; 0x14a4 <__vector_1>
       8:	0c 94 14 0a 	jmp	0x1428	; 0x1428 <__vector_2>
       c:	0c 94 c1 0a 	jmp	0x1582	; 0x1582 <__vector_3>
      10:	0c 94 6e 0b 	jmp	0x16dc	; 0x16dc <__bad_interrupt>
      14:	0c 94 15 0b 	jmp	0x162a	; 0x162a <__vector_5>
      18:	0c 94 7b 09 	jmp	0x12f6	; 0x12f6 <__vector_6>
      1c:	0c 94 90 0a 	jmp	0x1520	; 0x1520 <__vector_7>
      20:	0c 94 6e 0b 	jmp	0x16dc	; 0x16dc <__bad_interrupt>
      24:	0c 94 6e 0b 	jmp	0x16dc	; 0x16dc <__bad_interrupt>
      28:	0c 94 6e 0b 	jmp	0x16dc	; 0x16dc <__bad_interrupt>
      2c:	0c 94 fa 0f 	jmp	0x1ff4	; 0x1ff4 <__vector_11>
      30:	0c 94 6e 0b 	jmp	0x16dc	; 0x16dc <__bad_interrupt>
      34:	0c 94 6e 0b 	jmp	0x16dc	; 0x16dc <__bad_interrupt>
      38:	0c 94 6e 0b 	jmp	0x16dc	; 0x16dc <__bad_interrupt>
      3c:	0c 94 e3 0f 	jmp	0x1fc6	; 0x1fc6 <__vector_15>
      40:	0c 94 6e 0b 	jmp	0x16dc	; 0x16dc <__bad_interrupt>
      44:	0c 94 6e 0b 	jmp	0x16dc	; 0x16dc <__bad_interrupt>
      48:	0c 94 22 09 	jmp	0x1244	; 0x1244 <__vector_18>
      4c:	0c 94 6e 0b 	jmp	0x16dc	; 0x16dc <__bad_interrupt>
      50:	0c 94 6e 0b 	jmp	0x16dc	; 0x16dc <__bad_interrupt>
      54:	0c 94 6e 0b 	jmp	0x16dc	; 0x16dc <__bad_interrupt>
      58:	0c 94 6e 0b 	jmp	0x16dc	; 0x16dc <__bad_interrupt>
      5c:	0c 94 6e 0b 	jmp	0x16dc	; 0x16dc <__bad_interrupt>
      60:	0c 94 6c 2a 	jmp	0x54d8	; 0x54d8 <__vector_24>
      64:	0c 94 6e 0b 	jmp	0x16dc	; 0x16dc <__bad_interrupt>
      68:	0c 94 6e 0b 	jmp	0x16dc	; 0x16dc <__bad_interrupt>
      6c:	0c 94 6e 0b 	jmp	0x16dc	; 0x16dc <__bad_interrupt>
      70:	0c 94 be 10 	jmp	0x217c	; 0x217c <__vector_28>
      74:	0c 94 6e 0b 	jmp	0x16dc	; 0x16dc <__bad_interrupt>
      78:	0c 94 6e 0b 	jmp	0x16dc	; 0x16dc <__bad_interrupt>

0000007c <_initSeq>:
      7c:	af 40 a0 a6 a4 a2 ee c8 2f 24 ac 00 f8 00 e3 ff     .@....../$......

0000008c <masks.1989>:
      8c:	01 02 04 08 10 20 40 80                             ..... @.

00000094 <defaultConfig>:
      94:	fe 00 ff 00 00 03 00 01 00 00 00 96 04 00 19 00     ................
      a4:	64 00 00 00 00 00 fd ff 14 00 00 00 32 00 5a 00     d...........2.Z.
      b4:	32 00 5a 00 00 00 14 00 c8 00 0a 00 5a 00 14 00     2.Z.........Z...
      c4:	0f 00 fe ff 32 00 de 03 0f 00 1e 00 00 00 00 00     ....2...........
      d4:	00 00 00 00 58 02 0f 00 19 00 00 00 00 00 00 00     ....X...........
	...
     12c:	00 00 00 01                                         ....

00000130 <font12x16>:
     130:	0c 10 4f 11                                         ..O.

00000134 <_font12x16map>:
	...
     154:	7c 00 ff 33 ff 33 7c 00 00 00 00 00 00 00 00 00     |..3.3|.........
     164:	00 00 00 00 00 00 3c 00 3c 00 00 00 00 00 3c 00     ......<.<.....<.
     174:	3c 00 00 00 00 00 00 00 00 00 00 02 10 1e 90 1f     <...............
     184:	f0 03 7e 02 1e 1e 90 1f f0 03 7e 02 1e 00 10 00     ..~.......~.....
     194:	00 00 00 00 78 04 fc 0c cc 0c ff 3f ff 3f cc 0c     ....x......?.?..
     1a4:	cc 0f 88 07 00 00 00 00 00 00 00 30 38 38 38 1c     ...........0888.
     1b4:	38 0e 00 07 80 03 c0 01 e0 38 70 38 38 38 1c 00     8........8p888..
     1c4:	00 00 00 00 00 1f b8 3f fc 31 c6 21 e2 37 3e 1e     .......?.1.!.7>.
     1d4:	1c 1c 00 36 00 22 00 00 00 00 00 00 00 00 00 00     ...6."..........
     1e4:	27 00 3f 00 1f 00 00 00 00 00 00 00 00 00 00 00     '.?.............
     1f4:	00 00 00 00 00 00 f0 03 fc 0f fe 1f 07 38 01 20     .............8. 
     204:	01 20 00 00 00 00 00 00 00 00 00 00 00 00 01 20     . ............. 
     214:	01 20 07 38 fe 1f fc 0f f0 03 00 00 00 00 00 00     . .8............
     224:	00 00 00 00 98 0c b8 0e e0 03 f8 0f f8 0f e0 03     ................
     234:	b8 0e 98 0c 00 00 00 00 00 00 00 00 80 01 80 01     ................
     244:	80 01 f0 0f f0 0f 80 01 80 01 80 01 00 00 00 00     ................
	...
     25c:	00 b8 00 f8 00 78 00 00 00 00 00 00 00 00 00 00     .....x..........
     26c:	00 00 00 00 80 01 80 01 80 01 80 01 80 01 80 01     ................
     27c:	80 01 80 01 00 00 00 00 00 00 00 00 00 00 00 00     ................
     28c:	00 38 00 38 00 38 00 00 00 00 00 00 00 00 00 00     .8.8.8..........
     29c:	00 00 00 18 00 1c 00 0e 00 07 80 03 c0 01 e0 00     ................
     2ac:	70 00 38 00 1c 00 0e 00 00 00 f8 07 fe 1f 06 1e     p.8.............
     2bc:	03 33 83 31 c3 30 63 30 33 30 1e 18 fe 1f f8 07     .3.1.0c030......
     2cc:	00 00 00 00 00 00 0c 30 0c 30 0e 30 ff 3f ff 3f     .......0.0.0.?.?
     2dc:	00 30 00 30 00 30 00 00 00 00 1c 30 1e 38 07 3c     .0.0.0.....0.8.<
     2ec:	03 3e 03 37 83 33 c3 31 e3 30 77 30 3e 30 1c 30     .>.7.3.1.0w0>0.0
     2fc:	00 00 0c 0c 0e 1c 07 38 c3 30 c3 30 c3 30 c3 30     .......8.0.0.0.0
     30c:	c3 30 e7 39 7e 1f 3c 0e 00 00 c0 03 e0 03 70 03     .0.9~.<.......p.
     31c:	38 03 1c 03 0e 03 07 03 ff 3f ff 3f 00 03 00 03     8........?.?....
     32c:	00 00 3f 0c 7f 1c 63 38 63 30 63 30 63 30 63 30     ..?...c8c0c0c0c0
     33c:	63 30 e3 38 c3 1f 83 0f 00 00 c0 0f f0 1f f8 39     c0.8...........9
     34c:	dc 30 ce 30 c7 30 c3 30 c3 30 c3 39 80 1f 00 0f     .0.0.0.0.0.9....
     35c:	00 00 03 00 03 00 03 00 03 30 03 3c 03 0f c3 03     .........0.<....
     36c:	f3 00 3f 00 0f 00 03 00 00 00 00 0f bc 1f fe 39     ..?............9
     37c:	e7 30 c3 30 c3 30 c3 30 e7 30 fe 39 bc 1f 00 0f     .0.0.0.0.0.9....
     38c:	00 00 3c 00 7e 00 e7 30 c3 30 c3 30 c3 38 c3 1c     ..<.~..0.0.0.8..
     39c:	c3 0e e7 07 fe 03 fc 00 00 00 00 00 00 00 00 00     ................
     3ac:	70 1c 70 1c 70 1c 00 00 00 00 00 00 00 00 00 00     p.p.p...........
	...
     3c4:	70 9c 70 fc 70 7c 00 00 00 00 00 00 00 00 00 00     p.p.p|..........
     3d4:	00 00 00 00 c0 00 e0 01 f0 03 38 07 1c 0e 0e 1c     ..........8.....
     3e4:	07 38 03 30 00 00 00 00 00 00 00 00 60 06 60 06     .8.0........`.`.
     3f4:	60 06 60 06 60 06 60 06 60 06 60 06 60 06 00 00     `.`.`.`.`.`.`...
     404:	00 00 00 00 03 30 07 38 0e 1c 1c 0e 38 07 f0 03     .....0.8....8...
     414:	e0 01 c0 00 00 00 00 00 00 00 1c 00 1e 00 07 00     ................
     424:	03 00 83 37 c3 37 e3 00 77 00 3e 00 1c 00 00 00     ...7.7..w.>.....
     434:	00 00 f8 0f fe 1f 07 18 f3 33 fb 37 1b 36 fb 37     .........3.7.6.7
     444:	fb 37 07 36 fe 03 f8 01 00 00 00 38 00 3f e0 07     .7.6.......8.?..
     454:	fc 06 1f 06 1f 06 fc 06 e0 07 00 3f 00 38 00 00     ...........?.8..
     464:	00 00 ff 3f ff 3f c3 30 c3 30 c3 30 c3 30 e7 30     ...?.?.0.0.0.0.0
     474:	fe 39 bc 1f 00 0f 00 00 00 00 f0 03 fc 0f 0e 1c     .9..............
     484:	07 38 03 30 03 30 03 30 07 38 0e 1c 0c 0c 00 00     .8.0.0.0.8......
     494:	00 00 ff 3f ff 3f 03 30 03 30 03 30 03 30 07 38     ...?.?.0.0.0.0.8
     4a4:	0e 1c fc 0f f0 03 00 00 00 00 ff 3f ff 3f c3 30     ...........?.?.0
     4b4:	c3 30 c3 30 c3 30 c3 30 c3 30 03 30 03 30 00 00     .0.0.0.0.0.0.0..
     4c4:	00 00 ff 3f ff 3f c3 00 c3 00 c3 00 c3 00 c3 00     ...?.?..........
     4d4:	c3 00 03 00 03 00 00 00 00 00 f0 03 fc 0f 0e 1c     ................
     4e4:	07 38 03 30 c3 30 c3 30 c3 30 c7 3f c6 3f 00 00     .8.0.0.0.0.?.?..
     4f4:	00 00 ff 3f ff 3f c0 00 c0 00 c0 00 c0 00 c0 00     ...?.?..........
     504:	c0 00 ff 3f ff 3f 00 00 00 00 00 00 00 00 03 30     ...?.?.........0
     514:	03 30 ff 3f ff 3f 03 30 03 30 00 00 00 00 00 00     .0.?.?.0.0......
     524:	00 00 00 0e 00 1e 00 38 00 30 00 30 00 30 00 30     .......8.0.0.0.0
     534:	00 38 ff 1f ff 07 00 00 00 00 ff 3f ff 3f c0 00     .8.........?.?..
     544:	e0 01 f0 03 38 07 1c 0e 0e 1c 07 38 03 30 00 00     ....8......8.0..
     554:	00 00 ff 3f ff 3f 00 30 00 30 00 30 00 30 00 30     ...?.?.0.0.0.0.0
     564:	00 30 00 30 00 30 00 00 00 00 ff 3f ff 3f 1e 00     .0.0.0.....?.?..
     574:	78 00 e0 01 e0 01 78 00 1e 00 ff 3f ff 3f 00 00     x.....x....?.?..
     584:	00 00 ff 3f ff 3f 0e 00 38 00 f0 00 c0 03 00 07     ...?.?..8.......
     594:	00 1c ff 3f ff 3f 00 00 00 00 f0 03 fc 0f 0e 1c     ...?.?..........
     5a4:	07 38 03 30 03 30 07 38 0e 1c fc 0f f0 03 00 00     .8.0.0.8........
     5b4:	00 00 ff 3f ff 3f 83 01 83 01 83 01 83 01 83 01     ...?.?..........
     5c4:	c7 01 fe 00 7c 00 00 00 00 00 f0 03 fc 0f 0e 1c     ....|...........
     5d4:	07 38 03 30 03 36 07 3e 0e 1c fc 3f f0 33 00 00     .8.0.6.>...?.3..
     5e4:	00 00 ff 3f ff 3f 83 01 83 01 83 03 83 07 83 0f     ...?.?..........
     5f4:	c7 1d fe 38 7c 30 00 00 00 00 3c 0c 7e 1c e7 38     ...8|0....<.~..8
     604:	c3 30 c3 30 c3 30 c3 30 c7 39 8e 1f 0c 0f 00 00     .0.0.0.0.9......
     614:	00 00 00 00 03 00 03 00 03 00 ff 3f ff 3f 03 00     ...........?.?..
     624:	03 00 03 00 00 00 00 00 00 00 ff 07 ff 1f 00 38     ...............8
     634:	00 30 00 30 00 30 00 30 00 38 ff 1f ff 07 00 00     .0.0.0.0.8......
     644:	00 00 07 00 3f 00 f8 01 c0 0f 00 3e 00 3e c0 0f     ....?......>.>..
     654:	f8 01 3f 00 07 00 00 00 00 00 ff 3f ff 3f 00 1c     ..?........?.?..
     664:	00 06 80 03 80 03 00 06 00 1c ff 3f ff 3f 00 00     ...........?.?..
     674:	00 00 03 30 0f 3c 1c 0e 30 03 e0 01 e0 01 30 03     ...0.<..0.....0.
     684:	1c 0e 0f 3c 03 30 00 00 00 00 03 00 0f 00 3c 00     ...<.0........<.
     694:	f0 00 c0 3f c0 3f f0 00 3c 00 0f 00 03 00 00 00     ...?.?..<.......
     6a4:	00 00 03 30 03 3c 03 3e 03 33 c3 31 e3 30 33 30     ...0.<.>.3.1.030
     6b4:	1f 30 0f 30 03 30 00 00 00 00 00 00 00 00 ff 3f     .0.0.0.........?
     6c4:	ff 3f 03 30 03 30 03 30 03 30 00 00 00 00 00 00     .?.0.0.0.0......
     6d4:	00 00 0e 00 1c 00 38 00 70 00 e0 00 c0 01 80 03     ......8.p.......
     6e4:	00 07 00 0e 00 1c 00 18 00 00 00 00 00 00 03 30     ...............0
     6f4:	03 30 03 30 03 30 ff 3f ff 3f 00 00 00 00 00 00     .0.0.0.?.?......
     704:	00 00 60 00 70 00 38 00 1c 00 0e 00 07 00 0e 00     ..`.p.8.........
     714:	1c 00 38 00 70 00 60 00 00 00 00 c0 00 c0 00 c0     ..8.p.`.........
     724:	00 c0 00 c0 00 c0 00 c0 00 c0 00 c0 00 c0 00 c0     ................

00000734 <font6x8>:
     734:	06 08 5f 11                                         .._.

00000738 <_font6x8map>:
	...
     740:	06 5f 06 00 00 07 03 00 07 03 00 24 7e 24 7e 24     ._.........$~$~$
     750:	00 24 2b 6a 12 00 00 63 13 08 64 63 00 36 49 56     .$+j...c..dc.6IV
     760:	20 50 00 00 07 03 00 00 00 00 3e 41 00 00 00 00      P........>A....
     770:	41 3e 00 00 00 08 3e 1c 3e 08 00 08 08 3e 08 08     A>....>.>....>..
     780:	00 00 e0 60 00 00 00 08 08 08 08 08 00 00 60 60     ...`..........``
     790:	00 00 00 20 10 08 04 02 00 3e 51 49 45 3e 00 00     ... .....>QIE>..
     7a0:	42 7f 40 00 00 62 51 49 49 46 00 22 49 49 49 36     B.@..bQIIF."III6
     7b0:	00 18 14 12 7f 10 00 2f 49 49 49 31 00 3c 4a 49     ......./III1.<JI
     7c0:	49 30 00 01 71 09 05 03 00 36 49 49 49 36 00 06     I0..q....6III6..
     7d0:	49 49 29 1e 00 00 6c 6c 00 00 00 00 ec 6c 00 00     II)...ll.....l..
     7e0:	00 08 14 22 41 00 00 24 24 24 24 24 00 00 41 22     ..."A..$$$$$..A"
     7f0:	14 08 00 02 01 59 09 06 00 3e 41 5d 55 1e 00 7e     .....Y...>A]U..~
     800:	11 11 11 7e 00 7f 49 49 49 36 00 3e 41 41 41 22     ...~..III6.>AAA"
     810:	00 7f 41 41 41 3e 00 7f 49 49 49 41 00 7f 09 09     ..AAA>..IIIA....
     820:	09 01 00 3e 41 49 49 7a 00 7f 08 08 08 7f 00 00     ...>AIIz........
     830:	41 7f 41 00 00 30 40 40 40 3f 00 7f 08 14 22 41     A.A..0@@@?...."A
     840:	00 7f 40 40 40 40 00 7f 02 04 02 7f 00 7f 02 04     ..@@@@..........
     850:	08 7f 00 3e 41 41 41 3e 00 7f 09 09 09 06 00 3e     ...>AAA>.......>
     860:	41 51 21 5e 00 7f 09 09 19 66 00 26 49 49 49 32     AQ!^.....f.&III2
     870:	00 01 01 7f 01 01 00 3f 40 40 40 3f 00 1f 20 40     .......?@@@?.. @
     880:	20 1f 00 3f 40 3c 40 3f 00 63 14 08 14 63 00 07      ..?@<@?.c...c..
     890:	08 70 08 07 00 71 49 45 43 00 00 00 7f 41 41 00     .p...qIEC....AA.
     8a0:	00 02 04 08 10 20 00 00 41 41 7f 00 00 04 02 01     ..... ..AA......
     8b0:	02 04 80 80 80 80 80 80 00 00 03 07 00 00 00 20     ............... 
     8c0:	54 54 54 78 00 7f 44 44 44 38 00 38 44 44 44 28     TTTx..DDD8.8DDD(
     8d0:	00 38 44 44 44 7f 00 38 54 54 54 08 00 08 7e 09     .8DDD..8TTT...~.
     8e0:	09 00 00 18 a4 a4 a4 7c 00 7f 04 04 78 00 00 00     .......|....x...
     8f0:	00 7d 40 00 00 40 80 84 7d 00 00 7f 10 28 44 00     .}@..@..}....(D.
     900:	00 00 00 7f 40 00 00 7c 04 18 04 78 00 7c 04 04     ....@..|...x.|..
     910:	78 00 00 38 44 44 44 38 00 fc 44 44 44 38 00 38     x..8DDD8..DDD8.8
     920:	44 44 44 fc 00 44 78 44 04 08 00 08 54 54 54 20     DDD..DxD....TTT 
     930:	00 04 3e 44 24 00 00 3c 40 20 7c 00 00 1c 20 40     ..>D$..<@ |... @
     940:	20 1c 00 3c 60 30 60 3c 00 6c 10 10 6c 00 00 9c      ..<`0`<.l..l...
     950:	a0 60 3c 00 00 64 54 54 4c 00 00 08 3e 41 41 00     .`<..dTTL...>AA.
     960:	00 00 00 77 00 00 00 00 41 41 3e 08 00 02 01 02     ...w....AA>.....
     970:	01 00 00 3c 26 23 26 3c                             ...<&#&<

00000978 <fonts>:
     978:	34 07 30 01                                         4.0.

0000097c <glyArrowUp>:
     97c:	08 08 30 38 3c 3e 3e 3c 38 30                       ..08<>><80

00000986 <glyArrowDown>:
     986:	08 08 06 0e 1e 3e 3e 1e 0e 06                       .....>>...

00000990 <glyBall>:
     990:	09 09 38 00 fe 00 fe 00 ff 01 ff 01 ff 01 fe 00     ..8.............
     9a0:	fe 00 38 00                                         ..8.

000009a4 <glyDirCW>:
     9a4:	09 03 00 00 00 00 02 02 02 07 02                    ...........

000009af <glyDirCCW>:
     9af:	05 03 02 07 02 02 02                                .......

000009b6 <glyLogo>:
     9b6:	40 40 00 00 00 00 01 03 03 03 03 03 03 03 03 03     @@..............
     9c6:	03 03 03 03 03 03 07 0f 1f 1f 3f 3f 7f 7f 7f 7f     ..........??....
     9d6:	7f 3f 1f 0f 00 03 03 03 03 03 03 03 03 03 03 03     .?..............
     9e6:	03 03 03 03 03 07 07 07 07 07 07 07 03 03 01 00     ................
     9f6:	00 00 00 00 00 00 ff ff 00 00 00 00 00 00 00 00     ................
     a06:	00 01 1f 7f ff ff ff ff ff e7 c3 e7 ff ff ff ff     ................
     a16:	ff ff fe f0 00 00 00 00 00 00 00 00 00 07 0f 3f     ...............?
     a26:	7f ff ff ff fc fc ff ff ff ff ff ff ff ff 7c c3     ..............|.
     a36:	00 00 00 00 00 00 ff ff 00 00 00 00 00 00 00 00     ................
     a46:	00 00 f0 f8 fc fe fe fe fe fc fc fd fb f7 f7 ef     ................
     a56:	df 0b 00 00 00 00 00 00 00 01 03 03 ff ff ff ff     ................
     a66:	ff ff ff ff 7f 7f ff ff ff fe fc f8 e0 80 7f ff     ................
     a76:	00 00 00 00 00 00 ff ff 00 00 00 00 00 00 00 00     ................
	...
     a8e:	00 00 00 80 fd ff ff ff ff ff 7f 1f 3f 7f 7f fe     ............?...
     a9e:	fe fc f8 f8 f0 f0 e0 c0 c0 e0 c0 c0 c0 c0 80 80     ................
     aae:	00 00 00 00 00 00 ff ff 00 00 00 00 00 00 ff ff     ................
     abe:	00 00 01 01 03 03 07 07 07 0f 07 07 07 03 03 07     ................
     ace:	0f 0f 3f 7f ff ff fe fe ff ff ff ff ff af 03 00     ..?.............
	...
     af2:	00 00 ff ff 00 00 00 00 00 00 ff ff 3f 7f ff ff     ............?...
     b02:	fc f8 fc ff ff ff ff ff ff ff ff e8 c0 c0 80 80     ................
     b12:	00 00 00 00 80 f9 ff ff ff ff ff 7f 7f 7f 7f ff     ................
     b22:	7f 7f 7f 3f 1f 01 00 00 00 00 00 00 00 00 00 00     ...?............
     b32:	00 00 ff ff 00 00 00 00 00 fe ff ff ff ff ff ff     ................
     b42:	ff 7f ff ff ff ff fe fc f0 e0 00 00 00 00 00 00     ................
     b52:	00 00 01 1f 7f ff ff ff ff ff c7 c7 cf ff ff ff     ................
     b62:	ff ff ff fe f0 00 00 00 00 00 00 00 00 00 00 00     ................
     b72:	00 00 ff ff 00 00 00 00 00 00 f0 f8 d8 d8 f8 d8     ................
     b82:	d8 d8 d8 98 18 18 18 18 18 18 18 18 18 18 18 18     ................
     b92:	18 18 18 f8 f8 fc fc fc fe fc fc fc fc f8 f0 f0     ................
     ba2:	d8 d8 18 18 18 18 18 18 18 18 18 18 18 18 18 18     ................
     bb2:	18 18 f8 f0 00 00                                   ......

00000bb8 <scrESCCal>:
     bb8:	c4 0d 2e 0e                                         ....

00000bbc <lstMenu>:
     bbc:	62 0e 72 0e 80 0e 8e 0e 9c 0e ab 0e b7 0e c5 0e     b.r.............
     bcc:	d8 0e e8 0e f8 0e fe 0e                             ........

00000bd4 <strAreYouSure>:
     bd4:	41 72 65 20 79 6f 75 20 73 75 72 65 3f 00           Are you sure?.

00000be2 <_skMENUSAVE>:
     be2:	53 41 56 45 20 55 50 20 20 20 44 4f 57 4e 20 20     SAVE UP   DOWN  
     bf2:	45 4e 54 45 52 00                                   ENTER.

00000bf8 <__c.2234>:
     bf8:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
	...

00000c09 <_skEDIT>:
     c09:	43 41 4e 43 45 4c 20 20 44 4f 57 4e 20 20 20 55     CANCEL  DOWN   U
     c19:	50 20 20 4f 4b 00                                   P  OK.

00000c1f <__c.2224>:
     c1f:	41 43 43 2d 5a 20 64 61 6d 70 69 6e 67 00           ACC-Z damping.

00000c2d <__c.2222>:
     c2d:	41 43 43 20 58 20 26 20 59 20 20 20 20 00           ACC X & Y    .

00000c3b <__c.2210>:
     c3b:	54 72 69 6d 20 50 3a 20 20 20 20 52 3a 00           Trim P:    R:.

00000c49 <__c.2208>:
     c49:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
	...

00000c5a <__c.2203>:
     c5a:	52 00                                               R.

00000c5c <__c.2201>:
     c5c:	4e 00                                               N.

00000c5e <__c.2199>:
     c5e:	52 65 76 65 72 73 65 20 47 59 52 4f 00              Reverse GYRO.

00000c6b <__c.2197>:
     c6b:	59 41 57 20 20 20 20 20 20 20 20 20 00              YAW         .

00000c78 <__c.2195>:
     c78:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
	...

00000c89 <__c.2193>:
     c89:	50 69 74 63 68 20 26 20 52 6f 6c 6c 00              Pitch & Roll.

00000c96 <strYes>:
     c96:	59 65 73 00                                         Yes.

00000c9a <strNo>:
     c9a:	4e 6f 20 00                                         No .

00000c9e <__c.2173>:
     c9e:	41 20 54 72 69 20 00                                A Tri .

00000ca5 <__c.2171>:
     ca5:	59 20 54 72 69 20 00                                Y Tri .

00000cac <__c.2169>:
     cac:	58 20 51 75 61 64 00                                X Quad.

00000cb3 <__c.2167>:
     cb3:	2b 20 51 75 61 64 00                                + Quad.

00000cba <__c.2165>:
     cba:	58 20 51 75 61 64 00                                X Quad.

00000cc1 <__c.2163>:
     cc1:	2b 20 51 75 61 64 00                                + Quad.

00000cc8 <__c.2161>:
     cc8:	55 41 52 54 20 00                                   UART .

00000cce <__c.2159>:
     cce:	42 75 64 64 79 00                                   Buddy.

00000cd4 <__c.2157>:
     cd4:	54 52 49 20 00                                      TRI .

00000cd9 <__c.2155>:
     cd9:	51 75 61 64 00                                      Quad.

00000cde <_skBACK>:
     cde:	42 41 43 4b 20 20 20 20 20 20 20 20 20 20 20 20     BACK            
     cee:	20 20 20 20 20 00                                        .

00000cf4 <strSPC1>:
     cf4:	20 00                                                .

00000cf6 <strErr>:
     cf6:	45 72 72 00                                         Err.

00000cfa <strSPC4>:
     cfa:	20 20 20 20 00                                          .

00000cff <__c.2128>:
     cff:	4e 41 00                                            NA.

00000d02 <strARMED>:
     d02:	41 52 4d 45 44 00                                   ARMED.

00000d08 <strVersionInfo>:
     d08:	48 65 66 6e 79 43 6f 70 74 65 72 32 20 76 30 2e     HefnyCopter2 v0.
     d18:	39 2e 39 62 00                                      9.9b.

00000d1d <strOK>:
     d1d:	4f 4b 20 00                                         OK .

00000d21 <str1>:
     d21:	31 00                                               1.

00000d23 <strX>:
     d23:	58 00                                               X.

00000d25 <str2>:
     d25:	32 00                                               2.

00000d27 <__c.2099>:
     d27:	2b 00                                               +.

00000d29 <__c.2097>:
     d29:	58 00                                               X.

00000d2b <__c.2095>:
     d2b:	59 00                                               Y.

00000d2d <__c.2093>:
     d2d:	2b 00                                               +.

00000d2f <__c.2091>:
     d2f:	41 00                                               A.

00000d31 <__c.2089>:
     d31:	58 00                                               X.

00000d33 <__c.2087>:
     d33:	55 41 52 54 20 00                                   UART .

00000d39 <__c.2085>:
     d39:	42 75 64 64 79 00                                   Buddy.

00000d3f <__c.2083>:
     d3f:	54 52 49 20 00                                      TRI .

00000d44 <__c.2081>:
     d44:	51 75 61 64 00                                      Quad.

00000d49 <__c.2079>:
     d49:	41 4c 54 48 4c 44 00                                ALTHLD.

00000d50 <__c.2077>:
     d50:	53 54 41 42 4c 45 00                                STABLE.

00000d57 <__c.2075>:
     d57:	41 43 52 4f 20 20 00                                ACRO  .

00000d5e <pages>:
     d5e:	0c 0f 3e 2f 22 0f 56 0f b5 37 00 00 0c 0f 22 2f     ..>/".V..7...."/
     d6e:	6c 0f 70 0f 26 2c 86 0f 70 0f b0 2a bb 0f 56 0f     l.p.&,..p..*..V.
     d7e:	d3 33 d0 0f 56 0f d6 31 d0 0f 56 0f 2c 31 d0 0f     .3..V..1..V.,1..
     d8e:	56 0f 43 36 17 10 4e 10 c6 35 64 10 de 0c c0 2b     V.C6..N..5d....+
     d9e:	a2 10 de 0c 85 2e d8 10 08 11 86 2b a2 10 1e 11     ...........+....
     dae:	fd 2c d8 10 08 11 05 2f c4 0d de 0c d6 2a 00 00     .,...../.....*..
     dbe:	34 11 f0 2e 00 00                                   4.....

00000dc4 <scrESCCal0>:
     dc4:	2d 54 41 4b 45 20 4f 46 46 20 50 52 4f 50 45 4c     -TAKE OFF PROPEL
     dd4:	4c 45 52 53 21 21 0a 2d 50 72 65 73 73 20 63 6f     LERS!!.-Press co
     de4:	6e 74 69 6e 75 65 0a 2d 54 75 72 6e 20 4f 66 66     ntinue.-Turn Off
     df4:	20 51 75 61 64 63 6f 70 74 65 72 2e 0a 0a 2d 51      Quadcopter...-Q
     e04:	75 61 64 20 77 69 6c 6c 20 73 74 61 72 74 65 64     uad will started
     e14:	0a 69 6e 20 41 52 4d 45 44 20 54 41 4b 45 43 41     .in ARMED TAKECA
     e24:	52 45 20 73 74 61 74 65 0a 00                       RE state..

00000e2e <scrESCCal1>:
     e2e:	50 72 65 73 73 20 43 6f 6e 74 69 6e 75 65 20 61     Press Continue a
     e3e:	66 74 65 72 20 63 61 6c 69 62 72 61 74 69 6f 6e     fter calibration
     e4e:	2e 0a 0a 75 6e 70 6c 75 67 20 62 61 74 74 65 72     ...unplug batter
     e5e:	79 2e 0a 00                                         y...

00000e62 <strStabilization>:
     e62:	47 79 72 6f 20 50 49 44 20 45 64 69 74 6f 72 00     Gyro PID Editor.

00000e72 <strSelflevel>:
     e72:	53 65 6c 66 20 4c 65 76 65 6c 69 6e 67 00           Self Leveling.

00000e80 <strAltitudeHold>:
     e80:	41 6c 74 69 74 75 64 65 20 48 6f 6c 64 00           Altitude Hold.

00000e8e <strModeSettings>:
     e8e:	4d 6f 64 65 20 53 65 74 74 69 6e 67 73 00           Mode Settings.

00000e9c <strMiscSettings>:
     e9c:	4d 69 73 63 2e 20 53 65 74 74 69 6e 67 73 00        Misc. Settings.

00000eab <strSensorTest>:
     eab:	53 65 6e 73 6f 72 20 54 65 73 74 00                 Sensor Test.

00000eb7 <strReceiverTest>:
     eb7:	52 65 63 65 69 76 65 72 20 54 65 73 74 00           Receiver Test.

00000ec5 <strSensorCalibration>:
     ec5:	53 65 6e 73 6f 72 20 43 61 6c 69 62 72 61 74 69     Sensor Calibrati
     ed5:	6f 6e 00                                            on.

00000ed8 <strRadioCalibration>:
     ed8:	53 74 69 63 6b 20 43 65 6e 74 65 72 69 6e 67 00     Stick Centering.

00000ee8 <strESCCalibration>:
     ee8:	45 53 43 20 43 61 6c 69 62 72 61 74 69 6f 6e 00     ESC Calibration.

00000ef8 <strDebug>:
     ef8:	44 65 62 75 67 00                                   Debug.

00000efe <strFactoryReset>:
     efe:	46 61 63 74 6f 72 79 20 52 65 73 65 74 00           Factory Reset.

00000f0c <_skHOME>:
     f0c:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     f1c:	20 4d 45 4e 55 00                                    MENU.

00000f22 <scrHomePage>:
     f22:	0a 0a 42 61 74 74 3a 20 20 20 20 20 20 20 76 0a     ..Batt:       v.
     f32:	0a 0a 52 58 3a 20 2d 20 20 53 4e 3a 20 20 20 20     ..RX: -  SN:    
     f42:	53 54 3a 20 2d 0a 46 6c 79 3a 20 20 20 42 6f 61     ST: -.Fly:   Boa
     f52:	72 64 3a 00                                         rd:.

00000f56 <_skMENU>:
     f56:	42 41 43 4b 20 55 50 20 20 20 44 4f 57 4e 20 20     BACK UP   DOWN  
     f66:	45 4e 54 45 52 00                                   ENTER.

00000f6c <scrHomePageArmed>:
     f6c:	0a 0a 0a 00                                         ....

00000f70 <_skSAVE>:
     f70:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     f80:	20 44 4f 4e 45 00                                    DONE.

00000f86 <scrHomePageArmedESCCalibration>:
     f86:	0a 0a 0a 4d 31 3a 20 20 20 20 20 20 20 4d 34 3a     ...M1:       M4:
     f96:	0a 4d 32 3a 20 20 20 20 20 20 20 4d 33 3a 0a 45     .M2:       M3:.E
     fa6:	53 43 20 43 61 6c 69 62 72 61 74 69 6f 6e 20 6d     SC Calibration m
     fb6:	6f 64 65 0a 00                                      ode..

00000fbb <scrHomePageRestart>:
     fbb:	0a 52 45 53 54 41 52 54 0a 20 20 20 20 20 20 42     .RESTART.      B
     fcb:	4f 41 52 44 00                                      OARD.

00000fd0 <scrStabilization>:
     fd0:	0a 50 3a 20 20 20 20 20 20 20 4c 69 6d 3a 0a 49     .P:       Lim:.I
     fe0:	3a 20 20 20 20 20 20 20 4c 69 6d 3a 0a 44 3a 20     :       Lim:.D: 
     ff0:	20 20 20 20 20 20 4c 69 6d 3a 0a 4e 6f 69 73 65           Lim:.Noise
    1000:	20 46 69 6c 74 65 72 3a 0a 54 72 69 6d 20 50 3a      Filter:.Trim P:
    1010:	20 20 20 20 52 3a 00                                    R:.

00001017 <scrModeSettings>:
    1017:	46 72 61 6d 65 20 54 79 70 65 3a 0a 42 75 64 64     Frame Type:.Budd
    1027:	79 20 53 79 73 74 65 6d 3a 0a 42 6f 61 72 64 20     y System:.Board 
    1037:	44 69 72 3a 0a 46 6c 79 20 20 20 44 69 72 3a 0a     Dir:.Fly   Dir:.
    1047:	53 6f 6e 61 72 3a 00                                Sonar:.

0000104e <_skPAGE>:
    104e:	42 41 43 4b 20 50 52 45 56 20 4e 45 58 54 20 43     BACK PREV NEXT C
    105e:	48 41 4e 47 45 00                                   HANGE.

00001064 <scrMiscSettings>:
    1064:	41 75 74 6f 20 44 69 73 61 72 6d 3a 0a 56 6f 6c     Auto Disarm:.Vol
    1074:	74 20 41 6c 61 72 6d 3a 20 20 20 20 20 20 2f 31     t Alarm:      /1
    1084:	30 76 0a 54 68 72 6f 74 74 6c 65 20 6d 69 6e 3a     0v.Throttle min:
    1094:	0a 53 74 69 63 6b 20 53 63 61 6c 65 3a 00           .Stick Scale:.

000010a2 <scrSensorTest>:
    10a2:	47 79 72 6f 20 58 3a 0a 47 79 72 6f 20 59 3a 0a     Gyro X:.Gyro Y:.
    10b2:	47 79 72 6f 20 5a 3a 0a 41 63 63 20 20 58 3a 0a     Gyro Z:.Acc  X:.
    10c2:	41 63 63 20 20 59 3a 0a 41 63 63 20 20 5a 3a 0a     Acc  Y:.Acc  Z:.
    10d2:	42 61 74 74 3a 00                                   Batt:.

000010d8 <scrReceiverTest>:
    10d8:	20 43 48 20 20 20 52 58 2d 31 20 20 20 20 52 58      CH   RX-1    RX
    10e8:	2d 32 0a 41 69 6c 3a 0a 45 6c 65 3a 0a 52 75 64     -2.Ail:.Ele:.Rud
    10f8:	3a 0a 54 68 72 3a 0a 41 75 78 3a 0a 52 58 3a 00     :.Thr:.Aux:.RX:.

00001108 <_skCONTINUE>:
    1108:	42 41 43 4b 20 20 20 20 20 20 20 20 20 43 4f 4e     BACK         CON
    1118:	54 49 4e 55 45 00                                   TINUE.

0000111e <_skCLRDONE>:
    111e:	42 41 43 4b 20 43 4c 52 20 20 20 20 20 20 20 20     BACK CLR        
    112e:	20 44 4f 4e 45 00                                    DONE.

00001134 <_skCANCELYES>:
    1134:	4e 4f 20 20 20 20 20 20 20 20 20 20 20 20 20 20     NO              
    1144:	20 20 59 45 53 00 00 40 7a 10 f3 5a 00 a0 72 4e       YES..@z..Z..rN
    1154:	18 09 00 10 a5 d4 e8 00 00 e8 76 48 17 00 00 e4     ..........vH....
    1164:	0b 54 02 00 00 ca 9a 3b 00 00 00 e1 f5 05 00 00     .T.....;........
    1174:	80 96 98 00 00 00 40 42 0f 00 00 00 a0 86 01 00     ......@B........
    1184:	00 00 10 27 00 00 00 00 e8 03 00 00 00 00 64 00     ...'..........d.
    1194:	00 00 00 00 0a 00 00 00 00 00 01 00 00 00 00 00     ................
    11a4:	2c 76 d8 88 dc 67 4f 08 23 df c1 df ae 59 e1 b1     ,v...gO.#....Y..
    11b4:	b7 96 e5 e3 e4 53 c6 3a e6 51 99 76 96 e8 e6 c2     .....S.:.Q.v....
    11c4:	84 26 eb 89 8c 9b 62 ed 40 7c 6f fc ef bc 9c 9f     .&....b.@|o.....
    11d4:	40 f2 ba a5 6f a5 f4 90 05 5a 2a f7 5c 93 6b 6c     @...o....Z*.\.kl
    11e4:	f9 67 6d c1 1b fc e0 e4 0d 47 fe f5 20 e6 b5 00     .gm......G.. ...
    11f4:	d0 ed 90 2e 03 00 94 35 77 05 00 80 84 1e 08 00     .......5w.......
    1204:	00 20 4e 0a 00 00 00 c8 0c 33 33 33 33 0f 98 6e     . N......3333..n
    1214:	12 83 11 41 ef 8d 21 14 89 3b e6 55 16 cf fe e6     ...A..!..;.U....
    1224:	db 18 d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb e4 24     ....K8..|......$
    1234:	20 32 84 72 5e 22 81 00 c9 f1 24 ec a1 e5 3d 27      2.r^"....$...='

00001244 <__vector_18>:
	sendData(column & 0x0f, LCD_COMMAND);
}

__attribute__ ((section(".lowtext")))
ISR(TIMER0_OVF_vect, ISR_NOBLOCK)
{
    1244:	78 94       	sei
    1246:	1f 92       	push	r1
    1248:	0f 92       	push	r0
    124a:	0f b6       	in	r0, 0x3f	; 63
    124c:	0f 92       	push	r0
    124e:	11 24       	eor	r1, r1
    1250:	2f 93       	push	r18
    1252:	3f 93       	push	r19
    1254:	4f 93       	push	r20
    1256:	5f 93       	push	r21
    1258:	6f 93       	push	r22
    125a:	7f 93       	push	r23
    125c:	8f 93       	push	r24
    125e:	9f 93       	push	r25
    1260:	af 93       	push	r26
    1262:	bf 93       	push	r27
    1264:	cf 93       	push	r28
    1266:	df 93       	push	r29
    1268:	ef 93       	push	r30
    126a:	ff 93       	push	r31
	TCNT0_X +=1;
    126c:	80 91 ba 05 	lds	r24, 0x05BA
    1270:	90 91 bb 05 	lds	r25, 0x05BB
    1274:	01 96       	adiw	r24, 0x01	; 1
    1276:	90 93 bb 05 	sts	0x05BB, r25
    127a:	80 93 ba 05 	sts	0x05BA, r24
	static uint16_t offset;
	
	if (offset % LCDWIDTH == 0)
    127e:	c0 91 1d 05 	lds	r28, 0x051D
    1282:	d0 91 1e 05 	lds	r29, 0x051E
    1286:	ce 01       	movw	r24, r28
    1288:	8f 77       	andi	r24, 0x7F	; 127
    128a:	90 70       	andi	r25, 0x00	; 0
    128c:	00 97       	sbiw	r24, 0x00	; 0
    128e:	99 f4       	brne	.+38     	; 0x12b6 <__vector_18+0x72>
		setPos(offset / LCDWIDTH, 0);
    1290:	ce 01       	movw	r24, r28
    1292:	88 0f       	add	r24, r24
    1294:	89 2f       	mov	r24, r25
    1296:	88 1f       	adc	r24, r24
    1298:	99 0b       	sbc	r25, r25
    129a:	91 95       	neg	r25
	LCD_CS = 1;
}

static void setPos(uint8_t line, uint8_t column)
{
	sendData(0xB0 | (line & 0x07), LCD_COMMAND);
    129c:	87 70       	andi	r24, 0x07	; 7
    129e:	80 6b       	ori	r24, 0xB0	; 176
    12a0:	60 e0       	ldi	r22, 0x00	; 0
    12a2:	0e 94 d1 0b 	call	0x17a2	; 0x17a2 <sendData>
	sendData(0x10 | (column >> 4), LCD_COMMAND);
    12a6:	80 e1       	ldi	r24, 0x10	; 16
    12a8:	60 e0       	ldi	r22, 0x00	; 0
    12aa:	0e 94 d1 0b 	call	0x17a2	; 0x17a2 <sendData>
	sendData(column & 0x0f, LCD_COMMAND);
    12ae:	80 e0       	ldi	r24, 0x00	; 0
    12b0:	60 e0       	ldi	r22, 0x00	; 0
    12b2:	0e 94 d1 0b 	call	0x17a2	; 0x17a2 <sendData>
	static uint16_t offset;
	
	if (offset % LCDWIDTH == 0)
		setPos(offset / LCDWIDTH, 0);
		
	sendData(*(_screen + offset++), LCD_DATA);
    12b6:	fe 01       	movw	r30, r28
    12b8:	e3 5e       	subi	r30, 0xE3	; 227
    12ba:	fe 4f       	sbci	r31, 0xFE	; 254
    12bc:	80 81       	ld	r24, Z
    12be:	61 e0       	ldi	r22, 0x01	; 1
    12c0:	0e 94 d1 0b 	call	0x17a2	; 0x17a2 <sendData>
    12c4:	21 96       	adiw	r28, 0x01	; 1
	offset %= sizeof(_screen);
    12c6:	d3 70       	andi	r29, 0x03	; 3
    12c8:	d0 93 1e 05 	sts	0x051E, r29
    12cc:	c0 93 1d 05 	sts	0x051D, r28
}
    12d0:	ff 91       	pop	r31
    12d2:	ef 91       	pop	r30
    12d4:	df 91       	pop	r29
    12d6:	cf 91       	pop	r28
    12d8:	bf 91       	pop	r27
    12da:	af 91       	pop	r26
    12dc:	9f 91       	pop	r25
    12de:	8f 91       	pop	r24
    12e0:	7f 91       	pop	r23
    12e2:	6f 91       	pop	r22
    12e4:	5f 91       	pop	r21
    12e6:	4f 91       	pop	r20
    12e8:	3f 91       	pop	r19
    12ea:	2f 91       	pop	r18
    12ec:	0f 90       	pop	r0
    12ee:	0f be       	out	0x3f, r0	; 63
    12f0:	0f 90       	pop	r0
    12f2:	1f 90       	pop	r1
    12f4:	18 95       	reti

000012f6 <__vector_6>:
 
 uint8_t OldPortCValue;

__attribute__ ((section(".lowtext")))
ISR (RX2_ALL_vect)
{
    12f6:	1f 92       	push	r1
    12f8:	0f 92       	push	r0
    12fa:	0f b6       	in	r0, 0x3f	; 63
    12fc:	0f 92       	push	r0
    12fe:	11 24       	eor	r1, r1
    1300:	0f 93       	push	r16
    1302:	1f 93       	push	r17
    1304:	2f 93       	push	r18
    1306:	3f 93       	push	r19
    1308:	4f 93       	push	r20
    130a:	5f 93       	push	r21
    130c:	6f 93       	push	r22
    130e:	7f 93       	push	r23
    1310:	8f 93       	push	r24
    1312:	9f 93       	push	r25
    1314:	af 93       	push	r26
    1316:	bf 93       	push	r27
    1318:	cf 93       	push	r28
    131a:	df 93       	push	r29
    131c:	ef 93       	push	r30
    131e:	ff 93       	push	r31
	uint8_t Changes = PINC ^ OldPortCValue;  // capture changed bit
    1320:	16 b1       	in	r17, 0x06	; 6
    1322:	80 91 dc 07 	lds	r24, 0x07DC
    1326:	18 27       	eor	r17, r24
	OldPortCValue = PINC;
    1328:	86 b1       	in	r24, 0x06	; 6
    132a:	80 93 dc 07 	sts	0x07DC, r24
	uint16_t TCNT1_TEMP = TCNT1;
    132e:	c0 91 84 00 	lds	r28, 0x0084
    1332:	d0 91 85 00 	lds	r29, 0x0085
	// if there is a signal change in ROLL
	if ((Changes & RX2_ROLL_PIN)!=0)
    1336:	01 2f       	mov	r16, r17
    1338:	15 ff       	sbrs	r17, 5
    133a:	18 c0       	rjmp	.+48     	; 0x136c <__vector_6+0x76>
	{
		if (RX2_ROLL)
    133c:	86 b1       	in	r24, 0x06	; 6
    133e:	85 ff       	sbrs	r24, 5
    1340:	05 c0       	rjmp	.+10     	; 0x134c <__vector_6+0x56>
		{
			RX_raw[1][RXChannel_AIL]=TCNT1_TEMP;
    1342:	d0 93 ea 07 	sts	0x07EA, r29
    1346:	c0 93 e9 07 	sts	0x07E9, r28
    134a:	10 c0       	rjmp	.+32     	; 0x136c <__vector_6+0x76>
		}
		else
		{
			CalculateSignalLength2 (RXChannel_AIL);
    134c:	80 e0       	ldi	r24, 0x00	; 0
    134e:	0e 94 1b 26 	call	0x4c36	; 0x4c36 <CalculateSignalLength2>
			
			RX2_LastValidSignal_timestampAux = TCNT1_X;
    1352:	80 91 5e 06 	lds	r24, 0x065E
    1356:	90 91 5f 06 	lds	r25, 0x065F
    135a:	90 93 d1 07 	sts	0x07D1, r25
    135e:	80 93 d0 07 	sts	0x07D0, r24
			RX_Good = TX2_FOUND_ERR;  // CLR bit 6 ---  Status = OK
    1362:	80 91 b8 07 	lds	r24, 0x07B8
    1366:	8f 71       	andi	r24, 0x1F	; 31
    1368:	80 93 b8 07 	sts	0x07B8, r24
		}	
	}
	// if there is a signal change in PITCH
	if ((Changes & RX2_PITCH_PIN)!=0)
    136c:	00 ff       	sbrs	r16, 0
    136e:	0b c0       	rjmp	.+22     	; 0x1386 <__vector_6+0x90>
	{
		if (RX2_PITCH)
    1370:	86 b1       	in	r24, 0x06	; 6
    1372:	80 ff       	sbrs	r24, 0
    1374:	05 c0       	rjmp	.+10     	; 0x1380 <__vector_6+0x8a>
		{
			RX_raw[1][RXChannel_ELE]=TCNT1_TEMP;
    1376:	d0 93 ec 07 	sts	0x07EC, r29
    137a:	c0 93 eb 07 	sts	0x07EB, r28
    137e:	03 c0       	rjmp	.+6      	; 0x1386 <__vector_6+0x90>
		}
		else
		{
			CalculateSignalLength2 (RXChannel_ELE);
    1380:	81 e0       	ldi	r24, 0x01	; 1
    1382:	0e 94 1b 26 	call	0x4c36	; 0x4c36 <CalculateSignalLength2>
		}	
	}
	// if there is a signal change in THR
	if ((Changes & RX2_COLL_PIN)!=0)
    1386:	17 ff       	sbrs	r17, 7
    1388:	2d c0       	rjmp	.+90     	; 0x13e4 <__vector_6+0xee>
    138a:	80 91 d7 06 	lds	r24, 0x06D7
	{
		if (RX2_COLL)
    138e:	37 9b       	sbis	0x06, 7	; 6
    1390:	0b c0       	rjmp	.+22     	; 0x13a8 <__vector_6+0xb2>
		{
			RX_raw[1][RXChannel_THR]=TCNT1_TEMP;
    1392:	d0 93 f0 07 	sts	0x07F0, r29
    1396:	c0 93 ef 07 	sts	0x07EF, r28
			
			if (Config.IsESCCalibration==ESCCalibration_ON)
    139a:	81 30       	cpi	r24, 0x01	; 1
    139c:	19 f5       	brne	.+70     	; 0x13e4 <__vector_6+0xee>
			{ 
				M1=1;M2=1;M3=1;M4=1;
    139e:	46 9a       	sbi	0x08, 6	; 8
    13a0:	44 9a       	sbi	0x08, 4	; 8
    13a2:	42 9a       	sbi	0x08, 2	; 8
    13a4:	43 9a       	sbi	0x08, 3	; 8
    13a6:	1e c0       	rjmp	.+60     	; 0x13e4 <__vector_6+0xee>
			}
		}
		else
		{
			if ((Config.IsESCCalibration==ESCCalibration_ON) && (IS_TX2_GOOD) && (!IS_SYS_ACT_DISARM))
    13a8:	81 30       	cpi	r24, 0x01	; 1
    13aa:	61 f4       	brne	.+24     	; 0x13c4 <__vector_6+0xce>
    13ac:	80 91 b8 07 	lds	r24, 0x07B8
    13b0:	80 7f       	andi	r24, 0xF0	; 240
    13b2:	41 f4       	brne	.+16     	; 0x13c4 <__vector_6+0xce>
    13b4:	80 91 4f 05 	lds	r24, 0x054F
    13b8:	81 fd       	sbrc	r24, 1
    13ba:	04 c0       	rjmp	.+8      	; 0x13c4 <__vector_6+0xce>
			{
				M1=0;M2=0;M3=0;M4=0;
    13bc:	46 98       	cbi	0x08, 6	; 8
    13be:	44 98       	cbi	0x08, 4	; 8
    13c0:	42 98       	cbi	0x08, 2	; 8
    13c2:	43 98       	cbi	0x08, 3	; 8
			}
				
			CalculateSignalLength2 (RXChannel_THR);
    13c4:	83 e0       	ldi	r24, 0x03	; 3
    13c6:	0e 94 1b 26 	call	0x4c36	; 0x4c36 <CalculateSignalLength2>
			RX2_LastValidSignal_timestamp = TCNT1_X;
    13ca:	80 91 5e 06 	lds	r24, 0x065E
    13ce:	90 91 5f 06 	lds	r25, 0x065F
    13d2:	90 93 d5 07 	sts	0x07D5, r25
    13d6:	80 93 d4 07 	sts	0x07D4, r24
			RX_Good = TX2_CONNECTED_ERR;  // CLR bit 5 ---  Status = OK
    13da:	80 91 b8 07 	lds	r24, 0x07B8
    13de:	8f 72       	andi	r24, 0x2F	; 47
    13e0:	80 93 b8 07 	sts	0x07B8, r24
		}	
	}
	// if there is a signal change in YAW
	if ((Changes & RX2_YAW_PIN) !=0)
    13e4:	01 ff       	sbrs	r16, 1
    13e6:	0b c0       	rjmp	.+22     	; 0x13fe <__vector_6+0x108>
	{
		if (RX2_YAW)
    13e8:	86 b1       	in	r24, 0x06	; 6
    13ea:	81 ff       	sbrs	r24, 1
    13ec:	05 c0       	rjmp	.+10     	; 0x13f8 <__vector_6+0x102>
		{
			RX_raw[1][RXChannel_RUD]=TCNT1_TEMP;
    13ee:	d0 93 ee 07 	sts	0x07EE, r29
    13f2:	c0 93 ed 07 	sts	0x07ED, r28
    13f6:	03 c0       	rjmp	.+6      	; 0x13fe <__vector_6+0x108>
		}
		else
		{
			CalculateSignalLength2 (RXChannel_RUD);
    13f8:	82 e0       	ldi	r24, 0x02	; 2
    13fa:	0e 94 1b 26 	call	0x4c36	; 0x4c36 <CalculateSignalLength2>
			
		}	
	}
	
}
    13fe:	ff 91       	pop	r31
    1400:	ef 91       	pop	r30
    1402:	df 91       	pop	r29
    1404:	cf 91       	pop	r28
    1406:	bf 91       	pop	r27
    1408:	af 91       	pop	r26
    140a:	9f 91       	pop	r25
    140c:	8f 91       	pop	r24
    140e:	7f 91       	pop	r23
    1410:	6f 91       	pop	r22
    1412:	5f 91       	pop	r21
    1414:	4f 91       	pop	r20
    1416:	3f 91       	pop	r19
    1418:	2f 91       	pop	r18
    141a:	1f 91       	pop	r17
    141c:	0f 91       	pop	r16
    141e:	0f 90       	pop	r0
    1420:	0f be       	out	0x3f, r0	; 63
    1422:	0f 90       	pop	r0
    1424:	1f 90       	pop	r1
    1426:	18 95       	reti

00001428 <__vector_2>:

#ifdef PRIMARY_INPUT_RX

__attribute__ ((section(".lowtext")))
ISR (RX1_COLL_vect)
{
    1428:	1f 92       	push	r1
    142a:	0f 92       	push	r0
    142c:	0f b6       	in	r0, 0x3f	; 63
    142e:	0f 92       	push	r0
    1430:	11 24       	eor	r1, r1
    1432:	2f 93       	push	r18
    1434:	3f 93       	push	r19
    1436:	4f 93       	push	r20
    1438:	5f 93       	push	r21
    143a:	6f 93       	push	r22
    143c:	7f 93       	push	r23
    143e:	8f 93       	push	r24
    1440:	9f 93       	push	r25
    1442:	af 93       	push	r26
    1444:	bf 93       	push	r27
    1446:	ef 93       	push	r30
    1448:	ff 93       	push	r31
	if (RX1_COLL)
    144a:	89 b1       	in	r24, 0x09	; 9
    144c:	83 ff       	sbrs	r24, 3
    144e:	09 c0       	rjmp	.+18     	; 0x1462 <__vector_2+0x3a>
	{
		RX_raw[0][RXChannel_THR]=TCNT1;
    1450:	80 91 84 00 	lds	r24, 0x0084
    1454:	90 91 85 00 	lds	r25, 0x0085
    1458:	90 93 e6 07 	sts	0x07E6, r25
    145c:	80 93 e5 07 	sts	0x07E5, r24
    1460:	10 c0       	rjmp	.+32     	; 0x1482 <__vector_2+0x5a>

	}
	else
	{
		CalculateSignalLength1(RXChannel_THR);
    1462:	83 e0       	ldi	r24, 0x03	; 3
    1464:	0e 94 f2 25 	call	0x4be4	; 0x4be4 <CalculateSignalLength1>
		
		RX1_LastValidSignal_timestamp = TCNT1_X;
    1468:	80 91 5e 06 	lds	r24, 0x065E
    146c:	90 91 5f 06 	lds	r25, 0x065F
    1470:	90 93 d7 07 	sts	0x07D7, r25
    1474:	80 93 d6 07 	sts	0x07D6, r24
		RX_Good = TX1_CONNECTED_ERR;		// CLR bit 0 ---  Status = OK
    1478:	80 91 b8 07 	lds	r24, 0x07B8
    147c:	82 7f       	andi	r24, 0xF2	; 242
    147e:	80 93 b8 07 	sts	0x07B8, r24
	}
	
}
    1482:	ff 91       	pop	r31
    1484:	ef 91       	pop	r30
    1486:	bf 91       	pop	r27
    1488:	af 91       	pop	r26
    148a:	9f 91       	pop	r25
    148c:	8f 91       	pop	r24
    148e:	7f 91       	pop	r23
    1490:	6f 91       	pop	r22
    1492:	5f 91       	pop	r21
    1494:	4f 91       	pop	r20
    1496:	3f 91       	pop	r19
    1498:	2f 91       	pop	r18
    149a:	0f 90       	pop	r0
    149c:	0f be       	out	0x3f, r0	; 63
    149e:	0f 90       	pop	r0
    14a0:	1f 90       	pop	r1
    14a2:	18 95       	reti

000014a4 <__vector_1>:



__attribute__ ((section(".lowtext")))
ISR (RX1_ROLL_vect)
{
    14a4:	1f 92       	push	r1
    14a6:	0f 92       	push	r0
    14a8:	0f b6       	in	r0, 0x3f	; 63
    14aa:	0f 92       	push	r0
    14ac:	11 24       	eor	r1, r1
    14ae:	2f 93       	push	r18
    14b0:	3f 93       	push	r19
    14b2:	4f 93       	push	r20
    14b4:	5f 93       	push	r21
    14b6:	6f 93       	push	r22
    14b8:	7f 93       	push	r23
    14ba:	8f 93       	push	r24
    14bc:	9f 93       	push	r25
    14be:	af 93       	push	r26
    14c0:	bf 93       	push	r27
    14c2:	ef 93       	push	r30
    14c4:	ff 93       	push	r31
	if (RX1_ROLL)
    14c6:	89 b1       	in	r24, 0x09	; 9
    14c8:	82 ff       	sbrs	r24, 2
    14ca:	09 c0       	rjmp	.+18     	; 0x14de <__vector_1+0x3a>
	{
		RX_raw[0][RXChannel_AIL]=TCNT1;
    14cc:	80 91 84 00 	lds	r24, 0x0084
    14d0:	90 91 85 00 	lds	r25, 0x0085
    14d4:	90 93 e0 07 	sts	0x07E0, r25
    14d8:	80 93 df 07 	sts	0x07DF, r24
    14dc:	10 c0       	rjmp	.+32     	; 0x14fe <__vector_1+0x5a>
	}
	else
	{
		CalculateSignalLength1(RXChannel_AIL);
    14de:	80 e0       	ldi	r24, 0x00	; 0
    14e0:	0e 94 f2 25 	call	0x4be4	; 0x4be4 <CalculateSignalLength1>
		
		RX1_LastValidSignal_timestampAux = TCNT1_X;
    14e4:	80 91 5e 06 	lds	r24, 0x065E
    14e8:	90 91 5f 06 	lds	r25, 0x065F
    14ec:	90 93 d9 07 	sts	0x07D9, r25
    14f0:	80 93 d8 07 	sts	0x07D8, r24
		RX_Good = TX1_FOUND_ERR;			// CLR bit 1 ---  Status = OK
    14f4:	80 91 b8 07 	lds	r24, 0x07B8
    14f8:	81 7f       	andi	r24, 0xF1	; 241
    14fa:	80 93 b8 07 	sts	0x07B8, r24

		
	}
	
}
    14fe:	ff 91       	pop	r31
    1500:	ef 91       	pop	r30
    1502:	bf 91       	pop	r27
    1504:	af 91       	pop	r26
    1506:	9f 91       	pop	r25
    1508:	8f 91       	pop	r24
    150a:	7f 91       	pop	r23
    150c:	6f 91       	pop	r22
    150e:	5f 91       	pop	r21
    1510:	4f 91       	pop	r20
    1512:	3f 91       	pop	r19
    1514:	2f 91       	pop	r18
    1516:	0f 90       	pop	r0
    1518:	0f be       	out	0x3f, r0	; 63
    151a:	0f 90       	pop	r0
    151c:	1f 90       	pop	r1
    151e:	18 95       	reti

00001520 <__vector_7>:


__attribute__ ((section(".lowtext")))
ISR (RX1_PITCH_vect)
{
    1520:	1f 92       	push	r1
    1522:	0f 92       	push	r0
    1524:	0f b6       	in	r0, 0x3f	; 63
    1526:	0f 92       	push	r0
    1528:	11 24       	eor	r1, r1
    152a:	2f 93       	push	r18
    152c:	3f 93       	push	r19
    152e:	4f 93       	push	r20
    1530:	5f 93       	push	r21
    1532:	6f 93       	push	r22
    1534:	7f 93       	push	r23
    1536:	8f 93       	push	r24
    1538:	9f 93       	push	r25
    153a:	af 93       	push	r26
    153c:	bf 93       	push	r27
    153e:	ef 93       	push	r30
    1540:	ff 93       	push	r31
	if (RX1_PITCH)
    1542:	89 b1       	in	r24, 0x09	; 9
    1544:	80 ff       	sbrs	r24, 0
    1546:	09 c0       	rjmp	.+18     	; 0x155a <__vector_7+0x3a>
	{
		RX_raw[0][RXChannel_ELE]=TCNT1;
    1548:	80 91 84 00 	lds	r24, 0x0084
    154c:	90 91 85 00 	lds	r25, 0x0085
    1550:	90 93 e2 07 	sts	0x07E2, r25
    1554:	80 93 e1 07 	sts	0x07E1, r24
    1558:	03 c0       	rjmp	.+6      	; 0x1560 <__vector_7+0x40>
	}
	else
	{
		CalculateSignalLength1(RXChannel_ELE);
    155a:	81 e0       	ldi	r24, 0x01	; 1
    155c:	0e 94 f2 25 	call	0x4be4	; 0x4be4 <CalculateSignalLength1>
	}
}
    1560:	ff 91       	pop	r31
    1562:	ef 91       	pop	r30
    1564:	bf 91       	pop	r27
    1566:	af 91       	pop	r26
    1568:	9f 91       	pop	r25
    156a:	8f 91       	pop	r24
    156c:	7f 91       	pop	r23
    156e:	6f 91       	pop	r22
    1570:	5f 91       	pop	r21
    1572:	4f 91       	pop	r20
    1574:	3f 91       	pop	r19
    1576:	2f 91       	pop	r18
    1578:	0f 90       	pop	r0
    157a:	0f be       	out	0x3f, r0	; 63
    157c:	0f 90       	pop	r0
    157e:	1f 90       	pop	r1
    1580:	18 95       	reti

00001582 <__vector_3>:

volatile uint16_t LongTime;
volatile uint16_t ShortTime;
__attribute__ ((section(".lowtext")))
ISR (RX1_YAW_vect)
{   
    1582:	1f 92       	push	r1
    1584:	0f 92       	push	r0
    1586:	0f b6       	in	r0, 0x3f	; 63
    1588:	0f 92       	push	r0
    158a:	11 24       	eor	r1, r1
    158c:	2f 93       	push	r18
    158e:	3f 93       	push	r19
    1590:	4f 93       	push	r20
    1592:	5f 93       	push	r21
    1594:	6f 93       	push	r22
    1596:	7f 93       	push	r23
    1598:	8f 93       	push	r24
    159a:	9f 93       	push	r25
    159c:	af 93       	push	r26
    159e:	bf 93       	push	r27
    15a0:	ef 93       	push	r30
    15a2:	ff 93       	push	r31
	// SONAR IS HERE IN UART MODE
	// SONAR RAW VALUE = RX_Length[0][RXChannel_RUD]
	if ((Config.RX_mode==RX_mode_UARTMode) && (IS_MISC_SENSOR_SONAR_ENABLED==true))
    15a4:	80 91 d3 06 	lds	r24, 0x06D3
    15a8:	8f 3f       	cpi	r24, 0xFF	; 255
    15aa:	f9 f4       	brne	.+62     	; 0x15ea <__vector_3+0x68>
    15ac:	80 91 de 06 	lds	r24, 0x06DE
    15b0:	80 ff       	sbrs	r24, 0
    15b2:	1b c0       	rjmp	.+54     	; 0x15ea <__vector_3+0x68>
	{
		if (RX1_YAW)
    15b4:	83 b1       	in	r24, 0x03	; 3
    15b6:	82 ff       	sbrs	r24, 2
    15b8:	09 c0       	rjmp	.+18     	; 0x15cc <__vector_3+0x4a>
		{
			//ShortTime = TCNT1;
			LongTime = TCNT0_X;
    15ba:	80 91 ba 05 	lds	r24, 0x05BA
    15be:	90 91 bb 05 	lds	r25, 0x05BB
    15c2:	90 93 de 07 	sts	0x07DE, r25
    15c6:	80 93 dd 07 	sts	0x07DD, r24
    15ca:	1e c0       	rjmp	.+60     	; 0x1608 <__vector_3+0x86>
		}
		else
		{
			RX_Length[0][RXChannel_RUD] = (TCNT0_X - LongTime) ; // * SONAR_TO_cm_Convert_BIG + (TCNT1 - ShortTime) * SONAR_TO_cm_Convert;
    15cc:	80 91 ba 05 	lds	r24, 0x05BA
    15d0:	90 91 bb 05 	lds	r25, 0x05BB
    15d4:	20 91 dd 07 	lds	r18, 0x07DD
    15d8:	30 91 de 07 	lds	r19, 0x07DE
    15dc:	82 1b       	sub	r24, r18
    15de:	93 0b       	sbc	r25, r19
    15e0:	90 93 d3 05 	sts	0x05D3, r25
    15e4:	80 93 d2 05 	sts	0x05D2, r24
    15e8:	0f c0       	rjmp	.+30     	; 0x1608 <__vector_3+0x86>

	}
	else
	{
		
		if (RX1_YAW)
    15ea:	83 b1       	in	r24, 0x03	; 3
    15ec:	82 ff       	sbrs	r24, 2
    15ee:	09 c0       	rjmp	.+18     	; 0x1602 <__vector_3+0x80>
		{
			RX_raw[0][RXChannel_RUD]=TCNT1;
    15f0:	80 91 84 00 	lds	r24, 0x0084
    15f4:	90 91 85 00 	lds	r25, 0x0085
    15f8:	90 93 e4 07 	sts	0x07E4, r25
    15fc:	80 93 e3 07 	sts	0x07E3, r24
    1600:	03 c0       	rjmp	.+6      	; 0x1608 <__vector_3+0x86>
		}
		else
		{
			CalculateSignalLength1(RXChannel_RUD);
    1602:	82 e0       	ldi	r24, 0x02	; 2
    1604:	0e 94 f2 25 	call	0x4be4	; 0x4be4 <CalculateSignalLength1>
		}
	}	
}
    1608:	ff 91       	pop	r31
    160a:	ef 91       	pop	r30
    160c:	bf 91       	pop	r27
    160e:	af 91       	pop	r26
    1610:	9f 91       	pop	r25
    1612:	8f 91       	pop	r24
    1614:	7f 91       	pop	r23
    1616:	6f 91       	pop	r22
    1618:	5f 91       	pop	r21
    161a:	4f 91       	pop	r20
    161c:	3f 91       	pop	r19
    161e:	2f 91       	pop	r18
    1620:	0f 90       	pop	r0
    1622:	0f be       	out	0x3f, r0	; 63
    1624:	0f 90       	pop	r0
    1626:	1f 90       	pop	r1
    1628:	18 95       	reti

0000162a <__vector_5>:



__attribute__ ((section(".lowtext")))
ISR (RX_AUX_vect)
{
    162a:	1f 92       	push	r1
    162c:	0f 92       	push	r0
    162e:	0f b6       	in	r0, 0x3f	; 63
    1630:	0f 92       	push	r0
    1632:	11 24       	eor	r1, r1
    1634:	2f 93       	push	r18
    1636:	3f 93       	push	r19
    1638:	4f 93       	push	r20
    163a:	5f 93       	push	r21
    163c:	6f 93       	push	r22
    163e:	7f 93       	push	r23
    1640:	8f 93       	push	r24
    1642:	9f 93       	push	r25
    1644:	af 93       	push	r26
    1646:	bf 93       	push	r27
    1648:	ef 93       	push	r30
    164a:	ff 93       	push	r31
	// There is only ONE AUX PORT - usually assigned to Secondary RX 
	if (RX_AUX)
    164c:	83 b1       	in	r24, 0x03	; 3
    164e:	80 ff       	sbrs	r24, 0
    1650:	0c c0       	rjmp	.+24     	; 0x166a <__vector_5+0x40>
	{
		RX_raw[1][RXChannel_AUX]=TCNT1;
    1652:	80 91 84 00 	lds	r24, 0x0084
    1656:	90 91 85 00 	lds	r25, 0x0085
    165a:	90 93 f2 07 	sts	0x07F2, r25
    165e:	80 93 f1 07 	sts	0x07F1, r24
		UpdateServo=true;
    1662:	81 e0       	ldi	r24, 0x01	; 1
    1664:	80 93 ce 06 	sts	0x06CE, r24
    1668:	0b c0       	rjmp	.+22     	; 0x1680 <__vector_5+0x56>
	}
	else
	{
		CalculateSignalLength2(RXChannel_AUX);
    166a:	84 e0       	ldi	r24, 0x04	; 4
    166c:	0e 94 1b 26 	call	0x4c36	; 0x4c36 <CalculateSignalLength2>
		RX_Length[0][RXChannel_AUX]=RX_Length[1][RXChannel_AUX];
    1670:	80 91 e0 05 	lds	r24, 0x05E0
    1674:	90 91 e1 05 	lds	r25, 0x05E1
    1678:	90 93 d7 05 	sts	0x05D7, r25
    167c:	80 93 d6 05 	sts	0x05D6, r24
	}

}
    1680:	ff 91       	pop	r31
    1682:	ef 91       	pop	r30
    1684:	bf 91       	pop	r27
    1686:	af 91       	pop	r26
    1688:	9f 91       	pop	r25
    168a:	8f 91       	pop	r24
    168c:	7f 91       	pop	r23
    168e:	6f 91       	pop	r22
    1690:	5f 91       	pop	r21
    1692:	4f 91       	pop	r20
    1694:	3f 91       	pop	r19
    1696:	2f 91       	pop	r18
    1698:	0f 90       	pop	r0
    169a:	0f be       	out	0x3f, r0	; 63
    169c:	0f 90       	pop	r0
    169e:	1f 90       	pop	r1
    16a0:	18 95       	reti

000016a2 <__ctors_end>:
    16a2:	11 24       	eor	r1, r1
    16a4:	1f be       	out	0x3f, r1	; 63
    16a6:	cf ef       	ldi	r28, 0xFF	; 255
    16a8:	d8 e0       	ldi	r29, 0x08	; 8
    16aa:	de bf       	out	0x3e, r29	; 62
    16ac:	cd bf       	out	0x3d, r28	; 61

000016ae <__do_copy_data>:
    16ae:	11 e0       	ldi	r17, 0x01	; 1
    16b0:	a0 e0       	ldi	r26, 0x00	; 0
    16b2:	b1 e0       	ldi	r27, 0x01	; 1
    16b4:	e4 ed       	ldi	r30, 0xD4	; 212
    16b6:	fb e7       	ldi	r31, 0x7B	; 123
    16b8:	02 c0       	rjmp	.+4      	; 0x16be <__do_copy_data+0x10>
    16ba:	05 90       	lpm	r0, Z+
    16bc:	0d 92       	st	X+, r0
    16be:	a4 31       	cpi	r26, 0x14	; 20
    16c0:	b1 07       	cpc	r27, r17
    16c2:	d9 f7       	brne	.-10     	; 0x16ba <__do_copy_data+0xc>

000016c4 <__do_clear_bss>:
    16c4:	18 e0       	ldi	r17, 0x08	; 8
    16c6:	a4 e1       	ldi	r26, 0x14	; 20
    16c8:	b1 e0       	ldi	r27, 0x01	; 1
    16ca:	01 c0       	rjmp	.+2      	; 0x16ce <.do_clear_bss_start>

000016cc <.do_clear_bss_loop>:
    16cc:	1d 92       	st	X+, r1

000016ce <.do_clear_bss_start>:
    16ce:	a4 30       	cpi	r26, 0x04	; 4
    16d0:	b1 07       	cpc	r27, r17
    16d2:	e1 f7       	brne	.-8      	; 0x16cc <.do_clear_bss_loop>
    16d4:	0e 94 6c 18 	call	0x30d8	; 0x30d8 <main>
    16d8:	0c 94 e8 3d 	jmp	0x7bd0	; 0x7bd0 <_exit>

000016dc <__bad_interrupt>:
    16dc:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000016e0 <Beeper_Beep>:
#include "../Include/Misc.h"
#include "../Include/IO_config.h"


void Beeper_Beep (uint16_t msDuration, uint8_t Times)
{
    16e0:	ef 92       	push	r14
    16e2:	ff 92       	push	r15
    16e4:	0f 93       	push	r16
    16e6:	1f 93       	push	r17
    16e8:	cf 93       	push	r28
    16ea:	df 93       	push	r29
    16ec:	ec 01       	movw	r28, r24
	
	//bool CurrentBuzzer_Status = Buzzer;
	
	for (int i=0; i< Times; ++i)
    16ee:	00 e0       	ldi	r16, 0x00	; 0
    16f0:	10 e0       	ldi	r17, 0x00	; 0
    16f2:	e6 2e       	mov	r14, r22
    16f4:	ff 24       	eor	r15, r15
    16f6:	0a c0       	rjmp	.+20     	; 0x170c <Beeper_Beep+0x2c>
	{
		Buzzer = ON;
    16f8:	29 9a       	sbi	0x05, 1	; 5
		delay_ms(msDuration);
    16fa:	ce 01       	movw	r24, r28
    16fc:	0e 94 d7 0e 	call	0x1dae	; 0x1dae <delay_ms>
		Buzzer = OFF;
    1700:	29 98       	cbi	0x05, 1	; 5
		delay_ms(msDuration);		
    1702:	ce 01       	movw	r24, r28
    1704:	0e 94 d7 0e 	call	0x1dae	; 0x1dae <delay_ms>
void Beeper_Beep (uint16_t msDuration, uint8_t Times)
{
	
	//bool CurrentBuzzer_Status = Buzzer;
	
	for (int i=0; i< Times; ++i)
    1708:	0f 5f       	subi	r16, 0xFF	; 255
    170a:	1f 4f       	sbci	r17, 0xFF	; 255
    170c:	0e 15       	cp	r16, r14
    170e:	1f 05       	cpc	r17, r15
    1710:	9c f3       	brlt	.-26     	; 0x16f8 <Beeper_Beep+0x18>
		delay_ms(msDuration);		
	}
	
	//Buzzer = CurrentBuzzer_Status;
	
}
    1712:	df 91       	pop	r29
    1714:	cf 91       	pop	r28
    1716:	1f 91       	pop	r17
    1718:	0f 91       	pop	r16
    171a:	ff 90       	pop	r15
    171c:	ef 90       	pop	r14
    171e:	08 95       	ret

00001720 <KeyBoard_Init>:

void KeyBoard_Init (void)
{

	// key pins to input
	KEYBOARD_DDR |= ALLKEYS;
    1720:	84 b1       	in	r24, 0x04	; 4
    1722:	80 6f       	ori	r24, 0xF0	; 240
    1724:	84 b9       	out	0x04, r24	; 4

	
	// pull up resistors on
	KEYBOARD_PORT |= ALLKEYS;
    1726:	85 b1       	in	r24, 0x05	; 5
    1728:	80 6f       	ori	r24, 0xF0	; 240
    172a:	85 b9       	out	0x05, r24	; 5
	
}
    172c:	08 95       	ret

0000172e <Keyboard_Read>:

uint16_t TCNT_X_snapshot3=0;
uint8_t Keyboard_Read()
{
    172e:	0f 93       	push	r16
    1730:	1f 93       	push	r17
	uint8_t keys = ~KEYBOARD_PIN & ALLKEYS;
    1732:	13 b1       	in	r17, 0x03	; 3
    1734:	10 95       	com	r17
    1736:	10 7f       	andi	r17, 0xF0	; 240
	uint8_t newkeys = keys & ~lastKeys; // always equal to ZERO  for repeated buttons.
    1738:	00 91 bf 05 	lds	r16, 0x05BF
	_keyrepeat = KEYBOARD_NO_REPEAT;
    173c:	10 92 cd 05 	sts	0x05CD, r1
	if (keys !=0) // if any key pressed even repeated.
    1740:	11 23       	and	r17, r17
    1742:	21 f1       	breq	.+72     	; 0x178c <Keyboard_Read+0x5e>
	{
		if (IsArmed==true) Disarm(); // this is for your own safety.
    1744:	80 91 85 07 	lds	r24, 0x0785
    1748:	81 30       	cpi	r24, 0x01	; 1
    174a:	11 f4       	brne	.+4      	; 0x1750 <Keyboard_Read+0x22>
    174c:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <Disarm>
		
		if ((lastKeys!=keys))
    1750:	80 91 bf 05 	lds	r24, 0x05BF
    1754:	81 17       	cp	r24, r17
    1756:	59 f0       	breq	.+22     	; 0x176e <Keyboard_Read+0x40>
		{	// Reset Timer if not the same key.
			TCNT_X_snapshot3 = TCNT1_X+300;
    1758:	80 91 5e 06 	lds	r24, 0x065E
    175c:	90 91 5f 06 	lds	r25, 0x065F
    1760:	84 5d       	subi	r24, 0xD4	; 212
    1762:	9e 4f       	sbci	r25, 0xFE	; 254
    1764:	90 93 15 01 	sts	0x0115, r25
    1768:	80 93 14 01 	sts	0x0114, r24
    176c:	0f c0       	rjmp	.+30     	; 0x178c <Keyboard_Read+0x5e>
		}
		else
		{	// Count to measure the key press duration.
			if ((TCNT_X_snapshot3 < TCNT1_X)) // some racing condition might happen here but not a problem we  dont need an atomic read for UI btn click.
    176e:	20 91 5e 06 	lds	r18, 0x065E
    1772:	30 91 5f 06 	lds	r19, 0x065F
    1776:	40 91 14 01 	lds	r20, 0x0114
    177a:	50 91 15 01 	lds	r21, 0x0115
    177e:	42 17       	cp	r20, r18
    1780:	53 07       	cpc	r21, r19
    1782:	20 f4       	brcc	.+8      	; 0x178c <Keyboard_Read+0x5e>
			{
				_keyrepeat = KEYBOARD_REPEAT;
    1784:	91 e0       	ldi	r25, 0x01	; 1
    1786:	90 93 cd 05 	sts	0x05CD, r25
				return keys; // re-press keys and set the repeated flag for more GUI handling.
    178a:	05 c0       	rjmp	.+10     	; 0x1796 <Keyboard_Read+0x68>

uint16_t TCNT_X_snapshot3=0;
uint8_t Keyboard_Read()
{
	uint8_t keys = ~KEYBOARD_PIN & ALLKEYS;
	uint8_t newkeys = keys & ~lastKeys; // always equal to ZERO  for repeated buttons.
    178c:	80 2f       	mov	r24, r16
    178e:	80 95       	com	r24
				_keyrepeat = KEYBOARD_REPEAT;
				return keys; // re-press keys and set the repeated flag for more GUI handling.
			}
		}
	}	
	lastKeys = keys;
    1790:	10 93 bf 05 	sts	0x05BF, r17
	return newkeys;
    1794:	81 23       	and	r24, r17
}
    1796:	1f 91       	pop	r17
    1798:	0f 91       	pop	r16
    179a:	08 95       	ret

0000179c <Keyboard_State>:


inline uint8_t Keyboard_State()
{
	return lastKeys;
}
    179c:	80 91 bf 05 	lds	r24, 0x05BF
    17a0:	08 95       	ret

000017a2 <sendData>:
	//LCD_CS = 1;
//}

static void sendData(uint8_t data, uint8_t CommandorData)
{
	LCD_CS = 0;
    17a2:	5d 98       	cbi	0x0b, 5	; 11
	LCD_A0 = CommandorData;
    17a4:	67 95       	ror	r22
    17a6:	66 27       	eor	r22, r22
    17a8:	67 95       	ror	r22
    17aa:	9b b1       	in	r25, 0x0b	; 11
    17ac:	9f 77       	andi	r25, 0x7F	; 127
    17ae:	96 2b       	or	r25, r22
    17b0:	9b b9       	out	0x0b, r25	; 11
    17b2:	98 e0       	ldi	r25, 0x08	; 8

static void sendByte(uint8_t byte)
{
	for (uint8_t i = 8; i; i--)
	{
		LCD_SCL = 0;
    17b4:	5c 98       	cbi	0x0b, 4	; 11
		
		if (byte & 0x80) // read MSB [& b10000000]
    17b6:	87 ff       	sbrs	r24, 7
    17b8:	02 c0       	rjmp	.+4      	; 0x17be <sendData+0x1c>
			LCD_SDA = 1;
    17ba:	59 9a       	sbi	0x0b, 1	; 11
    17bc:	01 c0       	rjmp	.+2      	; 0x17c0 <sendData+0x1e>
		else
			LCD_SDA = 0;
    17be:	59 98       	cbi	0x0b, 1	; 11
		
		LCD_SCL = 1;
    17c0:	5c 9a       	sbi	0x0b, 4	; 11
    17c2:	91 50       	subi	r25, 0x01	; 1
static uint8_t _curx, _cury;
static fontdescriptor_t _font;

static void sendByte(uint8_t byte)
{
	for (uint8_t i = 8; i; i--)
    17c4:	11 f0       	breq	.+4      	; 0x17ca <sendData+0x28>
			LCD_SDA = 1;
		else
			LCD_SDA = 0;
		
		LCD_SCL = 1;
		byte <<= 1;
    17c6:	88 0f       	add	r24, r24
    17c8:	f5 cf       	rjmp	.-22     	; 0x17b4 <sendData+0x12>
static void sendData(uint8_t data, uint8_t CommandorData)
{
	LCD_CS = 0;
	LCD_A0 = CommandorData;
	sendByte(data);
	LCD_CS = 1;
    17ca:	5d 9a       	sbi	0x0b, 5	; 11
}
    17cc:	08 95       	ret

000017ce <LCD_SetPos>:
	offset %= sizeof(_screen);
}

void LCD_SetPos(uint8_t line, uint8_t column)
{
	_curx = column % LCDWIDTH;
    17ce:	6f 77       	andi	r22, 0x7F	; 127
    17d0:	60 93 1c 01 	sts	0x011C, r22
	_cury = line * 8;
    17d4:	88 0f       	add	r24, r24
    17d6:	88 0f       	add	r24, r24
    17d8:	88 0f       	add	r24, r24
    17da:	80 93 1b 01 	sts	0x011B, r24
}
    17de:	08 95       	ret

000017e0 <lcdXY>:

void lcdXY(uint8_t x, uint8_t y)
{
	_curx = x;
    17e0:	80 93 1c 01 	sts	0x011C, r24
	_cury = y;
    17e4:	60 93 1b 01 	sts	0x011B, r22
}
    17e8:	08 95       	ret

000017ea <lcdSetPixel>:

void lcdSetPixel(uint8_t x, uint8_t y, uint8_t on)
{
	static const prog_char masks[8] = {0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80};
	uint8_t *scr = _screen + x + (y / 8 * LCDWIDTH); 
    17ea:	26 2f       	mov	r18, r22
    17ec:	26 95       	lsr	r18
    17ee:	26 95       	lsr	r18
    17f0:	26 95       	lsr	r18
    17f2:	30 e0       	ldi	r19, 0x00	; 0
    17f4:	36 95       	lsr	r19
    17f6:	32 2f       	mov	r19, r18
    17f8:	22 27       	eor	r18, r18
    17fa:	37 95       	ror	r19
    17fc:	27 95       	ror	r18
    17fe:	28 0f       	add	r18, r24
    1800:	31 1d       	adc	r19, r1
	uint8_t mask = pgm_read_byte(&masks[y % 8]);
    1802:	e6 2f       	mov	r30, r22
    1804:	f0 e0       	ldi	r31, 0x00	; 0
    1806:	e7 70       	andi	r30, 0x07	; 7
    1808:	f0 70       	andi	r31, 0x00	; 0
    180a:	e4 57       	subi	r30, 0x74	; 116
    180c:	ff 4f       	sbci	r31, 0xFF	; 255
    180e:	e4 91       	lpm	r30, Z+
	if ((_flags & REVERSED) ^ !on)
    1810:	91 e0       	ldi	r25, 0x01	; 1
    1812:	41 11       	cpse	r20, r1
    1814:	90 e0       	ldi	r25, 0x00	; 0
    1816:	80 91 1a 01 	lds	r24, 0x011A
    181a:	81 70       	andi	r24, 0x01	; 1
    181c:	d9 01       	movw	r26, r18
    181e:	a3 5e       	subi	r26, 0xE3	; 227
    1820:	be 4f       	sbci	r27, 0xFE	; 254
    1822:	89 17       	cp	r24, r25
    1824:	29 f0       	breq	.+10     	; 0x1830 <lcdSetPixel+0x46>
		*scr = *scr & ~mask;
    1826:	e0 95       	com	r30
    1828:	8c 91       	ld	r24, X
    182a:	e8 23       	and	r30, r24
    182c:	ec 93       	st	X, r30
    182e:	08 95       	ret
	else
		*scr = *scr | mask;
    1830:	8c 91       	ld	r24, X
    1832:	8e 2b       	or	r24, r30
    1834:	8c 93       	st	X, r24
    1836:	08 95       	ret

00001838 <LCD_Line>:
			////
		////e2 = 2 * err;
		////if (e2 > dy) { err += dy; x0 += sx; } /* e_xy + e_x > 0 */
		////if (e2 < dx) { err += dx; y0 += sy; } /* e_xy + e_y < 0 */
	////}
}
    1838:	08 95       	ret

0000183a <LCD_Rectangle>:
	//for (a = y0; a <= y1; a++)
	//{
		//lcdSetPixel(x0, a, color);
		//lcdSetPixel(x1, a, color);
	//}
}
    183a:	08 95       	ret

0000183c <LCD_FillRectangle>:
	//if (x0 > x1) { a = x0; x0 = x1; x1 = a;}
	//if (y0 > y1) { a = y0; y0 = y1; y1 = a;}
	//for (a = y0; a <= y1; a++)
		//for(uint8_t i = x0; i <= x1; i++)
			//lcdSetPixel(i, a, color);
}
    183c:	08 95       	ret

0000183e <LCD_Clear>:
 
void LCD_Clear()
{
	memset(_screen, 0, sizeof(_screen));
    183e:	80 e0       	ldi	r24, 0x00	; 0
    1840:	94 e0       	ldi	r25, 0x04	; 4
    1842:	ed e1       	ldi	r30, 0x1D	; 29
    1844:	f1 e0       	ldi	r31, 0x01	; 1
    1846:	df 01       	movw	r26, r30
    1848:	9c 01       	movw	r18, r24
    184a:	1d 92       	st	X+, r1
    184c:	21 50       	subi	r18, 0x01	; 1
    184e:	30 40       	sbci	r19, 0x00	; 0
    1850:	e1 f7       	brne	.-8      	; 0x184a <LCD_Clear+0xc>
	LCD_SetPos(0, 0);
    1852:	80 e0       	ldi	r24, 0x00	; 0
    1854:	60 e0       	ldi	r22, 0x00	; 0
    1856:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <LCD_SetPos>
	_flags = 0;
    185a:	10 92 1a 01 	sts	0x011A, r1
}
    185e:	08 95       	ret

00001860 <lcdWriteSprite_P>:

void lcdWriteSprite_P(PGM_P sprite, uint8_t sizeX, uint8_t sizeY, uint8_t mode)
{
    1860:	8f 92       	push	r8
    1862:	9f 92       	push	r9
    1864:	bf 92       	push	r11
    1866:	cf 92       	push	r12
    1868:	df 92       	push	r13
    186a:	ef 92       	push	r14
    186c:	ff 92       	push	r15
    186e:	0f 93       	push	r16
    1870:	1f 93       	push	r17
    1872:	df 93       	push	r29
    1874:	cf 93       	push	r28
    1876:	0f 92       	push	r0
    1878:	cd b7       	in	r28, 0x3d	; 61
    187a:	de b7       	in	r29, 0x3e	; 62
    187c:	4c 01       	movw	r8, r24
    187e:	e6 2e       	mov	r14, r22
    1880:	f4 2e       	mov	r15, r20
    1882:	c2 2e       	mov	r12, r18
	uint8_t b = 0;
	for (uint8_t i = 0; i < sizeX; i++)
    1884:	dd 24       	eor	r13, r13
	_flags = 0;
}

void lcdWriteSprite_P(PGM_P sprite, uint8_t sizeX, uint8_t sizeY, uint8_t mode)
{
	uint8_t b = 0;
    1886:	bb 24       	eor	r11, r11
			if (j % 8 == 0)
					b = pgm_read_byte(sprite++);
					
			if (mode == ROP_COPY)
			{
				if ((_cury % 8 == 0) && (sizeY - j >= 8))
    1888:	04 2f       	mov	r16, r20
    188a:	10 e0       	ldi	r17, 0x00	; 0
}

void lcdWriteSprite_P(PGM_P sprite, uint8_t sizeX, uint8_t sizeY, uint8_t mode)
{
	uint8_t b = 0;
	for (uint8_t i = 0; i < sizeX; i++)
    188c:	4f c0       	rjmp	.+158    	; 0x192c <lcdWriteSprite_P+0xcc>
	{
		for (uint8_t j = 0; j < sizeY; j++)
		{
			if (j % 8 == 0)
    188e:	83 2f       	mov	r24, r19
    1890:	87 70       	andi	r24, 0x07	; 7
    1892:	29 f4       	brne	.+10     	; 0x189e <lcdWriteSprite_P+0x3e>
					b = pgm_read_byte(sprite++);
    1894:	f4 01       	movw	r30, r8
    1896:	08 94       	sec
    1898:	81 1c       	adc	r8, r1
    189a:	91 1c       	adc	r9, r1
    189c:	b4 90       	lpm	r11, Z+
					
			if (mode == ROP_COPY)
    189e:	cc 20       	and	r12, r12
    18a0:	79 f5       	brne	.+94     	; 0x1900 <lcdWriteSprite_P+0xa0>
			{
				if ((_cury % 8 == 0) && (sizeY - j >= 8))
    18a2:	60 91 1b 01 	lds	r22, 0x011B
    18a6:	86 2f       	mov	r24, r22
    18a8:	87 70       	andi	r24, 0x07	; 7
    18aa:	19 f5       	brne	.+70     	; 0x18f2 <lcdWriteSprite_P+0x92>
    18ac:	c8 01       	movw	r24, r16
    18ae:	83 1b       	sub	r24, r19
    18b0:	91 09       	sbc	r25, r1
    18b2:	88 30       	cpi	r24, 0x08	; 8
    18b4:	91 05       	cpc	r25, r1
    18b6:	ec f0       	brlt	.+58     	; 0x18f2 <lcdWriteSprite_P+0x92>
				{
					lcdSetByte(_curx + i, _cury + j, b);
    18b8:	63 0f       	add	r22, r19
		*scr = *scr | mask;
}

static void lcdSetByte(uint8_t x, uint8_t y, uint8_t b)
{
	uint8_t *scr = _screen + x + (y / 8 * LCDWIDTH); 
    18ba:	66 95       	lsr	r22
    18bc:	66 95       	lsr	r22
    18be:	66 95       	lsr	r22
    18c0:	a6 2f       	mov	r26, r22
    18c2:	b0 e0       	ldi	r27, 0x00	; 0
    18c4:	b6 95       	lsr	r27
    18c6:	ba 2f       	mov	r27, r26
    18c8:	aa 27       	eor	r26, r26
    18ca:	b7 95       	ror	r27
    18cc:	a7 95       	ror	r26
					
			if (mode == ROP_COPY)
			{
				if ((_cury % 8 == 0) && (sizeY - j >= 8))
				{
					lcdSetByte(_curx + i, _cury + j, b);
    18ce:	80 91 1c 01 	lds	r24, 0x011C
    18d2:	8d 0d       	add	r24, r13
		*scr = *scr | mask;
}

static void lcdSetByte(uint8_t x, uint8_t y, uint8_t b)
{
	uint8_t *scr = _screen + x + (y / 8 * LCDWIDTH); 
    18d4:	a8 0f       	add	r26, r24
    18d6:	b1 1d       	adc	r27, r1
	if (_flags & REVERSED)
    18d8:	80 91 1a 01 	lds	r24, 0x011A
    18dc:	a3 5e       	subi	r26, 0xE3	; 227
    18de:	be 4f       	sbci	r27, 0xFE	; 254
    18e0:	80 ff       	sbrs	r24, 0
    18e2:	04 c0       	rjmp	.+8      	; 0x18ec <lcdWriteSprite_P+0x8c>
		*scr = ~b;
    18e4:	8b 2d       	mov	r24, r11
    18e6:	80 95       	com	r24
    18e8:	8c 93       	st	X, r24
    18ea:	01 c0       	rjmp	.+2      	; 0x18ee <lcdWriteSprite_P+0x8e>
	else
		*scr = b;
    18ec:	bc 92       	st	X, r11
			if (mode == ROP_COPY)
			{
				if ((_cury % 8 == 0) && (sizeY - j >= 8))
				{
					lcdSetByte(_curx + i, _cury + j, b);
					j += 7; // just +7 b/c the loop increments anyway
    18ee:	39 5f       	subi	r19, 0xF9	; 249
    18f0:	17 c0       	rjmp	.+46     	; 0x1920 <lcdWriteSprite_P+0xc0>
				}
				else
					lcdSetPixel(_curx + i, _cury + j, b & 0x01);
    18f2:	80 91 1c 01 	lds	r24, 0x011C
    18f6:	63 0f       	add	r22, r19
    18f8:	4b 2d       	mov	r20, r11
    18fa:	41 70       	andi	r20, 0x01	; 1
    18fc:	8d 0d       	add	r24, r13
    18fe:	0c c0       	rjmp	.+24     	; 0x1918 <lcdWriteSprite_P+0xb8>
			}				
			else if (mode == ROP_PAINT)
    1900:	8c 2d       	mov	r24, r12
    1902:	81 30       	cpi	r24, 0x01	; 1
    1904:	69 f4       	brne	.+26     	; 0x1920 <lcdWriteSprite_P+0xc0>
			{
				if (b & 0x01)
    1906:	b0 fe       	sbrs	r11, 0
    1908:	0b c0       	rjmp	.+22     	; 0x1920 <lcdWriteSprite_P+0xc0>
					lcdSetPixel(_curx + i, _cury + j, 1);
    190a:	80 91 1c 01 	lds	r24, 0x011C
    190e:	60 91 1b 01 	lds	r22, 0x011B
    1912:	63 0f       	add	r22, r19
    1914:	8d 0d       	add	r24, r13
    1916:	41 e0       	ldi	r20, 0x01	; 1
    1918:	39 83       	std	Y+1, r19	; 0x01
    191a:	0e 94 f5 0b 	call	0x17ea	; 0x17ea <lcdSetPixel>
    191e:	39 81       	ldd	r19, Y+1	; 0x01
			}			
			b >>= 1;
    1920:	b6 94       	lsr	r11
void lcdWriteSprite_P(PGM_P sprite, uint8_t sizeX, uint8_t sizeY, uint8_t mode)
{
	uint8_t b = 0;
	for (uint8_t i = 0; i < sizeX; i++)
	{
		for (uint8_t j = 0; j < sizeY; j++)
    1922:	3f 5f       	subi	r19, 0xFF	; 255
    1924:	3f 15       	cp	r19, r15
    1926:	08 f4       	brcc	.+2      	; 0x192a <lcdWriteSprite_P+0xca>
    1928:	b2 cf       	rjmp	.-156    	; 0x188e <lcdWriteSprite_P+0x2e>
}

void lcdWriteSprite_P(PGM_P sprite, uint8_t sizeX, uint8_t sizeY, uint8_t mode)
{
	uint8_t b = 0;
	for (uint8_t i = 0; i < sizeX; i++)
    192a:	d3 94       	inc	r13
    192c:	de 14       	cp	r13, r14
    192e:	10 f4       	brcc	.+4      	; 0x1934 <lcdWriteSprite_P+0xd4>
    1930:	30 e0       	ldi	r19, 0x00	; 0
    1932:	f8 cf       	rjmp	.-16     	; 0x1924 <lcdWriteSprite_P+0xc4>
					lcdSetPixel(_curx + i, _cury + j, 1);
			}			
			b >>= 1;
		}
	}	
}
    1934:	0f 90       	pop	r0
    1936:	cf 91       	pop	r28
    1938:	df 91       	pop	r29
    193a:	1f 91       	pop	r17
    193c:	0f 91       	pop	r16
    193e:	ff 90       	pop	r15
    1940:	ef 90       	pop	r14
    1942:	df 90       	pop	r13
    1944:	cf 90       	pop	r12
    1946:	bf 90       	pop	r11
    1948:	9f 90       	pop	r9
    194a:	8f 90       	pop	r8
    194c:	08 95       	ret

0000194e <lcdWriteGlyph_P>:

void lcdWriteGlyph_P(const glyph_t *glyph, uint8_t mode)
{
    194e:	26 2f       	mov	r18, r22
	uint8_t sizeX = pgm_read_byte(&glyph->sizeX);
    1950:	fc 01       	movw	r30, r24
    1952:	64 91       	lpm	r22, Z+
	uint8_t sizeY = pgm_read_byte(&glyph->sizeY);
    1954:	31 96       	adiw	r30, 0x01	; 1
    1956:	44 91       	lpm	r20, Z+
	lcdWriteSprite_P((PGM_P)&glyph->glyph, sizeX, sizeY, mode);
    1958:	02 96       	adiw	r24, 0x02	; 2
    195a:	0e 94 30 0c 	call	0x1860	; 0x1860 <lcdWriteSprite_P>
}
    195e:	08 95       	ret

00001960 <lcdWriteChar>:

void lcdWriteChar(char c)
{
	if (c == '\n')
    1960:	8a 30       	cpi	r24, 0x0A	; 10
    1962:	51 f4       	brne	.+20     	; 0x1978 <lcdWriteChar+0x18>
	{
		_cury += _font.sizeY;
    1964:	80 91 1b 01 	lds	r24, 0x011B
    1968:	90 91 17 01 	lds	r25, 0x0117
    196c:	89 0f       	add	r24, r25
    196e:	80 93 1b 01 	sts	0x011B, r24
		_curx = 0;
    1972:	10 92 1c 01 	sts	0x011C, r1
    1976:	08 95       	ret
	}
	else
	{
		lcdWriteSprite_P(_font.selector(c), _font.sizeX, _font.sizeY, 0);
    1978:	e0 91 18 01 	lds	r30, 0x0118
    197c:	f0 91 19 01 	lds	r31, 0x0119
    1980:	09 95       	icall
    1982:	60 91 16 01 	lds	r22, 0x0116
    1986:	40 91 17 01 	lds	r20, 0x0117
    198a:	20 e0       	ldi	r18, 0x00	; 0
    198c:	0e 94 30 0c 	call	0x1860	; 0x1860 <lcdWriteSprite_P>
		_curx += _font.sizeX;
    1990:	80 91 1c 01 	lds	r24, 0x011C
    1994:	90 91 16 01 	lds	r25, 0x0116
    1998:	89 0f       	add	r24, r25
    199a:	80 93 1c 01 	sts	0x011C, r24
    199e:	08 95       	ret

000019a0 <LCD_WriteString>:
	}
}

void LCD_WriteString(char *s)
{
    19a0:	ef 92       	push	r14
    19a2:	ff 92       	push	r15
    19a4:	cf 93       	push	r28
    19a6:	df 93       	push	r29
    19a8:	e8 2e       	mov	r14, r24
    19aa:	e7 01       	movw	r28, r14
    19ac:	7e 01       	movw	r14, r28
    19ae:	f9 2e       	mov	r15, r25
    19b0:	e7 01       	movw	r28, r14
	while (*s)
    19b2:	02 c0       	rjmp	.+4      	; 0x19b8 <LCD_WriteString+0x18>
	{
		lcdWriteChar(*s);
    19b4:	0e 94 b0 0c 	call	0x1960	; 0x1960 <lcdWriteChar>
	}
}

void LCD_WriteString(char *s)
{
	while (*s)
    19b8:	89 91       	ld	r24, Y+
    19ba:	88 23       	and	r24, r24
    19bc:	d9 f7       	brne	.-10     	; 0x19b4 <LCD_WriteString+0x14>
	{
		lcdWriteChar(*s);
		s++;
	}		
}
    19be:	df 91       	pop	r29
    19c0:	cf 91       	pop	r28
    19c2:	ff 90       	pop	r15
    19c4:	ef 90       	pop	r14
    19c6:	08 95       	ret

000019c8 <LCD_WriteString_P>:
}



void LCD_WriteString_P(PGM_P s)
{
    19c8:	cf 93       	push	r28
    19ca:	df 93       	push	r29
    19cc:	ec 01       	movw	r28, r24
	char c;
	while ((c = pgm_read_byte(s++)))
    19ce:	02 c0       	rjmp	.+4      	; 0x19d4 <LCD_WriteString_P+0xc>
		lcdWriteChar(c);
    19d0:	0e 94 b0 0c 	call	0x1960	; 0x1960 <lcdWriteChar>
    19d4:	fe 01       	movw	r30, r28


void LCD_WriteString_P(PGM_P s)
{
	char c;
	while ((c = pgm_read_byte(s++)))
    19d6:	21 96       	adiw	r28, 0x01	; 1
    19d8:	84 91       	lpm	r24, Z+
    19da:	88 23       	and	r24, r24
    19dc:	c9 f7       	brne	.-14     	; 0x19d0 <LCD_WriteString_P+0x8>
		lcdWriteChar(c);
}
    19de:	df 91       	pop	r29
    19e0:	cf 91       	pop	r28
    19e2:	08 95       	ret

000019e4 <lcdReverse>:
	lcdReverse(0);
}


void lcdReverse(uint8_t reversed)
{
    19e4:	90 91 1a 01 	lds	r25, 0x011A
	if (reversed)
    19e8:	88 23       	and	r24, r24
    19ea:	11 f0       	breq	.+4      	; 0x19f0 <lcdReverse+0xc>
		_flags |= REVERSED;
    19ec:	91 60       	ori	r25, 0x01	; 1
    19ee:	01 c0       	rjmp	.+2      	; 0x19f2 <lcdReverse+0xe>
	else
		_flags &= ~REVERSED;
    19f0:	9e 7f       	andi	r25, 0xFE	; 254
    19f2:	90 93 1a 01 	sts	0x011A, r25
    19f6:	08 95       	ret

000019f8 <LCD_WriteStringex>:
}



void LCD_WriteStringex(uint8_t x, uint8_t y, char *str, BOOL LCDReverse)
{
    19f8:	ef 92       	push	r14
    19fa:	ff 92       	push	r15
    19fc:	0f 93       	push	r16
    19fe:	1f 93       	push	r17
    1a00:	df 93       	push	r29
    1a02:	cf 93       	push	r28
    1a04:	00 d0       	rcall	.+0      	; 0x1a06 <LCD_WriteStringex+0xe>
    1a06:	0f 92       	push	r0
    1a08:	cd b7       	in	r28, 0x3d	; 61
    1a0a:	de b7       	in	r29, 0x3e	; 62
    1a0c:	18 2f       	mov	r17, r24
    1a0e:	82 2f       	mov	r24, r18
	lcdReverse(LCDReverse);
    1a10:	4a 83       	std	Y+2, r20	; 0x02
    1a12:	5b 83       	std	Y+3, r21	; 0x03
    1a14:	69 83       	std	Y+1, r22	; 0x01
    1a16:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <lcdReverse>
	LCD_SetPos(x, y);
    1a1a:	81 2f       	mov	r24, r17
    1a1c:	69 81       	ldd	r22, Y+1	; 0x01
    1a1e:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <LCD_SetPos>
    1a22:	4a 81       	ldd	r20, Y+2	; 0x02
    1a24:	5b 81       	ldd	r21, Y+3	; 0x03
    1a26:	8a 01       	movw	r16, r20
	while (*str)
    1a28:	02 c0       	rjmp	.+4      	; 0x1a2e <LCD_WriteStringex+0x36>
	{
		lcdWriteChar(*str);
    1a2a:	0e 94 b0 0c 	call	0x1960	; 0x1960 <lcdWriteChar>

void LCD_WriteStringex(uint8_t x, uint8_t y, char *str, BOOL LCDReverse)
{
	lcdReverse(LCDReverse);
	LCD_SetPos(x, y);
	while (*str)
    1a2e:	f8 01       	movw	r30, r16
    1a30:	81 91       	ld	r24, Z+
    1a32:	8f 01       	movw	r16, r30
    1a34:	88 23       	and	r24, r24
    1a36:	c9 f7       	brne	.-14     	; 0x1a2a <LCD_WriteStringex+0x32>
	{
		lcdWriteChar(*str);
		str++;
	}		
	lcdReverse(0);
    1a38:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <lcdReverse>
}
    1a3c:	0f 90       	pop	r0
    1a3e:	0f 90       	pop	r0
    1a40:	0f 90       	pop	r0
    1a42:	cf 91       	pop	r28
    1a44:	df 91       	pop	r29
    1a46:	1f 91       	pop	r17
    1a48:	0f 91       	pop	r16
    1a4a:	ff 90       	pop	r15
    1a4c:	ef 90       	pop	r14
    1a4e:	08 95       	ret

00001a50 <LCD_WriteSpace>:
		_flags &= ~REVERSED;
}


void LCD_WriteSpace(uint8_t len)
{
    1a50:	0f 93       	push	r16
    1a52:	1f 93       	push	r17
    1a54:	08 2f       	mov	r16, r24
	for (uint8_t i = 0; i < len; i++)
    1a56:	10 e0       	ldi	r17, 0x00	; 0
    1a58:	04 c0       	rjmp	.+8      	; 0x1a62 <LCD_WriteSpace+0x12>
		lcdWriteChar(32);
    1a5a:	80 e2       	ldi	r24, 0x20	; 32
    1a5c:	0e 94 b0 0c 	call	0x1960	; 0x1960 <lcdWriteChar>
}


void LCD_WriteSpace(uint8_t len)
{
	for (uint8_t i = 0; i < len; i++)
    1a60:	1f 5f       	subi	r17, 0xFF	; 255
    1a62:	10 17       	cp	r17, r16
    1a64:	d0 f3       	brcs	.-12     	; 0x1a5a <LCD_WriteSpace+0xa>
		lcdWriteChar(32);
}
    1a66:	1f 91       	pop	r17
    1a68:	0f 91       	pop	r16
    1a6a:	08 95       	ret

00001a6c <LCD_WritePadded>:

void LCD_WritePadded(char *s, uint8_t len)
{
    1a6c:	0f 93       	push	r16
    1a6e:	1f 93       	push	r17
    1a70:	df 93       	push	r29
    1a72:	cf 93       	push	r28
    1a74:	0f 92       	push	r0
    1a76:	cd b7       	in	r28, 0x3d	; 61
    1a78:	de b7       	in	r29, 0x3e	; 62
    1a7a:	8c 01       	movw	r16, r24
	LCD_WriteString(s);
    1a7c:	69 83       	std	Y+1, r22	; 0x01
    1a7e:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <LCD_WriteString>
	LCD_WriteSpace(len - strlen(s));
    1a82:	f8 01       	movw	r30, r16
    1a84:	01 90       	ld	r0, Z+
    1a86:	00 20       	and	r0, r0
    1a88:	e9 f7       	brne	.-6      	; 0x1a84 <LCD_WritePadded+0x18>
    1a8a:	31 97       	sbiw	r30, 0x01	; 1
    1a8c:	e0 1b       	sub	r30, r16
    1a8e:	f1 0b       	sbc	r31, r17
    1a90:	69 81       	ldd	r22, Y+1	; 0x01
    1a92:	86 2f       	mov	r24, r22
    1a94:	8e 1b       	sub	r24, r30
    1a96:	0e 94 28 0d 	call	0x1a50	; 0x1a50 <LCD_WriteSpace>
}
    1a9a:	0f 90       	pop	r0
    1a9c:	cf 91       	pop	r28
    1a9e:	df 91       	pop	r29
    1aa0:	1f 91       	pop	r17
    1aa2:	0f 91       	pop	r16
    1aa4:	08 95       	ret

00001aa6 <LCD_WritePadded_P>:


void LCD_WritePadded_P(const char *s, uint8_t len)
{
    1aa6:	0f 93       	push	r16
    1aa8:	1f 93       	push	r17
    1aaa:	df 93       	push	r29
    1aac:	cf 93       	push	r28
    1aae:	0f 92       	push	r0
    1ab0:	cd b7       	in	r28, 0x3d	; 61
    1ab2:	de b7       	in	r29, 0x3e	; 62
    1ab4:	8c 01       	movw	r16, r24
	LCD_WriteString_P(s);
    1ab6:	69 83       	std	Y+1, r22	; 0x01
    1ab8:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <LCD_WriteString_P>
	LCD_WriteSpace(len - strlen_P(s));
    1abc:	c8 01       	movw	r24, r16
    1abe:	0e 94 f8 3a 	call	0x75f0	; 0x75f0 <strlen_P>
    1ac2:	69 81       	ldd	r22, Y+1	; 0x01
    1ac4:	68 1b       	sub	r22, r24
    1ac6:	86 2f       	mov	r24, r22
    1ac8:	0e 94 28 0d 	call	0x1a50	; 0x1a50 <LCD_WriteSpace>
}
    1acc:	0f 90       	pop	r0
    1ace:	cf 91       	pop	r28
    1ad0:	df 91       	pop	r29
    1ad2:	1f 91       	pop	r17
    1ad4:	0f 91       	pop	r16
    1ad6:	08 95       	ret

00001ad8 <LCD_WriteString_Pex>:
		lcdWriteChar(c);
}


void LCD_WriteString_Pex(uint8_t x, uint8_t y, PGM_P str, uint8_t len, BOOL LCDReverse)
{
    1ad8:	ef 92       	push	r14
    1ada:	ff 92       	push	r15
    1adc:	0f 93       	push	r16
    1ade:	1f 93       	push	r17
    1ae0:	df 93       	push	r29
    1ae2:	cf 93       	push	r28
    1ae4:	00 d0       	rcall	.+0      	; 0x1ae6 <LCD_WriteString_Pex+0xe>
    1ae6:	cd b7       	in	r28, 0x3d	; 61
    1ae8:	de b7       	in	r29, 0x3e	; 62
    1aea:	18 2f       	mov	r17, r24
    1aec:	7a 01       	movw	r14, r20
    1aee:	80 2f       	mov	r24, r16
	lcdReverse(LCDReverse);
    1af0:	2a 83       	std	Y+2, r18	; 0x02
    1af2:	69 83       	std	Y+1, r22	; 0x01
    1af4:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <lcdReverse>
	LCD_SetPos(x, y);
    1af8:	81 2f       	mov	r24, r17
    1afa:	69 81       	ldd	r22, Y+1	; 0x01
    1afc:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <LCD_SetPos>
	LCD_WritePadded_P(str, len);
    1b00:	c7 01       	movw	r24, r14
    1b02:	2a 81       	ldd	r18, Y+2	; 0x02
    1b04:	62 2f       	mov	r22, r18
    1b06:	0e 94 53 0d 	call	0x1aa6	; 0x1aa6 <LCD_WritePadded_P>
	lcdReverse(0);
    1b0a:	80 e0       	ldi	r24, 0x00	; 0
    1b0c:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <lcdReverse>
}
    1b10:	0f 90       	pop	r0
    1b12:	0f 90       	pop	r0
    1b14:	cf 91       	pop	r28
    1b16:	df 91       	pop	r29
    1b18:	1f 91       	pop	r17
    1b1a:	0f 91       	pop	r16
    1b1c:	ff 90       	pop	r15
    1b1e:	ef 90       	pop	r14
    1b20:	08 95       	ret

00001b22 <LCD_WriteValue_double_ex>:
	LCD_WriteString_P(s);
	LCD_WriteSpace(len - strlen_P(s));
}

void LCD_WriteValue_double_ex(uint8_t x, uint8_t y, double value, int8_t len, BOOL LCDReverse)
{
    1b22:	bf 92       	push	r11
    1b24:	cf 92       	push	r12
    1b26:	df 92       	push	r13
    1b28:	ef 92       	push	r14
    1b2a:	ff 92       	push	r15
    1b2c:	0f 93       	push	r16
    1b2e:	1f 93       	push	r17
    1b30:	df 93       	push	r29
    1b32:	cf 93       	push	r28
    1b34:	cd b7       	in	r28, 0x3d	; 61
    1b36:	de b7       	in	r29, 0x3e	; 62
    1b38:	62 97       	sbiw	r28, 0x12	; 18
    1b3a:	0f b6       	in	r0, 0x3f	; 63
    1b3c:	f8 94       	cli
    1b3e:	de bf       	out	0x3e, r29	; 62
    1b40:	0f be       	out	0x3f, r0	; 63
    1b42:	cd bf       	out	0x3d, r28	; 61
    1b44:	f8 2e       	mov	r15, r24
    1b46:	b6 2e       	mov	r11, r22
    1b48:	ca 01       	movw	r24, r20
    1b4a:	b9 01       	movw	r22, r18
    1b4c:	30 2f       	mov	r19, r16
	char s[17];
	dtostrf(value, len-2,2, s);
    1b4e:	32 50       	subi	r19, 0x02	; 2
    1b50:	43 2f       	mov	r20, r19
    1b52:	22 e0       	ldi	r18, 0x02	; 2
    1b54:	6e 01       	movw	r12, r28
    1b56:	08 94       	sec
    1b58:	c1 1c       	adc	r12, r1
    1b5a:	d1 1c       	adc	r13, r1
    1b5c:	86 01       	movw	r16, r12
    1b5e:	3a 8b       	std	Y+18, r19	; 0x12
    1b60:	0e 94 c6 3a 	call	0x758c	; 0x758c <dtostrf>
	//itoa(value, s, 10);
	lcdReverse(LCDReverse);
    1b64:	8e 2d       	mov	r24, r14
    1b66:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <lcdReverse>
	LCD_SetPos(x, y);
    1b6a:	8f 2d       	mov	r24, r15
    1b6c:	6b 2d       	mov	r22, r11
    1b6e:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <LCD_SetPos>
	LCD_WritePadded(s, len-2);
    1b72:	c6 01       	movw	r24, r12
    1b74:	3a 89       	ldd	r19, Y+18	; 0x12
    1b76:	63 2f       	mov	r22, r19
    1b78:	0e 94 36 0d 	call	0x1a6c	; 0x1a6c <LCD_WritePadded>
	lcdReverse(0);
    1b7c:	80 e0       	ldi	r24, 0x00	; 0
    1b7e:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <lcdReverse>

}
    1b82:	62 96       	adiw	r28, 0x12	; 18
    1b84:	0f b6       	in	r0, 0x3f	; 63
    1b86:	f8 94       	cli
    1b88:	de bf       	out	0x3e, r29	; 62
    1b8a:	0f be       	out	0x3f, r0	; 63
    1b8c:	cd bf       	out	0x3d, r28	; 61
    1b8e:	cf 91       	pop	r28
    1b90:	df 91       	pop	r29
    1b92:	1f 91       	pop	r17
    1b94:	0f 91       	pop	r16
    1b96:	ff 90       	pop	r15
    1b98:	ef 90       	pop	r14
    1b9a:	df 90       	pop	r13
    1b9c:	cf 90       	pop	r12
    1b9e:	bf 90       	pop	r11
    1ba0:	08 95       	ret

00001ba2 <LCD_WriteValue_double>:
void LCD_WriteValue_double(uint8_t x, uint8_t y, double value,  BOOL LCDReverse)
{
    1ba2:	ef 92       	push	r14
    1ba4:	0f 93       	push	r16
    1ba6:	e0 2e       	mov	r14, r16
	LCD_WriteValue_double_ex(x,y,value,5,LCDReverse);
    1ba8:	05 e0       	ldi	r16, 0x05	; 5
    1baa:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <LCD_WriteValue_double_ex>
}
    1bae:	0f 91       	pop	r16
    1bb0:	ef 90       	pop	r14
    1bb2:	08 95       	ret

00001bb4 <LCD_WriteValue>:

void LCD_WriteValue(uint8_t x, uint8_t y, int16_t value, uint8_t len, BOOL LCDReverse)
{
    1bb4:	df 92       	push	r13
    1bb6:	ef 92       	push	r14
    1bb8:	ff 92       	push	r15
    1bba:	0f 93       	push	r16
    1bbc:	1f 93       	push	r17
    1bbe:	df 93       	push	r29
    1bc0:	cf 93       	push	r28
    1bc2:	cd b7       	in	r28, 0x3d	; 61
    1bc4:	de b7       	in	r29, 0x3e	; 62
    1bc6:	28 97       	sbiw	r28, 0x08	; 8
    1bc8:	0f b6       	in	r0, 0x3f	; 63
    1bca:	f8 94       	cli
    1bcc:	de bf       	out	0x3e, r29	; 62
    1bce:	0f be       	out	0x3f, r0	; 63
    1bd0:	cd bf       	out	0x3d, r28	; 61
    1bd2:	d8 2e       	mov	r13, r24
    1bd4:	16 2f       	mov	r17, r22
	char s[7];
	itoa(value, s, 10);
    1bd6:	ca 01       	movw	r24, r20
    1bd8:	7e 01       	movw	r14, r28
    1bda:	08 94       	sec
    1bdc:	e1 1c       	adc	r14, r1
    1bde:	f1 1c       	adc	r15, r1
    1be0:	b7 01       	movw	r22, r14
    1be2:	4a e0       	ldi	r20, 0x0A	; 10
    1be4:	50 e0       	ldi	r21, 0x00	; 0
    1be6:	28 87       	std	Y+8, r18	; 0x08
    1be8:	0e 94 15 3b 	call	0x762a	; 0x762a <itoa>
	lcdReverse(LCDReverse);
    1bec:	80 2f       	mov	r24, r16
    1bee:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <lcdReverse>
	LCD_SetPos(x, y);
    1bf2:	8d 2d       	mov	r24, r13
    1bf4:	61 2f       	mov	r22, r17
    1bf6:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <LCD_SetPos>
	LCD_WritePadded(s, len);
    1bfa:	c7 01       	movw	r24, r14
    1bfc:	28 85       	ldd	r18, Y+8	; 0x08
    1bfe:	62 2f       	mov	r22, r18
    1c00:	0e 94 36 0d 	call	0x1a6c	; 0x1a6c <LCD_WritePadded>
	lcdReverse(0);
    1c04:	80 e0       	ldi	r24, 0x00	; 0
    1c06:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <lcdReverse>
}
    1c0a:	28 96       	adiw	r28, 0x08	; 8
    1c0c:	0f b6       	in	r0, 0x3f	; 63
    1c0e:	f8 94       	cli
    1c10:	de bf       	out	0x3e, r29	; 62
    1c12:	0f be       	out	0x3f, r0	; 63
    1c14:	cd bf       	out	0x3d, r28	; 61
    1c16:	cf 91       	pop	r28
    1c18:	df 91       	pop	r29
    1c1a:	1f 91       	pop	r17
    1c1c:	0f 91       	pop	r16
    1c1e:	ff 90       	pop	r15
    1c20:	ef 90       	pop	r14
    1c22:	df 90       	pop	r13
    1c24:	08 95       	ret

00001c26 <LCD_Enable>:
}

void LCD_Enable()
{
	// reset timer0 to avoid re-entrant call of ISR b/c it is non blocking
	TCNT0 = 0;
    1c26:	16 bc       	out	0x26, r1	; 38
	TIFR0 = _BV(TOV0);
    1c28:	81 e0       	ldi	r24, 0x01	; 1
    1c2a:	85 bb       	out	0x15, r24	; 21
	TIMSK0 |= _BV(TOIE0);	// enable interrupt on overflow
    1c2c:	ee e6       	ldi	r30, 0x6E	; 110
    1c2e:	f0 e0       	ldi	r31, 0x00	; 0
    1c30:	80 81       	ld	r24, Z
    1c32:	81 60       	ori	r24, 0x01	; 1
    1c34:	80 83       	st	Z, r24
}
    1c36:	08 95       	ret

00001c38 <LCD_Disable>:

void LCD_Disable()
{
	TIMSK0 &= ~_BV(TOIE0);	// disable overflow interrupt
    1c38:	ee e6       	ldi	r30, 0x6E	; 110
    1c3a:	f0 e0       	ldi	r31, 0x00	; 0
    1c3c:	80 81       	ld	r24, Z
    1c3e:	8e 7f       	andi	r24, 0xFE	; 254
    1c40:	80 83       	st	Z, r24
}
    1c42:	08 95       	ret

00001c44 <lcdSetContrast>:
	LCD_WritePadded(s, len);
	lcdReverse(0);
}

void lcdSetContrast(uint8_t contrast)
{
    1c44:	0f 93       	push	r16
    1c46:	1f 93       	push	r17
    1c48:	cf 93       	push	r28
    1c4a:	df 93       	push	r29
    1c4c:	08 2f       	mov	r16, r24
	uint8_t t = TIMSK0;
    1c4e:	ce e6       	ldi	r28, 0x6E	; 110
    1c50:	d0 e0       	ldi	r29, 0x00	; 0
    1c52:	18 81       	ld	r17, Y
	LCD_Disable();
    1c54:	0e 94 1c 0e 	call	0x1c38	; 0x1c38 <LCD_Disable>
	sendData(0x81, LCD_COMMAND);
    1c58:	81 e8       	ldi	r24, 0x81	; 129
    1c5a:	60 e0       	ldi	r22, 0x00	; 0
    1c5c:	0e 94 d1 0b 	call	0x17a2	; 0x17a2 <sendData>
	sendData(contrast & 0x3F, LCD_COMMAND); 
    1c60:	80 2f       	mov	r24, r16
    1c62:	8f 73       	andi	r24, 0x3F	; 63
    1c64:	60 e0       	ldi	r22, 0x00	; 0
    1c66:	0e 94 d1 0b 	call	0x17a2	; 0x17a2 <sendData>
	TIMSK0 = t;
    1c6a:	18 83       	st	Y, r17
}
    1c6c:	df 91       	pop	r29
    1c6e:	cf 91       	pop	r28
    1c70:	1f 91       	pop	r17
    1c72:	0f 91       	pop	r16
    1c74:	08 95       	ret

00001c76 <LCD_SelectFont>:
{
	TIMSK0 &= ~_BV(TOIE0);	// disable overflow interrupt
}

void LCD_SelectFont(const fontdescriptor_t *font)
{
    1c76:	bc 01       	movw	r22, r24
	if (font == NULL)
    1c78:	00 97       	sbiw	r24, 0x00	; 0
    1c7a:	11 f4       	brne	.+4      	; 0x1c80 <LCD_SelectFont+0xa>
		font = &font6x8;
    1c7c:	64 e3       	ldi	r22, 0x34	; 52
    1c7e:	77 e0       	ldi	r23, 0x07	; 7
	memcpy_P(&_font, font, sizeof(_font));
    1c80:	86 e1       	ldi	r24, 0x16	; 22
    1c82:	91 e0       	ldi	r25, 0x01	; 1
    1c84:	44 e0       	ldi	r20, 0x04	; 4
    1c86:	50 e0       	ldi	r21, 0x00	; 0
    1c88:	0e 94 e8 3a 	call	0x75d0	; 0x75d0 <memcpy_P>
}
    1c8c:	08 95       	ret

00001c8e <LCD_Init>:
	0xe3,
	0xff // end of array
};

void LCD_Init()
{
    1c8e:	cf 93       	push	r28
    1c90:	df 93       	push	r29
	// pins
	LCD_CS_DIR = OUTPUT;
    1c92:	55 9a       	sbi	0x0a, 5	; 10
	LCD_RST_DIR = OUTPUT;
    1c94:	56 9a       	sbi	0x0a, 6	; 10
	LCD_A0_DIR = OUTPUT;
    1c96:	57 9a       	sbi	0x0a, 7	; 10
	LCD_SCL_DIR = OUTPUT;
    1c98:	54 9a       	sbi	0x0a, 4	; 10
	LCD_SDA_DIR = OUTPUT;
    1c9a:	51 9a       	sbi	0x0a, 1	; 10

	// init display
	LCD_RST = 0;
    1c9c:	5e 98       	cbi	0x0b, 6	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1c9e:	89 ef       	ldi	r24, 0xF9	; 249
    1ca0:	90 e0       	ldi	r25, 0x00	; 0
    1ca2:	01 97       	sbiw	r24, 0x01	; 1
    1ca4:	f1 f7       	brne	.-4      	; 0x1ca2 <LCD_Init+0x14>
    1ca6:	00 c0       	rjmp	.+0      	; 0x1ca8 <LCD_Init+0x1a>
    1ca8:	00 00       	nop
	_delay_ms(1);	// version 0.9.9
	LCD_RST = 1;
    1caa:	5e 9a       	sbi	0x0b, 6	; 11
    1cac:	e9 ef       	ldi	r30, 0xF9	; 249
    1cae:	f0 e0       	ldi	r31, 0x00	; 0
    1cb0:	31 97       	sbiw	r30, 0x01	; 1
    1cb2:	f1 f7       	brne	.-4      	; 0x1cb0 <LCD_Init+0x22>
    1cb4:	00 c0       	rjmp	.+0      	; 0x1cb6 <LCD_Init+0x28>
    1cb6:	00 00       	nop
	_delay_ms(1); // version 0.9.9
	
	const unsigned char* ptr = _initSeq;
	uint8_t c;
	c = pgm_read_byte(ptr++);
    1cb8:	cc e7       	ldi	r28, 0x7C	; 124
    1cba:	d0 e0       	ldi	r29, 0x00	; 0
    1cbc:	fe 01       	movw	r30, r28
    1cbe:	84 91       	lpm	r24, Z+
    1cc0:	21 96       	adiw	r28, 0x01	; 1
	while (c!=0xff)
    1cc2:	06 c0       	rjmp	.+12     	; 0x1cd0 <LCD_Init+0x42>
	{
		sendData(c, LCD_COMMAND);
    1cc4:	60 e0       	ldi	r22, 0x00	; 0
    1cc6:	0e 94 d1 0b 	call	0x17a2	; 0x17a2 <sendData>
    1cca:	fe 01       	movw	r30, r28
		c = pgm_read_byte(ptr++);
    1ccc:	21 96       	adiw	r28, 0x01	; 1
    1cce:	84 91       	lpm	r24, Z+
	_delay_ms(1); // version 0.9.9
	
	const unsigned char* ptr = _initSeq;
	uint8_t c;
	c = pgm_read_byte(ptr++);
	while (c!=0xff)
    1cd0:	8f 3f       	cpi	r24, 0xFF	; 255
    1cd2:	c1 f7       	brne	.-16     	; 0x1cc4 <LCD_Init+0x36>
	{
		sendData(c, LCD_COMMAND);
		c = pgm_read_byte(ptr++);
	}	
	LCD_SelectFont(NULL);		// select default font
    1cd4:	80 e0       	ldi	r24, 0x00	; 0
    1cd6:	90 e0       	ldi	r25, 0x00	; 0
    1cd8:	0e 94 3b 0e 	call	0x1c76	; 0x1c76 <LCD_SelectFont>
	
	// use timer0 with clk/8 and overflow
	// at 256 as interrupt based output of data bytes
	// ie every 1024us one byte is send to display. whole screen takes about 105ms
	TCCR0B = _BV(CS01);		// clk/8
    1cdc:	82 e0       	ldi	r24, 0x02	; 2
    1cde:	85 bd       	out	0x25, r24	; 37
	LCD_Enable();
    1ce0:	0e 94 13 0e 	call	0x1c26	; 0x1c26 <LCD_Enable>
}
    1ce4:	df 91       	pop	r29
    1ce6:	cf 91       	pop	r28
    1ce8:	08 95       	ret

00001cea <LED_FlashOrangeLED>:
#include "../Include/Misc.h"
#include "../Include/IO_config.h"


void LED_FlashOrangeLED (uint16_t msDuration, uint8_t Times)
{
    1cea:	cf 92       	push	r12
    1cec:	df 92       	push	r13
    1cee:	ef 92       	push	r14
    1cf0:	ff 92       	push	r15
    1cf2:	0f 93       	push	r16
    1cf4:	1f 93       	push	r17
    1cf6:	df 93       	push	r29
    1cf8:	cf 93       	push	r28
    1cfa:	0f 92       	push	r0
    1cfc:	cd b7       	in	r28, 0x3d	; 61
    1cfe:	de b7       	in	r29, 0x3e	; 62
    1d00:	6c 01       	movw	r12, r24
	bool CurrentLED_Status = LED_Orange;
    1d02:	25 b1       	in	r18, 0x05	; 5
    1d04:	26 95       	lsr	r18
    1d06:	26 95       	lsr	r18
    1d08:	26 95       	lsr	r18
    1d0a:	21 70       	andi	r18, 0x01	; 1
	
	for (int i=0; i< Times; ++i)
    1d0c:	00 e0       	ldi	r16, 0x00	; 0
    1d0e:	10 e0       	ldi	r17, 0x00	; 0
    1d10:	e6 2e       	mov	r14, r22
    1d12:	ff 24       	eor	r15, r15
    1d14:	24 c0       	rjmp	.+72     	; 0x1d5e <LED_FlashOrangeLED+0x74>
	{
		LED_Orange = ~LED_Orange;
    1d16:	85 b1       	in	r24, 0x05	; 5
    1d18:	86 95       	lsr	r24
    1d1a:	86 95       	lsr	r24
    1d1c:	86 95       	lsr	r24
    1d1e:	80 95       	com	r24
    1d20:	81 70       	andi	r24, 0x01	; 1
    1d22:	88 0f       	add	r24, r24
    1d24:	88 0f       	add	r24, r24
    1d26:	88 0f       	add	r24, r24
    1d28:	95 b1       	in	r25, 0x05	; 5
    1d2a:	97 7f       	andi	r25, 0xF7	; 247
    1d2c:	98 2b       	or	r25, r24
    1d2e:	95 b9       	out	0x05, r25	; 5
		delay_ms(msDuration);
    1d30:	c6 01       	movw	r24, r12
    1d32:	29 83       	std	Y+1, r18	; 0x01
    1d34:	0e 94 d7 0e 	call	0x1dae	; 0x1dae <delay_ms>
		LED_Orange = ~LED_Orange;
    1d38:	85 b1       	in	r24, 0x05	; 5
    1d3a:	86 95       	lsr	r24
    1d3c:	86 95       	lsr	r24
    1d3e:	86 95       	lsr	r24
    1d40:	80 95       	com	r24
    1d42:	81 70       	andi	r24, 0x01	; 1
    1d44:	88 0f       	add	r24, r24
    1d46:	88 0f       	add	r24, r24
    1d48:	88 0f       	add	r24, r24
    1d4a:	95 b1       	in	r25, 0x05	; 5
    1d4c:	97 7f       	andi	r25, 0xF7	; 247
    1d4e:	98 2b       	or	r25, r24
    1d50:	95 b9       	out	0x05, r25	; 5
		delay_ms(msDuration);		
    1d52:	c6 01       	movw	r24, r12
    1d54:	0e 94 d7 0e 	call	0x1dae	; 0x1dae <delay_ms>

void LED_FlashOrangeLED (uint16_t msDuration, uint8_t Times)
{
	bool CurrentLED_Status = LED_Orange;
	
	for (int i=0; i< Times; ++i)
    1d58:	0f 5f       	subi	r16, 0xFF	; 255
    1d5a:	1f 4f       	sbci	r17, 0xFF	; 255
    1d5c:	29 81       	ldd	r18, Y+1	; 0x01
    1d5e:	0e 15       	cp	r16, r14
    1d60:	1f 05       	cpc	r17, r15
    1d62:	cc f2       	brlt	.-78     	; 0x1d16 <LED_FlashOrangeLED+0x2c>
		delay_ms(msDuration);
		LED_Orange = ~LED_Orange;
		delay_ms(msDuration);		
	}
	
	LED_Orange = CurrentLED_Status;
    1d64:	21 70       	andi	r18, 0x01	; 1
    1d66:	22 0f       	add	r18, r18
    1d68:	22 0f       	add	r18, r18
    1d6a:	22 0f       	add	r18, r18
    1d6c:	85 b1       	in	r24, 0x05	; 5
    1d6e:	87 7f       	andi	r24, 0xF7	; 247
    1d70:	82 2b       	or	r24, r18
    1d72:	85 b9       	out	0x05, r24	; 5
	
    1d74:	0f 90       	pop	r0
    1d76:	cf 91       	pop	r28
    1d78:	df 91       	pop	r29
    1d7a:	1f 91       	pop	r17
    1d7c:	0f 91       	pop	r16
    1d7e:	ff 90       	pop	r15
    1d80:	ef 90       	pop	r14
    1d82:	df 90       	pop	r13
    1d84:	cf 90       	pop	r12
    1d86:	08 95       	ret

00001d88 <delay_us>:



void delay_us(uint16_t time)            /* time delay for us */
{ 
 while(time--)
    1d88:	0f c0       	rjmp	.+30     	; 0x1da8 <delay_us+0x20>
	...
	asm volatile ("NOP"); asm volatile ("NOP"); 
	asm volatile ("NOP"); 
	asm volatile ("NOP"); asm volatile ("NOP"); 
	asm volatile ("NOP"); asm volatile ("NOP"); 
	asm volatile ("NOP"); asm volatile ("NOP"); 
	asm volatile ("NOP"); 
    1da6:	01 97       	sbiw	r24, 0x01	; 1



void delay_us(uint16_t time)            /* time delay for us */
{ 
 while(time--)
    1da8:	00 97       	sbiw	r24, 0x00	; 0
    1daa:	79 f7       	brne	.-34     	; 0x1d8a <delay_us+0x2>
	asm volatile ("NOP"); asm volatile ("NOP"); 
	asm volatile ("NOP"); asm volatile ("NOP"); 
	asm volatile ("NOP"); asm volatile ("NOP"); 
	asm volatile ("NOP"); 
 }
}
    1dac:	08 95       	ret

00001dae <delay_ms>:

void delay_ms(uint16_t time)
{
    1dae:	1f 93       	push	r17
    1db0:	cf 93       	push	r28
    1db2:	df 93       	push	r29
    1db4:	ec 01       	movw	r28, r24
	uint8_t i;
	while(time--)
    1db6:	08 c0       	rjmp	.+16     	; 0x1dc8 <delay_ms+0x1a>
    1db8:	1a e0       	ldi	r17, 0x0A	; 10
	{
		for(i=0;i<10;i++) delay_us(100);
    1dba:	84 e6       	ldi	r24, 0x64	; 100
    1dbc:	90 e0       	ldi	r25, 0x00	; 0
    1dbe:	0e 94 c4 0e 	call	0x1d88	; 0x1d88 <delay_us>
    1dc2:	11 50       	subi	r17, 0x01	; 1
    1dc4:	d1 f7       	brne	.-12     	; 0x1dba <delay_ms+0xc>
    1dc6:	21 97       	sbiw	r28, 0x01	; 1
}

void delay_ms(uint16_t time)
{
	uint8_t i;
	while(time--)
    1dc8:	20 97       	sbiw	r28, 0x00	; 0
    1dca:	b1 f7       	brne	.-20     	; 0x1db8 <delay_ms+0xa>
	{
		for(i=0;i<10;i++) delay_us(100);
	}
}
    1dcc:	df 91       	pop	r29
    1dce:	cf 91       	pop	r28
    1dd0:	1f 91       	pop	r17
    1dd2:	08 95       	ret

00001dd4 <Ultrasonic_Init>:
#include "..\Include\Ultrasonic.h"


void Ultrasonic_Init ()
{
	RX_SONAR_TRIGGER_DIR = OUTPUT;
    1dd4:	50 9a       	sbi	0x0a, 0	; 10
	RX_SONAR_TRIGGER=HIGH;   // Active LOW
    1dd6:	48 9a       	sbi	0x09, 0	; 9
	RX_SONAR_DIR = INPUT;
    1dd8:	22 98       	cbi	0x04, 2	; 4
	
	// enable interrupts
	EICRA  = _BV(ISC20);	// any edge on INT2
    1dda:	80 e1       	ldi	r24, 0x10	; 16
    1ddc:	80 93 69 00 	sts	0x0069, r24
	EIMSK  = _BV(INT2);	// enable interrupt for INT0, INT1 and INT2
    1de0:	84 e0       	ldi	r24, 0x04	; 4
    1de2:	8d bb       	out	0x1d, r24	; 29
	EIFR   = _BV(INTF2);	// clear interrupts
    1de4:	8c bb       	out	0x1c, r24	; 28
		
	
}
    1de6:	08 95       	ret

00001de8 <Disarm>:
#include "Include/Beeper.h"


void Disarm (void)
{
	IsArmed = false;
    1de8:	10 92 85 07 	sts	0x0785, r1
	//LED_FlashOrangeLED (LED_SHORT_TOGGLE,4);
	LED_Orange = OFF;
    1dec:	2b 98       	cbi	0x05, 3	; 5
	
	TCNT1_X_snapshot1 =0; // reset timer
    1dee:	10 92 e9 05 	sts	0x05E9, r1
    1df2:	10 92 e8 05 	sts	0x05E8, r1
	Beeper_Beep(BEEP_SHORT,2);				
    1df6:	86 e4       	ldi	r24, 0x46	; 70
    1df8:	90 e0       	ldi	r25, 0x00	; 0
    1dfa:	62 e0       	ldi	r22, 0x02	; 2
    1dfc:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <Beeper_Beep>
	Menu_LoadPage (PAGE_HOME);
    1e00:	80 e0       	ldi	r24, 0x00	; 0
    1e02:	90 e0       	ldi	r25, 0x00	; 0
    1e04:	0e 94 de 2e 	call	0x5dbc	; 0x5dbc <Menu_LoadPage>
}
    1e08:	08 95       	ret

00001e0a <Arm>:


void Arm (void)
{
	if ((Config.FrameType == FRAMETYPE_TRICOPTER) && (Config.BoardOrientationMode==QuadFlyingMode_X))
    1e0a:	80 91 d8 06 	lds	r24, 0x06D8
    1e0e:	82 30       	cpi	r24, 0x02	; 2
    1e10:	39 f4       	brne	.+14     	; 0x1e20 <Arm+0x16>
    1e12:	80 91 d9 06 	lds	r24, 0x06D9
    1e16:	81 30       	cpi	r24, 0x01	; 1
    1e18:	19 f4       	brne	.+6      	; 0x1e20 <Arm+0x16>
	{ // NOT VALID CONFIGURATION
		Disarm();
    1e1a:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <Disarm>
		
		return;
    1e1e:	08 95       	ret
	}
	
			
	IsArmed = true;
    1e20:	81 e0       	ldi	r24, 0x01	; 1
    1e22:	80 93 85 07 	sts	0x0785, r24
	LED_FlashOrangeLED (LED_SHORT_TOGGLE,4);
    1e26:	8e e1       	ldi	r24, 0x1E	; 30
    1e28:	90 e0       	ldi	r25, 0x00	; 0
    1e2a:	64 e0       	ldi	r22, 0x04	; 4
    1e2c:	70 e0       	ldi	r23, 0x00	; 0
    1e2e:	0e 94 75 0e 	call	0x1cea	; 0x1cea <LED_FlashOrangeLED>
	LED_Orange = ON;
    1e32:	2b 9a       	sbi	0x05, 3	; 5
	Beeper_Beep(BEEP_LONG,1);				
    1e34:	8c eb       	ldi	r24, 0xBC	; 188
    1e36:	92 e0       	ldi	r25, 0x02	; 2
    1e38:	61 e0       	ldi	r22, 0x01	; 1
    1e3a:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <Beeper_Beep>
	
	TCNT1_X_snapshot1 =0; // reset timer
    1e3e:	10 92 e9 05 	sts	0x05E9, r1
    1e42:	10 92 e8 05 	sts	0x05E8, r1
	TCNT_X_snapshotAutoDisarm=0;				
    1e46:	10 92 1e 06 	sts	0x061E, r1
    1e4a:	10 92 1d 06 	sts	0x061D, r1
	Menu_LoadPage (PAGE_HOME_ARMED);
    1e4e:	82 e0       	ldi	r24, 0x02	; 2
    1e50:	90 e0       	ldi	r25, 0x00	; 0
    1e52:	0e 94 de 2e 	call	0x5dbc	; 0x5dbc <Menu_LoadPage>
	
	PID_GyroTerms[0].I=0;
    1e56:	80 e0       	ldi	r24, 0x00	; 0
    1e58:	90 e0       	ldi	r25, 0x00	; 0
    1e5a:	dc 01       	movw	r26, r24
    1e5c:	80 93 68 06 	sts	0x0668, r24
    1e60:	90 93 69 06 	sts	0x0669, r25
    1e64:	a0 93 6a 06 	sts	0x066A, r26
    1e68:	b0 93 6b 06 	sts	0x066B, r27
	PID_GyroTerms[1].I=0;
    1e6c:	80 93 80 06 	sts	0x0680, r24
    1e70:	90 93 81 06 	sts	0x0681, r25
    1e74:	a0 93 82 06 	sts	0x0682, r26
    1e78:	b0 93 83 06 	sts	0x0683, r27
	PID_GyroTerms[2].I=0;
    1e7c:	80 93 98 06 	sts	0x0698, r24
    1e80:	90 93 99 06 	sts	0x0699, r25
    1e84:	a0 93 9a 06 	sts	0x069A, r26
    1e88:	b0 93 9b 06 	sts	0x069B, r27
	PID_AccTerms [0].I=0;
    1e8c:	80 93 54 05 	sts	0x0554, r24
    1e90:	90 93 55 05 	sts	0x0555, r25
    1e94:	a0 93 56 05 	sts	0x0556, r26
    1e98:	b0 93 57 05 	sts	0x0557, r27
	PID_AccTerms [1].I=0;
    1e9c:	80 93 6c 05 	sts	0x056C, r24
    1ea0:	90 93 6d 05 	sts	0x056D, r25
    1ea4:	a0 93 6e 05 	sts	0x056E, r26
    1ea8:	b0 93 6f 05 	sts	0x056F, r27
	PID_AccTerms [2].I=0;
    1eac:	80 93 84 05 	sts	0x0584, r24
    1eb0:	90 93 85 05 	sts	0x0585, r25
    1eb4:	a0 93 86 05 	sts	0x0586, r26
    1eb8:	b0 93 87 05 	sts	0x0587, r27
    1ebc:	08 95       	ret

00001ebe <Set_EEPROM_Default_Config>:
	Save_Config_to_EEPROM();
}

void Set_EEPROM_Default_Config(void)
{
	memcpy_P ( &Config, &defaultConfig, sizeof(config_t));
    1ebe:	81 ed       	ldi	r24, 0xD1	; 209
    1ec0:	96 e0       	ldi	r25, 0x06	; 6
    1ec2:	64 e9       	ldi	r22, 0x94	; 148
    1ec4:	70 e0       	ldi	r23, 0x00	; 0
    1ec6:	4c e9       	ldi	r20, 0x9C	; 156
    1ec8:	50 e0       	ldi	r21, 0x00	; 0
    1eca:	0e 94 e8 3a 	call	0x75d0	; 0x75d0 <memcpy_P>
}
    1ece:	08 95       	ret

00001ed0 <eeprom_write_byte_changed>:
	}
}


void eeprom_write_byte_changed( uint8_t * addr, uint8_t value )
{ 
    1ed0:	0f 93       	push	r16
    1ed2:	1f 93       	push	r17
    1ed4:	df 93       	push	r29
    1ed6:	cf 93       	push	r28
    1ed8:	0f 92       	push	r0
    1eda:	cd b7       	in	r28, 0x3d	; 61
    1edc:	de b7       	in	r29, 0x3e	; 62
    1ede:	8c 01       	movw	r16, r24
	if(eeprom_read_byte(addr) != value)
    1ee0:	69 83       	std	Y+1, r22	; 0x01
    1ee2:	0e 94 5c 3b 	call	0x76b8	; 0x76b8 <__eerd_byte_m324pa>
    1ee6:	69 81       	ldd	r22, Y+1	; 0x01
    1ee8:	86 17       	cp	r24, r22
    1eea:	19 f0       	breq	.+6      	; 0x1ef2 <eeprom_write_byte_changed+0x22>
	{
		eeprom_write_byte( addr, value );
    1eec:	c8 01       	movw	r24, r16
    1eee:	0e 94 64 3b 	call	0x76c8	; 0x76c8 <__eewr_byte_m324pa>
	}
}
    1ef2:	0f 90       	pop	r0
    1ef4:	cf 91       	pop	r28
    1ef6:	df 91       	pop	r29
    1ef8:	1f 91       	pop	r17
    1efa:	0f 91       	pop	r16
    1efc:	08 95       	ret

00001efe <eeprom_write_block_changes>:
	eeprom_write_block_changes( (const void*) &Config, (void*) EEPROM_DATA_START_POS, sizeof(config_t));	//current_config CONFIG_STRUCT
	
}

void eeprom_write_block_changes( const uint8_t * src, void * dest, size_t size )
{ 
    1efe:	cf 92       	push	r12
    1f00:	df 92       	push	r13
    1f02:	ef 92       	push	r14
    1f04:	ff 92       	push	r15
    1f06:	0f 93       	push	r16
    1f08:	1f 93       	push	r17
    1f0a:	cf 93       	push	r28
    1f0c:	df 93       	push	r29
    1f0e:	ec 01       	movw	r28, r24
    1f10:	7b 01       	movw	r14, r22
    1f12:	6a 01       	movw	r12, r20
	size_t len;

	for(len=0;len<size;len++)
    1f14:	00 e0       	ldi	r16, 0x00	; 0
    1f16:	10 e0       	ldi	r17, 0x00	; 0
    1f18:	08 c0       	rjmp	.+16     	; 0x1f2a <eeprom_write_block_changes+0x2c>
	{
		eeprom_write_byte_changed( dest,  *src );
    1f1a:	c7 01       	movw	r24, r14
    1f1c:	80 0f       	add	r24, r16
    1f1e:	91 1f       	adc	r25, r17
    1f20:	69 91       	ld	r22, Y+
    1f22:	0e 94 68 0f 	call	0x1ed0	; 0x1ed0 <eeprom_write_byte_changed>

void eeprom_write_block_changes( const uint8_t * src, void * dest, size_t size )
{ 
	size_t len;

	for(len=0;len<size;len++)
    1f26:	0f 5f       	subi	r16, 0xFF	; 255
    1f28:	1f 4f       	sbci	r17, 0xFF	; 255
    1f2a:	0c 15       	cp	r16, r12
    1f2c:	1d 05       	cpc	r17, r13
    1f2e:	a8 f3       	brcs	.-22     	; 0x1f1a <eeprom_write_block_changes+0x1c>
		eeprom_write_byte_changed( dest,  *src );

		src++;
		dest++;
	}
}
    1f30:	df 91       	pop	r29
    1f32:	cf 91       	pop	r28
    1f34:	1f 91       	pop	r17
    1f36:	0f 91       	pop	r16
    1f38:	ff 90       	pop	r15
    1f3a:	ef 90       	pop	r14
    1f3c:	df 90       	pop	r13
    1f3e:	cf 90       	pop	r12
    1f40:	08 95       	ret

00001f42 <Load_Config_from_EEPROM>:

void Load_Config_from_EEPROM(void)
{
	// write to eeProm
	
	eeprom_write_block_changes( (const void*) &Config, (void*) EEPROM_DATA_START_POS, sizeof(config_t));	//current_config CONFIG_STRUCT
    1f42:	81 ed       	ldi	r24, 0xD1	; 209
    1f44:	96 e0       	ldi	r25, 0x06	; 6
    1f46:	60 e0       	ldi	r22, 0x00	; 0
    1f48:	70 e0       	ldi	r23, 0x00	; 0
    1f4a:	4c e9       	ldi	r20, 0x9C	; 156
    1f4c:	50 e0       	ldi	r21, 0x00	; 0
    1f4e:	0e 94 7f 0f 	call	0x1efe	; 0x1efe <eeprom_write_block_changes>
	
}
    1f52:	08 95       	ret

00001f54 <Save_Config_to_EEPROM>:
}

void Save_Config_to_EEPROM(void)
{
	// write to eeProm
	cli();
    1f54:	f8 94       	cli
	eeprom_write_block_changes( (const void*) &Config, (void*) EEPROM_DATA_START_POS, sizeof(config_t));	//current_config CONFIG_STRUCT
    1f56:	81 ed       	ldi	r24, 0xD1	; 209
    1f58:	96 e0       	ldi	r25, 0x06	; 6
    1f5a:	60 e0       	ldi	r22, 0x00	; 0
    1f5c:	70 e0       	ldi	r23, 0x00	; 0
    1f5e:	4c e9       	ldi	r20, 0x9C	; 156
    1f60:	50 e0       	ldi	r21, 0x00	; 0
    1f62:	0e 94 7f 0f 	call	0x1efe	; 0x1efe <eeprom_write_block_changes>
	sei();
    1f66:	78 94       	sei
	
	Beeper_Beep(BEEP_LONG,1);	
    1f68:	8c eb       	ldi	r24, 0xBC	; 188
    1f6a:	92 e0       	ldi	r25, 0x02	; 2
    1f6c:	61 e0       	ldi	r22, 0x01	; 1
    1f6e:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <Beeper_Beep>
}
    1f72:	08 95       	ret

00001f74 <Save_Default_Config_to_EEPROM>:

void Save_Default_Config_to_EEPROM (void)
{
	
	// copy default config to config.
	Set_EEPROM_Default_Config();
    1f74:	0e 94 5f 0f 	call	0x1ebe	; 0x1ebe <Set_EEPROM_Default_Config>
    1f78:	e8 e2       	ldi	r30, 0x28	; 40
    1f7a:	f7 e0       	ldi	r31, 0x07	; 7
	
	
	// Init values.
	for (uint8_t i = 0; i < RXChannels; i++)
	{
		Config.RX_Mid[0][i] = PWM_MID;
    1f7c:	20 ef       	ldi	r18, 0xF0	; 240
    1f7e:	35 e0       	ldi	r19, 0x05	; 5
		Config.RX_Min[0][i] = PWM_LOW;
    1f80:	80 e6       	ldi	r24, 0x60	; 96
    1f82:	94 e0       	ldi	r25, 0x04	; 4
	
	
	// Init values.
	for (uint8_t i = 0; i < RXChannels; i++)
	{
		Config.RX_Mid[0][i] = PWM_MID;
    1f84:	21 93       	st	Z+, r18
    1f86:	31 93       	st	Z+, r19
		Config.RX_Min[0][i] = PWM_LOW;
    1f88:	93 8b       	std	Z+19, r25	; 0x13
    1f8a:	82 8b       	std	Z+18, r24	; 0x12
		Config.RX_Mid[1][i] = PWM_MID;
    1f8c:	31 87       	std	Z+9, r19	; 0x09
    1f8e:	20 87       	std	Z+8, r18	; 0x08
		Config.RX_Min[1][i] = PWM_LOW;
    1f90:	95 8f       	std	Z+29, r25	; 0x1d
    1f92:	84 8f       	std	Z+28, r24	; 0x1c
	// copy default config to config.
	Set_EEPROM_Default_Config();
	
	
	// Init values.
	for (uint8_t i = 0; i < RXChannels; i++)
    1f94:	47 e0       	ldi	r20, 0x07	; 7
    1f96:	e2 33       	cpi	r30, 0x32	; 50
    1f98:	f4 07       	cpc	r31, r20
    1f9a:	a1 f7       	brne	.-24     	; 0x1f84 <Save_Default_Config_to_EEPROM+0x10>
		Config.RX_Mid[1][i] = PWM_MID;
		Config.RX_Min[1][i] = PWM_LOW;
	}	
	
	// write to eeProm
	Save_Config_to_EEPROM();
    1f9c:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <Save_Config_to_EEPROM>
}
    1fa0:	08 95       	ret

00001fa2 <Initial_EEPROM_Config_Load>:


void Initial_EEPROM_Config_Load(void)
{
	// load up last settings from EEPROM
	if(eeprom_read_byte((uint8_t*) EEPROM_DATA_START_POS )!=HEFNYCOPTER2_SIGNATURE)
    1fa2:	80 e0       	ldi	r24, 0x00	; 0
    1fa4:	90 e0       	ldi	r25, 0x00	; 0
    1fa6:	0e 94 5c 3b 	call	0x76b8	; 0x76b8 <__eerd_byte_m324pa>
    1faa:	8e 3f       	cpi	r24, 0xFE	; 254
    1fac:	19 f0       	breq	.+6      	; 0x1fb4 <Initial_EEPROM_Config_Load+0x12>
	{
		Save_Default_Config_to_EEPROM();
    1fae:	0e 94 ba 0f 	call	0x1f74	; 0x1f74 <Save_Default_Config_to_EEPROM>
    1fb2:	08 95       	ret
		
	} else {
		// read eeprom
		eeprom_read_block(&Config, (void*) EEPROM_DATA_START_POS, sizeof(config_t)); 
    1fb4:	81 ed       	ldi	r24, 0xD1	; 209
    1fb6:	96 e0       	ldi	r25, 0x06	; 6
    1fb8:	60 e0       	ldi	r22, 0x00	; 0
    1fba:	70 e0       	ldi	r23, 0x00	; 0
    1fbc:	4c e9       	ldi	r20, 0x9C	; 156
    1fbe:	50 e0       	ldi	r21, 0x00	; 0
    1fc0:	0e 94 4c 3b 	call	0x7698	; 0x7698 <__eerd_block_m324pa>
    1fc4:	08 95       	ret

00001fc6 <__vector_15>:
*/

//volatile uint32_t x=0;

ISR(TIMER1_OVF_vect)
{
    1fc6:	1f 92       	push	r1
    1fc8:	0f 92       	push	r0
    1fca:	0f b6       	in	r0, 0x3f	; 63
    1fcc:	0f 92       	push	r0
    1fce:	11 24       	eor	r1, r1
    1fd0:	8f 93       	push	r24
    1fd2:	9f 93       	push	r25
	
	TCNT1_X++; // click every 0.0032768 sec [1 sec = 305.17578125 TCNT1_X] overflows every 214.7483648 sec = 3.579 min
    1fd4:	80 91 5e 06 	lds	r24, 0x065E
    1fd8:	90 91 5f 06 	lds	r25, 0x065F
    1fdc:	01 96       	adiw	r24, 0x01	; 1
    1fde:	90 93 5f 06 	sts	0x065F, r25
    1fe2:	80 93 5e 06 	sts	0x065E, r24
	//TCNT1_X_GlobalTimer +=32;  // 0.0032768
}
    1fe6:	9f 91       	pop	r25
    1fe8:	8f 91       	pop	r24
    1fea:	0f 90       	pop	r0
    1fec:	0f be       	out	0x3f, r0	; 63
    1fee:	0f 90       	pop	r0
    1ff0:	1f 90       	pop	r1
    1ff2:	18 95       	reti

00001ff4 <__vector_11>:


ISR(TIMER2_OVF_vect)
{
    1ff4:	1f 92       	push	r1
    1ff6:	0f 92       	push	r0
    1ff8:	0f b6       	in	r0, 0x3f	; 63
    1ffa:	0f 92       	push	r0
    1ffc:	11 24       	eor	r1, r1
    1ffe:	8f 93       	push	r24
    2000:	9f 93       	push	r25
	TCNT2_X++; 
    2002:	80 91 bd 05 	lds	r24, 0x05BD
    2006:	90 91 be 05 	lds	r25, 0x05BE
    200a:	01 96       	adiw	r24, 0x01	; 1
    200c:	90 93 be 05 	sts	0x05BE, r25
    2010:	80 93 bd 05 	sts	0x05BD, r24
}	
    2014:	9f 91       	pop	r25
    2016:	8f 91       	pop	r24
    2018:	0f 90       	pop	r0
    201a:	0f be       	out	0x3f, r0	; 63
    201c:	0f 90       	pop	r0
    201e:	1f 90       	pop	r1
    2020:	18 95       	reti

00002022 <Timer_Init>:
{
	
	//TIMER ZERO is RESERVED for LCD DISPLAY.	
	
	// Timer1 @20MHz with overflow interrupt
	TCCR1B = _BV(CS10);
    2022:	81 e0       	ldi	r24, 0x01	; 1
    2024:	80 93 81 00 	sts	0x0081, r24
	TIMSK1 = _BV(TOIE1);
    2028:	80 93 6f 00 	sts	0x006F, r24
	TCNT1_X =0;
    202c:	10 92 5f 06 	sts	0x065F, r1
    2030:	10 92 5e 06 	sts	0x065E, r1
			1 0 0		clkT2S/64 (From prescaler)
			1 0 1		clkT2S/128 (From prescaler)
			1 1 0		clkT2S/256 (From prescaler)
			1 1 1		clkT2S/1024 (From prescaler)
	*/
	TCCR2B  = (1 << CS21) | (1 << CS20);	//  div by 32	
    2034:	93 e0       	ldi	r25, 0x03	; 3
    2036:	90 93 b1 00 	sts	0x00B1, r25
	TIMSK2  = _BV(TOIE2); 
    203a:	80 93 70 00 	sts	0x0070, r24
	TIFR2   = 0;
    203e:	17 ba       	out	0x17, r1	; 23
	TCNT2	= 0;		// this overflows every  1.6us x 0xff = 409.6 us,  value tick 1.6us
    2040:	10 92 b2 00 	sts	0x00B2, r1
	TCNT2_X = 0;
    2044:	10 92 be 05 	sts	0x05BE, r1
    2048:	10 92 bd 05 	sts	0x05BD, r1
	/* IMPORTANT TCNT2 is used completly by motor and is reset during ESC pulse generation so you cannot depend on it for other purpose
	unless it is not time critical and no accuracy is required such as UI delays*/
	// tick: 12.8u  ov:3.2768ms	: TCNT2_X OV:  214.7483648 sec

    204c:	08 95       	ret

0000204e <UART_Init>:
	
}

void UART_Init( unsigned int ubrr)
{
	if (Config.RX_mode==RX_mode_UARTMode)
    204e:	20 91 d3 06 	lds	r18, 0x06D3
    2052:	2f 3f       	cpi	r18, 0xFF	; 255
    2054:	61 f4       	brne	.+24     	; 0x206e <UART_Init+0x20>
	{
		//memcpy(DisplayBuffer,"STR",3);
		RXIndex=0;
    2056:	10 92 1f 05 	sts	0x051F, r1
		/*Set baud rate */
		UBRR1H = (unsigned char)(ubrr>>8);	
    205a:	90 93 cd 00 	sts	0x00CD, r25
		UBRR1L = (unsigned char)ubrr;
    205e:	80 93 cc 00 	sts	0x00CC, r24
		
		//UCSR1A = (1 << U2X1); // doubling divisor rate;
		// Set frame format to 8 data bits, no parity, 1 stop bit
		UCSR1C = (0<<USBS1)|(1<<UCSZ11)|(1<<UCSZ10);
    2062:	86 e0       	ldi	r24, 0x06	; 6
    2064:	80 93 ca 00 	sts	0x00CA, r24
		// Enable receiver and transmitter
		UCSR1B =  (1<<TXEN1)	// Enable USART TX
    2068:	88 e9       	ldi	r24, 0x98	; 152
    206a:	80 93 c9 00 	sts	0x00C9, r24
    206e:	08 95       	ret

00002070 <send_byte>:

void send_byte(uint8_t u8Data)
{

	// Wait if a byte is being transmitted
	while((UCSR1A & (1<<UDRE1)) == 0);
    2070:	90 91 c8 00 	lds	r25, 0x00C8
    2074:	95 ff       	sbrs	r25, 5
    2076:	fc cf       	rjmp	.-8      	; 0x2070 <send_byte>
	// Transmit data
	/////////delay_ms(10);
	UDR1 = u8Data;
    2078:	80 93 ce 00 	sts	0x00CE, r24
}
    207c:	08 95       	ret

0000207e <Send_Data>:


void Send_Data (void * msg, uint8_t len)
{
    207e:	ef 92       	push	r14
    2080:	ff 92       	push	r15
    2082:	0f 93       	push	r16
    2084:	1f 93       	push	r17
    2086:	cf 93       	push	r28
    2088:	df 93       	push	r29
	
	for (int i=0; i<len;++i)
    208a:	08 2f       	mov	r16, r24
    208c:	19 2f       	mov	r17, r25
    208e:	c0 e0       	ldi	r28, 0x00	; 0
    2090:	d0 e0       	ldi	r29, 0x00	; 0
    2092:	e6 2e       	mov	r14, r22
    2094:	ff 24       	eor	r15, r15
    2096:	06 c0       	rjmp	.+12     	; 0x20a4 <Send_Data+0x26>
	{
		send_byte (((uint8_t *)msg)[i]);
    2098:	f8 01       	movw	r30, r16
    209a:	81 91       	ld	r24, Z+
    209c:	8f 01       	movw	r16, r30
    209e:	0e 94 38 10 	call	0x2070	; 0x2070 <send_byte>


void Send_Data (void * msg, uint8_t len)
{
	
	for (int i=0; i<len;++i)
    20a2:	21 96       	adiw	r28, 0x01	; 1
    20a4:	ce 15       	cp	r28, r14
    20a6:	df 05       	cpc	r29, r15
    20a8:	bc f3       	brlt	.-18     	; 0x2098 <Send_Data+0x1a>
	{
		send_byte (((uint8_t *)msg)[i]);
	}
	
	
}
    20aa:	df 91       	pop	r29
    20ac:	cf 91       	pop	r28
    20ae:	1f 91       	pop	r17
    20b0:	0f 91       	pop	r16
    20b2:	ff 90       	pop	r15
    20b4:	ef 90       	pop	r14
    20b6:	08 95       	ret

000020b8 <ParseCommand>:
}


void ParseCommand ()
{
	if (IsArmed==true)
    20b8:	80 91 85 07 	lds	r24, 0x0785
    20bc:	81 30       	cpi	r24, 0x01	; 1
    20be:	09 f4       	brne	.+2      	; 0x20c2 <ParseCommand+0xa>
    20c0:	5c c0       	rjmp	.+184    	; 0x217a <ParseCommand+0xc2>
    20c2:	80 e0       	ldi	r24, 0x00	; 0
    20c4:	90 e0       	ldi	r25, 0x00	; 0
    20c6:	20 e0       	ldi	r18, 0x00	; 0
		return ;
	}		
	int8_t CRC=0;
	for (int i=0;i < SERIAL_BUFFERSIZE_1; ++i)
	{
		CRC +=RXBuffer[i];
    20c8:	fc 01       	movw	r30, r24
    20ca:	ea 56       	subi	r30, 0x6A	; 106
    20cc:	f8 4f       	sbci	r31, 0xF8	; 248
    20ce:	30 81       	ld	r19, Z
    20d0:	23 0f       	add	r18, r19
	{
		//Just ignore for safty reasons....some commands generate beeps or flash led that call delay function which will crash your quadcopter if called.
		return ;
	}		
	int8_t CRC=0;
	for (int i=0;i < SERIAL_BUFFERSIZE_1; ++i)
    20d2:	01 96       	adiw	r24, 0x01	; 1
    20d4:	88 30       	cpi	r24, 0x08	; 8
    20d6:	91 05       	cpc	r25, r1
    20d8:	b9 f7       	brne	.-18     	; 0x20c8 <ParseCommand+0x10>
	{
		CRC +=RXBuffer[i];
	}
	if (CRC == (int8_t)RXBuffer[SERIAL_CRC_OFFSET])
    20da:	80 91 9e 07 	lds	r24, 0x079E
    20de:	28 17       	cp	r18, r24
    20e0:	09 f0       	breq	.+2      	; 0x20e4 <ParseCommand+0x2c>
    20e2:	4b c0       	rjmp	.+150    	; 0x217a <ParseCommand+0xc2>
	{
		switch (RXBuffer[SERIAL_HEADER])
    20e4:	80 91 96 07 	lds	r24, 0x0796
    20e8:	83 34       	cpi	r24, 0x43	; 67
    20ea:	21 f0       	breq	.+8      	; 0x20f4 <ParseCommand+0x3c>
    20ec:	86 35       	cpi	r24, 0x56	; 86
    20ee:	09 f0       	breq	.+2      	; 0x20f2 <ParseCommand+0x3a>
    20f0:	44 c0       	rjmp	.+136    	; 0x217a <ParseCommand+0xc2>
    20f2:	2a c0       	rjmp	.+84     	; 0x2148 <ParseCommand+0x90>
		{
			case SERIAL_HEADER_DOCMD:
				switch (RXBuffer[SERIAL_CMD_ID])
    20f4:	80 91 97 07 	lds	r24, 0x0797
    20f8:	85 30       	cpi	r24, 0x05	; 5
    20fa:	81 f0       	breq	.+32     	; 0x211c <ParseCommand+0x64>
    20fc:	86 30       	cpi	r24, 0x06	; 6
    20fe:	18 f4       	brcc	.+6      	; 0x2106 <ParseCommand+0x4e>
    2100:	81 30       	cpi	r24, 0x01	; 1
    2102:	d9 f5       	brne	.+118    	; 0x217a <ParseCommand+0xc2>
    2104:	05 c0       	rjmp	.+10     	; 0x2110 <ParseCommand+0x58>
    2106:	86 30       	cpi	r24, 0x06	; 6
    2108:	c9 f0       	breq	.+50     	; 0x213c <ParseCommand+0x84>
    210a:	87 30       	cpi	r24, 0x07	; 7
    210c:	b1 f5       	brne	.+108    	; 0x217a <ParseCommand+0xc2>
    210e:	19 c0       	rjmp	.+50     	; 0x2142 <ParseCommand+0x8a>
				{
					case SERIAL_CMD_LED_BLINK: // never  call while ARMED .... calling delay function will affect motor speed.
						LED_FlashOrangeLED (LED_SHORT_TOGGLE,4);
    2110:	8e e1       	ldi	r24, 0x1E	; 30
    2112:	90 e0       	ldi	r25, 0x00	; 0
    2114:	64 e0       	ldi	r22, 0x04	; 4
    2116:	0e 94 75 0e 	call	0x1cea	; 0x1cea <LED_FlashOrangeLED>
					break;
    211a:	08 95       	ret
					case SERIAL_CMD_READ_CONFIG:
						Send_Data("C",1);
    211c:	80 e0       	ldi	r24, 0x00	; 0
    211e:	91 e0       	ldi	r25, 0x01	; 1
    2120:	61 e0       	ldi	r22, 0x01	; 1
    2122:	0e 94 3f 10 	call	0x207e	; 0x207e <Send_Data>
						Send_Data(&Config,86);
    2126:	81 ed       	ldi	r24, 0xD1	; 209
    2128:	96 e0       	ldi	r25, 0x06	; 6
    212a:	66 e5       	ldi	r22, 0x56	; 86
    212c:	0e 94 3f 10 	call	0x207e	; 0x207e <Send_Data>
						Send_Data("E",1);
    2130:	82 e0       	ldi	r24, 0x02	; 2
    2132:	91 e0       	ldi	r25, 0x01	; 1
    2134:	61 e0       	ldi	r22, 0x01	; 1
    2136:	0e 94 3f 10 	call	0x207e	; 0x207e <Send_Data>
					break;
    213a:	08 95       	ret
					case SERIAL_CMD_SAVE_CONFIG:
						Save_Config_to_EEPROM();
    213c:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <Save_Config_to_EEPROM>
					break;
    2140:	08 95       	ret
					case SERIAL_CMD_CALIBRATE_ACC:
						Sensors_Calibrate();								
    2142:	0e 94 06 29 	call	0x520c	; 0x520c <Sensors_Calibrate>
					break;
    2146:	08 95       	ret
				}
			break;
			case SERIAL_HEADER_SETVALUE:
				//LED_FlashOrangeLED (LED_SHORT_TOGGLE,4);
				memcpy ((void *)&Config + RXBuffer[SERIAL_DATA_OFFSET] + (RXBuffer[SERIAL_DATA_OFFSET+1] * 0xff),(void *) &RXBuffer[SERIAL_DATA_VALUE], (int8_t) RXBuffer[SERIAL_DATA_LENGHT]);
    2148:	80 91 97 07 	lds	r24, 0x0797
    214c:	60 91 98 07 	lds	r22, 0x0798
    2150:	40 91 99 07 	lds	r20, 0x0799
    2154:	9f ef       	ldi	r25, 0xFF	; 255
    2156:	69 9f       	mul	r22, r25
    2158:	b0 01       	movw	r22, r0
    215a:	11 24       	eor	r1, r1
    215c:	68 0f       	add	r22, r24
    215e:	71 1d       	adc	r23, r1
    2160:	6f 52       	subi	r22, 0x2F	; 47
    2162:	79 4f       	sbci	r23, 0xF9	; 249
    2164:	24 2f       	mov	r18, r20
    2166:	33 27       	eor	r19, r19
    2168:	27 fd       	sbrc	r18, 7
    216a:	30 95       	com	r19
    216c:	ea e9       	ldi	r30, 0x9A	; 154
    216e:	f7 e0       	ldi	r31, 0x07	; 7
    2170:	cb 01       	movw	r24, r22
    2172:	bf 01       	movw	r22, r30
    2174:	53 2f       	mov	r21, r19
    2176:	0e 94 01 3b 	call	0x7602	; 0x7602 <memcpy>
    217a:	08 95       	ret

0000217c <__vector_28>:
  
  
void ParseCommand();

ISR (USART1_RX_vect)
{
    217c:	1f 92       	push	r1
    217e:	0f 92       	push	r0
    2180:	0f b6       	in	r0, 0x3f	; 63
    2182:	0f 92       	push	r0
    2184:	11 24       	eor	r1, r1
    2186:	2f 93       	push	r18
    2188:	3f 93       	push	r19
    218a:	4f 93       	push	r20
    218c:	5f 93       	push	r21
    218e:	6f 93       	push	r22
    2190:	7f 93       	push	r23
    2192:	8f 93       	push	r24
    2194:	9f 93       	push	r25
    2196:	af 93       	push	r26
    2198:	bf 93       	push	r27
    219a:	ef 93       	push	r30
    219c:	ff 93       	push	r31
	 while ( !(UCSR1A & (1<<RXC1))); 
    219e:	80 91 c8 00 	lds	r24, 0x00C8
    21a2:	87 ff       	sbrs	r24, 7
    21a4:	fc cf       	rjmp	.-8      	; 0x219e <__vector_28+0x22>
	 RXChar = UDR1;
    21a6:	80 91 ce 00 	lds	r24, 0x00CE
    21aa:	80 93 91 07 	sts	0x0791, r24
	 
	  if ((c_state!=IDLE) && (TCNT1_X - LastRXTime) > 20) 
    21ae:	80 91 20 05 	lds	r24, 0x0520
    21b2:	88 23       	and	r24, r24
    21b4:	99 f0       	breq	.+38     	; 0x21dc <__vector_28+0x60>
    21b6:	80 91 5e 06 	lds	r24, 0x065E
    21ba:	90 91 5f 06 	lds	r25, 0x065F
    21be:	20 91 92 07 	lds	r18, 0x0792
    21c2:	30 91 93 07 	lds	r19, 0x0793
    21c6:	82 1b       	sub	r24, r18
    21c8:	93 0b       	sbc	r25, r19
    21ca:	85 31       	cpi	r24, 0x15	; 21
    21cc:	91 05       	cpc	r25, r1
    21ce:	30 f0       	brcs	.+12     	; 0x21dc <__vector_28+0x60>
	   {
		   // timeout ..
		   c_state = IDLE;
    21d0:	10 92 20 05 	sts	0x0520, r1
		   RXIndex =0;
    21d4:	10 92 1f 05 	sts	0x051F, r1
		   DisplayBuffer[4]=0;
    21d8:	10 92 8b 07 	sts	0x078B, r1
		   //memcpy(DisplayBuffer,"OUT",3);
		   //return ;
	   }
	   RXBuffer[RXIndex]=RXChar;
    21dc:	e0 91 1f 05 	lds	r30, 0x051F
    21e0:	f0 e0       	ldi	r31, 0x00	; 0
    21e2:	80 91 91 07 	lds	r24, 0x0791
    21e6:	ea 56       	subi	r30, 0x6A	; 106
    21e8:	f8 4f       	sbci	r31, 0xF8	; 248
    21ea:	80 83       	st	Z, r24
	   switch (c_state)
    21ec:	80 91 20 05 	lds	r24, 0x0520
    21f0:	88 23       	and	r24, r24
    21f2:	19 f0       	breq	.+6      	; 0x21fa <__vector_28+0x7e>
    21f4:	81 30       	cpi	r24, 0x01	; 1
    21f6:	c1 f4       	brne	.+48     	; 0x2228 <__vector_28+0xac>
    21f8:	06 c0       	rjmp	.+12     	; 0x2206 <__vector_28+0x8a>
	   {
		   case IDLE:
		   // Waiting for new command
			   RXIndex=0;
    21fa:	10 92 1f 05 	sts	0x051F, r1
			   
			   
			   c_state = HEADER_RX;
    21fe:	81 e0       	ldi	r24, 0x01	; 1
    2200:	80 93 20 05 	sts	0x0520, r24
    2204:	07 c0       	rjmp	.+14     	; 0x2214 <__vector_28+0x98>
		   break;
		   
		   case HEADER_RX:
		   // Copy Data
				
			    if (RXIndex==SERIAL_BUFFERSIZE_1)
    2206:	80 91 1f 05 	lds	r24, 0x051F
    220a:	88 30       	cpi	r24, 0x08	; 8
    220c:	19 f4       	brne	.+6      	; 0x2214 <__vector_28+0x98>
				{
					ParseCommand();
    220e:	0e 94 5c 10 	call	0x20b8	; 0x20b8 <ParseCommand>
    2212:	0a c0       	rjmp	.+20     	; 0x2228 <__vector_28+0xac>
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    2214:	f8 94       	cli
				}
				else
				{
					ATOMIC_BLOCK(ATOMIC_FORCEON)
				   {
					 LastRXTime = TCNT1_X;
    2216:	80 91 5e 06 	lds	r24, 0x065E
    221a:	90 91 5f 06 	lds	r25, 0x065F
    221e:	90 93 93 07 	sts	0x0793, r25
    2222:	80 93 92 07 	sts	0x0792, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    2226:	78 94       	sei
				   }
				}								
		   break;
	   }
	
	 RXIndex+=1;
    2228:	80 91 1f 05 	lds	r24, 0x051F
    222c:	8f 5f       	subi	r24, 0xFF	; 255
    222e:	80 93 1f 05 	sts	0x051F, r24
	 if (RXIndex==SERIAL_BUFFERSIZE) 
    2232:	80 91 1f 05 	lds	r24, 0x051F
    2236:	89 30       	cpi	r24, 0x09	; 9
    2238:	21 f4       	brne	.+8      	; 0x2242 <__vector_28+0xc6>
	 {
		RXIndex=0;
    223a:	10 92 1f 05 	sts	0x051F, r1
		c_state = IDLE;
    223e:	10 92 20 05 	sts	0x0520, r1
	 }		
}
    2242:	ff 91       	pop	r31
    2244:	ef 91       	pop	r30
    2246:	bf 91       	pop	r27
    2248:	af 91       	pop	r26
    224a:	9f 91       	pop	r25
    224c:	8f 91       	pop	r24
    224e:	7f 91       	pop	r23
    2250:	6f 91       	pop	r22
    2252:	5f 91       	pop	r21
    2254:	4f 91       	pop	r20
    2256:	3f 91       	pop	r19
    2258:	2f 91       	pop	r18
    225a:	0f 90       	pop	r0
    225c:	0f be       	out	0x3f, r0	; 63
    225e:	0f 90       	pop	r0
    2260:	1f 90       	pop	r1
    2262:	18 95       	reti

00002264 <Send_Data_TEST>:
	
	
}

void Send_Data_TEST (void * msg, uint8_t len)
{
    2264:	ef 92       	push	r14
    2266:	ff 92       	push	r15
    2268:	0f 93       	push	r16
    226a:	1f 93       	push	r17
    226c:	cf 93       	push	r28
    226e:	df 93       	push	r29
	for (int i=0; i<len;++i)
    2270:	08 2f       	mov	r16, r24
    2272:	19 2f       	mov	r17, r25
    2274:	c0 e0       	ldi	r28, 0x00	; 0
    2276:	d0 e0       	ldi	r29, 0x00	; 0
    2278:	e6 2e       	mov	r14, r22
    227a:	ff 24       	eor	r15, r15
    227c:	06 c0       	rjmp	.+12     	; 0x228a <Send_Data_TEST+0x26>
	{
		send_byte (((uint8_t *)msg)[i]);
    227e:	f8 01       	movw	r30, r16
    2280:	81 91       	ld	r24, Z+
    2282:	8f 01       	movw	r16, r30
    2284:	0e 94 38 10 	call	0x2070	; 0x2070 <send_byte>
	
}

void Send_Data_TEST (void * msg, uint8_t len)
{
	for (int i=0; i<len;++i)
    2288:	21 96       	adiw	r28, 0x01	; 1
    228a:	ce 15       	cp	r28, r14
    228c:	df 05       	cpc	r29, r15
    228e:	bc f3       	brlt	.-18     	; 0x227e <Send_Data_TEST+0x1a>
	{
		send_byte (((uint8_t *)msg)[i]);
	}
	
    2290:	df 91       	pop	r29
    2292:	cf 91       	pop	r28
    2294:	1f 91       	pop	r17
    2296:	0f 91       	pop	r16
    2298:	ff 90       	pop	r15
    229a:	ef 90       	pop	r14
    229c:	08 95       	ret

0000229e <_font12x16selector>:
	*/
};

static PGM_P _font12x16selector(unsigned char c)
{
	return (PGM_P) _font12x16map + (c - 0x20) * BYTESPERCHAR;
    229e:	90 e0       	ldi	r25, 0x00	; 0
    22a0:	80 97       	sbiw	r24, 0x20	; 32
    22a2:	9c 01       	movw	r18, r24
    22a4:	22 0f       	add	r18, r18
    22a6:	33 1f       	adc	r19, r19
    22a8:	28 0f       	add	r18, r24
    22aa:	39 1f       	adc	r19, r25
    22ac:	83 e0       	ldi	r24, 0x03	; 3
    22ae:	22 0f       	add	r18, r18
    22b0:	33 1f       	adc	r19, r19
    22b2:	8a 95       	dec	r24
    22b4:	e1 f7       	brne	.-8      	; 0x22ae <_font12x16selector+0x10>
    22b6:	2c 5c       	subi	r18, 0xCC	; 204
    22b8:	3e 4f       	sbci	r19, 0xFE	; 254
}
    22ba:	c9 01       	movw	r24, r18
    22bc:	08 95       	ret

000022be <_font6x8selector>:
	*/
};

static PGM_P _font6x8selector(unsigned char c)
{
	return (PGM_P) _font6x8map + (c - 0x20) * BYTESPERCHAR;
    22be:	90 e0       	ldi	r25, 0x00	; 0
    22c0:	80 97       	sbiw	r24, 0x20	; 32
    22c2:	9c 01       	movw	r18, r24
    22c4:	22 0f       	add	r18, r18
    22c6:	33 1f       	adc	r19, r19
    22c8:	28 0f       	add	r18, r24
    22ca:	39 1f       	adc	r19, r25
    22cc:	22 0f       	add	r18, r18
    22ce:	33 1f       	adc	r19, r19
    22d0:	28 5c       	subi	r18, 0xC8	; 200
    22d2:	38 4f       	sbci	r19, 0xF8	; 248
}
    22d4:	c9 01       	movw	r24, r18
    22d6:	08 95       	ret

000022d8 <Setup>:
static uint8_t FlyingModesToggle;

void Setup (void)
{
	
	Menu_EnableAllItems();
    22d8:	0e 94 19 38 	call	0x7032	; 0x7032 <Menu_EnableAllItems>
	
	Initial_EEPROM_Config_Load();
    22dc:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <Initial_EEPROM_Config_Load>
	
	//Config.QuadFlyingMode = QuadFlyingMode_PLUS;
	
	RX_Init();
    22e0:	0e 94 40 26 	call	0x4c80	; 0x4c80 <RX_Init>
	if ((Config.RX_mode==RX_mode_UARTMode) && (IS_MISC_SENSOR_SONAR_ENABLED==true))
    22e4:	80 91 d3 06 	lds	r24, 0x06D3
    22e8:	8f 3f       	cpi	r24, 0xFF	; 255
    22ea:	31 f4       	brne	.+12     	; 0x22f8 <Setup+0x20>
    22ec:	80 91 de 06 	lds	r24, 0x06DE
    22f0:	80 ff       	sbrs	r24, 0
    22f2:	02 c0       	rjmp	.+4      	; 0x22f8 <Setup+0x20>
	{
		Ultrasonic_Init();
    22f4:	0e 94 ea 0e 	call	0x1dd4	; 0x1dd4 <Ultrasonic_Init>
	}		
	// Motors
	M1_DIR = OUTPUT;
    22f8:	3e 9a       	sbi	0x07, 6	; 7
	M2_DIR = OUTPUT;
    22fa:	3c 9a       	sbi	0x07, 4	; 7
	M3_DIR = OUTPUT;
    22fc:	3a 9a       	sbi	0x07, 2	; 7
	M4_DIR = OUTPUT;
    22fe:	3b 9a       	sbi	0x07, 3	; 7
	M1 = 0;
    2300:	46 98       	cbi	0x08, 6	; 8
	M2 = 0;
    2302:	44 98       	cbi	0x08, 4	; 8
	M3 = 0;
    2304:	42 98       	cbi	0x08, 2	; 8
	M4 = 0;
    2306:	43 98       	cbi	0x08, 3	; 8
	
	Buzzer_DIR = OUTPUT;
    2308:	21 9a       	sbi	0x04, 1	; 4
	LED_Orange_DIR = OUTPUT;
    230a:	23 9a       	sbi	0x04, 3	; 4
	
	
	// Sensors
	V_BAT  = INPUT;
    230c:	13 98       	cbi	0x02, 3	; 2
	
	
	
	// Timers
	TCCR1A = 0;	//Set timer 1 to run at 2.5MHz
    230e:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;
    2312:	10 92 81 00 	sts	0x0081, r1
	TCCR1C = 0;
    2316:	10 92 82 00 	sts	0x0082, r1
	

if (Config.RX_mode==RX_mode_UARTMode)
    231a:	80 91 d3 06 	lds	r24, 0x06D3
    231e:	8f 3f       	cpi	r24, 0xFF	; 255
    2320:	21 f4       	brne	.+8      	; 0x232a <Setup+0x52>
{
	UART_Init(10); //57600 = 20   115200=10
    2322:	8a e0       	ldi	r24, 0x0A	; 10
    2324:	90 e0       	ldi	r25, 0x00	; 0
    2326:	0e 94 27 10 	call	0x204e	; 0x204e <UART_Init>
}	



	ADCPort_Init();
    232a:	0e 94 9b 2a 	call	0x5536	; 0x5536 <ADCPort_Init>
	Sensors_Init();
    232e:	0e 94 c7 28 	call	0x518e	; 0x518e <Sensors_Init>
	KeyBoard_Init();
    2332:	0e 94 90 0b 	call	0x1720	; 0x1720 <KeyBoard_Init>
	Timer_Init();
    2336:	0e 94 11 10 	call	0x2022	; 0x2022 <Timer_Init>
	
	LCD_Init();
    233a:	0e 94 47 0e 	call	0x1c8e	; 0x1c8e <LCD_Init>
	LCD_Clear();
    233e:	0e 94 1f 0c 	call	0x183e	; 0x183e <LCD_Clear>
	
	Menu_MenuInit();
    2342:	0e 94 11 38 	call	0x7022	; 0x7022 <Menu_MenuInit>
	
		
	
	
	sei();
    2346:	78 94       	sei
	
	delay_ms(30);
    2348:	8e e1       	ldi	r24, 0x1E	; 30
    234a:	90 e0       	ldi	r25, 0x00	; 0
    234c:	0e 94 d7 0e 	call	0x1dae	; 0x1dae <delay_ms>
    
}
    2350:	08 95       	ret

00002352 <Loop>:
	We are in this loop because the system is not calibrated.
	This is the minimum functionality.
*/
void Loop(void)
{
	RX_CopyLatestReceiverValues(); // update RX_Latest also IS_TXn_GOOD
    2352:	0e 94 77 27 	call	0x4eee	; 0x4eee <RX_CopyLatestReceiverValues>
	
	if (TCNT_X_snapshot2==0) TCNT_X_snapshot2 = TCNT2_X;
    2356:	80 91 ea 05 	lds	r24, 0x05EA
    235a:	90 91 eb 05 	lds	r25, 0x05EB
    235e:	00 97       	sbiw	r24, 0x00	; 0
    2360:	41 f4       	brne	.+16     	; 0x2372 <Loop+0x20>
    2362:	80 91 bd 05 	lds	r24, 0x05BD
    2366:	90 91 be 05 	lds	r25, 0x05BE
    236a:	90 93 eb 05 	sts	0x05EB, r25
    236e:	80 93 ea 05 	sts	0x05EA, r24
	if ( (TCNT2_X- TCNT_X_snapshot2) > LCD_RefreashRate )  
    2372:	80 91 bd 05 	lds	r24, 0x05BD
    2376:	90 91 be 05 	lds	r25, 0x05BE
    237a:	20 91 ea 05 	lds	r18, 0x05EA
    237e:	30 91 eb 05 	lds	r19, 0x05EB
    2382:	82 1b       	sub	r24, r18
    2384:	93 0b       	sbc	r25, r19
    2386:	8b 30       	cpi	r24, 0x0B	; 11
    2388:	91 05       	cpc	r25, r1
    238a:	30 f0       	brcs	.+12     	; 0x2398 <Loop+0x46>
	{
		Menu_MenuShow();	
    238c:	0e 94 ce 37 	call	0x6f9c	; 0x6f9c <Menu_MenuShow>
		TCNT_X_snapshot2=0;
    2390:	10 92 eb 05 	sts	0x05EB, r1
    2394:	10 92 ea 05 	sts	0x05EA, r1
    2398:	08 95       	ret

0000239a <LoopESCCalibration>:
}

void LoopESCCalibration (void)
{
	
	Menu_LoadPage(PAGE_HOME_ESC_CALIBRATION);
    239a:	83 e0       	ldi	r24, 0x03	; 3
    239c:	0e 94 de 2e 	call	0x5dbc	; 0x5dbc <Menu_LoadPage>
	while (1)
	{
		Loop();
    23a0:	0e 94 a9 11 	call	0x2352	; 0x2352 <Loop>
    23a4:	fd cf       	rjmp	.-6      	; 0x23a0 <LoopESCCalibration+0x6>

000023a6 <LoopCalibration>:
// Never go to MainLoop "fly loop" unless Sensors & RX is calibrated.
// This loop to protect against any bug that might make the quad start or KB stick click
// as in this case crash is a must.
void LoopCalibration (void)
{
	menuEnabled[PAGE_STABILIZATION] =0;
    23a6:	10 92 a4 07 	sts	0x07A4, r1
	menuEnabled[PAGE_SELF_LEVELING] =0;
    23aa:	10 92 a5 07 	sts	0x07A5, r1
	menuEnabled[PAGE_ALT_HOLD]		=0;
    23ae:	10 92 a6 07 	sts	0x07A6, r1
	menuEnabled[PAGE_MISC_SETTING]  =0;
    23b2:	10 92 a8 07 	sts	0x07A8, r1
	menuEnabled[PAGE_ESC_CALIBRATION]=0; // u cannot make ESC Calibration as sticks are not ready for testing.
    23b6:	10 92 ad 07 	sts	0x07AD, r1
		
	while (!(Config.IsCalibrated & CALIBRATED_SENSOR) || !(Config.IsCalibrated & CALIBRATED_Stick_SECONDARY))
    23ba:	02 c0       	rjmp	.+4      	; 0x23c0 <LoopCalibration+0x1a>
	{	
		Loop();
    23bc:	0e 94 a9 11 	call	0x2352	; 0x2352 <Loop>
	menuEnabled[PAGE_SELF_LEVELING] =0;
	menuEnabled[PAGE_ALT_HOLD]		=0;
	menuEnabled[PAGE_MISC_SETTING]  =0;
	menuEnabled[PAGE_ESC_CALIBRATION]=0; // u cannot make ESC Calibration as sticks are not ready for testing.
		
	while (!(Config.IsCalibrated & CALIBRATED_SENSOR) || !(Config.IsCalibrated & CALIBRATED_Stick_SECONDARY))
    23c0:	80 91 d2 06 	lds	r24, 0x06D2
    23c4:	82 ff       	sbrs	r24, 2
    23c6:	fa cf       	rjmp	.-12     	; 0x23bc <LoopCalibration+0x16>
    23c8:	81 ff       	sbrs	r24, 1
    23ca:	f8 cf       	rjmp	.-16     	; 0x23bc <LoopCalibration+0x16>
	{	
		Loop();
	}
}
    23cc:	08 95       	ret

000023ce <HandleSticksForArming>:
// This function is never called if there is a calibration issue.
// called in true section of if (RX_Snapshot[RXChannel_THR] < STICKThrottle_ARMING) 
void HandleSticksForArming (void)
{
	
	if ((UIEnableStickCommands==false) || (ActiveRXIndex!=1) || (!IS_TX2_GOOD)) return ; // you cannot use Primary to Arm and Disarm
    23ce:	80 91 e7 05 	lds	r24, 0x05E7
    23d2:	88 23       	and	r24, r24
    23d4:	09 f4       	brne	.+2      	; 0x23d8 <HandleSticksForArming+0xa>
    23d6:	6c c1       	rjmp	.+728    	; 0x26b0 <HandleSticksForArming+0x2e2>
    23d8:	80 91 cc 05 	lds	r24, 0x05CC
    23dc:	81 30       	cpi	r24, 0x01	; 1
    23de:	09 f0       	breq	.+2      	; 0x23e2 <HandleSticksForArming+0x14>
    23e0:	67 c1       	rjmp	.+718    	; 0x26b0 <HandleSticksForArming+0x2e2>
    23e2:	80 91 b8 07 	lds	r24, 0x07B8
    23e6:	80 7f       	andi	r24, 0xF0	; 240
    23e8:	09 f0       	breq	.+2      	; 0x23ec <HandleSticksForArming+0x1e>
    23ea:	62 c1       	rjmp	.+708    	; 0x26b0 <HandleSticksForArming+0x2e2>
	SystemErrorType = CLR_SYS_ERR_SIGNAL;
    23ec:	80 91 c5 06 	lds	r24, 0x06C5
    23f0:	8e 7f       	andi	r24, 0xFE	; 254
    23f2:	80 93 c5 06 	sts	0x06C5, r24
	
	if (TCNT1_X_snapshot1==0)  TCNT1_X_snapshot1 = CurrentTCNT1_X; // start counting
    23f6:	80 91 e8 05 	lds	r24, 0x05E8
    23fa:	90 91 e9 05 	lds	r25, 0x05E9
    23fe:	00 97       	sbiw	r24, 0x00	; 0
    2400:	41 f4       	brne	.+16     	; 0x2412 <HandleSticksForArming+0x44>
    2402:	80 91 5c 06 	lds	r24, 0x065C
    2406:	90 91 5d 06 	lds	r25, 0x065D
    240a:	90 93 e9 05 	sts	0x05E9, r25
    240e:	80 93 e8 05 	sts	0x05E8, r24
		
		// DisArm Check
		if (IsArmed == true) 
    2412:	80 91 85 07 	lds	r24, 0x0785
    2416:	81 30       	cpi	r24, 0x01	; 1
    2418:	09 f0       	breq	.+2      	; 0x241c <HandleSticksForArming+0x4e>
    241a:	54 c0       	rjmp	.+168    	; 0x24c4 <HandleSticksForArming+0xf6>
		{
			if (RX_Latest[ActiveRXIndex][RXChannel_RUD] > STICK_LEFT)
    241c:	20 91 cc 05 	lds	r18, 0x05CC
    2420:	82 2f       	mov	r24, r18
    2422:	90 e0       	ldi	r25, 0x00	; 0
    2424:	fc 01       	movw	r30, r24
    2426:	ee 0f       	add	r30, r30
    2428:	ff 1f       	adc	r31, r31
    242a:	43 e0       	ldi	r20, 0x03	; 3
    242c:	88 0f       	add	r24, r24
    242e:	99 1f       	adc	r25, r25
    2430:	4a 95       	dec	r20
    2432:	e1 f7       	brne	.-8      	; 0x242c <HandleSticksForArming+0x5e>
    2434:	e8 0f       	add	r30, r24
    2436:	f9 1f       	adc	r31, r25
    2438:	ec 5f       	subi	r30, 0xFC	; 252
    243a:	f9 4f       	sbci	r31, 0xF9	; 249
    243c:	84 81       	ldd	r24, Z+4	; 0x04
    243e:	95 81       	ldd	r25, Z+5	; 0x05
    2440:	21 e0       	ldi	r18, 0x01	; 1
    2442:	81 39       	cpi	r24, 0x91	; 145
    2444:	92 07       	cpc	r25, r18
    2446:	84 f0       	brlt	.+32     	; 0x2468 <HandleSticksForArming+0x9a>
			{ // Check DisArming manually.
				bResetTCNR1_X  = false;
    2448:	10 92 57 06 	sts	0x0657, r1
				if ( (CurrentTCNT1_X - TCNT1_X_snapshot1) > STICKPOSITION_LONG_TIME )
    244c:	80 91 5c 06 	lds	r24, 0x065C
    2450:	90 91 5d 06 	lds	r25, 0x065D
    2454:	20 91 e8 05 	lds	r18, 0x05E8
    2458:	30 91 e9 05 	lds	r19, 0x05E9
    245c:	82 1b       	sub	r24, r18
    245e:	93 0b       	sbc	r25, r19
    2460:	21 e0       	ldi	r18, 0x01	; 1
    2462:	82 33       	cpi	r24, 0x32	; 50
    2464:	92 07       	cpc	r25, r18
    2466:	58 f5       	brcc	.+86     	; 0x24be <HandleSticksForArming+0xf0>
					Disarm();
					return ;
				}
			}
			
			if (Config.AutoDisarm!=0)
    2468:	60 91 d6 06 	lds	r22, 0x06D6
    246c:	66 23       	and	r22, r22
    246e:	09 f4       	brne	.+2      	; 0x2472 <HandleSticksForArming+0xa4>
    2470:	1f c1       	rjmp	.+574    	; 0x26b0 <HandleSticksForArming+0x2e2>
			{ // check auto disArm
				if (TCNT_X_snapshotAutoDisarm==0) TCNT_X_snapshotAutoDisarm = CurrentTCNT1_X;
    2472:	80 91 1d 06 	lds	r24, 0x061D
    2476:	90 91 1e 06 	lds	r25, 0x061E
    247a:	00 97       	sbiw	r24, 0x00	; 0
    247c:	41 f4       	brne	.+16     	; 0x248e <HandleSticksForArming+0xc0>
    247e:	80 91 5c 06 	lds	r24, 0x065C
    2482:	90 91 5d 06 	lds	r25, 0x065D
    2486:	90 93 1e 06 	sts	0x061E, r25
    248a:	80 93 1d 06 	sts	0x061D, r24
				if ((CurrentTCNT1_X - TCNT_X_snapshotAutoDisarm) > (DISARM_TIME * Config.AutoDisarm))
    248e:	80 91 5c 06 	lds	r24, 0x065C
    2492:	90 91 5d 06 	lds	r25, 0x065D
    2496:	20 91 1d 06 	lds	r18, 0x061D
    249a:	30 91 1e 06 	lds	r19, 0x061E
    249e:	82 1b       	sub	r24, r18
    24a0:	93 0b       	sbc	r25, r19
    24a2:	70 e0       	ldi	r23, 0x00	; 0
    24a4:	48 ee       	ldi	r20, 0xE8	; 232
    24a6:	53 e0       	ldi	r21, 0x03	; 3
    24a8:	64 9f       	mul	r22, r20
    24aa:	90 01       	movw	r18, r0
    24ac:	65 9f       	mul	r22, r21
    24ae:	30 0d       	add	r19, r0
    24b0:	74 9f       	mul	r23, r20
    24b2:	30 0d       	add	r19, r0
    24b4:	11 24       	eor	r1, r1
    24b6:	28 17       	cp	r18, r24
    24b8:	39 07       	cpc	r19, r25
    24ba:	08 f0       	brcs	.+2      	; 0x24be <HandleSticksForArming+0xf0>
    24bc:	f9 c0       	rjmp	.+498    	; 0x26b0 <HandleSticksForArming+0x2e2>
				{
					Disarm();
    24be:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <Disarm>
					return ;
    24c2:	08 95       	ret
				}
			}
			
		}			
		
		if (IsArmed == false) 
    24c4:	88 23       	and	r24, r24
    24c6:	09 f0       	breq	.+2      	; 0x24ca <HandleSticksForArming+0xfc>
    24c8:	f3 c0       	rjmp	.+486    	; 0x26b0 <HandleSticksForArming+0x2e2>
		{
			//int16_t Stick = (Config.RX_Mid[ActiveRXIndex][RXChannel_RUD] + RX_Latest[ActiveRXIndex][RXChannel_RUD] * RX_Div_Factor);
			if (RX_Latest[ActiveRXIndex][RXChannel_RUD]  < STICK_RIGHT)
    24ca:	20 91 cc 05 	lds	r18, 0x05CC
    24ce:	82 2f       	mov	r24, r18
    24d0:	90 e0       	ldi	r25, 0x00	; 0
    24d2:	fc 01       	movw	r30, r24
    24d4:	ee 0f       	add	r30, r30
    24d6:	ff 1f       	adc	r31, r31
    24d8:	23 e0       	ldi	r18, 0x03	; 3
    24da:	88 0f       	add	r24, r24
    24dc:	99 1f       	adc	r25, r25
    24de:	2a 95       	dec	r18
    24e0:	e1 f7       	brne	.-8      	; 0x24da <HandleSticksForArming+0x10c>
    24e2:	e8 0f       	add	r30, r24
    24e4:	f9 1f       	adc	r31, r25
    24e6:	ec 5f       	subi	r30, 0xFC	; 252
    24e8:	f9 4f       	sbci	r31, 0xF9	; 249
    24ea:	84 81       	ldd	r24, Z+4	; 0x04
    24ec:	95 81       	ldd	r25, Z+5	; 0x05
    24ee:	2e ef       	ldi	r18, 0xFE	; 254
    24f0:	80 37       	cpi	r24, 0x70	; 112
    24f2:	92 07       	cpc	r25, r18
    24f4:	fc f4       	brge	.+62     	; 0x2534 <HandleSticksForArming+0x166>
			{	// Armin Check
				bResetTCNR1_X = false;
    24f6:	10 92 57 06 	sts	0x0657, r1
				if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_LONG_TIME )
    24fa:	80 91 5c 06 	lds	r24, 0x065C
    24fe:	90 91 5d 06 	lds	r25, 0x065D
    2502:	20 91 e8 05 	lds	r18, 0x05E8
    2506:	30 91 e9 05 	lds	r19, 0x05E9
    250a:	82 1b       	sub	r24, r18
    250c:	93 0b       	sbc	r25, r19
    250e:	21 e0       	ldi	r18, 0x01	; 1
    2510:	82 33       	cpi	r24, 0x32	; 50
    2512:	92 07       	cpc	r25, r18
    2514:	78 f0       	brcs	.+30     	; 0x2534 <HandleSticksForArming+0x166>
				{
					if ((Config.RX_mode==RX_mode_BuddyMode) && (!IS_TX1_GOOD)) return; 
    2516:	80 91 d3 06 	lds	r24, 0x06D3
    251a:	88 23       	and	r24, r24
    251c:	41 f4       	brne	.+16     	; 0x252e <HandleSticksForArming+0x160>
    251e:	80 91 b8 07 	lds	r24, 0x07B8
    2522:	90 e0       	ldi	r25, 0x00	; 0
    2524:	8f 70       	andi	r24, 0x0F	; 15
    2526:	90 70       	andi	r25, 0x00	; 0
    2528:	00 97       	sbiw	r24, 0x00	; 0
    252a:	09 f0       	breq	.+2      	; 0x252e <HandleSticksForArming+0x160>
    252c:	c1 c0       	rjmp	.+386    	; 0x26b0 <HandleSticksForArming+0x2e2>
					// in Buddy mode you cannot arm is there is no signal from TX1
					
					Arm();
    252e:	0e 94 05 0f 	call	0x1e0a	; 0x1e0a <Arm>
					return ;
    2532:	08 95       	ret
				}
			}					
		
			//set modes Quad , X-Quad
		
			if (RX_Latest[ActiveRXIndex][RXChannel_AIL]  > STICK_LEFT)
    2534:	20 91 cc 05 	lds	r18, 0x05CC
    2538:	82 2f       	mov	r24, r18
    253a:	90 e0       	ldi	r25, 0x00	; 0
    253c:	fc 01       	movw	r30, r24
    253e:	ee 0f       	add	r30, r30
    2540:	ff 1f       	adc	r31, r31
    2542:	a3 e0       	ldi	r26, 0x03	; 3
    2544:	88 0f       	add	r24, r24
    2546:	99 1f       	adc	r25, r25
    2548:	aa 95       	dec	r26
    254a:	e1 f7       	brne	.-8      	; 0x2544 <HandleSticksForArming+0x176>
    254c:	e8 0f       	add	r30, r24
    254e:	f9 1f       	adc	r31, r25
    2550:	ec 5f       	subi	r30, 0xFC	; 252
    2552:	f9 4f       	sbci	r31, 0xF9	; 249
    2554:	80 81       	ld	r24, Z
    2556:	91 81       	ldd	r25, Z+1	; 0x01
    2558:	21 e0       	ldi	r18, 0x01	; 1
    255a:	81 39       	cpi	r24, 0x91	; 145
    255c:	92 07       	cpc	r25, r18
    255e:	ac f0       	brlt	.+42     	; 0x258a <HandleSticksForArming+0x1bc>
			{// X-QUAD MODE
				bResetTCNR1_X = false;
    2560:	10 92 57 06 	sts	0x0657, r1
				if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_LONG_TIME )
    2564:	80 91 5c 06 	lds	r24, 0x065C
    2568:	90 91 5d 06 	lds	r25, 0x065D
    256c:	20 91 e8 05 	lds	r18, 0x05E8
    2570:	30 91 e9 05 	lds	r19, 0x05E9
    2574:	82 1b       	sub	r24, r18
    2576:	93 0b       	sbc	r25, r19
    2578:	21 e0       	ldi	r18, 0x01	; 1
    257a:	82 33       	cpi	r24, 0x32	; 50
    257c:	92 07       	cpc	r25, r18
    257e:	08 f4       	brcc	.+2      	; 0x2582 <HandleSticksForArming+0x1b4>
    2580:	97 c0       	rjmp	.+302    	; 0x26b0 <HandleSticksForArming+0x2e2>
				{
					Config.QuadFlyingMode=QuadFlyingMode_X;
    2582:	81 e0       	ldi	r24, 0x01	; 1
    2584:	80 93 da 06 	sts	0x06DA, r24
    2588:	57 c0       	rjmp	.+174    	; 0x2638 <HandleSticksForArming+0x26a>
					LED_FlashOrangeLED (LED_LONG_TOGGLE,8);
					TCNT1_X_snapshot1 =0; // reset timer
				}
			}			
			else if ((RX_Latest[ActiveRXIndex][RXChannel_AIL]  < STICK_RIGHT))
    258a:	20 91 cc 05 	lds	r18, 0x05CC
    258e:	82 2f       	mov	r24, r18
    2590:	90 e0       	ldi	r25, 0x00	; 0
    2592:	fc 01       	movw	r30, r24
    2594:	ee 0f       	add	r30, r30
    2596:	ff 1f       	adc	r31, r31
    2598:	63 e0       	ldi	r22, 0x03	; 3
    259a:	88 0f       	add	r24, r24
    259c:	99 1f       	adc	r25, r25
    259e:	6a 95       	dec	r22
    25a0:	e1 f7       	brne	.-8      	; 0x259a <HandleSticksForArming+0x1cc>
    25a2:	e8 0f       	add	r30, r24
    25a4:	f9 1f       	adc	r31, r25
    25a6:	ec 5f       	subi	r30, 0xFC	; 252
    25a8:	f9 4f       	sbci	r31, 0xF9	; 249
    25aa:	80 81       	ld	r24, Z
    25ac:	91 81       	ldd	r25, Z+1	; 0x01
    25ae:	2e ef       	ldi	r18, 0xFE	; 254
    25b0:	80 37       	cpi	r24, 0x70	; 112
    25b2:	92 07       	cpc	r25, r18
    25b4:	bc f4       	brge	.+46     	; 0x25e4 <HandleSticksForArming+0x216>
				{	// QUAD COPTER MODE
					bResetTCNR1_X = false;
    25b6:	10 92 57 06 	sts	0x0657, r1
					if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_LONG_TIME )
    25ba:	80 91 5c 06 	lds	r24, 0x065C
    25be:	90 91 5d 06 	lds	r25, 0x065D
    25c2:	20 91 e8 05 	lds	r18, 0x05E8
    25c6:	30 91 e9 05 	lds	r19, 0x05E9
    25ca:	82 1b       	sub	r24, r18
    25cc:	93 0b       	sbc	r25, r19
    25ce:	21 e0       	ldi	r18, 0x01	; 1
    25d0:	82 33       	cpi	r24, 0x32	; 50
    25d2:	92 07       	cpc	r25, r18
    25d4:	08 f4       	brcc	.+2      	; 0x25d8 <HandleSticksForArming+0x20a>
    25d6:	6c c0       	rjmp	.+216    	; 0x26b0 <HandleSticksForArming+0x2e2>
					{
						Config.QuadFlyingMode=QuadFlyingMode_PLUS;
    25d8:	10 92 da 06 	sts	0x06DA, r1
						LED_FlashOrangeLED (LED_LONG_TOGGLE,4);
    25dc:	80 e5       	ldi	r24, 0x50	; 80
    25de:	90 e0       	ldi	r25, 0x00	; 0
    25e0:	64 e0       	ldi	r22, 0x04	; 4
    25e2:	2d c0       	rjmp	.+90     	; 0x263e <HandleSticksForArming+0x270>
					}		
			
				} 
				
			// set mode ACRO , Leveling
			else if ((RX_Latest[ActiveRXIndex][RXChannel_ELE]  < STICK_RIGHT))
    25e4:	20 91 cc 05 	lds	r18, 0x05CC
    25e8:	82 2f       	mov	r24, r18
    25ea:	90 e0       	ldi	r25, 0x00	; 0
    25ec:	fc 01       	movw	r30, r24
    25ee:	ee 0f       	add	r30, r30
    25f0:	ff 1f       	adc	r31, r31
    25f2:	43 e0       	ldi	r20, 0x03	; 3
    25f4:	88 0f       	add	r24, r24
    25f6:	99 1f       	adc	r25, r25
    25f8:	4a 95       	dec	r20
    25fa:	e1 f7       	brne	.-8      	; 0x25f4 <HandleSticksForArming+0x226>
    25fc:	e8 0f       	add	r30, r24
    25fe:	f9 1f       	adc	r31, r25
    2600:	ec 5f       	subi	r30, 0xFC	; 252
    2602:	f9 4f       	sbci	r31, 0xF9	; 249
    2604:	82 81       	ldd	r24, Z+2	; 0x02
    2606:	93 81       	ldd	r25, Z+3	; 0x03
    2608:	2e ef       	ldi	r18, 0xFE	; 254
    260a:	80 37       	cpi	r24, 0x70	; 112
    260c:	92 07       	cpc	r25, r18
    260e:	f4 f4       	brge	.+60     	; 0x264c <HandleSticksForArming+0x27e>
				{	//nFlyingModes = FLYINGMODE_LEVEL;
					bResetTCNR1_X = false;
    2610:	10 92 57 06 	sts	0x0657, r1
					if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_LONG_TIME )
    2614:	80 91 5c 06 	lds	r24, 0x065C
    2618:	90 91 5d 06 	lds	r25, 0x065D
    261c:	20 91 e8 05 	lds	r18, 0x05E8
    2620:	30 91 e9 05 	lds	r19, 0x05E9
    2624:	82 1b       	sub	r24, r18
    2626:	93 0b       	sbc	r25, r19
    2628:	21 e0       	ldi	r18, 0x01	; 1
    262a:	82 33       	cpi	r24, 0x32	; 50
    262c:	92 07       	cpc	r25, r18
    262e:	08 f4       	brcc	.+2      	; 0x2632 <HandleSticksForArming+0x264>
    2630:	3f c0       	rjmp	.+126    	; 0x26b0 <HandleSticksForArming+0x2e2>
					{
						nFlyingModes = FLYINGMODE_LEVEL;
    2632:	82 e0       	ldi	r24, 0x02	; 2
    2634:	80 93 1c 06 	sts	0x061C, r24
						LED_FlashOrangeLED (LED_LONG_TOGGLE,8);
    2638:	80 e5       	ldi	r24, 0x50	; 80
    263a:	90 e0       	ldi	r25, 0x00	; 0
    263c:	68 e0       	ldi	r22, 0x08	; 8
    263e:	0e 94 75 0e 	call	0x1cea	; 0x1cea <LED_FlashOrangeLED>
						TCNT1_X_snapshot1 =0; // reset timer
    2642:	10 92 e9 05 	sts	0x05E9, r1
    2646:	10 92 e8 05 	sts	0x05E8, r1
    264a:	08 95       	ret
					}		
			
				} 
			else if ((RX_Latest[ActiveRXIndex][RXChannel_ELE]  > STICK_LEFT))
    264c:	20 91 cc 05 	lds	r18, 0x05CC
    2650:	82 2f       	mov	r24, r18
    2652:	90 e0       	ldi	r25, 0x00	; 0
    2654:	fc 01       	movw	r30, r24
    2656:	ee 0f       	add	r30, r30
    2658:	ff 1f       	adc	r31, r31
    265a:	23 e0       	ldi	r18, 0x03	; 3
    265c:	88 0f       	add	r24, r24
    265e:	99 1f       	adc	r25, r25
    2660:	2a 95       	dec	r18
    2662:	e1 f7       	brne	.-8      	; 0x265c <HandleSticksForArming+0x28e>
    2664:	e8 0f       	add	r30, r24
    2666:	f9 1f       	adc	r31, r25
    2668:	ec 5f       	subi	r30, 0xFC	; 252
    266a:	f9 4f       	sbci	r31, 0xF9	; 249
    266c:	82 81       	ldd	r24, Z+2	; 0x02
    266e:	93 81       	ldd	r25, Z+3	; 0x03
    2670:	21 e0       	ldi	r18, 0x01	; 1
    2672:	81 39       	cpi	r24, 0x91	; 145
    2674:	92 07       	cpc	r25, r18
    2676:	e4 f0       	brlt	.+56     	; 0x26b0 <HandleSticksForArming+0x2e2>
				{	//nFlyingModes = FLYINGMODE_ACRO;
					bResetTCNR1_X = false;
    2678:	10 92 57 06 	sts	0x0657, r1
					if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_LONG_TIME )
    267c:	80 91 5c 06 	lds	r24, 0x065C
    2680:	90 91 5d 06 	lds	r25, 0x065D
    2684:	20 91 e8 05 	lds	r18, 0x05E8
    2688:	30 91 e9 05 	lds	r19, 0x05E9
    268c:	82 1b       	sub	r24, r18
    268e:	93 0b       	sbc	r25, r19
    2690:	21 e0       	ldi	r18, 0x01	; 1
    2692:	82 33       	cpi	r24, 0x32	; 50
    2694:	92 07       	cpc	r25, r18
    2696:	60 f0       	brcs	.+24     	; 0x26b0 <HandleSticksForArming+0x2e2>
					{
						nFlyingModes = FLYINGMODE_ACRO;
    2698:	81 e0       	ldi	r24, 0x01	; 1
    269a:	80 93 1c 06 	sts	0x061C, r24
						LED_FlashOrangeLED (LED_LONG_TOGGLE,4);
    269e:	80 e5       	ldi	r24, 0x50	; 80
    26a0:	90 e0       	ldi	r25, 0x00	; 0
    26a2:	64 e0       	ldi	r22, 0x04	; 4
    26a4:	0e 94 75 0e 	call	0x1cea	; 0x1cea <LED_FlashOrangeLED>
						TCNT1_X_snapshot1 =0; // reset timer
    26a8:	10 92 e9 05 	sts	0x05E9, r1
    26ac:	10 92 e8 05 	sts	0x05E8, r1
    26b0:	08 95       	ret

000026b2 <HandleSticksAsKeys>:

// This function is never called if there is a calibration issue.
// called in FALSE section of if (RX_Snapshot[RXChannel_THR] < STICKThrottle_ARMING) 
void HandleSticksAsKeys (void)
{
		if ((UIEnableStickCommands==false) || (!IS_TX2_GOOD))  return ; // you cannot use Primary as keys
    26b2:	80 91 e7 05 	lds	r24, 0x05E7
    26b6:	88 23       	and	r24, r24
    26b8:	09 f4       	brne	.+2      	; 0x26bc <HandleSticksAsKeys+0xa>
    26ba:	87 c0       	rjmp	.+270    	; 0x27ca <HandleSticksAsKeys+0x118>
    26bc:	80 91 b8 07 	lds	r24, 0x07B8
    26c0:	80 7f       	andi	r24, 0xF0	; 240
    26c2:	09 f0       	breq	.+2      	; 0x26c6 <HandleSticksAsKeys+0x14>
    26c4:	82 c0       	rjmp	.+260    	; 0x27ca <HandleSticksAsKeys+0x118>

		// if Throttle is high and stick are calibrated
		
		if (TCNT1_X_snapshot1==0)  TCNT1_X_snapshot1 = CurrentTCNT1_X; // start counting
    26c6:	80 91 e8 05 	lds	r24, 0x05E8
    26ca:	90 91 e9 05 	lds	r25, 0x05E9
    26ce:	00 97       	sbiw	r24, 0x00	; 0
    26d0:	41 f4       	brne	.+16     	; 0x26e2 <HandleSticksAsKeys+0x30>
    26d2:	80 91 5c 06 	lds	r24, 0x065C
    26d6:	90 91 5d 06 	lds	r25, 0x065D
    26da:	90 93 e9 05 	sts	0x05E9, r25
    26de:	80 93 e8 05 	sts	0x05E8, r24
				
	 	if ((RX_Latest[RX_MAIN][RXChannel_ELE]) > STICK_LEFT) 
    26e2:	80 91 10 06 	lds	r24, 0x0610
    26e6:	90 91 11 06 	lds	r25, 0x0611
    26ea:	21 e0       	ldi	r18, 0x01	; 1
    26ec:	81 39       	cpi	r24, 0x91	; 145
    26ee:	92 07       	cpc	r25, r18
    26f0:	8c f0       	brlt	.+34     	; 0x2714 <HandleSticksAsKeys+0x62>
		{
			bResetTCNR1_X = false;
    26f2:	10 92 57 06 	sts	0x0657, r1
			if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_SHORT_TIME )
    26f6:	80 91 5c 06 	lds	r24, 0x065C
    26fa:	90 91 5d 06 	lds	r25, 0x065D
    26fe:	20 91 e8 05 	lds	r18, 0x05E8
    2702:	30 91 e9 05 	lds	r19, 0x05E9
    2706:	82 1b       	sub	r24, r18
    2708:	93 0b       	sbc	r25, r19
    270a:	81 35       	cpi	r24, 0x51	; 81
    270c:	91 05       	cpc	r25, r1
    270e:	00 f1       	brcs	.+64     	; 0x2750 <HandleSticksAsKeys+0x9e>
			{
				_TXKeys = KEY_3;
    2710:	80 e2       	ldi	r24, 0x20	; 32
    2712:	18 c0       	rjmp	.+48     	; 0x2744 <HandleSticksAsKeys+0x92>
				TCNT1_X_snapshot1 =0; // reset timer
			}		
		
		}
		else if ((RX_Latest[RX_MAIN][RXChannel_ELE]) < STICK_RIGHT) 
    2714:	80 91 10 06 	lds	r24, 0x0610
    2718:	90 91 11 06 	lds	r25, 0x0611
    271c:	2e ef       	ldi	r18, 0xFE	; 254
    271e:	80 37       	cpi	r24, 0x70	; 112
    2720:	92 07       	cpc	r25, r18
    2722:	b4 f4       	brge	.+44     	; 0x2750 <HandleSticksAsKeys+0x9e>
		{
			bResetTCNR1_X = false;
    2724:	10 92 57 06 	sts	0x0657, r1
			if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_SHORT_TIME )
    2728:	80 91 5c 06 	lds	r24, 0x065C
    272c:	90 91 5d 06 	lds	r25, 0x065D
    2730:	20 91 e8 05 	lds	r18, 0x05E8
    2734:	30 91 e9 05 	lds	r19, 0x05E9
    2738:	82 1b       	sub	r24, r18
    273a:	93 0b       	sbc	r25, r19
    273c:	81 35       	cpi	r24, 0x51	; 81
    273e:	91 05       	cpc	r25, r1
    2740:	38 f0       	brcs	.+14     	; 0x2750 <HandleSticksAsKeys+0x9e>
			{
				_TXKeys = KEY_2;
    2742:	80 e4       	ldi	r24, 0x40	; 64
    2744:	80 93 c4 06 	sts	0x06C4, r24
				TCNT1_X_snapshot1 =0; // reset timer
    2748:	10 92 e9 05 	sts	0x05E9, r1
    274c:	10 92 e8 05 	sts	0x05E8, r1
			}		
		
		}		 	 
		
		if ((RX_Latest[RX_MAIN][RXChannel_AIL]) > STICK_LEFT) 
    2750:	80 91 0e 06 	lds	r24, 0x060E
    2754:	90 91 0f 06 	lds	r25, 0x060F
    2758:	21 e0       	ldi	r18, 0x01	; 1
    275a:	81 39       	cpi	r24, 0x91	; 145
    275c:	92 07       	cpc	r25, r18
    275e:	bc f0       	brlt	.+46     	; 0x278e <HandleSticksAsKeys+0xdc>
		{
			bResetTCNR1_X = false;
    2760:	10 92 57 06 	sts	0x0657, r1
			if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_SHORT_TIME )
    2764:	80 91 5c 06 	lds	r24, 0x065C
    2768:	90 91 5d 06 	lds	r25, 0x065D
    276c:	20 91 e8 05 	lds	r18, 0x05E8
    2770:	30 91 e9 05 	lds	r19, 0x05E9
    2774:	82 1b       	sub	r24, r18
    2776:	93 0b       	sbc	r25, r19
    2778:	81 35       	cpi	r24, 0x51	; 81
    277a:	91 05       	cpc	r25, r1
    277c:	30 f1       	brcs	.+76     	; 0x27ca <HandleSticksAsKeys+0x118>
			{
				_TXKeys = KEY_4;
    277e:	80 e1       	ldi	r24, 0x10	; 16
    2780:	80 93 c4 06 	sts	0x06C4, r24
				TCNT1_X_snapshot1 =0; // reset timer
    2784:	10 92 e9 05 	sts	0x05E9, r1
    2788:	10 92 e8 05 	sts	0x05E8, r1
    278c:	08 95       	ret
			}		
		
		}
		else if ((RX_Latest[RX_MAIN][RXChannel_AIL]) < STICK_RIGHT) 
    278e:	80 91 0e 06 	lds	r24, 0x060E
    2792:	90 91 0f 06 	lds	r25, 0x060F
    2796:	2e ef       	ldi	r18, 0xFE	; 254
    2798:	80 37       	cpi	r24, 0x70	; 112
    279a:	92 07       	cpc	r25, r18
    279c:	b4 f4       	brge	.+44     	; 0x27ca <HandleSticksAsKeys+0x118>
		{
			bResetTCNR1_X = false;
    279e:	10 92 57 06 	sts	0x0657, r1
			if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_SHORT_TIME )
    27a2:	80 91 5c 06 	lds	r24, 0x065C
    27a6:	90 91 5d 06 	lds	r25, 0x065D
    27aa:	20 91 e8 05 	lds	r18, 0x05E8
    27ae:	30 91 e9 05 	lds	r19, 0x05E9
    27b2:	82 1b       	sub	r24, r18
    27b4:	93 0b       	sbc	r25, r19
    27b6:	81 35       	cpi	r24, 0x51	; 81
    27b8:	91 05       	cpc	r25, r1
    27ba:	38 f0       	brcs	.+14     	; 0x27ca <HandleSticksAsKeys+0x118>
			{
				_TXKeys = KEY_1;
    27bc:	80 e8       	ldi	r24, 0x80	; 128
    27be:	80 93 c4 06 	sts	0x06C4, r24
				TCNT1_X_snapshot1 =0; // reset timer
    27c2:	10 92 e9 05 	sts	0x05E9, r1
    27c6:	10 92 e8 05 	sts	0x05E8, r1
    27ca:	08 95       	ret

000027cc <ZEROMotors>:
/*
// STOPS MOTORS IMMEDIATLY
*/
void ZEROMotors()
{
	MotorOut[0] = 0;
    27cc:	10 92 99 05 	sts	0x0599, r1
    27d0:	10 92 98 05 	sts	0x0598, r1
	MotorOut[1] = 0;
    27d4:	10 92 9b 05 	sts	0x059B, r1
    27d8:	10 92 9a 05 	sts	0x059A, r1
	MotorOut[2] = 0;
    27dc:	10 92 9d 05 	sts	0x059D, r1
    27e0:	10 92 9c 05 	sts	0x059C, r1
	if (Config.FrameType == FRAMETYPE_TRICOPTER)
    27e4:	80 91 d8 06 	lds	r24, 0x06D8
    27e8:	82 30       	cpi	r24, 0x02	; 2
    27ea:	39 f4       	brne	.+14     	; 0x27fa <ZEROMotors+0x2e>
	{
		MotorOut[3] = SERVO_IN_MIDDLE;
    27ec:	86 e2       	ldi	r24, 0x26	; 38
    27ee:	92 e0       	ldi	r25, 0x02	; 2
    27f0:	90 93 9f 05 	sts	0x059F, r25
    27f4:	80 93 9e 05 	sts	0x059E, r24
    27f8:	04 c0       	rjmp	.+8      	; 0x2802 <ZEROMotors+0x36>
	}	
	else
	{
		MotorOut[3] = 0;
    27fa:	10 92 9f 05 	sts	0x059F, r1
    27fe:	10 92 9e 05 	sts	0x059E, r1
	}		
		
	Motor_GenerateOutputSignal();
    2802:	0e 94 c9 24 	call	0x4992	; 0x4992 <Motor_GenerateOutputSignal>
    2806:	08 95       	ret

00002808 <MainLoop>:
	This is the main loop of the application.
*/

static uint16_t LowpassOutYaw;
void MainLoop(void)
{
    2808:	8f 92       	push	r8
    280a:	9f 92       	push	r9
    280c:	af 92       	push	r10
    280e:	bf 92       	push	r11
    2810:	cf 92       	push	r12
    2812:	df 92       	push	r13
    2814:	ef 92       	push	r14
    2816:	ff 92       	push	r15
    2818:	0f 93       	push	r16
    281a:	1f 93       	push	r17
    281c:	cf 93       	push	r28
    281e:	df 93       	push	r29
	
	RX_CopyLatestReceiverValues();
    2820:	0e 94 77 27 	call	0x4eee	; 0x4eee <RX_CopyLatestReceiverValues>
	//RX_Snapshot_1 [RXChannel_THR]= RX_Snapshot[RXChannel_THR];
	RX_Snapshot   [RXChannel_THR]= RX_Latest[ActiveRXIndex][RXChannel_THR];
    2824:	20 91 cc 05 	lds	r18, 0x05CC
    2828:	82 2f       	mov	r24, r18
    282a:	90 e0       	ldi	r25, 0x00	; 0
    282c:	fc 01       	movw	r30, r24
    282e:	ee 0f       	add	r30, r30
    2830:	ff 1f       	adc	r31, r31
    2832:	23 e0       	ldi	r18, 0x03	; 3
    2834:	88 0f       	add	r24, r24
    2836:	99 1f       	adc	r25, r25
    2838:	2a 95       	dec	r18
    283a:	e1 f7       	brne	.-8      	; 0x2834 <MainLoop+0x2c>
    283c:	e8 0f       	add	r30, r24
    283e:	f9 1f       	adc	r31, r25
    2840:	ec 5f       	subi	r30, 0xFC	; 252
    2842:	f9 4f       	sbci	r31, 0xF9	; 249
    2844:	86 81       	ldd	r24, Z+6	; 0x06
    2846:	97 81       	ldd	r25, Z+7	; 0x07
    2848:	90 93 c7 05 	sts	0x05C7, r25
    284c:	80 93 c6 05 	sts	0x05C6, r24
	Sensors_ReadAll();	
    2850:	0e 94 e7 29 	call	0x53ce	; 0x53ce <Sensors_ReadAll>
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    2854:	f8 94       	cli
	
	
	
	ATOMIC_BLOCK(ATOMIC_FORCEON)
    {
      CurrentTCNT1_X = TCNT1_X;
    2856:	80 91 5e 06 	lds	r24, 0x065E
    285a:	90 91 5f 06 	lds	r25, 0x065F
    285e:	90 93 5d 06 	sts	0x065D, r25
    2862:	80 93 5c 06 	sts	0x065C, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    2866:	78 94       	sei
    }

	IMU();
    2868:	0e 94 1b 1b 	call	0x3636	; 0x3636 <IMU>
 
	bResetTCNR1_X = true;
    286c:	21 e0       	ldi	r18, 0x01	; 1
    286e:	20 93 57 06 	sts	0x0657, r18
	
	
	if (Config.RX_mode==RX_mode_BuddyMode)
    2872:	80 91 d3 06 	lds	r24, 0x06D3
    2876:	88 23       	and	r24, r24
    2878:	89 f4       	brne	.+34     	; 0x289c <MainLoop+0x94>
	{   // in Buddy mode AUX channel is used for instance switching.
		if (IS_TX2_GOOD)
    287a:	80 91 b8 07 	lds	r24, 0x07B8
    287e:	80 7f       	andi	r24, 0xF0	; 240
    2880:	69 f4       	brne	.+26     	; 0x289c <MainLoop+0x94>
		{
			if (RX_Latest[RX_MAIN][RXChannel_AUX] < STICK_RIGHT)
    2882:	80 91 16 06 	lds	r24, 0x0616
    2886:	90 91 17 06 	lds	r25, 0x0617
    288a:	3e ef       	ldi	r19, 0xFE	; 254
    288c:	80 37       	cpi	r24, 0x70	; 112
    288e:	93 07       	cpc	r25, r19
    2890:	1c f4       	brge	.+6      	; 0x2898 <MainLoop+0x90>
			{
				ActiveRXIndex = 0;		// use Primary RX
    2892:	10 92 cc 05 	sts	0x05CC, r1
    2896:	02 c0       	rjmp	.+4      	; 0x289c <MainLoop+0x94>
			}
			else
			{
				ActiveRXIndex = 1;		// use Secondary RX
    2898:	20 93 cc 05 	sts	0x05CC, r18
	
		
	////////// Slow Actions inside
	// HINT: you can try to skip this if flying to save time for more useful tasks as user cannot access menu when flying
	
	if (TCNT_X_snapshot2==0) TCNT_X_snapshot2 = CurrentTCNT1_X;
    289c:	80 91 ea 05 	lds	r24, 0x05EA
    28a0:	90 91 eb 05 	lds	r25, 0x05EB
    28a4:	20 91 5c 06 	lds	r18, 0x065C
    28a8:	30 91 5d 06 	lds	r19, 0x065D
    28ac:	00 97       	sbiw	r24, 0x00	; 0
    28ae:	29 f4       	brne	.+10     	; 0x28ba <MainLoop+0xb2>
    28b0:	30 93 eb 05 	sts	0x05EB, r19
    28b4:	20 93 ea 05 	sts	0x05EA, r18
    28b8:	6a c0       	rjmp	.+212    	; 0x298e <MainLoop+0x186>
	else if ( ((CurrentTCNT1_X- TCNT_X_snapshot2) > 4) )  // TCNT1_X ticks in 32.768us
    28ba:	28 1b       	sub	r18, r24
    28bc:	39 0b       	sbc	r19, r25
    28be:	25 30       	cpi	r18, 0x05	; 5
    28c0:	31 05       	cpc	r19, r1
    28c2:	08 f4       	brcc	.+2      	; 0x28c6 <MainLoop+0xbe>
    28c4:	64 c0       	rjmp	.+200    	; 0x298e <MainLoop+0x186>
	{
		Menu_MenuShow();
    28c6:	0e 94 ce 37 	call	0x6f9c	; 0x6f9c <Menu_MenuShow>
		
		if (Config.VoltageAlarm > 0)
    28ca:	80 91 25 07 	lds	r24, 0x0725
    28ce:	88 23       	and	r24, r24
    28d0:	79 f0       	breq	.+30     	; 0x28f0 <MainLoop+0xe8>
		{
			//Sensor_GetBattery();
			if (Sensors_Latest[V_BAT_Index] < Config.VoltageAlarm)
    28d2:	20 91 49 06 	lds	r18, 0x0649
    28d6:	30 91 4a 06 	lds	r19, 0x064A
    28da:	90 e0       	ldi	r25, 0x00	; 0
    28dc:	40 91 c5 06 	lds	r20, 0x06C5
    28e0:	28 17       	cp	r18, r24
    28e2:	39 07       	cpc	r19, r25
    28e4:	14 f4       	brge	.+4      	; 0x28ea <MainLoop+0xe2>
			{
				
				SystemErrorType = SET_SYS_ERR_VOLTAGE;
    28e6:	42 60       	ori	r20, 0x02	; 2
    28e8:	01 c0       	rjmp	.+2      	; 0x28ec <MainLoop+0xe4>
			}
			else
			{
				SystemErrorType = CLR_SYS_ERR_VOLTAGE;
    28ea:	4d 7f       	andi	r20, 0xFD	; 253
    28ec:	40 93 c5 06 	sts	0x06C5, r20
				
			}
		}	
		if (SystemErrorType != SYS_ERR_NON)
    28f0:	80 91 c5 06 	lds	r24, 0x06C5
    28f4:	88 23       	and	r24, r24
    28f6:	51 f0       	breq	.+20     	; 0x290c <MainLoop+0x104>
		{
			Buzzer =~Buzzer ;	
    28f8:	85 b1       	in	r24, 0x05	; 5
    28fa:	86 95       	lsr	r24
    28fc:	80 95       	com	r24
    28fe:	81 70       	andi	r24, 0x01	; 1
    2900:	88 0f       	add	r24, r24
    2902:	95 b1       	in	r25, 0x05	; 5
    2904:	9d 7f       	andi	r25, 0xFD	; 253
    2906:	98 2b       	or	r25, r24
    2908:	95 b9       	out	0x05, r25	; 5
    290a:	01 c0       	rjmp	.+2      	; 0x290e <MainLoop+0x106>
		}
		else
		{
			Buzzer = OFF;
    290c:	29 98       	cbi	0x05, 1	; 5
		}
		
		if (Config.RX_mode==RX_mode_UARTMode)
    290e:	80 91 d3 06 	lds	r24, 0x06D3
    2912:	8f 3f       	cpi	r24, 0xFF	; 255
    2914:	c1 f5       	brne	.+112    	; 0x2986 <MainLoop+0x17e>
		{
				if ((FlyingModesToggle != LOW) && ( RX_Latest[RX_MAIN][RXChannel_AUX] < STICK_RIGHT ))
    2916:	20 91 21 05 	lds	r18, 0x0521
    291a:	22 23       	and	r18, r18
    291c:	81 f0       	breq	.+32     	; 0x293e <MainLoop+0x136>
    291e:	80 91 16 06 	lds	r24, 0x0616
    2922:	90 91 17 06 	lds	r25, 0x0617
    2926:	4e ef       	ldi	r20, 0xFE	; 254
    2928:	80 37       	cpi	r24, 0x70	; 112
    292a:	94 07       	cpc	r25, r20
    292c:	34 f4       	brge	.+12     	; 0x293a <MainLoop+0x132>
				{
					nFlyingModes = FLYINGMODE_ALTHOLD;
    292e:	84 e0       	ldi	r24, 0x04	; 4
    2930:	80 93 1c 06 	sts	0x061C, r24
					FlyingModesToggle = LOW;
    2934:	10 92 21 05 	sts	0x0521, r1
    2938:	26 c0       	rjmp	.+76     	; 0x2986 <MainLoop+0x17e>
				} else
				if ((FlyingModesToggle != HIGH) && (RX_Latest[RX_MAIN][RXChannel_AUX] > STICK_LEFT ))
    293a:	21 30       	cpi	r18, 0x01	; 1
    293c:	71 f0       	breq	.+28     	; 0x295a <MainLoop+0x152>
    293e:	80 91 16 06 	lds	r24, 0x0616
    2942:	90 91 17 06 	lds	r25, 0x0617
    2946:	51 e0       	ldi	r21, 0x01	; 1
    2948:	81 39       	cpi	r24, 0x91	; 145
    294a:	95 07       	cpc	r25, r21
    294c:	24 f0       	brlt	.+8      	; 0x2956 <MainLoop+0x14e>
				{
					//LED_Orange=ON;
					nFlyingModes = FLYINGMODE_ACRO;
    294e:	81 e0       	ldi	r24, 0x01	; 1
    2950:	80 93 1c 06 	sts	0x061C, r24
    2954:	16 c0       	rjmp	.+44     	; 0x2982 <MainLoop+0x17a>
					FlyingModesToggle = HIGH;
				} else
				if ((FlyingModesToggle != MID) && (RX_Latest[RX_MAIN][RXChannel_AUX]< STICK_LEFT) && ( RX_Latest[RX_MAIN][RXChannel_AUX] > STICK_RIGHT ))
    2956:	2b 30       	cpi	r18, 0x0B	; 11
    2958:	b1 f0       	breq	.+44     	; 0x2986 <MainLoop+0x17e>
    295a:	80 91 16 06 	lds	r24, 0x0616
    295e:	90 91 17 06 	lds	r25, 0x0617
    2962:	21 e0       	ldi	r18, 0x01	; 1
    2964:	80 39       	cpi	r24, 0x90	; 144
    2966:	92 07       	cpc	r25, r18
    2968:	74 f4       	brge	.+28     	; 0x2986 <MainLoop+0x17e>
    296a:	80 91 16 06 	lds	r24, 0x0616
    296e:	90 91 17 06 	lds	r25, 0x0617
    2972:	3e ef       	ldi	r19, 0xFE	; 254
    2974:	81 37       	cpi	r24, 0x71	; 113
    2976:	93 07       	cpc	r25, r19
    2978:	34 f0       	brlt	.+12     	; 0x2986 <MainLoop+0x17e>
				{
					nFlyingModes = FLYINGMODE_LEVEL;
    297a:	82 e0       	ldi	r24, 0x02	; 2
    297c:	80 93 1c 06 	sts	0x061C, r24
					FlyingModesToggle = MID;
    2980:	8b e0       	ldi	r24, 0x0B	; 11
    2982:	80 93 21 05 	sts	0x0521, r24
		}		
		//if ((IsArmed == true) && (RX_Snapshot[RXChannel_THR] < STICKThrottle_ARMING+160))
		//{ // calibrate when start flying
			//DynamicCalibration();
		//}			
		TCNT_X_snapshot2=0;
    2986:	10 92 eb 05 	sts	0x05EB, r1
    298a:	10 92 ea 05 	sts	0x05EA, r1
	}		
	
	//////////////// EOF Slow Loop
	
	if (RX_Snapshot[RXChannel_THR] < STICKThrottle_ARMING) 
    298e:	c0 91 c6 05 	lds	r28, 0x05C6
    2992:	d0 91 c7 05 	lds	r29, 0x05C7
    2996:	c2 33       	cpi	r28, 0x32	; 50
    2998:	d1 05       	cpc	r29, r1
    299a:	4c f4       	brge	.+18     	; 0x29ae <MainLoop+0x1a6>
	{	
		
		// Throttle is LOW
		// Here you can add code without caring about delays. As there quad is already off and on land.
		// here we test different positions of sticks to enable arm/disarm, Quad/X-Quad
		HandleSticksForArming();
    299c:	0e 94 e7 11 	call	0x23ce	; 0x23ce <HandleSticksForArming>
		
		// Stop motors if Throttle Stick is less than minimum.
		ZEROMotors();
    29a0:	0e 94 e6 13 	call	0x27cc	; 0x27cc <ZEROMotors>
		ZERO_Is();
    29a4:	0e 94 db 1a 	call	0x35b6	; 0x35b6 <ZERO_Is>
		IMU_Reset(); // reset angles for gyro [STABLE MODE]
    29a8:	0e 94 07 1b 	call	0x360e	; 0x360e <IMU_Reset>
    29ac:	6b c3       	rjmp	.+1750   	; 0x3084 <MainLoop+0x87c>
	}
	else
	{	// Throttle stick is NOT Down .... TAKE CARE
		
		if (IsArmed==false)
    29ae:	80 91 85 07 	lds	r24, 0x0785
    29b2:	88 23       	and	r24, r24
    29b4:	29 f4       	brne	.+10     	; 0x29c0 <MainLoop+0x1b8>
		{  // However we are still DisArmed
			ZEROMotors();
    29b6:	0e 94 e6 13 	call	0x27cc	; 0x27cc <ZEROMotors>
			
			// Sticks as Keyboard --- we are already disarmed to reach here.
			HandleSticksAsKeys();
    29ba:	0e 94 59 13 	call	0x26b2	; 0x26b2 <HandleSticksAsKeys>
    29be:	62 c3       	rjmp	.+1732   	; 0x3084 <MainLoop+0x87c>
		}
		else
		{	// MOTORS ARE ON HERE .... DANGEROUS
			
			
			TCNT_X_snapshotAutoDisarm = 0; // ZERO [user may disarm then fly slowly..in this case the qud will disarm once he turned off the stick...because the counter counts once the quad is armed..e.g. if it takes n sec to disarm automatically..user took n-1 sec keeping the stick low after arming then it will take 1 sec to disarm again after lowing the stick under STICKThrottle_ARMING
    29c0:	10 92 1e 06 	sts	0x061E, r1
    29c4:	10 92 1d 06 	sts	0x061D, r1
			
			// Armed & Throttle Stick > MIN . . . We should Fly now.
			//RX_Snapshot_1 [RXChannel_AIL]= RX_Snapshot[RXChannel_AIL];
			//RX_Snapshot_1 [RXChannel_ELE]= RX_Snapshot[RXChannel_ELE];
			//RX_Snapshot_1 [RXChannel_RUD]= RX_Snapshot[RXChannel_RUD];
			RX_Snapshot	  [RXChannel_AIL] = (RX_Latest[ActiveRXIndex][RXChannel_AIL] * Config.StickScaling * 0.05 );
    29c8:	20 91 cc 05 	lds	r18, 0x05CC
    29cc:	82 2f       	mov	r24, r18
    29ce:	90 e0       	ldi	r25, 0x00	; 0
    29d0:	fc 01       	movw	r30, r24
    29d2:	ee 0f       	add	r30, r30
    29d4:	ff 1f       	adc	r31, r31
    29d6:	13 e0       	ldi	r17, 0x03	; 3
    29d8:	88 0f       	add	r24, r24
    29da:	99 1f       	adc	r25, r25
    29dc:	1a 95       	dec	r17
    29de:	e1 f7       	brne	.-8      	; 0x29d8 <MainLoop+0x1d0>
    29e0:	e8 0f       	add	r30, r24
    29e2:	f9 1f       	adc	r31, r25
    29e4:	ec 5f       	subi	r30, 0xFC	; 252
    29e6:	f9 4f       	sbci	r31, 0xF9	; 249
    29e8:	80 81       	ld	r24, Z
    29ea:	91 81       	ldd	r25, Z+1	; 0x01
    29ec:	e0 90 dd 06 	lds	r14, 0x06DD
    29f0:	ff 24       	eor	r15, r15
    29f2:	e8 9e       	mul	r14, r24
    29f4:	b0 01       	movw	r22, r0
    29f6:	e9 9e       	mul	r14, r25
    29f8:	70 0d       	add	r23, r0
    29fa:	f8 9e       	mul	r15, r24
    29fc:	70 0d       	add	r23, r0
    29fe:	11 24       	eor	r1, r1
    2a00:	88 27       	eor	r24, r24
    2a02:	77 fd       	sbrc	r23, 7
    2a04:	80 95       	com	r24
    2a06:	98 2f       	mov	r25, r24
    2a08:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    2a0c:	2d ec       	ldi	r18, 0xCD	; 205
    2a0e:	3c ec       	ldi	r19, 0xCC	; 204
    2a10:	4c e4       	ldi	r20, 0x4C	; 76
    2a12:	5d e3       	ldi	r21, 0x3D	; 61
    2a14:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    2a18:	0e 94 f5 38 	call	0x71ea	; 0x71ea <__fixsfsi>
    2a1c:	70 93 c1 05 	sts	0x05C1, r23
    2a20:	60 93 c0 05 	sts	0x05C0, r22
			RX_Snapshot   [RXChannel_ELE] = (RX_Latest[ActiveRXIndex][RXChannel_ELE] * Config.StickScaling * 0.05 ); 
    2a24:	20 91 cc 05 	lds	r18, 0x05CC
    2a28:	82 2f       	mov	r24, r18
    2a2a:	90 e0       	ldi	r25, 0x00	; 0
    2a2c:	fc 01       	movw	r30, r24
    2a2e:	ee 0f       	add	r30, r30
    2a30:	ff 1f       	adc	r31, r31
    2a32:	a3 e0       	ldi	r26, 0x03	; 3
    2a34:	88 0f       	add	r24, r24
    2a36:	99 1f       	adc	r25, r25
    2a38:	aa 95       	dec	r26
    2a3a:	e1 f7       	brne	.-8      	; 0x2a34 <MainLoop+0x22c>
    2a3c:	e8 0f       	add	r30, r24
    2a3e:	f9 1f       	adc	r31, r25
    2a40:	ec 5f       	subi	r30, 0xFC	; 252
    2a42:	f9 4f       	sbci	r31, 0xF9	; 249
    2a44:	82 81       	ldd	r24, Z+2	; 0x02
    2a46:	93 81       	ldd	r25, Z+3	; 0x03
    2a48:	e8 9e       	mul	r14, r24
    2a4a:	b0 01       	movw	r22, r0
    2a4c:	e9 9e       	mul	r14, r25
    2a4e:	70 0d       	add	r23, r0
    2a50:	f8 9e       	mul	r15, r24
    2a52:	70 0d       	add	r23, r0
    2a54:	11 24       	eor	r1, r1
    2a56:	88 27       	eor	r24, r24
    2a58:	77 fd       	sbrc	r23, 7
    2a5a:	80 95       	com	r24
    2a5c:	98 2f       	mov	r25, r24
    2a5e:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    2a62:	2d ec       	ldi	r18, 0xCD	; 205
    2a64:	3c ec       	ldi	r19, 0xCC	; 204
    2a66:	4c e4       	ldi	r20, 0x4C	; 76
    2a68:	5d e3       	ldi	r21, 0x3D	; 61
    2a6a:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    2a6e:	0e 94 f5 38 	call	0x71ea	; 0x71ea <__fixsfsi>
    2a72:	70 93 c3 05 	sts	0x05C3, r23
    2a76:	60 93 c2 05 	sts	0x05C2, r22
			RX_Snapshot   [RXChannel_RUD] = (RX_Latest[ActiveRXIndex][RXChannel_RUD] * Config.StickScaling * 0.05 ); // version 0.9.9 
    2a7a:	20 91 cc 05 	lds	r18, 0x05CC
    2a7e:	82 2f       	mov	r24, r18
    2a80:	90 e0       	ldi	r25, 0x00	; 0
    2a82:	fc 01       	movw	r30, r24
    2a84:	ee 0f       	add	r30, r30
    2a86:	ff 1f       	adc	r31, r31
    2a88:	63 e0       	ldi	r22, 0x03	; 3
    2a8a:	88 0f       	add	r24, r24
    2a8c:	99 1f       	adc	r25, r25
    2a8e:	6a 95       	dec	r22
    2a90:	e1 f7       	brne	.-8      	; 0x2a8a <MainLoop+0x282>
    2a92:	e8 0f       	add	r30, r24
    2a94:	f9 1f       	adc	r31, r25
    2a96:	ec 5f       	subi	r30, 0xFC	; 252
    2a98:	f9 4f       	sbci	r31, 0xF9	; 249
    2a9a:	84 81       	ldd	r24, Z+4	; 0x04
    2a9c:	95 81       	ldd	r25, Z+5	; 0x05
    2a9e:	e8 9e       	mul	r14, r24
    2aa0:	b0 01       	movw	r22, r0
    2aa2:	e9 9e       	mul	r14, r25
    2aa4:	70 0d       	add	r23, r0
    2aa6:	f8 9e       	mul	r15, r24
    2aa8:	70 0d       	add	r23, r0
    2aaa:	11 24       	eor	r1, r1
    2aac:	88 27       	eor	r24, r24
    2aae:	77 fd       	sbrc	r23, 7
    2ab0:	80 95       	com	r24
    2ab2:	98 2f       	mov	r25, r24
    2ab4:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    2ab8:	2d ec       	ldi	r18, 0xCD	; 205
    2aba:	3c ec       	ldi	r19, 0xCC	; 204
    2abc:	4c e4       	ldi	r20, 0x4C	; 76
    2abe:	5d e3       	ldi	r21, 0x3D	; 61
    2ac0:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    2ac4:	0e 94 f5 38 	call	0x71ea	; 0x71ea <__fixsfsi>
    2ac8:	70 93 c5 05 	sts	0x05C5, r23
    2acc:	60 93 c4 05 	sts	0x05C4, r22
		
			
			// Add Throttle to Motors
			MotorOut[0] = RX_Snapshot[RXChannel_THR];
			MotorOut[1] = RX_Snapshot[RXChannel_THR];
			if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    2ad0:	80 91 d8 06 	lds	r24, 0x06D8
    2ad4:	81 30       	cpi	r24, 0x01	; 1
    2ad6:	71 f4       	brne	.+28     	; 0x2af4 <MainLoop+0x2ec>
				* The logic below depends on board orientation i.e. sensor orientation compared to motor directions.
				* the IMU in ACHRO mode is totally independent from user sticks ... so it does not matter how the user
				* flies his quad i.e. in X or PLUS .... it does not matter because it is handled in another code lines not here.
				* here we handle board orientation only.
				*/
				if (Config.BoardOrientationMode==QuadFlyingMode_X)
    2ad8:	40 91 d9 06 	lds	r20, 0x06D9
    2adc:	80 91 37 06 	lds	r24, 0x0637
    2ae0:	90 91 38 06 	lds	r25, 0x0638
    2ae4:	20 91 b8 05 	lds	r18, 0x05B8
    2ae8:	30 91 b9 05 	lds	r19, 0x05B9
    2aec:	41 30       	cpi	r20, 0x01	; 1
    2aee:	09 f0       	breq	.+2      	; 0x2af2 <MainLoop+0x2ea>
    2af0:	57 c0       	rjmp	.+174    	; 0x2ba0 <MainLoop+0x398>
    2af2:	34 c0       	rjmp	.+104    	; 0x2b5c <MainLoop+0x354>
			}
			else
			{	// Balance Tri-Copter
				// NOT VALID if Board Orientation is X
					
				MotorOut[2] += gyroPitch; // * 1.0;
    2af4:	60 91 37 06 	lds	r22, 0x0637
    2af8:	70 91 38 06 	lds	r23, 0x0638
    2afc:	cb 01       	movw	r24, r22
    2afe:	8c 0f       	add	r24, r28
    2b00:	9d 1f       	adc	r25, r29
    2b02:	90 93 9d 05 	sts	0x059D, r25
    2b06:	80 93 9c 05 	sts	0x059C, r24
					
				gyroPitch    = gyroPitch * 0.5; // distribute pitch on two front motors .... half the effect. 
    2b0a:	88 27       	eor	r24, r24
    2b0c:	77 fd       	sbrc	r23, 7
    2b0e:	80 95       	com	r24
    2b10:	98 2f       	mov	r25, r24
    2b12:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    2b16:	20 e0       	ldi	r18, 0x00	; 0
    2b18:	30 e0       	ldi	r19, 0x00	; 0
    2b1a:	40 e0       	ldi	r20, 0x00	; 0
    2b1c:	5f e3       	ldi	r21, 0x3F	; 63
    2b1e:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    2b22:	0e 94 f5 38 	call	0x71ea	; 0x71ea <__fixsfsi>
    2b26:	9b 01       	movw	r18, r22
    2b28:	70 93 38 06 	sts	0x0638, r23
    2b2c:	60 93 37 06 	sts	0x0637, r22
				MotorOut[0] -= gyroPitch  ;
				MotorOut[1] -= gyroPitch  ;
					
				gyroRoll = gyroRoll; // * 0.85;
    2b30:	40 91 b8 05 	lds	r20, 0x05B8
    2b34:	50 91 b9 05 	lds	r21, 0x05B9
				// NOT VALID if Board Orientation is X
					
				MotorOut[2] += gyroPitch; // * 1.0;
					
				gyroPitch    = gyroPitch * 0.5; // distribute pitch on two front motors .... half the effect. 
				MotorOut[0] -= gyroPitch  ;
    2b38:	ce 01       	movw	r24, r28
    2b3a:	82 1b       	sub	r24, r18
    2b3c:	93 0b       	sbc	r25, r19
				MotorOut[1] -= gyroPitch  ;
					
				gyroRoll = gyroRoll; // * 0.85;
				MotorOut[0] -= gyroRoll  ;
    2b3e:	84 1b       	sub	r24, r20
    2b40:	95 0b       	sbc	r25, r21
    2b42:	90 93 99 05 	sts	0x0599, r25
    2b46:	80 93 98 05 	sts	0x0598, r24
					
				MotorOut[2] += gyroPitch; // * 1.0;
					
				gyroPitch    = gyroPitch * 0.5; // distribute pitch on two front motors .... half the effect. 
				MotorOut[0] -= gyroPitch  ;
				MotorOut[1] -= gyroPitch  ;
    2b4a:	c4 0f       	add	r28, r20
    2b4c:	d5 1f       	adc	r29, r21
					
				gyroRoll = gyroRoll; // * 0.85;
				MotorOut[0] -= gyroRoll  ;
				MotorOut[1] += gyroRoll  ;
    2b4e:	c2 1b       	sub	r28, r18
    2b50:	d3 0b       	sbc	r29, r19
    2b52:	d0 93 9b 05 	sts	0x059B, r29
    2b56:	c0 93 9a 05 	sts	0x059A, r28
    2b5a:	3d c0       	rjmp	.+122    	; 0x2bd6 <MainLoop+0x3ce>
				if (Config.BoardOrientationMode==QuadFlyingMode_X)
				{	// Board Orientation in X-Mode
					// {-1,1,1,-1} QUAD_ROL_X
					MotorOut[0] -= gyroRoll ;
					MotorOut[3] -= gyroRoll ;
					MotorOut[1] += gyroRoll ;
    2b5c:	b9 01       	movw	r22, r18
    2b5e:	6c 0f       	add	r22, r28
    2b60:	7d 1f       	adc	r23, r29
				* here we handle board orientation only.
				*/
				if (Config.BoardOrientationMode==QuadFlyingMode_X)
				{	// Board Orientation in X-Mode
					// {-1,1,1,-1} QUAD_ROL_X
					MotorOut[0] -= gyroRoll ;
    2b62:	ae 01       	movw	r20, r28
    2b64:	42 1b       	sub	r20, r18
    2b66:	53 0b       	sbc	r21, r19
					MotorOut[3] -= gyroRoll ;
					MotorOut[1] += gyroRoll ;
					MotorOut[2] += gyroRoll ;
					
					// {-1,-1,1,1} QUAD_AIL_X
					MotorOut[0] -= gyroPitch;
    2b68:	48 1b       	sub	r20, r24
    2b6a:	59 0b       	sbc	r21, r25
    2b6c:	50 93 99 05 	sts	0x0599, r21
    2b70:	40 93 98 05 	sts	0x0598, r20
					MotorOut[1] -= gyroPitch;
    2b74:	ab 01       	movw	r20, r22
    2b76:	48 1b       	sub	r20, r24
    2b78:	59 0b       	sbc	r21, r25
    2b7a:	50 93 9b 05 	sts	0x059B, r21
    2b7e:	40 93 9a 05 	sts	0x059A, r20
					MotorOut[2] += gyroPitch;
    2b82:	68 0f       	add	r22, r24
    2b84:	79 1f       	adc	r23, r25
    2b86:	70 93 9d 05 	sts	0x059D, r23
    2b8a:	60 93 9c 05 	sts	0x059C, r22
				*/
				if (Config.BoardOrientationMode==QuadFlyingMode_X)
				{	// Board Orientation in X-Mode
					// {-1,1,1,-1} QUAD_ROL_X
					MotorOut[0] -= gyroRoll ;
					MotorOut[3] -= gyroRoll ;
    2b8e:	c8 0f       	add	r28, r24
    2b90:	d9 1f       	adc	r29, r25
					
					// {-1,-1,1,1} QUAD_AIL_X
					MotorOut[0] -= gyroPitch;
					MotorOut[1] -= gyroPitch;
					MotorOut[2] += gyroPitch;
					MotorOut[3] += gyroPitch;
    2b92:	c2 1b       	sub	r28, r18
    2b94:	d3 0b       	sbc	r29, r19
    2b96:	d0 93 9f 05 	sts	0x059F, r29
    2b9a:	c0 93 9e 05 	sts	0x059E, r28
    2b9e:	1b c0       	rjmp	.+54     	; 0x2bd6 <MainLoop+0x3ce>
					
				}
				else
				{	// Board Orientation in Plus-Mode
					// {0,1,0,-1} QUAD_ROL_PLUS
					MotorOut[1] += gyroRoll  ;
    2ba0:	a9 01       	movw	r20, r18
    2ba2:	4c 0f       	add	r20, r28
    2ba4:	5d 1f       	adc	r21, r29
    2ba6:	50 93 9b 05 	sts	0x059B, r21
    2baa:	40 93 9a 05 	sts	0x059A, r20
					MotorOut[3] -= gyroRoll  ;
    2bae:	ae 01       	movw	r20, r28
    2bb0:	42 1b       	sub	r20, r18
    2bb2:	53 0b       	sbc	r21, r19
    2bb4:	50 93 9f 05 	sts	0x059F, r21
    2bb8:	40 93 9e 05 	sts	0x059E, r20
				
					// {-1,0,1,0} QUAD_AIL_PLUS
					MotorOut[0] -= gyroPitch ;
    2bbc:	9e 01       	movw	r18, r28
    2bbe:	28 1b       	sub	r18, r24
    2bc0:	39 0b       	sbc	r19, r25
    2bc2:	30 93 99 05 	sts	0x0599, r19
    2bc6:	20 93 98 05 	sts	0x0598, r18
					MotorOut[2] += gyroPitch ; 
    2bca:	c8 0f       	add	r28, r24
    2bcc:	d9 1f       	adc	r29, r25
    2bce:	d0 93 9d 05 	sts	0x059D, r29
    2bd2:	c0 93 9c 05 	sts	0x059C, r28
			*
			*	Pilot Control Logic.
			*	Handles signals from remote control in ACRO mode.
			*	in stabilization mode controls are added in IMU logic as angles.
			*/
			if (nFlyingModes == FLYINGMODE_ACRO)
    2bd6:	80 91 1c 06 	lds	r24, 0x061C
    2bda:	81 30       	cpi	r24, 0x01	; 1
    2bdc:	09 f0       	breq	.+2      	; 0x2be0 <MainLoop+0x3d8>
    2bde:	2e c1       	rjmp	.+604    	; 0x2e3c <MainLoop+0x634>
			{
				if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    2be0:	90 91 d8 06 	lds	r25, 0x06D8
    2be4:	80 91 da 06 	lds	r24, 0x06DA
    2be8:	91 30       	cpi	r25, 0x01	; 1
    2bea:	09 f0       	breq	.+2      	; 0x2bee <MainLoop+0x3e6>
    2bec:	a3 c0       	rjmp	.+326    	; 0x2d34 <MainLoop+0x52c>
    2bee:	60 91 c0 05 	lds	r22, 0x05C0
    2bf2:	70 91 c1 05 	lds	r23, 0x05C1
    2bf6:	e0 90 c2 05 	lds	r14, 0x05C2
    2bfa:	f0 90 c3 05 	lds	r15, 0x05C3
    2bfe:	80 90 9e 05 	lds	r8, 0x059E
    2c02:	90 90 9f 05 	lds	r9, 0x059F
    2c06:	a0 90 9a 05 	lds	r10, 0x059A
    2c0a:	b0 90 9b 05 	lds	r11, 0x059B
    2c0e:	c0 90 9c 05 	lds	r12, 0x059C
    2c12:	d0 90 9d 05 	lds	r13, 0x059D
    2c16:	00 91 98 05 	lds	r16, 0x0598
    2c1a:	10 91 99 05 	lds	r17, 0x0599
				{
				
					if (Config.QuadFlyingMode==QuadFlyingMode_X)
    2c1e:	81 30       	cpi	r24, 0x01	; 1
    2c20:	09 f0       	breq	.+2      	; 0x2c24 <MainLoop+0x41c>
    2c22:	49 c0       	rjmp	.+146    	; 0x2cb6 <MainLoop+0x4ae>
					{
						RX_Snapshot[RXChannel_AIL] = RX_Snapshot[RXChannel_AIL] * 0.63;		// because we fly X
    2c24:	88 27       	eor	r24, r24
    2c26:	77 fd       	sbrc	r23, 7
    2c28:	80 95       	com	r24
    2c2a:	98 2f       	mov	r25, r24
    2c2c:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    2c30:	2e ea       	ldi	r18, 0xAE	; 174
    2c32:	37 e4       	ldi	r19, 0x47	; 71
    2c34:	41 e2       	ldi	r20, 0x21	; 33
    2c36:	5f e3       	ldi	r21, 0x3F	; 63
    2c38:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    2c3c:	0e 94 f5 38 	call	0x71ea	; 0x71ea <__fixsfsi>
    2c40:	eb 01       	movw	r28, r22
    2c42:	70 93 c1 05 	sts	0x05C1, r23
    2c46:	60 93 c0 05 	sts	0x05C0, r22
						RX_Snapshot[RXChannel_ELE] = RX_Snapshot[RXChannel_ELE] * 0.63;
    2c4a:	b7 01       	movw	r22, r14
    2c4c:	88 27       	eor	r24, r24
    2c4e:	77 fd       	sbrc	r23, 7
    2c50:	80 95       	com	r24
    2c52:	98 2f       	mov	r25, r24
    2c54:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    2c58:	2e ea       	ldi	r18, 0xAE	; 174
    2c5a:	37 e4       	ldi	r19, 0x47	; 71
    2c5c:	41 e2       	ldi	r20, 0x21	; 33
    2c5e:	5f e3       	ldi	r21, 0x3F	; 63
    2c60:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    2c64:	0e 94 f5 38 	call	0x71ea	; 0x71ea <__fixsfsi>
    2c68:	9b 01       	movw	r18, r22
    2c6a:	70 93 c3 05 	sts	0x05C3, r23
    2c6e:	60 93 c2 05 	sts	0x05C2, r22
					
						// {0.63,-0.63,-0.63,0.63} QUAD_AIL_X
						MotorOut[0] += RX_Snapshot[RXChannel_AIL] ;
						MotorOut[3] += RX_Snapshot[RXChannel_AIL] ;
    2c72:	8c 0e       	add	r8, r28
    2c74:	9d 1e       	adc	r9, r29
						MotorOut[1] -= RX_Snapshot[RXChannel_AIL] ;
						MotorOut[2] -= RX_Snapshot[RXChannel_AIL] ;
    2c76:	cc 1a       	sub	r12, r28
    2c78:	dd 0a       	sbc	r13, r29
					{
						RX_Snapshot[RXChannel_AIL] = RX_Snapshot[RXChannel_AIL] * 0.63;		// because we fly X
						RX_Snapshot[RXChannel_ELE] = RX_Snapshot[RXChannel_ELE] * 0.63;
					
						// {0.63,-0.63,-0.63,0.63} QUAD_AIL_X
						MotorOut[0] += RX_Snapshot[RXChannel_AIL] ;
    2c7a:	ce 01       	movw	r24, r28
    2c7c:	82 0f       	add	r24, r18
    2c7e:	93 1f       	adc	r25, r19
						MotorOut[3] += RX_Snapshot[RXChannel_AIL] ;
						MotorOut[1] -= RX_Snapshot[RXChannel_AIL] ;
						MotorOut[2] -= RX_Snapshot[RXChannel_AIL] ;
				
						// {0.63,0.63,-0.63,-0.63} QUAD_ELE_X
						MotorOut[0] += RX_Snapshot[RXChannel_ELE];
    2c80:	80 0f       	add	r24, r16
    2c82:	91 1f       	adc	r25, r17
    2c84:	90 93 99 05 	sts	0x0599, r25
    2c88:	80 93 98 05 	sts	0x0598, r24
						RX_Snapshot[RXChannel_ELE] = RX_Snapshot[RXChannel_ELE] * 0.63;
					
						// {0.63,-0.63,-0.63,0.63} QUAD_AIL_X
						MotorOut[0] += RX_Snapshot[RXChannel_AIL] ;
						MotorOut[3] += RX_Snapshot[RXChannel_AIL] ;
						MotorOut[1] -= RX_Snapshot[RXChannel_AIL] ;
    2c8c:	a2 0e       	add	r10, r18
    2c8e:	b3 1e       	adc	r11, r19
						MotorOut[2] -= RX_Snapshot[RXChannel_AIL] ;
				
						// {0.63,0.63,-0.63,-0.63} QUAD_ELE_X
						MotorOut[0] += RX_Snapshot[RXChannel_ELE];
						MotorOut[1] += RX_Snapshot[RXChannel_ELE];
    2c90:	ac 1a       	sub	r10, r28
    2c92:	bd 0a       	sbc	r11, r29
    2c94:	b0 92 9b 05 	sts	0x059B, r11
    2c98:	a0 92 9a 05 	sts	0x059A, r10
						MotorOut[2] -= RX_Snapshot[RXChannel_ELE];
    2c9c:	c2 1a       	sub	r12, r18
    2c9e:	d3 0a       	sbc	r13, r19
    2ca0:	d0 92 9d 05 	sts	0x059D, r13
    2ca4:	c0 92 9c 05 	sts	0x059C, r12
						MotorOut[3] -= RX_Snapshot[RXChannel_ELE];
    2ca8:	82 1a       	sub	r8, r18
    2caa:	93 0a       	sbc	r9, r19
    2cac:	90 92 9f 05 	sts	0x059F, r9
    2cb0:	80 92 9e 05 	sts	0x059E, r8
    2cb4:	2e c1       	rjmp	.+604    	; 0x2f12 <MainLoop+0x70a>
					
					}
					else
					{
				
						RX_Snapshot[RXChannel_AIL] = RX_Snapshot[RXChannel_AIL] * 0.9;		// 0.9: to reduce sensitivity more than STABLE mode
    2cb6:	88 27       	eor	r24, r24
    2cb8:	77 fd       	sbrc	r23, 7
    2cba:	80 95       	com	r24
    2cbc:	98 2f       	mov	r25, r24
    2cbe:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    2cc2:	26 e6       	ldi	r18, 0x66	; 102
    2cc4:	36 e6       	ldi	r19, 0x66	; 102
    2cc6:	46 e6       	ldi	r20, 0x66	; 102
    2cc8:	5f e3       	ldi	r21, 0x3F	; 63
    2cca:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    2cce:	0e 94 f5 38 	call	0x71ea	; 0x71ea <__fixsfsi>
    2cd2:	eb 01       	movw	r28, r22
    2cd4:	70 93 c1 05 	sts	0x05C1, r23
    2cd8:	60 93 c0 05 	sts	0x05C0, r22
						RX_Snapshot[RXChannel_ELE] = RX_Snapshot[RXChannel_ELE] * 0.9;
    2cdc:	b7 01       	movw	r22, r14
    2cde:	88 27       	eor	r24, r24
    2ce0:	77 fd       	sbrc	r23, 7
    2ce2:	80 95       	com	r24
    2ce4:	98 2f       	mov	r25, r24
    2ce6:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    2cea:	26 e6       	ldi	r18, 0x66	; 102
    2cec:	36 e6       	ldi	r19, 0x66	; 102
    2cee:	46 e6       	ldi	r20, 0x66	; 102
    2cf0:	5f e3       	ldi	r21, 0x3F	; 63
    2cf2:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    2cf6:	0e 94 f5 38 	call	0x71ea	; 0x71ea <__fixsfsi>
    2cfa:	70 93 c3 05 	sts	0x05C3, r23
    2cfe:	60 93 c2 05 	sts	0x05C2, r22
						// {0.9,0,-0.9,0} QUAD_ELE_PLUS
						MotorOut[0] += RX_Snapshot[RXChannel_ELE] ; 
    2d02:	06 0f       	add	r16, r22
    2d04:	17 1f       	adc	r17, r23
    2d06:	10 93 99 05 	sts	0x0599, r17
    2d0a:	00 93 98 05 	sts	0x0598, r16
						MotorOut[2] -= RX_Snapshot[RXChannel_ELE] ; 
    2d0e:	c6 1a       	sub	r12, r22
    2d10:	d7 0a       	sbc	r13, r23
    2d12:	d0 92 9d 05 	sts	0x059D, r13
    2d16:	c0 92 9c 05 	sts	0x059C, r12
						// {0,-0.9,0,0.9} QUAD_AIL_PLUS	
						MotorOut[1] -= RX_Snapshot[RXChannel_AIL] ; 
    2d1a:	ac 1a       	sub	r10, r28
    2d1c:	bd 0a       	sbc	r11, r29
    2d1e:	b0 92 9b 05 	sts	0x059B, r11
    2d22:	a0 92 9a 05 	sts	0x059A, r10
						MotorOut[3] += RX_Snapshot[RXChannel_AIL] ;  
    2d26:	c8 0d       	add	r28, r8
    2d28:	d9 1d       	adc	r29, r9
    2d2a:	d0 93 9f 05 	sts	0x059F, r29
    2d2e:	c0 93 9e 05 	sts	0x059E, r28
    2d32:	ef c0       	rjmp	.+478    	; 0x2f12 <MainLoop+0x70a>
				}
				else
				{ // TRICopter
					
						int8_t inv=1; // Flying in Y mode
						if (Config.QuadFlyingMode==QuadFlyingMode_X)
    2d34:	81 30       	cpi	r24, 0x01	; 1
    2d36:	11 f0       	breq	.+4      	; 0x2d3c <MainLoop+0x534>
					}
				}
				else
				{ // TRICopter
					
						int8_t inv=1; // Flying in Y mode
    2d38:	01 e0       	ldi	r16, 0x01	; 1
    2d3a:	01 c0       	rjmp	.+2      	; 0x2d3e <MainLoop+0x536>
						if (Config.QuadFlyingMode==QuadFlyingMode_X)
						{ // Flying in A mode
							inv = -1;
    2d3c:	0f ef       	ldi	r16, 0xFF	; 255
						}							
							// {0.5,0.5,1.1,X} TRI_ELE_FRONT
							MotorOut[2] -= inv * (RX_Snapshot[RXChannel_ELE] * 1.1); 
    2d3e:	c0 91 c2 05 	lds	r28, 0x05C2
    2d42:	d0 91 c3 05 	lds	r29, 0x05C3
    2d46:	60 91 9c 05 	lds	r22, 0x059C
    2d4a:	70 91 9d 05 	lds	r23, 0x059D
    2d4e:	88 27       	eor	r24, r24
    2d50:	77 fd       	sbrc	r23, 7
    2d52:	80 95       	com	r24
    2d54:	98 2f       	mov	r25, r24
    2d56:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    2d5a:	4b 01       	movw	r8, r22
    2d5c:	5c 01       	movw	r10, r24
    2d5e:	60 2f       	mov	r22, r16
    2d60:	77 27       	eor	r23, r23
    2d62:	67 fd       	sbrc	r22, 7
    2d64:	70 95       	com	r23
    2d66:	87 2f       	mov	r24, r23
    2d68:	97 2f       	mov	r25, r23
    2d6a:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    2d6e:	6b 01       	movw	r12, r22
    2d70:	7c 01       	movw	r14, r24
    2d72:	be 01       	movw	r22, r28
    2d74:	88 27       	eor	r24, r24
    2d76:	77 fd       	sbrc	r23, 7
    2d78:	80 95       	com	r24
    2d7a:	98 2f       	mov	r25, r24
    2d7c:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    2d80:	2d ec       	ldi	r18, 0xCD	; 205
    2d82:	3c ec       	ldi	r19, 0xCC	; 204
    2d84:	4c e8       	ldi	r20, 0x8C	; 140
    2d86:	5f e3       	ldi	r21, 0x3F	; 63
    2d88:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    2d8c:	9b 01       	movw	r18, r22
    2d8e:	ac 01       	movw	r20, r24
    2d90:	c7 01       	movw	r24, r14
    2d92:	b6 01       	movw	r22, r12
    2d94:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    2d98:	9b 01       	movw	r18, r22
    2d9a:	ac 01       	movw	r20, r24
    2d9c:	c5 01       	movw	r24, r10
    2d9e:	b4 01       	movw	r22, r8
    2da0:	0e 94 24 38 	call	0x7048	; 0x7048 <__subsf3>
    2da4:	0e 94 f5 38 	call	0x71ea	; 0x71ea <__fixsfsi>
    2da8:	70 93 9d 05 	sts	0x059D, r23
    2dac:	60 93 9c 05 	sts	0x059C, r22
							RX_Snapshot[RXChannel_ELE] = inv * RX_Snapshot[RXChannel_ELE] * 0.5;
    2db0:	e0 2e       	mov	r14, r16
    2db2:	ff 24       	eor	r15, r15
    2db4:	e7 fc       	sbrc	r14, 7
    2db6:	f0 94       	com	r15
    2db8:	ec 9e       	mul	r14, r28
    2dba:	b0 01       	movw	r22, r0
    2dbc:	ed 9e       	mul	r14, r29
    2dbe:	70 0d       	add	r23, r0
    2dc0:	fc 9e       	mul	r15, r28
    2dc2:	70 0d       	add	r23, r0
    2dc4:	11 24       	eor	r1, r1
    2dc6:	88 27       	eor	r24, r24
    2dc8:	77 fd       	sbrc	r23, 7
    2dca:	80 95       	com	r24
    2dcc:	98 2f       	mov	r25, r24
    2dce:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    2dd2:	20 e0       	ldi	r18, 0x00	; 0
    2dd4:	30 e0       	ldi	r19, 0x00	; 0
    2dd6:	40 e0       	ldi	r20, 0x00	; 0
    2dd8:	5f e3       	ldi	r21, 0x3F	; 63
    2dda:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    2dde:	0e 94 f5 38 	call	0x71ea	; 0x71ea <__fixsfsi>
    2de2:	fb 01       	movw	r30, r22
    2de4:	70 93 c3 05 	sts	0x05C3, r23
    2de8:	60 93 c2 05 	sts	0x05C2, r22
							MotorOut[0] += RX_Snapshot[RXChannel_ELE] ; 
    2dec:	20 91 98 05 	lds	r18, 0x0598
    2df0:	30 91 99 05 	lds	r19, 0x0599
							MotorOut[1] += RX_Snapshot[RXChannel_ELE] ; 
    2df4:	80 91 9a 05 	lds	r24, 0x059A
    2df8:	90 91 9b 05 	lds	r25, 0x059B
						
							// {1,-1,0,X} TRI_AIL_FRONT
							RX_Snapshot[RXChannel_AIL] = inv * RX_Snapshot[RXChannel_AIL];
    2dfc:	60 91 c0 05 	lds	r22, 0x05C0
    2e00:	70 91 c1 05 	lds	r23, 0x05C1
    2e04:	e6 9e       	mul	r14, r22
    2e06:	a0 01       	movw	r20, r0
    2e08:	e7 9e       	mul	r14, r23
    2e0a:	50 0d       	add	r21, r0
    2e0c:	f6 9e       	mul	r15, r22
    2e0e:	50 0d       	add	r21, r0
    2e10:	11 24       	eor	r1, r1
    2e12:	50 93 c1 05 	sts	0x05C1, r21
    2e16:	40 93 c0 05 	sts	0x05C0, r20
							inv = -1;
						}							
							// {0.5,0.5,1.1,X} TRI_ELE_FRONT
							MotorOut[2] -= inv * (RX_Snapshot[RXChannel_ELE] * 1.1); 
							RX_Snapshot[RXChannel_ELE] = inv * RX_Snapshot[RXChannel_ELE] * 0.5;
							MotorOut[0] += RX_Snapshot[RXChannel_ELE] ; 
    2e1a:	24 0f       	add	r18, r20
    2e1c:	35 1f       	adc	r19, r21
							MotorOut[1] += RX_Snapshot[RXChannel_ELE] ; 
						
							// {1,-1,0,X} TRI_AIL_FRONT
							RX_Snapshot[RXChannel_AIL] = inv * RX_Snapshot[RXChannel_AIL];
							MotorOut[0] += RX_Snapshot[RXChannel_AIL] ; 
    2e1e:	2e 0f       	add	r18, r30
    2e20:	3f 1f       	adc	r19, r31
    2e22:	30 93 99 05 	sts	0x0599, r19
    2e26:	20 93 98 05 	sts	0x0598, r18
						}							
							// {0.5,0.5,1.1,X} TRI_ELE_FRONT
							MotorOut[2] -= inv * (RX_Snapshot[RXChannel_ELE] * 1.1); 
							RX_Snapshot[RXChannel_ELE] = inv * RX_Snapshot[RXChannel_ELE] * 0.5;
							MotorOut[0] += RX_Snapshot[RXChannel_ELE] ; 
							MotorOut[1] += RX_Snapshot[RXChannel_ELE] ; 
    2e2a:	84 1b       	sub	r24, r20
    2e2c:	95 0b       	sbc	r25, r21
						
							// {1,-1,0,X} TRI_AIL_FRONT
							RX_Snapshot[RXChannel_AIL] = inv * RX_Snapshot[RXChannel_AIL];
							MotorOut[0] += RX_Snapshot[RXChannel_AIL] ; 
							MotorOut[1] -= RX_Snapshot[RXChannel_AIL] ;  
    2e2e:	8e 0f       	add	r24, r30
    2e30:	9f 1f       	adc	r25, r31
    2e32:	90 93 9b 05 	sts	0x059B, r25
    2e36:	80 93 9a 05 	sts	0x059A, r24
    2e3a:	6b c0       	rjmp	.+214    	; 0x2f12 <MainLoop+0x70a>
			{
				// in stabilization mode ... activate Acc-Z & Sonar if enabled.
				
				double Landing;
				
				Landing = IMU_HeightKeeping();
    2e3c:	0e 94 5b 20 	call	0x40b6	; 0x40b6 <IMU_HeightKeeping>
    2e40:	7b 01       	movw	r14, r22
    2e42:	8c 01       	movw	r16, r24
				MotorOut[0] += Landing;
    2e44:	60 91 98 05 	lds	r22, 0x0598
    2e48:	70 91 99 05 	lds	r23, 0x0599
    2e4c:	88 27       	eor	r24, r24
    2e4e:	77 fd       	sbrc	r23, 7
    2e50:	80 95       	com	r24
    2e52:	98 2f       	mov	r25, r24
    2e54:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    2e58:	a8 01       	movw	r20, r16
    2e5a:	97 01       	movw	r18, r14
    2e5c:	0e 94 25 38 	call	0x704a	; 0x704a <__addsf3>
    2e60:	0e 94 f5 38 	call	0x71ea	; 0x71ea <__fixsfsi>
    2e64:	70 93 99 05 	sts	0x0599, r23
    2e68:	60 93 98 05 	sts	0x0598, r22
				MotorOut[1] += Landing;
    2e6c:	60 91 9a 05 	lds	r22, 0x059A
    2e70:	70 91 9b 05 	lds	r23, 0x059B
    2e74:	88 27       	eor	r24, r24
    2e76:	77 fd       	sbrc	r23, 7
    2e78:	80 95       	com	r24
    2e7a:	98 2f       	mov	r25, r24
    2e7c:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    2e80:	a8 01       	movw	r20, r16
    2e82:	97 01       	movw	r18, r14
    2e84:	0e 94 25 38 	call	0x704a	; 0x704a <__addsf3>
    2e88:	0e 94 f5 38 	call	0x71ea	; 0x71ea <__fixsfsi>
    2e8c:	70 93 9b 05 	sts	0x059B, r23
    2e90:	60 93 9a 05 	sts	0x059A, r22
				if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    2e94:	80 91 d8 06 	lds	r24, 0x06D8
    2e98:	c0 90 9c 05 	lds	r12, 0x059C
    2e9c:	d0 90 9d 05 	lds	r13, 0x059D
    2ea0:	81 30       	cpi	r24, 0x01	; 1
    2ea2:	31 f5       	brne	.+76     	; 0x2ef0 <MainLoop+0x6e8>
				{
					
					MotorOut[2] += Landing;
    2ea4:	b6 01       	movw	r22, r12
    2ea6:	88 27       	eor	r24, r24
    2ea8:	77 fd       	sbrc	r23, 7
    2eaa:	80 95       	com	r24
    2eac:	98 2f       	mov	r25, r24
    2eae:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    2eb2:	a8 01       	movw	r20, r16
    2eb4:	97 01       	movw	r18, r14
    2eb6:	0e 94 25 38 	call	0x704a	; 0x704a <__addsf3>
    2eba:	0e 94 f5 38 	call	0x71ea	; 0x71ea <__fixsfsi>
    2ebe:	70 93 9d 05 	sts	0x059D, r23
    2ec2:	60 93 9c 05 	sts	0x059C, r22
					MotorOut[3] += Landing;		
    2ec6:	60 91 9e 05 	lds	r22, 0x059E
    2eca:	70 91 9f 05 	lds	r23, 0x059F
    2ece:	88 27       	eor	r24, r24
    2ed0:	77 fd       	sbrc	r23, 7
    2ed2:	80 95       	com	r24
    2ed4:	98 2f       	mov	r25, r24
    2ed6:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    2eda:	a8 01       	movw	r20, r16
    2edc:	97 01       	movw	r18, r14
    2ede:	0e 94 25 38 	call	0x704a	; 0x704a <__addsf3>
    2ee2:	0e 94 f5 38 	call	0x71ea	; 0x71ea <__fixsfsi>
    2ee6:	70 93 9f 05 	sts	0x059F, r23
    2eea:	60 93 9e 05 	sts	0x059E, r22
    2eee:	11 c0       	rjmp	.+34     	; 0x2f12 <MainLoop+0x70a>
				}
				else
				{
					MotorOut[2] += Landing;
    2ef0:	b6 01       	movw	r22, r12
    2ef2:	88 27       	eor	r24, r24
    2ef4:	77 fd       	sbrc	r23, 7
    2ef6:	80 95       	com	r24
    2ef8:	98 2f       	mov	r25, r24
    2efa:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    2efe:	a8 01       	movw	r20, r16
    2f00:	97 01       	movw	r18, r14
    2f02:	0e 94 25 38 	call	0x704a	; 0x704a <__addsf3>
    2f06:	0e 94 f5 38 	call	0x71ea	; 0x71ea <__fixsfsi>
    2f0a:	70 93 9d 05 	sts	0x059D, r23
    2f0e:	60 93 9c 05 	sts	0x059C, r22
													
										
			}
			
									
			if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    2f12:	00 91 d8 06 	lds	r16, 0x06D8
    2f16:	80 91 cf 06 	lds	r24, 0x06CF
    2f1a:	90 91 d0 06 	lds	r25, 0x06D0
    2f1e:	01 30       	cpi	r16, 0x01	; 1
    2f20:	49 f5       	brne	.+82     	; 0x2f74 <MainLoop+0x76c>
			{
				MotorOut[0] -= gyroYaw;
    2f22:	20 91 98 05 	lds	r18, 0x0598
    2f26:	30 91 99 05 	lds	r19, 0x0599
    2f2a:	28 1b       	sub	r18, r24
    2f2c:	39 0b       	sbc	r19, r25
    2f2e:	30 93 99 05 	sts	0x0599, r19
    2f32:	20 93 98 05 	sts	0x0598, r18
				MotorOut[2] -= gyroYaw;
    2f36:	20 91 9c 05 	lds	r18, 0x059C
    2f3a:	30 91 9d 05 	lds	r19, 0x059D
    2f3e:	28 1b       	sub	r18, r24
    2f40:	39 0b       	sbc	r19, r25
    2f42:	30 93 9d 05 	sts	0x059D, r19
    2f46:	20 93 9c 05 	sts	0x059C, r18
				MotorOut[1] += gyroYaw;
    2f4a:	20 91 9a 05 	lds	r18, 0x059A
    2f4e:	30 91 9b 05 	lds	r19, 0x059B
    2f52:	28 0f       	add	r18, r24
    2f54:	39 1f       	adc	r19, r25
    2f56:	30 93 9b 05 	sts	0x059B, r19
    2f5a:	20 93 9a 05 	sts	0x059A, r18
				MotorOut[3] += gyroYaw;
    2f5e:	20 91 9e 05 	lds	r18, 0x059E
    2f62:	30 91 9f 05 	lds	r19, 0x059F
    2f66:	28 0f       	add	r18, r24
    2f68:	39 1f       	adc	r19, r25
    2f6a:	30 93 9f 05 	sts	0x059F, r19
    2f6e:	20 93 9e 05 	sts	0x059E, r18
    2f72:	3a c0       	rjmp	.+116    	; 0x2fe8 <MainLoop+0x7e0>
			}
			else
			{
			
				MotorOut[3]  = (Config.ReverseYAW * gyroYaw) + SERVO_IN_MIDDLE; 
    2f74:	20 91 6c 07 	lds	r18, 0x076C
    2f78:	c2 2f       	mov	r28, r18
    2f7a:	dd 27       	eor	r29, r29
    2f7c:	c7 fd       	sbrc	r28, 7
    2f7e:	d0 95       	com	r29
    2f80:	c8 9f       	mul	r28, r24
    2f82:	b0 01       	movw	r22, r0
    2f84:	c9 9f       	mul	r28, r25
    2f86:	70 0d       	add	r23, r0
    2f88:	d8 9f       	mul	r29, r24
    2f8a:	70 0d       	add	r23, r0
    2f8c:	11 24       	eor	r1, r1
    2f8e:	6a 5d       	subi	r22, 0xDA	; 218
    2f90:	7d 4f       	sbci	r23, 0xFD	; 253
				MotorOut[3]  = MotorOut[3] - (Config.ReverseYAW * RX_Snapshot[RXChannel_RUD] * 0.2);
    2f92:	88 27       	eor	r24, r24
    2f94:	77 fd       	sbrc	r23, 7
    2f96:	80 95       	com	r24
    2f98:	98 2f       	mov	r25, r24
    2f9a:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    2f9e:	6b 01       	movw	r12, r22
    2fa0:	7c 01       	movw	r14, r24
    2fa2:	80 91 c4 05 	lds	r24, 0x05C4
    2fa6:	90 91 c5 05 	lds	r25, 0x05C5
    2faa:	c8 9f       	mul	r28, r24
    2fac:	b0 01       	movw	r22, r0
    2fae:	c9 9f       	mul	r28, r25
    2fb0:	70 0d       	add	r23, r0
    2fb2:	d8 9f       	mul	r29, r24
    2fb4:	70 0d       	add	r23, r0
    2fb6:	11 24       	eor	r1, r1
    2fb8:	88 27       	eor	r24, r24
    2fba:	77 fd       	sbrc	r23, 7
    2fbc:	80 95       	com	r24
    2fbe:	98 2f       	mov	r25, r24
    2fc0:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    2fc4:	2d ec       	ldi	r18, 0xCD	; 205
    2fc6:	3c ec       	ldi	r19, 0xCC	; 204
    2fc8:	4c e4       	ldi	r20, 0x4C	; 76
    2fca:	5e e3       	ldi	r21, 0x3E	; 62
    2fcc:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    2fd0:	9b 01       	movw	r18, r22
    2fd2:	ac 01       	movw	r20, r24
    2fd4:	c7 01       	movw	r24, r14
    2fd6:	b6 01       	movw	r22, r12
    2fd8:	0e 94 24 38 	call	0x7048	; 0x7048 <__subsf3>
    2fdc:	0e 94 f5 38 	call	0x71ea	; 0x71ea <__fixsfsi>
    2fe0:	70 93 9f 05 	sts	0x059F, r23
    2fe4:	60 93 9e 05 	sts	0x059E, r22
			}						
			
			// Save motors from turning-off
            if (MotorOut[0]<MOTORS_IDLE_VALUE) MotorOut[0]=MOTORS_IDLE_VALUE;
    2fe8:	80 91 98 05 	lds	r24, 0x0598
    2fec:	90 91 99 05 	lds	r25, 0x0599
    2ff0:	84 36       	cpi	r24, 0x64	; 100
    2ff2:	91 05       	cpc	r25, r1
    2ff4:	34 f4       	brge	.+12     	; 0x3002 <MainLoop+0x7fa>
    2ff6:	84 e6       	ldi	r24, 0x64	; 100
    2ff8:	90 e0       	ldi	r25, 0x00	; 0
    2ffa:	90 93 99 05 	sts	0x0599, r25
    2ffe:	80 93 98 05 	sts	0x0598, r24
            if (MotorOut[1]<MOTORS_IDLE_VALUE) MotorOut[1]=MOTORS_IDLE_VALUE;
    3002:	80 91 9a 05 	lds	r24, 0x059A
    3006:	90 91 9b 05 	lds	r25, 0x059B
    300a:	84 36       	cpi	r24, 0x64	; 100
    300c:	91 05       	cpc	r25, r1
    300e:	34 f4       	brge	.+12     	; 0x301c <MainLoop+0x814>
    3010:	84 e6       	ldi	r24, 0x64	; 100
    3012:	90 e0       	ldi	r25, 0x00	; 0
    3014:	90 93 9b 05 	sts	0x059B, r25
    3018:	80 93 9a 05 	sts	0x059A, r24
            if (MotorOut[2]<MOTORS_IDLE_VALUE) MotorOut[2]=MOTORS_IDLE_VALUE;
    301c:	80 91 9c 05 	lds	r24, 0x059C
    3020:	90 91 9d 05 	lds	r25, 0x059D
    3024:	84 36       	cpi	r24, 0x64	; 100
    3026:	91 05       	cpc	r25, r1
    3028:	34 f4       	brge	.+12     	; 0x3036 <MainLoop+0x82e>
    302a:	84 e6       	ldi	r24, 0x64	; 100
    302c:	90 e0       	ldi	r25, 0x00	; 0
    302e:	90 93 9d 05 	sts	0x059D, r25
    3032:	80 93 9c 05 	sts	0x059C, r24
            
									
			if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    3036:	01 30       	cpi	r16, 0x01	; 1
    3038:	69 f4       	brne	.+26     	; 0x3054 <MainLoop+0x84c>
			{
				if (MotorOut[3]<MOTORS_IDLE_VALUE) MotorOut[3]=MOTORS_IDLE_VALUE;
    303a:	80 91 9e 05 	lds	r24, 0x059E
    303e:	90 91 9f 05 	lds	r25, 0x059F
    3042:	84 36       	cpi	r24, 0x64	; 100
    3044:	91 05       	cpc	r25, r1
    3046:	34 f4       	brge	.+12     	; 0x3054 <MainLoop+0x84c>
    3048:	84 e6       	ldi	r24, 0x64	; 100
    304a:	90 e0       	ldi	r25, 0x00	; 0
    304c:	90 93 9f 05 	sts	0x059F, r25
    3050:	80 93 9e 05 	sts	0x059E, r24
			}
			
		
			// Sending Sensors & Motor Data 
			if (Config.RX_mode==RX_mode_UARTMode)
    3054:	80 91 d3 06 	lds	r24, 0x06D3
    3058:	8f 3f       	cpi	r24, 0xFF	; 255
    305a:	a1 f4       	brne	.+40     	; 0x3084 <MainLoop+0x87c>
			{
				//LED_Orange=~LED_Orange;
				Send_Data("S",1);
    305c:	84 e0       	ldi	r24, 0x04	; 4
    305e:	91 e0       	ldi	r25, 0x01	; 1
    3060:	61 e0       	ldi	r22, 0x01	; 1
    3062:	0e 94 3f 10 	call	0x207e	; 0x207e <Send_Data>
				Send_Data(Sensors_Latest,12);
    3066:	8d e3       	ldi	r24, 0x3D	; 61
    3068:	96 e0       	ldi	r25, 0x06	; 6
    306a:	6c e0       	ldi	r22, 0x0C	; 12
    306c:	0e 94 3f 10 	call	0x207e	; 0x207e <Send_Data>
				Send_Data(MotorOut,8);
    3070:	88 e9       	ldi	r24, 0x98	; 152
    3072:	95 e0       	ldi	r25, 0x05	; 5
    3074:	68 e0       	ldi	r22, 0x08	; 8
    3076:	0e 94 3f 10 	call	0x207e	; 0x207e <Send_Data>
				Send_Data("E",1);
    307a:	86 e0       	ldi	r24, 0x06	; 6
    307c:	91 e0       	ldi	r25, 0x01	; 1
    307e:	61 e0       	ldi	r22, 0x01	; 1
    3080:	0e 94 3f 10 	call	0x207e	; 0x207e <Send_Data>
		} // End of ARMED & Throttle > Minimum
				
			
	}  // End of Throttle stick is NOT Down [Armed Could be True or not]
	
	if ((!IS_TX2_GOOD)) // if no signal and there is no AutoLandingMode.
    3084:	80 91 b8 07 	lds	r24, 0x07B8
    3088:	80 7f       	andi	r24, 0xF0	; 240
    308a:	79 f0       	breq	.+30     	; 0x30aa <MainLoop+0x8a2>
	{
		ZEROMotors();
    308c:	0e 94 e6 13 	call	0x27cc	; 0x27cc <ZEROMotors>
		if (IsArmed==true)
    3090:	80 91 85 07 	lds	r24, 0x0785
    3094:	81 30       	cpi	r24, 0x01	; 1
    3096:	49 f4       	brne	.+18     	; 0x30aa <MainLoop+0x8a2>
		{
			Motor_GenerateOutputSignal();	
    3098:	0e 94 c9 24 	call	0x4992	; 0x4992 <Motor_GenerateOutputSignal>
			Disarm();	
    309c:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <Disarm>
			SystemErrorType = SET_SYS_ERR_SIGNAL; // only error if signal lost while arming
    30a0:	80 91 c5 06 	lds	r24, 0x06C5
    30a4:	81 60       	ori	r24, 0x01	; 1
    30a6:	80 93 c5 06 	sts	0x06C5, r24
		
		
		//return ; // Do nothing all below depends on TX.
	}
	
	Motor_GenerateOutputSignal();	
    30aa:	0e 94 c9 24 	call	0x4992	; 0x4992 <Motor_GenerateOutputSignal>
	
	if (bResetTCNR1_X==true)
    30ae:	80 91 57 06 	lds	r24, 0x0657
    30b2:	81 30       	cpi	r24, 0x01	; 1
    30b4:	21 f4       	brne	.+8      	; 0x30be <MainLoop+0x8b6>
	{
		TCNT1_X_snapshot1= 0; // reset timeout
    30b6:	10 92 e9 05 	sts	0x05E9, r1
    30ba:	10 92 e8 05 	sts	0x05E8, r1
	}
	
	
}	
    30be:	df 91       	pop	r29
    30c0:	cf 91       	pop	r28
    30c2:	1f 91       	pop	r17
    30c4:	0f 91       	pop	r16
    30c6:	ff 90       	pop	r15
    30c8:	ef 90       	pop	r14
    30ca:	df 90       	pop	r13
    30cc:	cf 90       	pop	r12
    30ce:	bf 90       	pop	r11
    30d0:	af 90       	pop	r10
    30d2:	9f 90       	pop	r9
    30d4:	8f 90       	pop	r8
    30d6:	08 95       	ret

000030d8 <main>:

int main(void)
{
	// Stick Commands are only available for Secondary Receiver and when Stick is calibrated.
	
	UIEnableStickCommands=false;  
    30d8:	10 92 e7 05 	sts	0x05E7, r1
	Setup();
    30dc:	0e 94 6c 11 	call	0x22d8	; 0x22d8 <Setup>
	SystemActions = SYS_ACT_NON;
    30e0:	10 92 4f 05 	sts	0x054F, r1
    SystemErrorType = SYS_ERR_NON;
    30e4:	10 92 c5 06 	sts	0x06C5, r1
	nFlyingModes = FLYINGMODE_ACRO;
    30e8:	81 e0       	ldi	r24, 0x01	; 1
    30ea:	80 93 1c 06 	sts	0x061C, r24
	FlyingModesToggle = HIGH;
    30ee:	80 93 21 05 	sts	0x0521, r24
	
	DataPtr = (uint8_t *) (&Sensors_Latest);
    30f2:	8d e3       	ldi	r24, 0x3D	; 61
    30f4:	96 e0       	ldi	r25, 0x06	; 6
    30f6:	90 93 95 07 	sts	0x0795, r25
    30fa:	80 93 94 07 	sts	0x0794, r24
	DataCounter=0;
    30fe:	10 92 86 07 	sts	0x0786, r1
	
	// Never go to MainLoop "fly loop" unless Sensors & RX is calibrated.
	// This loop to protect against any bug that might make the quad start or KB stick click
	// as in this case crash is a must.
	LoopCalibration ();
    3102:	0e 94 d3 11 	call	0x23a6	; 0x23a6 <LoopCalibration>

	
	
	// This loop better be under the sensor/stick loop to avoid entering this mode is sticks are not calibrated.
	// This is no longer a condition after adding menuEnabled[PAGE_ESC_CALIBRATION]=0
	if (Config.IsESCCalibration==ESCCalibration_ON)		
    3106:	80 91 d7 06 	lds	r24, 0x06D7
    310a:	81 30       	cpi	r24, 0x01	; 1
    310c:	11 f4       	brne	.+4      	; 0x3112 <main+0x3a>
	{
		LoopESCCalibration ();
    310e:	0e 94 cd 11 	call	0x239a	; 0x239a <LoopESCCalibration>
	Mixer[Mixer_Quad_PLUS].Roll[4]  = {0,-1.0,0,1.0};
//#define Mixer_Quad_X		1
//#define Mixer_TRI			2
*/

	Menu_EnableAllItems();
    3112:	0e 94 19 38 	call	0x7032	; 0x7032 <Menu_EnableAllItems>
	
				
	while(1)
    {
		//LoopESCCalibration();
    	MainLoop();
    3116:	0e 94 04 14 	call	0x2808	; 0x2808 <MainLoop>
    311a:	fd cf       	rjmp	.-6      	; 0x3116 <main+0x3e>

0000311c <PID_Calculate_ACC>:




float PID_Calculate_ACC (pid_param_t PID_Params, pid_terms_t *PID_Term, double  Value)
{
    311c:	6f 92       	push	r6
    311e:	7f 92       	push	r7
    3120:	8f 92       	push	r8
    3122:	9f 92       	push	r9
    3124:	af 92       	push	r10
    3126:	bf 92       	push	r11
    3128:	cf 92       	push	r12
    312a:	df 92       	push	r13
    312c:	ef 92       	push	r14
    312e:	ff 92       	push	r15
    3130:	0f 93       	push	r16
    3132:	1f 93       	push	r17
    3134:	df 93       	push	r29
    3136:	cf 93       	push	r28
    3138:	cd b7       	in	r28, 0x3d	; 61
    313a:	de b7       	in	r29, 0x3e	; 62
    313c:	2e 97       	sbiw	r28, 0x0e	; 14
    313e:	0f b6       	in	r0, 0x3f	; 63
    3140:	f8 94       	cli
    3142:	de bf       	out	0x3e, r29	; 62
    3144:	0f be       	out	0x3f, r0	; 63
    3146:	cd bf       	out	0x3d, r28	; 61
    3148:	c9 82       	std	Y+1, r12	; 0x01
    314a:	da 82       	std	Y+2, r13	; 0x02
    314c:	eb 82       	std	Y+3, r14	; 0x03
    314e:	fc 82       	std	Y+4, r15	; 0x04
    3150:	0d 83       	std	Y+5, r16	; 0x05
    3152:	1e 83       	std	Y+6, r17	; 0x06
    3154:	2f 83       	std	Y+7, r18	; 0x07
    3156:	38 87       	std	Y+8, r19	; 0x08
    3158:	49 87       	std	Y+9, r20	; 0x09
    315a:	5a 87       	std	Y+10, r21	; 0x0a
    315c:	6b 87       	std	Y+11, r22	; 0x0b
    315e:	7c 87       	std	Y+12, r23	; 0x0c
    3160:	8d 87       	std	Y+13, r24	; 0x0d
    3162:	9e 87       	std	Y+14, r25	; 0x0e
    3164:	ef 8c       	ldd	r14, Y+31	; 0x1f
    3166:	f8 a0       	ldd	r15, Y+32	; 0x20
    3168:	09 a1       	ldd	r16, Y+33	; 0x21
    316a:	1a a1       	ldd	r17, Y+34	; 0x22
    316c:	6d 80       	ldd	r6, Y+5	; 0x05
    316e:	7e 80       	ldd	r7, Y+6	; 0x06
	#define ACC_I_MIN	4
		
	float Output;
		
		double AbsValue = abs (Value);
    3170:	c8 01       	movw	r24, r16
    3172:	b7 01       	movw	r22, r14
    3174:	0e 94 bd 3a 	call	0x757a	; 0x757a <abs>
    3178:	9c 01       	movw	r18, r24
    317a:	b9 01       	movw	r22, r18
    317c:	88 27       	eor	r24, r24
    317e:	77 fd       	sbrc	r23, 7
    3180:	80 95       	com	r24
    3182:	98 2f       	mov	r25, r24
    3184:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
		// Calculate Terms 
		if (AbsValue > 1)
    3188:	20 e0       	ldi	r18, 0x00	; 0
    318a:	30 e0       	ldi	r19, 0x00	; 0
    318c:	40 e8       	ldi	r20, 0x80	; 128
    318e:	5f e3       	ldi	r21, 0x3F	; 63
    3190:	0e 94 d8 39 	call	0x73b0	; 0x73b0 <__gesf2>
    3194:	18 16       	cp	r1, r24
    3196:	cc f4       	brge	.+50     	; 0x31ca <PID_Calculate_ACC+0xae>
	    PID_Term->P  = ((float)(Value * PID_Params._P) / 10.0f);						
    3198:	69 81       	ldd	r22, Y+1	; 0x01
    319a:	7a 81       	ldd	r23, Y+2	; 0x02
    319c:	88 27       	eor	r24, r24
    319e:	77 fd       	sbrc	r23, 7
    31a0:	80 95       	com	r24
    31a2:	98 2f       	mov	r25, r24
    31a4:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    31a8:	9b 01       	movw	r18, r22
    31aa:	ac 01       	movw	r20, r24
    31ac:	c8 01       	movw	r24, r16
    31ae:	b7 01       	movw	r22, r14
    31b0:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    31b4:	20 e0       	ldi	r18, 0x00	; 0
    31b6:	30 e0       	ldi	r19, 0x00	; 0
    31b8:	40 e2       	ldi	r20, 0x20	; 32
    31ba:	51 e4       	ldi	r21, 0x41	; 65
    31bc:	0e 94 8d 38 	call	0x711a	; 0x711a <__divsf3>
    31c0:	f5 01       	movw	r30, r10
    31c2:	60 83       	st	Z, r22
    31c4:	71 83       	std	Z+1, r23	; 0x01
    31c6:	82 83       	std	Z+2, r24	; 0x02
    31c8:	93 83       	std	Z+3, r25	; 0x03
		//if ((abs(Value - PID_Term->Error) > AbsValue ) || (Value ==0))
		//{  // Zero I if different signs.
			//PID_Term->I =0; ..... removed because it nakes whobbles.S
		//}
		//else 
		int16_t DeltaError = (Value - PID_Term->Error);
    31ca:	c8 01       	movw	r24, r16
    31cc:	b7 01       	movw	r22, r14
    31ce:	f5 01       	movw	r30, r10
    31d0:	24 85       	ldd	r18, Z+12	; 0x0c
    31d2:	35 85       	ldd	r19, Z+13	; 0x0d
    31d4:	46 85       	ldd	r20, Z+14	; 0x0e
    31d6:	57 85       	ldd	r21, Z+15	; 0x0f
    31d8:	0e 94 24 38 	call	0x7048	; 0x7048 <__subsf3>
    31dc:	0e 94 f5 38 	call	0x71ea	; 0x71ea <__fixsfsi>
    31e0:	6b 01       	movw	r12, r22
		if (Value > ACC_I_MIN)
    31e2:	c8 01       	movw	r24, r16
    31e4:	b7 01       	movw	r22, r14
    31e6:	20 e0       	ldi	r18, 0x00	; 0
    31e8:	30 e0       	ldi	r19, 0x00	; 0
    31ea:	40 e8       	ldi	r20, 0x80	; 128
    31ec:	50 e4       	ldi	r21, 0x40	; 64
    31ee:	0e 94 d8 39 	call	0x73b0	; 0x73b0 <__gesf2>
    31f2:	18 16       	cp	r1, r24
    31f4:	bc f4       	brge	.+46     	; 0x3224 <PID_Calculate_ACC+0x108>
		{
			PID_Term->I += (float)(PID_Params._I / 100.0f);						    		
    31f6:	b3 01       	movw	r22, r6
    31f8:	88 27       	eor	r24, r24
    31fa:	77 fd       	sbrc	r23, 7
    31fc:	80 95       	com	r24
    31fe:	98 2f       	mov	r25, r24
    3200:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    3204:	20 e0       	ldi	r18, 0x00	; 0
    3206:	30 e0       	ldi	r19, 0x00	; 0
    3208:	48 ec       	ldi	r20, 0xC8	; 200
    320a:	52 e4       	ldi	r21, 0x42	; 66
    320c:	0e 94 8d 38 	call	0x711a	; 0x711a <__divsf3>
    3210:	9b 01       	movw	r18, r22
    3212:	ac 01       	movw	r20, r24
    3214:	f5 01       	movw	r30, r10
    3216:	64 81       	ldd	r22, Z+4	; 0x04
    3218:	75 81       	ldd	r23, Z+5	; 0x05
    321a:	86 81       	ldd	r24, Z+6	; 0x06
    321c:	97 81       	ldd	r25, Z+7	; 0x07
    321e:	0e 94 25 38 	call	0x704a	; 0x704a <__addsf3>
    3222:	32 c0       	rjmp	.+100    	; 0x3288 <PID_Calculate_ACC+0x16c>
		}
		else if (Value < -ACC_I_MIN)
    3224:	c8 01       	movw	r24, r16
    3226:	b7 01       	movw	r22, r14
    3228:	20 e0       	ldi	r18, 0x00	; 0
    322a:	30 e0       	ldi	r19, 0x00	; 0
    322c:	40 e8       	ldi	r20, 0x80	; 128
    322e:	50 ec       	ldi	r21, 0xC0	; 192
    3230:	0e 94 89 38 	call	0x7112	; 0x7112 <__cmpsf2>
    3234:	87 ff       	sbrs	r24, 7
    3236:	15 c0       	rjmp	.+42     	; 0x3262 <PID_Calculate_ACC+0x146>
		{	
			PID_Term->I -= (float)(PID_Params._I / 100.0f );						    		
    3238:	b3 01       	movw	r22, r6
    323a:	88 27       	eor	r24, r24
    323c:	77 fd       	sbrc	r23, 7
    323e:	80 95       	com	r24
    3240:	98 2f       	mov	r25, r24
    3242:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    3246:	20 e0       	ldi	r18, 0x00	; 0
    3248:	30 e0       	ldi	r19, 0x00	; 0
    324a:	48 ec       	ldi	r20, 0xC8	; 200
    324c:	52 e4       	ldi	r21, 0x42	; 66
    324e:	0e 94 8d 38 	call	0x711a	; 0x711a <__divsf3>
    3252:	9b 01       	movw	r18, r22
    3254:	ac 01       	movw	r20, r24
    3256:	f5 01       	movw	r30, r10
    3258:	64 81       	ldd	r22, Z+4	; 0x04
    325a:	75 81       	ldd	r23, Z+5	; 0x05
    325c:	86 81       	ldd	r24, Z+6	; 0x06
    325e:	97 81       	ldd	r25, Z+7	; 0x07
    3260:	11 c0       	rjmp	.+34     	; 0x3284 <PID_Calculate_ACC+0x168>
		}
		else
		{
			PID_Term->I -= (float)(PID_Term->I * PID_I_LEAK_RATE);
    3262:	f5 01       	movw	r30, r10
    3264:	64 80       	ldd	r6, Z+4	; 0x04
    3266:	75 80       	ldd	r7, Z+5	; 0x05
    3268:	86 80       	ldd	r8, Z+6	; 0x06
    326a:	97 80       	ldd	r9, Z+7	; 0x07
    326c:	c4 01       	movw	r24, r8
    326e:	b3 01       	movw	r22, r6
    3270:	2a e0       	ldi	r18, 0x0A	; 10
    3272:	37 ed       	ldi	r19, 0xD7	; 215
    3274:	43 e2       	ldi	r20, 0x23	; 35
    3276:	5c e3       	ldi	r21, 0x3C	; 60
    3278:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    327c:	9b 01       	movw	r18, r22
    327e:	ac 01       	movw	r20, r24
    3280:	c4 01       	movw	r24, r8
    3282:	b3 01       	movw	r22, r6
    3284:	0e 94 24 38 	call	0x7048	; 0x7048 <__subsf3>
    3288:	f5 01       	movw	r30, r10
    328a:	64 83       	std	Z+4, r22	; 0x04
    328c:	75 83       	std	Z+5, r23	; 0x05
    328e:	86 83       	std	Z+6, r24	; 0x06
    3290:	97 83       	std	Z+7, r25	; 0x07
		}			
				
		
		PID_Term->D= (float)((float)(DeltaError) * (float)PID_Params._D) / 20.0f ;
    3292:	b6 01       	movw	r22, r12
    3294:	88 27       	eor	r24, r24
    3296:	77 fd       	sbrc	r23, 7
    3298:	80 95       	com	r24
    329a:	98 2f       	mov	r25, r24
    329c:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    32a0:	3b 01       	movw	r6, r22
    32a2:	4c 01       	movw	r8, r24
    32a4:	69 85       	ldd	r22, Y+9	; 0x09
    32a6:	7a 85       	ldd	r23, Y+10	; 0x0a
    32a8:	88 27       	eor	r24, r24
    32aa:	77 fd       	sbrc	r23, 7
    32ac:	80 95       	com	r24
    32ae:	98 2f       	mov	r25, r24
    32b0:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    32b4:	9b 01       	movw	r18, r22
    32b6:	ac 01       	movw	r20, r24
    32b8:	c4 01       	movw	r24, r8
    32ba:	b3 01       	movw	r22, r6
    32bc:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    32c0:	20 e0       	ldi	r18, 0x00	; 0
    32c2:	30 e0       	ldi	r19, 0x00	; 0
    32c4:	40 ea       	ldi	r20, 0xA0	; 160
    32c6:	51 e4       	ldi	r21, 0x41	; 65
    32c8:	0e 94 8d 38 	call	0x711a	; 0x711a <__divsf3>
    32cc:	f5 01       	movw	r30, r10
    32ce:	60 87       	std	Z+8, r22	; 0x08
    32d0:	71 87       	std	Z+9, r23	; 0x09
    32d2:	82 87       	std	Z+10, r24	; 0x0a
    32d4:	93 87       	std	Z+11, r25	; 0x0b
		PID_Term->Error = Value;	
    32d6:	e4 86       	std	Z+12, r14	; 0x0c
    32d8:	f5 86       	std	Z+13, r15	; 0x0d
    32da:	06 87       	std	Z+14, r16	; 0x0e
    32dc:	17 87       	std	Z+15, r17	; 0x0f
		
				
		// Limit boundaries to custom values defined by user.
		PID_Term->I= Limiterf(PID_Term->I, PID_Params._ILimit);
    32de:	e4 80       	ldd	r14, Z+4	; 0x04
    32e0:	f5 80       	ldd	r15, Z+5	; 0x05
    32e2:	06 81       	ldd	r16, Z+6	; 0x06
    32e4:	17 81       	ldd	r17, Z+7	; 0x07
    32e6:	6f 81       	ldd	r22, Y+7	; 0x07
    32e8:	78 85       	ldd	r23, Y+8	; 0x08
    32ea:	88 27       	eor	r24, r24
    32ec:	77 fd       	sbrc	r23, 7
    32ee:	80 95       	com	r24
    32f0:	98 2f       	mov	r25, r24
    32f2:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    32f6:	9b 01       	movw	r18, r22
    32f8:	ac 01       	movw	r20, r24
    32fa:	c8 01       	movw	r24, r16
    32fc:	b7 01       	movw	r22, r14
    32fe:	0e 94 51 22 	call	0x44a2	; 0x44a2 <Limiterf>
    3302:	f5 01       	movw	r30, r10
    3304:	64 83       	std	Z+4, r22	; 0x04
    3306:	75 83       	std	Z+5, r23	; 0x05
    3308:	86 83       	std	Z+6, r24	; 0x06
    330a:	97 83       	std	Z+7, r25	; 0x07
		PID_Term->P= Limiterf(PID_Term->P, PID_Params._PLimit);
    330c:	e0 80       	ld	r14, Z
    330e:	f1 80       	ldd	r15, Z+1	; 0x01
    3310:	02 81       	ldd	r16, Z+2	; 0x02
    3312:	13 81       	ldd	r17, Z+3	; 0x03
    3314:	6b 81       	ldd	r22, Y+3	; 0x03
    3316:	7c 81       	ldd	r23, Y+4	; 0x04
    3318:	88 27       	eor	r24, r24
    331a:	77 fd       	sbrc	r23, 7
    331c:	80 95       	com	r24
    331e:	98 2f       	mov	r25, r24
    3320:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    3324:	9b 01       	movw	r18, r22
    3326:	ac 01       	movw	r20, r24
    3328:	c8 01       	movw	r24, r16
    332a:	b7 01       	movw	r22, r14
    332c:	0e 94 51 22 	call	0x44a2	; 0x44a2 <Limiterf>
    3330:	f5 01       	movw	r30, r10
    3332:	60 83       	st	Z, r22
    3334:	71 83       	std	Z+1, r23	; 0x01
    3336:	82 83       	std	Z+2, r24	; 0x02
    3338:	93 83       	std	Z+3, r25	; 0x03
	    PID_Term->D= Limiterf(PID_Term->D, PID_Params._DLimit);
    333a:	e0 84       	ldd	r14, Z+8	; 0x08
    333c:	f1 84       	ldd	r15, Z+9	; 0x09
    333e:	02 85       	ldd	r16, Z+10	; 0x0a
    3340:	13 85       	ldd	r17, Z+11	; 0x0b
    3342:	6b 85       	ldd	r22, Y+11	; 0x0b
    3344:	7c 85       	ldd	r23, Y+12	; 0x0c
    3346:	88 27       	eor	r24, r24
    3348:	77 fd       	sbrc	r23, 7
    334a:	80 95       	com	r24
    334c:	98 2f       	mov	r25, r24
    334e:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    3352:	9b 01       	movw	r18, r22
    3354:	ac 01       	movw	r20, r24
    3356:	c8 01       	movw	r24, r16
    3358:	b7 01       	movw	r22, r14
    335a:	0e 94 51 22 	call	0x44a2	; 0x44a2 <Limiterf>
    335e:	7b 01       	movw	r14, r22
    3360:	8c 01       	movw	r16, r24
    3362:	f5 01       	movw	r30, r10
    3364:	60 87       	std	Z+8, r22	; 0x08
    3366:	71 87       	std	Z+9, r23	; 0x09
    3368:	82 87       	std	Z+10, r24	; 0x0a
    336a:	93 87       	std	Z+11, r25	; 0x0b
	
		Output = (PID_Term->P + PID_Term->I + PID_Term->D);	// P + I + D
    336c:	60 81       	ld	r22, Z
    336e:	71 81       	ldd	r23, Z+1	; 0x01
    3370:	82 81       	ldd	r24, Z+2	; 0x02
    3372:	93 81       	ldd	r25, Z+3	; 0x03
    3374:	24 81       	ldd	r18, Z+4	; 0x04
    3376:	35 81       	ldd	r19, Z+5	; 0x05
    3378:	46 81       	ldd	r20, Z+6	; 0x06
    337a:	57 81       	ldd	r21, Z+7	; 0x07
    337c:	0e 94 25 38 	call	0x704a	; 0x704a <__addsf3>
    3380:	a8 01       	movw	r20, r16
    3382:	97 01       	movw	r18, r14
    3384:	0e 94 25 38 	call	0x704a	; 0x704a <__addsf3>
		return  Output; 
}
    3388:	2e 96       	adiw	r28, 0x0e	; 14
    338a:	0f b6       	in	r0, 0x3f	; 63
    338c:	f8 94       	cli
    338e:	de bf       	out	0x3e, r29	; 62
    3390:	0f be       	out	0x3f, r0	; 63
    3392:	cd bf       	out	0x3d, r28	; 61
    3394:	cf 91       	pop	r28
    3396:	df 91       	pop	r29
    3398:	1f 91       	pop	r17
    339a:	0f 91       	pop	r16
    339c:	ff 90       	pop	r15
    339e:	ef 90       	pop	r14
    33a0:	df 90       	pop	r13
    33a2:	cf 90       	pop	r12
    33a4:	bf 90       	pop	r11
    33a6:	af 90       	pop	r10
    33a8:	9f 90       	pop	r9
    33aa:	8f 90       	pop	r8
    33ac:	7f 90       	pop	r7
    33ae:	6f 90       	pop	r6
    33b0:	08 95       	ret

000033b2 <PID_Calculate>:

float PID_Calculate (pid_param_t PID_Params, pid_terms_t *PID_Term, double  Value)
{
    33b2:	af 92       	push	r10
    33b4:	bf 92       	push	r11
    33b6:	cf 92       	push	r12
    33b8:	df 92       	push	r13
    33ba:	ef 92       	push	r14
    33bc:	ff 92       	push	r15
    33be:	0f 93       	push	r16
    33c0:	1f 93       	push	r17
    33c2:	df 93       	push	r29
    33c4:	cf 93       	push	r28
    33c6:	cd b7       	in	r28, 0x3d	; 61
    33c8:	de b7       	in	r29, 0x3e	; 62
    33ca:	2e 97       	sbiw	r28, 0x0e	; 14
    33cc:	0f b6       	in	r0, 0x3f	; 63
    33ce:	f8 94       	cli
    33d0:	de bf       	out	0x3e, r29	; 62
    33d2:	0f be       	out	0x3f, r0	; 63
    33d4:	cd bf       	out	0x3d, r28	; 61
    33d6:	c9 82       	std	Y+1, r12	; 0x01
    33d8:	da 82       	std	Y+2, r13	; 0x02
    33da:	eb 82       	std	Y+3, r14	; 0x03
    33dc:	fc 82       	std	Y+4, r15	; 0x04
    33de:	0d 83       	std	Y+5, r16	; 0x05
    33e0:	1e 83       	std	Y+6, r17	; 0x06
    33e2:	2f 83       	std	Y+7, r18	; 0x07
    33e4:	38 87       	std	Y+8, r19	; 0x08
    33e6:	49 87       	std	Y+9, r20	; 0x09
    33e8:	5a 87       	std	Y+10, r21	; 0x0a
    33ea:	6b 87       	std	Y+11, r22	; 0x0b
    33ec:	7c 87       	std	Y+12, r23	; 0x0c
    33ee:	8d 87       	std	Y+13, r24	; 0x0d
    33f0:	9e 87       	std	Y+14, r25	; 0x0e
    33f2:	eb 8c       	ldd	r14, Y+27	; 0x1b
    33f4:	fc 8c       	ldd	r15, Y+28	; 0x1c
    33f6:	0d 8d       	ldd	r16, Y+29	; 0x1d
    33f8:	1e 8d       	ldd	r17, Y+30	; 0x1e
		float Output;
		
		// Calculate Terms 
	    PID_Term->P  = ((float)(Value * PID_Params._P) / 20.0f);						
    33fa:	69 81       	ldd	r22, Y+1	; 0x01
    33fc:	7a 81       	ldd	r23, Y+2	; 0x02
    33fe:	88 27       	eor	r24, r24
    3400:	77 fd       	sbrc	r23, 7
    3402:	80 95       	com	r24
    3404:	98 2f       	mov	r25, r24
    3406:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    340a:	9b 01       	movw	r18, r22
    340c:	ac 01       	movw	r20, r24
    340e:	c8 01       	movw	r24, r16
    3410:	b7 01       	movw	r22, r14
    3412:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    3416:	20 e0       	ldi	r18, 0x00	; 0
    3418:	30 e0       	ldi	r19, 0x00	; 0
    341a:	40 ea       	ldi	r20, 0xA0	; 160
    341c:	51 e4       	ldi	r21, 0x41	; 65
    341e:	0e 94 8d 38 	call	0x711a	; 0x711a <__divsf3>
    3422:	f5 01       	movw	r30, r10
    3424:	60 83       	st	Z, r22
    3426:	71 83       	std	Z+1, r23	; 0x01
    3428:	82 83       	std	Z+2, r24	; 0x02
    342a:	93 83       	std	Z+3, r25	; 0x03
		
		
		
		int16_t DeltaError = (Value - PID_Term->Error);
    342c:	c8 01       	movw	r24, r16
    342e:	b7 01       	movw	r22, r14
    3430:	24 85       	ldd	r18, Z+12	; 0x0c
    3432:	35 85       	ldd	r19, Z+13	; 0x0d
    3434:	46 85       	ldd	r20, Z+14	; 0x0e
    3436:	57 85       	ldd	r21, Z+15	; 0x0f
    3438:	0e 94 24 38 	call	0x7048	; 0x7048 <__subsf3>
    343c:	0e 94 f5 38 	call	0x71ea	; 0x71ea <__fixsfsi>
    3440:	6b 01       	movw	r12, r22
		/*
		// I Logic here:
		// DEAD band = 2
		// Increment or Decrement by Value * PID_Params._I 
		*/
		if ((Value > 1) || (Value < -1))
    3442:	c8 01       	movw	r24, r16
    3444:	b7 01       	movw	r22, r14
    3446:	20 e0       	ldi	r18, 0x00	; 0
    3448:	30 e0       	ldi	r19, 0x00	; 0
    344a:	40 e8       	ldi	r20, 0x80	; 128
    344c:	5f e3       	ldi	r21, 0x3F	; 63
    344e:	0e 94 d8 39 	call	0x73b0	; 0x73b0 <__gesf2>
    3452:	18 16       	cp	r1, r24
    3454:	54 f0       	brlt	.+20     	; 0x346a <PID_Calculate+0xb8>
    3456:	c8 01       	movw	r24, r16
    3458:	b7 01       	movw	r22, r14
    345a:	20 e0       	ldi	r18, 0x00	; 0
    345c:	30 e0       	ldi	r19, 0x00	; 0
    345e:	40 e8       	ldi	r20, 0x80	; 128
    3460:	5f eb       	ldi	r21, 0xBF	; 191
    3462:	0e 94 89 38 	call	0x7112	; 0x7112 <__cmpsf2>
    3466:	87 ff       	sbrs	r24, 7
    3468:	22 c0       	rjmp	.+68     	; 0x34ae <PID_Calculate+0xfc>
		{	// only increment I when the Value is increasing compared to the old one, also use [-2,2] as deadband.
			PID_Term->I += (float)((float)(Value * PID_Params._I) / 200.0f) ;	// try to replace Value with DeltaError
    346a:	6d 81       	ldd	r22, Y+5	; 0x05
    346c:	7e 81       	ldd	r23, Y+6	; 0x06
    346e:	88 27       	eor	r24, r24
    3470:	77 fd       	sbrc	r23, 7
    3472:	80 95       	com	r24
    3474:	98 2f       	mov	r25, r24
    3476:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    347a:	9b 01       	movw	r18, r22
    347c:	ac 01       	movw	r20, r24
    347e:	c8 01       	movw	r24, r16
    3480:	b7 01       	movw	r22, r14
    3482:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    3486:	20 e0       	ldi	r18, 0x00	; 0
    3488:	30 e0       	ldi	r19, 0x00	; 0
    348a:	48 e4       	ldi	r20, 0x48	; 72
    348c:	53 e4       	ldi	r21, 0x43	; 67
    348e:	0e 94 8d 38 	call	0x711a	; 0x711a <__divsf3>
    3492:	9b 01       	movw	r18, r22
    3494:	ac 01       	movw	r20, r24
    3496:	f5 01       	movw	r30, r10
    3498:	64 81       	ldd	r22, Z+4	; 0x04
    349a:	75 81       	ldd	r23, Z+5	; 0x05
    349c:	86 81       	ldd	r24, Z+6	; 0x06
    349e:	97 81       	ldd	r25, Z+7	; 0x07
    34a0:	0e 94 25 38 	call	0x704a	; 0x704a <__addsf3>
    34a4:	f5 01       	movw	r30, r10
    34a6:	64 83       	std	Z+4, r22	; 0x04
    34a8:	75 83       	std	Z+5, r23	; 0x05
    34aa:	86 83       	std	Z+6, r24	; 0x06
    34ac:	97 83       	std	Z+7, r25	; 0x07
			//PID_Term->I -= (float)(PID_Term->I * PID_I_LEAK_RATE);
		//}	
		
		
		
		PID_Term->D= (float)(DeltaError * PID_Params._D) / 20.0f ;
    34ae:	89 85       	ldd	r24, Y+9	; 0x09
    34b0:	9a 85       	ldd	r25, Y+10	; 0x0a
    34b2:	c8 9e       	mul	r12, r24
    34b4:	b0 01       	movw	r22, r0
    34b6:	c9 9e       	mul	r12, r25
    34b8:	70 0d       	add	r23, r0
    34ba:	d8 9e       	mul	r13, r24
    34bc:	70 0d       	add	r23, r0
    34be:	11 24       	eor	r1, r1
    34c0:	88 27       	eor	r24, r24
    34c2:	77 fd       	sbrc	r23, 7
    34c4:	80 95       	com	r24
    34c6:	98 2f       	mov	r25, r24
    34c8:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    34cc:	20 e0       	ldi	r18, 0x00	; 0
    34ce:	30 e0       	ldi	r19, 0x00	; 0
    34d0:	40 ea       	ldi	r20, 0xA0	; 160
    34d2:	51 e4       	ldi	r21, 0x41	; 65
    34d4:	0e 94 8d 38 	call	0x711a	; 0x711a <__divsf3>
    34d8:	f5 01       	movw	r30, r10
    34da:	60 87       	std	Z+8, r22	; 0x08
    34dc:	71 87       	std	Z+9, r23	; 0x09
    34de:	82 87       	std	Z+10, r24	; 0x0a
    34e0:	93 87       	std	Z+11, r25	; 0x0b
		PID_Term->Error = Value;	
    34e2:	e4 86       	std	Z+12, r14	; 0x0c
    34e4:	f5 86       	std	Z+13, r15	; 0x0d
    34e6:	06 87       	std	Z+14, r16	; 0x0e
    34e8:	17 87       	std	Z+15, r17	; 0x0f
		
				
		// Limit boundaries to custom values defined by user.
		PID_Term->I= Limiterf(PID_Term->I, PID_Params._ILimit);
    34ea:	e4 80       	ldd	r14, Z+4	; 0x04
    34ec:	f5 80       	ldd	r15, Z+5	; 0x05
    34ee:	06 81       	ldd	r16, Z+6	; 0x06
    34f0:	17 81       	ldd	r17, Z+7	; 0x07
    34f2:	6f 81       	ldd	r22, Y+7	; 0x07
    34f4:	78 85       	ldd	r23, Y+8	; 0x08
    34f6:	88 27       	eor	r24, r24
    34f8:	77 fd       	sbrc	r23, 7
    34fa:	80 95       	com	r24
    34fc:	98 2f       	mov	r25, r24
    34fe:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    3502:	9b 01       	movw	r18, r22
    3504:	ac 01       	movw	r20, r24
    3506:	c8 01       	movw	r24, r16
    3508:	b7 01       	movw	r22, r14
    350a:	0e 94 51 22 	call	0x44a2	; 0x44a2 <Limiterf>
    350e:	f5 01       	movw	r30, r10
    3510:	64 83       	std	Z+4, r22	; 0x04
    3512:	75 83       	std	Z+5, r23	; 0x05
    3514:	86 83       	std	Z+6, r24	; 0x06
    3516:	97 83       	std	Z+7, r25	; 0x07
		PID_Term->P= Limiterf(PID_Term->P, PID_Params._PLimit);
    3518:	e0 80       	ld	r14, Z
    351a:	f1 80       	ldd	r15, Z+1	; 0x01
    351c:	02 81       	ldd	r16, Z+2	; 0x02
    351e:	13 81       	ldd	r17, Z+3	; 0x03
    3520:	6b 81       	ldd	r22, Y+3	; 0x03
    3522:	7c 81       	ldd	r23, Y+4	; 0x04
    3524:	88 27       	eor	r24, r24
    3526:	77 fd       	sbrc	r23, 7
    3528:	80 95       	com	r24
    352a:	98 2f       	mov	r25, r24
    352c:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    3530:	9b 01       	movw	r18, r22
    3532:	ac 01       	movw	r20, r24
    3534:	c8 01       	movw	r24, r16
    3536:	b7 01       	movw	r22, r14
    3538:	0e 94 51 22 	call	0x44a2	; 0x44a2 <Limiterf>
    353c:	f5 01       	movw	r30, r10
    353e:	60 83       	st	Z, r22
    3540:	71 83       	std	Z+1, r23	; 0x01
    3542:	82 83       	std	Z+2, r24	; 0x02
    3544:	93 83       	std	Z+3, r25	; 0x03
	    PID_Term->D= Limiterf(PID_Term->D, PID_Params._DLimit);
    3546:	e0 84       	ldd	r14, Z+8	; 0x08
    3548:	f1 84       	ldd	r15, Z+9	; 0x09
    354a:	02 85       	ldd	r16, Z+10	; 0x0a
    354c:	13 85       	ldd	r17, Z+11	; 0x0b
    354e:	6b 85       	ldd	r22, Y+11	; 0x0b
    3550:	7c 85       	ldd	r23, Y+12	; 0x0c
    3552:	88 27       	eor	r24, r24
    3554:	77 fd       	sbrc	r23, 7
    3556:	80 95       	com	r24
    3558:	98 2f       	mov	r25, r24
    355a:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    355e:	9b 01       	movw	r18, r22
    3560:	ac 01       	movw	r20, r24
    3562:	c8 01       	movw	r24, r16
    3564:	b7 01       	movw	r22, r14
    3566:	0e 94 51 22 	call	0x44a2	; 0x44a2 <Limiterf>
    356a:	7b 01       	movw	r14, r22
    356c:	8c 01       	movw	r16, r24
    356e:	f5 01       	movw	r30, r10
    3570:	60 87       	std	Z+8, r22	; 0x08
    3572:	71 87       	std	Z+9, r23	; 0x09
    3574:	82 87       	std	Z+10, r24	; 0x0a
    3576:	93 87       	std	Z+11, r25	; 0x0b
	
		Output = (PID_Term->P + PID_Term->I + PID_Term->D);	// P + I + D
    3578:	60 81       	ld	r22, Z
    357a:	71 81       	ldd	r23, Z+1	; 0x01
    357c:	82 81       	ldd	r24, Z+2	; 0x02
    357e:	93 81       	ldd	r25, Z+3	; 0x03
    3580:	24 81       	ldd	r18, Z+4	; 0x04
    3582:	35 81       	ldd	r19, Z+5	; 0x05
    3584:	46 81       	ldd	r20, Z+6	; 0x06
    3586:	57 81       	ldd	r21, Z+7	; 0x07
    3588:	0e 94 25 38 	call	0x704a	; 0x704a <__addsf3>
    358c:	a8 01       	movw	r20, r16
    358e:	97 01       	movw	r18, r14
    3590:	0e 94 25 38 	call	0x704a	; 0x704a <__addsf3>
		//Output = Output / 10;
		return  Output; //Limiter(Output,(int16_t)300);
}		
    3594:	2e 96       	adiw	r28, 0x0e	; 14
    3596:	0f b6       	in	r0, 0x3f	; 63
    3598:	f8 94       	cli
    359a:	de bf       	out	0x3e, r29	; 62
    359c:	0f be       	out	0x3f, r0	; 63
    359e:	cd bf       	out	0x3d, r28	; 61
    35a0:	cf 91       	pop	r28
    35a2:	df 91       	pop	r29
    35a4:	1f 91       	pop	r17
    35a6:	0f 91       	pop	r16
    35a8:	ff 90       	pop	r15
    35aa:	ef 90       	pop	r14
    35ac:	df 90       	pop	r13
    35ae:	cf 90       	pop	r12
    35b0:	bf 90       	pop	r11
    35b2:	af 90       	pop	r10
    35b4:	08 95       	ret

000035b6 <ZERO_Is>:

void ZERO_Is()
{
	PID_GyroTerms[0].I=0;
    35b6:	80 e0       	ldi	r24, 0x00	; 0
    35b8:	90 e0       	ldi	r25, 0x00	; 0
    35ba:	dc 01       	movw	r26, r24
    35bc:	80 93 68 06 	sts	0x0668, r24
    35c0:	90 93 69 06 	sts	0x0669, r25
    35c4:	a0 93 6a 06 	sts	0x066A, r26
    35c8:	b0 93 6b 06 	sts	0x066B, r27
	PID_GyroTerms[1].I=0;
    35cc:	80 93 80 06 	sts	0x0680, r24
    35d0:	90 93 81 06 	sts	0x0681, r25
    35d4:	a0 93 82 06 	sts	0x0682, r26
    35d8:	b0 93 83 06 	sts	0x0683, r27
//	PID_GyroTerms[2].I=0;
	PID_AccTerms[0].I=0;
    35dc:	80 93 54 05 	sts	0x0554, r24
    35e0:	90 93 55 05 	sts	0x0555, r25
    35e4:	a0 93 56 05 	sts	0x0556, r26
    35e8:	b0 93 57 05 	sts	0x0557, r27
	PID_AccTerms[1].I=0;
    35ec:	80 93 6c 05 	sts	0x056C, r24
    35f0:	90 93 6d 05 	sts	0x056D, r25
    35f4:	a0 93 6e 05 	sts	0x056E, r26
    35f8:	b0 93 6f 05 	sts	0x056F, r27
	PID_SonarTerms[0].I=0;
    35fc:	80 93 71 07 	sts	0x0771, r24
    3600:	90 93 72 07 	sts	0x0772, r25
    3604:	a0 93 73 07 	sts	0x0773, r26
    3608:	b0 93 74 07 	sts	0x0774, r27
}
    360c:	08 95       	ret

0000360e <IMU_Reset>:


void IMU_Reset()
{
	
	AnglePitch=0;
    360e:	80 e0       	ldi	r24, 0x00	; 0
    3610:	90 e0       	ldi	r25, 0x00	; 0
    3612:	dc 01       	movw	r26, r24
    3614:	80 93 18 06 	sts	0x0618, r24
    3618:	90 93 19 06 	sts	0x0619, r25
    361c:	a0 93 1a 06 	sts	0x061A, r26
    3620:	b0 93 1b 06 	sts	0x061B, r27
	AngleRoll=0;
    3624:	80 93 ca 06 	sts	0x06CA, r24
    3628:	90 93 cb 06 	sts	0x06CB, r25
    362c:	a0 93 cc 06 	sts	0x06CC, r26
    3630:	b0 93 cd 06 	sts	0x06CD, r27
	
}
    3634:	08 95       	ret

00003636 <IMU>:
//////////////////////////////////////////////////////////////////////////
// inspired by link: http://scolton.blogspot.com/2012/09/a-bit-more-kk20-modding.html
// Although I implement PID and super position in http://hefnycopter.net/index.php/developing-source-code/22-quadcopter-control-function-layers.html
void IMU (void)
{
    3636:	2f 92       	push	r2
    3638:	3f 92       	push	r3
    363a:	4f 92       	push	r4
    363c:	5f 92       	push	r5
    363e:	6f 92       	push	r6
    3640:	7f 92       	push	r7
    3642:	8f 92       	push	r8
    3644:	9f 92       	push	r9
    3646:	af 92       	push	r10
    3648:	bf 92       	push	r11
    364a:	cf 92       	push	r12
    364c:	df 92       	push	r13
    364e:	ef 92       	push	r14
    3650:	ff 92       	push	r15
    3652:	0f 93       	push	r16
    3654:	1f 93       	push	r17
    3656:	df 93       	push	r29
    3658:	cf 93       	push	r28
    365a:	00 d0       	rcall	.+0      	; 0x365c <IMU+0x26>
    365c:	00 d0       	rcall	.+0      	; 0x365e <IMU+0x28>
    365e:	00 d0       	rcall	.+0      	; 0x3660 <IMU+0x2a>
    3660:	cd b7       	in	r28, 0x3d	; 61
    3662:	de b7       	in	r29, 0x3e	; 62
	
		double Alpha;	
		double Beta;
	
	    // calculate ACC-Z
		Alpha = Config.AccParams[1].ComplementaryFilterAlpha / 1000.0;
    3664:	60 91 15 07 	lds	r22, 0x0715
    3668:	70 91 16 07 	lds	r23, 0x0716
    366c:	88 27       	eor	r24, r24
    366e:	77 fd       	sbrc	r23, 7
    3670:	80 95       	com	r24
    3672:	98 2f       	mov	r25, r24
    3674:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    3678:	20 e0       	ldi	r18, 0x00	; 0
    367a:	30 e0       	ldi	r19, 0x00	; 0
    367c:	4a e7       	ldi	r20, 0x7A	; 122
    367e:	54 e4       	ldi	r21, 0x44	; 68
    3680:	0e 94 8d 38 	call	0x711a	; 0x711a <__divsf3>
    3684:	7b 01       	movw	r14, r22
    3686:	8c 01       	movw	r16, r24
		Beta = 1- Alpha; // complementary filter to remove noise
		CompAccZ = (double) (Alpha * CompGyroZ) + (double) (Beta * Sensors_Latest[ACC_Z_Index]);
    3688:	a0 90 1f 06 	lds	r10, 0x061F
    368c:	b0 90 20 06 	lds	r11, 0x0620
    3690:	c0 90 21 06 	lds	r12, 0x0621
    3694:	d0 90 22 06 	lds	r13, 0x0622
    3698:	40 90 47 06 	lds	r4, 0x0647
    369c:	50 90 48 06 	lds	r5, 0x0648
    36a0:	7f 2d       	mov	r23, r15
    36a2:	91 2f       	mov	r25, r17
    36a4:	a6 01       	movw	r20, r12
    36a6:	95 01       	movw	r18, r10
    36a8:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    36ac:	3b 01       	movw	r6, r22
    36ae:	4c 01       	movw	r8, r24
		double Alpha;	
		double Beta;
	
	    // calculate ACC-Z
		Alpha = Config.AccParams[1].ComplementaryFilterAlpha / 1000.0;
		Beta = 1- Alpha; // complementary filter to remove noise
    36b0:	60 e0       	ldi	r22, 0x00	; 0
    36b2:	70 e0       	ldi	r23, 0x00	; 0
    36b4:	80 e8       	ldi	r24, 0x80	; 128
    36b6:	9f e3       	ldi	r25, 0x3F	; 63
    36b8:	2e 2d       	mov	r18, r14
    36ba:	3f 2d       	mov	r19, r15
    36bc:	40 2f       	mov	r20, r16
    36be:	51 2f       	mov	r21, r17
    36c0:	0e 94 24 38 	call	0x7048	; 0x7048 <__subsf3>
    36c4:	7b 01       	movw	r14, r22
    36c6:	8c 01       	movw	r16, r24
		CompAccZ = (double) (Alpha * CompGyroZ) + (double) (Beta * Sensors_Latest[ACC_Z_Index]);
    36c8:	b2 01       	movw	r22, r4
    36ca:	88 27       	eor	r24, r24
    36cc:	77 fd       	sbrc	r23, 7
    36ce:	80 95       	com	r24
    36d0:	98 2f       	mov	r25, r24
    36d2:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    36d6:	9b 01       	movw	r18, r22
    36d8:	ac 01       	movw	r20, r24
    36da:	c8 01       	movw	r24, r16
    36dc:	b7 01       	movw	r22, r14
    36de:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    36e2:	9b 01       	movw	r18, r22
    36e4:	ac 01       	movw	r20, r24
    36e6:	c4 01       	movw	r24, r8
    36e8:	b3 01       	movw	r22, r6
    36ea:	0e 94 25 38 	call	0x704a	; 0x704a <__addsf3>
    36ee:	60 93 39 06 	sts	0x0639, r22
    36f2:	70 93 3a 06 	sts	0x063A, r23
    36f6:	80 93 3b 06 	sts	0x063B, r24
    36fa:	90 93 3c 06 	sts	0x063C, r25
		
		// calculate YAW
		Alpha = Config.GyroParams[1].ComplementaryFilterAlpha / 1000.0;
    36fe:	60 91 f9 06 	lds	r22, 0x06F9
    3702:	70 91 fa 06 	lds	r23, 0x06FA
    3706:	88 27       	eor	r24, r24
    3708:	77 fd       	sbrc	r23, 7
    370a:	80 95       	com	r24
    370c:	98 2f       	mov	r25, r24
    370e:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    3712:	20 e0       	ldi	r18, 0x00	; 0
    3714:	30 e0       	ldi	r19, 0x00	; 0
    3716:	4a e7       	ldi	r20, 0x7A	; 122
    3718:	54 e4       	ldi	r21, 0x44	; 68
    371a:	0e 94 8d 38 	call	0x711a	; 0x711a <__divsf3>
    371e:	7b 01       	movw	r14, r22
    3720:	8c 01       	movw	r16, r24
		Beta = 1- Alpha; // complementary filter to remove noise
		CompGyroZ = (double) (Alpha * CompGyroZ) + (double) (Beta * Sensors_Latest[GYRO_Z_Index]);
    3722:	80 90 41 06 	lds	r8, 0x0641
    3726:	90 90 42 06 	lds	r9, 0x0642
    372a:	7f 2d       	mov	r23, r15
    372c:	91 2f       	mov	r25, r17
    372e:	a6 01       	movw	r20, r12
    3730:	95 01       	movw	r18, r10
    3732:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    3736:	5b 01       	movw	r10, r22
    3738:	6c 01       	movw	r12, r24
		Beta = 1- Alpha; // complementary filter to remove noise
		CompAccZ = (double) (Alpha * CompGyroZ) + (double) (Beta * Sensors_Latest[ACC_Z_Index]);
		
		// calculate YAW
		Alpha = Config.GyroParams[1].ComplementaryFilterAlpha / 1000.0;
		Beta = 1- Alpha; // complementary filter to remove noise
    373a:	60 e0       	ldi	r22, 0x00	; 0
    373c:	70 e0       	ldi	r23, 0x00	; 0
    373e:	80 e8       	ldi	r24, 0x80	; 128
    3740:	9f e3       	ldi	r25, 0x3F	; 63
    3742:	2e 2d       	mov	r18, r14
    3744:	3f 2d       	mov	r19, r15
    3746:	40 2f       	mov	r20, r16
    3748:	51 2f       	mov	r21, r17
    374a:	0e 94 24 38 	call	0x7048	; 0x7048 <__subsf3>
    374e:	7b 01       	movw	r14, r22
    3750:	8c 01       	movw	r16, r24
		CompGyroZ = (double) (Alpha * CompGyroZ) + (double) (Beta * Sensors_Latest[GYRO_Z_Index]);
    3752:	b4 01       	movw	r22, r8
    3754:	88 27       	eor	r24, r24
    3756:	77 fd       	sbrc	r23, 7
    3758:	80 95       	com	r24
    375a:	98 2f       	mov	r25, r24
    375c:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    3760:	9b 01       	movw	r18, r22
    3762:	ac 01       	movw	r20, r24
    3764:	c8 01       	movw	r24, r16
    3766:	b7 01       	movw	r22, r14
    3768:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    376c:	9b 01       	movw	r18, r22
    376e:	ac 01       	movw	r20, r24
    3770:	c6 01       	movw	r24, r12
    3772:	b5 01       	movw	r22, r10
    3774:	0e 94 25 38 	call	0x704a	; 0x704a <__addsf3>
    3778:	60 93 1f 06 	sts	0x061F, r22
    377c:	70 93 20 06 	sts	0x0620, r23
    3780:	80 93 21 06 	sts	0x0621, r24
    3784:	90 93 22 06 	sts	0x0622, r25
		
		Alpha = Config.GyroParams[0].ComplementaryFilterAlpha / 1000.0;
    3788:	60 91 eb 06 	lds	r22, 0x06EB
    378c:	70 91 ec 06 	lds	r23, 0x06EC
    3790:	88 27       	eor	r24, r24
    3792:	77 fd       	sbrc	r23, 7
    3794:	80 95       	com	r24
    3796:	98 2f       	mov	r25, r24
    3798:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    379c:	20 e0       	ldi	r18, 0x00	; 0
    379e:	30 e0       	ldi	r19, 0x00	; 0
    37a0:	4a e7       	ldi	r20, 0x7A	; 122
    37a2:	54 e4       	ldi	r21, 0x44	; 68
    37a4:	0e 94 8d 38 	call	0x711a	; 0x711a <__divsf3>
    37a8:	8b 01       	movw	r16, r22
    37aa:	e8 2e       	mov	r14, r24
    37ac:	b9 2e       	mov	r11, r25
		Beta = 1- Alpha; // complementary filter to remove noise
    37ae:	60 e0       	ldi	r22, 0x00	; 0
    37b0:	70 e0       	ldi	r23, 0x00	; 0
    37b2:	80 e8       	ldi	r24, 0x80	; 128
    37b4:	9f e3       	ldi	r25, 0x3F	; 63
    37b6:	20 2f       	mov	r18, r16
    37b8:	31 2f       	mov	r19, r17
    37ba:	4e 2d       	mov	r20, r14
    37bc:	5b 2d       	mov	r21, r11
    37be:	0e 94 24 38 	call	0x7048	; 0x7048 <__subsf3>
    37c2:	56 2e       	mov	r5, r22
    37c4:	47 2e       	mov	r4, r23
    37c6:	38 2e       	mov	r3, r24
    37c8:	29 2e       	mov	r2, r25
		CompGyroPitch = (double) (Alpha * CompGyroPitch) + (double) (Beta * Sensors_Latest[GYRO_PITCH_Index]);
    37ca:	c0 90 3f 06 	lds	r12, 0x063F
    37ce:	d0 90 40 06 	lds	r13, 0x0640
    37d2:	60 2f       	mov	r22, r16
    37d4:	71 2f       	mov	r23, r17
    37d6:	8e 2d       	mov	r24, r14
    37d8:	9b 2d       	mov	r25, r11
    37da:	20 91 e2 05 	lds	r18, 0x05E2
    37de:	30 91 e3 05 	lds	r19, 0x05E3
    37e2:	40 91 e4 05 	lds	r20, 0x05E4
    37e6:	50 91 e5 05 	lds	r21, 0x05E5
    37ea:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    37ee:	3b 01       	movw	r6, r22
    37f0:	4c 01       	movw	r8, r24
    37f2:	b6 01       	movw	r22, r12
    37f4:	88 27       	eor	r24, r24
    37f6:	77 fd       	sbrc	r23, 7
    37f8:	80 95       	com	r24
    37fa:	98 2f       	mov	r25, r24
    37fc:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    3800:	9b 01       	movw	r18, r22
    3802:	ac 01       	movw	r20, r24
    3804:	d2 01       	movw	r26, r4
    3806:	f1 01       	movw	r30, r2
    3808:	6b 2f       	mov	r22, r27
    380a:	7a 2f       	mov	r23, r26
    380c:	8f 2f       	mov	r24, r31
    380e:	9e 2f       	mov	r25, r30
    3810:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    3814:	9b 01       	movw	r18, r22
    3816:	ac 01       	movw	r20, r24
    3818:	c4 01       	movw	r24, r8
    381a:	b3 01       	movw	r22, r6
    381c:	0e 94 25 38 	call	0x704a	; 0x704a <__addsf3>
    3820:	f6 2e       	mov	r15, r22
    3822:	d7 2e       	mov	r13, r23
    3824:	c8 2e       	mov	r12, r24
    3826:	a9 2e       	mov	r10, r25
    3828:	86 2f       	mov	r24, r22
    382a:	9d 2d       	mov	r25, r13
    382c:	ac 2d       	mov	r26, r12
    382e:	ba 2d       	mov	r27, r10
    3830:	80 93 e2 05 	sts	0x05E2, r24
    3834:	90 93 e3 05 	sts	0x05E3, r25
    3838:	a0 93 e4 05 	sts	0x05E4, r26
    383c:	b0 93 e5 05 	sts	0x05E5, r27
		CompGyroRoll  = (double) (Alpha * CompGyroRoll)  + (double) (Beta * Sensors_Latest[GYRO_ROLL_Index]);
    3840:	20 91 3d 06 	lds	r18, 0x063D
    3844:	30 91 3e 06 	lds	r19, 0x063E
    3848:	3e 83       	std	Y+6, r19	; 0x06
    384a:	2d 83       	std	Y+5, r18	; 0x05
    384c:	60 2f       	mov	r22, r16
    384e:	71 2f       	mov	r23, r17
    3850:	8e 2d       	mov	r24, r14
    3852:	9b 2d       	mov	r25, r11
    3854:	20 91 60 06 	lds	r18, 0x0660
    3858:	30 91 61 06 	lds	r19, 0x0661
    385c:	40 91 62 06 	lds	r20, 0x0662
    3860:	50 91 63 06 	lds	r21, 0x0663
    3864:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    3868:	3b 01       	movw	r6, r22
    386a:	4c 01       	movw	r8, r24
    386c:	ed 81       	ldd	r30, Y+5	; 0x05
    386e:	fe 81       	ldd	r31, Y+6	; 0x06
    3870:	bf 01       	movw	r22, r30
    3872:	88 27       	eor	r24, r24
    3874:	77 fd       	sbrc	r23, 7
    3876:	80 95       	com	r24
    3878:	98 2f       	mov	r25, r24
    387a:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    387e:	9b 01       	movw	r18, r22
    3880:	ac 01       	movw	r20, r24
    3882:	d2 01       	movw	r26, r4
    3884:	f1 01       	movw	r30, r2
    3886:	6b 2f       	mov	r22, r27
    3888:	7a 2f       	mov	r23, r26
    388a:	8f 2f       	mov	r24, r31
    388c:	9e 2f       	mov	r25, r30
    388e:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    3892:	9b 01       	movw	r18, r22
    3894:	ac 01       	movw	r20, r24
    3896:	c4 01       	movw	r24, r8
    3898:	b3 01       	movw	r22, r6
    389a:	0e 94 25 38 	call	0x704a	; 0x704a <__addsf3>
    389e:	60 93 60 06 	sts	0x0660, r22
    38a2:	70 93 61 06 	sts	0x0661, r23
    38a6:	80 93 62 06 	sts	0x0662, r24
    38aa:	90 93 63 06 	sts	0x0663, r25
		
					
		// GYRO Always calculated.
		gyroPitch =	PID_Calculate (Config.GyroParams[0], &PID_GyroTerms[0],CompGyroPitch);	
    38ae:	00 d0       	rcall	.+0      	; 0x38b0 <IMU+0x27a>
    38b0:	00 d0       	rcall	.+0      	; 0x38b2 <IMU+0x27c>
    38b2:	8f 2d       	mov	r24, r15
    38b4:	9d 2d       	mov	r25, r13
    38b6:	ac 2d       	mov	r26, r12
    38b8:	ba 2d       	mov	r27, r10
    38ba:	ed b7       	in	r30, 0x3d	; 61
    38bc:	fe b7       	in	r31, 0x3e	; 62
    38be:	81 83       	std	Z+1, r24	; 0x01
    38c0:	92 83       	std	Z+2, r25	; 0x02
    38c2:	a3 83       	std	Z+3, r26	; 0x03
    38c4:	b4 83       	std	Z+4, r27	; 0x04
    38c6:	c0 90 df 06 	lds	r12, 0x06DF
    38ca:	d0 90 e0 06 	lds	r13, 0x06E0
    38ce:	e0 90 e1 06 	lds	r14, 0x06E1
    38d2:	f0 90 e2 06 	lds	r15, 0x06E2
    38d6:	00 91 e3 06 	lds	r16, 0x06E3
    38da:	10 91 e4 06 	lds	r17, 0x06E4
    38de:	20 91 e5 06 	lds	r18, 0x06E5
    38e2:	30 91 e6 06 	lds	r19, 0x06E6
    38e6:	40 91 e7 06 	lds	r20, 0x06E7
    38ea:	50 91 e8 06 	lds	r21, 0x06E8
    38ee:	60 91 e9 06 	lds	r22, 0x06E9
    38f2:	70 91 ea 06 	lds	r23, 0x06EA
    38f6:	80 91 eb 06 	lds	r24, 0x06EB
    38fa:	90 91 ec 06 	lds	r25, 0x06EC
    38fe:	e4 e6       	ldi	r30, 0x64	; 100
    3900:	ae 2e       	mov	r10, r30
    3902:	e6 e0       	ldi	r30, 0x06	; 6
    3904:	be 2e       	mov	r11, r30
    3906:	0e 94 d9 19 	call	0x33b2	; 0x33b2 <PID_Calculate>
    390a:	0e 94 f5 38 	call	0x71ea	; 0x71ea <__fixsfsi>
    390e:	70 93 38 06 	sts	0x0638, r23
    3912:	60 93 37 06 	sts	0x0637, r22
		gyroRoll  = PID_Calculate (Config.GyroParams[0], &PID_GyroTerms[1],CompGyroRoll); 
    3916:	80 91 60 06 	lds	r24, 0x0660
    391a:	90 91 61 06 	lds	r25, 0x0661
    391e:	a0 91 62 06 	lds	r26, 0x0662
    3922:	b0 91 63 06 	lds	r27, 0x0663
    3926:	ed b7       	in	r30, 0x3d	; 61
    3928:	fe b7       	in	r31, 0x3e	; 62
    392a:	81 83       	std	Z+1, r24	; 0x01
    392c:	92 83       	std	Z+2, r25	; 0x02
    392e:	a3 83       	std	Z+3, r26	; 0x03
    3930:	b4 83       	std	Z+4, r27	; 0x04
    3932:	c0 90 df 06 	lds	r12, 0x06DF
    3936:	d0 90 e0 06 	lds	r13, 0x06E0
    393a:	e0 90 e1 06 	lds	r14, 0x06E1
    393e:	f0 90 e2 06 	lds	r15, 0x06E2
    3942:	00 91 e3 06 	lds	r16, 0x06E3
    3946:	10 91 e4 06 	lds	r17, 0x06E4
    394a:	20 91 e5 06 	lds	r18, 0x06E5
    394e:	30 91 e6 06 	lds	r19, 0x06E6
    3952:	40 91 e7 06 	lds	r20, 0x06E7
    3956:	50 91 e8 06 	lds	r21, 0x06E8
    395a:	60 91 e9 06 	lds	r22, 0x06E9
    395e:	70 91 ea 06 	lds	r23, 0x06EA
    3962:	80 91 eb 06 	lds	r24, 0x06EB
    3966:	90 91 ec 06 	lds	r25, 0x06EC
    396a:	bc e7       	ldi	r27, 0x7C	; 124
    396c:	ab 2e       	mov	r10, r27
    396e:	b6 e0       	ldi	r27, 0x06	; 6
    3970:	bb 2e       	mov	r11, r27
    3972:	0e 94 d9 19 	call	0x33b2	; 0x33b2 <PID_Calculate>
    3976:	0e 94 f5 38 	call	0x71ea	; 0x71ea <__fixsfsi>
    397a:	70 93 b9 05 	sts	0x05B9, r23
    397e:	60 93 b8 05 	sts	0x05B8, r22
		gyroYaw   = PID_Calculate (Config.GyroParams[1], &PID_GyroTerms[2],CompGyroZ -((double)((float)RX_Snapshot[RXChannel_RUD]  / 2.0f))); 
    3982:	0d b7       	in	r16, 0x3d	; 61
    3984:	1e b7       	in	r17, 0x3e	; 62
    3986:	0f 5f       	subi	r16, 0xFF	; 255
    3988:	1f 4f       	sbci	r17, 0xFF	; 255
    398a:	60 91 c4 05 	lds	r22, 0x05C4
    398e:	70 91 c5 05 	lds	r23, 0x05C5
    3992:	88 27       	eor	r24, r24
    3994:	77 fd       	sbrc	r23, 7
    3996:	80 95       	com	r24
    3998:	98 2f       	mov	r25, r24
    399a:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    399e:	20 e0       	ldi	r18, 0x00	; 0
    39a0:	30 e0       	ldi	r19, 0x00	; 0
    39a2:	40 e0       	ldi	r20, 0x00	; 0
    39a4:	5f e3       	ldi	r21, 0x3F	; 63
    39a6:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    39aa:	9b 01       	movw	r18, r22
    39ac:	ac 01       	movw	r20, r24
    39ae:	60 91 1f 06 	lds	r22, 0x061F
    39b2:	70 91 20 06 	lds	r23, 0x0620
    39b6:	80 91 21 06 	lds	r24, 0x0621
    39ba:	90 91 22 06 	lds	r25, 0x0622
    39be:	0e 94 24 38 	call	0x7048	; 0x7048 <__subsf3>
    39c2:	f8 01       	movw	r30, r16
    39c4:	60 83       	st	Z, r22
    39c6:	71 83       	std	Z+1, r23	; 0x01
    39c8:	82 83       	std	Z+2, r24	; 0x02
    39ca:	93 83       	std	Z+3, r25	; 0x03
    39cc:	c0 90 ed 06 	lds	r12, 0x06ED
    39d0:	d0 90 ee 06 	lds	r13, 0x06EE
    39d4:	e0 90 ef 06 	lds	r14, 0x06EF
    39d8:	f0 90 f0 06 	lds	r15, 0x06F0
    39dc:	00 91 f1 06 	lds	r16, 0x06F1
    39e0:	10 91 f2 06 	lds	r17, 0x06F2
    39e4:	20 91 f3 06 	lds	r18, 0x06F3
    39e8:	30 91 f4 06 	lds	r19, 0x06F4
    39ec:	40 91 f5 06 	lds	r20, 0x06F5
    39f0:	50 91 f6 06 	lds	r21, 0x06F6
    39f4:	60 91 f7 06 	lds	r22, 0x06F7
    39f8:	70 91 f8 06 	lds	r23, 0x06F8
    39fc:	80 91 f9 06 	lds	r24, 0x06F9
    3a00:	90 91 fa 06 	lds	r25, 0x06FA
    3a04:	a4 e9       	ldi	r26, 0x94	; 148
    3a06:	aa 2e       	mov	r10, r26
    3a08:	a6 e0       	ldi	r26, 0x06	; 6
    3a0a:	ba 2e       	mov	r11, r26
    3a0c:	0e 94 d9 19 	call	0x33b2	; 0x33b2 <PID_Calculate>
    3a10:	0e 94 f5 38 	call	0x71ea	; 0x71ea <__fixsfsi>
    3a14:	70 93 d0 06 	sts	0x06D0, r23
    3a18:	60 93 cf 06 	sts	0x06CF, r22
		//if (IS_FLYINGMODE_ACRO==0)
		//{	// Level or ALT HOLD
			
			// Read ACC and Trims
			// ACC directions are same as GYRO direction [we added "-" for this purpose] 
			double APitch = - Sensors_Latest[ACC_PITCH_Index] - Config.Acc_Pitch_Trim;
    3a1c:	60 91 43 06 	lds	r22, 0x0643
    3a20:	70 91 44 06 	lds	r23, 0x0644
    3a24:	70 95       	com	r23
    3a26:	61 95       	neg	r22
    3a28:	7f 4f       	sbci	r23, 0xFF	; 255
    3a2a:	80 91 26 07 	lds	r24, 0x0726
    3a2e:	99 27       	eor	r25, r25
    3a30:	87 fd       	sbrc	r24, 7
    3a32:	90 95       	com	r25
    3a34:	68 1b       	sub	r22, r24
    3a36:	79 0b       	sbc	r23, r25
    3a38:	88 27       	eor	r24, r24
    3a3a:	77 fd       	sbrc	r23, 7
    3a3c:	80 95       	com	r24
    3a3e:	98 2f       	mov	r25, r24
    3a40:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    3a44:	d6 2e       	mov	r13, r22
    3a46:	c7 2e       	mov	r12, r23
    3a48:	b8 2e       	mov	r11, r24
    3a4a:	a9 2e       	mov	r10, r25
			double ARoll  = - Sensors_Latest[ACC_ROLL_Index]  - Config.Acc_Roll_Trim;
    3a4c:	60 91 45 06 	lds	r22, 0x0645
    3a50:	70 91 46 06 	lds	r23, 0x0646
    3a54:	70 95       	com	r23
    3a56:	61 95       	neg	r22
    3a58:	7f 4f       	sbci	r23, 0xFF	; 255
    3a5a:	80 91 27 07 	lds	r24, 0x0727
    3a5e:	99 27       	eor	r25, r25
    3a60:	87 fd       	sbrc	r24, 7
    3a62:	90 95       	com	r25
    3a64:	68 1b       	sub	r22, r24
    3a66:	79 0b       	sbc	r23, r25
    3a68:	88 27       	eor	r24, r24
    3a6a:	77 fd       	sbrc	r23, 7
    3a6c:	80 95       	com	r24
    3a6e:	98 2f       	mov	r25, r24
    3a70:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    3a74:	56 2e       	mov	r5, r22
    3a76:	79 83       	std	Y+1, r23	; 0x01
    3a78:	8a 83       	std	Y+2, r24	; 0x02
    3a7a:	9b 83       	std	Y+3, r25	; 0x03
			double DT_YAW =  (double)Sensors_Latest[GYRO_Z_Index] * GYRO_RATE; 
    3a7c:	80 91 41 06 	lds	r24, 0x0641
    3a80:	90 91 42 06 	lds	r25, 0x0642
			
			
			// Do the Magic of IMU LEVELING here
			// check also : http://scolton.blogspot.com/2012/09/fun-with-complementary-filter-multiwii.html
			AnglePitch = AnglePitch
					   + (double)Sensors_Latest[GYRO_PITCH_Index] * GYRO_RATE
    3a84:	e0 90 18 06 	lds	r14, 0x0618
    3a88:	f0 90 19 06 	lds	r15, 0x0619
    3a8c:	00 91 1a 06 	lds	r16, 0x061A
    3a90:	10 91 1b 06 	lds	r17, 0x061B
    3a94:	60 91 3f 06 	lds	r22, 0x063F
    3a98:	70 91 40 06 	lds	r23, 0x0640
    3a9c:	88 27       	eor	r24, r24
    3a9e:	77 fd       	sbrc	r23, 7
    3aa0:	80 95       	com	r24
    3aa2:	98 2f       	mov	r25, r24
    3aa4:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    3aa8:	2b e1       	ldi	r18, 0x1B	; 27
    3aaa:	3f e2       	ldi	r19, 0x2F	; 47
    3aac:	4d ed       	ldi	r20, 0xDD	; 221
    3aae:	5c e3       	ldi	r21, 0x3C	; 60
    3ab0:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    3ab4:	9b 01       	movw	r18, r22
    3ab6:	ac 01       	movw	r20, r24
    3ab8:	c8 01       	movw	r24, r16
    3aba:	b7 01       	movw	r22, r14
    3abc:	0e 94 25 38 	call	0x704a	; 0x704a <__addsf3>
    3ac0:	9b 01       	movw	r18, r22
    3ac2:	ac 01       	movw	r20, r24
			double DT_YAW =  (double)Sensors_Latest[GYRO_Z_Index] * GYRO_RATE; 
			
			
			// Do the Magic of IMU LEVELING here
			// check also : http://scolton.blogspot.com/2012/09/fun-with-complementary-filter-multiwii.html
			AnglePitch = AnglePitch
    3ac4:	20 93 18 06 	sts	0x0618, r18
    3ac8:	30 93 19 06 	sts	0x0619, r19
    3acc:	40 93 1a 06 	sts	0x061A, r20
    3ad0:	50 93 1b 06 	sts	0x061B, r21
					   + (double)Sensors_Latest[GYRO_PITCH_Index] * GYRO_RATE
					  // + (sin(AngleRoll * DEG_TO_RAD) * DT_YAW)  // integrate component of yaw rate into pitch angle
						;
			AngleRoll = AngleRoll  
					  + (double)Sensors_Latest[GYRO_ROLL_Index]  * GYRO_RATE
    3ad4:	e0 90 ca 06 	lds	r14, 0x06CA
    3ad8:	f0 90 cb 06 	lds	r15, 0x06CB
    3adc:	00 91 cc 06 	lds	r16, 0x06CC
    3ae0:	10 91 cd 06 	lds	r17, 0x06CD
    3ae4:	60 91 3d 06 	lds	r22, 0x063D
    3ae8:	70 91 3e 06 	lds	r23, 0x063E
    3aec:	88 27       	eor	r24, r24
    3aee:	77 fd       	sbrc	r23, 7
    3af0:	80 95       	com	r24
    3af2:	98 2f       	mov	r25, r24
    3af4:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    3af8:	2b e1       	ldi	r18, 0x1B	; 27
    3afa:	3f e2       	ldi	r19, 0x2F	; 47
    3afc:	4d ed       	ldi	r20, 0xDD	; 221
    3afe:	5c e3       	ldi	r21, 0x3C	; 60
    3b00:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    3b04:	9b 01       	movw	r18, r22
    3b06:	ac 01       	movw	r20, r24
    3b08:	c8 01       	movw	r24, r16
    3b0a:	b7 01       	movw	r22, r14
    3b0c:	0e 94 25 38 	call	0x704a	; 0x704a <__addsf3>
    3b10:	9b 01       	movw	r18, r22
    3b12:	ac 01       	movw	r20, r24
			// check also : http://scolton.blogspot.com/2012/09/fun-with-complementary-filter-multiwii.html
			AnglePitch = AnglePitch
					   + (double)Sensors_Latest[GYRO_PITCH_Index] * GYRO_RATE
					  // + (sin(AngleRoll * DEG_TO_RAD) * DT_YAW)  // integrate component of yaw rate into pitch angle
						;
			AngleRoll = AngleRoll  
    3b14:	20 93 ca 06 	sts	0x06CA, r18
    3b18:	30 93 cb 06 	sts	0x06CB, r19
    3b1c:	40 93 cc 06 	sts	0x06CC, r20
    3b20:	50 93 cd 06 	sts	0x06CD, r21
					  + (double)Sensors_Latest[GYRO_ROLL_Index]  * GYRO_RATE
					 // - (sin(AnglePitch * DEG_TO_RAD) * DT_YAW)  // integrate component of yaw rate into roll angle
					  ; 
			
			// Correct Drift using ACC
			Alpha = Config.AccParams[0].ComplementaryFilterAlpha / 1000.0; // TODO: optimize
    3b24:	60 91 07 07 	lds	r22, 0x0707
    3b28:	70 91 08 07 	lds	r23, 0x0708
    3b2c:	88 27       	eor	r24, r24
    3b2e:	77 fd       	sbrc	r23, 7
    3b30:	80 95       	com	r24
    3b32:	98 2f       	mov	r25, r24
    3b34:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    3b38:	20 e0       	ldi	r18, 0x00	; 0
    3b3a:	30 e0       	ldi	r19, 0x00	; 0
    3b3c:	4a e7       	ldi	r20, 0x7A	; 122
    3b3e:	54 e4       	ldi	r21, 0x44	; 68
    3b40:	0e 94 8d 38 	call	0x711a	; 0x711a <__divsf3>
    3b44:	f6 2e       	mov	r15, r22
    3b46:	07 2f       	mov	r16, r23
    3b48:	18 2f       	mov	r17, r24
    3b4a:	e9 2e       	mov	r14, r25
			Beta = 1- Alpha;
    3b4c:	60 e0       	ldi	r22, 0x00	; 0
    3b4e:	70 e0       	ldi	r23, 0x00	; 0
    3b50:	80 e8       	ldi	r24, 0x80	; 128
    3b52:	9f e3       	ldi	r25, 0x3F	; 63
    3b54:	2f 2d       	mov	r18, r15
    3b56:	30 2f       	mov	r19, r16
    3b58:	41 2f       	mov	r20, r17
    3b5a:	5e 2d       	mov	r21, r14
    3b5c:	0e 94 24 38 	call	0x7048	; 0x7048 <__subsf3>
    3b60:	46 2e       	mov	r4, r22
    3b62:	37 2e       	mov	r3, r23
    3b64:	28 2e       	mov	r2, r24
    3b66:	9c 83       	std	Y+4, r25	; 0x04
			#define ACC_SMALL_ANGLE	40
			// if small angle then correct using ACC
			if ((APitch < ACC_SMALL_ANGLE) && (APitch > -ACC_SMALL_ANGLE)) 
    3b68:	0f 90       	pop	r0
    3b6a:	0f 90       	pop	r0
    3b6c:	0f 90       	pop	r0
    3b6e:	0f 90       	pop	r0
    3b70:	a6 01       	movw	r20, r12
    3b72:	95 01       	movw	r18, r10
    3b74:	65 2f       	mov	r22, r21
    3b76:	74 2f       	mov	r23, r20
    3b78:	83 2f       	mov	r24, r19
    3b7a:	92 2f       	mov	r25, r18
    3b7c:	20 e0       	ldi	r18, 0x00	; 0
    3b7e:	30 e0       	ldi	r19, 0x00	; 0
    3b80:	40 e2       	ldi	r20, 0x20	; 32
    3b82:	52 e4       	ldi	r21, 0x42	; 66
    3b84:	0e 94 89 38 	call	0x7112	; 0x7112 <__cmpsf2>
    3b88:	87 ff       	sbrs	r24, 7
    3b8a:	3b c0       	rjmp	.+118    	; 0x3c02 <IMU+0x5cc>
    3b8c:	a6 01       	movw	r20, r12
    3b8e:	95 01       	movw	r18, r10
    3b90:	65 2f       	mov	r22, r21
    3b92:	74 2f       	mov	r23, r20
    3b94:	83 2f       	mov	r24, r19
    3b96:	92 2f       	mov	r25, r18
    3b98:	20 e0       	ldi	r18, 0x00	; 0
    3b9a:	30 e0       	ldi	r19, 0x00	; 0
    3b9c:	40 e2       	ldi	r20, 0x20	; 32
    3b9e:	52 ec       	ldi	r21, 0xC2	; 194
    3ba0:	0e 94 d8 39 	call	0x73b0	; 0x73b0 <__gesf2>
    3ba4:	18 16       	cp	r1, r24
    3ba6:	6c f5       	brge	.+90     	; 0x3c02 <IMU+0x5cc>
			{
				AnglePitch = Alpha * AnglePitch + Beta * APitch;
    3ba8:	20 91 18 06 	lds	r18, 0x0618
    3bac:	30 91 19 06 	lds	r19, 0x0619
    3bb0:	40 91 1a 06 	lds	r20, 0x061A
    3bb4:	50 91 1b 06 	lds	r21, 0x061B
    3bb8:	6f 2d       	mov	r22, r15
    3bba:	70 2f       	mov	r23, r16
    3bbc:	81 2f       	mov	r24, r17
    3bbe:	9e 2d       	mov	r25, r14
    3bc0:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    3bc4:	3b 01       	movw	r6, r22
    3bc6:	4c 01       	movw	r8, r24
    3bc8:	2c 81       	ldd	r18, Y+4	; 0x04
    3bca:	64 2d       	mov	r22, r4
    3bcc:	73 2d       	mov	r23, r3
    3bce:	82 2d       	mov	r24, r2
    3bd0:	92 2f       	mov	r25, r18
    3bd2:	d6 01       	movw	r26, r12
    3bd4:	f5 01       	movw	r30, r10
    3bd6:	2b 2f       	mov	r18, r27
    3bd8:	3a 2f       	mov	r19, r26
    3bda:	4f 2f       	mov	r20, r31
    3bdc:	5e 2f       	mov	r21, r30
    3bde:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    3be2:	9b 01       	movw	r18, r22
    3be4:	ac 01       	movw	r20, r24
    3be6:	c4 01       	movw	r24, r8
    3be8:	b3 01       	movw	r22, r6
    3bea:	0e 94 25 38 	call	0x704a	; 0x704a <__addsf3>
    3bee:	9b 01       	movw	r18, r22
    3bf0:	ac 01       	movw	r20, r24
    3bf2:	20 93 18 06 	sts	0x0618, r18
    3bf6:	30 93 19 06 	sts	0x0619, r19
    3bfa:	40 93 1a 06 	sts	0x061A, r20
    3bfe:	50 93 1b 06 	sts	0x061B, r21
			}
		
			if ((ARoll  < ACC_SMALL_ANGLE) && (ARoll  > -ACC_SMALL_ANGLE))
    3c02:	49 81       	ldd	r20, Y+1	; 0x01
    3c04:	3a 81       	ldd	r19, Y+2	; 0x02
    3c06:	2b 81       	ldd	r18, Y+3	; 0x03
    3c08:	65 2d       	mov	r22, r5
    3c0a:	74 2f       	mov	r23, r20
    3c0c:	83 2f       	mov	r24, r19
    3c0e:	92 2f       	mov	r25, r18
    3c10:	20 e0       	ldi	r18, 0x00	; 0
    3c12:	30 e0       	ldi	r19, 0x00	; 0
    3c14:	40 e2       	ldi	r20, 0x20	; 32
    3c16:	52 e4       	ldi	r21, 0x42	; 66
    3c18:	0e 94 89 38 	call	0x7112	; 0x7112 <__cmpsf2>
    3c1c:	87 ff       	sbrs	r24, 7
    3c1e:	3d c0       	rjmp	.+122    	; 0x3c9a <IMU+0x664>
    3c20:	49 81       	ldd	r20, Y+1	; 0x01
    3c22:	3a 81       	ldd	r19, Y+2	; 0x02
    3c24:	2b 81       	ldd	r18, Y+3	; 0x03
    3c26:	65 2d       	mov	r22, r5
    3c28:	74 2f       	mov	r23, r20
    3c2a:	83 2f       	mov	r24, r19
    3c2c:	92 2f       	mov	r25, r18
    3c2e:	20 e0       	ldi	r18, 0x00	; 0
    3c30:	30 e0       	ldi	r19, 0x00	; 0
    3c32:	40 e2       	ldi	r20, 0x20	; 32
    3c34:	52 ec       	ldi	r21, 0xC2	; 194
    3c36:	0e 94 d8 39 	call	0x73b0	; 0x73b0 <__gesf2>
    3c3a:	18 16       	cp	r1, r24
    3c3c:	74 f5       	brge	.+92     	; 0x3c9a <IMU+0x664>
			{
				AngleRoll =  Alpha * AngleRoll + Beta * ARoll;
    3c3e:	20 91 ca 06 	lds	r18, 0x06CA
    3c42:	30 91 cb 06 	lds	r19, 0x06CB
    3c46:	40 91 cc 06 	lds	r20, 0x06CC
    3c4a:	50 91 cd 06 	lds	r21, 0x06CD
    3c4e:	6f 2d       	mov	r22, r15
    3c50:	70 2f       	mov	r23, r16
    3c52:	81 2f       	mov	r24, r17
    3c54:	9e 2d       	mov	r25, r14
    3c56:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    3c5a:	7b 01       	movw	r14, r22
    3c5c:	8c 01       	movw	r16, r24
    3c5e:	2c 81       	ldd	r18, Y+4	; 0x04
    3c60:	64 2d       	mov	r22, r4
    3c62:	73 2d       	mov	r23, r3
    3c64:	82 2d       	mov	r24, r2
    3c66:	92 2f       	mov	r25, r18
    3c68:	a9 81       	ldd	r26, Y+1	; 0x01
    3c6a:	da 80       	ldd	r13, Y+2	; 0x02
    3c6c:	cb 80       	ldd	r12, Y+3	; 0x03
    3c6e:	25 2d       	mov	r18, r5
    3c70:	3a 2f       	mov	r19, r26
    3c72:	4d 2d       	mov	r20, r13
    3c74:	5c 2d       	mov	r21, r12
    3c76:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    3c7a:	9b 01       	movw	r18, r22
    3c7c:	ac 01       	movw	r20, r24
    3c7e:	c8 01       	movw	r24, r16
    3c80:	b7 01       	movw	r22, r14
    3c82:	0e 94 25 38 	call	0x704a	; 0x704a <__addsf3>
    3c86:	9b 01       	movw	r18, r22
    3c88:	ac 01       	movw	r20, r24
    3c8a:	20 93 ca 06 	sts	0x06CA, r18
    3c8e:	30 93 cb 06 	sts	0x06CB, r19
    3c92:	40 93 cc 06 	sts	0x06CC, r20
    3c96:	50 93 cd 06 	sts	0x06CD, r21
			
			}
			
			
			NavY = AnglePitch;
    3c9a:	e0 90 18 06 	lds	r14, 0x0618
    3c9e:	f0 90 19 06 	lds	r15, 0x0619
    3ca2:	00 91 1a 06 	lds	r16, 0x061A
    3ca6:	10 91 1b 06 	lds	r17, 0x061B
    3caa:	e0 92 00 06 	sts	0x0600, r14
    3cae:	f0 92 01 06 	sts	0x0601, r15
    3cb2:	00 93 02 06 	sts	0x0602, r16
    3cb6:	10 93 03 06 	sts	0x0603, r17
			NavX = AngleRoll;
    3cba:	20 90 ca 06 	lds	r2, 0x06CA
    3cbe:	30 90 cb 06 	lds	r3, 0x06CB
    3cc2:	40 90 cc 06 	lds	r4, 0x06CC
    3cc6:	50 90 cd 06 	lds	r5, 0x06CD
    3cca:	20 92 4a 05 	sts	0x054A, r2
    3cce:	30 92 4b 05 	sts	0x054B, r3
    3cd2:	40 92 4c 05 	sts	0x054C, r4
    3cd6:	50 92 4d 05 	sts	0x054D, r5
			
			
			
			
			if ((Config.BoardOrientationMode==QuadFlyingMode_PLUS) && (Config.QuadFlyingMode==QuadFlyingMode_X))
    3cda:	80 91 d9 06 	lds	r24, 0x06D9
    3cde:	88 23       	and	r24, r24
    3ce0:	09 f0       	breq	.+2      	; 0x3ce4 <IMU+0x6ae>
    3ce2:	9d c0       	rjmp	.+314    	; 0x3e1e <IMU+0x7e8>
    3ce4:	90 91 da 06 	lds	r25, 0x06DA
    3ce8:	91 30       	cpi	r25, 0x01	; 1
    3cea:	09 f0       	breq	.+2      	; 0x3cee <IMU+0x6b8>
    3cec:	98 c0       	rjmp	.+304    	; 0x3e1e <IMU+0x7e8>
			{
				if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    3cee:	80 91 d8 06 	lds	r24, 0x06D8
    3cf2:	60 91 c0 05 	lds	r22, 0x05C0
    3cf6:	70 91 c1 05 	lds	r23, 0x05C1
    3cfa:	c0 90 c2 05 	lds	r12, 0x05C2
    3cfe:	d0 90 c3 05 	lds	r13, 0x05C3
    3d02:	81 30       	cpi	r24, 0x01	; 1
    3d04:	09 f0       	breq	.+2      	; 0x3d08 <IMU+0x6d2>
    3d06:	48 c0       	rjmp	.+144    	; 0x3d98 <IMU+0x762>
				{	
					NavY += ( -  (double)((float)RX_Snapshot[RXChannel_AIL]  / 2.0f));
    3d08:	88 27       	eor	r24, r24
    3d0a:	77 fd       	sbrc	r23, 7
    3d0c:	80 95       	com	r24
    3d0e:	98 2f       	mov	r25, r24
    3d10:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    3d14:	20 e0       	ldi	r18, 0x00	; 0
    3d16:	30 e0       	ldi	r19, 0x00	; 0
    3d18:	40 e0       	ldi	r20, 0x00	; 0
    3d1a:	5f e3       	ldi	r21, 0x3F	; 63
    3d1c:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    3d20:	a6 2e       	mov	r10, r22
    3d22:	97 2e       	mov	r9, r23
    3d24:	88 2e       	mov	r8, r24
    3d26:	79 2e       	mov	r7, r25
					NavY += ( -  (double)((float)RX_Snapshot[RXChannel_ELE]  / 2.0f));	
    3d28:	b6 01       	movw	r22, r12
    3d2a:	88 27       	eor	r24, r24
    3d2c:	77 fd       	sbrc	r23, 7
    3d2e:	80 95       	com	r24
    3d30:	98 2f       	mov	r25, r24
    3d32:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    3d36:	20 e0       	ldi	r18, 0x00	; 0
    3d38:	30 e0       	ldi	r19, 0x00	; 0
    3d3a:	40 e0       	ldi	r20, 0x00	; 0
    3d3c:	5f e3       	ldi	r21, 0x3F	; 63
    3d3e:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    3d42:	d6 2e       	mov	r13, r22
    3d44:	c7 2e       	mov	r12, r23
    3d46:	b8 2e       	mov	r11, r24
    3d48:	69 2e       	mov	r6, r25
			
			if ((Config.BoardOrientationMode==QuadFlyingMode_PLUS) && (Config.QuadFlyingMode==QuadFlyingMode_X))
			{
				if (Config.FrameType == FRAMETYPE_QUADCOPTER)
				{	
					NavY += ( -  (double)((float)RX_Snapshot[RXChannel_AIL]  / 2.0f));
    3d4a:	c8 01       	movw	r24, r16
    3d4c:	b7 01       	movw	r22, r14
    3d4e:	2a 2d       	mov	r18, r10
    3d50:	39 2d       	mov	r19, r9
    3d52:	48 2d       	mov	r20, r8
    3d54:	57 2d       	mov	r21, r7
    3d56:	0e 94 24 38 	call	0x7048	; 0x7048 <__subsf3>
					NavY += ( -  (double)((float)RX_Snapshot[RXChannel_ELE]  / 2.0f));	
    3d5a:	d6 01       	movw	r26, r12
    3d5c:	2b 2f       	mov	r18, r27
    3d5e:	3a 2f       	mov	r19, r26
    3d60:	4b 2d       	mov	r20, r11
    3d62:	56 2d       	mov	r21, r6
    3d64:	0e 94 24 38 	call	0x7048	; 0x7048 <__subsf3>
    3d68:	60 93 00 06 	sts	0x0600, r22
    3d6c:	70 93 01 06 	sts	0x0601, r23
    3d70:	80 93 02 06 	sts	0x0602, r24
    3d74:	90 93 03 06 	sts	0x0603, r25
					NavX += ( -  (double)((float)RX_Snapshot[RXChannel_AIL]  / 2.0f));
    3d78:	c2 01       	movw	r24, r4
    3d7a:	b1 01       	movw	r22, r2
    3d7c:	2a 2d       	mov	r18, r10
    3d7e:	39 2d       	mov	r19, r9
    3d80:	48 2d       	mov	r20, r8
    3d82:	57 2d       	mov	r21, r7
    3d84:	0e 94 24 38 	call	0x7048	; 0x7048 <__subsf3>
					NavX += ( +  (double)((float)RX_Snapshot[RXChannel_ELE]  / 2.0f));	
    3d88:	d6 01       	movw	r26, r12
    3d8a:	2b 2f       	mov	r18, r27
    3d8c:	3a 2f       	mov	r19, r26
    3d8e:	4b 2d       	mov	r20, r11
    3d90:	56 2d       	mov	r21, r6
    3d92:	0e 94 25 38 	call	0x704a	; 0x704a <__addsf3>
    3d96:	d4 c0       	rjmp	.+424    	; 0x3f40 <IMU+0x90a>
				}
				else
				{
					NavY += ( +  (double)((float)RX_Snapshot[RXChannel_AIL]  / 2.0f));
    3d98:	88 27       	eor	r24, r24
    3d9a:	77 fd       	sbrc	r23, 7
    3d9c:	80 95       	com	r24
    3d9e:	98 2f       	mov	r25, r24
    3da0:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    3da4:	20 e0       	ldi	r18, 0x00	; 0
    3da6:	30 e0       	ldi	r19, 0x00	; 0
    3da8:	40 e0       	ldi	r20, 0x00	; 0
    3daa:	5f e3       	ldi	r21, 0x3F	; 63
    3dac:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    3db0:	a6 2e       	mov	r10, r22
    3db2:	97 2e       	mov	r9, r23
    3db4:	88 2e       	mov	r8, r24
    3db6:	79 2e       	mov	r7, r25
					NavY += ( +  (double)((float)RX_Snapshot[RXChannel_ELE]  / 2.0f));	
    3db8:	b6 01       	movw	r22, r12
    3dba:	88 27       	eor	r24, r24
    3dbc:	77 fd       	sbrc	r23, 7
    3dbe:	80 95       	com	r24
    3dc0:	98 2f       	mov	r25, r24
    3dc2:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    3dc6:	20 e0       	ldi	r18, 0x00	; 0
    3dc8:	30 e0       	ldi	r19, 0x00	; 0
    3dca:	40 e0       	ldi	r20, 0x00	; 0
    3dcc:	5f e3       	ldi	r21, 0x3F	; 63
    3dce:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    3dd2:	d6 2e       	mov	r13, r22
    3dd4:	c7 2e       	mov	r12, r23
    3dd6:	b8 2e       	mov	r11, r24
    3dd8:	69 2e       	mov	r6, r25
					NavX += ( -  (double)((float)RX_Snapshot[RXChannel_AIL]  / 2.0f));
					NavX += ( +  (double)((float)RX_Snapshot[RXChannel_ELE]  / 2.0f));	
				}
				else
				{
					NavY += ( +  (double)((float)RX_Snapshot[RXChannel_AIL]  / 2.0f));
    3dda:	c8 01       	movw	r24, r16
    3ddc:	b7 01       	movw	r22, r14
    3dde:	2a 2d       	mov	r18, r10
    3de0:	39 2d       	mov	r19, r9
    3de2:	48 2d       	mov	r20, r8
    3de4:	57 2d       	mov	r21, r7
    3de6:	0e 94 25 38 	call	0x704a	; 0x704a <__addsf3>
					NavY += ( +  (double)((float)RX_Snapshot[RXChannel_ELE]  / 2.0f));	
    3dea:	d6 01       	movw	r26, r12
    3dec:	2b 2f       	mov	r18, r27
    3dee:	3a 2f       	mov	r19, r26
    3df0:	4b 2d       	mov	r20, r11
    3df2:	56 2d       	mov	r21, r6
    3df4:	0e 94 25 38 	call	0x704a	; 0x704a <__addsf3>
    3df8:	60 93 00 06 	sts	0x0600, r22
    3dfc:	70 93 01 06 	sts	0x0601, r23
    3e00:	80 93 02 06 	sts	0x0602, r24
    3e04:	90 93 03 06 	sts	0x0603, r25
					NavX += ( +  (double)((float)RX_Snapshot[RXChannel_AIL]  / 2.0f));
    3e08:	c2 01       	movw	r24, r4
    3e0a:	b1 01       	movw	r22, r2
    3e0c:	2a 2d       	mov	r18, r10
    3e0e:	39 2d       	mov	r19, r9
    3e10:	48 2d       	mov	r20, r8
    3e12:	57 2d       	mov	r21, r7
    3e14:	0e 94 25 38 	call	0x704a	; 0x704a <__addsf3>
					NavX += ( -  (double)((float)RX_Snapshot[RXChannel_ELE]  / 2.0f));	
    3e18:	d6 01       	movw	r26, r12
    3e1a:	fb 2d       	mov	r31, r11
    3e1c:	8b c0       	rjmp	.+278    	; 0x3f34 <IMU+0x8fe>
			{
				NavY += ( -  (double)((float)RX_Snapshot[RXChannel_ELE] / 2.0f));	
				NavX += ( -  (double)((float)RX_Snapshot[RXChannel_AIL] / 2.0f));
			}
			*/
			else if (Config.BoardOrientationMode==Config.QuadFlyingMode)  // ver 0.9.9 code optimization
    3e1e:	90 91 da 06 	lds	r25, 0x06DA
    3e22:	89 17       	cp	r24, r25
    3e24:	99 f5       	brne	.+102    	; 0x3e8c <IMU+0x856>
			{ 
				NavY += ( -  (double)((float)RX_Snapshot[RXChannel_ELE] / 2.0f));	
    3e26:	60 91 c2 05 	lds	r22, 0x05C2
    3e2a:	70 91 c3 05 	lds	r23, 0x05C3
    3e2e:	88 27       	eor	r24, r24
    3e30:	77 fd       	sbrc	r23, 7
    3e32:	80 95       	com	r24
    3e34:	98 2f       	mov	r25, r24
    3e36:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    3e3a:	20 e0       	ldi	r18, 0x00	; 0
    3e3c:	30 e0       	ldi	r19, 0x00	; 0
    3e3e:	40 e0       	ldi	r20, 0x00	; 0
    3e40:	5f e3       	ldi	r21, 0x3F	; 63
    3e42:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    3e46:	9b 01       	movw	r18, r22
    3e48:	ac 01       	movw	r20, r24
    3e4a:	c8 01       	movw	r24, r16
    3e4c:	b7 01       	movw	r22, r14
    3e4e:	0e 94 24 38 	call	0x7048	; 0x7048 <__subsf3>
    3e52:	60 93 00 06 	sts	0x0600, r22
    3e56:	70 93 01 06 	sts	0x0601, r23
    3e5a:	80 93 02 06 	sts	0x0602, r24
    3e5e:	90 93 03 06 	sts	0x0603, r25
				NavX += ( -  (double)((float)RX_Snapshot[RXChannel_AIL] / 2.0f));
    3e62:	60 91 c0 05 	lds	r22, 0x05C0
    3e66:	70 91 c1 05 	lds	r23, 0x05C1
    3e6a:	88 27       	eor	r24, r24
    3e6c:	77 fd       	sbrc	r23, 7
    3e6e:	80 95       	com	r24
    3e70:	98 2f       	mov	r25, r24
    3e72:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    3e76:	20 e0       	ldi	r18, 0x00	; 0
    3e78:	30 e0       	ldi	r19, 0x00	; 0
    3e7a:	40 e0       	ldi	r20, 0x00	; 0
    3e7c:	5f e3       	ldi	r21, 0x3F	; 63
    3e7e:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    3e82:	9b 01       	movw	r18, r22
    3e84:	ac 01       	movw	r20, r24
    3e86:	c2 01       	movw	r24, r4
    3e88:	b1 01       	movw	r22, r2
    3e8a:	58 c0       	rjmp	.+176    	; 0x3f3c <IMU+0x906>
			}
			else if ((Config.BoardOrientationMode==QuadFlyingMode_X) && (Config.QuadFlyingMode==QuadFlyingMode_PLUS))
    3e8c:	81 30       	cpi	r24, 0x01	; 1
    3e8e:	09 f0       	breq	.+2      	; 0x3e92 <IMU+0x85c>
    3e90:	5f c0       	rjmp	.+190    	; 0x3f50 <IMU+0x91a>
    3e92:	99 23       	and	r25, r25
    3e94:	09 f0       	breq	.+2      	; 0x3e98 <IMU+0x862>
    3e96:	5c c0       	rjmp	.+184    	; 0x3f50 <IMU+0x91a>
			{ 
				NavY += ( +  (double)((float)RX_Snapshot[RXChannel_AIL]  / 2.0f));
    3e98:	60 91 c0 05 	lds	r22, 0x05C0
    3e9c:	70 91 c1 05 	lds	r23, 0x05C1
    3ea0:	88 27       	eor	r24, r24
    3ea2:	77 fd       	sbrc	r23, 7
    3ea4:	80 95       	com	r24
    3ea6:	98 2f       	mov	r25, r24
    3ea8:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    3eac:	20 e0       	ldi	r18, 0x00	; 0
    3eae:	30 e0       	ldi	r19, 0x00	; 0
    3eb0:	40 e0       	ldi	r20, 0x00	; 0
    3eb2:	5f e3       	ldi	r21, 0x3F	; 63
    3eb4:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    3eb8:	d6 2e       	mov	r13, r22
    3eba:	c7 2e       	mov	r12, r23
    3ebc:	b8 2e       	mov	r11, r24
    3ebe:	a9 2e       	mov	r10, r25
				NavY += ( -  (double)((float)RX_Snapshot[RXChannel_ELE]  / 2.0f));	
    3ec0:	60 91 c2 05 	lds	r22, 0x05C2
    3ec4:	70 91 c3 05 	lds	r23, 0x05C3
    3ec8:	88 27       	eor	r24, r24
    3eca:	77 fd       	sbrc	r23, 7
    3ecc:	80 95       	com	r24
    3ece:	98 2f       	mov	r25, r24
    3ed0:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    3ed4:	20 e0       	ldi	r18, 0x00	; 0
    3ed6:	30 e0       	ldi	r19, 0x00	; 0
    3ed8:	40 e0       	ldi	r20, 0x00	; 0
    3eda:	5f e3       	ldi	r21, 0x3F	; 63
    3edc:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    3ee0:	96 2e       	mov	r9, r22
    3ee2:	87 2e       	mov	r8, r23
    3ee4:	78 2e       	mov	r7, r24
    3ee6:	69 2e       	mov	r6, r25
				NavY += ( -  (double)((float)RX_Snapshot[RXChannel_ELE] / 2.0f));	
				NavX += ( -  (double)((float)RX_Snapshot[RXChannel_AIL] / 2.0f));
			}
			else if ((Config.BoardOrientationMode==QuadFlyingMode_X) && (Config.QuadFlyingMode==QuadFlyingMode_PLUS))
			{ 
				NavY += ( +  (double)((float)RX_Snapshot[RXChannel_AIL]  / 2.0f));
    3ee8:	c8 01       	movw	r24, r16
    3eea:	b7 01       	movw	r22, r14
    3eec:	d6 01       	movw	r26, r12
    3eee:	f5 01       	movw	r30, r10
    3ef0:	2b 2f       	mov	r18, r27
    3ef2:	3a 2f       	mov	r19, r26
    3ef4:	4f 2f       	mov	r20, r31
    3ef6:	5e 2f       	mov	r21, r30
    3ef8:	0e 94 25 38 	call	0x704a	; 0x704a <__addsf3>
				NavY += ( -  (double)((float)RX_Snapshot[RXChannel_ELE]  / 2.0f));	
    3efc:	d4 01       	movw	r26, r8
    3efe:	f3 01       	movw	r30, r6
    3f00:	2b 2f       	mov	r18, r27
    3f02:	3a 2f       	mov	r19, r26
    3f04:	4f 2f       	mov	r20, r31
    3f06:	5e 2f       	mov	r21, r30
    3f08:	0e 94 24 38 	call	0x7048	; 0x7048 <__subsf3>
    3f0c:	60 93 00 06 	sts	0x0600, r22
    3f10:	70 93 01 06 	sts	0x0601, r23
    3f14:	80 93 02 06 	sts	0x0602, r24
    3f18:	90 93 03 06 	sts	0x0603, r25
				NavX += ( -  (double)((float)RX_Snapshot[RXChannel_AIL]  / 2.0f));
    3f1c:	c2 01       	movw	r24, r4
    3f1e:	b1 01       	movw	r22, r2
    3f20:	d6 01       	movw	r26, r12
    3f22:	f5 01       	movw	r30, r10
    3f24:	2b 2f       	mov	r18, r27
    3f26:	3a 2f       	mov	r19, r26
    3f28:	4f 2f       	mov	r20, r31
    3f2a:	5e 2f       	mov	r21, r30
    3f2c:	0e 94 24 38 	call	0x7048	; 0x7048 <__subsf3>
				NavX += ( -  (double)((float)RX_Snapshot[RXChannel_ELE]  / 2.0f));	
    3f30:	d4 01       	movw	r26, r8
    3f32:	f7 2d       	mov	r31, r7
    3f34:	2b 2f       	mov	r18, r27
    3f36:	3a 2f       	mov	r19, r26
    3f38:	4f 2f       	mov	r20, r31
    3f3a:	56 2d       	mov	r21, r6
    3f3c:	0e 94 24 38 	call	0x7048	; 0x7048 <__subsf3>
    3f40:	60 93 4a 05 	sts	0x054A, r22
    3f44:	70 93 4b 05 	sts	0x054B, r23
    3f48:	80 93 4c 05 	sts	0x054C, r24
    3f4c:	90 93 4d 05 	sts	0x054D, r25
			}
				
		if (IS_FLYINGMODE_ACRO==0)
    3f50:	80 91 1c 06 	lds	r24, 0x061C
    3f54:	80 fd       	sbrc	r24, 0
    3f56:	96 c0       	rjmp	.+300    	; 0x4084 <IMU+0xa4e>
		{
			
			gyroPitch+=	PID_Calculate_ACC (Config.AccParams[0], &PID_AccTerms[0],NavY); //AnglePitch);	
    3f58:	60 91 37 06 	lds	r22, 0x0637
    3f5c:	70 91 38 06 	lds	r23, 0x0638
    3f60:	88 27       	eor	r24, r24
    3f62:	77 fd       	sbrc	r23, 7
    3f64:	80 95       	com	r24
    3f66:	98 2f       	mov	r25, r24
    3f68:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    3f6c:	3b 01       	movw	r6, r22
    3f6e:	4c 01       	movw	r8, r24
    3f70:	00 d0       	rcall	.+0      	; 0x3f72 <IMU+0x93c>
    3f72:	00 d0       	rcall	.+0      	; 0x3f74 <IMU+0x93e>
    3f74:	80 91 00 06 	lds	r24, 0x0600
    3f78:	90 91 01 06 	lds	r25, 0x0601
    3f7c:	a0 91 02 06 	lds	r26, 0x0602
    3f80:	b0 91 03 06 	lds	r27, 0x0603
    3f84:	ed b7       	in	r30, 0x3d	; 61
    3f86:	fe b7       	in	r31, 0x3e	; 62
    3f88:	81 83       	std	Z+1, r24	; 0x01
    3f8a:	92 83       	std	Z+2, r25	; 0x02
    3f8c:	a3 83       	std	Z+3, r26	; 0x03
    3f8e:	b4 83       	std	Z+4, r27	; 0x04
    3f90:	c0 90 fb 06 	lds	r12, 0x06FB
    3f94:	d0 90 fc 06 	lds	r13, 0x06FC
    3f98:	e0 90 fd 06 	lds	r14, 0x06FD
    3f9c:	f0 90 fe 06 	lds	r15, 0x06FE
    3fa0:	00 91 ff 06 	lds	r16, 0x06FF
    3fa4:	10 91 00 07 	lds	r17, 0x0700
    3fa8:	20 91 01 07 	lds	r18, 0x0701
    3fac:	30 91 02 07 	lds	r19, 0x0702
    3fb0:	40 91 03 07 	lds	r20, 0x0703
    3fb4:	50 91 04 07 	lds	r21, 0x0704
    3fb8:	60 91 05 07 	lds	r22, 0x0705
    3fbc:	70 91 06 07 	lds	r23, 0x0706
    3fc0:	80 91 07 07 	lds	r24, 0x0707
    3fc4:	90 91 08 07 	lds	r25, 0x0708
    3fc8:	f0 e5       	ldi	r31, 0x50	; 80
    3fca:	af 2e       	mov	r10, r31
    3fcc:	f5 e0       	ldi	r31, 0x05	; 5
    3fce:	bf 2e       	mov	r11, r31
    3fd0:	0e 94 8e 18 	call	0x311c	; 0x311c <PID_Calculate_ACC>
    3fd4:	9b 01       	movw	r18, r22
    3fd6:	ac 01       	movw	r20, r24
    3fd8:	c4 01       	movw	r24, r8
    3fda:	b3 01       	movw	r22, r6
    3fdc:	0e 94 25 38 	call	0x704a	; 0x704a <__addsf3>
    3fe0:	0e 94 f5 38 	call	0x71ea	; 0x71ea <__fixsfsi>
    3fe4:	70 93 38 06 	sts	0x0638, r23
    3fe8:	60 93 37 06 	sts	0x0637, r22
			gyroRoll += PID_Calculate_ACC (Config.AccParams[0], &PID_AccTerms[1],NavX); //AngleRoll); 
    3fec:	60 91 b8 05 	lds	r22, 0x05B8
    3ff0:	70 91 b9 05 	lds	r23, 0x05B9
    3ff4:	88 27       	eor	r24, r24
    3ff6:	77 fd       	sbrc	r23, 7
    3ff8:	80 95       	com	r24
    3ffa:	98 2f       	mov	r25, r24
    3ffc:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    4000:	3b 01       	movw	r6, r22
    4002:	4c 01       	movw	r8, r24
    4004:	80 91 4a 05 	lds	r24, 0x054A
    4008:	90 91 4b 05 	lds	r25, 0x054B
    400c:	a0 91 4c 05 	lds	r26, 0x054C
    4010:	b0 91 4d 05 	lds	r27, 0x054D
    4014:	ed b7       	in	r30, 0x3d	; 61
    4016:	fe b7       	in	r31, 0x3e	; 62
    4018:	81 83       	std	Z+1, r24	; 0x01
    401a:	92 83       	std	Z+2, r25	; 0x02
    401c:	a3 83       	std	Z+3, r26	; 0x03
    401e:	b4 83       	std	Z+4, r27	; 0x04
    4020:	c0 90 fb 06 	lds	r12, 0x06FB
    4024:	d0 90 fc 06 	lds	r13, 0x06FC
    4028:	e0 90 fd 06 	lds	r14, 0x06FD
    402c:	f0 90 fe 06 	lds	r15, 0x06FE
    4030:	00 91 ff 06 	lds	r16, 0x06FF
    4034:	10 91 00 07 	lds	r17, 0x0700
    4038:	20 91 01 07 	lds	r18, 0x0701
    403c:	30 91 02 07 	lds	r19, 0x0702
    4040:	40 91 03 07 	lds	r20, 0x0703
    4044:	50 91 04 07 	lds	r21, 0x0704
    4048:	60 91 05 07 	lds	r22, 0x0705
    404c:	70 91 06 07 	lds	r23, 0x0706
    4050:	80 91 07 07 	lds	r24, 0x0707
    4054:	90 91 08 07 	lds	r25, 0x0708
    4058:	e8 e6       	ldi	r30, 0x68	; 104
    405a:	ae 2e       	mov	r10, r30
    405c:	e5 e0       	ldi	r30, 0x05	; 5
    405e:	be 2e       	mov	r11, r30
    4060:	0e 94 8e 18 	call	0x311c	; 0x311c <PID_Calculate_ACC>
    4064:	9b 01       	movw	r18, r22
    4066:	ac 01       	movw	r20, r24
    4068:	c4 01       	movw	r24, r8
    406a:	b3 01       	movw	r22, r6
    406c:	0e 94 25 38 	call	0x704a	; 0x704a <__addsf3>
    4070:	0e 94 f5 38 	call	0x71ea	; 0x71ea <__fixsfsi>
    4074:	70 93 b9 05 	sts	0x05B9, r23
    4078:	60 93 b8 05 	sts	0x05B8, r22
    407c:	0f 90       	pop	r0
    407e:	0f 90       	pop	r0
    4080:	0f 90       	pop	r0
    4082:	0f 90       	pop	r0
		 
		}
		
	
}
    4084:	26 96       	adiw	r28, 0x06	; 6
    4086:	0f b6       	in	r0, 0x3f	; 63
    4088:	f8 94       	cli
    408a:	de bf       	out	0x3e, r29	; 62
    408c:	0f be       	out	0x3f, r0	; 63
    408e:	cd bf       	out	0x3d, r28	; 61
    4090:	cf 91       	pop	r28
    4092:	df 91       	pop	r29
    4094:	1f 91       	pop	r17
    4096:	0f 91       	pop	r16
    4098:	ff 90       	pop	r15
    409a:	ef 90       	pop	r14
    409c:	df 90       	pop	r13
    409e:	cf 90       	pop	r12
    40a0:	bf 90       	pop	r11
    40a2:	af 90       	pop	r10
    40a4:	9f 90       	pop	r9
    40a6:	8f 90       	pop	r8
    40a8:	7f 90       	pop	r7
    40aa:	6f 90       	pop	r6
    40ac:	5f 90       	pop	r5
    40ae:	4f 90       	pop	r4
    40b0:	3f 90       	pop	r3
    40b2:	2f 90       	pop	r2
    40b4:	08 95       	ret

000040b6 <IMU_HeightKeeping>:

	

	
double IMU_HeightKeeping ()
{
    40b6:	af 92       	push	r10
    40b8:	bf 92       	push	r11
    40ba:	cf 92       	push	r12
    40bc:	df 92       	push	r13
    40be:	ef 92       	push	r14
    40c0:	ff 92       	push	r15
    40c2:	0f 93       	push	r16
    40c4:	1f 93       	push	r17
	double Temp;
//	ThrottleTemp = RX_Snapshot[RXChannel_THR];
	
	// calculate damping
	
	Landing = PID_Calculate (Config.AccParams[1], &PID_AccTerms[2],-CompAccZ) ;
    40c6:	00 d0       	rcall	.+0      	; 0x40c8 <IMU_HeightKeeping+0x12>
    40c8:	00 d0       	rcall	.+0      	; 0x40ca <IMU_HeightKeeping+0x14>
    40ca:	80 91 39 06 	lds	r24, 0x0639
    40ce:	90 91 3a 06 	lds	r25, 0x063A
    40d2:	a0 91 3b 06 	lds	r26, 0x063B
    40d6:	b0 91 3c 06 	lds	r27, 0x063C
    40da:	b0 58       	subi	r27, 0x80	; 128
    40dc:	ed b7       	in	r30, 0x3d	; 61
    40de:	fe b7       	in	r31, 0x3e	; 62
    40e0:	81 83       	std	Z+1, r24	; 0x01
    40e2:	92 83       	std	Z+2, r25	; 0x02
    40e4:	a3 83       	std	Z+3, r26	; 0x03
    40e6:	b4 83       	std	Z+4, r27	; 0x04
    40e8:	c0 90 09 07 	lds	r12, 0x0709
    40ec:	d0 90 0a 07 	lds	r13, 0x070A
    40f0:	e0 90 0b 07 	lds	r14, 0x070B
    40f4:	f0 90 0c 07 	lds	r15, 0x070C
    40f8:	00 91 0d 07 	lds	r16, 0x070D
    40fc:	10 91 0e 07 	lds	r17, 0x070E
    4100:	20 91 0f 07 	lds	r18, 0x070F
    4104:	30 91 10 07 	lds	r19, 0x0710
    4108:	40 91 11 07 	lds	r20, 0x0711
    410c:	50 91 12 07 	lds	r21, 0x0712
    4110:	60 91 13 07 	lds	r22, 0x0713
    4114:	70 91 14 07 	lds	r23, 0x0714
    4118:	80 91 15 07 	lds	r24, 0x0715
    411c:	90 91 16 07 	lds	r25, 0x0716
    4120:	a0 e8       	ldi	r26, 0x80	; 128
    4122:	aa 2e       	mov	r10, r26
    4124:	a5 e0       	ldi	r26, 0x05	; 5
    4126:	ba 2e       	mov	r11, r26
    4128:	0e 94 d9 19 	call	0x33b2	; 0x33b2 <PID_Calculate>
    412c:	60 93 58 06 	sts	0x0658, r22
    4130:	70 93 59 06 	sts	0x0659, r23
    4134:	80 93 5a 06 	sts	0x065A, r24
    4138:	90 93 5b 06 	sts	0x065B, r25
			
			
	// Calculate Altitude Hold
	if ((Config.RX_mode==RX_mode_UARTMode) && (IS_MISC_SENSOR_SONAR_ENABLED==true) && (nFlyingModes == FLYINGMODE_ALTHOLD))
    413c:	0f 90       	pop	r0
    413e:	0f 90       	pop	r0
    4140:	0f 90       	pop	r0
    4142:	0f 90       	pop	r0
    4144:	80 91 d3 06 	lds	r24, 0x06D3
    4148:	8f 3f       	cpi	r24, 0xFF	; 255
    414a:	09 f0       	breq	.+2      	; 0x414e <IMU_HeightKeeping+0x98>
    414c:	f4 c0       	rjmp	.+488    	; 0x4336 <IMU_HeightKeeping+0x280>
    414e:	80 91 de 06 	lds	r24, 0x06DE
    4152:	80 ff       	sbrs	r24, 0
    4154:	f0 c0       	rjmp	.+480    	; 0x4336 <IMU_HeightKeeping+0x280>
    4156:	80 91 1c 06 	lds	r24, 0x061C
    415a:	84 30       	cpi	r24, 0x04	; 4
    415c:	09 f0       	breq	.+2      	; 0x4160 <IMU_HeightKeeping+0xaa>
    415e:	eb c0       	rjmp	.+470    	; 0x4336 <IMU_HeightKeeping+0x280>
	{
		RX_SONAR_TRIGGER = HIGH;
    4160:	48 9a       	sbi	0x09, 0	; 9
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    4162:	f8 94       	cli
		ATOMIC_BLOCK(ATOMIC_FORCEON)
		{	
			Temp = RX_SONAR_RAW; 
    4164:	60 91 d2 05 	lds	r22, 0x05D2
    4168:	70 91 d3 05 	lds	r23, 0x05D3
    416c:	80 e0       	ldi	r24, 0x00	; 0
    416e:	90 e0       	ldi	r25, 0x00	; 0
    4170:	0e 94 26 39 	call	0x724c	; 0x724c <__floatunsisf>
    4174:	7b 01       	movw	r14, r22
    4176:	8c 01       	movw	r16, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    4178:	78 94       	sei
		}
	
		if (Temp < 550) // if SONAR Reading is VALID - not BEYOND maximum range
    417a:	7f 2d       	mov	r23, r15
    417c:	91 2f       	mov	r25, r17
    417e:	20 e0       	ldi	r18, 0x00	; 0
    4180:	30 e8       	ldi	r19, 0x80	; 128
    4182:	49 e0       	ldi	r20, 0x09	; 9
    4184:	54 e4       	ldi	r21, 0x44	; 68
    4186:	0e 94 89 38 	call	0x7112	; 0x7112 <__cmpsf2>
    418a:	87 ff       	sbrs	r24, 7
    418c:	b4 c0       	rjmp	.+360    	; 0x42f6 <IMU_HeightKeeping+0x240>
		{
			
			if ((bALTHOLD == false))
    418e:	80 91 27 05 	lds	r24, 0x0527
    4192:	88 23       	and	r24, r24
    4194:	29 f5       	brne	.+74     	; 0x41e0 <IMU_HeightKeeping+0x12a>
			{   
				if (ThrottleTemp<3)
    4196:	80 91 25 05 	lds	r24, 0x0525
    419a:	90 91 26 05 	lds	r25, 0x0526
    419e:	83 30       	cpi	r24, 0x03	; 3
    41a0:	91 05       	cpc	r25, r1
    41a2:	34 f4       	brge	.+12     	; 0x41b0 <IMU_HeightKeeping+0xfa>
				{ // current altitude is the old one
					ThrottleTemp+=1;
    41a4:	01 96       	adiw	r24, 0x01	; 1
    41a6:	90 93 26 05 	sts	0x0526, r25
    41aa:	80 93 25 05 	sts	0x0525, r24
    41ae:	c9 c0       	rjmp	.+402    	; 0x4342 <IMU_HeightKeeping+0x28c>
					return Landing ;
				}
				// first time to switch to ALTHOLD
				LastAltitudeHold = Temp; // measure Altitude
    41b0:	6e 2d       	mov	r22, r14
    41b2:	7f 2d       	mov	r23, r15
    41b4:	80 2f       	mov	r24, r16
    41b6:	91 2f       	mov	r25, r17
    41b8:	0e 94 fa 38 	call	0x71f4	; 0x71f4 <__fixunssfsi>
    41bc:	70 93 c9 06 	sts	0x06C9, r23
    41c0:	60 93 c8 06 	sts	0x06C8, r22
				PID_SonarTerms[0].I=0;   // ZERO I
    41c4:	80 e0       	ldi	r24, 0x00	; 0
    41c6:	90 e0       	ldi	r25, 0x00	; 0
    41c8:	dc 01       	movw	r26, r24
    41ca:	80 93 71 07 	sts	0x0771, r24
    41ce:	90 93 72 07 	sts	0x0772, r25
    41d2:	a0 93 73 07 	sts	0x0773, r26
    41d6:	b0 93 74 07 	sts	0x0774, r27
				bALTHOLD = true;
    41da:	81 e0       	ldi	r24, 0x01	; 1
    41dc:	80 93 27 05 	sts	0x0527, r24
			}
			
			AltDiff = LastAltitudeHold - Temp;
    41e0:	60 91 c8 06 	lds	r22, 0x06C8
    41e4:	70 91 c9 06 	lds	r23, 0x06C9
    41e8:	80 e0       	ldi	r24, 0x00	; 0
    41ea:	90 e0       	ldi	r25, 0x00	; 0
    41ec:	0e 94 26 39 	call	0x724c	; 0x724c <__floatunsisf>
    41f0:	2e 2d       	mov	r18, r14
    41f2:	3f 2d       	mov	r19, r15
    41f4:	40 2f       	mov	r20, r16
    41f6:	51 2f       	mov	r21, r17
    41f8:	0e 94 24 38 	call	0x7048	; 0x7048 <__subsf3>
    41fc:	f6 2e       	mov	r15, r22
    41fe:	07 2f       	mov	r16, r23
    4200:	18 2f       	mov	r17, r24
    4202:	e9 2e       	mov	r14, r25
    4204:	86 2f       	mov	r24, r22
    4206:	90 2f       	mov	r25, r16
    4208:	a1 2f       	mov	r26, r17
    420a:	be 2d       	mov	r27, r14
    420c:	80 93 ac 06 	sts	0x06AC, r24
    4210:	90 93 ad 06 	sts	0x06AD, r25
    4214:	a0 93 ae 06 	sts	0x06AE, r26
    4218:	b0 93 af 06 	sts	0x06AF, r27
			if ((AltDiff<50) && (AltDiff>-50)) // no sudden change or false read
    421c:	6f 2d       	mov	r22, r15
    421e:	70 2f       	mov	r23, r16
    4220:	81 2f       	mov	r24, r17
    4222:	9e 2d       	mov	r25, r14
    4224:	20 e0       	ldi	r18, 0x00	; 0
    4226:	30 e0       	ldi	r19, 0x00	; 0
    4228:	48 e4       	ldi	r20, 0x48	; 72
    422a:	52 e4       	ldi	r21, 0x42	; 66
    422c:	0e 94 89 38 	call	0x7112	; 0x7112 <__cmpsf2>
    4230:	87 ff       	sbrs	r24, 7
    4232:	5c c0       	rjmp	.+184    	; 0x42ec <IMU_HeightKeeping+0x236>
    4234:	6f 2d       	mov	r22, r15
    4236:	70 2f       	mov	r23, r16
    4238:	81 2f       	mov	r24, r17
    423a:	9e 2d       	mov	r25, r14
    423c:	20 e0       	ldi	r18, 0x00	; 0
    423e:	30 e0       	ldi	r19, 0x00	; 0
    4240:	48 e4       	ldi	r20, 0x48	; 72
    4242:	52 ec       	ldi	r21, 0xC2	; 194
    4244:	0e 94 d8 39 	call	0x73b0	; 0x73b0 <__gesf2>
    4248:	18 16       	cp	r1, r24
    424a:	0c f0       	brlt	.+2      	; 0x424e <IMU_HeightKeeping+0x198>
    424c:	4f c0       	rjmp	.+158    	; 0x42ec <IMU_HeightKeeping+0x236>
			{
				IgnoreTimeOut=0;
    424e:	10 92 22 05 	sts	0x0522, r1
				ThrottleTemp = PID_Calculate (Config.SonarParams[0], &PID_SonarTerms[0],AltDiff) ;	
    4252:	00 d0       	rcall	.+0      	; 0x4254 <IMU_HeightKeeping+0x19e>
    4254:	00 d0       	rcall	.+0      	; 0x4256 <IMU_HeightKeeping+0x1a0>
    4256:	8f 2d       	mov	r24, r15
    4258:	90 2f       	mov	r25, r16
    425a:	a1 2f       	mov	r26, r17
    425c:	be 2d       	mov	r27, r14
    425e:	ed b7       	in	r30, 0x3d	; 61
    4260:	fe b7       	in	r31, 0x3e	; 62
    4262:	81 83       	std	Z+1, r24	; 0x01
    4264:	92 83       	std	Z+2, r25	; 0x02
    4266:	a3 83       	std	Z+3, r26	; 0x03
    4268:	b4 83       	std	Z+4, r27	; 0x04
    426a:	c0 90 17 07 	lds	r12, 0x0717
    426e:	d0 90 18 07 	lds	r13, 0x0718
    4272:	e0 90 19 07 	lds	r14, 0x0719
    4276:	f0 90 1a 07 	lds	r15, 0x071A
    427a:	00 91 1b 07 	lds	r16, 0x071B
    427e:	10 91 1c 07 	lds	r17, 0x071C
    4282:	20 91 1d 07 	lds	r18, 0x071D
    4286:	30 91 1e 07 	lds	r19, 0x071E
    428a:	40 91 1f 07 	lds	r20, 0x071F
    428e:	50 91 20 07 	lds	r21, 0x0720
    4292:	60 91 21 07 	lds	r22, 0x0721
    4296:	70 91 22 07 	lds	r23, 0x0722
    429a:	80 91 23 07 	lds	r24, 0x0723
    429e:	90 91 24 07 	lds	r25, 0x0724
    42a2:	fd e6       	ldi	r31, 0x6D	; 109
    42a4:	af 2e       	mov	r10, r31
    42a6:	f7 e0       	ldi	r31, 0x07	; 7
    42a8:	bf 2e       	mov	r11, r31
    42aa:	0e 94 d9 19 	call	0x33b2	; 0x33b2 <PID_Calculate>
    42ae:	0e 94 f5 38 	call	0x71ea	; 0x71ea <__fixsfsi>
    42b2:	7b 01       	movw	r14, r22
    42b4:	8c 01       	movw	r16, r24
    42b6:	70 93 26 05 	sts	0x0526, r23
    42ba:	60 93 25 05 	sts	0x0525, r22
				if (AltDiff==0) 
    42be:	0f 90       	pop	r0
    42c0:	0f 90       	pop	r0
    42c2:	0f 90       	pop	r0
    42c4:	0f 90       	pop	r0
    42c6:	60 91 ac 06 	lds	r22, 0x06AC
    42ca:	70 91 ad 06 	lds	r23, 0x06AD
    42ce:	80 91 ae 06 	lds	r24, 0x06AE
    42d2:	90 91 af 06 	lds	r25, 0x06AF
    42d6:	20 e0       	ldi	r18, 0x00	; 0
    42d8:	30 e0       	ldi	r19, 0x00	; 0
    42da:	a9 01       	movw	r20, r18
    42dc:	0e 94 89 38 	call	0x7112	; 0x7112 <__cmpsf2>
    42e0:	88 23       	and	r24, r24
    42e2:	21 f4       	brne	.+8      	; 0x42ec <IMU_HeightKeeping+0x236>
				{
					ThrottleZERO = ThrottleTemp;
    42e4:	f0 92 24 05 	sts	0x0524, r15
    42e8:	e0 92 23 05 	sts	0x0523, r14
					//}						
				//
				//}
				
							
			Landing += ThrottleTemp;
    42ec:	60 91 25 05 	lds	r22, 0x0525
    42f0:	70 91 26 05 	lds	r23, 0x0526
    42f4:	04 c0       	rjmp	.+8      	; 0x42fe <IMU_HeightKeeping+0x248>
		}
		else
		{
			Landing += ThrottleZERO;
    42f6:	60 91 23 05 	lds	r22, 0x0523
    42fa:	70 91 24 05 	lds	r23, 0x0524
    42fe:	88 27       	eor	r24, r24
    4300:	77 fd       	sbrc	r23, 7
    4302:	80 95       	com	r24
    4304:	98 2f       	mov	r25, r24
    4306:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    430a:	9b 01       	movw	r18, r22
    430c:	ac 01       	movw	r20, r24
    430e:	60 91 58 06 	lds	r22, 0x0658
    4312:	70 91 59 06 	lds	r23, 0x0659
    4316:	80 91 5a 06 	lds	r24, 0x065A
    431a:	90 91 5b 06 	lds	r25, 0x065B
    431e:	0e 94 25 38 	call	0x704a	; 0x704a <__addsf3>
    4322:	60 93 58 06 	sts	0x0658, r22
    4326:	70 93 59 06 	sts	0x0659, r23
    432a:	80 93 5a 06 	sts	0x065A, r24
    432e:	90 93 5b 06 	sts	0x065B, r25
		}
		
		RX_SONAR_TRIGGER = LOW;
    4332:	48 98       	cbi	0x09, 0	; 9
    4334:	06 c0       	rjmp	.+12     	; 0x4342 <IMU_HeightKeeping+0x28c>
	}
	else
	{
			ThrottleTemp=0;
    4336:	10 92 26 05 	sts	0x0526, r1
    433a:	10 92 25 05 	sts	0x0525, r1
			bALTHOLD=false;
    433e:	10 92 27 05 	sts	0x0527, r1
	}
	
	
	
	
	return Landing;
    4342:	70 91 58 06 	lds	r23, 0x0658
    4346:	60 91 59 06 	lds	r22, 0x0659
    434a:	90 91 5a 06 	lds	r25, 0x065A
    434e:	80 91 5b 06 	lds	r24, 0x065B
    4352:	ab 01       	movw	r20, r22
    4354:	9c 01       	movw	r18, r24
    4356:	65 2f       	mov	r22, r21
    4358:	74 2f       	mov	r23, r20
    435a:	83 2f       	mov	r24, r19
    435c:	92 2f       	mov	r25, r18
    435e:	1f 91       	pop	r17
    4360:	0f 91       	pop	r16
    4362:	ff 90       	pop	r15
    4364:	ef 90       	pop	r14
    4366:	df 90       	pop	r13
    4368:	cf 90       	pop	r12
    436a:	bf 90       	pop	r11
    436c:	af 90       	pop	r10
    436e:	08 95       	ret

00004370 <arctan2>:
  //}
  //z *= (180.0f / PI * 10); 
  //return z;
//}

int arctan2(int y, int x) {                                    // http://www.dspguru.com/comp.dsp/tricks/alg/fxdatan2.htm
    4370:	6f 92       	push	r6
    4372:	7f 92       	push	r7
    4374:	8f 92       	push	r8
    4376:	9f 92       	push	r9
    4378:	af 92       	push	r10
    437a:	bf 92       	push	r11
    437c:	cf 92       	push	r12
    437e:	df 92       	push	r13
    4380:	ef 92       	push	r14
    4382:	ff 92       	push	r15
    4384:	0f 93       	push	r16
    4386:	1f 93       	push	r17
    4388:	cf 93       	push	r28
    438a:	df 93       	push	r29
    438c:	ec 01       	movw	r28, r24
    438e:	6b 01       	movw	r12, r22
   int coeff_1 = 128;                                          // angle in Quids (1024 Quids=360) <<<<<<<<<<<<<<
   int coeff_2 = 3*coeff_1;
   float abs_y = abs(y)+1e-10;
    4390:	bc 01       	movw	r22, r24
    4392:	97 ff       	sbrs	r25, 7
    4394:	04 c0       	rjmp	.+8      	; 0x439e <arctan2+0x2e>
    4396:	66 27       	eor	r22, r22
    4398:	77 27       	eor	r23, r23
    439a:	68 1b       	sub	r22, r24
    439c:	79 0b       	sbc	r23, r25
    439e:	88 27       	eor	r24, r24
    43a0:	77 fd       	sbrc	r23, 7
    43a2:	80 95       	com	r24
    43a4:	98 2f       	mov	r25, r24
    43a6:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    43aa:	2f ef       	ldi	r18, 0xFF	; 255
    43ac:	36 ee       	ldi	r19, 0xE6	; 230
    43ae:	4b ed       	ldi	r20, 0xDB	; 219
    43b0:	5e e2       	ldi	r21, 0x2E	; 46
    43b2:	0e 94 25 38 	call	0x704a	; 0x704a <__addsf3>
    43b6:	16 2f       	mov	r17, r22
    43b8:	07 2f       	mov	r16, r23
    43ba:	f8 2e       	mov	r15, r24
    43bc:	e9 2e       	mov	r14, r25
    43be:	b6 01       	movw	r22, r12
    43c0:	88 27       	eor	r24, r24
    43c2:	77 fd       	sbrc	r23, 7
    43c4:	80 95       	com	r24
    43c6:	98 2f       	mov	r25, r24
   float r, angle;

   if (x >= 0) {
    43c8:	d7 fc       	sbrc	r13, 7
    43ca:	2b c0       	rjmp	.+86     	; 0x4422 <arctan2+0xb2>
     r = (x - abs_y) / (x + abs_y);
    43cc:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    43d0:	5b 01       	movw	r10, r22
    43d2:	6c 01       	movw	r12, r24
    43d4:	d8 01       	movw	r26, r16
    43d6:	f7 01       	movw	r30, r14
    43d8:	2b 2f       	mov	r18, r27
    43da:	3a 2f       	mov	r19, r26
    43dc:	4f 2f       	mov	r20, r31
    43de:	5e 2f       	mov	r21, r30
    43e0:	0e 94 24 38 	call	0x7048	; 0x7048 <__subsf3>
    43e4:	3b 01       	movw	r6, r22
    43e6:	4c 01       	movw	r8, r24
    43e8:	c6 01       	movw	r24, r12
    43ea:	b5 01       	movw	r22, r10
    43ec:	d8 01       	movw	r26, r16
    43ee:	f7 01       	movw	r30, r14
    43f0:	2b 2f       	mov	r18, r27
    43f2:	3a 2f       	mov	r19, r26
    43f4:	4f 2f       	mov	r20, r31
    43f6:	5e 2f       	mov	r21, r30
    43f8:	0e 94 25 38 	call	0x704a	; 0x704a <__addsf3>
    43fc:	9b 01       	movw	r18, r22
    43fe:	ac 01       	movw	r20, r24
    4400:	c4 01       	movw	r24, r8
    4402:	b3 01       	movw	r22, r6
    4404:	0e 94 8d 38 	call	0x711a	; 0x711a <__divsf3>
     angle = coeff_1 - coeff_1 * r;
    4408:	20 e0       	ldi	r18, 0x00	; 0
    440a:	30 e0       	ldi	r19, 0x00	; 0
    440c:	40 e0       	ldi	r20, 0x00	; 0
    440e:	53 e4       	ldi	r21, 0x43	; 67
    4410:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    4414:	9b 01       	movw	r18, r22
    4416:	ac 01       	movw	r20, r24
    4418:	60 e0       	ldi	r22, 0x00	; 0
    441a:	70 e0       	ldi	r23, 0x00	; 0
    441c:	80 e0       	ldi	r24, 0x00	; 0
    441e:	93 e4       	ldi	r25, 0x43	; 67
    4420:	2a c0       	rjmp	.+84     	; 0x4476 <arctan2+0x106>
   }  else {
     r = (x + abs_y) / (abs_y - x);
    4422:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    4426:	5b 01       	movw	r10, r22
    4428:	6c 01       	movw	r12, r24
    442a:	d8 01       	movw	r26, r16
    442c:	f7 01       	movw	r30, r14
    442e:	2b 2f       	mov	r18, r27
    4430:	3a 2f       	mov	r19, r26
    4432:	4f 2f       	mov	r20, r31
    4434:	5e 2f       	mov	r21, r30
    4436:	0e 94 25 38 	call	0x704a	; 0x704a <__addsf3>
    443a:	3b 01       	movw	r6, r22
    443c:	4c 01       	movw	r8, r24
    443e:	a8 01       	movw	r20, r16
    4440:	97 01       	movw	r18, r14
    4442:	65 2f       	mov	r22, r21
    4444:	74 2f       	mov	r23, r20
    4446:	83 2f       	mov	r24, r19
    4448:	92 2f       	mov	r25, r18
    444a:	a6 01       	movw	r20, r12
    444c:	95 01       	movw	r18, r10
    444e:	0e 94 24 38 	call	0x7048	; 0x7048 <__subsf3>
    4452:	9b 01       	movw	r18, r22
    4454:	ac 01       	movw	r20, r24
    4456:	c4 01       	movw	r24, r8
    4458:	b3 01       	movw	r22, r6
    445a:	0e 94 8d 38 	call	0x711a	; 0x711a <__divsf3>
     angle = coeff_2 - coeff_1 * r;
    445e:	20 e0       	ldi	r18, 0x00	; 0
    4460:	30 e0       	ldi	r19, 0x00	; 0
    4462:	40 e0       	ldi	r20, 0x00	; 0
    4464:	53 e4       	ldi	r21, 0x43	; 67
    4466:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    446a:	9b 01       	movw	r18, r22
    446c:	ac 01       	movw	r20, r24
    446e:	60 e0       	ldi	r22, 0x00	; 0
    4470:	70 e0       	ldi	r23, 0x00	; 0
    4472:	80 ec       	ldi	r24, 0xC0	; 192
    4474:	93 e4       	ldi	r25, 0x43	; 67
    4476:	0e 94 24 38 	call	0x7048	; 0x7048 <__subsf3>
   }
   if (y < 0)      return (int)(-angle);
    447a:	d7 fd       	sbrc	r29, 7
    447c:	90 58       	subi	r25, 0x80	; 128
   else            return (int)(angle);
    447e:	0e 94 f5 38 	call	0x71ea	; 0x71ea <__fixsfsi>
}
    4482:	cb 01       	movw	r24, r22
    4484:	df 91       	pop	r29
    4486:	cf 91       	pop	r28
    4488:	1f 91       	pop	r17
    448a:	0f 91       	pop	r16
    448c:	ff 90       	pop	r15
    448e:	ef 90       	pop	r14
    4490:	df 90       	pop	r13
    4492:	cf 90       	pop	r12
    4494:	bf 90       	pop	r11
    4496:	af 90       	pop	r10
    4498:	9f 90       	pop	r9
    449a:	8f 90       	pop	r8
    449c:	7f 90       	pop	r7
    449e:	6f 90       	pop	r6
    44a0:	08 95       	ret

000044a2 <Limiterf>:


float Limiterf (float Value, float Limit)
{
    44a2:	af 92       	push	r10
    44a4:	bf 92       	push	r11
    44a6:	cf 92       	push	r12
    44a8:	df 92       	push	r13
    44aa:	ef 92       	push	r14
    44ac:	ff 92       	push	r15
    44ae:	0f 93       	push	r16
    44b0:	1f 93       	push	r17
    44b2:	d6 2e       	mov	r13, r22
    44b4:	c7 2e       	mov	r12, r23
    44b6:	b8 2e       	mov	r11, r24
    44b8:	a9 2e       	mov	r10, r25
    44ba:	79 01       	movw	r14, r18
    44bc:	8a 01       	movw	r16, r20
	if (Value > Limit) return   Limit;
    44be:	a6 01       	movw	r20, r12
    44c0:	95 01       	movw	r18, r10
    44c2:	65 2f       	mov	r22, r21
    44c4:	74 2f       	mov	r23, r20
    44c6:	83 2f       	mov	r24, r19
    44c8:	92 2f       	mov	r25, r18
    44ca:	a8 01       	movw	r20, r16
    44cc:	97 01       	movw	r18, r14
    44ce:	0e 94 d8 39 	call	0x73b0	; 0x73b0 <__gesf2>
    44d2:	18 16       	cp	r1, r24
    44d4:	b4 f0       	brlt	.+44     	; 0x4502 <Limiterf+0x60>
	if (Value < -Limit) return -Limit;
    44d6:	17 fb       	bst	r17, 7
    44d8:	10 95       	com	r17
    44da:	17 f9       	bld	r17, 7
    44dc:	10 95       	com	r17
    44de:	a6 01       	movw	r20, r12
    44e0:	95 01       	movw	r18, r10
    44e2:	65 2f       	mov	r22, r21
    44e4:	74 2f       	mov	r23, r20
    44e6:	83 2f       	mov	r24, r19
    44e8:	92 2f       	mov	r25, r18
    44ea:	a8 01       	movw	r20, r16
    44ec:	97 01       	movw	r18, r14
    44ee:	0e 94 89 38 	call	0x7112	; 0x7112 <__cmpsf2>
    44f2:	87 fd       	sbrc	r24, 7
    44f4:	06 c0       	rjmp	.+12     	; 0x4502 <Limiterf+0x60>
	
	return Value;
    44f6:	96 01       	movw	r18, r12
    44f8:	c5 01       	movw	r24, r10
    44fa:	e3 2e       	mov	r14, r19
    44fc:	f2 2e       	mov	r15, r18
    44fe:	09 2f       	mov	r16, r25
    4500:	18 2f       	mov	r17, r24
}
    4502:	6e 2d       	mov	r22, r14
    4504:	7f 2d       	mov	r23, r15
    4506:	80 2f       	mov	r24, r16
    4508:	91 2f       	mov	r25, r17
    450a:	1f 91       	pop	r17
    450c:	0f 91       	pop	r16
    450e:	ff 90       	pop	r15
    4510:	ef 90       	pop	r14
    4512:	df 90       	pop	r13
    4514:	cf 90       	pop	r12
    4516:	bf 90       	pop	r11
    4518:	af 90       	pop	r10
    451a:	08 95       	ret

0000451c <Limiter>:

int16_t Limiter (int16_t Value, int16_t Limit)
{
	if (Value > Limit) return   Limit;
    451c:	68 17       	cp	r22, r24
    451e:	79 07       	cpc	r23, r25
    4520:	3c f0       	brlt	.+14     	; 0x4530 <Limiter+0x14>
	if (Value < -Limit) return -Limit;
    4522:	70 95       	com	r23
    4524:	61 95       	neg	r22
    4526:	7f 4f       	sbci	r23, 0xFF	; 255
    4528:	68 17       	cp	r22, r24
    452a:	79 07       	cpc	r23, r25
    452c:	0c f4       	brge	.+2      	; 0x4530 <Limiter+0x14>
    452e:	bc 01       	movw	r22, r24
	
	return Value;
}
    4530:	cb 01       	movw	r24, r22
    4532:	08 95       	ret

00004534 <ScaleSensor>:
			 return (int16_t) y;
		}
	   }	
		*/
	return 0;	
}
    4534:	80 e0       	ldi	r24, 0x00	; 0
    4536:	90 e0       	ldi	r25, 0x00	; 0
    4538:	08 95       	ret

0000453a <vector3d_modulus>:

#include "../Include/Vector3D.h"

//get modulus of a 3d vector sqrt(x^2+y^2+y^2)
float vector3d_modulus(float* vector)
{
    453a:	6f 92       	push	r6
    453c:	7f 92       	push	r7
    453e:	8f 92       	push	r8
    4540:	9f 92       	push	r9
    4542:	af 92       	push	r10
    4544:	bf 92       	push	r11
    4546:	cf 92       	push	r12
    4548:	df 92       	push	r13
    454a:	ef 92       	push	r14
    454c:	ff 92       	push	r15
    454e:	0f 93       	push	r16
    4550:	1f 93       	push	r17
    4552:	fc 01       	movw	r30, r24
        static float R;  
        R = vector[0]*vector[0];
    4554:	20 81       	ld	r18, Z
    4556:	31 81       	ldd	r19, Z+1	; 0x01
    4558:	42 81       	ldd	r20, Z+2	; 0x02
    455a:	53 81       	ldd	r21, Z+3	; 0x03
        R += vector[1]*vector[1];
    455c:	e4 80       	ldd	r14, Z+4	; 0x04
    455e:	f5 80       	ldd	r15, Z+5	; 0x05
    4560:	06 81       	ldd	r16, Z+6	; 0x06
    4562:	17 81       	ldd	r17, Z+7	; 0x07
        R += vector[2]*vector[2];
    4564:	a0 84       	ldd	r10, Z+8	; 0x08
    4566:	b1 84       	ldd	r11, Z+9	; 0x09
    4568:	c2 84       	ldd	r12, Z+10	; 0x0a
    456a:	d3 84       	ldd	r13, Z+11	; 0x0b

//get modulus of a 3d vector sqrt(x^2+y^2+y^2)
float vector3d_modulus(float* vector)
{
        static float R;  
        R = vector[0]*vector[0];
    456c:	ca 01       	movw	r24, r20
    456e:	b9 01       	movw	r22, r18
    4570:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    4574:	3b 01       	movw	r6, r22
    4576:	4c 01       	movw	r8, r24
        R += vector[1]*vector[1];
    4578:	c8 01       	movw	r24, r16
    457a:	b7 01       	movw	r22, r14
    457c:	a8 01       	movw	r20, r16
    457e:	97 01       	movw	r18, r14
    4580:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    4584:	9b 01       	movw	r18, r22
    4586:	ac 01       	movw	r20, r24
    4588:	c4 01       	movw	r24, r8
    458a:	b3 01       	movw	r22, r6
    458c:	0e 94 25 38 	call	0x704a	; 0x704a <__addsf3>
    4590:	7b 01       	movw	r14, r22
    4592:	8c 01       	movw	r16, r24
        R += vector[2]*vector[2];
    4594:	c6 01       	movw	r24, r12
    4596:	b5 01       	movw	r22, r10
    4598:	a6 01       	movw	r20, r12
    459a:	95 01       	movw	r18, r10
    459c:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    45a0:	9b 01       	movw	r18, r22
    45a2:	ac 01       	movw	r20, r24
    45a4:	c8 01       	movw	r24, r16
    45a6:	b7 01       	movw	r22, r14
    45a8:	0e 94 25 38 	call	0x704a	; 0x704a <__addsf3>
    45ac:	26 2f       	mov	r18, r22
    45ae:	37 2f       	mov	r19, r23
    45b0:	48 2f       	mov	r20, r24
    45b2:	59 2f       	mov	r21, r25
    45b4:	20 93 2c 05 	sts	0x052C, r18
    45b8:	30 93 2d 05 	sts	0x052D, r19
    45bc:	40 93 2e 05 	sts	0x052E, r20
    45c0:	50 93 2f 05 	sts	0x052F, r21
        return sqrt(R);
    45c4:	0e 94 43 3a 	call	0x7486	; 0x7486 <sqrt>
}
    45c8:	1f 91       	pop	r17
    45ca:	0f 91       	pop	r16
    45cc:	ff 90       	pop	r15
    45ce:	ef 90       	pop	r14
    45d0:	df 90       	pop	r13
    45d2:	cf 90       	pop	r12
    45d4:	bf 90       	pop	r11
    45d6:	af 90       	pop	r10
    45d8:	9f 90       	pop	r9
    45da:	8f 90       	pop	r8
    45dc:	7f 90       	pop	r7
    45de:	6f 90       	pop	r6
    45e0:	08 95       	ret

000045e2 <vector3d_normalize>:

//convert vector to a vector with same direction and modulus 1
void vector3d_normalize(float* vector)
{
    45e2:	ef 92       	push	r14
    45e4:	ff 92       	push	r15
    45e6:	0f 93       	push	r16
    45e8:	1f 93       	push	r17
    45ea:	cf 93       	push	r28
    45ec:	df 93       	push	r29
    45ee:	ec 01       	movw	r28, r24
        static float R;  
        R = vector3d_modulus(vector);
    45f0:	0e 94 9d 22 	call	0x453a	; 0x453a <vector3d_modulus>
    45f4:	7b 01       	movw	r14, r22
    45f6:	8c 01       	movw	r16, r24
    45f8:	60 93 28 05 	sts	0x0528, r22
    45fc:	70 93 29 05 	sts	0x0529, r23
    4600:	80 93 2a 05 	sts	0x052A, r24
    4604:	90 93 2b 05 	sts	0x052B, r25
        vector[0] /= R;
    4608:	68 81       	ld	r22, Y
    460a:	79 81       	ldd	r23, Y+1	; 0x01
    460c:	8a 81       	ldd	r24, Y+2	; 0x02
    460e:	9b 81       	ldd	r25, Y+3	; 0x03
    4610:	a8 01       	movw	r20, r16
    4612:	97 01       	movw	r18, r14
    4614:	0e 94 8d 38 	call	0x711a	; 0x711a <__divsf3>
    4618:	68 83       	st	Y, r22
    461a:	79 83       	std	Y+1, r23	; 0x01
    461c:	8a 83       	std	Y+2, r24	; 0x02
    461e:	9b 83       	std	Y+3, r25	; 0x03
        vector[1] /= R; 
    4620:	6c 81       	ldd	r22, Y+4	; 0x04
    4622:	7d 81       	ldd	r23, Y+5	; 0x05
    4624:	8e 81       	ldd	r24, Y+6	; 0x06
    4626:	9f 81       	ldd	r25, Y+7	; 0x07
    4628:	a8 01       	movw	r20, r16
    462a:	97 01       	movw	r18, r14
    462c:	0e 94 8d 38 	call	0x711a	; 0x711a <__divsf3>
    4630:	6c 83       	std	Y+4, r22	; 0x04
    4632:	7d 83       	std	Y+5, r23	; 0x05
    4634:	8e 83       	std	Y+6, r24	; 0x06
    4636:	9f 83       	std	Y+7, r25	; 0x07
        vector[2] /= R;  
    4638:	68 85       	ldd	r22, Y+8	; 0x08
    463a:	79 85       	ldd	r23, Y+9	; 0x09
    463c:	8a 85       	ldd	r24, Y+10	; 0x0a
    463e:	9b 85       	ldd	r25, Y+11	; 0x0b
    4640:	a8 01       	movw	r20, r16
    4642:	97 01       	movw	r18, r14
    4644:	0e 94 8d 38 	call	0x711a	; 0x711a <__divsf3>
    4648:	68 87       	std	Y+8, r22	; 0x08
    464a:	79 87       	std	Y+9, r23	; 0x09
    464c:	8a 87       	std	Y+10, r24	; 0x0a
    464e:	9b 87       	std	Y+11, r25	; 0x0b
}
    4650:	df 91       	pop	r29
    4652:	cf 91       	pop	r28
    4654:	1f 91       	pop	r17
    4656:	0f 91       	pop	r16
    4658:	ff 90       	pop	r15
    465a:	ef 90       	pop	r14
    465c:	08 95       	ret

0000465e <vector3d_dot>:

//calcuate vector dot-product  c = a . b
float vector3d_dot(float* a,float* b)
{
    465e:	cf 92       	push	r12
    4660:	df 92       	push	r13
    4662:	ef 92       	push	r14
    4664:	ff 92       	push	r15
    4666:	0f 93       	push	r16
    4668:	1f 93       	push	r17
    466a:	cf 93       	push	r28
    466c:	df 93       	push	r29
    466e:	ec 01       	movw	r28, r24
    4670:	8b 01       	movw	r16, r22
        return a[0]*b[0]+a[1]*b[1]+a[2]*b[2];
    4672:	68 81       	ld	r22, Y
    4674:	79 81       	ldd	r23, Y+1	; 0x01
    4676:	8a 81       	ldd	r24, Y+2	; 0x02
    4678:	9b 81       	ldd	r25, Y+3	; 0x03
    467a:	f8 01       	movw	r30, r16
    467c:	20 81       	ld	r18, Z
    467e:	31 81       	ldd	r19, Z+1	; 0x01
    4680:	42 81       	ldd	r20, Z+2	; 0x02
    4682:	53 81       	ldd	r21, Z+3	; 0x03
    4684:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    4688:	6b 01       	movw	r12, r22
    468a:	7c 01       	movw	r14, r24
    468c:	6c 81       	ldd	r22, Y+4	; 0x04
    468e:	7d 81       	ldd	r23, Y+5	; 0x05
    4690:	8e 81       	ldd	r24, Y+6	; 0x06
    4692:	9f 81       	ldd	r25, Y+7	; 0x07
    4694:	f8 01       	movw	r30, r16
    4696:	24 81       	ldd	r18, Z+4	; 0x04
    4698:	35 81       	ldd	r19, Z+5	; 0x05
    469a:	46 81       	ldd	r20, Z+6	; 0x06
    469c:	57 81       	ldd	r21, Z+7	; 0x07
    469e:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    46a2:	9b 01       	movw	r18, r22
    46a4:	ac 01       	movw	r20, r24
    46a6:	c7 01       	movw	r24, r14
    46a8:	b6 01       	movw	r22, r12
    46aa:	0e 94 25 38 	call	0x704a	; 0x704a <__addsf3>
    46ae:	6b 01       	movw	r12, r22
    46b0:	7c 01       	movw	r14, r24
    46b2:	68 85       	ldd	r22, Y+8	; 0x08
    46b4:	79 85       	ldd	r23, Y+9	; 0x09
    46b6:	8a 85       	ldd	r24, Y+10	; 0x0a
    46b8:	9b 85       	ldd	r25, Y+11	; 0x0b
    46ba:	f8 01       	movw	r30, r16
    46bc:	20 85       	ldd	r18, Z+8	; 0x08
    46be:	31 85       	ldd	r19, Z+9	; 0x09
    46c0:	42 85       	ldd	r20, Z+10	; 0x0a
    46c2:	53 85       	ldd	r21, Z+11	; 0x0b
    46c4:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    46c8:	9b 01       	movw	r18, r22
    46ca:	ac 01       	movw	r20, r24
    46cc:	c7 01       	movw	r24, r14
    46ce:	b6 01       	movw	r22, r12
    46d0:	0e 94 25 38 	call	0x704a	; 0x704a <__addsf3>
}
    46d4:	df 91       	pop	r29
    46d6:	cf 91       	pop	r28
    46d8:	1f 91       	pop	r17
    46da:	0f 91       	pop	r16
    46dc:	ff 90       	pop	r15
    46de:	ef 90       	pop	r14
    46e0:	df 90       	pop	r13
    46e2:	cf 90       	pop	r12
    46e4:	08 95       	ret

000046e6 <vector3d_cross>:


//calcuate vector cross-product  c = a x b
void vector3d_cross(float* a,float* b, float* c)
{
    46e6:	af 92       	push	r10
    46e8:	bf 92       	push	r11
    46ea:	cf 92       	push	r12
    46ec:	df 92       	push	r13
    46ee:	ef 92       	push	r14
    46f0:	ff 92       	push	r15
    46f2:	0f 93       	push	r16
    46f4:	1f 93       	push	r17
    46f6:	cf 93       	push	r28
    46f8:	df 93       	push	r29
    46fa:	ec 01       	movw	r28, r24
    46fc:	8b 01       	movw	r16, r22
    46fe:	7a 01       	movw	r14, r20
        c[0] = a[1]*b[2] - a[2]*b[1];
    4700:	6c 81       	ldd	r22, Y+4	; 0x04
    4702:	7d 81       	ldd	r23, Y+5	; 0x05
    4704:	8e 81       	ldd	r24, Y+6	; 0x06
    4706:	9f 81       	ldd	r25, Y+7	; 0x07
    4708:	f8 01       	movw	r30, r16
    470a:	20 85       	ldd	r18, Z+8	; 0x08
    470c:	31 85       	ldd	r19, Z+9	; 0x09
    470e:	42 85       	ldd	r20, Z+10	; 0x0a
    4710:	53 85       	ldd	r21, Z+11	; 0x0b
    4712:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    4716:	5b 01       	movw	r10, r22
    4718:	6c 01       	movw	r12, r24
    471a:	68 85       	ldd	r22, Y+8	; 0x08
    471c:	79 85       	ldd	r23, Y+9	; 0x09
    471e:	8a 85       	ldd	r24, Y+10	; 0x0a
    4720:	9b 85       	ldd	r25, Y+11	; 0x0b
    4722:	f8 01       	movw	r30, r16
    4724:	24 81       	ldd	r18, Z+4	; 0x04
    4726:	35 81       	ldd	r19, Z+5	; 0x05
    4728:	46 81       	ldd	r20, Z+6	; 0x06
    472a:	57 81       	ldd	r21, Z+7	; 0x07
    472c:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    4730:	9b 01       	movw	r18, r22
    4732:	ac 01       	movw	r20, r24
    4734:	c6 01       	movw	r24, r12
    4736:	b5 01       	movw	r22, r10
    4738:	0e 94 24 38 	call	0x7048	; 0x7048 <__subsf3>
    473c:	f7 01       	movw	r30, r14
    473e:	60 83       	st	Z, r22
    4740:	71 83       	std	Z+1, r23	; 0x01
    4742:	82 83       	std	Z+2, r24	; 0x02
    4744:	93 83       	std	Z+3, r25	; 0x03
        c[1] = a[2]*b[0] - a[0]*b[2];
    4746:	68 85       	ldd	r22, Y+8	; 0x08
    4748:	79 85       	ldd	r23, Y+9	; 0x09
    474a:	8a 85       	ldd	r24, Y+10	; 0x0a
    474c:	9b 85       	ldd	r25, Y+11	; 0x0b
    474e:	f8 01       	movw	r30, r16
    4750:	20 81       	ld	r18, Z
    4752:	31 81       	ldd	r19, Z+1	; 0x01
    4754:	42 81       	ldd	r20, Z+2	; 0x02
    4756:	53 81       	ldd	r21, Z+3	; 0x03
    4758:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    475c:	5b 01       	movw	r10, r22
    475e:	6c 01       	movw	r12, r24
    4760:	68 81       	ld	r22, Y
    4762:	79 81       	ldd	r23, Y+1	; 0x01
    4764:	8a 81       	ldd	r24, Y+2	; 0x02
    4766:	9b 81       	ldd	r25, Y+3	; 0x03
    4768:	f8 01       	movw	r30, r16
    476a:	20 85       	ldd	r18, Z+8	; 0x08
    476c:	31 85       	ldd	r19, Z+9	; 0x09
    476e:	42 85       	ldd	r20, Z+10	; 0x0a
    4770:	53 85       	ldd	r21, Z+11	; 0x0b
    4772:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    4776:	9b 01       	movw	r18, r22
    4778:	ac 01       	movw	r20, r24
    477a:	c6 01       	movw	r24, r12
    477c:	b5 01       	movw	r22, r10
    477e:	0e 94 24 38 	call	0x7048	; 0x7048 <__subsf3>
    4782:	f7 01       	movw	r30, r14
    4784:	64 83       	std	Z+4, r22	; 0x04
    4786:	75 83       	std	Z+5, r23	; 0x05
    4788:	86 83       	std	Z+6, r24	; 0x06
    478a:	97 83       	std	Z+7, r25	; 0x07
        c[2] = a[0]*b[1] - a[1]*b[0];
    478c:	68 81       	ld	r22, Y
    478e:	79 81       	ldd	r23, Y+1	; 0x01
    4790:	8a 81       	ldd	r24, Y+2	; 0x02
    4792:	9b 81       	ldd	r25, Y+3	; 0x03
    4794:	f8 01       	movw	r30, r16
    4796:	24 81       	ldd	r18, Z+4	; 0x04
    4798:	35 81       	ldd	r19, Z+5	; 0x05
    479a:	46 81       	ldd	r20, Z+6	; 0x06
    479c:	57 81       	ldd	r21, Z+7	; 0x07
    479e:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    47a2:	5b 01       	movw	r10, r22
    47a4:	6c 01       	movw	r12, r24
    47a6:	6c 81       	ldd	r22, Y+4	; 0x04
    47a8:	7d 81       	ldd	r23, Y+5	; 0x05
    47aa:	8e 81       	ldd	r24, Y+6	; 0x06
    47ac:	9f 81       	ldd	r25, Y+7	; 0x07
    47ae:	f8 01       	movw	r30, r16
    47b0:	20 81       	ld	r18, Z
    47b2:	31 81       	ldd	r19, Z+1	; 0x01
    47b4:	42 81       	ldd	r20, Z+2	; 0x02
    47b6:	53 81       	ldd	r21, Z+3	; 0x03
    47b8:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    47bc:	9b 01       	movw	r18, r22
    47be:	ac 01       	movw	r20, r24
    47c0:	c6 01       	movw	r24, r12
    47c2:	b5 01       	movw	r22, r10
    47c4:	0e 94 24 38 	call	0x7048	; 0x7048 <__subsf3>
    47c8:	f7 01       	movw	r30, r14
    47ca:	60 87       	std	Z+8, r22	; 0x08
    47cc:	71 87       	std	Z+9, r23	; 0x09
    47ce:	82 87       	std	Z+10, r24	; 0x0a
    47d0:	93 87       	std	Z+11, r25	; 0x0b
}
    47d2:	df 91       	pop	r29
    47d4:	cf 91       	pop	r28
    47d6:	1f 91       	pop	r17
    47d8:	0f 91       	pop	r16
    47da:	ff 90       	pop	r15
    47dc:	ef 90       	pop	r14
    47de:	df 90       	pop	r13
    47e0:	cf 90       	pop	r12
    47e2:	bf 90       	pop	r11
    47e4:	af 90       	pop	r10
    47e6:	08 95       	ret

000047e8 <vector3d_scale>:

//calcuate vector scalar-product  n = s x a
void vector3d_scale(float s, float* a , float* b)
{
    47e8:	cf 92       	push	r12
    47ea:	df 92       	push	r13
    47ec:	ef 92       	push	r14
    47ee:	ff 92       	push	r15
    47f0:	0f 93       	push	r16
    47f2:	1f 93       	push	r17
    47f4:	cf 93       	push	r28
    47f6:	df 93       	push	r29
    47f8:	7b 01       	movw	r14, r22
    47fa:	8c 01       	movw	r16, r24
    47fc:	ea 01       	movw	r28, r20
    47fe:	69 01       	movw	r12, r18
        b[0] = s*a[0];
    4800:	28 81       	ld	r18, Y
    4802:	39 81       	ldd	r19, Y+1	; 0x01
    4804:	4a 81       	ldd	r20, Y+2	; 0x02
    4806:	5b 81       	ldd	r21, Y+3	; 0x03
    4808:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    480c:	f6 01       	movw	r30, r12
    480e:	60 83       	st	Z, r22
    4810:	71 83       	std	Z+1, r23	; 0x01
    4812:	82 83       	std	Z+2, r24	; 0x02
    4814:	93 83       	std	Z+3, r25	; 0x03
        b[1] = s*a[1];
    4816:	c8 01       	movw	r24, r16
    4818:	b7 01       	movw	r22, r14
    481a:	2c 81       	ldd	r18, Y+4	; 0x04
    481c:	3d 81       	ldd	r19, Y+5	; 0x05
    481e:	4e 81       	ldd	r20, Y+6	; 0x06
    4820:	5f 81       	ldd	r21, Y+7	; 0x07
    4822:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    4826:	f6 01       	movw	r30, r12
    4828:	64 83       	std	Z+4, r22	; 0x04
    482a:	75 83       	std	Z+5, r23	; 0x05
    482c:	86 83       	std	Z+6, r24	; 0x06
    482e:	97 83       	std	Z+7, r25	; 0x07
        b[2] = s*a[2];
    4830:	c8 01       	movw	r24, r16
    4832:	b7 01       	movw	r22, r14
    4834:	28 85       	ldd	r18, Y+8	; 0x08
    4836:	39 85       	ldd	r19, Y+9	; 0x09
    4838:	4a 85       	ldd	r20, Y+10	; 0x0a
    483a:	5b 85       	ldd	r21, Y+11	; 0x0b
    483c:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    4840:	f6 01       	movw	r30, r12
    4842:	60 87       	std	Z+8, r22	; 0x08
    4844:	71 87       	std	Z+9, r23	; 0x09
    4846:	82 87       	std	Z+10, r24	; 0x0a
    4848:	93 87       	std	Z+11, r25	; 0x0b
} 
    484a:	df 91       	pop	r29
    484c:	cf 91       	pop	r28
    484e:	1f 91       	pop	r17
    4850:	0f 91       	pop	r16
    4852:	ff 90       	pop	r15
    4854:	ef 90       	pop	r14
    4856:	df 90       	pop	r13
    4858:	cf 90       	pop	r12
    485a:	08 95       	ret

0000485c <vector3d_add>:


//calcuate vector sum   c = a + b
void vector3d_add(float* a , float* b, float* c)
{
    485c:	ef 92       	push	r14
    485e:	ff 92       	push	r15
    4860:	0f 93       	push	r16
    4862:	1f 93       	push	r17
    4864:	cf 93       	push	r28
    4866:	df 93       	push	r29
    4868:	ec 01       	movw	r28, r24
    486a:	8b 01       	movw	r16, r22
    486c:	7a 01       	movw	r14, r20
        c[0] = a[0] + b[0];
    486e:	68 81       	ld	r22, Y
    4870:	79 81       	ldd	r23, Y+1	; 0x01
    4872:	8a 81       	ldd	r24, Y+2	; 0x02
    4874:	9b 81       	ldd	r25, Y+3	; 0x03
    4876:	f8 01       	movw	r30, r16
    4878:	20 81       	ld	r18, Z
    487a:	31 81       	ldd	r19, Z+1	; 0x01
    487c:	42 81       	ldd	r20, Z+2	; 0x02
    487e:	53 81       	ldd	r21, Z+3	; 0x03
    4880:	0e 94 25 38 	call	0x704a	; 0x704a <__addsf3>
    4884:	f7 01       	movw	r30, r14
    4886:	60 83       	st	Z, r22
    4888:	71 83       	std	Z+1, r23	; 0x01
    488a:	82 83       	std	Z+2, r24	; 0x02
    488c:	93 83       	std	Z+3, r25	; 0x03
        c[1] = a[1] + b[1];
    488e:	6c 81       	ldd	r22, Y+4	; 0x04
    4890:	7d 81       	ldd	r23, Y+5	; 0x05
    4892:	8e 81       	ldd	r24, Y+6	; 0x06
    4894:	9f 81       	ldd	r25, Y+7	; 0x07
    4896:	f8 01       	movw	r30, r16
    4898:	24 81       	ldd	r18, Z+4	; 0x04
    489a:	35 81       	ldd	r19, Z+5	; 0x05
    489c:	46 81       	ldd	r20, Z+6	; 0x06
    489e:	57 81       	ldd	r21, Z+7	; 0x07
    48a0:	0e 94 25 38 	call	0x704a	; 0x704a <__addsf3>
    48a4:	f7 01       	movw	r30, r14
    48a6:	64 83       	std	Z+4, r22	; 0x04
    48a8:	75 83       	std	Z+5, r23	; 0x05
    48aa:	86 83       	std	Z+6, r24	; 0x06
    48ac:	97 83       	std	Z+7, r25	; 0x07
        c[2] = a[2] + b[2];
    48ae:	68 85       	ldd	r22, Y+8	; 0x08
    48b0:	79 85       	ldd	r23, Y+9	; 0x09
    48b2:	8a 85       	ldd	r24, Y+10	; 0x0a
    48b4:	9b 85       	ldd	r25, Y+11	; 0x0b
    48b6:	f8 01       	movw	r30, r16
    48b8:	20 85       	ldd	r18, Z+8	; 0x08
    48ba:	31 85       	ldd	r19, Z+9	; 0x09
    48bc:	42 85       	ldd	r20, Z+10	; 0x0a
    48be:	53 85       	ldd	r21, Z+11	; 0x0b
    48c0:	0e 94 25 38 	call	0x704a	; 0x704a <__addsf3>
    48c4:	f7 01       	movw	r30, r14
    48c6:	60 87       	std	Z+8, r22	; 0x08
    48c8:	71 87       	std	Z+9, r23	; 0x09
    48ca:	82 87       	std	Z+10, r24	; 0x0a
    48cc:	93 87       	std	Z+11, r25	; 0x0b
} 
    48ce:	df 91       	pop	r29
    48d0:	cf 91       	pop	r28
    48d2:	1f 91       	pop	r17
    48d4:	0f 91       	pop	r16
    48d6:	ff 90       	pop	r15
    48d8:	ef 90       	pop	r14
    48da:	08 95       	ret

000048dc <vector3d_skew_plus_identity>:
//for v = {x,y,z} returns
// m = {{1,-z,y}
//              {z,1,-x}
//              {-y,x,1}}
void vector3d_skew_plus_identity(float *v,float* m)
{
    48dc:	ef 92       	push	r14
    48de:	ff 92       	push	r15
    48e0:	0f 93       	push	r16
    48e2:	1f 93       	push	r17
    48e4:	dc 01       	movw	r26, r24
    48e6:	fb 01       	movw	r30, r22
        m[0*3+0]=1;
    48e8:	20 e0       	ldi	r18, 0x00	; 0
    48ea:	30 e0       	ldi	r19, 0x00	; 0
    48ec:	40 e8       	ldi	r20, 0x80	; 128
    48ee:	5f e3       	ldi	r21, 0x3F	; 63
    48f0:	20 83       	st	Z, r18
    48f2:	31 83       	std	Z+1, r19	; 0x01
    48f4:	42 83       	std	Z+2, r20	; 0x02
    48f6:	53 83       	std	Z+3, r21	; 0x03
        m[0*3+1]=-v[2];
    48f8:	18 96       	adiw	r26, 0x08	; 8
    48fa:	6d 91       	ld	r22, X+
    48fc:	7d 91       	ld	r23, X+
    48fe:	8d 91       	ld	r24, X+
    4900:	9c 91       	ld	r25, X
    4902:	1b 97       	sbiw	r26, 0x0b	; 11
    4904:	90 58       	subi	r25, 0x80	; 128
    4906:	64 83       	std	Z+4, r22	; 0x04
    4908:	75 83       	std	Z+5, r23	; 0x05
    490a:	86 83       	std	Z+6, r24	; 0x06
    490c:	97 83       	std	Z+7, r25	; 0x07
        m[0*3+2]=v[1];
    490e:	14 96       	adiw	r26, 0x04	; 4
    4910:	6d 91       	ld	r22, X+
    4912:	7d 91       	ld	r23, X+
    4914:	8d 91       	ld	r24, X+
    4916:	9c 91       	ld	r25, X
    4918:	17 97       	sbiw	r26, 0x07	; 7
    491a:	60 87       	std	Z+8, r22	; 0x08
    491c:	71 87       	std	Z+9, r23	; 0x09
    491e:	82 87       	std	Z+10, r24	; 0x0a
    4920:	93 87       	std	Z+11, r25	; 0x0b
        m[1*3+0]=v[2];
    4922:	18 96       	adiw	r26, 0x08	; 8
    4924:	6d 91       	ld	r22, X+
    4926:	7d 91       	ld	r23, X+
    4928:	8d 91       	ld	r24, X+
    492a:	9c 91       	ld	r25, X
    492c:	1b 97       	sbiw	r26, 0x0b	; 11
    492e:	64 87       	std	Z+12, r22	; 0x0c
    4930:	75 87       	std	Z+13, r23	; 0x0d
    4932:	86 87       	std	Z+14, r24	; 0x0e
    4934:	97 87       	std	Z+15, r25	; 0x0f
        m[1*3+1]=1;
    4936:	20 8b       	std	Z+16, r18	; 0x10
    4938:	31 8b       	std	Z+17, r19	; 0x11
    493a:	42 8b       	std	Z+18, r20	; 0x12
    493c:	53 8b       	std	Z+19, r21	; 0x13
        m[1*3+2]=-v[0];
    493e:	6d 91       	ld	r22, X+
    4940:	7d 91       	ld	r23, X+
    4942:	8d 91       	ld	r24, X+
    4944:	9c 91       	ld	r25, X
    4946:	13 97       	sbiw	r26, 0x03	; 3
    4948:	90 58       	subi	r25, 0x80	; 128
    494a:	64 8b       	std	Z+20, r22	; 0x14
    494c:	75 8b       	std	Z+21, r23	; 0x15
    494e:	86 8b       	std	Z+22, r24	; 0x16
    4950:	97 8b       	std	Z+23, r25	; 0x17
        m[2*3+0]=-v[1];
    4952:	14 96       	adiw	r26, 0x04	; 4
    4954:	ed 90       	ld	r14, X+
    4956:	fd 90       	ld	r15, X+
    4958:	0d 91       	ld	r16, X+
    495a:	1c 91       	ld	r17, X
    495c:	17 97       	sbiw	r26, 0x07	; 7
    495e:	17 fb       	bst	r17, 7
    4960:	10 95       	com	r17
    4962:	17 f9       	bld	r17, 7
    4964:	10 95       	com	r17
    4966:	e0 8e       	std	Z+24, r14	; 0x18
    4968:	f1 8e       	std	Z+25, r15	; 0x19
    496a:	02 8f       	std	Z+26, r16	; 0x1a
    496c:	13 8f       	std	Z+27, r17	; 0x1b
        m[2*3+1]=v[0];
    496e:	8d 91       	ld	r24, X+
    4970:	9d 91       	ld	r25, X+
    4972:	0d 90       	ld	r0, X+
    4974:	bc 91       	ld	r27, X
    4976:	a0 2d       	mov	r26, r0
    4978:	84 8f       	std	Z+28, r24	; 0x1c
    497a:	95 8f       	std	Z+29, r25	; 0x1d
    497c:	a6 8f       	std	Z+30, r26	; 0x1e
    497e:	b7 8f       	std	Z+31, r27	; 0x1f
        m[2*3+2]=1;
    4980:	20 a3       	std	Z+32, r18	; 0x20
    4982:	31 a3       	std	Z+33, r19	; 0x21
    4984:	42 a3       	std	Z+34, r20	; 0x22
    4986:	53 a3       	std	Z+35, r21	; 0x23
}
    4988:	1f 91       	pop	r17
    498a:	0f 91       	pop	r16
    498c:	ff 90       	pop	r15
    498e:	ef 90       	pop	r14
    4990:	08 95       	ret

00004992 <Motor_GenerateOutputSignal>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    4992:	f8 94       	cli
	
	// Make sure we have spent enough time between pulses
	// Also, handle the odd case where the TCNT2_X rolls over and TCNT2_X < ElapsedTCNT2
	ATOMIC_BLOCK(ATOMIC_FORCEON)
   {
      CurrentTCNT2 = TCNT2_X;
    4994:	80 91 bd 05 	lds	r24, 0x05BD
    4998:	90 91 be 05 	lds	r25, 0x05BE
    499c:	90 93 cf 07 	sts	0x07CF, r25
    49a0:	80 93 ce 07 	sts	0x07CE, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    49a4:	78 94       	sei
   }

   if (CurrentTCNT2 >= MotorStartTCNT) 
    49a6:	20 91 ce 07 	lds	r18, 0x07CE
    49aa:	30 91 cf 07 	lds	r19, 0x07CF
    49ae:	80 91 c1 07 	lds	r24, 0x07C1
    49b2:	90 91 c2 07 	lds	r25, 0x07C2
    49b6:	28 17       	cp	r18, r24
    49b8:	39 07       	cpc	r19, r25
    49ba:	38 f0       	brcs	.+14     	; 0x49ca <Motor_GenerateOutputSignal+0x38>
   {
		ElapsedTCNT2 = CurrentTCNT2 - MotorStartTCNT;
    49bc:	28 1b       	sub	r18, r24
    49be:	39 0b       	sbc	r19, r25
    49c0:	30 93 bc 07 	sts	0x07BC, r19
    49c4:	20 93 bb 07 	sts	0x07BB, r18
    49c8:	08 c0       	rjmp	.+16     	; 0x49da <Motor_GenerateOutputSignal+0x48>
   }
   else 
   {
		ElapsedTCNT2 = (0xffff - MotorStartTCNT) + CurrentTCNT2;
    49ca:	80 95       	com	r24
    49cc:	90 95       	com	r25
    49ce:	82 0f       	add	r24, r18
    49d0:	93 1f       	adc	r25, r19
    49d2:	90 93 bc 07 	sts	0x07BC, r25
    49d6:	80 93 bb 07 	sts	0x07BB, r24
	
	// If period less than 1/ESC_RATE, pad it out.
	// check Timer.c for timing table
	
	//interval in us
	PMW_Pulse_Interval = (PWM_LOW_PULSE_INTERVAL - ( ElapsedTCNT2 * 409)); // 409 = OV time of TCNT2
    49da:	40 91 bb 07 	lds	r20, 0x07BB
    49de:	50 91 bc 07 	lds	r21, 0x07BC
    49e2:	89 e9       	ldi	r24, 0x99	; 153
    49e4:	91 e0       	ldi	r25, 0x01	; 1
    49e6:	48 9f       	mul	r20, r24
    49e8:	90 01       	movw	r18, r0
    49ea:	49 9f       	mul	r20, r25
    49ec:	30 0d       	add	r19, r0
    49ee:	58 9f       	mul	r21, r24
    49f0:	30 0d       	add	r19, r0
    49f2:	11 24       	eor	r1, r1
    49f4:	80 ea       	ldi	r24, 0xA0	; 160
    49f6:	9f e0       	ldi	r25, 0x0F	; 15
    49f8:	82 1b       	sub	r24, r18
    49fa:	93 0b       	sbc	r25, r19
    49fc:	0d c0       	rjmp	.+26     	; 0x4a18 <Motor_GenerateOutputSignal+0x86>
	while (PMW_Pulse_Interval > 0)
	{
		//LED_Orange=~LED_Orange;
			TCNT2 =0;
    49fe:	10 92 b2 00 	sts	0x00B2, r1
			if (PMW_Pulse_Interval>100)
    4a02:	85 36       	cpi	r24, 0x65	; 101
    4a04:	91 05       	cpc	r25, r1
    4a06:	3c f0       	brlt	.+14     	; 0x4a16 <Motor_GenerateOutputSignal+0x84>
			{   // make big jumps if PWM_Low_Pulse_Interval is high
				// [more accurate to decrease the % between the while loop and the PWM_Low_Pulse_Interval -=80 execution time.]
				while (TCNT2 < 40); //=8us 1.50
    4a08:	20 91 b2 00 	lds	r18, 0x00B2
    4a0c:	28 32       	cpi	r18, 0x28	; 40
    4a0e:	e0 f3       	brcs	.-8      	; 0x4a08 <Motor_GenerateOutputSignal+0x76>
				PMW_Pulse_Interval -=80;	
    4a10:	80 55       	subi	r24, 0x50	; 80
    4a12:	90 40       	sbci	r25, 0x00	; 0
    4a14:	01 c0       	rjmp	.+2      	; 0x4a18 <Motor_GenerateOutputSignal+0x86>
			}
			else
			{   //
				///////////while (TCNT2 < 5); //=8us
				PMW_Pulse_Interval -=1;
    4a16:	01 97       	sbiw	r24, 0x01	; 1
    4a18:	90 93 c7 07 	sts	0x07C7, r25
    4a1c:	80 93 c6 07 	sts	0x07C6, r24
	// If period less than 1/ESC_RATE, pad it out.
	// check Timer.c for timing table
	
	//interval in us
	PMW_Pulse_Interval = (PWM_LOW_PULSE_INTERVAL - ( ElapsedTCNT2 * 409)); // 409 = OV time of TCNT2
	while (PMW_Pulse_Interval > 0)
    4a20:	80 91 c6 07 	lds	r24, 0x07C6
    4a24:	90 91 c7 07 	lds	r25, 0x07C7
    4a28:	18 16       	cp	r1, r24
    4a2a:	19 06       	cpc	r1, r25
    4a2c:	44 f3       	brlt	.-48     	; 0x49fe <Motor_GenerateOutputSignal+0x6c>
				PMW_Pulse_Interval -=1;
			}
			
	}
	
	times+=1;
    4a2e:	80 91 30 05 	lds	r24, 0x0530
    4a32:	8f 5f       	subi	r24, 0xFF	; 255
    4a34:	80 93 30 05 	sts	0x0530, r24
	
	// Set motor limits (0 -> MOTORS_HIGH_VALUE)
	if ( MotorOut[0] < 0 ) m1 = 0;
    4a38:	80 91 98 05 	lds	r24, 0x0598
    4a3c:	90 91 99 05 	lds	r25, 0x0599
    4a40:	97 ff       	sbrs	r25, 7
    4a42:	05 c0       	rjmp	.+10     	; 0x4a4e <Motor_GenerateOutputSignal+0xbc>
    4a44:	10 92 c9 07 	sts	0x07C9, r1
    4a48:	10 92 c8 07 	sts	0x07C8, r1
    4a4c:	0a c0       	rjmp	.+20     	; 0x4a62 <Motor_GenerateOutputSignal+0xd0>
	else if ( MotorOut[0] > MOTORS_HIGH_VALUE ) m1 = MOTORS_HIGH_VALUE;
    4a4e:	24 e0       	ldi	r18, 0x04	; 4
    4a50:	8f 37       	cpi	r24, 0x7F	; 127
    4a52:	92 07       	cpc	r25, r18
    4a54:	14 f0       	brlt	.+4      	; 0x4a5a <Motor_GenerateOutputSignal+0xc8>
    4a56:	8e e7       	ldi	r24, 0x7E	; 126
    4a58:	94 e0       	ldi	r25, 0x04	; 4
	else m1 = MotorOut[0];
    4a5a:	90 93 c9 07 	sts	0x07C9, r25
    4a5e:	80 93 c8 07 	sts	0x07C8, r24
	
	if ( MotorOut[1] < 0 ) m2 = 0;
    4a62:	80 91 9a 05 	lds	r24, 0x059A
    4a66:	90 91 9b 05 	lds	r25, 0x059B
    4a6a:	97 ff       	sbrs	r25, 7
    4a6c:	05 c0       	rjmp	.+10     	; 0x4a78 <Motor_GenerateOutputSignal+0xe6>
    4a6e:	10 92 c0 07 	sts	0x07C0, r1
    4a72:	10 92 bf 07 	sts	0x07BF, r1
    4a76:	0a c0       	rjmp	.+20     	; 0x4a8c <Motor_GenerateOutputSignal+0xfa>
	else if ( MotorOut[1] > MOTORS_HIGH_VALUE ) m2 = MOTORS_HIGH_VALUE;
    4a78:	24 e0       	ldi	r18, 0x04	; 4
    4a7a:	8f 37       	cpi	r24, 0x7F	; 127
    4a7c:	92 07       	cpc	r25, r18
    4a7e:	14 f0       	brlt	.+4      	; 0x4a84 <Motor_GenerateOutputSignal+0xf2>
    4a80:	8e e7       	ldi	r24, 0x7E	; 126
    4a82:	94 e0       	ldi	r25, 0x04	; 4
	else m2 = MotorOut[1];
    4a84:	90 93 c0 07 	sts	0x07C0, r25
    4a88:	80 93 bf 07 	sts	0x07BF, r24

	if ( MotorOut[2] < 0 ) m3 = 0;
    4a8c:	80 91 9c 05 	lds	r24, 0x059C
    4a90:	90 91 9d 05 	lds	r25, 0x059D
    4a94:	97 ff       	sbrs	r25, 7
    4a96:	05 c0       	rjmp	.+10     	; 0x4aa2 <Motor_GenerateOutputSignal+0x110>
    4a98:	10 92 cd 07 	sts	0x07CD, r1
    4a9c:	10 92 cc 07 	sts	0x07CC, r1
    4aa0:	0a c0       	rjmp	.+20     	; 0x4ab6 <Motor_GenerateOutputSignal+0x124>
	else if ( MotorOut[2] > MOTORS_HIGH_VALUE ) m3 = MOTORS_HIGH_VALUE;
    4aa2:	24 e0       	ldi	r18, 0x04	; 4
    4aa4:	8f 37       	cpi	r24, 0x7F	; 127
    4aa6:	92 07       	cpc	r25, r18
    4aa8:	14 f0       	brlt	.+4      	; 0x4aae <Motor_GenerateOutputSignal+0x11c>
    4aaa:	8e e7       	ldi	r24, 0x7E	; 126
    4aac:	94 e0       	ldi	r25, 0x04	; 4
	else m3 = MotorOut[2];
    4aae:	90 93 cd 07 	sts	0x07CD, r25
    4ab2:	80 93 cc 07 	sts	0x07CC, r24

	if ( MotorOut[3] < 0 ) m4 = 0;
    4ab6:	80 91 9e 05 	lds	r24, 0x059E
    4aba:	90 91 9f 05 	lds	r25, 0x059F
    4abe:	97 ff       	sbrs	r25, 7
    4ac0:	05 c0       	rjmp	.+10     	; 0x4acc <Motor_GenerateOutputSignal+0x13a>
    4ac2:	10 92 be 07 	sts	0x07BE, r1
    4ac6:	10 92 bd 07 	sts	0x07BD, r1
    4aca:	0a c0       	rjmp	.+20     	; 0x4ae0 <Motor_GenerateOutputSignal+0x14e>
	else if ( MotorOut[3] > MOTORS_HIGH_VALUE ) m4 = MOTORS_HIGH_VALUE;
    4acc:	24 e0       	ldi	r18, 0x04	; 4
    4ace:	8f 37       	cpi	r24, 0x7F	; 127
    4ad0:	92 07       	cpc	r25, r18
    4ad2:	14 f0       	brlt	.+4      	; 0x4ad8 <Motor_GenerateOutputSignal+0x146>
    4ad4:	8e e7       	ldi	r24, 0x7E	; 126
    4ad6:	94 e0       	ldi	r25, 0x04	; 4
	else m4 = MotorOut[3];
    4ad8:	90 93 be 07 	sts	0x07BE, r25
    4adc:	80 93 bd 07 	sts	0x07BD, r24
	
	
	// Minimum pulse we want to make is 1ms, max is 2ms
	// So to start, let's make the 1ms base pulse.
	// First, we switch on the motor outputs
	M1 = 1;
    4ae0:	46 9a       	sbi	0x08, 6	; 8
	M2 = 1;
    4ae2:	44 9a       	sbi	0x08, 4	; 8
	M3 = 1;
    4ae4:	42 9a       	sbi	0x08, 2	; 8
	if (Config.FrameType== FRAMETYPE_QUADCOPTER) 
    4ae6:	80 91 d8 06 	lds	r24, 0x06D8
    4aea:	81 30       	cpi	r24, 0x01	; 1
    4aec:	11 f4       	brne	.+4      	; 0x4af2 <Motor_GenerateOutputSignal+0x160>
	{
		M4 =1;
    4aee:	43 9a       	sbi	0x08, 3	; 8
    4af0:	09 c0       	rjmp	.+18     	; 0x4b04 <Motor_GenerateOutputSignal+0x172>
	}
	else if (Config.FrameType== FRAMETYPE_TRICOPTER)
    4af2:	82 30       	cpi	r24, 0x02	; 2
    4af4:	39 f4       	brne	.+14     	; 0x4b04 <Motor_GenerateOutputSignal+0x172>
	{
		if (times==5)
    4af6:	80 91 30 05 	lds	r24, 0x0530
    4afa:	85 30       	cpi	r24, 0x05	; 5
    4afc:	19 f4       	brne	.+6      	; 0x4b04 <Motor_GenerateOutputSignal+0x172>
		{
			M4 = 1;		// time to update servo
    4afe:	43 9a       	sbi	0x08, 3	; 8
			//UpdateServo = FALSE;
			times=0;	// reset time divider
    4b00:	10 92 30 05 	sts	0x0530, r1
		} // else keep it zero.			
	} 
	
	
	// Minimum pulse width we want to make is 1ms, max is 2ms
	PMW_Pulse_Interval = BASE_PULSE + Config.ThrottleMin;
    4b04:	80 91 dc 06 	lds	r24, 0x06DC
    4b08:	90 e0       	ldi	r25, 0x00	; 0
    4b0a:	80 5e       	subi	r24, 0xE0	; 224
    4b0c:	9c 4f       	sbci	r25, 0xFC	; 252
    4b0e:	0d c0       	rjmp	.+26     	; 0x4b2a <Motor_GenerateOutputSignal+0x198>
	while (PMW_Pulse_Interval > 0)
	{
			TCNT2 =0;
    4b10:	10 92 b2 00 	sts	0x00B2, r1
			if (PMW_Pulse_Interval>100)
    4b14:	85 36       	cpi	r24, 0x65	; 101
    4b16:	91 05       	cpc	r25, r1
    4b18:	3c f0       	brlt	.+14     	; 0x4b28 <Motor_GenerateOutputSignal+0x196>
			{   // make big jumps if PWM_Low_Pulse_Interval is high
				// [more accurate to decrease the % between the while loop and the PWM_Low_Pulse_Interval -=80 execution time.]
				while (TCNT2 < 45); //=8us //1. 50
    4b1a:	20 91 b2 00 	lds	r18, 0x00B2
    4b1e:	2d 32       	cpi	r18, 0x2D	; 45
    4b20:	e0 f3       	brcs	.-8      	; 0x4b1a <Motor_GenerateOutputSignal+0x188>
				PMW_Pulse_Interval -=80;	
    4b22:	80 55       	subi	r24, 0x50	; 80
    4b24:	90 40       	sbci	r25, 0x00	; 0
    4b26:	01 c0       	rjmp	.+2      	; 0x4b2a <Motor_GenerateOutputSignal+0x198>
			}
			else
			{   //
				//////while (TCNT2 < 5); //=8us
				PMW_Pulse_Interval -=1;
    4b28:	01 97       	sbiw	r24, 0x01	; 1
    4b2a:	90 93 c7 07 	sts	0x07C7, r25
    4b2e:	80 93 c6 07 	sts	0x07C6, r24
	} 
	
	
	// Minimum pulse width we want to make is 1ms, max is 2ms
	PMW_Pulse_Interval = BASE_PULSE + Config.ThrottleMin;
	while (PMW_Pulse_Interval > 0)
    4b32:	80 91 c6 07 	lds	r24, 0x07C6
    4b36:	90 91 c7 07 	lds	r25, 0x07C7
    4b3a:	18 16       	cp	r1, r24
    4b3c:	19 06       	cpc	r1, r25
    4b3e:	44 f3       	brlt	.-48     	; 0x4b10 <Motor_GenerateOutputSignal+0x17e>
				PMW_Pulse_Interval -=1;
			}
	}
		
	
	for (i=0;i<MOTORS_HIGH_VALUE+4;i+=4)			// 1000 gives a max of 2200us 
    4b40:	10 92 c5 07 	sts	0x07C5, r1
    4b44:	10 92 c4 07 	sts	0x07C4, r1
    4b48:	39 c0       	rjmp	.+114    	; 0x4bbc <Motor_GenerateOutputSignal+0x22a>
		/*
		MOTORS_HIGH_VALUE+4
		in order to guarantee that all Ms are zeros when getting out of this loop.
		*/
		
		if (i>=m1) M1 = 0;
    4b4a:	20 91 c4 07 	lds	r18, 0x07C4
    4b4e:	30 91 c5 07 	lds	r19, 0x07C5
    4b52:	80 91 c8 07 	lds	r24, 0x07C8
    4b56:	90 91 c9 07 	lds	r25, 0x07C9
    4b5a:	28 17       	cp	r18, r24
    4b5c:	39 07       	cpc	r19, r25
    4b5e:	08 f0       	brcs	.+2      	; 0x4b62 <Motor_GenerateOutputSignal+0x1d0>
    4b60:	46 98       	cbi	0x08, 6	; 8
		if (i>=m2) M2 = 0;
    4b62:	20 91 c4 07 	lds	r18, 0x07C4
    4b66:	30 91 c5 07 	lds	r19, 0x07C5
    4b6a:	80 91 bf 07 	lds	r24, 0x07BF
    4b6e:	90 91 c0 07 	lds	r25, 0x07C0
    4b72:	28 17       	cp	r18, r24
    4b74:	39 07       	cpc	r19, r25
    4b76:	08 f0       	brcs	.+2      	; 0x4b7a <Motor_GenerateOutputSignal+0x1e8>
    4b78:	44 98       	cbi	0x08, 4	; 8
		if (i>=m3) M3 = 0;
    4b7a:	20 91 c4 07 	lds	r18, 0x07C4
    4b7e:	30 91 c5 07 	lds	r19, 0x07C5
    4b82:	80 91 cc 07 	lds	r24, 0x07CC
    4b86:	90 91 cd 07 	lds	r25, 0x07CD
    4b8a:	28 17       	cp	r18, r24
    4b8c:	39 07       	cpc	r19, r25
    4b8e:	08 f0       	brcs	.+2      	; 0x4b92 <Motor_GenerateOutputSignal+0x200>
    4b90:	42 98       	cbi	0x08, 2	; 8
		if (i>=m4) M4 = 0;
    4b92:	20 91 c4 07 	lds	r18, 0x07C4
    4b96:	30 91 c5 07 	lds	r19, 0x07C5
    4b9a:	80 91 bd 07 	lds	r24, 0x07BD
    4b9e:	90 91 be 07 	lds	r25, 0x07BE
    4ba2:	28 17       	cp	r18, r24
    4ba4:	39 07       	cpc	r19, r25
    4ba6:	08 f0       	brcs	.+2      	; 0x4baa <Motor_GenerateOutputSignal+0x218>
    4ba8:	43 98       	cbi	0x08, 3	; 8
				PMW_Pulse_Interval -=1;
			}
	}
		
	
	for (i=0;i<MOTORS_HIGH_VALUE+4;i+=4)			// 1000 gives a max of 2200us 
    4baa:	80 91 c4 07 	lds	r24, 0x07C4
    4bae:	90 91 c5 07 	lds	r25, 0x07C5
    4bb2:	04 96       	adiw	r24, 0x04	; 4
    4bb4:	90 93 c5 07 	sts	0x07C5, r25
    4bb8:	80 93 c4 07 	sts	0x07C4, r24
    4bbc:	80 91 c4 07 	lds	r24, 0x07C4
    4bc0:	90 91 c5 07 	lds	r25, 0x07C5
    4bc4:	24 e0       	ldi	r18, 0x04	; 4
    4bc6:	82 38       	cpi	r24, 0x82	; 130
    4bc8:	92 07       	cpc	r25, r18
    4bca:	08 f4       	brcc	.+2      	; 0x4bce <Motor_GenerateOutputSignal+0x23c>
    4bcc:	be cf       	rjmp	.-132    	; 0x4b4a <Motor_GenerateOutputSignal+0x1b8>
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    4bce:	f8 94       	cli
		if (i>=m4) M4 = 0;
	}
	// Measure period of ESC rate from here
    ATOMIC_BLOCK(ATOMIC_FORCEON)
    {
      MotorStartTCNT = TCNT2_X;
    4bd0:	80 91 bd 05 	lds	r24, 0x05BD
    4bd4:	90 91 be 05 	lds	r25, 0x05BE
    4bd8:	90 93 c2 07 	sts	0x07C2, r25
    4bdc:	80 93 c1 07 	sts	0x07C1, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    4be0:	78 94       	sei
    }
	
	
 }
    4be2:	08 95       	ret

00004be4 <CalculateSignalLength1>:



void CalculateSignalLength1(uint8_t ChannelIndex)
{
	if (TCNT1 > RX_raw[0][ChannelIndex] )
    4be4:	20 91 84 00 	lds	r18, 0x0084
    4be8:	30 91 85 00 	lds	r19, 0x0085
    4bec:	90 e0       	ldi	r25, 0x00	; 0
    4bee:	88 0f       	add	r24, r24
    4bf0:	99 1f       	adc	r25, r25
    4bf2:	fc 01       	movw	r30, r24
    4bf4:	e1 52       	subi	r30, 0x21	; 33
    4bf6:	f8 4f       	sbci	r31, 0xF8	; 248
    4bf8:	40 81       	ld	r20, Z
    4bfa:	51 81       	ldd	r21, Z+1	; 0x01
    4bfc:	dc 01       	movw	r26, r24
    4bfe:	a2 53       	subi	r26, 0x32	; 50
    4c00:	ba 4f       	sbci	r27, 0xFA	; 250
    4c02:	42 17       	cp	r20, r18
    4c04:	53 07       	cpc	r21, r19
    4c06:	48 f4       	brcc	.+18     	; 0x4c1a <CalculateSignalLength1+0x36>
	{
		RX_Length[0][ChannelIndex] = TCNT1 - RX_raw[0][ChannelIndex] ;	
    4c08:	20 91 84 00 	lds	r18, 0x0084
    4c0c:	30 91 85 00 	lds	r19, 0x0085
    4c10:	80 81       	ld	r24, Z
    4c12:	91 81       	ldd	r25, Z+1	; 0x01
    4c14:	28 1b       	sub	r18, r24
    4c16:	39 0b       	sbc	r19, r25
    4c18:	0a c0       	rjmp	.+20     	; 0x4c2e <CalculateSignalLength1+0x4a>
	}
	else
	{
		RX_Length[0][ChannelIndex] = (0xffff - RX_raw[0][ChannelIndex] + TCNT1 );	
    4c1a:	20 81       	ld	r18, Z
    4c1c:	31 81       	ldd	r19, Z+1	; 0x01
    4c1e:	80 91 84 00 	lds	r24, 0x0084
    4c22:	90 91 85 00 	lds	r25, 0x0085
    4c26:	20 95       	com	r18
    4c28:	30 95       	com	r19
    4c2a:	28 0f       	add	r18, r24
    4c2c:	39 1f       	adc	r19, r25
    4c2e:	11 96       	adiw	r26, 0x01	; 1
    4c30:	3c 93       	st	X, r19
    4c32:	2e 93       	st	-X, r18
    4c34:	08 95       	ret

00004c36 <CalculateSignalLength2>:
	}
	
}
void CalculateSignalLength2(uint8_t ChannelIndex)
{
	uint16_t TCNT1_TEMP = TCNT1;
    4c36:	20 91 84 00 	lds	r18, 0x0084
    4c3a:	30 91 85 00 	lds	r19, 0x0085
	if (TCNT1_TEMP > RX_raw[1][ChannelIndex] )
    4c3e:	90 e0       	ldi	r25, 0x00	; 0
    4c40:	05 96       	adiw	r24, 0x05	; 5
    4c42:	88 0f       	add	r24, r24
    4c44:	99 1f       	adc	r25, r25
    4c46:	fc 01       	movw	r30, r24
    4c48:	e1 52       	subi	r30, 0x21	; 33
    4c4a:	f8 4f       	sbci	r31, 0xF8	; 248
    4c4c:	40 81       	ld	r20, Z
    4c4e:	51 81       	ldd	r21, Z+1	; 0x01
    4c50:	dc 01       	movw	r26, r24
    4c52:	a2 53       	subi	r26, 0x32	; 50
    4c54:	ba 4f       	sbci	r27, 0xFA	; 250
    4c56:	42 17       	cp	r20, r18
    4c58:	53 07       	cpc	r21, r19
    4c5a:	40 f4       	brcc	.+16     	; 0x4c6c <CalculateSignalLength2+0x36>
	{
		RX_Length[1][ChannelIndex] = TCNT1_TEMP - RX_raw[1][ChannelIndex] ;	
    4c5c:	80 81       	ld	r24, Z
    4c5e:	91 81       	ldd	r25, Z+1	; 0x01
    4c60:	28 1b       	sub	r18, r24
    4c62:	39 0b       	sbc	r19, r25
    4c64:	11 96       	adiw	r26, 0x01	; 1
    4c66:	3c 93       	st	X, r19
    4c68:	2e 93       	st	-X, r18
    4c6a:	08 95       	ret
	}
	else
	{
		RX_Length[1][ChannelIndex] = (0xffff - RX_raw[1][ChannelIndex] + TCNT1_TEMP);	
    4c6c:	40 81       	ld	r20, Z
    4c6e:	51 81       	ldd	r21, Z+1	; 0x01
    4c70:	40 95       	com	r20
    4c72:	50 95       	com	r21
    4c74:	42 0f       	add	r20, r18
    4c76:	53 1f       	adc	r21, r19
    4c78:	11 96       	adiw	r26, 0x01	; 1
    4c7a:	5c 93       	st	X, r21
    4c7c:	4e 93       	st	-X, r20
    4c7e:	08 95       	ret

00004c80 <RX_Init>:


void RX_Init(void)
{
	
	RX_AUX_DIR   	 	= INPUT;
    4c80:	20 98       	cbi	0x04, 0	; 4

#ifdef PRIMARY_INPUT_RX

	if (Config.RX_mode==RX_mode_BuddyMode)
    4c82:	80 91 d3 06 	lds	r24, 0x06D3
    4c86:	88 23       	and	r24, r24
    4c88:	f1 f4       	brne	.+60     	; 0x4cc6 <RX_Init+0x46>
	{
	
		ActiveRXIndex=0;
    4c8a:	10 92 cc 05 	sts	0x05CC, r1
		RX1_ROLL_DIR 		= INPUT;
    4c8e:	52 98       	cbi	0x0a, 2	; 10
		RX1_PITCH_DIR 		= INPUT;
    4c90:	50 98       	cbi	0x0a, 0	; 10
		RX1_COLL_DIR   		= INPUT;
    4c92:	53 98       	cbi	0x0a, 3	; 10
		RX1_YAW_DIR   	 	= INPUT;
    4c94:	22 98       	cbi	0x04, 2	; 4

		// enable interrupts
		EICRA  = _BV(ISC00) | _BV(ISC10) | _BV(ISC20);	// any edge on INT0, INT1 and INT2
    4c96:	85 e1       	ldi	r24, 0x15	; 21
    4c98:	80 93 69 00 	sts	0x0069, r24
		EIMSK  = _BV(INT0)  | _BV(INT1)  | _BV(INT2);	// enable interrupt for INT0, INT1 and INT2
    4c9c:	87 e0       	ldi	r24, 0x07	; 7
    4c9e:	8d bb       	out	0x1d, r24	; 29
		EIFR   = _BV(INTF0) | _BV(INTF1) | _BV(INTF2);	// clear interrupts
    4ca0:	8c bb       	out	0x1c, r24	; 28
		
		PCICR  |= _BV(PCIE1) | _BV(PCIE3);				// enable PCI1 and PCI3
    4ca2:	80 91 68 00 	lds	r24, 0x0068
    4ca6:	8a 60       	ori	r24, 0x0A	; 10
    4ca8:	80 93 68 00 	sts	0x0068, r24
		PCMSK1 |= _BV(PCINT8);							// enable PCINT8 (AUX) -> PCI1
    4cac:	80 91 6c 00 	lds	r24, 0x006C
    4cb0:	81 60       	ori	r24, 0x01	; 1
    4cb2:	80 93 6c 00 	sts	0x006C, r24
		PCMSK3 |= _BV(PCINT24);							// enable PCINT24 (THR) -> PCI3
    4cb6:	80 91 73 00 	lds	r24, 0x0073
    4cba:	81 60       	ori	r24, 0x01	; 1
    4cbc:	80 93 73 00 	sts	0x0073, r24
		PCIFR  |= _BV(PCIF1) | _BV(PCIF3);
    4cc0:	8b b3       	in	r24, 0x1b	; 27
    4cc2:	8a 60       	ori	r24, 0x0A	; 10
    4cc4:	8b bb       	out	0x1b, r24	; 27
#endif

	
#ifdef SECONDARY_INPUT_RX

	ActiveRXIndex=1;
    4cc6:	81 e0       	ldi	r24, 0x01	; 1
    4cc8:	80 93 cc 05 	sts	0x05CC, r24
	RX2_ROLL_DIR 		= INPUT;
    4ccc:	3d 98       	cbi	0x07, 5	; 7
	RX2_PITCH_DIR 		= INPUT;
    4cce:	38 98       	cbi	0x07, 0	; 7
	RX2_COLL_DIR   		= INPUT;
    4cd0:	3f 98       	cbi	0x07, 7	; 7
	RX2_YAW_DIR   	 	= INPUT;
    4cd2:	39 98       	cbi	0x07, 1	; 7
	PCINT16 - PC0 - OUTPUT 6
	PCINT17 - PC1 - OUTPUT 5 
	PCINT21 - PC5 - OUTPUT 7
	PCINT23 - PC7 - OUTPUT 8 
	*/
	PCICR  |= _BV(PCIE1)   | _BV(PCIE2);														// enable PCI1 and PCI2
    4cd4:	80 91 68 00 	lds	r24, 0x0068
    4cd8:	86 60       	ori	r24, 0x06	; 6
    4cda:	80 93 68 00 	sts	0x0068, r24
	PCMSK1 |= _BV(PCINT8);																		// enable PCINT8 (AUX) -> PCI1
    4cde:	80 91 6c 00 	lds	r24, 0x006C
    4ce2:	81 60       	ori	r24, 0x01	; 1
    4ce4:	80 93 6c 00 	sts	0x006C, r24
	PCMSK2 |= _BV(PCINT16) | _BV(PCINT17) | _BV(PCINT21) |_BV(PCINT23);							// enable PCINT24 (THR) -> PCI3
    4ce8:	80 91 6d 00 	lds	r24, 0x006D
    4cec:	83 6a       	ori	r24, 0xA3	; 163
    4cee:	80 93 6d 00 	sts	0x006D, r24
	PCIFR  |= _BV(PCIF1)   | _BV(PCIF2);														// clear interrupts
    4cf2:	8b b3       	in	r24, 0x1b	; 27
    4cf4:	86 60       	ori	r24, 0x06	; 6
    4cf6:	8b bb       	out	0x1b, r24	; 27
#endif
	

		
	
	RX_Good =TX1_NOT_FOUND;
    4cf8:	80 91 b8 07 	lds	r24, 0x07B8
    4cfc:	81 60       	ori	r24, 0x01	; 1
    4cfe:	80 93 b8 07 	sts	0x07B8, r24
	RX_Good =TX2_NOT_FOUND;
    4d02:	80 91 b8 07 	lds	r24, 0x07B8
    4d06:	80 61       	ori	r24, 0x10	; 16
    4d08:	80 93 b8 07 	sts	0x07B8, r24
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    4d0c:	f8 94       	cli
	
	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		RX1_LastValidSignal_timestamp= TCNT1_X;
    4d0e:	80 91 5e 06 	lds	r24, 0x065E
    4d12:	90 91 5f 06 	lds	r25, 0x065F
    4d16:	90 93 d7 07 	sts	0x07D7, r25
    4d1a:	80 93 d6 07 	sts	0x07D6, r24
		RX1_LastValidSignal_timestampAux= TCNT1_X;
    4d1e:	80 91 5e 06 	lds	r24, 0x065E
    4d22:	90 91 5f 06 	lds	r25, 0x065F
    4d26:	90 93 d9 07 	sts	0x07D9, r25
    4d2a:	80 93 d8 07 	sts	0x07D8, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    4d2e:	78 94       	sei
	}	
	
	RX2_LastValidSignal_timestamp= RX2_LastValidSignal_timestamp;
    4d30:	80 91 d4 07 	lds	r24, 0x07D4
    4d34:	90 91 d5 07 	lds	r25, 0x07D5
    4d38:	90 93 d5 07 	sts	0x07D5, r25
    4d3c:	80 93 d4 07 	sts	0x07D4, r24
	RX2_LastValidSignal_timestampAux= RX2_LastValidSignal_timestampAux;	
    4d40:	80 91 d0 07 	lds	r24, 0x07D0
    4d44:	90 91 d1 07 	lds	r25, 0x07D1
    4d48:	90 93 d1 07 	sts	0x07D1, r25
    4d4c:	80 93 d0 07 	sts	0x07D0, r24
}
    4d50:	08 95       	ret

00004d52 <RX_raw_GetReceiverValues>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    4d52:	f8 94       	cli
  uint16_t RX_raw_GetReceiverValues (uint8_t RXIndex, uint8_t Channel)
{
	uint16_t _t;
	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		_t = RX_Length[RXIndex][Channel];
    4d54:	90 e0       	ldi	r25, 0x00	; 0
    4d56:	fc 01       	movw	r30, r24
    4d58:	ee 0f       	add	r30, r30
    4d5a:	ff 1f       	adc	r31, r31
    4d5c:	ee 0f       	add	r30, r30
    4d5e:	ff 1f       	adc	r31, r31
    4d60:	e8 0f       	add	r30, r24
    4d62:	f9 1f       	adc	r31, r25
    4d64:	e6 0f       	add	r30, r22
    4d66:	f1 1d       	adc	r31, r1
    4d68:	ee 0f       	add	r30, r30
    4d6a:	ff 1f       	adc	r31, r31
    4d6c:	e2 53       	subi	r30, 0x32	; 50
    4d6e:	fa 4f       	sbci	r31, 0xFA	; 250
    4d70:	20 81       	ld	r18, Z
    4d72:	31 81       	ldd	r19, Z+1	; 0x01
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    4d74:	78 94       	sei
	}		
	return _t;
}
    4d76:	c9 01       	movw	r24, r18
    4d78:	08 95       	ret

00004d7a <RX_GetReceiverValues>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    4d7a:	f8 94       	cli
{
	int16_t _t;
	//////if (RX_Good != TX_GOOD) return 0;
	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		_t = ((int)(RX_Length[RXIndex][Channel]));
    4d7c:	90 e0       	ldi	r25, 0x00	; 0
    4d7e:	70 e0       	ldi	r23, 0x00	; 0
    4d80:	9c 01       	movw	r18, r24
    4d82:	22 0f       	add	r18, r18
    4d84:	33 1f       	adc	r19, r19
    4d86:	22 0f       	add	r18, r18
    4d88:	33 1f       	adc	r19, r19
    4d8a:	28 0f       	add	r18, r24
    4d8c:	39 1f       	adc	r19, r25
    4d8e:	a9 01       	movw	r20, r18
    4d90:	46 0f       	add	r20, r22
    4d92:	57 1f       	adc	r21, r23
    4d94:	44 0f       	add	r20, r20
    4d96:	55 1f       	adc	r21, r21
    4d98:	fa 01       	movw	r30, r20
    4d9a:	e2 53       	subi	r30, 0x32	; 50
    4d9c:	fa 4f       	sbci	r31, 0xFA	; 250
    4d9e:	80 81       	ld	r24, Z
    4da0:	91 81       	ldd	r25, Z+1	; 0x01
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    4da2:	78 94       	sei
	}		
	_t -= Config.RX_Mid[RXIndex][Channel];
    4da4:	48 5d       	subi	r20, 0xD8	; 216
    4da6:	58 4f       	sbci	r21, 0xF8	; 248
    4da8:	fa 01       	movw	r30, r20
    4daa:	40 81       	ld	r20, Z
    4dac:	51 81       	ldd	r21, Z+1	; 0x01
    4dae:	84 1b       	sub	r24, r20
    4db0:	95 0b       	sbc	r25, r21
	_t /=Config.RX_DiV_Value[RXIndex][Channel]; //RX_Div_Factor;
    4db2:	26 0f       	add	r18, r22
    4db4:	37 1f       	adc	r19, r23
    4db6:	2e 59       	subi	r18, 0x9E	; 158
    4db8:	38 4f       	sbci	r19, 0xF8	; 248
    4dba:	f9 01       	movw	r30, r18
    4dbc:	60 81       	ld	r22, Z
    4dbe:	77 27       	eor	r23, r23
    4dc0:	67 fd       	sbrc	r22, 7
    4dc2:	70 95       	com	r23
    4dc4:	0e 94 aa 3a 	call	0x7554	; 0x7554 <__divmodhi4>
	return _t;
}
    4dc8:	cb 01       	movw	r24, r22
    4dca:	08 95       	ret

00004dcc <RX_GetReceiverThrottleValue>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    4dcc:	f8 94       	cli
	
	///if (RX_Good != TX_GOOD) return 0;
	
	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		if (RXIndex==0)
    4dce:	88 23       	and	r24, r24
    4dd0:	11 f5       	brne	.+68     	; 0x4e16 <RX_GetReceiverThrottleValue+0x4a>
		{
			if ( (TCNT1_X - RX1_LastValidSignal_timestamp) > RX_SIGNAL_LOST_DURATION)
    4dd2:	40 91 5e 06 	lds	r20, 0x065E
    4dd6:	50 91 5f 06 	lds	r21, 0x065F
    4dda:	60 91 d6 07 	lds	r22, 0x07D6
    4dde:	70 91 d7 07 	lds	r23, 0x07D7
    4de2:	46 1b       	sub	r20, r22
    4de4:	57 0b       	sbc	r21, r23
    4de6:	45 31       	cpi	r20, 0x15	; 21
    4de8:	51 05       	cpc	r21, r1
    4dea:	20 f0       	brcs	.+8      	; 0x4df4 <RX_GetReceiverThrottleValue+0x28>
			{
				RX_Good =TX1_NOT_FOUND;
    4dec:	80 91 b8 07 	lds	r24, 0x07B8
    4df0:	81 60       	ori	r24, 0x01	; 1
    4df2:	34 c0       	rjmp	.+104    	; 0x4e5c <RX_GetReceiverThrottleValue+0x90>
				return 0;
			}	
		
			if ( (TCNT1_X - RX1_LastValidSignal_timestampAux) > RX_SIGNAL_LOST_DURATION)
    4df4:	40 91 5e 06 	lds	r20, 0x065E
    4df8:	50 91 5f 06 	lds	r21, 0x065F
    4dfc:	60 91 d8 07 	lds	r22, 0x07D8
    4e00:	70 91 d9 07 	lds	r23, 0x07D9
    4e04:	46 1b       	sub	r20, r22
    4e06:	57 0b       	sbc	r21, r23
    4e08:	45 31       	cpi	r20, 0x15	; 21
    4e0a:	51 05       	cpc	r21, r1
    4e0c:	68 f1       	brcs	.+90     	; 0x4e68 <RX_GetReceiverThrottleValue+0x9c>
			{
				RX_Good =TX1_DISCONNECTED;
    4e0e:	80 91 b8 07 	lds	r24, 0x07B8
    4e12:	82 60       	ori	r24, 0x02	; 2
    4e14:	23 c0       	rjmp	.+70     	; 0x4e5c <RX_GetReceiverThrottleValue+0x90>
				return 0;
			}
		}	
		if (RXIndex==1)
    4e16:	81 30       	cpi	r24, 0x01	; 1
    4e18:	39 f5       	brne	.+78     	; 0x4e68 <RX_GetReceiverThrottleValue+0x9c>
		{
			if ( (TCNT1_X - RX2_LastValidSignal_timestamp) > RX_SIGNAL_LOST_DURATION)
    4e1a:	40 91 5e 06 	lds	r20, 0x065E
    4e1e:	50 91 5f 06 	lds	r21, 0x065F
    4e22:	60 91 d4 07 	lds	r22, 0x07D4
    4e26:	70 91 d5 07 	lds	r23, 0x07D5
    4e2a:	46 1b       	sub	r20, r22
    4e2c:	57 0b       	sbc	r21, r23
    4e2e:	45 31       	cpi	r20, 0x15	; 21
    4e30:	51 05       	cpc	r21, r1
    4e32:	20 f0       	brcs	.+8      	; 0x4e3c <RX_GetReceiverThrottleValue+0x70>
			{
				RX_Good =TX2_NOT_FOUND;
    4e34:	80 91 b8 07 	lds	r24, 0x07B8
    4e38:	80 61       	ori	r24, 0x10	; 16
    4e3a:	10 c0       	rjmp	.+32     	; 0x4e5c <RX_GetReceiverThrottleValue+0x90>
				return 0;
			}	
		
			if ( (TCNT1_X - RX2_LastValidSignal_timestampAux) > RX_SIGNAL_LOST_DURATION)
    4e3c:	40 91 5e 06 	lds	r20, 0x065E
    4e40:	50 91 5f 06 	lds	r21, 0x065F
    4e44:	60 91 d0 07 	lds	r22, 0x07D0
    4e48:	70 91 d1 07 	lds	r23, 0x07D1
    4e4c:	46 1b       	sub	r20, r22
    4e4e:	57 0b       	sbc	r21, r23
    4e50:	45 31       	cpi	r20, 0x15	; 21
    4e52:	51 05       	cpc	r21, r1
    4e54:	48 f0       	brcs	.+18     	; 0x4e68 <RX_GetReceiverThrottleValue+0x9c>
			{
				RX_Good =TX2_DISCONNECTED;
    4e56:	80 91 b8 07 	lds	r24, 0x07B8
    4e5a:	80 62       	ori	r24, 0x20	; 32
    4e5c:	80 93 b8 07 	sts	0x07B8, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    4e60:	78 94       	sei
    __asm__ volatile ("" ::: "memory");
    4e62:	20 e0       	ldi	r18, 0x00	; 0
    4e64:	30 e0       	ldi	r19, 0x00	; 0
    4e66:	41 c0       	rjmp	.+130    	; 0x4eea <RX_GetReceiverThrottleValue+0x11e>
				return 0;
			}
		}			
		
		
		iTemp16 = ((int)(RX_Length[RXIndex][RXChannel_THR]));
    4e68:	28 2f       	mov	r18, r24
    4e6a:	30 e0       	ldi	r19, 0x00	; 0
    4e6c:	c9 01       	movw	r24, r18
    4e6e:	88 0f       	add	r24, r24
    4e70:	99 1f       	adc	r25, r25
    4e72:	a9 01       	movw	r20, r18
    4e74:	b3 e0       	ldi	r27, 0x03	; 3
    4e76:	44 0f       	add	r20, r20
    4e78:	55 1f       	adc	r21, r21
    4e7a:	ba 95       	dec	r27
    4e7c:	e1 f7       	brne	.-8      	; 0x4e76 <RX_GetReceiverThrottleValue+0xaa>
    4e7e:	84 0f       	add	r24, r20
    4e80:	95 1f       	adc	r25, r21
    4e82:	fc 01       	movw	r30, r24
    4e84:	e2 53       	subi	r30, 0x32	; 50
    4e86:	fa 4f       	sbci	r31, 0xFA	; 250
    4e88:	46 81       	ldd	r20, Z+6	; 0x06
    4e8a:	57 81       	ldd	r21, Z+7	; 0x07
    4e8c:	50 93 db 07 	sts	0x07DB, r21
    4e90:	40 93 da 07 	sts	0x07DA, r20
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    4e94:	78 94       	sei
	}		
	
	iTemp16 -= Config.RX_Min[RXIndex][RXChannel_THR];
    4e96:	40 91 da 07 	lds	r20, 0x07DA
    4e9a:	50 91 db 07 	lds	r21, 0x07DB
    4e9e:	8e 5b       	subi	r24, 0xBE	; 190
    4ea0:	98 4f       	sbci	r25, 0xF8	; 248
    4ea2:	fc 01       	movw	r30, r24
    4ea4:	80 81       	ld	r24, Z
    4ea6:	91 81       	ldd	r25, Z+1	; 0x01
    4ea8:	48 1b       	sub	r20, r24
    4eaa:	59 0b       	sbc	r21, r25
    4eac:	50 93 db 07 	sts	0x07DB, r21
    4eb0:	40 93 da 07 	sts	0x07DA, r20
	iTemp16 /= Config.RX_DiV_Value[RXIndex][RXChannel_THR]; //RX_Div_Factor;
    4eb4:	80 91 da 07 	lds	r24, 0x07DA
    4eb8:	90 91 db 07 	lds	r25, 0x07DB
    4ebc:	f9 01       	movw	r30, r18
    4ebe:	ee 0f       	add	r30, r30
    4ec0:	ff 1f       	adc	r31, r31
    4ec2:	ee 0f       	add	r30, r30
    4ec4:	ff 1f       	adc	r31, r31
    4ec6:	e2 0f       	add	r30, r18
    4ec8:	f3 1f       	adc	r31, r19
    4eca:	eb 59       	subi	r30, 0x9B	; 155
    4ecc:	f8 4f       	sbci	r31, 0xF8	; 248
    4ece:	60 81       	ld	r22, Z
    4ed0:	77 27       	eor	r23, r23
    4ed2:	67 fd       	sbrc	r22, 7
    4ed4:	70 95       	com	r23
    4ed6:	0e 94 aa 3a 	call	0x7554	; 0x7554 <__divmodhi4>
    4eda:	70 93 db 07 	sts	0x07DB, r23
    4ede:	60 93 da 07 	sts	0x07DA, r22
	 
	return iTemp16;
    4ee2:	20 91 da 07 	lds	r18, 0x07DA
    4ee6:	30 91 db 07 	lds	r19, 0x07DB
}
    4eea:	c9 01       	movw	r24, r18
    4eec:	08 95       	ret

00004eee <RX_CopyLatestReceiverValues>:
 
void RX_CopyLatestReceiverValues (void)
{
    4eee:	cf 92       	push	r12
    4ef0:	df 92       	push	r13
    4ef2:	ef 92       	push	r14
    4ef4:	ff 92       	push	r15
    4ef6:	0f 93       	push	r16
    4ef8:	1f 93       	push	r17
    4efa:	cf 93       	push	r28
    4efc:	df 93       	push	r29
	for (int ch=0;ch<2;++ch)
    4efe:	c0 e0       	ldi	r28, 0x00	; 0
    4f00:	d0 e0       	ldi	r29, 0x00	; 0
    4f02:	2d c0       	rjmp	.+90     	; 0x4f5e <RX_CopyLatestReceiverValues+0x70>
	{
		for (int i=0;i<RXChannels;++i)
		{
			if (i == RXChannel_THR)
    4f04:	03 30       	cpi	r16, 0x03	; 3
    4f06:	11 05       	cpc	r17, r1
    4f08:	39 f4       	brne	.+14     	; 0x4f18 <RX_CopyLatestReceiverValues+0x2a>
			{
				RX_Latest[ch][i]= RX_GetReceiverThrottleValue(ch);	 
    4f0a:	8c 2f       	mov	r24, r28
    4f0c:	0e 94 e6 26 	call	0x4dcc	; 0x4dcc <RX_GetReceiverThrottleValue>
    4f10:	f7 01       	movw	r30, r14
    4f12:	91 83       	std	Z+1, r25	; 0x01
    4f14:	80 83       	st	Z, r24
    4f16:	1a c0       	rjmp	.+52     	; 0x4f4c <RX_CopyLatestReceiverValues+0x5e>
			}
			else
			{
				RX_Latest[ch][i]= RX_GetReceiverValues(ch,i);	 
    4f18:	8c 2f       	mov	r24, r28
    4f1a:	60 2f       	mov	r22, r16
    4f1c:	0e 94 bd 26 	call	0x4d7a	; 0x4d7a <RX_GetReceiverValues>
    4f20:	f6 01       	movw	r30, r12
    4f22:	e0 0f       	add	r30, r16
    4f24:	f1 1f       	adc	r31, r17
    4f26:	ee 0f       	add	r30, r30
    4f28:	ff 1f       	adc	r31, r31
    4f2a:	ec 5f       	subi	r30, 0xFC	; 252
    4f2c:	f9 4f       	sbci	r31, 0xF9	; 249
    4f2e:	91 83       	std	Z+1, r25	; 0x01
    4f30:	80 83       	st	Z, r24
				if ((RX_Latest[ch][i]<STICK_DEADBAND) && (RX_Latest[ch][i]>-STICK_DEADBAND)) RX_Latest[ch][i]=0;
    4f32:	80 81       	ld	r24, Z
    4f34:	91 81       	ldd	r25, Z+1	; 0x01
    4f36:	8f 30       	cpi	r24, 0x0F	; 15
    4f38:	91 05       	cpc	r25, r1
    4f3a:	44 f4       	brge	.+16     	; 0x4f4c <RX_CopyLatestReceiverValues+0x5e>
    4f3c:	80 81       	ld	r24, Z
    4f3e:	91 81       	ldd	r25, Z+1	; 0x01
    4f40:	3f ef       	ldi	r19, 0xFF	; 255
    4f42:	82 3f       	cpi	r24, 0xF2	; 242
    4f44:	93 07       	cpc	r25, r19
    4f46:	14 f0       	brlt	.+4      	; 0x4f4c <RX_CopyLatestReceiverValues+0x5e>
    4f48:	11 82       	std	Z+1, r1	; 0x01
    4f4a:	10 82       	st	Z, r1
 
void RX_CopyLatestReceiverValues (void)
{
	for (int ch=0;ch<2;++ch)
	{
		for (int i=0;i<RXChannels;++i)
    4f4c:	0f 5f       	subi	r16, 0xFF	; 255
    4f4e:	1f 4f       	sbci	r17, 0xFF	; 255
    4f50:	05 30       	cpi	r16, 0x05	; 5
    4f52:	11 05       	cpc	r17, r1
    4f54:	b9 f6       	brne	.-82     	; 0x4f04 <RX_CopyLatestReceiverValues+0x16>
	return iTemp16;
}
 
void RX_CopyLatestReceiverValues (void)
{
	for (int ch=0;ch<2;++ch)
    4f56:	21 96       	adiw	r28, 0x01	; 1
    4f58:	c2 30       	cpi	r28, 0x02	; 2
    4f5a:	d1 05       	cpc	r29, r1
    4f5c:	c9 f0       	breq	.+50     	; 0x4f90 <RX_CopyLatestReceiverValues+0xa2>
	 
	return iTemp16;
}
 
void RX_CopyLatestReceiverValues (void)
{
    4f5e:	00 e0       	ldi	r16, 0x00	; 0
    4f60:	10 e0       	ldi	r17, 0x00	; 0
			{
				RX_Latest[ch][i]= RX_GetReceiverThrottleValue(ch);	 
			}
			else
			{
				RX_Latest[ch][i]= RX_GetReceiverValues(ch,i);	 
    4f62:	6e 01       	movw	r12, r28
    4f64:	cc 0c       	add	r12, r12
    4f66:	dd 1c       	adc	r13, r13
    4f68:	cc 0c       	add	r12, r12
    4f6a:	dd 1c       	adc	r13, r13
    4f6c:	cc 0e       	add	r12, r28
    4f6e:	dd 1e       	adc	r13, r29
	{
		for (int i=0;i<RXChannels;++i)
		{
			if (i == RXChannel_THR)
			{
				RX_Latest[ch][i]= RX_GetReceiverThrottleValue(ch);	 
    4f70:	7e 01       	movw	r14, r28
    4f72:	ee 0c       	add	r14, r14
    4f74:	ff 1c       	adc	r15, r15
    4f76:	ce 01       	movw	r24, r28
    4f78:	53 e0       	ldi	r21, 0x03	; 3
    4f7a:	88 0f       	add	r24, r24
    4f7c:	99 1f       	adc	r25, r25
    4f7e:	5a 95       	dec	r21
    4f80:	e1 f7       	brne	.-8      	; 0x4f7a <RX_CopyLatestReceiverValues+0x8c>
    4f82:	e8 0e       	add	r14, r24
    4f84:	f9 1e       	adc	r15, r25
    4f86:	8a e0       	ldi	r24, 0x0A	; 10
    4f88:	96 e0       	ldi	r25, 0x06	; 6
    4f8a:	e8 0e       	add	r14, r24
    4f8c:	f9 1e       	adc	r15, r25
    4f8e:	ba cf       	rjmp	.-140    	; 0x4f04 <RX_CopyLatestReceiverValues+0x16>
				if ((RX_Latest[ch][i]<STICK_DEADBAND) && (RX_Latest[ch][i]>-STICK_DEADBAND)) RX_Latest[ch][i]=0;
			}
		}	
	}
				
}
    4f90:	df 91       	pop	r29
    4f92:	cf 91       	pop	r28
    4f94:	1f 91       	pop	r17
    4f96:	0f 91       	pop	r16
    4f98:	ff 90       	pop	r15
    4f9a:	ef 90       	pop	r14
    4f9c:	df 90       	pop	r13
    4f9e:	cf 90       	pop	r12
    4fa0:	08 95       	ret

00004fa2 <RX_StickCenterCalibrationInit>:

void RX_StickCenterCalibrationInit(uint8_t RXIndex)
{
	for (int i=0; i<RXChannels; ++i)
	{
		RX_MAX_raw[RXIndex][i]=0;
    4fa2:	63 e2       	ldi	r22, 0x23	; 35
    4fa4:	76 e0       	ldi	r23, 0x06	; 6
    4fa6:	28 2f       	mov	r18, r24
    4fa8:	30 e0       	ldi	r19, 0x00	; 0
    4faa:	f9 01       	movw	r30, r18
    4fac:	ee 0f       	add	r30, r30
    4fae:	ff 1f       	adc	r31, r31
    4fb0:	93 e0       	ldi	r25, 0x03	; 3
    4fb2:	22 0f       	add	r18, r18
    4fb4:	33 1f       	adc	r19, r19
    4fb6:	9a 95       	dec	r25
    4fb8:	e1 f7       	brne	.-8      	; 0x4fb2 <RX_StickCenterCalibrationInit+0x10>
    4fba:	e2 0f       	add	r30, r18
    4fbc:	f3 1f       	adc	r31, r19
    4fbe:	e6 0f       	add	r30, r22
    4fc0:	f7 1f       	adc	r31, r23
    4fc2:	11 82       	std	Z+1, r1	; 0x01
    4fc4:	10 82       	st	Z, r1
		RX_MIN_raw[RXIndex][i]=0xfffe;
    4fc6:	40 eb       	ldi	r20, 0xB0	; 176
    4fc8:	56 e0       	ldi	r21, 0x06	; 6
    4fca:	28 2f       	mov	r18, r24
    4fcc:	30 e0       	ldi	r19, 0x00	; 0
    4fce:	f9 01       	movw	r30, r18
    4fd0:	ee 0f       	add	r30, r30
    4fd2:	ff 1f       	adc	r31, r31
    4fd4:	a3 e0       	ldi	r26, 0x03	; 3
    4fd6:	22 0f       	add	r18, r18
    4fd8:	33 1f       	adc	r19, r19
    4fda:	aa 95       	dec	r26
    4fdc:	e1 f7       	brne	.-8      	; 0x4fd6 <RX_StickCenterCalibrationInit+0x34>
    4fde:	e2 0f       	add	r30, r18
    4fe0:	f3 1f       	adc	r31, r19
    4fe2:	e4 0f       	add	r30, r20
    4fe4:	f5 1f       	adc	r31, r21
    4fe6:	2e ef       	ldi	r18, 0xFE	; 254
    4fe8:	3f ef       	ldi	r19, 0xFF	; 255
    4fea:	31 83       	std	Z+1, r19	; 0x01
    4fec:	20 83       	st	Z, r18

void RX_StickCenterCalibrationInit(uint8_t RXIndex)
{
	for (int i=0; i<RXChannels; ++i)
	{
		RX_MAX_raw[RXIndex][i]=0;
    4fee:	a8 2f       	mov	r26, r24
    4ff0:	b0 e0       	ldi	r27, 0x00	; 0
    4ff2:	fd 01       	movw	r30, r26
    4ff4:	ee 0f       	add	r30, r30
    4ff6:	ff 1f       	adc	r31, r31
    4ff8:	93 e0       	ldi	r25, 0x03	; 3
    4ffa:	aa 0f       	add	r26, r26
    4ffc:	bb 1f       	adc	r27, r27
    4ffe:	9a 95       	dec	r25
    5000:	e1 f7       	brne	.-8      	; 0x4ffa <RX_StickCenterCalibrationInit+0x58>
    5002:	ea 0f       	add	r30, r26
    5004:	fb 1f       	adc	r31, r27
    5006:	e6 0f       	add	r30, r22
    5008:	f7 1f       	adc	r31, r23
    500a:	13 82       	std	Z+3, r1	; 0x03
    500c:	12 82       	std	Z+2, r1	; 0x02
		RX_MIN_raw[RXIndex][i]=0xfffe;
    500e:	a8 2f       	mov	r26, r24
    5010:	b0 e0       	ldi	r27, 0x00	; 0
    5012:	fd 01       	movw	r30, r26
    5014:	ee 0f       	add	r30, r30
    5016:	ff 1f       	adc	r31, r31
    5018:	93 e0       	ldi	r25, 0x03	; 3
    501a:	aa 0f       	add	r26, r26
    501c:	bb 1f       	adc	r27, r27
    501e:	9a 95       	dec	r25
    5020:	e1 f7       	brne	.-8      	; 0x501a <RX_StickCenterCalibrationInit+0x78>
    5022:	ea 0f       	add	r30, r26
    5024:	fb 1f       	adc	r31, r27
    5026:	e4 0f       	add	r30, r20
    5028:	f5 1f       	adc	r31, r21
    502a:	33 83       	std	Z+3, r19	; 0x03
    502c:	22 83       	std	Z+2, r18	; 0x02

void RX_StickCenterCalibrationInit(uint8_t RXIndex)
{
	for (int i=0; i<RXChannels; ++i)
	{
		RX_MAX_raw[RXIndex][i]=0;
    502e:	a8 2f       	mov	r26, r24
    5030:	b0 e0       	ldi	r27, 0x00	; 0
    5032:	fd 01       	movw	r30, r26
    5034:	ee 0f       	add	r30, r30
    5036:	ff 1f       	adc	r31, r31
    5038:	93 e0       	ldi	r25, 0x03	; 3
    503a:	aa 0f       	add	r26, r26
    503c:	bb 1f       	adc	r27, r27
    503e:	9a 95       	dec	r25
    5040:	e1 f7       	brne	.-8      	; 0x503a <RX_StickCenterCalibrationInit+0x98>
    5042:	ea 0f       	add	r30, r26
    5044:	fb 1f       	adc	r31, r27
    5046:	e6 0f       	add	r30, r22
    5048:	f7 1f       	adc	r31, r23
    504a:	15 82       	std	Z+5, r1	; 0x05
    504c:	14 82       	std	Z+4, r1	; 0x04
		RX_MIN_raw[RXIndex][i]=0xfffe;
    504e:	a8 2f       	mov	r26, r24
    5050:	b0 e0       	ldi	r27, 0x00	; 0
    5052:	fd 01       	movw	r30, r26
    5054:	ee 0f       	add	r30, r30
    5056:	ff 1f       	adc	r31, r31
    5058:	93 e0       	ldi	r25, 0x03	; 3
    505a:	aa 0f       	add	r26, r26
    505c:	bb 1f       	adc	r27, r27
    505e:	9a 95       	dec	r25
    5060:	e1 f7       	brne	.-8      	; 0x505a <RX_StickCenterCalibrationInit+0xb8>
    5062:	ea 0f       	add	r30, r26
    5064:	fb 1f       	adc	r31, r27
    5066:	e4 0f       	add	r30, r20
    5068:	f5 1f       	adc	r31, r21
    506a:	35 83       	std	Z+5, r19	; 0x05
    506c:	24 83       	std	Z+4, r18	; 0x04

void RX_StickCenterCalibrationInit(uint8_t RXIndex)
{
	for (int i=0; i<RXChannels; ++i)
	{
		RX_MAX_raw[RXIndex][i]=0;
    506e:	a8 2f       	mov	r26, r24
    5070:	b0 e0       	ldi	r27, 0x00	; 0
    5072:	fd 01       	movw	r30, r26
    5074:	ee 0f       	add	r30, r30
    5076:	ff 1f       	adc	r31, r31
    5078:	93 e0       	ldi	r25, 0x03	; 3
    507a:	aa 0f       	add	r26, r26
    507c:	bb 1f       	adc	r27, r27
    507e:	9a 95       	dec	r25
    5080:	e1 f7       	brne	.-8      	; 0x507a <RX_StickCenterCalibrationInit+0xd8>
    5082:	ea 0f       	add	r30, r26
    5084:	fb 1f       	adc	r31, r27
    5086:	e6 0f       	add	r30, r22
    5088:	f7 1f       	adc	r31, r23
    508a:	17 82       	std	Z+7, r1	; 0x07
    508c:	16 82       	std	Z+6, r1	; 0x06
		RX_MIN_raw[RXIndex][i]=0xfffe;
    508e:	a8 2f       	mov	r26, r24
    5090:	b0 e0       	ldi	r27, 0x00	; 0
    5092:	fd 01       	movw	r30, r26
    5094:	ee 0f       	add	r30, r30
    5096:	ff 1f       	adc	r31, r31
    5098:	93 e0       	ldi	r25, 0x03	; 3
    509a:	aa 0f       	add	r26, r26
    509c:	bb 1f       	adc	r27, r27
    509e:	9a 95       	dec	r25
    50a0:	e1 f7       	brne	.-8      	; 0x509a <RX_StickCenterCalibrationInit+0xf8>
    50a2:	ea 0f       	add	r30, r26
    50a4:	fb 1f       	adc	r31, r27
    50a6:	e4 0f       	add	r30, r20
    50a8:	f5 1f       	adc	r31, r21
    50aa:	37 83       	std	Z+7, r19	; 0x07
    50ac:	26 83       	std	Z+6, r18	; 0x06

void RX_StickCenterCalibrationInit(uint8_t RXIndex)
{
	for (int i=0; i<RXChannels; ++i)
	{
		RX_MAX_raw[RXIndex][i]=0;
    50ae:	a8 2f       	mov	r26, r24
    50b0:	b0 e0       	ldi	r27, 0x00	; 0
    50b2:	fd 01       	movw	r30, r26
    50b4:	ee 0f       	add	r30, r30
    50b6:	ff 1f       	adc	r31, r31
    50b8:	93 e0       	ldi	r25, 0x03	; 3
    50ba:	aa 0f       	add	r26, r26
    50bc:	bb 1f       	adc	r27, r27
    50be:	9a 95       	dec	r25
    50c0:	e1 f7       	brne	.-8      	; 0x50ba <RX_StickCenterCalibrationInit+0x118>
    50c2:	ea 0f       	add	r30, r26
    50c4:	fb 1f       	adc	r31, r27
    50c6:	e6 0f       	add	r30, r22
    50c8:	f7 1f       	adc	r31, r23
    50ca:	11 86       	std	Z+9, r1	; 0x09
    50cc:	10 86       	std	Z+8, r1	; 0x08
		RX_MIN_raw[RXIndex][i]=0xfffe;
    50ce:	68 2f       	mov	r22, r24
    50d0:	70 e0       	ldi	r23, 0x00	; 0
    50d2:	fb 01       	movw	r30, r22
    50d4:	ee 0f       	add	r30, r30
    50d6:	ff 1f       	adc	r31, r31
    50d8:	b3 e0       	ldi	r27, 0x03	; 3
    50da:	66 0f       	add	r22, r22
    50dc:	77 1f       	adc	r23, r23
    50de:	ba 95       	dec	r27
    50e0:	e1 f7       	brne	.-8      	; 0x50da <RX_StickCenterCalibrationInit+0x138>
    50e2:	e6 0f       	add	r30, r22
    50e4:	f7 1f       	adc	r31, r23
    50e6:	e4 0f       	add	r30, r20
    50e8:	f5 1f       	adc	r31, r21
    50ea:	31 87       	std	Z+9, r19	; 0x09
    50ec:	20 87       	std	Z+8, r18	; 0x08
	}
}
    50ee:	08 95       	ret

000050f0 <RX_StickCenterCalibration>:


void RX_StickCenterCalibration (uint8_t RXIndex)
{
    50f0:	df 92       	push	r13
    50f2:	ef 92       	push	r14
    50f4:	ff 92       	push	r15
    50f6:	0f 93       	push	r16
    50f8:	1f 93       	push	r17
    50fa:	cf 93       	push	r28
    50fc:	df 93       	push	r29
    50fe:	d8 2e       	mov	r13, r24
		RX_MIN_raw[RXIndex][i]=0xfffe;
	}
}


void RX_StickCenterCalibration (uint8_t RXIndex)
    5100:	28 2f       	mov	r18, r24
    5102:	30 e0       	ldi	r19, 0x00	; 0
    5104:	89 01       	movw	r16, r18
    5106:	00 0f       	add	r16, r16
    5108:	11 1f       	adc	r17, r17
    510a:	73 e0       	ldi	r23, 0x03	; 3
    510c:	22 0f       	add	r18, r18
    510e:	33 1f       	adc	r19, r19
    5110:	7a 95       	dec	r23
    5112:	e1 f7       	brne	.-8      	; 0x510c <RX_StickCenterCalibration+0x1c>
    5114:	02 0f       	add	r16, r18
    5116:	13 1f       	adc	r17, r19
    5118:	0d 5d       	subi	r16, 0xDD	; 221
    511a:	19 4f       	sbci	r17, 0xF9	; 249
    511c:	28 2f       	mov	r18, r24
    511e:	30 e0       	ldi	r19, 0x00	; 0
    5120:	e9 01       	movw	r28, r18
    5122:	cc 0f       	add	r28, r28
    5124:	dd 1f       	adc	r29, r29
    5126:	53 e0       	ldi	r21, 0x03	; 3
    5128:	22 0f       	add	r18, r18
    512a:	33 1f       	adc	r19, r19
    512c:	5a 95       	dec	r21
    512e:	e1 f7       	brne	.-8      	; 0x5128 <RX_StickCenterCalibration+0x38>
    5130:	c2 0f       	add	r28, r18
    5132:	d3 1f       	adc	r29, r19
    5134:	c0 55       	subi	r28, 0x50	; 80
    5136:	d9 4f       	sbci	r29, 0xF9	; 249
{
	
	uint16_t tempRX;
	for (int i=0;i<RXChannels;++i)
    5138:	ee 24       	eor	r14, r14
    513a:	ff 24       	eor	r15, r15
	{
		tempRX = RX_raw_GetReceiverValues(RXIndex,i);
    513c:	8d 2d       	mov	r24, r13
    513e:	6e 2d       	mov	r22, r14
    5140:	0e 94 a9 26 	call	0x4d52	; 0x4d52 <RX_raw_GetReceiverValues>
    5144:	9c 01       	movw	r18, r24
		if (tempRX!=0)
    5146:	00 97       	sbiw	r24, 0x00	; 0
    5148:	81 f0       	breq	.+32     	; 0x516a <RX_StickCenterCalibration+0x7a>
		{
			
			if ( tempRX > RX_MAX_raw[RXIndex][i]) 
    514a:	f8 01       	movw	r30, r16
    514c:	80 81       	ld	r24, Z
    514e:	91 81       	ldd	r25, Z+1	; 0x01
    5150:	82 17       	cp	r24, r18
    5152:	93 07       	cpc	r25, r19
    5154:	18 f4       	brcc	.+6      	; 0x515c <RX_StickCenterCalibration+0x6c>
			{
				RX_MAX_raw[RXIndex][i] = tempRX;
    5156:	31 83       	std	Z+1, r19	; 0x01
    5158:	20 83       	st	Z, r18
    515a:	07 c0       	rjmp	.+14     	; 0x516a <RX_StickCenterCalibration+0x7a>
			}
			else if (tempRX < RX_MIN_raw[RXIndex][i]) 
    515c:	88 81       	ld	r24, Y
    515e:	99 81       	ldd	r25, Y+1	; 0x01
    5160:	28 17       	cp	r18, r24
    5162:	39 07       	cpc	r19, r25
    5164:	10 f4       	brcc	.+4      	; 0x516a <RX_StickCenterCalibration+0x7a>
			{
				RX_MIN_raw[RXIndex][i] = tempRX;
    5166:	39 83       	std	Y+1, r19	; 0x01
    5168:	28 83       	st	Y, r18

void RX_StickCenterCalibration (uint8_t RXIndex)
{
	
	uint16_t tempRX;
	for (int i=0;i<RXChannels;++i)
    516a:	08 94       	sec
    516c:	e1 1c       	adc	r14, r1
    516e:	f1 1c       	adc	r15, r1
    5170:	0e 5f       	subi	r16, 0xFE	; 254
    5172:	1f 4f       	sbci	r17, 0xFF	; 255
    5174:	22 96       	adiw	r28, 0x02	; 2
    5176:	f5 e0       	ldi	r31, 0x05	; 5
    5178:	ef 16       	cp	r14, r31
    517a:	f1 04       	cpc	r15, r1
    517c:	f9 f6       	brne	.-66     	; 0x513c <RX_StickCenterCalibration+0x4c>
			{
				RX_MIN_raw[RXIndex][i] = tempRX;
			}
		}
	}				
    517e:	df 91       	pop	r29
    5180:	cf 91       	pop	r28
    5182:	1f 91       	pop	r17
    5184:	0f 91       	pop	r16
    5186:	ff 90       	pop	r15
    5188:	ef 90       	pop	r14
    518a:	df 90       	pop	r13
    518c:	08 95       	ret

0000518e <Sensors_Init>:
	


void Sensors_Init(void)
{
	ACC_PITCH  = INPUT;
    518e:	15 98       	cbi	0x02, 5	; 2
	ACC_ROLL  = INPUT;
    5190:	16 98       	cbi	0x02, 6	; 2
	ACC_Z  = INPUT;
    5192:	17 98       	cbi	0x02, 7	; 2
	
	GYRO_ROLL = INPUT;
    5194:	11 98       	cbi	0x02, 1	; 2
	GYRO_PITCH = INPUT;
    5196:	14 98       	cbi	0x02, 4	; 2
	GYRO_Z = INPUT;
    5198:	12 98       	cbi	0x02, 2	; 2
	//{
		//
		//StabilityMatrix_GX[i]=0;
		//StabilityMatrix_GY[i]=0;
	//}
}
    519a:	08 95       	ret

0000519c <Sensors_Test>:

/*
// This function Test if sensors are working OK or not.
*/
char *Sensors_Test(uint8_t channel, uint16_t LowLimit ,uint16_t HighLimit)
{
    519c:	ef 92       	push	r14
    519e:	ff 92       	push	r15
    51a0:	0f 93       	push	r16
    51a2:	1f 93       	push	r17
    51a4:	cf 93       	push	r28
    51a6:	df 93       	push	r29
    51a8:	8b 01       	movw	r16, r22
    51aa:	7a 01       	movw	r14, r20
	
	nResult[channel] = ADCPort_Get(channel);
    51ac:	c8 2f       	mov	r28, r24
    51ae:	d0 e0       	ldi	r29, 0x00	; 0
    51b0:	0e 94 a4 2a 	call	0x5548	; 0x5548 <ADCPort_Get>
    51b4:	cc 0f       	add	r28, r28
    51b6:	dd 1f       	adc	r29, r29
    51b8:	c0 56       	subi	r28, 0x60	; 96
    51ba:	da 4f       	sbci	r29, 0xFA	; 250
    51bc:	99 83       	std	Y+1, r25	; 0x01
    51be:	88 83       	st	Y, r24
	  
	utoa (nResult[channel],Result,10);
    51c0:	88 81       	ld	r24, Y
    51c2:	99 81       	ldd	r25, Y+1	; 0x01
    51c4:	60 eb       	ldi	r22, 0xB0	; 176
    51c6:	75 e0       	ldi	r23, 0x05	; 5
    51c8:	4a e0       	ldi	r20, 0x0A	; 10
    51ca:	50 e0       	ldi	r21, 0x00	; 0
    51cc:	0e 94 36 3b 	call	0x766c	; 0x766c <utoa>
	
	if ((nResult[channel]  >= LowLimit)  
    51d0:	88 81       	ld	r24, Y
    51d2:	99 81       	ldd	r25, Y+1	; 0x01
    51d4:	80 17       	cp	r24, r16
    51d6:	91 07       	cpc	r25, r17
    51d8:	50 f0       	brcs	.+20     	; 0x51ee <Sensors_Test+0x52>
	 && (nResult[channel]  <= HighLimit))
    51da:	88 81       	ld	r24, Y
    51dc:	99 81       	ldd	r25, Y+1	; 0x01
    51de:	e8 16       	cp	r14, r24
    51e0:	f9 06       	cpc	r15, r25
    51e2:	28 f0       	brcs	.+10     	; 0x51ee <Sensors_Test+0x52>
	{
		strcat (Result, ("  "));  
    51e4:	80 eb       	ldi	r24, 0xB0	; 176
    51e6:	95 e0       	ldi	r25, 0x05	; 5
    51e8:	68 e0       	ldi	r22, 0x08	; 8
    51ea:	71 e0       	ldi	r23, 0x01	; 1
    51ec:	04 c0       	rjmp	.+8      	; 0x51f6 <Sensors_Test+0x5a>
	}
	else
	{
		strcat (Result, (" X"));  
    51ee:	80 eb       	ldi	r24, 0xB0	; 176
    51f0:	95 e0       	ldi	r25, 0x05	; 5
    51f2:	6b e0       	ldi	r22, 0x0B	; 11
    51f4:	71 e0       	ldi	r23, 0x01	; 1
    51f6:	0e 94 0a 3b 	call	0x7614	; 0x7614 <strcat>
	}
	  
	return Result;
}
    51fa:	80 eb       	ldi	r24, 0xB0	; 176
    51fc:	95 e0       	ldi	r25, 0x05	; 5
    51fe:	df 91       	pop	r29
    5200:	cf 91       	pop	r28
    5202:	1f 91       	pop	r17
    5204:	0f 91       	pop	r16
    5206:	ff 90       	pop	r15
    5208:	ef 90       	pop	r14
    520a:	08 95       	ret

0000520c <Sensors_Calibrate>:

/*
// Calibrate Sensors and return result in nResult global variable.
*/
void Sensors_Calibrate (void)
{
    520c:	ef 92       	push	r14
    520e:	ff 92       	push	r15
    5210:	0f 93       	push	r16
    5212:	1f 93       	push	r17
    5214:	df 93       	push	r29
    5216:	cf 93       	push	r28
    5218:	0f 92       	push	r0
    521a:	cd b7       	in	r28, 0x3d	; 61
    521c:	de b7       	in	r29, 0x3e	; 62
	BOOL LEDOLD = LED_Orange;
    521e:	25 b1       	in	r18, 0x05	; 5
    5220:	26 95       	lsr	r18
    5222:	26 95       	lsr	r18
    5224:	26 95       	lsr	r18
    5226:	21 70       	andi	r18, 0x01	; 1
	int i;
	for (i=0;i<6;++i)
	{
		nResult [i]=0;
    5228:	10 92 a1 05 	sts	0x05A1, r1
    522c:	10 92 a0 05 	sts	0x05A0, r1
    5230:	10 92 a3 05 	sts	0x05A3, r1
    5234:	10 92 a2 05 	sts	0x05A2, r1
    5238:	10 92 a5 05 	sts	0x05A5, r1
    523c:	10 92 a4 05 	sts	0x05A4, r1
    5240:	10 92 a7 05 	sts	0x05A7, r1
    5244:	10 92 a6 05 	sts	0x05A6, r1
    5248:	10 92 a9 05 	sts	0x05A9, r1
    524c:	10 92 a8 05 	sts	0x05A8, r1
    5250:	10 92 ab 05 	sts	0x05AB, r1
    5254:	10 92 aa 05 	sts	0x05AA, r1
    5258:	59 e1       	ldi	r21, 0x19	; 25
    525a:	e5 2e       	mov	r14, r21
    525c:	f1 2c       	mov	r15, r1
	}
	
	// check: http://www.x-firm.com/?page_id=191
	for (int i=0;i<25;++i)
	{
		nResult[ACC_PITCH_Index] += ADCPort_Get(ACC_PITCH_PNUM);
    525e:	00 91 a6 05 	lds	r16, 0x05A6
    5262:	10 91 a7 05 	lds	r17, 0x05A7
    5266:	85 e0       	ldi	r24, 0x05	; 5
    5268:	29 83       	std	Y+1, r18	; 0x01
    526a:	0e 94 a4 2a 	call	0x5548	; 0x5548 <ADCPort_Get>
    526e:	08 0f       	add	r16, r24
    5270:	19 1f       	adc	r17, r25
    5272:	10 93 a7 05 	sts	0x05A7, r17
    5276:	00 93 a6 05 	sts	0x05A6, r16
		nResult[ACC_ROLL_Index] += ADCPort_Get(ACC_ROLL_PNUM);
    527a:	00 91 a8 05 	lds	r16, 0x05A8
    527e:	10 91 a9 05 	lds	r17, 0x05A9
    5282:	86 e0       	ldi	r24, 0x06	; 6
    5284:	0e 94 a4 2a 	call	0x5548	; 0x5548 <ADCPort_Get>
    5288:	08 0f       	add	r16, r24
    528a:	19 1f       	adc	r17, r25
    528c:	10 93 a9 05 	sts	0x05A9, r17
    5290:	00 93 a8 05 	sts	0x05A8, r16
		nResult[ACC_Z_Index] += ADCPort_Get(ACC_Z_PNUM);
    5294:	00 91 aa 05 	lds	r16, 0x05AA
    5298:	10 91 ab 05 	lds	r17, 0x05AB
    529c:	87 e0       	ldi	r24, 0x07	; 7
    529e:	0e 94 a4 2a 	call	0x5548	; 0x5548 <ADCPort_Get>
    52a2:	08 0f       	add	r16, r24
    52a4:	19 1f       	adc	r17, r25
    52a6:	10 93 ab 05 	sts	0x05AB, r17
    52aa:	00 93 aa 05 	sts	0x05AA, r16
		
		nResult[GYRO_ROLL_Index] += ADCPort_Get(GYRO_ROLL_PNUM);
    52ae:	00 91 a0 05 	lds	r16, 0x05A0
    52b2:	10 91 a1 05 	lds	r17, 0x05A1
    52b6:	81 e0       	ldi	r24, 0x01	; 1
    52b8:	0e 94 a4 2a 	call	0x5548	; 0x5548 <ADCPort_Get>
    52bc:	08 0f       	add	r16, r24
    52be:	19 1f       	adc	r17, r25
    52c0:	10 93 a1 05 	sts	0x05A1, r17
    52c4:	00 93 a0 05 	sts	0x05A0, r16
		nResult[GYRO_PITCH_Index] += ADCPort_Get(GYRO_PITCH_PNUM);
    52c8:	00 91 a2 05 	lds	r16, 0x05A2
    52cc:	10 91 a3 05 	lds	r17, 0x05A3
    52d0:	84 e0       	ldi	r24, 0x04	; 4
    52d2:	0e 94 a4 2a 	call	0x5548	; 0x5548 <ADCPort_Get>
    52d6:	08 0f       	add	r16, r24
    52d8:	19 1f       	adc	r17, r25
    52da:	10 93 a3 05 	sts	0x05A3, r17
    52de:	00 93 a2 05 	sts	0x05A2, r16
		nResult[GYRO_Z_Index] += ADCPort_Get(GYRO_Z_PNUM); 
    52e2:	00 91 a4 05 	lds	r16, 0x05A4
    52e6:	10 91 a5 05 	lds	r17, 0x05A5
    52ea:	82 e0       	ldi	r24, 0x02	; 2
    52ec:	0e 94 a4 2a 	call	0x5548	; 0x5548 <ADCPort_Get>
    52f0:	08 0f       	add	r16, r24
    52f2:	19 1f       	adc	r17, r25
    52f4:	10 93 a5 05 	sts	0x05A5, r17
    52f8:	00 93 a4 05 	sts	0x05A4, r16
    52fc:	8f e0       	ldi	r24, 0x0F	; 15
    52fe:	97 e2       	ldi	r25, 0x27	; 39
    5300:	01 97       	sbiw	r24, 0x01	; 1
    5302:	f1 f7       	brne	.-4      	; 0x5300 <Sensors_Calibrate+0xf4>
    5304:	00 c0       	rjmp	.+0      	; 0x5306 <Sensors_Calibrate+0xfa>
    5306:	00 00       	nop
		_delay_ms(40);
		LED_Orange =~LED_Orange;
    5308:	85 b1       	in	r24, 0x05	; 5
    530a:	86 95       	lsr	r24
    530c:	86 95       	lsr	r24
    530e:	86 95       	lsr	r24
    5310:	80 95       	com	r24
    5312:	81 70       	andi	r24, 0x01	; 1
    5314:	88 0f       	add	r24, r24
    5316:	88 0f       	add	r24, r24
    5318:	88 0f       	add	r24, r24
    531a:	95 b1       	in	r25, 0x05	; 5
    531c:	97 7f       	andi	r25, 0xF7	; 247
    531e:	98 2b       	or	r25, r24
    5320:	95 b9       	out	0x05, r25	; 5
    5322:	08 94       	sec
    5324:	e1 08       	sbc	r14, r1
    5326:	f1 08       	sbc	r15, r1
	{
		nResult [i]=0;
	}
	
	// check: http://www.x-firm.com/?page_id=191
	for (int i=0;i<25;++i)
    5328:	29 81       	ldd	r18, Y+1	; 0x01
    532a:	e1 14       	cp	r14, r1
    532c:	f1 04       	cpc	r15, r1
    532e:	09 f0       	breq	.+2      	; 0x5332 <Sensors_Calibrate+0x126>
    5330:	96 cf       	rjmp	.-212    	; 0x525e <Sensors_Calibrate+0x52>
		nResult[GYRO_Z_Index] += ADCPort_Get(GYRO_Z_PNUM); 
		_delay_ms(40);
		LED_Orange =~LED_Orange;
	}
	
	LED_Orange = LEDOLD;
    5332:	21 70       	andi	r18, 0x01	; 1
    5334:	22 0f       	add	r18, r18
    5336:	22 0f       	add	r18, r18
    5338:	22 0f       	add	r18, r18
    533a:	85 b1       	in	r24, 0x05	; 5
    533c:	87 7f       	andi	r24, 0xF7	; 247
    533e:	82 2b       	or	r24, r18
    5340:	85 b9       	out	0x05, r24	; 5
	
	for (i=0;i<6;++i)
    5342:	20 e0       	ldi	r18, 0x00	; 0
    5344:	30 e0       	ldi	r19, 0x00	; 0
	{
		nResult[i] /=25;
    5346:	09 e1       	ldi	r16, 0x19	; 25
    5348:	10 e0       	ldi	r17, 0x00	; 0
    534a:	f9 01       	movw	r30, r18
    534c:	ee 0f       	add	r30, r30
    534e:	ff 1f       	adc	r31, r31
    5350:	e0 56       	subi	r30, 0x60	; 96
    5352:	fa 4f       	sbci	r31, 0xFA	; 250
    5354:	80 81       	ld	r24, Z
    5356:	91 81       	ldd	r25, Z+1	; 0x01
    5358:	b8 01       	movw	r22, r16
    535a:	0e 94 96 3a 	call	0x752c	; 0x752c <__udivmodhi4>
    535e:	71 83       	std	Z+1, r23	; 0x01
    5360:	60 83       	st	Z, r22
		LED_Orange =~LED_Orange;
	}
	
	LED_Orange = LEDOLD;
	
	for (i=0;i<6;++i)
    5362:	2f 5f       	subi	r18, 0xFF	; 255
    5364:	3f 4f       	sbci	r19, 0xFF	; 255
    5366:	26 30       	cpi	r18, 0x06	; 6
    5368:	31 05       	cpc	r19, r1
    536a:	79 f7       	brne	.-34     	; 0x534a <Sensors_Calibrate+0x13e>
	{
		nResult[i] /=25;
	}	
	
	Config.IsCalibrated = (Config.IsCalibrated | CALIBRATED_SENSOR);
    536c:	80 91 d2 06 	lds	r24, 0x06D2
    5370:	84 60       	ori	r24, 0x04	; 4
    5372:	80 93 d2 06 	sts	0x06D2, r24
    5376:	a4 e5       	ldi	r26, 0x54	; 84
    5378:	b7 e0       	ldi	r27, 0x07	; 7
	for (i=0;i<6;++i)
    537a:	80 e0       	ldi	r24, 0x00	; 0
    537c:	90 e0       	ldi	r25, 0x00	; 0
	Config.Sensor_zero[i] = nResult[i];
    537e:	fc 01       	movw	r30, r24
    5380:	ee 0f       	add	r30, r30
    5382:	ff 1f       	adc	r31, r31
    5384:	e0 56       	subi	r30, 0x60	; 96
    5386:	fa 4f       	sbci	r31, 0xFA	; 250
    5388:	20 81       	ld	r18, Z
    538a:	31 81       	ldd	r19, Z+1	; 0x01
    538c:	2d 93       	st	X+, r18
    538e:	3d 93       	st	X+, r19
	{
		nResult[i] /=25;
	}	
	
	Config.IsCalibrated = (Config.IsCalibrated | CALIBRATED_SENSOR);
	for (i=0;i<6;++i)
    5390:	01 96       	adiw	r24, 0x01	; 1
    5392:	86 30       	cpi	r24, 0x06	; 6
    5394:	91 05       	cpc	r25, r1
    5396:	99 f7       	brne	.-26     	; 0x537e <Sensors_Calibrate+0x172>
	Config.Sensor_zero[i] = nResult[i];
		
	
	//nResult[ACC_Z_Index]-=100; // Sensor: horizontal, upward ... the caller of this function is responsible for updating Config.Sensor_zero[i] = nResult[i];
		
}
    5398:	0f 90       	pop	r0
    539a:	cf 91       	pop	r28
    539c:	df 91       	pop	r29
    539e:	1f 91       	pop	r17
    53a0:	0f 91       	pop	r16
    53a2:	ff 90       	pop	r15
    53a4:	ef 90       	pop	r14
    53a6:	08 95       	ret

000053a8 <Sensor_GetBattery>:
}*/

int16_t  Sensor_GetBattery(void)
{
	 // because the V_BAT is connected to a voltage divider R1 & R2
	return (ADCPort_Get(V_BAT_PNUM) *  BAT_VOLT_RATIO);
    53a8:	83 e0       	ldi	r24, 0x03	; 3
    53aa:	0e 94 a4 2a 	call	0x5548	; 0x5548 <ADCPort_Get>
    53ae:	24 e6       	ldi	r18, 0x64	; 100
    53b0:	30 e0       	ldi	r19, 0x00	; 0
    53b2:	ac 01       	movw	r20, r24
    53b4:	42 9f       	mul	r20, r18
    53b6:	c0 01       	movw	r24, r0
    53b8:	43 9f       	mul	r20, r19
    53ba:	90 0d       	add	r25, r0
    53bc:	52 9f       	mul	r21, r18
    53be:	90 0d       	add	r25, r0
    53c0:	11 24       	eor	r1, r1
    53c2:	64 e7       	ldi	r22, 0x74	; 116
    53c4:	71 e0       	ldi	r23, 0x01	; 1
    53c6:	0e 94 96 3a 	call	0x752c	; 0x752c <__udivmodhi4>
} 
    53ca:	cb 01       	movw	r24, r22
    53cc:	08 95       	ret

000053ce <Sensors_ReadAll>:
   //{
		//TX1= TCNT1;
		//TX= TCNT1_X;
   //}   
	//
	Sensors_Latest[ACC_PITCH_Index] = ADCPort_Get(ACC_PITCH_PNUM)-Config.Sensor_zero[ACC_PITCH_Index]; 
    53ce:	85 e0       	ldi	r24, 0x05	; 5
    53d0:	0e 94 a4 2a 	call	0x5548	; 0x5548 <ADCPort_Get>
    53d4:	20 91 5a 07 	lds	r18, 0x075A
    53d8:	30 91 5b 07 	lds	r19, 0x075B
    53dc:	82 1b       	sub	r24, r18
    53de:	93 0b       	sbc	r25, r19
    53e0:	90 93 44 06 	sts	0x0644, r25
    53e4:	80 93 43 06 	sts	0x0643, r24
	Sensors_Latest[ACC_ROLL_Index] = ADCPort_Get(ACC_ROLL_PNUM)-Config.Sensor_zero[ACC_ROLL_Index];
    53e8:	86 e0       	ldi	r24, 0x06	; 6
    53ea:	0e 94 a4 2a 	call	0x5548	; 0x5548 <ADCPort_Get>
    53ee:	20 91 5c 07 	lds	r18, 0x075C
    53f2:	30 91 5d 07 	lds	r19, 0x075D
    53f6:	82 1b       	sub	r24, r18
    53f8:	93 0b       	sbc	r25, r19
    53fa:	90 93 46 06 	sts	0x0646, r25
    53fe:	80 93 45 06 	sts	0x0645, r24
	Sensors_Latest[ACC_Z_Index] = ADCPort_Get(ACC_Z_PNUM)-Config.Sensor_zero[ACC_Z_Index];
    5402:	87 e0       	ldi	r24, 0x07	; 7
    5404:	0e 94 a4 2a 	call	0x5548	; 0x5548 <ADCPort_Get>
    5408:	20 91 5e 07 	lds	r18, 0x075E
    540c:	30 91 5f 07 	lds	r19, 0x075F
    5410:	82 1b       	sub	r24, r18
    5412:	93 0b       	sbc	r25, r19
    5414:	90 93 48 06 	sts	0x0648, r25
    5418:	80 93 47 06 	sts	0x0647, r24
		
	Sensors_Latest[GYRO_ROLL_Index] = ADCPort_Get(GYRO_ROLL_PNUM)-Config.Sensor_zero[GYRO_ROLL_Index];
    541c:	81 e0       	ldi	r24, 0x01	; 1
    541e:	0e 94 a4 2a 	call	0x5548	; 0x5548 <ADCPort_Get>
    5422:	20 91 54 07 	lds	r18, 0x0754
    5426:	30 91 55 07 	lds	r19, 0x0755
    542a:	82 1b       	sub	r24, r18
    542c:	93 0b       	sbc	r25, r19
    542e:	90 93 3e 06 	sts	0x063E, r25
    5432:	80 93 3d 06 	sts	0x063D, r24
	if (abs(Sensors_Latest[GYRO_ROLL_Index])< DEAD_BAND_GYRO) Sensors_Latest[GYRO_ROLL_Index] = 0;
    5436:	80 91 3d 06 	lds	r24, 0x063D
    543a:	90 91 3e 06 	lds	r25, 0x063E
    543e:	97 ff       	sbrs	r25, 7
    5440:	03 c0       	rjmp	.+6      	; 0x5448 <Sensors_ReadAll+0x7a>
    5442:	90 95       	com	r25
    5444:	81 95       	neg	r24
    5446:	9f 4f       	sbci	r25, 0xFF	; 255
    5448:	82 30       	cpi	r24, 0x02	; 2
    544a:	91 05       	cpc	r25, r1
    544c:	24 f4       	brge	.+8      	; 0x5456 <Sensors_ReadAll+0x88>
    544e:	10 92 3e 06 	sts	0x063E, r1
    5452:	10 92 3d 06 	sts	0x063D, r1
	Sensors_Latest[GYRO_PITCH_Index] = ADCPort_Get(GYRO_PITCH_PNUM)-Config.Sensor_zero[GYRO_PITCH_Index];
    5456:	84 e0       	ldi	r24, 0x04	; 4
    5458:	0e 94 a4 2a 	call	0x5548	; 0x5548 <ADCPort_Get>
    545c:	20 91 56 07 	lds	r18, 0x0756
    5460:	30 91 57 07 	lds	r19, 0x0757
    5464:	82 1b       	sub	r24, r18
    5466:	93 0b       	sbc	r25, r19
    5468:	90 93 40 06 	sts	0x0640, r25
    546c:	80 93 3f 06 	sts	0x063F, r24
	if (abs(Sensors_Latest[GYRO_PITCH_Index])< DEAD_BAND_GYRO) Sensors_Latest[GYRO_PITCH_Index] = 0;
    5470:	80 91 3f 06 	lds	r24, 0x063F
    5474:	90 91 40 06 	lds	r25, 0x0640
    5478:	97 ff       	sbrs	r25, 7
    547a:	03 c0       	rjmp	.+6      	; 0x5482 <Sensors_ReadAll+0xb4>
    547c:	90 95       	com	r25
    547e:	81 95       	neg	r24
    5480:	9f 4f       	sbci	r25, 0xFF	; 255
    5482:	82 30       	cpi	r24, 0x02	; 2
    5484:	91 05       	cpc	r25, r1
    5486:	24 f4       	brge	.+8      	; 0x5490 <Sensors_ReadAll+0xc2>
    5488:	10 92 40 06 	sts	0x0640, r1
    548c:	10 92 3f 06 	sts	0x063F, r1
	Sensors_Latest[GYRO_Z_Index] = ADCPort_Get(GYRO_Z_PNUM)-Config.Sensor_zero[GYRO_Z_Index];
    5490:	82 e0       	ldi	r24, 0x02	; 2
    5492:	0e 94 a4 2a 	call	0x5548	; 0x5548 <ADCPort_Get>
    5496:	20 91 58 07 	lds	r18, 0x0758
    549a:	30 91 59 07 	lds	r19, 0x0759
    549e:	82 1b       	sub	r24, r18
    54a0:	93 0b       	sbc	r25, r19
    54a2:	90 93 42 06 	sts	0x0642, r25
    54a6:	80 93 41 06 	sts	0x0641, r24
	if (abs(Sensors_Latest[GYRO_Z_Index])< DEAD_BAND_GYRO) Sensors_Latest[GYRO_Z_Index] = 0;
    54aa:	80 91 41 06 	lds	r24, 0x0641
    54ae:	90 91 42 06 	lds	r25, 0x0642
    54b2:	97 ff       	sbrs	r25, 7
    54b4:	03 c0       	rjmp	.+6      	; 0x54bc <Sensors_ReadAll+0xee>
    54b6:	90 95       	com	r25
    54b8:	81 95       	neg	r24
    54ba:	9f 4f       	sbci	r25, 0xFF	; 255
    54bc:	82 30       	cpi	r24, 0x02	; 2
    54be:	91 05       	cpc	r25, r1
    54c0:	24 f4       	brge	.+8      	; 0x54ca <Sensors_ReadAll+0xfc>
    54c2:	10 92 42 06 	sts	0x0642, r1
    54c6:	10 92 41 06 	sts	0x0641, r1
	
	Sensors_Latest[V_BAT_Index] = Sensor_GetBattery(); 
    54ca:	0e 94 d4 29 	call	0x53a8	; 0x53a8 <Sensor_GetBattery>
    54ce:	90 93 4a 06 	sts	0x064A, r25
    54d2:	80 93 49 06 	sts	0x0649, r24
	//else
	//{
		//Sensors_dt = TX1 - TX2;
	//}
	//TX2=TX1;
}
    54d6:	08 95       	ret

000054d8 <__vector_24>:
 * 
 *  8.913kHz on mega128 16MHz 1kHz/channel ??
 ***** I used 20 MHz 13 - 260 us conv average = (260-13)/2 + 13 = 136.5 us = 7.326 KHz
*/
ISR(ADC_vect, ISR_NOBLOCK)
{
    54d8:	78 94       	sei
    54da:	1f 92       	push	r1
    54dc:	0f 92       	push	r0
    54de:	0f b6       	in	r0, 0x3f	; 63
    54e0:	0f 92       	push	r0
    54e2:	11 24       	eor	r1, r1
    54e4:	2f 93       	push	r18
    54e6:	8f 93       	push	r24
    54e8:	9f 93       	push	r25
    54ea:	ef 93       	push	r30
    54ec:	ff 93       	push	r31
	static uint8_t _index;
	ADCValues[_index] = ADC;
    54ee:	20 91 31 05 	lds	r18, 0x0531
    54f2:	e2 2f       	mov	r30, r18
    54f4:	f0 e0       	ldi	r31, 0x00	; 0
    54f6:	80 91 78 00 	lds	r24, 0x0078
    54fa:	90 91 79 00 	lds	r25, 0x0079
    54fe:	ee 0f       	add	r30, r30
    5500:	ff 1f       	adc	r31, r31
    5502:	ed 50       	subi	r30, 0x0D	; 13
    5504:	f8 4f       	sbci	r31, 0xF8	; 248
    5506:	91 83       	std	Z+1, r25	; 0x01
    5508:	80 83       	st	Z, r24
	_index = (_index + 1) % 8U;
    550a:	82 2f       	mov	r24, r18
    550c:	8f 5f       	subi	r24, 0xFF	; 255
    550e:	87 70       	andi	r24, 0x07	; 7
    5510:	80 93 31 05 	sts	0x0531, r24
	ADMUX = _index;
    5514:	80 93 7c 00 	sts	0x007C, r24
	ADCSRA |= _BV(ADSC);
    5518:	ea e7       	ldi	r30, 0x7A	; 122
    551a:	f0 e0       	ldi	r31, 0x00	; 0
    551c:	80 81       	ld	r24, Z
    551e:	80 64       	ori	r24, 0x40	; 64
    5520:	80 83       	st	Z, r24
	
	
}
    5522:	ff 91       	pop	r31
    5524:	ef 91       	pop	r30
    5526:	9f 91       	pop	r25
    5528:	8f 91       	pop	r24
    552a:	2f 91       	pop	r18
    552c:	0f 90       	pop	r0
    552e:	0f be       	out	0x3f, r0	; 63
    5530:	0f 90       	pop	r0
    5532:	1f 90       	pop	r1
    5534:	18 95       	reti

00005536 <ADCPort_Init>:

void ADCPort_Init ()
{
	DIDR0 = 0xFF;	// disable all digital inputs on Port A
    5536:	8f ef       	ldi	r24, 0xFF	; 255
    5538:	80 93 7e 00 	sts	0x007E, r24
	ADMUX = 0;
    553c:	10 92 7c 00 	sts	0x007C, r1
	ADCSRA = 0b11011111;	// ADEN, ADSC, ADIE, 
    5540:	8f ed       	ldi	r24, 0xDF	; 223
    5542:	80 93 7a 00 	sts	0x007A, r24
		
}
    5546:	08 95       	ret

00005548 <ADCPort_Get>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    5548:	f8 94       	cli
*/
inline uint16_t ADCPort_Get(uint8_t channel)
{
	uint16_t _t;
	ATOMIC_BLOCK(ATOMIC_FORCEON)
		_t = ADCValues[channel];
    554a:	e8 2f       	mov	r30, r24
    554c:	f0 e0       	ldi	r31, 0x00	; 0
    554e:	ee 0f       	add	r30, r30
    5550:	ff 1f       	adc	r31, r31
    5552:	ed 50       	subi	r30, 0x0D	; 13
    5554:	f8 4f       	sbci	r31, 0xF8	; 248
    5556:	20 81       	ld	r18, Z
    5558:	31 81       	ldd	r19, Z+1	; 0x01
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    555a:	78 94       	sei
	return _t;
    555c:	c9 01       	movw	r24, r18
    555e:	08 95       	ret

00005560 <_hHomeRestart>:
}


void _hHomeRestart (void)
{
	NOKEYRETURN
    5560:	80 91 bc 05 	lds	r24, 0x05BC
    5564:	88 23       	and	r24, r24
    5566:	11 f0       	breq	.+4      	; 0x556c <_hHomeRestart+0xc>
	
	if (KEY4)
    5568:	84 fd       	sbrc	r24, 4
    556a:	ff cf       	rjmp	.-2      	; 0x556a <_hHomeRestart+0xa>
    556c:	08 95       	ret

0000556e <tsmMain>:
	Menu_LoadPage(PAGE_HOME);
}

PGM_P tsmMain(uint8_t index)
{
	return (PGM_P)pgm_read_word(&lstMenu[index]);
    556e:	90 e0       	ldi	r25, 0x00	; 0
    5570:	88 0f       	add	r24, r24
    5572:	99 1f       	adc	r25, r25
    5574:	84 54       	subi	r24, 0x44	; 68
    5576:	94 4f       	sbci	r25, 0xF4	; 244
    5578:	fc 01       	movw	r30, r24
    557a:	25 91       	lpm	r18, Z+
    557c:	34 91       	lpm	r19, Z+
}
    557e:	c9 01       	movw	r24, r18
    5580:	08 95       	ret

00005582 <writeSoftkeys>:
		//LCD_WriteString_P(e.text);
	//}
//}

static void writeSoftkeys(const char* sk)
{
    5582:	cf 93       	push	r28
    5584:	df 93       	push	r29
    5586:	ec 01       	movw	r28, r24
	if (!sk)
    5588:	00 97       	sbiw	r24, 0x00	; 0
    558a:	31 f4       	brne	.+12     	; 0x5598 <writeSoftkeys+0x16>
		sk = currentPage.softkeys;
    558c:	c0 91 44 05 	lds	r28, 0x0544
    5590:	d0 91 45 05 	lds	r29, 0x0545
	if (sk)
    5594:	20 97       	sbiw	r28, 0x00	; 0
    5596:	39 f0       	breq	.+14     	; 0x55a6 <writeSoftkeys+0x24>
	{
		LCD_SetPos(7, 0);
    5598:	87 e0       	ldi	r24, 0x07	; 7
    559a:	60 e0       	ldi	r22, 0x00	; 0
    559c:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <LCD_SetPos>
		LCD_WriteString_P(sk);
    55a0:	ce 01       	movw	r24, r28
    55a2:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <LCD_WriteString_P>
	}
}
    55a6:	df 91       	pop	r29
    55a8:	cf 91       	pop	r28
    55aa:	08 95       	ret

000055ac <_hDebug>:

	static double YAWAngle;
static double OldAngle;
	static double YAWAngle2;
void _hDebug()
{
    55ac:	cf 92       	push	r12
    55ae:	df 92       	push	r13
    55b0:	ef 92       	push	r14
    55b2:	ff 92       	push	r15
    55b4:	0f 93       	push	r16
    55b6:	1f 93       	push	r17
    55b8:	cf 93       	push	r28
    55ba:	df 93       	push	r29

	if (IS_INIT)
    55bc:	80 91 bc 05 	lds	r24, 0x05BC
    55c0:	80 fd       	sbrc	r24, 0
    55c2:	9b c0       	rjmp	.+310    	; 0x56fa <_hDebug+0x14e>
			//send_byte(0x01);
			//send_byte(0x01);send_byte(0x00);send_byte(0x00);send_byte(0x00);
			//send_byte(98);
	
		}
		if (KEY3)
    55c4:	85 ff       	sbrs	r24, 5
    55c6:	2b c0       	rjmp	.+86     	; 0x561e <_hDebug+0x72>
		{
			//gyroZangle=0;
			//gyroYangle=0;
			//gyroXangle=0;
			AnglePitch=0;
    55c8:	80 e0       	ldi	r24, 0x00	; 0
    55ca:	90 e0       	ldi	r25, 0x00	; 0
    55cc:	dc 01       	movw	r26, r24
    55ce:	80 93 18 06 	sts	0x0618, r24
    55d2:	90 93 19 06 	sts	0x0619, r25
    55d6:	a0 93 1a 06 	sts	0x061A, r26
    55da:	b0 93 1b 06 	sts	0x061B, r27
			AngleRoll=0;
    55de:	80 93 ca 06 	sts	0x06CA, r24
    55e2:	90 93 cb 06 	sts	0x06CB, r25
    55e6:	a0 93 cc 06 	sts	0x06CC, r26
    55ea:	b0 93 cd 06 	sts	0x06CD, r27
			YAWAngle2=0;
    55ee:	80 93 38 05 	sts	0x0538, r24
    55f2:	90 93 39 05 	sts	0x0539, r25
    55f6:	a0 93 3a 05 	sts	0x053A, r26
    55fa:	b0 93 3b 05 	sts	0x053B, r27
			YAWAngle=0;
    55fe:	80 93 3c 05 	sts	0x053C, r24
    5602:	90 93 3d 05 	sts	0x053D, r25
    5606:	a0 93 3e 05 	sts	0x053E, r26
    560a:	b0 93 3f 05 	sts	0x053F, r27
			OldAngle=0;
    560e:	80 93 40 05 	sts	0x0540, r24
    5612:	90 93 41 05 	sts	0x0541, r25
    5616:	a0 93 42 05 	sts	0x0542, r26
    561a:	b0 93 43 05 	sts	0x0543, r27
	//{
    double Temp;
	//RX_SONAR_TRIGGER = HIGH;
	//DisplayBuffer[9]=0;
	//IMU();
		RX_Snapshot   [RXChannel_RUD] = (RX_Latest[ActiveRXIndex][RXChannel_RUD] * Config.StickScaling / 20); // version 0.9.9 
    561e:	20 91 cc 05 	lds	r18, 0x05CC
    5622:	82 2f       	mov	r24, r18
    5624:	90 e0       	ldi	r25, 0x00	; 0
    5626:	fc 01       	movw	r30, r24
    5628:	ee 0f       	add	r30, r30
    562a:	ff 1f       	adc	r31, r31
    562c:	43 e0       	ldi	r20, 0x03	; 3
    562e:	88 0f       	add	r24, r24
    5630:	99 1f       	adc	r25, r25
    5632:	4a 95       	dec	r20
    5634:	e1 f7       	brne	.-8      	; 0x562e <_hDebug+0x82>
    5636:	e8 0f       	add	r30, r24
    5638:	f9 1f       	adc	r31, r25
    563a:	ec 5f       	subi	r30, 0xFC	; 252
    563c:	f9 4f       	sbci	r31, 0xF9	; 249
    563e:	24 81       	ldd	r18, Z+4	; 0x04
    5640:	35 81       	ldd	r19, Z+5	; 0x05
    5642:	40 91 dd 06 	lds	r20, 0x06DD
    5646:	50 e0       	ldi	r21, 0x00	; 0
    5648:	42 9f       	mul	r20, r18
    564a:	c0 01       	movw	r24, r0
    564c:	43 9f       	mul	r20, r19
    564e:	90 0d       	add	r25, r0
    5650:	52 9f       	mul	r21, r18
    5652:	90 0d       	add	r25, r0
    5654:	11 24       	eor	r1, r1
    5656:	64 e1       	ldi	r22, 0x14	; 20
    5658:	70 e0       	ldi	r23, 0x00	; 0
    565a:	0e 94 aa 3a 	call	0x7554	; 0x7554 <__divmodhi4>
    565e:	8b 01       	movw	r16, r22
    5660:	70 93 c5 05 	sts	0x05C5, r23
    5664:	60 93 c4 05 	sts	0x05C4, r22
		
				gyroYaw = gyroYaw * 4;
    5668:	c0 91 cf 06 	lds	r28, 0x06CF
    566c:	d0 91 d0 06 	lds	r29, 0x06D0
    5670:	cc 0f       	add	r28, r28
    5672:	dd 1f       	adc	r29, r29
    5674:	cc 0f       	add	r28, r28
    5676:	dd 1f       	adc	r29, r29
    5678:	d0 93 d0 06 	sts	0x06D0, r29
    567c:	c0 93 cf 06 	sts	0x06CF, r28
				//LowpassOutYaw = (3 * LowpassOutYaw + gyroYaw) / 4;
				MotorOut[3]  = gyroYaw + SERVO_IN_MIDDLE - (RX_Snapshot[RXChannel_RUD] / 2.0); //( 2.0 * MotorOut[3] +  gyroYaw + SERVO_IN_MIDDLE) / 3.0;
    5680:	be 01       	movw	r22, r28
    5682:	6a 5d       	subi	r22, 0xDA	; 218
    5684:	7d 4f       	sbci	r23, 0xFD	; 253
    5686:	88 27       	eor	r24, r24
    5688:	77 fd       	sbrc	r23, 7
    568a:	80 95       	com	r24
    568c:	98 2f       	mov	r25, r24
    568e:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    5692:	6b 01       	movw	r12, r22
    5694:	7c 01       	movw	r14, r24
    5696:	b8 01       	movw	r22, r16
    5698:	88 27       	eor	r24, r24
    569a:	77 fd       	sbrc	r23, 7
    569c:	80 95       	com	r24
    569e:	98 2f       	mov	r25, r24
    56a0:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    56a4:	20 e0       	ldi	r18, 0x00	; 0
    56a6:	30 e0       	ldi	r19, 0x00	; 0
    56a8:	40 e0       	ldi	r20, 0x00	; 0
    56aa:	5f e3       	ldi	r21, 0x3F	; 63
    56ac:	0e 94 dc 39 	call	0x73b8	; 0x73b8 <__mulsf3>
    56b0:	9b 01       	movw	r18, r22
    56b2:	ac 01       	movw	r20, r24
    56b4:	c7 01       	movw	r24, r14
    56b6:	b6 01       	movw	r22, r12
    56b8:	0e 94 24 38 	call	0x7048	; 0x7048 <__subsf3>
    56bc:	0e 94 f5 38 	call	0x71ea	; 0x71ea <__fixsfsi>
    56c0:	70 93 9f 05 	sts	0x059F, r23
    56c4:	60 93 9e 05 	sts	0x059E, r22
				//ATOMIC_BLOCK(ATOMIC_FORCEON)
				//{	
					//Temp = RX_SONAR_RAW; 
				//}
				//LCD_WriteValue(0,48, Temp,6,false);
				LCD_WriteValue(1,48, gyroYaw,9,false);
    56c8:	81 e0       	ldi	r24, 0x01	; 1
    56ca:	60 e3       	ldi	r22, 0x30	; 48
    56cc:	ae 01       	movw	r20, r28
    56ce:	29 e0       	ldi	r18, 0x09	; 9
    56d0:	00 e0       	ldi	r16, 0x00	; 0
    56d2:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <LCD_WriteValue>
				LCD_WriteValue(2,48, RX_Snapshot[RXChannel_RUD],9,false);
    56d6:	40 91 c4 05 	lds	r20, 0x05C4
    56da:	50 91 c5 05 	lds	r21, 0x05C5
    56de:	82 e0       	ldi	r24, 0x02	; 2
    56e0:	60 e3       	ldi	r22, 0x30	; 48
    56e2:	29 e0       	ldi	r18, 0x09	; 9
    56e4:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <LCD_WriteValue>
				//LCD_WriteValue_double_ex(3,48, OldAngle,9,false);
				LCD_WriteValue(4,48, MotorOut[3],9,false);
    56e8:	40 91 9e 05 	lds	r20, 0x059E
    56ec:	50 91 9f 05 	lds	r21, 0x059F
    56f0:	84 e0       	ldi	r24, 0x04	; 4
    56f2:	60 e3       	ldi	r22, 0x30	; 48
    56f4:	29 e0       	ldi	r18, 0x09	; 9
    56f6:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <LCD_WriteValue>
	LCD_SetPos(5,48);
	strcat_P(sXDeg,strSPC3);
	LCD_WriteString(sXDeg);
*/
	}
}
    56fa:	df 91       	pop	r29
    56fc:	cf 91       	pop	r28
    56fe:	1f 91       	pop	r17
    5700:	0f 91       	pop	r16
    5702:	ff 90       	pop	r15
    5704:	ef 90       	pop	r14
    5706:	df 90       	pop	r13
    5708:	cf 90       	pop	r12
    570a:	08 95       	ret

0000570c <_hSensorCalibration>:

	_helper_DisplayRXStatus(6);
}

void _hSensorCalibration()
{
    570c:	0f 93       	push	r16
    570e:	1f 93       	push	r17
    5710:	cf 93       	push	r28
    5712:	df 93       	push	r29
	NOKEYRETURN;
    5714:	80 91 bc 05 	lds	r24, 0x05BC
    5718:	88 23       	and	r24, r24
    571a:	69 f1       	breq	.+90     	; 0x5776 <_hSensorCalibration+0x6a>
	uint8_t i;
		
	if (KEY4)
    571c:	84 ff       	sbrs	r24, 4
    571e:	19 c0       	rjmp	.+50     	; 0x5752 <_hSensorCalibration+0x46>
    5720:	15 e0       	ldi	r17, 0x05	; 5
	{
		// Delay to allow not touching the board.		
		for (i=0; i<5;++i)
		{
			LED_FlashOrangeLED (200,2);
    5722:	88 ec       	ldi	r24, 0xC8	; 200
    5724:	90 e0       	ldi	r25, 0x00	; 0
    5726:	62 e0       	ldi	r22, 0x02	; 2
    5728:	0e 94 75 0e 	call	0x1cea	; 0x1cea <LED_FlashOrangeLED>
			Beeper_Beep(BEEP_SHORT,1);
    572c:	86 e4       	ldi	r24, 0x46	; 70
    572e:	90 e0       	ldi	r25, 0x00	; 0
    5730:	61 e0       	ldi	r22, 0x01	; 1
    5732:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <Beeper_Beep>
    5736:	11 50       	subi	r17, 0x01	; 1
	uint8_t i;
		
	if (KEY4)
	{
		// Delay to allow not touching the board.		
		for (i=0; i<5;++i)
    5738:	a1 f7       	brne	.-24     	; 0x5722 <_hSensorCalibration+0x16>
		{
			LED_FlashOrangeLED (200,2);
			Beeper_Beep(BEEP_SHORT,1);
		}
	
		Sensors_Calibrate ();
    573a:	0e 94 06 29 	call	0x520c	; 0x520c <Sensors_Calibrate>
		
		Save_Config_to_EEPROM();
    573e:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <Save_Config_to_EEPROM>
		currentPage.softkeys = _skBACK;
    5742:	8e ed       	ldi	r24, 0xDE	; 222
    5744:	9c e0       	ldi	r25, 0x0C	; 12
    5746:	90 93 45 05 	sts	0x0545, r25
    574a:	80 93 44 05 	sts	0x0544, r24
		writeSoftkeys(currentPage.softkeys);
    574e:	0e 94 c1 2a 	call	0x5582	; 0x5582 <writeSoftkeys>
    5752:	c4 e5       	ldi	r28, 0x54	; 84
    5754:	d7 e0       	ldi	r29, 0x07	; 7
void _hSensorCalibration()
{
	NOKEYRETURN;
	uint8_t i;
		
	if (KEY4)
    5756:	10 e0       	ldi	r17, 0x00	; 0
	}
	
	
	for (i=0; i<6;++i)
	{ // order is aligned with ACC_PITCH_Index & GYRO_ROLL_Index
		LCD_SetPos(i, 48);
    5758:	81 2f       	mov	r24, r17
    575a:	60 e3       	ldi	r22, 0x30	; 48
    575c:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <LCD_SetPos>
		LCD_WriteValue(i,48,Config.Sensor_zero[i],5,false);
    5760:	49 91       	ld	r20, Y+
    5762:	59 91       	ld	r21, Y+
    5764:	81 2f       	mov	r24, r17
    5766:	60 e3       	ldi	r22, 0x30	; 48
    5768:	25 e0       	ldi	r18, 0x05	; 5
    576a:	00 e0       	ldi	r16, 0x00	; 0
    576c:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <LCD_WriteValue>
		currentPage.softkeys = _skBACK;
		writeSoftkeys(currentPage.softkeys);
	}
	
	
	for (i=0; i<6;++i)
    5770:	1f 5f       	subi	r17, 0xFF	; 255
    5772:	16 30       	cpi	r17, 0x06	; 6
    5774:	89 f7       	brne	.-30     	; 0x5758 <_hSensorCalibration+0x4c>
	{ // order is aligned with ACC_PITCH_Index & GYRO_ROLL_Index
		LCD_SetPos(i, 48);
		LCD_WriteValue(i,48,Config.Sensor_zero[i],5,false);
	}	
	
}
    5776:	df 91       	pop	r29
    5778:	cf 91       	pop	r28
    577a:	1f 91       	pop	r17
    577c:	0f 91       	pop	r16
    577e:	08 95       	ret

00005780 <_hSensorTest>:
	}
}


void _hSensorTest()
{
    5780:	0f 93       	push	r16
	#define AccHighLimit		850
	#define GyroLowLimit		500		
	#define GyroHighLimit		630

	
	LCD_SetPos(0, 48);
    5782:	80 e0       	ldi	r24, 0x00	; 0
    5784:	60 e3       	ldi	r22, 0x30	; 48
    5786:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <LCD_SetPos>
	LCD_WriteString(Sensors_Test(GYRO_ROLL_PNUM,GyroLowLimit,GyroHighLimit));
    578a:	81 e0       	ldi	r24, 0x01	; 1
    578c:	64 ef       	ldi	r22, 0xF4	; 244
    578e:	71 e0       	ldi	r23, 0x01	; 1
    5790:	46 e7       	ldi	r20, 0x76	; 118
    5792:	52 e0       	ldi	r21, 0x02	; 2
    5794:	0e 94 ce 28 	call	0x519c	; 0x519c <Sensors_Test>
    5798:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <LCD_WriteString>
	LCD_SetPos(1, 48);
    579c:	81 e0       	ldi	r24, 0x01	; 1
    579e:	60 e3       	ldi	r22, 0x30	; 48
    57a0:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <LCD_SetPos>
	LCD_WriteString(Sensors_Test(GYRO_PITCH_PNUM,GyroLowLimit,GyroHighLimit));
    57a4:	84 e0       	ldi	r24, 0x04	; 4
    57a6:	64 ef       	ldi	r22, 0xF4	; 244
    57a8:	71 e0       	ldi	r23, 0x01	; 1
    57aa:	46 e7       	ldi	r20, 0x76	; 118
    57ac:	52 e0       	ldi	r21, 0x02	; 2
    57ae:	0e 94 ce 28 	call	0x519c	; 0x519c <Sensors_Test>
    57b2:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <LCD_WriteString>
	LCD_SetPos(2, 48);
    57b6:	82 e0       	ldi	r24, 0x02	; 2
    57b8:	60 e3       	ldi	r22, 0x30	; 48
    57ba:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <LCD_SetPos>
	LCD_WriteString(Sensors_Test(GYRO_Z_PNUM,GyroLowLimit,GyroHighLimit));
    57be:	82 e0       	ldi	r24, 0x02	; 2
    57c0:	64 ef       	ldi	r22, 0xF4	; 244
    57c2:	71 e0       	ldi	r23, 0x01	; 1
    57c4:	46 e7       	ldi	r20, 0x76	; 118
    57c6:	52 e0       	ldi	r21, 0x02	; 2
    57c8:	0e 94 ce 28 	call	0x519c	; 0x519c <Sensors_Test>
    57cc:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <LCD_WriteString>
	
	LCD_SetPos(3, 48);
    57d0:	83 e0       	ldi	r24, 0x03	; 3
    57d2:	60 e3       	ldi	r22, 0x30	; 48
    57d4:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <LCD_SetPos>
	LCD_WriteString(Sensors_Test(ACC_PITCH_PNUM,AccLowLimit,AccHighLimit));
    57d8:	85 e0       	ldi	r24, 0x05	; 5
    57da:	62 ec       	ldi	r22, 0xC2	; 194
    57dc:	71 e0       	ldi	r23, 0x01	; 1
    57de:	42 e5       	ldi	r20, 0x52	; 82
    57e0:	53 e0       	ldi	r21, 0x03	; 3
    57e2:	0e 94 ce 28 	call	0x519c	; 0x519c <Sensors_Test>
    57e6:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <LCD_WriteString>
	LCD_SetPos(4, 48);
    57ea:	84 e0       	ldi	r24, 0x04	; 4
    57ec:	60 e3       	ldi	r22, 0x30	; 48
    57ee:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <LCD_SetPos>
	LCD_WriteString(Sensors_Test(ACC_ROLL_PNUM,AccLowLimit,AccHighLimit));
    57f2:	86 e0       	ldi	r24, 0x06	; 6
    57f4:	62 ec       	ldi	r22, 0xC2	; 194
    57f6:	71 e0       	ldi	r23, 0x01	; 1
    57f8:	42 e5       	ldi	r20, 0x52	; 82
    57fa:	53 e0       	ldi	r21, 0x03	; 3
    57fc:	0e 94 ce 28 	call	0x519c	; 0x519c <Sensors_Test>
    5800:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <LCD_WriteString>
	LCD_SetPos(5, 48);
    5804:	85 e0       	ldi	r24, 0x05	; 5
    5806:	60 e3       	ldi	r22, 0x30	; 48
    5808:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <LCD_SetPos>
	LCD_WriteString(Sensors_Test(ACC_Z_PNUM,AccLowLimit,AccHighLimit));
    580c:	87 e0       	ldi	r24, 0x07	; 7
    580e:	62 ec       	ldi	r22, 0xC2	; 194
    5810:	71 e0       	ldi	r23, 0x01	; 1
    5812:	42 e5       	ldi	r20, 0x52	; 82
    5814:	53 e0       	ldi	r21, 0x03	; 3
    5816:	0e 94 ce 28 	call	0x519c	; 0x519c <Sensors_Test>
    581a:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <LCD_WriteString>
	LCD_SetPos(6, 48);
    581e:	86 e0       	ldi	r24, 0x06	; 6
    5820:	60 e3       	ldi	r22, 0x30	; 48
    5822:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <LCD_SetPos>
	LCD_WriteValue_double(6,48,Sensor_GetBattery(),false);
    5826:	0e 94 d4 29 	call	0x53a8	; 0x53a8 <Sensor_GetBattery>
    582a:	9c 01       	movw	r18, r24
    582c:	b9 01       	movw	r22, r18
    582e:	88 27       	eor	r24, r24
    5830:	77 fd       	sbrc	r23, 7
    5832:	80 95       	com	r24
    5834:	98 2f       	mov	r25, r24
    5836:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    583a:	9b 01       	movw	r18, r22
    583c:	ac 01       	movw	r20, r24
    583e:	86 e0       	ldi	r24, 0x06	; 6
    5840:	60 e3       	ldi	r22, 0x30	; 48
    5842:	00 e0       	ldi	r16, 0x00	; 0
    5844:	0e 94 d1 0d 	call	0x1ba2	; 0x1ba2 <LCD_WriteValue_double>
}
    5848:	0f 91       	pop	r16
    584a:	08 95       	ret

0000584c <_hHomeArmedESC>:


void _hHomeArmedESC (void)
{
	
	if (IS_INIT)	
    584c:	80 91 bc 05 	lds	r24, 0x05BC
    5850:	80 ff       	sbrs	r24, 0
    5852:	10 c0       	rjmp	.+32     	; 0x5874 <_hHomeArmedESC+0x28>
	{
		LCD_SelectFont (&font12x16);
    5854:	80 e3       	ldi	r24, 0x30	; 48
    5856:	91 e0       	ldi	r25, 0x01	; 1
    5858:	0e 94 3b 0e 	call	0x1c76	; 0x1c76 <LCD_SelectFont>
		LCD_SetPos(0,0);
    585c:	80 e0       	ldi	r24, 0x00	; 0
    585e:	60 e0       	ldi	r22, 0x00	; 0
    5860:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <LCD_SetPos>
		LCD_WriteString_P(strARMED);
    5864:	82 e0       	ldi	r24, 0x02	; 2
    5866:	9d e0       	ldi	r25, 0x0D	; 13
    5868:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <LCD_WriteString_P>
		LCD_SelectFont (NULL);
    586c:	80 e0       	ldi	r24, 0x00	; 0
    586e:	90 e0       	ldi	r25, 0x00	; 0
    5870:	0e 94 3b 0e 	call	0x1c76	; 0x1c76 <LCD_SelectFont>
	}
	
	if (KEY4)
    5874:	80 91 bc 05 	lds	r24, 0x05BC
    5878:	84 ff       	sbrs	r24, 4
    587a:	04 c0       	rjmp	.+8      	; 0x5884 <_hHomeArmedESC+0x38>
	{
		//reset ESC Calibration mode.
		Config.IsESCCalibration=ESCCalibration_OFF;
    587c:	10 92 d7 06 	sts	0x06D7, r1
		Save_Config_to_EEPROM();
    5880:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <Save_Config_to_EEPROM>
	}
	
	LCD_SetPos(3,18);
    5884:	83 e0       	ldi	r24, 0x03	; 3
    5886:	62 e1       	ldi	r22, 0x12	; 18
    5888:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <LCD_SetPos>
	itoa(MotorOut[0],sXDeg,10);
    588c:	80 91 98 05 	lds	r24, 0x0598
    5890:	90 91 99 05 	lds	r25, 0x0599
    5894:	6c ee       	ldi	r22, 0xEC	; 236
    5896:	75 e0       	ldi	r23, 0x05	; 5
    5898:	4a e0       	ldi	r20, 0x0A	; 10
    589a:	50 e0       	ldi	r21, 0x00	; 0
    589c:	0e 94 15 3b 	call	0x762a	; 0x762a <itoa>
	LCD_WritePadded(sXDeg,5);
    58a0:	8c ee       	ldi	r24, 0xEC	; 236
    58a2:	95 e0       	ldi	r25, 0x05	; 5
    58a4:	65 e0       	ldi	r22, 0x05	; 5
    58a6:	0e 94 36 0d 	call	0x1a6c	; 0x1a6c <LCD_WritePadded>
	
	LCD_SetPos(3,78);
    58aa:	83 e0       	ldi	r24, 0x03	; 3
    58ac:	6e e4       	ldi	r22, 0x4E	; 78
    58ae:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <LCD_SetPos>
	itoa(MotorOut[3],sXDeg,10);
    58b2:	80 91 9e 05 	lds	r24, 0x059E
    58b6:	90 91 9f 05 	lds	r25, 0x059F
    58ba:	6c ee       	ldi	r22, 0xEC	; 236
    58bc:	75 e0       	ldi	r23, 0x05	; 5
    58be:	4a e0       	ldi	r20, 0x0A	; 10
    58c0:	50 e0       	ldi	r21, 0x00	; 0
    58c2:	0e 94 15 3b 	call	0x762a	; 0x762a <itoa>
	LCD_WritePadded(sXDeg,5);
    58c6:	8c ee       	ldi	r24, 0xEC	; 236
    58c8:	95 e0       	ldi	r25, 0x05	; 5
    58ca:	65 e0       	ldi	r22, 0x05	; 5
    58cc:	0e 94 36 0d 	call	0x1a6c	; 0x1a6c <LCD_WritePadded>
	
	LCD_SetPos(4,18);
    58d0:	84 e0       	ldi	r24, 0x04	; 4
    58d2:	62 e1       	ldi	r22, 0x12	; 18
    58d4:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <LCD_SetPos>
	itoa(MotorOut[1],sXDeg,10);
    58d8:	80 91 9a 05 	lds	r24, 0x059A
    58dc:	90 91 9b 05 	lds	r25, 0x059B
    58e0:	6c ee       	ldi	r22, 0xEC	; 236
    58e2:	75 e0       	ldi	r23, 0x05	; 5
    58e4:	4a e0       	ldi	r20, 0x0A	; 10
    58e6:	50 e0       	ldi	r21, 0x00	; 0
    58e8:	0e 94 15 3b 	call	0x762a	; 0x762a <itoa>
	LCD_WritePadded(sXDeg,5);
    58ec:	8c ee       	ldi	r24, 0xEC	; 236
    58ee:	95 e0       	ldi	r25, 0x05	; 5
    58f0:	65 e0       	ldi	r22, 0x05	; 5
    58f2:	0e 94 36 0d 	call	0x1a6c	; 0x1a6c <LCD_WritePadded>
	
	LCD_SetPos(4,78);
    58f6:	84 e0       	ldi	r24, 0x04	; 4
    58f8:	6e e4       	ldi	r22, 0x4E	; 78
    58fa:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <LCD_SetPos>
	itoa(MotorOut[2],sXDeg,10);
    58fe:	80 91 9c 05 	lds	r24, 0x059C
    5902:	90 91 9d 05 	lds	r25, 0x059D
    5906:	6c ee       	ldi	r22, 0xEC	; 236
    5908:	75 e0       	ldi	r23, 0x05	; 5
    590a:	4a e0       	ldi	r20, 0x0A	; 10
    590c:	50 e0       	ldi	r21, 0x00	; 0
    590e:	0e 94 15 3b 	call	0x762a	; 0x762a <itoa>
	LCD_WritePadded(sXDeg,5);
    5912:	8c ee       	ldi	r24, 0xEC	; 236
    5914:	95 e0       	ldi	r25, 0x05	; 5
    5916:	65 e0       	ldi	r22, 0x05	; 5
    5918:	0e 94 36 0d 	call	0x1a6c	; 0x1a6c <LCD_WritePadded>
	
}
    591c:	08 95       	ret

0000591e <_helper_DisplayBiStateText>:
	};
//////////////////////////////////////////////////////////////////////////

	
void _helper_DisplayBiStateText(uint8_t Row, uint8_t Col, PGM_P strTrue, PGM_P strFalse, bool Condition, BOOL LCDReverse )
{
    591e:	af 92       	push	r10
    5920:	bf 92       	push	r11
    5922:	cf 92       	push	r12
    5924:	df 92       	push	r13
    5926:	ef 92       	push	r14
    5928:	0f 93       	push	r16
    592a:	1f 93       	push	r17
    592c:	df 93       	push	r29
    592e:	cf 93       	push	r28
    5930:	0f 92       	push	r0
    5932:	cd b7       	in	r28, 0x3d	; 61
    5934:	de b7       	in	r29, 0x3e	; 62
    5936:	18 2f       	mov	r17, r24
    5938:	6a 01       	movw	r12, r20
    593a:	59 01       	movw	r10, r18
    593c:	8e 2d       	mov	r24, r14
		lcdReverse(LCDReverse);
    593e:	69 83       	std	Y+1, r22	; 0x01
    5940:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <lcdReverse>
		LCD_SetPos(Row, Col);
    5944:	81 2f       	mov	r24, r17
    5946:	69 81       	ldd	r22, Y+1	; 0x01
    5948:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <LCD_SetPos>
		if (Condition==true) 
    594c:	00 23       	and	r16, r16
    594e:	11 f0       	breq	.+4      	; 0x5954 <_helper_DisplayBiStateText+0x36>
		{
			LCD_WriteString_P(strTrue);
    5950:	c6 01       	movw	r24, r12
    5952:	01 c0       	rjmp	.+2      	; 0x5956 <_helper_DisplayBiStateText+0x38>
		}
		else
		{
			LCD_WriteString_P(strFalse);
    5954:	c5 01       	movw	r24, r10
    5956:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <LCD_WriteString_P>
		}	
		lcdReverse(false);
    595a:	80 e0       	ldi	r24, 0x00	; 0
    595c:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <lcdReverse>
}
    5960:	0f 90       	pop	r0
    5962:	cf 91       	pop	r28
    5964:	df 91       	pop	r29
    5966:	1f 91       	pop	r17
    5968:	0f 91       	pop	r16
    596a:	ef 90       	pop	r14
    596c:	df 90       	pop	r13
    596e:	cf 90       	pop	r12
    5970:	bf 90       	pop	r11
    5972:	af 90       	pop	r10
    5974:	08 95       	ret

00005976 <_helper_SaveinEEPROM_ifChanged>:


void _helper_SaveinEEPROM_ifChanged()
{
	if (bValueChanged==true)
    5976:	80 91 32 05 	lds	r24, 0x0532
    597a:	81 30       	cpi	r24, 0x01	; 1
    597c:	21 f4       	brne	.+8      	; 0x5986 <_helper_SaveinEEPROM_ifChanged+0x10>
		{
			Save_Config_to_EEPROM();
    597e:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <Save_Config_to_EEPROM>
			bValueChanged = false;
    5982:	10 92 32 05 	sts	0x0532, r1
    5986:	08 95       	ret

00005988 <_helper_DisplayRXStatus>:
			return ;
	}
}

void _helper_DisplayRXStatus(uint8_t Row)
{
    5988:	ef 92       	push	r14
    598a:	0f 93       	push	r16
    598c:	1f 93       	push	r17
    598e:	18 2f       	mov	r17, r24
	// Write RX Status
	// FIX: highlighted is the selected one.
	_helper_DisplayBiStateText(Row,18,str1,strX,IS_TX1_GOOD,(ActiveRXIndex!=1));
    5990:	20 91 b8 07 	lds	r18, 0x07B8
    5994:	80 91 cc 05 	lds	r24, 0x05CC
    5998:	30 e0       	ldi	r19, 0x00	; 0
    599a:	2f 70       	andi	r18, 0x0F	; 15
    599c:	30 70       	andi	r19, 0x00	; 0
    599e:	01 e0       	ldi	r16, 0x01	; 1
    59a0:	21 15       	cp	r18, r1
    59a2:	31 05       	cpc	r19, r1
    59a4:	09 f0       	breq	.+2      	; 0x59a8 <_helper_DisplayRXStatus+0x20>
    59a6:	00 e0       	ldi	r16, 0x00	; 0
    59a8:	91 e0       	ldi	r25, 0x01	; 1
    59aa:	81 30       	cpi	r24, 0x01	; 1
    59ac:	09 f4       	brne	.+2      	; 0x59b0 <_helper_DisplayRXStatus+0x28>
    59ae:	90 e0       	ldi	r25, 0x00	; 0
    59b0:	81 2f       	mov	r24, r17
    59b2:	62 e1       	ldi	r22, 0x12	; 18
    59b4:	41 e2       	ldi	r20, 0x21	; 33
    59b6:	5d e0       	ldi	r21, 0x0D	; 13
    59b8:	23 e2       	ldi	r18, 0x23	; 35
    59ba:	3d e0       	ldi	r19, 0x0D	; 13
    59bc:	e9 2e       	mov	r14, r25
    59be:	0e 94 8f 2c 	call	0x591e	; 0x591e <_helper_DisplayBiStateText>
	
	_helper_DisplayBiStateText(Row,30,str2,strX,IS_TX2_GOOD,(ActiveRXIndex!=0));
    59c2:	80 91 b8 07 	lds	r24, 0x07B8
    59c6:	20 91 cc 05 	lds	r18, 0x05CC
    59ca:	80 7f       	andi	r24, 0xF0	; 240
    59cc:	01 e0       	ldi	r16, 0x01	; 1
    59ce:	09 f0       	breq	.+2      	; 0x59d2 <_helper_DisplayRXStatus+0x4a>
    59d0:	00 e0       	ldi	r16, 0x00	; 0
    59d2:	91 e0       	ldi	r25, 0x01	; 1
    59d4:	22 23       	and	r18, r18
    59d6:	09 f4       	brne	.+2      	; 0x59da <_helper_DisplayRXStatus+0x52>
    59d8:	90 e0       	ldi	r25, 0x00	; 0
    59da:	81 2f       	mov	r24, r17
    59dc:	6e e1       	ldi	r22, 0x1E	; 30
    59de:	45 e2       	ldi	r20, 0x25	; 37
    59e0:	5d e0       	ldi	r21, 0x0D	; 13
    59e2:	23 e2       	ldi	r18, 0x23	; 35
    59e4:	3d e0       	ldi	r19, 0x0D	; 13
    59e6:	e9 2e       	mov	r14, r25
    59e8:	0e 94 8f 2c 	call	0x591e	; 0x591e <_helper_DisplayBiStateText>
	
	lcdReverse(false);
    59ec:	80 e0       	ldi	r24, 0x00	; 0
    59ee:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <lcdReverse>
	
}
    59f2:	1f 91       	pop	r17
    59f4:	0f 91       	pop	r16
    59f6:	ef 90       	pop	r14
    59f8:	08 95       	ret

000059fa <_hStickCentering>:



BOOL bError; 
void _hStickCentering()
{
    59fa:	0f 93       	push	r16
    59fc:	1f 93       	push	r17
    59fe:	cf 93       	push	r28
    5a00:	df 93       	push	r29
	uint8_t i ;
	UIEnableStickCommands=false; // you cannot use sticks here. for arming or as buttons.
    5a02:	10 92 e7 05 	sts	0x05E7, r1
	
	if (IS_INIT)
    5a06:	80 91 bc 05 	lds	r24, 0x05BC
    5a0a:	80 ff       	sbrs	r24, 0
    5a0c:	0c c0       	rjmp	.+24     	; 0x5a26 <_hStickCentering+0x2c>
	{
		RX_StickCenterCalibrationInit(ActiveRXIndex);
    5a0e:	80 91 cc 05 	lds	r24, 0x05CC
    5a12:	0e 94 d1 27 	call	0x4fa2	; 0x4fa2 <RX_StickCenterCalibrationInit>
		LCD_WriteString_Pex(0,0,strSPC1,18,false); // clear the header
    5a16:	80 e0       	ldi	r24, 0x00	; 0
    5a18:	60 e0       	ldi	r22, 0x00	; 0
    5a1a:	44 ef       	ldi	r20, 0xF4	; 244
    5a1c:	5c e0       	ldi	r21, 0x0C	; 12
    5a1e:	22 e1       	ldi	r18, 0x12	; 18
    5a20:	00 e0       	ldi	r16, 0x00	; 0
    5a22:	0e 94 6c 0d 	call	0x1ad8	; 0x1ad8 <LCD_WriteString_Pex>
	}
	
	if (KEY4)
    5a26:	80 91 bc 05 	lds	r24, 0x05BC
    5a2a:	84 ff       	sbrs	r24, 4
    5a2c:	bf c0       	rjmp	.+382    	; 0x5bac <_hStickCentering+0x1b2>
	{
		if (!bError)
    5a2e:	80 91 03 08 	lds	r24, 0x0803
    5a32:	88 23       	and	r24, r24
    5a34:	09 f0       	breq	.+2      	; 0x5a38 <_hStickCentering+0x3e>
    5a36:	b5 c0       	rjmp	.+362    	; 0x5ba2 <_hStickCentering+0x1a8>
    5a38:	20 e0       	ldi	r18, 0x00	; 0
    5a3a:	30 e0       	ldi	r19, 0x00	; 0
			// Save config
			for (i = 0; i < RXChannels; i++)
			{
				Config.RX_Mid[ActiveRXIndex][i] = (RX_MAX_raw[ActiveRXIndex][i]+RX_MIN_raw[ActiveRXIndex][i])/2;
				Config.RX_Min[ActiveRXIndex][i] = RX_MIN_raw[ActiveRXIndex][i];
				Config.RX_DiV_Value[ActiveRXIndex][i] = ((RX_MAX_raw[ActiveRXIndex][i] - RX_MIN_raw[ActiveRXIndex][i]) / 1000);
    5a3c:	08 ee       	ldi	r16, 0xE8	; 232
    5a3e:	13 e0       	ldi	r17, 0x03	; 3
		if (!bError)
		{
			// Save config
			for (i = 0; i < RXChannels; i++)
			{
				Config.RX_Mid[ActiveRXIndex][i] = (RX_MAX_raw[ActiveRXIndex][i]+RX_MIN_raw[ActiveRXIndex][i])/2;
    5a40:	80 91 cc 05 	lds	r24, 0x05CC
    5a44:	40 91 cc 05 	lds	r20, 0x05CC
    5a48:	60 91 cc 05 	lds	r22, 0x05CC
    5a4c:	90 e0       	ldi	r25, 0x00	; 0
    5a4e:	fc 01       	movw	r30, r24
    5a50:	ee 0f       	add	r30, r30
    5a52:	ff 1f       	adc	r31, r31
    5a54:	ee 0f       	add	r30, r30
    5a56:	ff 1f       	adc	r31, r31
    5a58:	e8 0f       	add	r30, r24
    5a5a:	f9 1f       	adc	r31, r25
    5a5c:	e2 0f       	add	r30, r18
    5a5e:	f3 1f       	adc	r31, r19
    5a60:	ee 0f       	add	r30, r30
    5a62:	ff 1f       	adc	r31, r31
    5a64:	e8 5d       	subi	r30, 0xD8	; 216
    5a66:	f8 4f       	sbci	r31, 0xF8	; 248
    5a68:	70 e0       	ldi	r23, 0x00	; 0
    5a6a:	cb 01       	movw	r24, r22
    5a6c:	88 0f       	add	r24, r24
    5a6e:	99 1f       	adc	r25, r25
    5a70:	88 0f       	add	r24, r24
    5a72:	99 1f       	adc	r25, r25
    5a74:	86 0f       	add	r24, r22
    5a76:	97 1f       	adc	r25, r23
    5a78:	82 0f       	add	r24, r18
    5a7a:	93 1f       	adc	r25, r19
    5a7c:	88 0f       	add	r24, r24
    5a7e:	99 1f       	adc	r25, r25
    5a80:	80 55       	subi	r24, 0x50	; 80
    5a82:	99 4f       	sbci	r25, 0xF9	; 249
    5a84:	50 e0       	ldi	r21, 0x00	; 0
    5a86:	da 01       	movw	r26, r20
    5a88:	aa 0f       	add	r26, r26
    5a8a:	bb 1f       	adc	r27, r27
    5a8c:	aa 0f       	add	r26, r26
    5a8e:	bb 1f       	adc	r27, r27
    5a90:	a4 0f       	add	r26, r20
    5a92:	b5 1f       	adc	r27, r21
    5a94:	a2 0f       	add	r26, r18
    5a96:	b3 1f       	adc	r27, r19
    5a98:	aa 0f       	add	r26, r26
    5a9a:	bb 1f       	adc	r27, r27
    5a9c:	ad 5d       	subi	r26, 0xDD	; 221
    5a9e:	b9 4f       	sbci	r27, 0xF9	; 249
    5aa0:	ec 01       	movw	r28, r24
    5aa2:	88 81       	ld	r24, Y
    5aa4:	99 81       	ldd	r25, Y+1	; 0x01
    5aa6:	4d 91       	ld	r20, X+
    5aa8:	5c 91       	ld	r21, X
    5aaa:	84 0f       	add	r24, r20
    5aac:	95 1f       	adc	r25, r21
    5aae:	96 95       	lsr	r25
    5ab0:	87 95       	ror	r24
    5ab2:	91 83       	std	Z+1, r25	; 0x01
    5ab4:	80 83       	st	Z, r24
				Config.RX_Min[ActiveRXIndex][i] = RX_MIN_raw[ActiveRXIndex][i];
    5ab6:	40 91 cc 05 	lds	r20, 0x05CC
    5aba:	80 91 cc 05 	lds	r24, 0x05CC
    5abe:	50 e0       	ldi	r21, 0x00	; 0
    5ac0:	fa 01       	movw	r30, r20
    5ac2:	ee 0f       	add	r30, r30
    5ac4:	ff 1f       	adc	r31, r31
    5ac6:	ee 0f       	add	r30, r30
    5ac8:	ff 1f       	adc	r31, r31
    5aca:	e4 0f       	add	r30, r20
    5acc:	f5 1f       	adc	r31, r21
    5ace:	e2 0f       	add	r30, r18
    5ad0:	f3 1f       	adc	r31, r19
    5ad2:	ee 0f       	add	r30, r30
    5ad4:	ff 1f       	adc	r31, r31
    5ad6:	e4 5c       	subi	r30, 0xC4	; 196
    5ad8:	f8 4f       	sbci	r31, 0xF8	; 248
    5ada:	90 e0       	ldi	r25, 0x00	; 0
    5adc:	dc 01       	movw	r26, r24
    5ade:	aa 0f       	add	r26, r26
    5ae0:	bb 1f       	adc	r27, r27
    5ae2:	aa 0f       	add	r26, r26
    5ae4:	bb 1f       	adc	r27, r27
    5ae6:	a8 0f       	add	r26, r24
    5ae8:	b9 1f       	adc	r27, r25
    5aea:	a2 0f       	add	r26, r18
    5aec:	b3 1f       	adc	r27, r19
    5aee:	aa 0f       	add	r26, r26
    5af0:	bb 1f       	adc	r27, r27
    5af2:	a0 55       	subi	r26, 0x50	; 80
    5af4:	b9 4f       	sbci	r27, 0xF9	; 249
    5af6:	8d 91       	ld	r24, X+
    5af8:	9c 91       	ld	r25, X
    5afa:	91 83       	std	Z+1, r25	; 0x01
    5afc:	80 83       	st	Z, r24
				Config.RX_DiV_Value[ActiveRXIndex][i] = ((RX_MAX_raw[ActiveRXIndex][i] - RX_MIN_raw[ActiveRXIndex][i]) / 1000);
    5afe:	80 91 cc 05 	lds	r24, 0x05CC
    5b02:	60 91 cc 05 	lds	r22, 0x05CC
    5b06:	40 91 cc 05 	lds	r20, 0x05CC
    5b0a:	90 e0       	ldi	r25, 0x00	; 0
    5b0c:	fc 01       	movw	r30, r24
    5b0e:	ee 0f       	add	r30, r30
    5b10:	ff 1f       	adc	r31, r31
    5b12:	ee 0f       	add	r30, r30
    5b14:	ff 1f       	adc	r31, r31
    5b16:	e8 0f       	add	r30, r24
    5b18:	f9 1f       	adc	r31, r25
    5b1a:	e2 0f       	add	r30, r18
    5b1c:	f3 1f       	adc	r31, r19
    5b1e:	ee 59       	subi	r30, 0x9E	; 158
    5b20:	f8 4f       	sbci	r31, 0xF8	; 248
    5b22:	70 e0       	ldi	r23, 0x00	; 0
    5b24:	cb 01       	movw	r24, r22
    5b26:	88 0f       	add	r24, r24
    5b28:	99 1f       	adc	r25, r25
    5b2a:	88 0f       	add	r24, r24
    5b2c:	99 1f       	adc	r25, r25
    5b2e:	86 0f       	add	r24, r22
    5b30:	97 1f       	adc	r25, r23
    5b32:	82 0f       	add	r24, r18
    5b34:	93 1f       	adc	r25, r19
    5b36:	88 0f       	add	r24, r24
    5b38:	99 1f       	adc	r25, r25
    5b3a:	8d 5d       	subi	r24, 0xDD	; 221
    5b3c:	99 4f       	sbci	r25, 0xF9	; 249
    5b3e:	50 e0       	ldi	r21, 0x00	; 0
    5b40:	da 01       	movw	r26, r20
    5b42:	aa 0f       	add	r26, r26
    5b44:	bb 1f       	adc	r27, r27
    5b46:	aa 0f       	add	r26, r26
    5b48:	bb 1f       	adc	r27, r27
    5b4a:	a4 0f       	add	r26, r20
    5b4c:	b5 1f       	adc	r27, r21
    5b4e:	a2 0f       	add	r26, r18
    5b50:	b3 1f       	adc	r27, r19
    5b52:	aa 0f       	add	r26, r26
    5b54:	bb 1f       	adc	r27, r27
    5b56:	a0 55       	subi	r26, 0x50	; 80
    5b58:	b9 4f       	sbci	r27, 0xF9	; 249
    5b5a:	ec 01       	movw	r28, r24
    5b5c:	88 81       	ld	r24, Y
    5b5e:	99 81       	ldd	r25, Y+1	; 0x01
    5b60:	4d 91       	ld	r20, X+
    5b62:	5c 91       	ld	r21, X
    5b64:	11 97       	sbiw	r26, 0x01	; 1
    5b66:	84 1b       	sub	r24, r20
    5b68:	95 0b       	sbc	r25, r21
    5b6a:	b8 01       	movw	r22, r16
    5b6c:	0e 94 96 3a 	call	0x752c	; 0x752c <__udivmodhi4>
    5b70:	60 83       	st	Z, r22
    5b72:	2f 5f       	subi	r18, 0xFF	; 255
    5b74:	3f 4f       	sbci	r19, 0xFF	; 255
	if (KEY4)
	{
		if (!bError)
		{
			// Save config
			for (i = 0; i < RXChannels; i++)
    5b76:	25 30       	cpi	r18, 0x05	; 5
    5b78:	31 05       	cpc	r19, r1
    5b7a:	09 f0       	breq	.+2      	; 0x5b7e <_hStickCentering+0x184>
    5b7c:	61 cf       	rjmp	.-318    	; 0x5a40 <_hStickCentering+0x46>
				Config.RX_Min[ActiveRXIndex][i] = RX_MIN_raw[ActiveRXIndex][i];
				Config.RX_DiV_Value[ActiveRXIndex][i] = ((RX_MAX_raw[ActiveRXIndex][i] - RX_MIN_raw[ActiveRXIndex][i]) / 1000);
				
			}		
			
			Config.IsCalibrated= (Config.IsCalibrated | (1 << ActiveRXIndex));	// either 0b00000001 or 0b00000010
    5b7e:	20 91 cc 05 	lds	r18, 0x05CC
    5b82:	81 e0       	ldi	r24, 0x01	; 1
    5b84:	90 e0       	ldi	r25, 0x00	; 0
    5b86:	02 c0       	rjmp	.+4      	; 0x5b8c <_hStickCentering+0x192>
    5b88:	88 0f       	add	r24, r24
    5b8a:	99 1f       	adc	r25, r25
    5b8c:	2a 95       	dec	r18
    5b8e:	e2 f7       	brpl	.-8      	; 0x5b88 <_hStickCentering+0x18e>
    5b90:	20 91 d2 06 	lds	r18, 0x06D2
    5b94:	28 2b       	or	r18, r24
    5b96:	e1 ed       	ldi	r30, 0xD1	; 209
    5b98:	f6 e0       	ldi	r31, 0x06	; 6
    5b9a:	21 83       	std	Z+1, r18	; 0x01
			Save_Config_to_EEPROM();
    5b9c:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <Save_Config_to_EEPROM>
    5ba0:	05 c0       	rjmp	.+10     	; 0x5bac <_hStickCentering+0x1b2>
		}
		else
		{
			Beeper_Beep(BEEP_ERROR,3);	
    5ba2:	88 ec       	ldi	r24, 0xC8	; 200
    5ba4:	90 e0       	ldi	r25, 0x00	; 0
    5ba6:	63 e0       	ldi	r22, 0x03	; 3
    5ba8:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <Beeper_Beep>
		}
		
	}
	
	if (KEY2)
    5bac:	80 91 bc 05 	lds	r24, 0x05BC
    5bb0:	86 ff       	sbrs	r24, 6
    5bb2:	04 c0       	rjmp	.+8      	; 0x5bbc <_hStickCentering+0x1c2>
	{
		RX_StickCenterCalibrationInit(ActiveRXIndex);				
    5bb4:	80 91 cc 05 	lds	r24, 0x05CC
    5bb8:	0e 94 d1 27 	call	0x4fa2	; 0x4fa2 <RX_StickCenterCalibrationInit>
	}
	
	bError = false;
    5bbc:	10 92 03 08 	sts	0x0803, r1
	RX_StickCenterCalibration(ActiveRXIndex);
    5bc0:	80 91 cc 05 	lds	r24, 0x05CC
    5bc4:	0e 94 78 28 	call	0x50f0	; 0x50f0 <RX_StickCenterCalibration>
    5bc8:	c0 e0       	ldi	r28, 0x00	; 0
    5bca:	d0 e0       	ldi	r29, 0x00	; 0
		else
		{
			if ((RX_MAX_raw[ActiveRXIndex][i]< RX_MIN_raw[ActiveRXIndex][i]) || (RX_MIN_raw[ActiveRXIndex][i]==0))  // RX_MIN_raw[i]=0 if the Remote is OFF when entering the test
			{
				LCD_WriteString_P(strErr);	
				bError = TRUE;
    5bcc:	11 e0       	ldi	r17, 0x01	; 1
}



BOOL bError; 
void _hStickCentering()
    5bce:	ce 01       	movw	r24, r28
	
	bError = false;
	RX_StickCenterCalibration(ActiveRXIndex);
	for (uint8_t i = 0; i < RXChannels; i++)
	{
		LCD_SetPos(i+1, 30);
    5bd0:	8f 5f       	subi	r24, 0xFF	; 255
    5bd2:	6e e1       	ldi	r22, 0x1E	; 30
    5bd4:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <LCD_SetPos>
		utoa(RX_MAX_raw[ActiveRXIndex][i], sXDeg, 10);
    5bd8:	80 91 cc 05 	lds	r24, 0x05CC
    5bdc:	90 e0       	ldi	r25, 0x00	; 0
    5bde:	fc 01       	movw	r30, r24
    5be0:	ee 0f       	add	r30, r30
    5be2:	ff 1f       	adc	r31, r31
    5be4:	ee 0f       	add	r30, r30
    5be6:	ff 1f       	adc	r31, r31
    5be8:	e8 0f       	add	r30, r24
    5bea:	f9 1f       	adc	r31, r25
    5bec:	ec 0f       	add	r30, r28
    5bee:	fd 1f       	adc	r31, r29
    5bf0:	ee 0f       	add	r30, r30
    5bf2:	ff 1f       	adc	r31, r31
    5bf4:	ed 5d       	subi	r30, 0xDD	; 221
    5bf6:	f9 4f       	sbci	r31, 0xF9	; 249
    5bf8:	80 81       	ld	r24, Z
    5bfa:	91 81       	ldd	r25, Z+1	; 0x01
    5bfc:	6c ee       	ldi	r22, 0xEC	; 236
    5bfe:	75 e0       	ldi	r23, 0x05	; 5
    5c00:	4a e0       	ldi	r20, 0x0A	; 10
    5c02:	50 e0       	ldi	r21, 0x00	; 0
    5c04:	0e 94 36 3b 	call	0x766c	; 0x766c <utoa>
		LCD_WriteString(sXDeg);
    5c08:	8c ee       	ldi	r24, 0xEC	; 236
    5c0a:	95 e0       	ldi	r25, 0x05	; 5
    5c0c:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <LCD_WriteString>
		LCD_WriteString_P(strSPC1);
    5c10:	84 ef       	ldi	r24, 0xF4	; 244
    5c12:	9c e0       	ldi	r25, 0x0C	; 12
    5c14:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <LCD_WriteString_P>
		utoa(RX_MIN_raw[ActiveRXIndex][i], sXDeg, 10);
    5c18:	80 91 cc 05 	lds	r24, 0x05CC
    5c1c:	90 e0       	ldi	r25, 0x00	; 0
    5c1e:	fc 01       	movw	r30, r24
    5c20:	ee 0f       	add	r30, r30
    5c22:	ff 1f       	adc	r31, r31
    5c24:	ee 0f       	add	r30, r30
    5c26:	ff 1f       	adc	r31, r31
    5c28:	e8 0f       	add	r30, r24
    5c2a:	f9 1f       	adc	r31, r25
    5c2c:	ec 0f       	add	r30, r28
    5c2e:	fd 1f       	adc	r31, r29
    5c30:	ee 0f       	add	r30, r30
    5c32:	ff 1f       	adc	r31, r31
    5c34:	e0 55       	subi	r30, 0x50	; 80
    5c36:	f9 4f       	sbci	r31, 0xF9	; 249
    5c38:	80 81       	ld	r24, Z
    5c3a:	91 81       	ldd	r25, Z+1	; 0x01
    5c3c:	6c ee       	ldi	r22, 0xEC	; 236
    5c3e:	75 e0       	ldi	r23, 0x05	; 5
    5c40:	4a e0       	ldi	r20, 0x0A	; 10
    5c42:	50 e0       	ldi	r21, 0x00	; 0
    5c44:	0e 94 36 3b 	call	0x766c	; 0x766c <utoa>
		LCD_WriteString(sXDeg);
    5c48:	8c ee       	ldi	r24, 0xEC	; 236
    5c4a:	95 e0       	ldi	r25, 0x05	; 5
    5c4c:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <LCD_WriteString>
		if ((ActiveRXIndex==0) && (i == RXChannel_AUX))
    5c50:	80 91 cc 05 	lds	r24, 0x05CC
    5c54:	88 23       	and	r24, r24
    5c56:	29 f4       	brne	.+10     	; 0x5c62 <_hStickCentering+0x268>
    5c58:	c4 30       	cpi	r28, 0x04	; 4
    5c5a:	19 f4       	brne	.+6      	; 0x5c62 <_hStickCentering+0x268>
		{
			LCD_WriteString_P(PSTR("NA"));
    5c5c:	8f ef       	ldi	r24, 0xFF	; 255
    5c5e:	9c e0       	ldi	r25, 0x0C	; 12
    5c60:	45 c0       	rjmp	.+138    	; 0x5cec <_hStickCentering+0x2f2>
		}
		else
		{
			if ((RX_MAX_raw[ActiveRXIndex][i]< RX_MIN_raw[ActiveRXIndex][i]) || (RX_MIN_raw[ActiveRXIndex][i]==0))  // RX_MIN_raw[i]=0 if the Remote is OFF when entering the test
    5c62:	20 91 cc 05 	lds	r18, 0x05CC
    5c66:	80 91 cc 05 	lds	r24, 0x05CC
    5c6a:	30 e0       	ldi	r19, 0x00	; 0
    5c6c:	d9 01       	movw	r26, r18
    5c6e:	aa 0f       	add	r26, r26
    5c70:	bb 1f       	adc	r27, r27
    5c72:	aa 0f       	add	r26, r26
    5c74:	bb 1f       	adc	r27, r27
    5c76:	a2 0f       	add	r26, r18
    5c78:	b3 1f       	adc	r27, r19
    5c7a:	ac 0f       	add	r26, r28
    5c7c:	bd 1f       	adc	r27, r29
    5c7e:	aa 0f       	add	r26, r26
    5c80:	bb 1f       	adc	r27, r27
    5c82:	ad 5d       	subi	r26, 0xDD	; 221
    5c84:	b9 4f       	sbci	r27, 0xF9	; 249
    5c86:	90 e0       	ldi	r25, 0x00	; 0
    5c88:	fc 01       	movw	r30, r24
    5c8a:	ee 0f       	add	r30, r30
    5c8c:	ff 1f       	adc	r31, r31
    5c8e:	ee 0f       	add	r30, r30
    5c90:	ff 1f       	adc	r31, r31
    5c92:	e8 0f       	add	r30, r24
    5c94:	f9 1f       	adc	r31, r25
    5c96:	ec 0f       	add	r30, r28
    5c98:	fd 1f       	adc	r31, r29
    5c9a:	ee 0f       	add	r30, r30
    5c9c:	ff 1f       	adc	r31, r31
    5c9e:	e0 55       	subi	r30, 0x50	; 80
    5ca0:	f9 4f       	sbci	r31, 0xF9	; 249
    5ca2:	2d 91       	ld	r18, X+
    5ca4:	3c 91       	ld	r19, X
    5ca6:	11 97       	sbiw	r26, 0x01	; 1
    5ca8:	80 81       	ld	r24, Z
    5caa:	91 81       	ldd	r25, Z+1	; 0x01
    5cac:	28 17       	cp	r18, r24
    5cae:	39 07       	cpc	r19, r25
    5cb0:	a0 f0       	brcs	.+40     	; 0x5cda <_hStickCentering+0x2e0>
    5cb2:	80 91 cc 05 	lds	r24, 0x05CC
    5cb6:	90 e0       	ldi	r25, 0x00	; 0
    5cb8:	fc 01       	movw	r30, r24
    5cba:	ee 0f       	add	r30, r30
    5cbc:	ff 1f       	adc	r31, r31
    5cbe:	ee 0f       	add	r30, r30
    5cc0:	ff 1f       	adc	r31, r31
    5cc2:	e8 0f       	add	r30, r24
    5cc4:	f9 1f       	adc	r31, r25
    5cc6:	ec 0f       	add	r30, r28
    5cc8:	fd 1f       	adc	r31, r29
    5cca:	ee 0f       	add	r30, r30
    5ccc:	ff 1f       	adc	r31, r31
    5cce:	e0 55       	subi	r30, 0x50	; 80
    5cd0:	f9 4f       	sbci	r31, 0xF9	; 249
    5cd2:	80 81       	ld	r24, Z
    5cd4:	91 81       	ldd	r25, Z+1	; 0x01
    5cd6:	00 97       	sbiw	r24, 0x00	; 0
    5cd8:	39 f4       	brne	.+14     	; 0x5ce8 <_hStickCentering+0x2ee>
			{
				LCD_WriteString_P(strErr);	
    5cda:	86 ef       	ldi	r24, 0xF6	; 246
    5cdc:	9c e0       	ldi	r25, 0x0C	; 12
    5cde:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <LCD_WriteString_P>
				bError = TRUE;
    5ce2:	10 93 03 08 	sts	0x0803, r17
    5ce6:	04 c0       	rjmp	.+8      	; 0x5cf0 <_hStickCentering+0x2f6>
			}
			else
			{
				LCD_WriteString_P(strSPC4);	
    5ce8:	8a ef       	ldi	r24, 0xFA	; 250
    5cea:	9c e0       	ldi	r25, 0x0C	; 12
    5cec:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <LCD_WriteString_P>
    5cf0:	21 96       	adiw	r28, 0x01	; 1
		RX_StickCenterCalibrationInit(ActiveRXIndex);				
	}
	
	bError = false;
	RX_StickCenterCalibration(ActiveRXIndex);
	for (uint8_t i = 0; i < RXChannels; i++)
    5cf2:	c5 30       	cpi	r28, 0x05	; 5
    5cf4:	d1 05       	cpc	r29, r1
    5cf6:	09 f0       	breq	.+2      	; 0x5cfa <_hStickCentering+0x300>
    5cf8:	6a cf       	rjmp	.-300    	; 0x5bce <_hStickCentering+0x1d4>
			}
		}	
	}
	

	_helper_DisplayRXStatus(6);
    5cfa:	86 e0       	ldi	r24, 0x06	; 6
    5cfc:	0e 94 c4 2c 	call	0x5988	; 0x5988 <_helper_DisplayRXStatus>
}
    5d00:	df 91       	pop	r29
    5d02:	cf 91       	pop	r28
    5d04:	1f 91       	pop	r17
    5d06:	0f 91       	pop	r16
    5d08:	08 95       	ret

00005d0a <_hReceiverTest>:
	LCD_SetPos(6, 48);
	LCD_WriteValue_double(6,48,Sensor_GetBattery(),false);
}

void _hReceiverTest()
{
    5d0a:	0f 93       	push	r16
    5d0c:	1f 93       	push	r17
    5d0e:	cf 93       	push	r28
    5d10:	df 93       	push	r29
	UIEnableStickCommands=false; // you cannot use sticks here. for arming or as buttons.
    5d12:	10 92 e7 05 	sts	0x05E7, r1
	
	RX_CopyLatestReceiverValues();
    5d16:	0e 94 77 27 	call	0x4eee	; 0x4eee <RX_CopyLatestReceiverValues>
    5d1a:	c0 e0       	ldi	r28, 0x00	; 0
    5d1c:	d0 e0       	ldi	r29, 0x00	; 0
    5d1e:	ce 01       	movw	r24, r28
    5d20:	8f 5f       	subi	r24, 0xFF	; 255
    5d22:	18 2f       	mov	r17, r24
		
		
	for (uint8_t i = 0; i < RXChannels; i++)
	{
		LCD_SetPos(i+1, 24);
    5d24:	68 e1       	ldi	r22, 0x18	; 24
    5d26:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <LCD_SetPos>
			
		//itoa(RX_Latest[ActiveRXIndex][i], sXDeg, 10);
		LCD_WriteValue(i+1,36,RX_Latest[0][i],5,(!IS_TX1_GOOD));
    5d2a:	fe 01       	movw	r30, r28
    5d2c:	ee 0f       	add	r30, r30
    5d2e:	ff 1f       	adc	r31, r31
    5d30:	ec 5f       	subi	r30, 0xFC	; 252
    5d32:	f9 4f       	sbci	r31, 0xF9	; 249
    5d34:	40 81       	ld	r20, Z
    5d36:	51 81       	ldd	r21, Z+1	; 0x01
    5d38:	80 91 b8 07 	lds	r24, 0x07B8
    5d3c:	90 e0       	ldi	r25, 0x00	; 0
    5d3e:	8f 70       	andi	r24, 0x0F	; 15
    5d40:	90 70       	andi	r25, 0x00	; 0
    5d42:	01 e0       	ldi	r16, 0x01	; 1
    5d44:	00 97       	sbiw	r24, 0x00	; 0
    5d46:	09 f4       	brne	.+2      	; 0x5d4a <_hReceiverTest+0x40>
    5d48:	00 e0       	ldi	r16, 0x00	; 0
    5d4a:	81 2f       	mov	r24, r17
    5d4c:	64 e2       	ldi	r22, 0x24	; 36
    5d4e:	25 e0       	ldi	r18, 0x05	; 5
    5d50:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <LCD_WriteValue>
		LCD_WriteValue(i+1,84,RX_Latest[1][i],5,(!IS_TX2_GOOD));
    5d54:	fe 01       	movw	r30, r28
    5d56:	ee 0f       	add	r30, r30
    5d58:	ff 1f       	adc	r31, r31
    5d5a:	e2 5f       	subi	r30, 0xF2	; 242
    5d5c:	f9 4f       	sbci	r31, 0xF9	; 249
    5d5e:	40 81       	ld	r20, Z
    5d60:	51 81       	ldd	r21, Z+1	; 0x01
    5d62:	80 91 b8 07 	lds	r24, 0x07B8
    5d66:	80 7f       	andi	r24, 0xF0	; 240
    5d68:	01 e0       	ldi	r16, 0x01	; 1
    5d6a:	09 f4       	brne	.+2      	; 0x5d6e <_hReceiverTest+0x64>
    5d6c:	00 e0       	ldi	r16, 0x00	; 0
    5d6e:	81 2f       	mov	r24, r17
    5d70:	64 e5       	ldi	r22, 0x54	; 84
    5d72:	25 e0       	ldi	r18, 0x05	; 5
    5d74:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <LCD_WriteValue>
    5d78:	21 96       	adiw	r28, 0x01	; 1
	UIEnableStickCommands=false; // you cannot use sticks here. for arming or as buttons.
	
	RX_CopyLatestReceiverValues();
		
		
	for (uint8_t i = 0; i < RXChannels; i++)
    5d7a:	c5 30       	cpi	r28, 0x05	; 5
    5d7c:	d1 05       	cpc	r29, r1
    5d7e:	79 f6       	brne	.-98     	; 0x5d1e <_hReceiverTest+0x14>
		LCD_WriteValue(i+1,84,RX_Latest[1][i],5,(!IS_TX2_GOOD));
		
	}			
	
	
	_helper_DisplayRXStatus(6);
    5d80:	86 e0       	ldi	r24, 0x06	; 6
    5d82:	0e 94 c4 2c 	call	0x5988	; 0x5988 <_helper_DisplayRXStatus>
	
}
    5d86:	df 91       	pop	r29
    5d88:	cf 91       	pop	r28
    5d8a:	1f 91       	pop	r17
    5d8c:	0f 91       	pop	r16
    5d8e:	08 95       	ret

00005d90 <_helper_Words>:
	
}


void _helper_Words (int8_t row, int8_t col,  BOOL LCDReverse, bool Condition, PGM_P TrueString, PGM_P FalseString, int8_t Len)
{
    5d90:	cf 92       	push	r12
    5d92:	ef 92       	push	r14
    5d94:	ff 92       	push	r15
    5d96:	0f 93       	push	r16
    5d98:	1f 93       	push	r17
    5d9a:	94 2f       	mov	r25, r20
    5d9c:	32 2f       	mov	r19, r18
    5d9e:	2c 2d       	mov	r18, r12
	if (Condition== TRUE)
    5da0:	33 23       	and	r19, r19
    5da2:	11 f0       	breq	.+4      	; 0x5da8 <_helper_Words+0x18>
	{
		LCD_WriteString_Pex(row,col,TrueString,Len,LCDReverse);
    5da4:	a8 01       	movw	r20, r16
    5da6:	01 c0       	rjmp	.+2      	; 0x5daa <_helper_Words+0x1a>
	}
	else
	{
		LCD_WriteString_Pex(row,col,FalseString,Len,LCDReverse);
    5da8:	a7 01       	movw	r20, r14
    5daa:	09 2f       	mov	r16, r25
    5dac:	0e 94 6c 0d 	call	0x1ad8	; 0x1ad8 <LCD_WriteString_Pex>
	}
}
    5db0:	1f 91       	pop	r17
    5db2:	0f 91       	pop	r16
    5db4:	ff 90       	pop	r15
    5db6:	ef 90       	pop	r14
    5db8:	cf 90       	pop	r12
    5dba:	08 95       	ret

00005dbc <Menu_LoadPage>:

/*
//	Put screen into CurrentPage ==> MemoryScreen
*/
void Menu_LoadPage(uint8_t pageIndex)
{
    5dbc:	1f 93       	push	r17
    5dbe:	18 2f       	mov	r17, r24
	memcpy_P(&currentPage, &pages[pageIndex], sizeof(currentPage));
    5dc0:	66 e0       	ldi	r22, 0x06	; 6
    5dc2:	86 9f       	mul	r24, r22
    5dc4:	b0 01       	movw	r22, r0
    5dc6:	11 24       	eor	r1, r1
    5dc8:	62 5a       	subi	r22, 0xA2	; 162
    5dca:	72 4f       	sbci	r23, 0xF2	; 242
    5dcc:	84 e4       	ldi	r24, 0x44	; 68
    5dce:	95 e0       	ldi	r25, 0x05	; 5
    5dd0:	46 e0       	ldi	r20, 0x06	; 6
    5dd2:	50 e0       	ldi	r21, 0x00	; 0
    5dd4:	0e 94 e8 3a 	call	0x75d0	; 0x75d0 <memcpy_P>
	page = pageIndex;
    5dd8:	10 93 35 05 	sts	0x0535, r17
}
    5ddc:	1f 91       	pop	r17
    5dde:	08 95       	ret

00005de0 <_hFactoryReset>:
*/
	}
}
void _hFactoryReset()
{
	if (IS_INIT)
    5de0:	80 91 bc 05 	lds	r24, 0x05BC
    5de4:	80 ff       	sbrs	r24, 0
    5de6:	09 c0       	rjmp	.+18     	; 0x5dfa <_hFactoryReset+0x1a>
	{
		LCD_SetPos(3, 18);
    5de8:	83 e0       	ldi	r24, 0x03	; 3
    5dea:	62 e1       	ldi	r22, 0x12	; 18
    5dec:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <LCD_SetPos>
		LCD_WriteString_P(strAreYouSure);
    5df0:	84 ed       	ldi	r24, 0xD4	; 212
    5df2:	9b e0       	ldi	r25, 0x0B	; 11
    5df4:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <LCD_WriteString_P>
    5df8:	08 95       	ret
	}
	else if (KEY4)	// Yes
    5dfa:	84 ff       	sbrs	r24, 4
    5dfc:	05 c0       	rjmp	.+10     	; 0x5e08 <_hFactoryReset+0x28>
	{
		Save_Default_Config_to_EEPROM();
    5dfe:	0e 94 ba 0f 	call	0x1f74	; 0x1f74 <Save_Default_Config_to_EEPROM>
		//RST_CTRL
		Menu_LoadPage(PAGE_RESTART);
    5e02:	84 e0       	ldi	r24, 0x04	; 4
    5e04:	0e 94 de 2e 	call	0x5dbc	; 0x5dbc <Menu_LoadPage>
    5e08:	08 95       	ret

00005e0a <_hESCCalibration>:
	
}

void _hESCCalibration()
{
	NOKEYRETURN
    5e0a:	80 91 bc 05 	lds	r24, 0x05BC
    5e0e:	88 23       	and	r24, r24
    5e10:	c1 f0       	breq	.+48     	; 0x5e42 <_hESCCalibration+0x38>
	
	if (KEY4)
    5e12:	84 ff       	sbrs	r24, 4
    5e14:	16 c0       	rjmp	.+44     	; 0x5e42 <_hESCCalibration+0x38>
	{
		if ((Config.IsCalibrated & CALIBRATED_SENSOR) && ((Config.IsCalibrated & CALIBRATED_Stick_SECONDARY)==CALIBRATED_Stick_SECONDARY))
    5e16:	80 91 d2 06 	lds	r24, 0x06D2
		LCD_WriteValue(i,48,Config.Sensor_zero[i],5,false);
	}	
	
}

void _hESCCalibration()
    5e1a:	86 70       	andi	r24, 0x06	; 6
{
	NOKEYRETURN
	
	if (KEY4)
	{
		if ((Config.IsCalibrated & CALIBRATED_SENSOR) && ((Config.IsCalibrated & CALIBRATED_Stick_SECONDARY)==CALIBRATED_Stick_SECONDARY))
    5e1c:	86 30       	cpi	r24, 0x06	; 6
    5e1e:	61 f4       	brne	.+24     	; 0x5e38 <_hESCCalibration+0x2e>
		{
			SystemActions = SYS_ACT_DISARM;
    5e20:	82 e0       	ldi	r24, 0x02	; 2
    5e22:	80 93 4f 05 	sts	0x054F, r24
			Config.IsESCCalibration=ESCCalibration_ON;
    5e26:	81 e0       	ldi	r24, 0x01	; 1
    5e28:	80 93 d7 06 	sts	0x06D7, r24
			Save_Config_to_EEPROM();
    5e2c:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <Save_Config_to_EEPROM>
			Menu_LoadPage(PAGE_RESTART);
    5e30:	84 e0       	ldi	r24, 0x04	; 4
    5e32:	0e 94 de 2e 	call	0x5dbc	; 0x5dbc <Menu_LoadPage>
			return;
    5e36:	08 95       	ret
		}
		else
		{ //...flash as error
			LED_FlashOrangeLED(LED_SHORT_TOGGLE,2);
    5e38:	8e e1       	ldi	r24, 0x1E	; 30
    5e3a:	90 e0       	ldi	r25, 0x00	; 0
    5e3c:	62 e0       	ldi	r22, 0x02	; 2
    5e3e:	0e 94 75 0e 	call	0x1cea	; 0x1cea <LED_FlashOrangeLED>
    5e42:	08 95       	ret

00005e44 <_hHomeArmed>:
}

void _hHomeArmed()
{
	
	if (IS_INIT)	
    5e44:	80 91 bc 05 	lds	r24, 0x05BC
    5e48:	80 ff       	sbrs	r24, 0
    5e4a:	10 c0       	rjmp	.+32     	; 0x5e6c <_hHomeArmed+0x28>
	{
		LCD_SelectFont (&font12x16);
    5e4c:	80 e3       	ldi	r24, 0x30	; 48
    5e4e:	91 e0       	ldi	r25, 0x01	; 1
    5e50:	0e 94 3b 0e 	call	0x1c76	; 0x1c76 <LCD_SelectFont>
		LCD_SetPos(0,0);
    5e54:	80 e0       	ldi	r24, 0x00	; 0
    5e56:	60 e0       	ldi	r22, 0x00	; 0
    5e58:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <LCD_SetPos>
		LCD_WriteString_P(strARMED);
    5e5c:	82 e0       	ldi	r24, 0x02	; 2
    5e5e:	9d e0       	ldi	r25, 0x0D	; 13
    5e60:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <LCD_WriteString_P>
		LCD_SelectFont (NULL);
    5e64:	80 e0       	ldi	r24, 0x00	; 0
    5e66:	90 e0       	ldi	r25, 0x00	; 0
    5e68:	0e 94 3b 0e 	call	0x1c76	; 0x1c76 <LCD_SelectFont>
	}
	
	
	if (KEY4)	// MENU
    5e6c:	80 91 bc 05 	lds	r24, 0x05BC
    5e70:	84 ff       	sbrs	r24, 4
    5e72:	03 c0       	rjmp	.+6      	; 0x5e7a <_hHomeArmed+0x36>
	{
		Menu_LoadPage(PAGE_MENU);
    5e74:	81 e0       	ldi	r24, 0x01	; 1
    5e76:	0e 94 de 2e 	call	0x5dbc	; 0x5dbc <Menu_LoadPage>
    5e7a:	08 95       	ret

00005e7c <_hHomePage>:
}



void _hHomePage()
{
    5e7c:	cf 92       	push	r12
    5e7e:	ef 92       	push	r14
    5e80:	ff 92       	push	r15
    5e82:	0f 93       	push	r16
    5e84:	1f 93       	push	r17
	
	if (IS_INIT)
    5e86:	80 91 bc 05 	lds	r24, 0x05BC
    5e8a:	80 ff       	sbrs	r24, 0
    5e8c:	31 c0       	rjmp	.+98     	; 0x5ef0 <_hHomePage+0x74>
	{
		// Version
		LCD_SetPos(0,0);
    5e8e:	80 e0       	ldi	r24, 0x00	; 0
    5e90:	60 e0       	ldi	r22, 0x00	; 0
    5e92:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <LCD_SetPos>
		LCD_WriteString_P(strVersionInfo);
    5e96:	88 e0       	ldi	r24, 0x08	; 8
    5e98:	9d e0       	ldi	r25, 0x0D	; 13
    5e9a:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <LCD_WriteString_P>
		// Sensors
		_helper_DisplayBiStateText(5, 60, strOK, strErr, (Config.IsCalibrated & CALIBRATED_SENSOR),false);
    5e9e:	80 91 d2 06 	lds	r24, 0x06D2
    5ea2:	01 e0       	ldi	r16, 0x01	; 1
    5ea4:	82 ff       	sbrs	r24, 2
    5ea6:	00 e0       	ldi	r16, 0x00	; 0
    5ea8:	85 e0       	ldi	r24, 0x05	; 5
    5eaa:	6c e3       	ldi	r22, 0x3C	; 60
    5eac:	4d e1       	ldi	r20, 0x1D	; 29
    5eae:	5d e0       	ldi	r21, 0x0D	; 13
    5eb0:	26 ef       	ldi	r18, 0xF6	; 246
    5eb2:	3c e0       	ldi	r19, 0x0C	; 12
    5eb4:	ee 24       	eor	r14, r14
    5eb6:	0e 94 8f 2c 	call	0x591e	; 0x591e <_helper_DisplayBiStateText>
		
		//Stick Centering & Calibration
		_helper_DisplayBiStateText(5, 102, str1, strX, (Config.IsCalibrated & CALIBRATED_Stick_PRIMARY),false);
    5eba:	00 91 d2 06 	lds	r16, 0x06D2
    5ebe:	10 e0       	ldi	r17, 0x00	; 0
    5ec0:	01 70       	andi	r16, 0x01	; 1
    5ec2:	10 70       	andi	r17, 0x00	; 0
    5ec4:	85 e0       	ldi	r24, 0x05	; 5
    5ec6:	66 e6       	ldi	r22, 0x66	; 102
    5ec8:	41 e2       	ldi	r20, 0x21	; 33
    5eca:	5d e0       	ldi	r21, 0x0D	; 13
    5ecc:	23 e2       	ldi	r18, 0x23	; 35
    5ece:	3d e0       	ldi	r19, 0x0D	; 13
    5ed0:	0e 94 8f 2c 	call	0x591e	; 0x591e <_helper_DisplayBiStateText>
		
		_helper_DisplayBiStateText(5, 114, str2, strX, (Config.IsCalibrated & CALIBRATED_Stick_SECONDARY),false);
    5ed4:	80 91 d2 06 	lds	r24, 0x06D2
    5ed8:	01 e0       	ldi	r16, 0x01	; 1
    5eda:	81 ff       	sbrs	r24, 1
    5edc:	00 e0       	ldi	r16, 0x00	; 0
    5ede:	85 e0       	ldi	r24, 0x05	; 5
    5ee0:	62 e7       	ldi	r22, 0x72	; 114
    5ee2:	45 e2       	ldi	r20, 0x25	; 37
    5ee4:	5d e0       	ldi	r21, 0x0D	; 13
    5ee6:	23 e2       	ldi	r18, 0x23	; 35
    5ee8:	3d e0       	ldi	r19, 0x0D	; 13
    5eea:	ee 24       	eor	r14, r14
    5eec:	0e 94 8f 2c 	call	0x591e	; 0x591e <_helper_DisplayBiStateText>
		
		
	}
	
	if (KEY4)	// MENU
    5ef0:	80 91 bc 05 	lds	r24, 0x05BC
    5ef4:	84 ff       	sbrs	r24, 4
    5ef6:	04 c0       	rjmp	.+8      	; 0x5f00 <_hHomePage+0x84>
	{
		Menu_LoadPage(PAGE_MENU);
    5ef8:	81 e0       	ldi	r24, 0x01	; 1
    5efa:	0e 94 de 2e 	call	0x5dbc	; 0x5dbc <Menu_LoadPage>
		return;
    5efe:	94 c0       	rjmp	.+296    	; 0x6028 <_hHomePage+0x1ac>
	}
	
	// Write Voltage
	//LCD_SetPos(2, 30);
	double volt = (double)(Sensor_GetBattery()/10.0f);
    5f00:	0e 94 d4 29 	call	0x53a8	; 0x53a8 <Sensor_GetBattery>
    5f04:	9c 01       	movw	r18, r24
    5f06:	b9 01       	movw	r22, r18
    5f08:	88 27       	eor	r24, r24
    5f0a:	77 fd       	sbrc	r23, 7
    5f0c:	80 95       	com	r24
    5f0e:	98 2f       	mov	r25, r24
    5f10:	0e 94 28 39 	call	0x7250	; 0x7250 <__floatsisf>
    5f14:	20 e0       	ldi	r18, 0x00	; 0
    5f16:	30 e0       	ldi	r19, 0x00	; 0
    5f18:	40 e2       	ldi	r20, 0x20	; 32
    5f1a:	51 e4       	ldi	r21, 0x41	; 65
    5f1c:	0e 94 8d 38 	call	0x711a	; 0x711a <__divsf3>
    5f20:	9b 01       	movw	r18, r22
    5f22:	ac 01       	movw	r20, r24
	LCD_WriteValue_double_ex(2,36,volt,8,IS_SYS_ERR_VOLTAGE); // FIX: 8 to display 2 digits volt besides floating point
    5f24:	90 91 c5 06 	lds	r25, 0x06C5
    5f28:	92 70       	andi	r25, 0x02	; 2
    5f2a:	82 e0       	ldi	r24, 0x02	; 2
    5f2c:	64 e2       	ldi	r22, 0x24	; 36
    5f2e:	08 e0       	ldi	r16, 0x08	; 8
    5f30:	e9 2e       	mov	r14, r25
    5f32:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <LCD_WriteValue_double_ex>
	//LCD_WriteValue(2,36,Sensor_GetBattery(),4,IS_SYS_ERR_VOLTAGE);
	LCD_SetPos (3,6);
    5f36:	83 e0       	ldi	r24, 0x03	; 3
    5f38:	66 e0       	ldi	r22, 0x06	; 6
    5f3a:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <LCD_SetPos>
	if (nFlyingModes == FLYINGMODE_ACRO)
    5f3e:	80 91 1c 06 	lds	r24, 0x061C
    5f42:	81 30       	cpi	r24, 0x01	; 1
    5f44:	19 f4       	brne	.+6      	; 0x5f4c <_hHomePage+0xd0>
	{
		LCD_WriteString_P(PSTR("ACRO  "));
    5f46:	87 e5       	ldi	r24, 0x57	; 87
    5f48:	9d e0       	ldi	r25, 0x0D	; 13
    5f4a:	09 c0       	rjmp	.+18     	; 0x5f5e <_hHomePage+0xe2>
	}
	else if (nFlyingModes == FLYINGMODE_LEVEL)
    5f4c:	82 30       	cpi	r24, 0x02	; 2
    5f4e:	19 f4       	brne	.+6      	; 0x5f56 <_hHomePage+0xda>
	{
		LCD_WriteString_P(PSTR("STABLE"));
    5f50:	80 e5       	ldi	r24, 0x50	; 80
    5f52:	9d e0       	ldi	r25, 0x0D	; 13
    5f54:	04 c0       	rjmp	.+8      	; 0x5f5e <_hHomePage+0xe2>
	}
	else if (nFlyingModes == FLYINGMODE_ALTHOLD)
    5f56:	84 30       	cpi	r24, 0x04	; 4
    5f58:	21 f4       	brne	.+8      	; 0x5f62 <_hHomePage+0xe6>
	{
		LCD_WriteString_P(PSTR("ALTHLD"));
    5f5a:	89 e4       	ldi	r24, 0x49	; 73
    5f5c:	9d e0       	ldi	r25, 0x0D	; 13
    5f5e:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <LCD_WriteString_P>
	}
	
	_helper_Words (3,48,  0,(Config.FrameType== FRAMETYPE_QUADCOPTER),PSTR("Quad"),PSTR("TRI "),5);
    5f62:	21 e0       	ldi	r18, 0x01	; 1
    5f64:	80 91 d8 06 	lds	r24, 0x06D8
    5f68:	81 30       	cpi	r24, 0x01	; 1
    5f6a:	09 f0       	breq	.+2      	; 0x5f6e <_hHomePage+0xf2>
    5f6c:	20 e0       	ldi	r18, 0x00	; 0
    5f6e:	83 e0       	ldi	r24, 0x03	; 3
    5f70:	60 e3       	ldi	r22, 0x30	; 48
    5f72:	40 e0       	ldi	r20, 0x00	; 0
    5f74:	04 e4       	ldi	r16, 0x44	; 68
    5f76:	1d e0       	ldi	r17, 0x0D	; 13
    5f78:	bf e3       	ldi	r27, 0x3F	; 63
    5f7a:	eb 2e       	mov	r14, r27
    5f7c:	bd e0       	ldi	r27, 0x0D	; 13
    5f7e:	fb 2e       	mov	r15, r27
    5f80:	a5 e0       	ldi	r26, 0x05	; 5
    5f82:	ca 2e       	mov	r12, r26
    5f84:	0e 94 c8 2e 	call	0x5d90	; 0x5d90 <_helper_Words>
	_helper_Words (3,84,0,(Config.RX_mode == RX_mode_BuddyMode),PSTR("Buddy"),PSTR("UART "),5);
    5f88:	21 e0       	ldi	r18, 0x01	; 1
    5f8a:	80 91 d3 06 	lds	r24, 0x06D3
    5f8e:	81 11       	cpse	r24, r1
    5f90:	20 e0       	ldi	r18, 0x00	; 0
    5f92:	83 e0       	ldi	r24, 0x03	; 3
    5f94:	64 e5       	ldi	r22, 0x54	; 84
    5f96:	40 e0       	ldi	r20, 0x00	; 0
    5f98:	09 e3       	ldi	r16, 0x39	; 57
    5f9a:	1d e0       	ldi	r17, 0x0D	; 13
    5f9c:	f3 e3       	ldi	r31, 0x33	; 51
    5f9e:	ef 2e       	mov	r14, r31
    5fa0:	fd e0       	ldi	r31, 0x0D	; 13
    5fa2:	ff 2e       	mov	r15, r31
    5fa4:	e5 e0       	ldi	r30, 0x05	; 5
    5fa6:	ce 2e       	mov	r12, r30
    5fa8:	0e 94 c8 2e 	call	0x5d90	; 0x5d90 <_helper_Words>
	
	_helper_DisplayRXStatus(5);
    5fac:	85 e0       	ldi	r24, 0x05	; 5
    5fae:	0e 94 c4 2c 	call	0x5988	; 0x5988 <_helper_DisplayRXStatus>
	
		
	///////// Flying Mode
	LCD_SetPos (6,24);
    5fb2:	86 e0       	ldi	r24, 0x06	; 6
    5fb4:	68 e1       	ldi	r22, 0x18	; 24
    5fb6:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <LCD_SetPos>
	LCD_SelectFont (&font12x16);
    5fba:	80 e3       	ldi	r24, 0x30	; 48
    5fbc:	91 e0       	ldi	r25, 0x01	; 1
    5fbe:	0e 94 3b 0e 	call	0x1c76	; 0x1c76 <LCD_SelectFont>
	
	if (Config.QuadFlyingMode==QuadFlyingMode_X)
    5fc2:	80 91 da 06 	lds	r24, 0x06DA
    5fc6:	81 30       	cpi	r24, 0x01	; 1
    5fc8:	51 f4       	brne	.+20     	; 0x5fde <_hHomePage+0x162>
	{
		if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    5fca:	80 91 d8 06 	lds	r24, 0x06D8
    5fce:	81 30       	cpi	r24, 0x01	; 1
    5fd0:	19 f4       	brne	.+6      	; 0x5fd8 <_hHomePage+0x15c>
		{
			LCD_WriteString_P(PSTR ("X"));
    5fd2:	81 e3       	ldi	r24, 0x31	; 49
    5fd4:	9d e0       	ldi	r25, 0x0D	; 13
    5fd6:	0c c0       	rjmp	.+24     	; 0x5ff0 <_hHomePage+0x174>
		}
		else
		{
			LCD_WriteString_P(PSTR ("A"));
    5fd8:	8f e2       	ldi	r24, 0x2F	; 47
    5fda:	9d e0       	ldi	r25, 0x0D	; 13
    5fdc:	09 c0       	rjmp	.+18     	; 0x5ff0 <_hHomePage+0x174>
		}			
	}
	else
	{
		if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    5fde:	80 91 d8 06 	lds	r24, 0x06D8
    5fe2:	81 30       	cpi	r24, 0x01	; 1
    5fe4:	19 f4       	brne	.+6      	; 0x5fec <_hHomePage+0x170>
		{
			LCD_WriteString_P(PSTR ("+"));
    5fe6:	8d e2       	ldi	r24, 0x2D	; 45
    5fe8:	9d e0       	ldi	r25, 0x0D	; 13
    5fea:	02 c0       	rjmp	.+4      	; 0x5ff0 <_hHomePage+0x174>
		}
		else
		{
			LCD_WriteString_P(PSTR ("Y"));
    5fec:	8b e2       	ldi	r24, 0x2B	; 43
    5fee:	9d e0       	ldi	r25, 0x0D	; 13
    5ff0:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <LCD_WriteString_P>
		}			
	}
	
	LCD_SetPos (6,80);
    5ff4:	86 e0       	ldi	r24, 0x06	; 6
    5ff6:	60 e5       	ldi	r22, 0x50	; 80
    5ff8:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <LCD_SetPos>
	LCD_SelectFont (&font12x16);
    5ffc:	80 e3       	ldi	r24, 0x30	; 48
    5ffe:	91 e0       	ldi	r25, 0x01	; 1
    6000:	0e 94 3b 0e 	call	0x1c76	; 0x1c76 <LCD_SelectFont>
	if (Config.BoardOrientationMode==QuadFlyingMode_X)
    6004:	80 91 d9 06 	lds	r24, 0x06D9
    6008:	81 30       	cpi	r24, 0x01	; 1
    600a:	19 f4       	brne	.+6      	; 0x6012 <_hHomePage+0x196>
	{
		LCD_WriteString_P(PSTR ("X"));
    600c:	89 e2       	ldi	r24, 0x29	; 41
    600e:	9d e0       	ldi	r25, 0x0D	; 13
    6010:	02 c0       	rjmp	.+4      	; 0x6016 <_hHomePage+0x19a>
	}
	else
	{
		LCD_WriteString_P(PSTR ("+"));
    6012:	87 e2       	ldi	r24, 0x27	; 39
    6014:	9d e0       	ldi	r25, 0x0D	; 13
    6016:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <LCD_WriteString_P>
	}
	LCD_SelectFont (NULL);
    601a:	80 e0       	ldi	r24, 0x00	; 0
    601c:	90 e0       	ldi	r25, 0x00	; 0
    601e:	0e 94 3b 0e 	call	0x1c76	; 0x1c76 <LCD_SelectFont>
	///////
	UIEnableStickCommands=true;
    6022:	81 e0       	ldi	r24, 0x01	; 1
    6024:	80 93 e7 05 	sts	0x05E7, r24
	
}
    6028:	1f 91       	pop	r17
    602a:	0f 91       	pop	r16
    602c:	ff 90       	pop	r15
    602e:	ef 90       	pop	r14
    6030:	cf 90       	pop	r12
    6032:	08 95       	ret

00006034 <defaultHandler>:


void defaultHandler()
{
	
	if (editMode==true)
    6034:	80 91 b5 07 	lds	r24, 0x07B5
    6038:	81 30       	cpi	r24, 0x01	; 1
    603a:	19 f4       	brne	.+6      	; 0x6042 <defaultHandler+0xe>
	{		// edit mode?
		editModeHandler();
    603c:	0e 94 40 30 	call	0x6080	; 0x6080 <editModeHandler>
    6040:	08 95       	ret
	}
	else
	{
		if (IS_INIT | IS_KEYREFRESH) 
    6042:	80 91 bc 05 	lds	r24, 0x05BC
    6046:	90 e0       	ldi	r25, 0x00	; 0
    6048:	83 70       	andi	r24, 0x03	; 3
    604a:	90 70       	andi	r25, 0x00	; 0
    604c:	00 97       	sbiw	r24, 0x00	; 0
    604e:	81 f0       	breq	.+32     	; 0x6070 <defaultHandler+0x3c>
		{
			LCD_Clear();
    6050:	0e 94 1f 0c 	call	0x183e	; 0x183e <LCD_Clear>
			// 1- display screen content
			if (currentPage.screen)
    6054:	80 91 48 05 	lds	r24, 0x0548
    6058:	90 91 49 05 	lds	r25, 0x0549
    605c:	00 97       	sbiw	r24, 0x00	; 0
    605e:	11 f0       	breq	.+4      	; 0x6064 <defaultHandler+0x30>
				LCD_WriteString_P(currentPage.screen);
    6060:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <LCD_WriteString_P>
			// 2- Display control buttons... always be last to overwrite any graphics on it.
			writeSoftkeys(currentPage.softkeys);
    6064:	80 91 44 05 	lds	r24, 0x0544
    6068:	90 91 45 05 	lds	r25, 0x0545
    606c:	0e 94 c1 2a 	call	0x5582	; 0x5582 <writeSoftkeys>
			//LCD_SetPos(0, 0);
		}
		
		if (currentPage.handler)
    6070:	e0 91 46 05 	lds	r30, 0x0546
    6074:	f0 91 47 05 	lds	r31, 0x0547
    6078:	30 97       	sbiw	r30, 0x00	; 0
    607a:	09 f0       	breq	.+2      	; 0x607e <defaultHandler+0x4a>
		{
			currentPage.handler();
    607c:	09 95       	icall
    607e:	08 95       	ret

00006080 <editModeHandler>:
		subpage = (subpage + 1) % num;
}


void editModeHandler()
{
    6080:	0f 93       	push	r16
	if (KEY4)	// DONE;
    6082:	80 91 bc 05 	lds	r24, 0x05BC
    6086:	84 ff       	sbrs	r24, 4
    6088:	23 c0       	rjmp	.+70     	; 0x60d0 <editModeHandler+0x50>
	{
		editMode = false;
    608a:	10 92 b5 07 	sts	0x07B5, r1
		_mykey = KEY_REFRESH;
    608e:	82 e0       	ldi	r24, 0x02	; 2
    6090:	80 93 bc 05 	sts	0x05BC, r24
		
		if (editValueType == TYPE_UINT8)
    6094:	80 91 b4 07 	lds	r24, 0x07B4
    6098:	82 30       	cpi	r24, 0x02	; 2
    609a:	11 f0       	breq	.+4      	; 0x60a0 <editModeHandler+0x20>
			*((uint8_t*)editValuePtr) = (uint8_t) editValue;
		else if (editValueType == TYPE_INT8)
    609c:	81 30       	cpi	r24, 0x01	; 1
    609e:	41 f4       	brne	.+16     	; 0x60b0 <editModeHandler+0x30>
			*((int8_t*)editValuePtr) = (int8_t) editValue;
    60a0:	e0 91 b2 07 	lds	r30, 0x07B2
    60a4:	f0 91 b3 07 	lds	r31, 0x07B3
    60a8:	80 91 b9 07 	lds	r24, 0x07B9
    60ac:	80 83       	st	Z, r24
    60ae:	58 c0       	rjmp	.+176    	; 0x6160 <editModeHandler+0xe0>
		else if (editValueType == TYPE_INT16)
    60b0:	83 30       	cpi	r24, 0x03	; 3
    60b2:	19 f0       	breq	.+6      	; 0x60ba <editModeHandler+0x3a>
			*(int16_t*)editValuePtr = (int16_t) editValue;
		else if (editValueType == TYPE_UINT16)
    60b4:	84 30       	cpi	r24, 0x04	; 4
    60b6:	09 f0       	breq	.+2      	; 0x60ba <editModeHandler+0x3a>
    60b8:	53 c0       	rjmp	.+166    	; 0x6160 <editModeHandler+0xe0>
			*(uint16_t*)editValuePtr =(uint16_t) editValue;
    60ba:	e0 91 b2 07 	lds	r30, 0x07B2
    60be:	f0 91 b3 07 	lds	r31, 0x07B3
    60c2:	80 91 b9 07 	lds	r24, 0x07B9
    60c6:	90 91 ba 07 	lds	r25, 0x07BA
    60ca:	91 83       	std	Z+1, r25	; 0x01
    60cc:	80 83       	st	Z, r24
    60ce:	48 c0       	rjmp	.+144    	; 0x6160 <editModeHandler+0xe0>
		
		LCD_SelectFont(NULL);
		defaultHandler();
		return;
	}
	if (ANYKEY)
    60d0:	88 23       	and	r24, r24
    60d2:	09 f4       	brne	.+2      	; 0x60d6 <editModeHandler+0x56>
    60d4:	56 c0       	rjmp	.+172    	; 0x6182 <editModeHandler+0x102>
	{
		if (KEY2)	// DOWN?
    60d6:	86 ff       	sbrs	r24, 6
    60d8:	1b c0       	rjmp	.+54     	; 0x6110 <editModeHandler+0x90>
		{
			
				if (_keyrepeat == KEYBOARD_REPEAT)
    60da:	20 91 cd 05 	lds	r18, 0x05CD
    60de:	80 91 b9 07 	lds	r24, 0x07B9
    60e2:	90 91 ba 07 	lds	r25, 0x07BA
    60e6:	21 30       	cpi	r18, 0x01	; 1
    60e8:	11 f4       	brne	.+4      	; 0x60ee <editModeHandler+0x6e>
				{
					editValue-=10;
    60ea:	0a 97       	sbiw	r24, 0x0a	; 10
    60ec:	01 c0       	rjmp	.+2      	; 0x60f0 <editModeHandler+0x70>
				}
				else
				{
					editValue--;	
    60ee:	01 97       	sbiw	r24, 0x01	; 1
    60f0:	90 93 ba 07 	sts	0x07BA, r25
    60f4:	80 93 b9 07 	sts	0x07B9, r24
				}
				
				if (editValue < editLoLimit)				
    60f8:	80 91 b6 07 	lds	r24, 0x07B6
    60fc:	90 91 b7 07 	lds	r25, 0x07B7
    6100:	20 91 b9 07 	lds	r18, 0x07B9
    6104:	30 91 ba 07 	lds	r19, 0x07BA
    6108:	28 17       	cp	r18, r24
    610a:	39 07       	cpc	r19, r25
    610c:	84 f5       	brge	.+96     	; 0x616e <editModeHandler+0xee>
    610e:	1c c0       	rjmp	.+56     	; 0x6148 <editModeHandler+0xc8>
				{
					editValue = editLoLimit;
				}
		}
		else if (KEY3)	// UP?
    6110:	85 ff       	sbrs	r24, 5
    6112:	1f c0       	rjmp	.+62     	; 0x6152 <editModeHandler+0xd2>
		{
				if (_keyrepeat == KEYBOARD_REPEAT)
    6114:	20 91 cd 05 	lds	r18, 0x05CD
    6118:	80 91 b9 07 	lds	r24, 0x07B9
    611c:	90 91 ba 07 	lds	r25, 0x07BA
    6120:	21 30       	cpi	r18, 0x01	; 1
    6122:	11 f4       	brne	.+4      	; 0x6128 <editModeHandler+0xa8>
				{
					editValue+=10;
    6124:	0a 96       	adiw	r24, 0x0a	; 10
    6126:	01 c0       	rjmp	.+2      	; 0x612a <editModeHandler+0xaa>
				}
				else
				{
					editValue++;	
    6128:	01 96       	adiw	r24, 0x01	; 1
    612a:	90 93 ba 07 	sts	0x07BA, r25
    612e:	80 93 b9 07 	sts	0x07B9, r24
				}
				
				if (editValue > editHiLimit)
    6132:	80 91 b0 07 	lds	r24, 0x07B0
    6136:	90 91 b1 07 	lds	r25, 0x07B1
    613a:	20 91 b9 07 	lds	r18, 0x07B9
    613e:	30 91 ba 07 	lds	r19, 0x07BA
    6142:	82 17       	cp	r24, r18
    6144:	93 07       	cpc	r25, r19
    6146:	9c f4       	brge	.+38     	; 0x616e <editModeHandler+0xee>
				{
					editValue=editHiLimit;
    6148:	90 93 ba 07 	sts	0x07BA, r25
    614c:	80 93 b9 07 	sts	0x07B9, r24
    6150:	0e c0       	rjmp	.+28     	; 0x616e <editModeHandler+0xee>
				}					
		}
		else if (KEY1)	// CLR?
    6152:	87 ff       	sbrs	r24, 7
    6154:	0c c0       	rjmp	.+24     	; 0x616e <editModeHandler+0xee>
		{
			editMode = false;
    6156:	10 92 b5 07 	sts	0x07B5, r1
			_mykey = KEY_REFRESH;
    615a:	82 e0       	ldi	r24, 0x02	; 2
    615c:	80 93 bc 05 	sts	0x05BC, r24
	
			LCD_SelectFont(NULL);
    6160:	80 e0       	ldi	r24, 0x00	; 0
    6162:	90 e0       	ldi	r25, 0x00	; 0
    6164:	0e 94 3b 0e 	call	0x1c76	; 0x1c76 <LCD_SelectFont>
			defaultHandler();
    6168:	0e 94 1a 30 	call	0x6034	; 0x6034 <defaultHandler>
			return;	
    616c:	0a c0       	rjmp	.+20     	; 0x6182 <editModeHandler+0x102>
		}
			
		LCD_WriteValue(2, 34, editValue, 5, -1);
    616e:	40 91 b9 07 	lds	r20, 0x07B9
    6172:	50 91 ba 07 	lds	r21, 0x07BA
    6176:	82 e0       	ldi	r24, 0x02	; 2
    6178:	62 e2       	ldi	r22, 0x22	; 34
    617a:	25 e0       	ldi	r18, 0x05	; 5
    617c:	0f ef       	ldi	r16, 0xFF	; 255
    617e:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <LCD_WriteValue>
	}
}
    6182:	0f 91       	pop	r16
    6184:	08 95       	ret

00006186 <startEditMode>:

static void startEditMode(void* valuePtr, int16_t loLimit, int16_t hiLimit, uint8_t valueType)
{
    6186:	0f 93       	push	r16
    6188:	fc 01       	movw	r30, r24
	editMode = true;
    618a:	81 e0       	ldi	r24, 0x01	; 1
    618c:	80 93 b5 07 	sts	0x07B5, r24
	_mykey = KEY_INIT;
    6190:	80 93 bc 05 	sts	0x05BC, r24
	editValuePtr = valuePtr;
    6194:	f0 93 b3 07 	sts	0x07B3, r31
    6198:	e0 93 b2 07 	sts	0x07B2, r30
	editValueType = valueType;
    619c:	20 93 b4 07 	sts	0x07B4, r18
	
	if (valueType == TYPE_UINT8)
    61a0:	22 30       	cpi	r18, 0x02	; 2
    61a2:	31 f4       	brne	.+12     	; 0x61b0 <startEditMode+0x2a>
		editValue = *(uint8_t*)valuePtr;
    61a4:	80 81       	ld	r24, Z
    61a6:	80 93 b9 07 	sts	0x07B9, r24
    61aa:	10 92 ba 07 	sts	0x07BA, r1
    61ae:	11 c0       	rjmp	.+34     	; 0x61d2 <startEditMode+0x4c>
	else if (valueType == TYPE_INT8)
    61b0:	21 30       	cpi	r18, 0x01	; 1
    61b2:	29 f4       	brne	.+10     	; 0x61be <startEditMode+0x38>
		editValue = *(int8_t*)valuePtr;
    61b4:	80 81       	ld	r24, Z
    61b6:	99 27       	eor	r25, r25
    61b8:	87 fd       	sbrc	r24, 7
    61ba:	90 95       	com	r25
    61bc:	06 c0       	rjmp	.+12     	; 0x61ca <startEditMode+0x44>
	else if (valueType == TYPE_INT16)
    61be:	23 30       	cpi	r18, 0x03	; 3
    61c0:	11 f0       	breq	.+4      	; 0x61c6 <startEditMode+0x40>
 		editValue = *(int16_t*)valuePtr;
	else if (valueType == TYPE_UINT16)
    61c2:	24 30       	cpi	r18, 0x04	; 4
    61c4:	31 f4       	brne	.+12     	; 0x61d2 <startEditMode+0x4c>
 		editValue = *(uint16_t*)valuePtr;
    61c6:	80 81       	ld	r24, Z
    61c8:	91 81       	ldd	r25, Z+1	; 0x01
    61ca:	90 93 ba 07 	sts	0x07BA, r25
    61ce:	80 93 b9 07 	sts	0x07B9, r24
	
	editLoLimit = loLimit;
    61d2:	70 93 b7 07 	sts	0x07B7, r23
    61d6:	60 93 b6 07 	sts	0x07B6, r22
	editHiLimit = hiLimit;
    61da:	50 93 b1 07 	sts	0x07B1, r21
    61de:	40 93 b0 07 	sts	0x07B0, r20
	
	LCD_FillRectangle(30, 11, 98, 34, 0);
    61e2:	8e e1       	ldi	r24, 0x1E	; 30
    61e4:	6b e0       	ldi	r22, 0x0B	; 11
    61e6:	42 e6       	ldi	r20, 0x62	; 98
    61e8:	22 e2       	ldi	r18, 0x22	; 34
    61ea:	00 e0       	ldi	r16, 0x00	; 0
    61ec:	0e 94 1e 0c 	call	0x183c	; 0x183c <LCD_FillRectangle>
	LCD_Rectangle(30, 11, 98, 34, 1);
    61f0:	8e e1       	ldi	r24, 0x1E	; 30
    61f2:	6b e0       	ldi	r22, 0x0B	; 11
    61f4:	42 e6       	ldi	r20, 0x62	; 98
    61f6:	22 e2       	ldi	r18, 0x22	; 34
    61f8:	01 e0       	ldi	r16, 0x01	; 1
    61fa:	0e 94 1d 0c 	call	0x183a	; 0x183a <LCD_Rectangle>
	LCD_Rectangle(31, 12, 97, 33, 1);
    61fe:	8f e1       	ldi	r24, 0x1F	; 31
    6200:	6c e0       	ldi	r22, 0x0C	; 12
    6202:	41 e6       	ldi	r20, 0x61	; 97
    6204:	21 e2       	ldi	r18, 0x21	; 33
    6206:	0e 94 1d 0c 	call	0x183a	; 0x183a <LCD_Rectangle>
	writeSoftkeys(_skEDIT);
    620a:	89 e0       	ldi	r24, 0x09	; 9
    620c:	9c e0       	ldi	r25, 0x0C	; 12
    620e:	0e 94 c1 2a 	call	0x5582	; 0x5582 <writeSoftkeys>
	LCD_SelectFont(&font12x16);
    6212:	80 e3       	ldi	r24, 0x30	; 48
    6214:	91 e0       	ldi	r25, 0x01	; 1
    6216:	0e 94 3b 0e 	call	0x1c76	; 0x1c76 <LCD_SelectFont>
	editModeHandler();
    621a:	0e 94 40 30 	call	0x6080	; 0x6080 <editModeHandler>
}
    621e:	0f 91       	pop	r16
    6220:	08 95       	ret

00006222 <PageKey>:
}


void PageKey(uint8_t num)
{
	if (KEY2)	// PREV
    6222:	90 91 bc 05 	lds	r25, 0x05BC
    6226:	96 ff       	sbrs	r25, 6
    6228:	08 c0       	rjmp	.+16     	; 0x623a <PageKey+0x18>
		subpage = subpage == 0 ? num - 1 : subpage - 1;
    622a:	60 91 36 05 	lds	r22, 0x0536
    622e:	61 11       	cpse	r22, r1
    6230:	86 2f       	mov	r24, r22
    6232:	81 50       	subi	r24, 0x01	; 1
    6234:	80 93 36 05 	sts	0x0536, r24
    6238:	08 95       	ret
	else if (KEY3) // NEXT
    623a:	95 ff       	sbrs	r25, 5
    623c:	0c c0       	rjmp	.+24     	; 0x6256 <PageKey+0x34>
		subpage = (subpage + 1) % num;
    623e:	20 91 36 05 	lds	r18, 0x0536
    6242:	30 e0       	ldi	r19, 0x00	; 0
    6244:	2f 5f       	subi	r18, 0xFF	; 255
    6246:	3f 4f       	sbci	r19, 0xFF	; 255
    6248:	68 2f       	mov	r22, r24
    624a:	c9 01       	movw	r24, r18
    624c:	70 e0       	ldi	r23, 0x00	; 0
    624e:	0e 94 aa 3a 	call	0x7554	; 0x7554 <__divmodhi4>
    6252:	80 93 36 05 	sts	0x0536, r24
    6256:	08 95       	ret

00006258 <_hAltitudeHold>:




void _hAltitudeHold()
{
    6258:	0f 93       	push	r16
	
	NOKEYRETURN;
    625a:	80 91 bc 05 	lds	r24, 0x05BC
    625e:	88 23       	and	r24, r24
    6260:	09 f4       	brne	.+2      	; 0x6264 <_hAltitudeHold+0xc>
    6262:	a2 c0       	rjmp	.+324    	; 0x63a8 <_hAltitudeHold+0x150>
	PageKey(6);
    6264:	86 e0       	ldi	r24, 0x06	; 6
    6266:	0e 94 11 31 	call	0x6222	; 0x6222 <PageKey>
	
	
	if (KEY4)
    626a:	20 91 bc 05 	lds	r18, 0x05BC
    626e:	24 ff       	sbrs	r18, 4
    6270:	36 c0       	rjmp	.+108    	; 0x62de <_hAltitudeHold+0x86>
	{
		bValueChanged = true;
    6272:	81 e0       	ldi	r24, 0x01	; 1
    6274:	80 93 32 05 	sts	0x0532, r24
		currentPage.softkeys = _skMENUSAVE;
    6278:	82 ee       	ldi	r24, 0xE2	; 226
    627a:	9b e0       	ldi	r25, 0x0B	; 11
    627c:	90 93 45 05 	sts	0x0545, r25
    6280:	80 93 44 05 	sts	0x0544, r24
		switch (subpage)
    6284:	80 91 36 05 	lds	r24, 0x0536
    6288:	82 30       	cpi	r24, 0x02	; 2
    628a:	a1 f0       	breq	.+40     	; 0x62b4 <_hAltitudeHold+0x5c>
    628c:	83 30       	cpi	r24, 0x03	; 3
    628e:	28 f4       	brcc	.+10     	; 0x629a <_hAltitudeHold+0x42>
    6290:	88 23       	and	r24, r24
    6292:	51 f0       	breq	.+20     	; 0x62a8 <_hAltitudeHold+0x50>
    6294:	81 30       	cpi	r24, 0x01	; 1
    6296:	19 f5       	brne	.+70     	; 0x62de <_hAltitudeHold+0x86>
    6298:	0a c0       	rjmp	.+20     	; 0x62ae <_hAltitudeHold+0x56>
    629a:	84 30       	cpi	r24, 0x04	; 4
    629c:	89 f0       	breq	.+34     	; 0x62c0 <_hAltitudeHold+0x68>
    629e:	84 30       	cpi	r24, 0x04	; 4
    62a0:	60 f0       	brcs	.+24     	; 0x62ba <_hAltitudeHold+0x62>
    62a2:	85 30       	cpi	r24, 0x05	; 5
    62a4:	e1 f4       	brne	.+56     	; 0x62de <_hAltitudeHold+0x86>
    62a6:	11 c0       	rjmp	.+34     	; 0x62ca <_hAltitudeHold+0x72>
		{
			case 0: startEditMode(&(Config.SonarParams[0]._P),-500,500,TYPE_INT16); return ;
    62a8:	87 e1       	ldi	r24, 0x17	; 23
    62aa:	97 e0       	ldi	r25, 0x07	; 7
    62ac:	0b c0       	rjmp	.+22     	; 0x62c4 <_hAltitudeHold+0x6c>
			case 1: startEditMode(&(Config.SonarParams[0]._PLimit),0,500,TYPE_INT16); return ;
    62ae:	89 e1       	ldi	r24, 0x19	; 25
    62b0:	97 e0       	ldi	r25, 0x07	; 7
    62b2:	0d c0       	rjmp	.+26     	; 0x62ce <_hAltitudeHold+0x76>
			case 2: startEditMode(&(Config.SonarParams[0]._I),-500,500,TYPE_INT16);  return ;
    62b4:	8b e1       	ldi	r24, 0x1B	; 27
    62b6:	97 e0       	ldi	r25, 0x07	; 7
    62b8:	05 c0       	rjmp	.+10     	; 0x62c4 <_hAltitudeHold+0x6c>
			case 3: startEditMode(&(Config.SonarParams[0]._ILimit),0,500,TYPE_INT16); return ;
    62ba:	8d e1       	ldi	r24, 0x1D	; 29
    62bc:	97 e0       	ldi	r25, 0x07	; 7
    62be:	07 c0       	rjmp	.+14     	; 0x62ce <_hAltitudeHold+0x76>
			case 4: startEditMode(&(Config.SonarParams[0]._D),-500,500,TYPE_INT16);  return ; // negative D
    62c0:	8f e1       	ldi	r24, 0x1F	; 31
    62c2:	97 e0       	ldi	r25, 0x07	; 7
    62c4:	6c e0       	ldi	r22, 0x0C	; 12
    62c6:	7e ef       	ldi	r23, 0xFE	; 254
    62c8:	04 c0       	rjmp	.+8      	; 0x62d2 <_hAltitudeHold+0x7a>
			case 5: startEditMode(&(Config.SonarParams[0]._DLimit),0,500,TYPE_INT16); return ;
    62ca:	81 e2       	ldi	r24, 0x21	; 33
    62cc:	97 e0       	ldi	r25, 0x07	; 7
    62ce:	60 e0       	ldi	r22, 0x00	; 0
    62d0:	70 e0       	ldi	r23, 0x00	; 0
    62d2:	44 ef       	ldi	r20, 0xF4	; 244
    62d4:	51 e0       	ldi	r21, 0x01	; 1
    62d6:	23 e0       	ldi	r18, 0x03	; 3
    62d8:	0e 94 c3 30 	call	0x6186	; 0x6186 <startEditMode>
    62dc:	65 c0       	rjmp	.+202    	; 0x63a8 <_hAltitudeHold+0x150>
		}
	}
	
	if (KEY1)
    62de:	27 ff       	sbrs	r18, 7
    62e0:	02 c0       	rjmp	.+4      	; 0x62e6 <_hAltitudeHold+0x8e>
	{
		_helper_SaveinEEPROM_ifChanged();
    62e2:	0e 94 bb 2c 	call	0x5976	; 0x5976 <_helper_SaveinEEPROM_ifChanged>
	}
	
	LCD_WriteValue(1,30,Config.SonarParams[0]._P,3,0==subpage);
    62e6:	40 91 17 07 	lds	r20, 0x0717
    62ea:	50 91 18 07 	lds	r21, 0x0718
    62ee:	01 e0       	ldi	r16, 0x01	; 1
    62f0:	80 91 36 05 	lds	r24, 0x0536
    62f4:	81 11       	cpse	r24, r1
    62f6:	00 e0       	ldi	r16, 0x00	; 0
    62f8:	81 e0       	ldi	r24, 0x01	; 1
    62fa:	6e e1       	ldi	r22, 0x1E	; 30
    62fc:	23 e0       	ldi	r18, 0x03	; 3
    62fe:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <LCD_WriteValue>
	LCD_WriteValue(1,84,Config.SonarParams[0]._PLimit,3,1==subpage);
    6302:	40 91 19 07 	lds	r20, 0x0719
    6306:	50 91 1a 07 	lds	r21, 0x071A
    630a:	01 e0       	ldi	r16, 0x01	; 1
    630c:	80 91 36 05 	lds	r24, 0x0536
    6310:	81 30       	cpi	r24, 0x01	; 1
    6312:	09 f0       	breq	.+2      	; 0x6316 <_hAltitudeHold+0xbe>
    6314:	00 e0       	ldi	r16, 0x00	; 0
    6316:	81 e0       	ldi	r24, 0x01	; 1
    6318:	64 e5       	ldi	r22, 0x54	; 84
    631a:	23 e0       	ldi	r18, 0x03	; 3
    631c:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <LCD_WriteValue>
	LCD_WriteValue(2,30,Config.SonarParams[0]._I,3,2==subpage);
    6320:	40 91 1b 07 	lds	r20, 0x071B
    6324:	50 91 1c 07 	lds	r21, 0x071C
    6328:	01 e0       	ldi	r16, 0x01	; 1
    632a:	80 91 36 05 	lds	r24, 0x0536
    632e:	82 30       	cpi	r24, 0x02	; 2
    6330:	09 f0       	breq	.+2      	; 0x6334 <_hAltitudeHold+0xdc>
    6332:	00 e0       	ldi	r16, 0x00	; 0
    6334:	82 e0       	ldi	r24, 0x02	; 2
    6336:	6e e1       	ldi	r22, 0x1E	; 30
    6338:	23 e0       	ldi	r18, 0x03	; 3
    633a:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <LCD_WriteValue>
	LCD_WriteValue(2,84,Config.SonarParams[0]._ILimit,3,3==subpage);
    633e:	40 91 1d 07 	lds	r20, 0x071D
    6342:	50 91 1e 07 	lds	r21, 0x071E
    6346:	01 e0       	ldi	r16, 0x01	; 1
    6348:	80 91 36 05 	lds	r24, 0x0536
    634c:	83 30       	cpi	r24, 0x03	; 3
    634e:	09 f0       	breq	.+2      	; 0x6352 <_hAltitudeHold+0xfa>
    6350:	00 e0       	ldi	r16, 0x00	; 0
    6352:	82 e0       	ldi	r24, 0x02	; 2
    6354:	64 e5       	ldi	r22, 0x54	; 84
    6356:	23 e0       	ldi	r18, 0x03	; 3
    6358:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <LCD_WriteValue>
	LCD_WriteValue(3,30,Config.SonarParams[0]._D,3,4==subpage);
    635c:	40 91 1f 07 	lds	r20, 0x071F
    6360:	50 91 20 07 	lds	r21, 0x0720
    6364:	01 e0       	ldi	r16, 0x01	; 1
    6366:	80 91 36 05 	lds	r24, 0x0536
    636a:	84 30       	cpi	r24, 0x04	; 4
    636c:	09 f0       	breq	.+2      	; 0x6370 <_hAltitudeHold+0x118>
    636e:	00 e0       	ldi	r16, 0x00	; 0
    6370:	83 e0       	ldi	r24, 0x03	; 3
    6372:	6e e1       	ldi	r22, 0x1E	; 30
    6374:	23 e0       	ldi	r18, 0x03	; 3
    6376:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <LCD_WriteValue>
	LCD_WriteValue(3,84,Config.SonarParams[0]._DLimit,3,5==subpage);
    637a:	40 91 21 07 	lds	r20, 0x0721
    637e:	50 91 22 07 	lds	r21, 0x0722
    6382:	01 e0       	ldi	r16, 0x01	; 1
    6384:	80 91 36 05 	lds	r24, 0x0536
    6388:	85 30       	cpi	r24, 0x05	; 5
    638a:	09 f0       	breq	.+2      	; 0x638e <_hAltitudeHold+0x136>
    638c:	00 e0       	ldi	r16, 0x00	; 0
    638e:	83 e0       	ldi	r24, 0x03	; 3
    6390:	64 e5       	ldi	r22, 0x54	; 84
    6392:	23 e0       	ldi	r18, 0x03	; 3
    6394:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <LCD_WriteValue>
	LCD_WriteString_Pex(5,0,PSTR("                "),16,false);    
    6398:	85 e0       	ldi	r24, 0x05	; 5
    639a:	60 e0       	ldi	r22, 0x00	; 0
    639c:	48 ef       	ldi	r20, 0xF8	; 248
    639e:	5b e0       	ldi	r21, 0x0B	; 11
    63a0:	20 e1       	ldi	r18, 0x10	; 16
    63a2:	00 e0       	ldi	r16, 0x00	; 0
    63a4:	0e 94 6c 0d 	call	0x1ad8	; 0x1ad8 <LCD_WriteString_Pex>
				
}
    63a8:	0f 91       	pop	r16
    63aa:	08 95       	ret

000063ac <_hSelfLeveling>:
}



void _hSelfLeveling()
{
    63ac:	0f 93       	push	r16
	
	
	NOKEYRETURN;
    63ae:	80 91 bc 05 	lds	r24, 0x05BC
    63b2:	88 23       	and	r24, r24
    63b4:	09 f4       	brne	.+2      	; 0x63b8 <_hSelfLeveling+0xc>
    63b6:	f5 c1       	rjmp	.+1002   	; 0x67a2 <_hSelfLeveling+0x3f6>
	PageKey(10);
    63b8:	8a e0       	ldi	r24, 0x0A	; 10
    63ba:	0e 94 11 31 	call	0x6222	; 0x6222 <PageKey>
	
	if ((subindex!=0) && (subpage>7)) subpage=0;
    63be:	80 91 37 05 	lds	r24, 0x0537
    63c2:	88 23       	and	r24, r24
    63c4:	31 f0       	breq	.+12     	; 0x63d2 <_hSelfLeveling+0x26>
    63c6:	80 91 36 05 	lds	r24, 0x0536
    63ca:	88 30       	cpi	r24, 0x08	; 8
    63cc:	10 f0       	brcs	.+4      	; 0x63d2 <_hSelfLeveling+0x26>
    63ce:	10 92 36 05 	sts	0x0536, r1
		
	
	
	if (KEY4)
    63d2:	80 91 bc 05 	lds	r24, 0x05BC
    63d6:	84 ff       	sbrs	r24, 4
    63d8:	d7 c0       	rjmp	.+430    	; 0x6588 <_hSelfLeveling+0x1dc>
	{
		if (subpage!=0) bValueChanged = true;
    63da:	20 91 36 05 	lds	r18, 0x0536
    63de:	22 23       	and	r18, r18
    63e0:	19 f0       	breq	.+6      	; 0x63e8 <_hSelfLeveling+0x3c>
    63e2:	81 e0       	ldi	r24, 0x01	; 1
    63e4:	80 93 32 05 	sts	0x0532, r24
		currentPage.softkeys = _skMENUSAVE;
    63e8:	82 ee       	ldi	r24, 0xE2	; 226
    63ea:	9b e0       	ldi	r25, 0x0B	; 11
    63ec:	90 93 45 05 	sts	0x0545, r25
    63f0:	80 93 44 05 	sts	0x0544, r24
		switch (subpage)
    63f4:	24 30       	cpi	r18, 0x04	; 4
    63f6:	09 f4       	brne	.+2      	; 0x63fa <_hSelfLeveling+0x4e>
    63f8:	6f c0       	rjmp	.+222    	; 0x64d8 <_hSelfLeveling+0x12c>
    63fa:	25 30       	cpi	r18, 0x05	; 5
    63fc:	58 f4       	brcc	.+22     	; 0x6414 <_hSelfLeveling+0x68>
    63fe:	21 30       	cpi	r18, 0x01	; 1
    6400:	a1 f1       	breq	.+104    	; 0x646a <_hSelfLeveling+0xbe>
    6402:	21 30       	cpi	r18, 0x01	; 1
    6404:	d0 f0       	brcs	.+52     	; 0x643a <_hSelfLeveling+0x8e>
    6406:	22 30       	cpi	r18, 0x02	; 2
    6408:	09 f4       	brne	.+2      	; 0x640c <_hSelfLeveling+0x60>
    640a:	40 c0       	rjmp	.+128    	; 0x648c <_hSelfLeveling+0xe0>
    640c:	23 30       	cpi	r18, 0x03	; 3
    640e:	09 f0       	breq	.+2      	; 0x6412 <_hSelfLeveling+0x66>
    6410:	bb c0       	rjmp	.+374    	; 0x6588 <_hSelfLeveling+0x1dc>
    6412:	51 c0       	rjmp	.+162    	; 0x64b6 <_hSelfLeveling+0x10a>
    6414:	27 30       	cpi	r18, 0x07	; 7
    6416:	09 f4       	brne	.+2      	; 0x641a <_hSelfLeveling+0x6e>
    6418:	94 c0       	rjmp	.+296    	; 0x6542 <_hSelfLeveling+0x196>
    641a:	28 30       	cpi	r18, 0x08	; 8
    641c:	38 f4       	brcc	.+14     	; 0x642c <_hSelfLeveling+0x80>
    641e:	25 30       	cpi	r18, 0x05	; 5
    6420:	09 f4       	brne	.+2      	; 0x6424 <_hSelfLeveling+0x78>
    6422:	6b c0       	rjmp	.+214    	; 0x64fa <_hSelfLeveling+0x14e>
    6424:	26 30       	cpi	r18, 0x06	; 6
    6426:	09 f0       	breq	.+2      	; 0x642a <_hSelfLeveling+0x7e>
    6428:	af c0       	rjmp	.+350    	; 0x6588 <_hSelfLeveling+0x1dc>
    642a:	7a c0       	rjmp	.+244    	; 0x6520 <_hSelfLeveling+0x174>
    642c:	28 30       	cpi	r18, 0x08	; 8
    642e:	09 f4       	brne	.+2      	; 0x6432 <_hSelfLeveling+0x86>
    6430:	9e c0       	rjmp	.+316    	; 0x656e <_hSelfLeveling+0x1c2>
    6432:	29 30       	cpi	r18, 0x09	; 9
    6434:	09 f0       	breq	.+2      	; 0x6438 <_hSelfLeveling+0x8c>
    6436:	a8 c0       	rjmp	.+336    	; 0x6588 <_hSelfLeveling+0x1dc>
    6438:	9d c0       	rjmp	.+314    	; 0x6574 <_hSelfLeveling+0x1c8>
		{
			case 0: if (subindex==0) 
    643a:	80 91 37 05 	lds	r24, 0x0537
    643e:	88 23       	and	r24, r24
    6440:	49 f4       	brne	.+18     	; 0x6454 <_hSelfLeveling+0xa8>
					{
						subindex=1; 
    6442:	81 e0       	ldi	r24, 0x01	; 1
    6444:	80 93 37 05 	sts	0x0537, r24
						LCD_WriteString_Pex(5,0,PSTR("                "),16,false);    
    6448:	85 e0       	ldi	r24, 0x05	; 5
    644a:	60 e0       	ldi	r22, 0x00	; 0
    644c:	49 e4       	ldi	r20, 0x49	; 73
    644e:	5c e0       	ldi	r21, 0x0C	; 12
    6450:	20 e1       	ldi	r18, 0x10	; 16
    6452:	07 c0       	rjmp	.+14     	; 0x6462 <_hSelfLeveling+0xb6>
					}
					else
					{
						subindex=0; 
    6454:	10 92 37 05 	sts	0x0537, r1
						LCD_WriteString_Pex(5,0,PSTR("Trim P:    R:"),13,false);
    6458:	85 e0       	ldi	r24, 0x05	; 5
    645a:	60 e0       	ldi	r22, 0x00	; 0
    645c:	4b e3       	ldi	r20, 0x3B	; 59
    645e:	5c e0       	ldi	r21, 0x0C	; 12
    6460:	2d e0       	ldi	r18, 0x0D	; 13
    6462:	00 e0       	ldi	r16, 0x00	; 0
    6464:	0e 94 6c 0d 	call	0x1ad8	; 0x1ad8 <LCD_WriteString_Pex>
    6468:	8f c0       	rjmp	.+286    	; 0x6588 <_hSelfLeveling+0x1dc>
					}				
					break;		
			case 1: startEditMode(&(Config.AccParams[subindex]._P),-500,500,TYPE_INT16); return ;
    646a:	80 91 37 05 	lds	r24, 0x0537
    646e:	90 e0       	ldi	r25, 0x00	; 0
    6470:	9c 01       	movw	r18, r24
    6472:	22 0f       	add	r18, r18
    6474:	33 1f       	adc	r19, r19
    6476:	c9 01       	movw	r24, r18
    6478:	e3 e0       	ldi	r30, 0x03	; 3
    647a:	88 0f       	add	r24, r24
    647c:	99 1f       	adc	r25, r25
    647e:	ea 95       	dec	r30
    6480:	e1 f7       	brne	.-8      	; 0x647a <_hSelfLeveling+0xce>
    6482:	82 1b       	sub	r24, r18
    6484:	93 0b       	sbc	r25, r19
    6486:	85 50       	subi	r24, 0x05	; 5
    6488:	99 4f       	sbci	r25, 0xF9	; 249
    648a:	47 c0       	rjmp	.+142    	; 0x651a <_hSelfLeveling+0x16e>
			case 2: startEditMode(&(Config.AccParams[subindex]._PLimit),0,500,TYPE_INT16); return ;
    648c:	80 91 37 05 	lds	r24, 0x0537
    6490:	90 e0       	ldi	r25, 0x00	; 0
    6492:	9c 01       	movw	r18, r24
    6494:	22 0f       	add	r18, r18
    6496:	33 1f       	adc	r19, r19
    6498:	c9 01       	movw	r24, r18
    649a:	63 e0       	ldi	r22, 0x03	; 3
    649c:	88 0f       	add	r24, r24
    649e:	99 1f       	adc	r25, r25
    64a0:	6a 95       	dec	r22
    64a2:	e1 f7       	brne	.-8      	; 0x649c <_hSelfLeveling+0xf0>
    64a4:	82 1b       	sub	r24, r18
    64a6:	93 0b       	sbc	r25, r19
    64a8:	83 50       	subi	r24, 0x03	; 3
    64aa:	99 4f       	sbci	r25, 0xF9	; 249
    64ac:	60 e0       	ldi	r22, 0x00	; 0
    64ae:	70 e0       	ldi	r23, 0x00	; 0
    64b0:	44 ef       	ldi	r20, 0xF4	; 244
    64b2:	51 e0       	ldi	r21, 0x01	; 1
    64b4:	5a c0       	rjmp	.+180    	; 0x656a <_hSelfLeveling+0x1be>
			case 3: startEditMode(&(Config.AccParams[subindex]._I),-500,500,TYPE_INT16);  return ;
    64b6:	80 91 37 05 	lds	r24, 0x0537
    64ba:	90 e0       	ldi	r25, 0x00	; 0
    64bc:	9c 01       	movw	r18, r24
    64be:	22 0f       	add	r18, r18
    64c0:	33 1f       	adc	r19, r19
    64c2:	c9 01       	movw	r24, r18
    64c4:	43 e0       	ldi	r20, 0x03	; 3
    64c6:	88 0f       	add	r24, r24
    64c8:	99 1f       	adc	r25, r25
    64ca:	4a 95       	dec	r20
    64cc:	e1 f7       	brne	.-8      	; 0x64c6 <_hSelfLeveling+0x11a>
    64ce:	82 1b       	sub	r24, r18
    64d0:	93 0b       	sbc	r25, r19
    64d2:	81 50       	subi	r24, 0x01	; 1
    64d4:	99 4f       	sbci	r25, 0xF9	; 249
    64d6:	21 c0       	rjmp	.+66     	; 0x651a <_hSelfLeveling+0x16e>
			case 4: startEditMode(&(Config.AccParams[subindex]._ILimit),0,500,TYPE_INT16); return ;
    64d8:	80 91 37 05 	lds	r24, 0x0537
    64dc:	90 e0       	ldi	r25, 0x00	; 0
    64de:	9c 01       	movw	r18, r24
    64e0:	22 0f       	add	r18, r18
    64e2:	33 1f       	adc	r19, r19
    64e4:	c9 01       	movw	r24, r18
    64e6:	b3 e0       	ldi	r27, 0x03	; 3
    64e8:	88 0f       	add	r24, r24
    64ea:	99 1f       	adc	r25, r25
    64ec:	ba 95       	dec	r27
    64ee:	e1 f7       	brne	.-8      	; 0x64e8 <_hSelfLeveling+0x13c>
    64f0:	82 1b       	sub	r24, r18
    64f2:	93 0b       	sbc	r25, r19
    64f4:	8f 5f       	subi	r24, 0xFF	; 255
    64f6:	98 4f       	sbci	r25, 0xF8	; 248
    64f8:	d9 cf       	rjmp	.-78     	; 0x64ac <_hSelfLeveling+0x100>
			case 5: startEditMode(&(Config.AccParams[subindex]._D),-500,500,TYPE_INT16);  return ; // negative D
    64fa:	80 91 37 05 	lds	r24, 0x0537
    64fe:	90 e0       	ldi	r25, 0x00	; 0
    6500:	9c 01       	movw	r18, r24
    6502:	22 0f       	add	r18, r18
    6504:	33 1f       	adc	r19, r19
    6506:	c9 01       	movw	r24, r18
    6508:	f3 e0       	ldi	r31, 0x03	; 3
    650a:	88 0f       	add	r24, r24
    650c:	99 1f       	adc	r25, r25
    650e:	fa 95       	dec	r31
    6510:	e1 f7       	brne	.-8      	; 0x650a <_hSelfLeveling+0x15e>
    6512:	82 1b       	sub	r24, r18
    6514:	93 0b       	sbc	r25, r19
    6516:	8d 5f       	subi	r24, 0xFD	; 253
    6518:	98 4f       	sbci	r25, 0xF8	; 248
    651a:	6c e0       	ldi	r22, 0x0C	; 12
    651c:	7e ef       	ldi	r23, 0xFE	; 254
    651e:	c8 cf       	rjmp	.-112    	; 0x64b0 <_hSelfLeveling+0x104>
			case 6: startEditMode(&(Config.AccParams[subindex]._DLimit),0,500,TYPE_INT16); return ;
    6520:	80 91 37 05 	lds	r24, 0x0537
    6524:	90 e0       	ldi	r25, 0x00	; 0
    6526:	9c 01       	movw	r18, r24
    6528:	22 0f       	add	r18, r18
    652a:	33 1f       	adc	r19, r19
    652c:	c9 01       	movw	r24, r18
    652e:	73 e0       	ldi	r23, 0x03	; 3
    6530:	88 0f       	add	r24, r24
    6532:	99 1f       	adc	r25, r25
    6534:	7a 95       	dec	r23
    6536:	e1 f7       	brne	.-8      	; 0x6530 <_hSelfLeveling+0x184>
    6538:	82 1b       	sub	r24, r18
    653a:	93 0b       	sbc	r25, r19
    653c:	8b 5f       	subi	r24, 0xFB	; 251
    653e:	98 4f       	sbci	r25, 0xF8	; 248
    6540:	b5 cf       	rjmp	.-150    	; 0x64ac <_hSelfLeveling+0x100>
			case 7: startEditMode(&(Config.AccParams[subindex].ComplementaryFilterAlpha),0,999,TYPE_INT16); return ;
    6542:	80 91 37 05 	lds	r24, 0x0537
    6546:	90 e0       	ldi	r25, 0x00	; 0
    6548:	9c 01       	movw	r18, r24
    654a:	22 0f       	add	r18, r18
    654c:	33 1f       	adc	r19, r19
    654e:	c9 01       	movw	r24, r18
    6550:	53 e0       	ldi	r21, 0x03	; 3
    6552:	88 0f       	add	r24, r24
    6554:	99 1f       	adc	r25, r25
    6556:	5a 95       	dec	r21
    6558:	e1 f7       	brne	.-8      	; 0x6552 <_hSelfLeveling+0x1a6>
    655a:	82 1b       	sub	r24, r18
    655c:	93 0b       	sbc	r25, r19
    655e:	89 5f       	subi	r24, 0xF9	; 249
    6560:	98 4f       	sbci	r25, 0xF8	; 248
    6562:	60 e0       	ldi	r22, 0x00	; 0
    6564:	70 e0       	ldi	r23, 0x00	; 0
    6566:	47 ee       	ldi	r20, 0xE7	; 231
    6568:	53 e0       	ldi	r21, 0x03	; 3
    656a:	23 e0       	ldi	r18, 0x03	; 3
    656c:	0a c0       	rjmp	.+20     	; 0x6582 <_hSelfLeveling+0x1d6>
			case 8: startEditMode(&(Config.Acc_Pitch_Trim),-25,25,TYPE_INT8);  return ; 
    656e:	86 e2       	ldi	r24, 0x26	; 38
    6570:	97 e0       	ldi	r25, 0x07	; 7
    6572:	02 c0       	rjmp	.+4      	; 0x6578 <_hSelfLeveling+0x1cc>
			case 9: startEditMode(&(Config.Acc_Roll_Trim),-25,25,TYPE_INT8); return ;
    6574:	87 e2       	ldi	r24, 0x27	; 39
    6576:	97 e0       	ldi	r25, 0x07	; 7
    6578:	67 ee       	ldi	r22, 0xE7	; 231
    657a:	7f ef       	ldi	r23, 0xFF	; 255
    657c:	49 e1       	ldi	r20, 0x19	; 25
    657e:	50 e0       	ldi	r21, 0x00	; 0
    6580:	21 e0       	ldi	r18, 0x01	; 1
    6582:	0e 94 c3 30 	call	0x6186	; 0x6186 <startEditMode>
    6586:	0d c1       	rjmp	.+538    	; 0x67a2 <_hSelfLeveling+0x3f6>
		
		}
	}
	
	if (KEY1)
    6588:	80 91 bc 05 	lds	r24, 0x05BC
    658c:	87 ff       	sbrs	r24, 7
    658e:	02 c0       	rjmp	.+4      	; 0x6594 <_hSelfLeveling+0x1e8>
	{
		_helper_SaveinEEPROM_ifChanged();
    6590:	0e 94 bb 2c 	call	0x5976	; 0x5976 <_helper_SaveinEEPROM_ifChanged>
	}
	
	lcdReverse(subpage == 0);
    6594:	81 e0       	ldi	r24, 0x01	; 1
    6596:	90 91 36 05 	lds	r25, 0x0536
    659a:	91 11       	cpse	r25, r1
    659c:	80 e0       	ldi	r24, 0x00	; 0
    659e:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <lcdReverse>
	if (subindex==0)
    65a2:	80 91 37 05 	lds	r24, 0x0537
    65a6:	88 23       	and	r24, r24
    65a8:	39 f5       	brne	.+78     	; 0x65f8 <_hSelfLeveling+0x24c>
	{
		strcpy_P(sXDeg,PSTR("ACC X & Y    "));
    65aa:	8c ee       	ldi	r24, 0xEC	; 236
    65ac:	95 e0       	ldi	r25, 0x05	; 5
    65ae:	6d e2       	ldi	r22, 0x2D	; 45
    65b0:	7c e0       	ldi	r23, 0x0C	; 12
    65b2:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <strcpy_P>
		LCD_WriteValue(5,42,Config.Acc_Pitch_Trim,3,8==subpage);
    65b6:	40 91 26 07 	lds	r20, 0x0726
    65ba:	55 27       	eor	r21, r21
    65bc:	47 fd       	sbrc	r20, 7
    65be:	50 95       	com	r21
    65c0:	01 e0       	ldi	r16, 0x01	; 1
    65c2:	80 91 36 05 	lds	r24, 0x0536
    65c6:	88 30       	cpi	r24, 0x08	; 8
    65c8:	09 f0       	breq	.+2      	; 0x65cc <_hSelfLeveling+0x220>
    65ca:	00 e0       	ldi	r16, 0x00	; 0
    65cc:	85 e0       	ldi	r24, 0x05	; 5
    65ce:	6a e2       	ldi	r22, 0x2A	; 42
    65d0:	23 e0       	ldi	r18, 0x03	; 3
    65d2:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <LCD_WriteValue>
		LCD_WriteValue(5,78,Config.Acc_Roll_Trim,3,9==subpage);
    65d6:	40 91 27 07 	lds	r20, 0x0727
    65da:	55 27       	eor	r21, r21
    65dc:	47 fd       	sbrc	r20, 7
    65de:	50 95       	com	r21
    65e0:	01 e0       	ldi	r16, 0x01	; 1
    65e2:	80 91 36 05 	lds	r24, 0x0536
    65e6:	89 30       	cpi	r24, 0x09	; 9
    65e8:	09 f0       	breq	.+2      	; 0x65ec <_hSelfLeveling+0x240>
    65ea:	00 e0       	ldi	r16, 0x00	; 0
    65ec:	85 e0       	ldi	r24, 0x05	; 5
    65ee:	6e e4       	ldi	r22, 0x4E	; 78
    65f0:	23 e0       	ldi	r18, 0x03	; 3
    65f2:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <LCD_WriteValue>
    65f6:	06 c0       	rjmp	.+12     	; 0x6604 <_hSelfLeveling+0x258>
	}
	else
	{
		strcpy_P(sXDeg,PSTR("ACC-Z damping"));
    65f8:	8c ee       	ldi	r24, 0xEC	; 236
    65fa:	95 e0       	ldi	r25, 0x05	; 5
    65fc:	6f e1       	ldi	r22, 0x1F	; 31
    65fe:	7c e0       	ldi	r23, 0x0C	; 12
    6600:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <strcpy_P>
	}
	
	LCD_WriteStringex (0,0,sXDeg,0==subpage);
    6604:	21 e0       	ldi	r18, 0x01	; 1
    6606:	80 91 36 05 	lds	r24, 0x0536
    660a:	81 11       	cpse	r24, r1
    660c:	20 e0       	ldi	r18, 0x00	; 0
    660e:	80 e0       	ldi	r24, 0x00	; 0
    6610:	60 e0       	ldi	r22, 0x00	; 0
    6612:	4c ee       	ldi	r20, 0xEC	; 236
    6614:	55 e0       	ldi	r21, 0x05	; 5
    6616:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <LCD_WriteStringex>
	LCD_WriteValue(1,30,Config.AccParams[subindex]._P,3,1==subpage);
    661a:	80 91 37 05 	lds	r24, 0x0537
    661e:	90 e0       	ldi	r25, 0x00	; 0
    6620:	88 0f       	add	r24, r24
    6622:	99 1f       	adc	r25, r25
    6624:	fc 01       	movw	r30, r24
    6626:	33 e0       	ldi	r19, 0x03	; 3
    6628:	ee 0f       	add	r30, r30
    662a:	ff 1f       	adc	r31, r31
    662c:	3a 95       	dec	r19
    662e:	e1 f7       	brne	.-8      	; 0x6628 <_hSelfLeveling+0x27c>
    6630:	e8 1b       	sub	r30, r24
    6632:	f9 0b       	sbc	r31, r25
    6634:	ef 52       	subi	r30, 0x2F	; 47
    6636:	f9 4f       	sbci	r31, 0xF9	; 249
    6638:	42 a5       	ldd	r20, Z+42	; 0x2a
    663a:	53 a5       	ldd	r21, Z+43	; 0x2b
    663c:	01 e0       	ldi	r16, 0x01	; 1
    663e:	80 91 36 05 	lds	r24, 0x0536
    6642:	81 30       	cpi	r24, 0x01	; 1
    6644:	09 f0       	breq	.+2      	; 0x6648 <_hSelfLeveling+0x29c>
    6646:	00 e0       	ldi	r16, 0x00	; 0
    6648:	81 e0       	ldi	r24, 0x01	; 1
    664a:	6e e1       	ldi	r22, 0x1E	; 30
    664c:	23 e0       	ldi	r18, 0x03	; 3
    664e:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <LCD_WriteValue>
	LCD_WriteValue(1,84,Config.AccParams[subindex]._PLimit,3,2==subpage);
    6652:	80 91 37 05 	lds	r24, 0x0537
    6656:	90 e0       	ldi	r25, 0x00	; 0
    6658:	88 0f       	add	r24, r24
    665a:	99 1f       	adc	r25, r25
    665c:	fc 01       	movw	r30, r24
    665e:	03 e0       	ldi	r16, 0x03	; 3
    6660:	ee 0f       	add	r30, r30
    6662:	ff 1f       	adc	r31, r31
    6664:	0a 95       	dec	r16
    6666:	e1 f7       	brne	.-8      	; 0x6660 <_hSelfLeveling+0x2b4>
    6668:	e8 1b       	sub	r30, r24
    666a:	f9 0b       	sbc	r31, r25
    666c:	ef 52       	subi	r30, 0x2F	; 47
    666e:	f9 4f       	sbci	r31, 0xF9	; 249
    6670:	44 a5       	ldd	r20, Z+44	; 0x2c
    6672:	55 a5       	ldd	r21, Z+45	; 0x2d
    6674:	01 e0       	ldi	r16, 0x01	; 1
    6676:	80 91 36 05 	lds	r24, 0x0536
    667a:	82 30       	cpi	r24, 0x02	; 2
    667c:	09 f0       	breq	.+2      	; 0x6680 <_hSelfLeveling+0x2d4>
    667e:	00 e0       	ldi	r16, 0x00	; 0
    6680:	81 e0       	ldi	r24, 0x01	; 1
    6682:	64 e5       	ldi	r22, 0x54	; 84
    6684:	23 e0       	ldi	r18, 0x03	; 3
    6686:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <LCD_WriteValue>
	LCD_WriteValue(2,30,Config.AccParams[subindex]._I,3,3==subpage);
    668a:	80 91 37 05 	lds	r24, 0x0537
    668e:	90 e0       	ldi	r25, 0x00	; 0
    6690:	88 0f       	add	r24, r24
    6692:	99 1f       	adc	r25, r25
    6694:	fc 01       	movw	r30, r24
    6696:	a3 e0       	ldi	r26, 0x03	; 3
    6698:	ee 0f       	add	r30, r30
    669a:	ff 1f       	adc	r31, r31
    669c:	aa 95       	dec	r26
    669e:	e1 f7       	brne	.-8      	; 0x6698 <_hSelfLeveling+0x2ec>
    66a0:	e8 1b       	sub	r30, r24
    66a2:	f9 0b       	sbc	r31, r25
    66a4:	ef 52       	subi	r30, 0x2F	; 47
    66a6:	f9 4f       	sbci	r31, 0xF9	; 249
    66a8:	46 a5       	ldd	r20, Z+46	; 0x2e
    66aa:	57 a5       	ldd	r21, Z+47	; 0x2f
    66ac:	01 e0       	ldi	r16, 0x01	; 1
    66ae:	80 91 36 05 	lds	r24, 0x0536
    66b2:	83 30       	cpi	r24, 0x03	; 3
    66b4:	09 f0       	breq	.+2      	; 0x66b8 <_hSelfLeveling+0x30c>
    66b6:	00 e0       	ldi	r16, 0x00	; 0
    66b8:	82 e0       	ldi	r24, 0x02	; 2
    66ba:	6e e1       	ldi	r22, 0x1E	; 30
    66bc:	23 e0       	ldi	r18, 0x03	; 3
    66be:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <LCD_WriteValue>
	LCD_WriteValue(2,84,Config.AccParams[subindex]._ILimit,3,4==subpage);
    66c2:	80 91 37 05 	lds	r24, 0x0537
    66c6:	90 e0       	ldi	r25, 0x00	; 0
    66c8:	88 0f       	add	r24, r24
    66ca:	99 1f       	adc	r25, r25
    66cc:	fc 01       	movw	r30, r24
    66ce:	73 e0       	ldi	r23, 0x03	; 3
    66d0:	ee 0f       	add	r30, r30
    66d2:	ff 1f       	adc	r31, r31
    66d4:	7a 95       	dec	r23
    66d6:	e1 f7       	brne	.-8      	; 0x66d0 <_hSelfLeveling+0x324>
    66d8:	e8 1b       	sub	r30, r24
    66da:	f9 0b       	sbc	r31, r25
    66dc:	ef 52       	subi	r30, 0x2F	; 47
    66de:	f9 4f       	sbci	r31, 0xF9	; 249
    66e0:	40 a9       	ldd	r20, Z+48	; 0x30
    66e2:	51 a9       	ldd	r21, Z+49	; 0x31
    66e4:	01 e0       	ldi	r16, 0x01	; 1
    66e6:	80 91 36 05 	lds	r24, 0x0536
    66ea:	84 30       	cpi	r24, 0x04	; 4
    66ec:	09 f0       	breq	.+2      	; 0x66f0 <_hSelfLeveling+0x344>
    66ee:	00 e0       	ldi	r16, 0x00	; 0
    66f0:	82 e0       	ldi	r24, 0x02	; 2
    66f2:	64 e5       	ldi	r22, 0x54	; 84
    66f4:	23 e0       	ldi	r18, 0x03	; 3
    66f6:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <LCD_WriteValue>
	LCD_WriteValue(3,30,Config.AccParams[subindex]._D,3,5==subpage);
    66fa:	80 91 37 05 	lds	r24, 0x0537
    66fe:	90 e0       	ldi	r25, 0x00	; 0
    6700:	88 0f       	add	r24, r24
    6702:	99 1f       	adc	r25, r25
    6704:	fc 01       	movw	r30, r24
    6706:	53 e0       	ldi	r21, 0x03	; 3
    6708:	ee 0f       	add	r30, r30
    670a:	ff 1f       	adc	r31, r31
    670c:	5a 95       	dec	r21
    670e:	e1 f7       	brne	.-8      	; 0x6708 <_hSelfLeveling+0x35c>
    6710:	e8 1b       	sub	r30, r24
    6712:	f9 0b       	sbc	r31, r25
    6714:	ef 52       	subi	r30, 0x2F	; 47
    6716:	f9 4f       	sbci	r31, 0xF9	; 249
    6718:	42 a9       	ldd	r20, Z+50	; 0x32
    671a:	53 a9       	ldd	r21, Z+51	; 0x33
    671c:	01 e0       	ldi	r16, 0x01	; 1
    671e:	80 91 36 05 	lds	r24, 0x0536
    6722:	85 30       	cpi	r24, 0x05	; 5
    6724:	09 f0       	breq	.+2      	; 0x6728 <_hSelfLeveling+0x37c>
    6726:	00 e0       	ldi	r16, 0x00	; 0
    6728:	83 e0       	ldi	r24, 0x03	; 3
    672a:	6e e1       	ldi	r22, 0x1E	; 30
    672c:	23 e0       	ldi	r18, 0x03	; 3
    672e:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <LCD_WriteValue>
	LCD_WriteValue(3,84,Config.AccParams[subindex]._DLimit,3,6==subpage);
    6732:	80 91 37 05 	lds	r24, 0x0537
    6736:	90 e0       	ldi	r25, 0x00	; 0
    6738:	88 0f       	add	r24, r24
    673a:	99 1f       	adc	r25, r25
    673c:	fc 01       	movw	r30, r24
    673e:	33 e0       	ldi	r19, 0x03	; 3
    6740:	ee 0f       	add	r30, r30
    6742:	ff 1f       	adc	r31, r31
    6744:	3a 95       	dec	r19
    6746:	e1 f7       	brne	.-8      	; 0x6740 <_hSelfLeveling+0x394>
    6748:	e8 1b       	sub	r30, r24
    674a:	f9 0b       	sbc	r31, r25
    674c:	ef 52       	subi	r30, 0x2F	; 47
    674e:	f9 4f       	sbci	r31, 0xF9	; 249
    6750:	44 a9       	ldd	r20, Z+52	; 0x34
    6752:	55 a9       	ldd	r21, Z+53	; 0x35
    6754:	01 e0       	ldi	r16, 0x01	; 1
    6756:	80 91 36 05 	lds	r24, 0x0536
    675a:	86 30       	cpi	r24, 0x06	; 6
    675c:	09 f0       	breq	.+2      	; 0x6760 <_hSelfLeveling+0x3b4>
    675e:	00 e0       	ldi	r16, 0x00	; 0
    6760:	83 e0       	ldi	r24, 0x03	; 3
    6762:	64 e5       	ldi	r22, 0x54	; 84
    6764:	23 e0       	ldi	r18, 0x03	; 3
    6766:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <LCD_WriteValue>
	LCD_WriteValue(4,84,Config.AccParams[subindex].ComplementaryFilterAlpha,3,7==subpage);
    676a:	80 91 37 05 	lds	r24, 0x0537
    676e:	90 e0       	ldi	r25, 0x00	; 0
    6770:	88 0f       	add	r24, r24
    6772:	99 1f       	adc	r25, r25
    6774:	fc 01       	movw	r30, r24
    6776:	03 e0       	ldi	r16, 0x03	; 3
    6778:	ee 0f       	add	r30, r30
    677a:	ff 1f       	adc	r31, r31
    677c:	0a 95       	dec	r16
    677e:	e1 f7       	brne	.-8      	; 0x6778 <_hSelfLeveling+0x3cc>
    6780:	e8 1b       	sub	r30, r24
    6782:	f9 0b       	sbc	r31, r25
    6784:	ef 52       	subi	r30, 0x2F	; 47
    6786:	f9 4f       	sbci	r31, 0xF9	; 249
    6788:	46 a9       	ldd	r20, Z+54	; 0x36
    678a:	57 a9       	ldd	r21, Z+55	; 0x37
    678c:	01 e0       	ldi	r16, 0x01	; 1
    678e:	80 91 36 05 	lds	r24, 0x0536
    6792:	87 30       	cpi	r24, 0x07	; 7
    6794:	09 f0       	breq	.+2      	; 0x6798 <_hSelfLeveling+0x3ec>
    6796:	00 e0       	ldi	r16, 0x00	; 0
    6798:	84 e0       	ldi	r24, 0x04	; 4
    679a:	64 e5       	ldi	r22, 0x54	; 84
    679c:	23 e0       	ldi	r18, 0x03	; 3
    679e:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <LCD_WriteValue>
	
}
    67a2:	0f 91       	pop	r16
    67a4:	08 95       	ret

000067a6 <_hStabilization>:

/*
* check : http://code.google.com/p/ardupirates/wiki/PID_Setting_SuperStable_Code
*/ 
void _hStabilization()
{
    67a6:	ef 92       	push	r14
    67a8:	0f 93       	push	r16
	NOKEYRETURN;
    67aa:	80 91 bc 05 	lds	r24, 0x05BC
    67ae:	88 23       	and	r24, r24
    67b0:	09 f4       	brne	.+2      	; 0x67b4 <_hStabilization+0xe>
    67b2:	e9 c1       	rjmp	.+978    	; 0x6b86 <_hStabilization+0x3e0>
	PageKey(9);
    67b4:	89 e0       	ldi	r24, 0x09	; 9
    67b6:	0e 94 11 31 	call	0x6222	; 0x6222 <PageKey>
	
	if (KEY4)
    67ba:	30 91 bc 05 	lds	r19, 0x05BC
    67be:	34 ff       	sbrs	r19, 4
    67c0:	c2 c0       	rjmp	.+388    	; 0x6946 <_hStabilization+0x1a0>
	{
		if (subpage!=0) bValueChanged = true;
    67c2:	20 91 36 05 	lds	r18, 0x0536
    67c6:	22 23       	and	r18, r18
    67c8:	19 f0       	breq	.+6      	; 0x67d0 <_hStabilization+0x2a>
    67ca:	81 e0       	ldi	r24, 0x01	; 1
    67cc:	80 93 32 05 	sts	0x0532, r24
		currentPage.softkeys = _skMENUSAVE;
    67d0:	82 ee       	ldi	r24, 0xE2	; 226
    67d2:	9b e0       	ldi	r25, 0x0B	; 11
    67d4:	90 93 45 05 	sts	0x0545, r25
    67d8:	80 93 44 05 	sts	0x0544, r24
		
		switch (subpage)
    67dc:	24 30       	cpi	r18, 0x04	; 4
    67de:	09 f4       	brne	.+2      	; 0x67e2 <_hStabilization+0x3c>
    67e0:	5a c0       	rjmp	.+180    	; 0x6896 <_hStabilization+0xf0>
    67e2:	25 30       	cpi	r18, 0x05	; 5
    67e4:	50 f4       	brcc	.+20     	; 0x67fa <_hStabilization+0x54>
    67e6:	21 30       	cpi	r18, 0x01	; 1
    67e8:	01 f1       	breq	.+64     	; 0x682a <_hStabilization+0x84>
    67ea:	21 30       	cpi	r18, 0x01	; 1
    67ec:	98 f0       	brcs	.+38     	; 0x6814 <_hStabilization+0x6e>
    67ee:	22 30       	cpi	r18, 0x02	; 2
    67f0:	71 f1       	breq	.+92     	; 0x684e <_hStabilization+0xa8>
    67f2:	23 30       	cpi	r18, 0x03	; 3
    67f4:	09 f0       	breq	.+2      	; 0x67f8 <_hStabilization+0x52>
    67f6:	a7 c0       	rjmp	.+334    	; 0x6946 <_hStabilization+0x1a0>
    67f8:	3b c0       	rjmp	.+118    	; 0x6870 <_hStabilization+0xca>
    67fa:	26 30       	cpi	r18, 0x06	; 6
    67fc:	09 f4       	brne	.+2      	; 0x6800 <_hStabilization+0x5a>
    67fe:	6d c0       	rjmp	.+218    	; 0x68da <_hStabilization+0x134>
    6800:	26 30       	cpi	r18, 0x06	; 6
    6802:	08 f4       	brcc	.+2      	; 0x6806 <_hStabilization+0x60>
    6804:	59 c0       	rjmp	.+178    	; 0x68b8 <_hStabilization+0x112>
    6806:	27 30       	cpi	r18, 0x07	; 7
    6808:	09 f4       	brne	.+2      	; 0x680c <_hStabilization+0x66>
    680a:	7c c0       	rjmp	.+248    	; 0x6904 <_hStabilization+0x15e>
    680c:	28 30       	cpi	r18, 0x08	; 8
    680e:	09 f0       	breq	.+2      	; 0x6812 <_hStabilization+0x6c>
    6810:	9a c0       	rjmp	.+308    	; 0x6946 <_hStabilization+0x1a0>
    6812:	90 c0       	rjmp	.+288    	; 0x6934 <_hStabilization+0x18e>
		{
			case 0: if (subindex==0) subindex=1; else subindex=0; break;
    6814:	80 91 37 05 	lds	r24, 0x0537
    6818:	88 23       	and	r24, r24
    681a:	21 f4       	brne	.+8      	; 0x6824 <_hStabilization+0x7e>
    681c:	81 e0       	ldi	r24, 0x01	; 1
    681e:	80 93 37 05 	sts	0x0537, r24
    6822:	91 c0       	rjmp	.+290    	; 0x6946 <_hStabilization+0x1a0>
    6824:	10 92 37 05 	sts	0x0537, r1
    6828:	8e c0       	rjmp	.+284    	; 0x6946 <_hStabilization+0x1a0>
			case 1: startEditMode(&(Config.GyroParams[subindex]._P),-500,500,TYPE_INT16); return ;
    682a:	20 91 37 05 	lds	r18, 0x0537
    682e:	30 e0       	ldi	r19, 0x00	; 0
    6830:	2f 5f       	subi	r18, 0xFF	; 255
    6832:	3f 4f       	sbci	r19, 0xFF	; 255
    6834:	22 0f       	add	r18, r18
    6836:	33 1f       	adc	r19, r19
    6838:	c9 01       	movw	r24, r18
    683a:	63 e0       	ldi	r22, 0x03	; 3
    683c:	88 0f       	add	r24, r24
    683e:	99 1f       	adc	r25, r25
    6840:	6a 95       	dec	r22
    6842:	e1 f7       	brne	.-8      	; 0x683c <_hStabilization+0x96>
    6844:	82 1b       	sub	r24, r18
    6846:	93 0b       	sbc	r25, r19
    6848:	8f 52       	subi	r24, 0x2F	; 47
    684a:	99 4f       	sbci	r25, 0xF9	; 249
    684c:	21 c0       	rjmp	.+66     	; 0x6890 <_hStabilization+0xea>
			case 2: startEditMode(&(Config.GyroParams[subindex]._PLimit),0,500,TYPE_INT16); return ;
    684e:	80 91 37 05 	lds	r24, 0x0537
    6852:	90 e0       	ldi	r25, 0x00	; 0
    6854:	9c 01       	movw	r18, r24
    6856:	22 0f       	add	r18, r18
    6858:	33 1f       	adc	r19, r19
    685a:	c9 01       	movw	r24, r18
    685c:	43 e0       	ldi	r20, 0x03	; 3
    685e:	88 0f       	add	r24, r24
    6860:	99 1f       	adc	r25, r25
    6862:	4a 95       	dec	r20
    6864:	e1 f7       	brne	.-8      	; 0x685e <_hStabilization+0xb8>
    6866:	82 1b       	sub	r24, r18
    6868:	93 0b       	sbc	r25, r19
    686a:	8f 51       	subi	r24, 0x1F	; 31
    686c:	99 4f       	sbci	r25, 0xF9	; 249
    686e:	45 c0       	rjmp	.+138    	; 0x68fa <_hStabilization+0x154>
			case 3: startEditMode(&(Config.GyroParams[subindex]._I),-500,500,TYPE_INT16);  return ;
    6870:	80 91 37 05 	lds	r24, 0x0537
    6874:	90 e0       	ldi	r25, 0x00	; 0
    6876:	9c 01       	movw	r18, r24
    6878:	22 0f       	add	r18, r18
    687a:	33 1f       	adc	r19, r19
    687c:	c9 01       	movw	r24, r18
    687e:	03 e0       	ldi	r16, 0x03	; 3
    6880:	88 0f       	add	r24, r24
    6882:	99 1f       	adc	r25, r25
    6884:	0a 95       	dec	r16
    6886:	e1 f7       	brne	.-8      	; 0x6880 <_hStabilization+0xda>
    6888:	82 1b       	sub	r24, r18
    688a:	93 0b       	sbc	r25, r19
    688c:	8d 51       	subi	r24, 0x1D	; 29
    688e:	99 4f       	sbci	r25, 0xF9	; 249
    6890:	6c e0       	ldi	r22, 0x0C	; 12
    6892:	7e ef       	ldi	r23, 0xFE	; 254
    6894:	34 c0       	rjmp	.+104    	; 0x68fe <_hStabilization+0x158>
			case 4: startEditMode(&(Config.GyroParams[subindex]._ILimit),0,500,TYPE_INT16); return ;
    6896:	80 91 37 05 	lds	r24, 0x0537
    689a:	90 e0       	ldi	r25, 0x00	; 0
    689c:	9c 01       	movw	r18, r24
    689e:	22 0f       	add	r18, r18
    68a0:	33 1f       	adc	r19, r19
    68a2:	c9 01       	movw	r24, r18
    68a4:	a3 e0       	ldi	r26, 0x03	; 3
    68a6:	88 0f       	add	r24, r24
    68a8:	99 1f       	adc	r25, r25
    68aa:	aa 95       	dec	r26
    68ac:	e1 f7       	brne	.-8      	; 0x68a6 <_hStabilization+0x100>
    68ae:	82 1b       	sub	r24, r18
    68b0:	93 0b       	sbc	r25, r19
    68b2:	8b 51       	subi	r24, 0x1B	; 27
    68b4:	99 4f       	sbci	r25, 0xF9	; 249
    68b6:	21 c0       	rjmp	.+66     	; 0x68fa <_hStabilization+0x154>
			case 5: startEditMode(&(Config.GyroParams[subindex]._D),-500,500,TYPE_INT16);  return ; 
    68b8:	80 91 37 05 	lds	r24, 0x0537
    68bc:	90 e0       	ldi	r25, 0x00	; 0
    68be:	9c 01       	movw	r18, r24
    68c0:	22 0f       	add	r18, r18
    68c2:	33 1f       	adc	r19, r19
    68c4:	c9 01       	movw	r24, r18
    68c6:	e3 e0       	ldi	r30, 0x03	; 3
    68c8:	88 0f       	add	r24, r24
    68ca:	99 1f       	adc	r25, r25
    68cc:	ea 95       	dec	r30
    68ce:	e1 f7       	brne	.-8      	; 0x68c8 <_hStabilization+0x122>
    68d0:	82 1b       	sub	r24, r18
    68d2:	93 0b       	sbc	r25, r19
    68d4:	89 51       	subi	r24, 0x19	; 25
    68d6:	99 4f       	sbci	r25, 0xF9	; 249
    68d8:	db cf       	rjmp	.-74     	; 0x6890 <_hStabilization+0xea>
			case 6: startEditMode(&(Config.GyroParams[subindex]._DLimit),0,500,TYPE_INT16); return ;
    68da:	80 91 37 05 	lds	r24, 0x0537
    68de:	90 e0       	ldi	r25, 0x00	; 0
    68e0:	9c 01       	movw	r18, r24
    68e2:	22 0f       	add	r18, r18
    68e4:	33 1f       	adc	r19, r19
    68e6:	c9 01       	movw	r24, r18
    68e8:	63 e0       	ldi	r22, 0x03	; 3
    68ea:	88 0f       	add	r24, r24
    68ec:	99 1f       	adc	r25, r25
    68ee:	6a 95       	dec	r22
    68f0:	e1 f7       	brne	.-8      	; 0x68ea <_hStabilization+0x144>
    68f2:	82 1b       	sub	r24, r18
    68f4:	93 0b       	sbc	r25, r19
    68f6:	87 51       	subi	r24, 0x17	; 23
    68f8:	99 4f       	sbci	r25, 0xF9	; 249
    68fa:	60 e0       	ldi	r22, 0x00	; 0
    68fc:	70 e0       	ldi	r23, 0x00	; 0
    68fe:	44 ef       	ldi	r20, 0xF4	; 244
    6900:	51 e0       	ldi	r21, 0x01	; 1
    6902:	14 c0       	rjmp	.+40     	; 0x692c <_hStabilization+0x186>
			case 7: startEditMode(&(Config.GyroParams[subindex].ComplementaryFilterAlpha),0,999,TYPE_INT16); return ;
    6904:	80 91 37 05 	lds	r24, 0x0537
    6908:	90 e0       	ldi	r25, 0x00	; 0
    690a:	9c 01       	movw	r18, r24
    690c:	22 0f       	add	r18, r18
    690e:	33 1f       	adc	r19, r19
    6910:	c9 01       	movw	r24, r18
    6912:	43 e0       	ldi	r20, 0x03	; 3
    6914:	88 0f       	add	r24, r24
    6916:	99 1f       	adc	r25, r25
    6918:	4a 95       	dec	r20
    691a:	e1 f7       	brne	.-8      	; 0x6914 <_hStabilization+0x16e>
    691c:	82 1b       	sub	r24, r18
    691e:	93 0b       	sbc	r25, r19
    6920:	85 51       	subi	r24, 0x15	; 21
    6922:	99 4f       	sbci	r25, 0xF9	; 249
    6924:	60 e0       	ldi	r22, 0x00	; 0
    6926:	70 e0       	ldi	r23, 0x00	; 0
    6928:	47 ee       	ldi	r20, 0xE7	; 231
    692a:	53 e0       	ldi	r21, 0x03	; 3
    692c:	23 e0       	ldi	r18, 0x03	; 3
    692e:	0e 94 c3 30 	call	0x6186	; 0x6186 <startEditMode>
    6932:	29 c1       	rjmp	.+594    	; 0x6b86 <_hStabilization+0x3e0>
			case 8: if (Config.ReverseYAW==GYRO_NORMAL) Config.ReverseYAW =GYRO_REVERSE; else Config.ReverseYAW = GYRO_NORMAL; break; // update the UI
    6934:	80 91 6c 07 	lds	r24, 0x076C
    6938:	81 30       	cpi	r24, 0x01	; 1
    693a:	11 f4       	brne	.+4      	; 0x6940 <_hStabilization+0x19a>
    693c:	8f ef       	ldi	r24, 0xFF	; 255
    693e:	01 c0       	rjmp	.+2      	; 0x6942 <_hStabilization+0x19c>
    6940:	81 e0       	ldi	r24, 0x01	; 1
    6942:	80 93 6c 07 	sts	0x076C, r24
		}
		
		
	}
	
	if (KEY1)
    6946:	37 ff       	sbrs	r19, 7
    6948:	02 c0       	rjmp	.+4      	; 0x694e <_hStabilization+0x1a8>
	{
		_helper_SaveinEEPROM_ifChanged();
    694a:	0e 94 bb 2c 	call	0x5976	; 0x5976 <_helper_SaveinEEPROM_ifChanged>
	}
	
	lcdReverse(subpage == 0);
    694e:	81 e0       	ldi	r24, 0x01	; 1
    6950:	90 91 36 05 	lds	r25, 0x0536
    6954:	91 11       	cpse	r25, r1
    6956:	80 e0       	ldi	r24, 0x00	; 0
    6958:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <lcdReverse>
	if (subindex==0)
    695c:	80 91 37 05 	lds	r24, 0x0537
    6960:	88 23       	and	r24, r24
    6962:	79 f4       	brne	.+30     	; 0x6982 <_hStabilization+0x1dc>
	{
		strcpy_P(sXDeg,PSTR("Pitch & Roll"));
    6964:	8c ee       	ldi	r24, 0xEC	; 236
    6966:	95 e0       	ldi	r25, 0x05	; 5
    6968:	69 e8       	ldi	r22, 0x89	; 137
    696a:	7c e0       	ldi	r23, 0x0C	; 12
    696c:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <strcpy_P>
		LCD_WriteString_Pex(5,0,PSTR("                "),16,false);    
    6970:	85 e0       	ldi	r24, 0x05	; 5
    6972:	60 e0       	ldi	r22, 0x00	; 0
    6974:	48 e7       	ldi	r20, 0x78	; 120
    6976:	5c e0       	ldi	r21, 0x0C	; 12
    6978:	20 e1       	ldi	r18, 0x10	; 16
    697a:	00 e0       	ldi	r16, 0x00	; 0
    697c:	0e 94 6c 0d 	call	0x1ad8	; 0x1ad8 <LCD_WriteString_Pex>
    6980:	32 c0       	rjmp	.+100    	; 0x69e6 <_hStabilization+0x240>
	
	}
	else
	{
		strcpy_P(sXDeg,PSTR("YAW         "));
    6982:	8c ee       	ldi	r24, 0xEC	; 236
    6984:	95 e0       	ldi	r25, 0x05	; 5
    6986:	6b e6       	ldi	r22, 0x6B	; 107
    6988:	7c e0       	ldi	r23, 0x0C	; 12
    698a:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <strcpy_P>
		if (Config.FrameType == FRAMETYPE_TRICOPTER)
    698e:	80 91 d8 06 	lds	r24, 0x06D8
    6992:	82 30       	cpi	r24, 0x02	; 2
    6994:	41 f5       	brne	.+80     	; 0x69e6 <_hStabilization+0x240>
		{
			LCD_WriteStringex (0,0,sXDeg,0==subpage);
    6996:	21 e0       	ldi	r18, 0x01	; 1
    6998:	80 91 36 05 	lds	r24, 0x0536
    699c:	81 11       	cpse	r24, r1
    699e:	20 e0       	ldi	r18, 0x00	; 0
    69a0:	80 e0       	ldi	r24, 0x00	; 0
    69a2:	60 e0       	ldi	r22, 0x00	; 0
    69a4:	4c ee       	ldi	r20, 0xEC	; 236
    69a6:	55 e0       	ldi	r21, 0x05	; 5
    69a8:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <LCD_WriteStringex>
			LCD_WriteString_Pex(5,0,PSTR("Reverse GYRO"),12,false);    
    69ac:	85 e0       	ldi	r24, 0x05	; 5
    69ae:	60 e0       	ldi	r22, 0x00	; 0
    69b0:	4e e5       	ldi	r20, 0x5E	; 94
    69b2:	5c e0       	ldi	r21, 0x0C	; 12
    69b4:	2c e0       	ldi	r18, 0x0C	; 12
    69b6:	00 e0       	ldi	r16, 0x00	; 0
    69b8:	0e 94 6c 0d 	call	0x1ad8	; 0x1ad8 <LCD_WriteString_Pex>
			
			_helper_DisplayBiStateText(5,84 ,PSTR("N"), PSTR("R"), Config.ReverseYAW==GYRO_NORMAL, 8==subpage);
    69bc:	01 e0       	ldi	r16, 0x01	; 1
    69be:	80 91 6c 07 	lds	r24, 0x076C
    69c2:	81 30       	cpi	r24, 0x01	; 1
    69c4:	09 f0       	breq	.+2      	; 0x69c8 <_hStabilization+0x222>
    69c6:	00 e0       	ldi	r16, 0x00	; 0
    69c8:	91 e0       	ldi	r25, 0x01	; 1
    69ca:	80 91 36 05 	lds	r24, 0x0536
    69ce:	88 30       	cpi	r24, 0x08	; 8
    69d0:	09 f0       	breq	.+2      	; 0x69d4 <_hStabilization+0x22e>
    69d2:	90 e0       	ldi	r25, 0x00	; 0
    69d4:	85 e0       	ldi	r24, 0x05	; 5
    69d6:	64 e5       	ldi	r22, 0x54	; 84
    69d8:	4c e5       	ldi	r20, 0x5C	; 92
    69da:	5c e0       	ldi	r21, 0x0C	; 12
    69dc:	2a e5       	ldi	r18, 0x5A	; 90
    69de:	3c e0       	ldi	r19, 0x0C	; 12
    69e0:	e9 2e       	mov	r14, r25
    69e2:	0e 94 8f 2c 	call	0x591e	; 0x591e <_helper_DisplayBiStateText>
		}		

	}
	LCD_WriteStringex (0,0,sXDeg,0==subpage);
    69e6:	21 e0       	ldi	r18, 0x01	; 1
    69e8:	80 91 36 05 	lds	r24, 0x0536
    69ec:	81 11       	cpse	r24, r1
    69ee:	20 e0       	ldi	r18, 0x00	; 0
    69f0:	80 e0       	ldi	r24, 0x00	; 0
    69f2:	60 e0       	ldi	r22, 0x00	; 0
    69f4:	4c ee       	ldi	r20, 0xEC	; 236
    69f6:	55 e0       	ldi	r21, 0x05	; 5
    69f8:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <LCD_WriteStringex>
	LCD_WriteValue(1,30,Config.GyroParams[subindex]._P,3,1==subpage);
    69fc:	80 91 37 05 	lds	r24, 0x0537
    6a00:	90 e0       	ldi	r25, 0x00	; 0
    6a02:	01 96       	adiw	r24, 0x01	; 1
    6a04:	88 0f       	add	r24, r24
    6a06:	99 1f       	adc	r25, r25
    6a08:	fc 01       	movw	r30, r24
    6a0a:	03 e0       	ldi	r16, 0x03	; 3
    6a0c:	ee 0f       	add	r30, r30
    6a0e:	ff 1f       	adc	r31, r31
    6a10:	0a 95       	dec	r16
    6a12:	e1 f7       	brne	.-8      	; 0x6a0c <_hStabilization+0x266>
    6a14:	e8 1b       	sub	r30, r24
    6a16:	f9 0b       	sbc	r31, r25
    6a18:	ef 52       	subi	r30, 0x2F	; 47
    6a1a:	f9 4f       	sbci	r31, 0xF9	; 249
    6a1c:	40 81       	ld	r20, Z
    6a1e:	51 81       	ldd	r21, Z+1	; 0x01
    6a20:	01 e0       	ldi	r16, 0x01	; 1
    6a22:	80 91 36 05 	lds	r24, 0x0536
    6a26:	81 30       	cpi	r24, 0x01	; 1
    6a28:	09 f0       	breq	.+2      	; 0x6a2c <_hStabilization+0x286>
    6a2a:	00 e0       	ldi	r16, 0x00	; 0
    6a2c:	81 e0       	ldi	r24, 0x01	; 1
    6a2e:	6e e1       	ldi	r22, 0x1E	; 30
    6a30:	23 e0       	ldi	r18, 0x03	; 3
    6a32:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <LCD_WriteValue>
	LCD_WriteValue(1,84,Config.GyroParams[subindex]._PLimit,3,2==subpage);
    6a36:	80 91 37 05 	lds	r24, 0x0537
    6a3a:	90 e0       	ldi	r25, 0x00	; 0
    6a3c:	88 0f       	add	r24, r24
    6a3e:	99 1f       	adc	r25, r25
    6a40:	fc 01       	movw	r30, r24
    6a42:	a3 e0       	ldi	r26, 0x03	; 3
    6a44:	ee 0f       	add	r30, r30
    6a46:	ff 1f       	adc	r31, r31
    6a48:	aa 95       	dec	r26
    6a4a:	e1 f7       	brne	.-8      	; 0x6a44 <_hStabilization+0x29e>
    6a4c:	e8 1b       	sub	r30, r24
    6a4e:	f9 0b       	sbc	r31, r25
    6a50:	ef 52       	subi	r30, 0x2F	; 47
    6a52:	f9 4f       	sbci	r31, 0xF9	; 249
    6a54:	40 89       	ldd	r20, Z+16	; 0x10
    6a56:	51 89       	ldd	r21, Z+17	; 0x11
    6a58:	01 e0       	ldi	r16, 0x01	; 1
    6a5a:	80 91 36 05 	lds	r24, 0x0536
    6a5e:	82 30       	cpi	r24, 0x02	; 2
    6a60:	09 f0       	breq	.+2      	; 0x6a64 <_hStabilization+0x2be>
    6a62:	00 e0       	ldi	r16, 0x00	; 0
    6a64:	81 e0       	ldi	r24, 0x01	; 1
    6a66:	64 e5       	ldi	r22, 0x54	; 84
    6a68:	23 e0       	ldi	r18, 0x03	; 3
    6a6a:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <LCD_WriteValue>
	LCD_WriteValue(2,30,Config.GyroParams[subindex]._I,3,3==subpage);
    6a6e:	80 91 37 05 	lds	r24, 0x0537
    6a72:	90 e0       	ldi	r25, 0x00	; 0
    6a74:	88 0f       	add	r24, r24
    6a76:	99 1f       	adc	r25, r25
    6a78:	fc 01       	movw	r30, r24
    6a7a:	73 e0       	ldi	r23, 0x03	; 3
    6a7c:	ee 0f       	add	r30, r30
    6a7e:	ff 1f       	adc	r31, r31
    6a80:	7a 95       	dec	r23
    6a82:	e1 f7       	brne	.-8      	; 0x6a7c <_hStabilization+0x2d6>
    6a84:	e8 1b       	sub	r30, r24
    6a86:	f9 0b       	sbc	r31, r25
    6a88:	ef 52       	subi	r30, 0x2F	; 47
    6a8a:	f9 4f       	sbci	r31, 0xF9	; 249
    6a8c:	42 89       	ldd	r20, Z+18	; 0x12
    6a8e:	53 89       	ldd	r21, Z+19	; 0x13
    6a90:	01 e0       	ldi	r16, 0x01	; 1
    6a92:	80 91 36 05 	lds	r24, 0x0536
    6a96:	83 30       	cpi	r24, 0x03	; 3
    6a98:	09 f0       	breq	.+2      	; 0x6a9c <_hStabilization+0x2f6>
    6a9a:	00 e0       	ldi	r16, 0x00	; 0
    6a9c:	82 e0       	ldi	r24, 0x02	; 2
    6a9e:	6e e1       	ldi	r22, 0x1E	; 30
    6aa0:	23 e0       	ldi	r18, 0x03	; 3
    6aa2:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <LCD_WriteValue>
	LCD_WriteValue(2,84,Config.GyroParams[subindex]._ILimit,3,4==subpage);
    6aa6:	80 91 37 05 	lds	r24, 0x0537
    6aaa:	90 e0       	ldi	r25, 0x00	; 0
    6aac:	88 0f       	add	r24, r24
    6aae:	99 1f       	adc	r25, r25
    6ab0:	fc 01       	movw	r30, r24
    6ab2:	53 e0       	ldi	r21, 0x03	; 3
    6ab4:	ee 0f       	add	r30, r30
    6ab6:	ff 1f       	adc	r31, r31
    6ab8:	5a 95       	dec	r21
    6aba:	e1 f7       	brne	.-8      	; 0x6ab4 <_hStabilization+0x30e>
    6abc:	e8 1b       	sub	r30, r24
    6abe:	f9 0b       	sbc	r31, r25
    6ac0:	ef 52       	subi	r30, 0x2F	; 47
    6ac2:	f9 4f       	sbci	r31, 0xF9	; 249
    6ac4:	44 89       	ldd	r20, Z+20	; 0x14
    6ac6:	55 89       	ldd	r21, Z+21	; 0x15
    6ac8:	01 e0       	ldi	r16, 0x01	; 1
    6aca:	80 91 36 05 	lds	r24, 0x0536
    6ace:	84 30       	cpi	r24, 0x04	; 4
    6ad0:	09 f0       	breq	.+2      	; 0x6ad4 <_hStabilization+0x32e>
    6ad2:	00 e0       	ldi	r16, 0x00	; 0
    6ad4:	82 e0       	ldi	r24, 0x02	; 2
    6ad6:	64 e5       	ldi	r22, 0x54	; 84
    6ad8:	23 e0       	ldi	r18, 0x03	; 3
    6ada:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <LCD_WriteValue>
	LCD_WriteValue(3,30,Config.GyroParams[subindex]._D,3,5==subpage);
    6ade:	80 91 37 05 	lds	r24, 0x0537
    6ae2:	90 e0       	ldi	r25, 0x00	; 0
    6ae4:	88 0f       	add	r24, r24
    6ae6:	99 1f       	adc	r25, r25
    6ae8:	fc 01       	movw	r30, r24
    6aea:	33 e0       	ldi	r19, 0x03	; 3
    6aec:	ee 0f       	add	r30, r30
    6aee:	ff 1f       	adc	r31, r31
    6af0:	3a 95       	dec	r19
    6af2:	e1 f7       	brne	.-8      	; 0x6aec <_hStabilization+0x346>
    6af4:	e8 1b       	sub	r30, r24
    6af6:	f9 0b       	sbc	r31, r25
    6af8:	ef 52       	subi	r30, 0x2F	; 47
    6afa:	f9 4f       	sbci	r31, 0xF9	; 249
    6afc:	46 89       	ldd	r20, Z+22	; 0x16
    6afe:	57 89       	ldd	r21, Z+23	; 0x17
    6b00:	01 e0       	ldi	r16, 0x01	; 1
    6b02:	80 91 36 05 	lds	r24, 0x0536
    6b06:	85 30       	cpi	r24, 0x05	; 5
    6b08:	09 f0       	breq	.+2      	; 0x6b0c <_hStabilization+0x366>
    6b0a:	00 e0       	ldi	r16, 0x00	; 0
    6b0c:	83 e0       	ldi	r24, 0x03	; 3
    6b0e:	6e e1       	ldi	r22, 0x1E	; 30
    6b10:	23 e0       	ldi	r18, 0x03	; 3
    6b12:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <LCD_WriteValue>
	LCD_WriteValue(3,84,Config.GyroParams[subindex]._DLimit,3,6==subpage);
    6b16:	80 91 37 05 	lds	r24, 0x0537
    6b1a:	90 e0       	ldi	r25, 0x00	; 0
    6b1c:	88 0f       	add	r24, r24
    6b1e:	99 1f       	adc	r25, r25
    6b20:	fc 01       	movw	r30, r24
    6b22:	03 e0       	ldi	r16, 0x03	; 3
    6b24:	ee 0f       	add	r30, r30
    6b26:	ff 1f       	adc	r31, r31
    6b28:	0a 95       	dec	r16
    6b2a:	e1 f7       	brne	.-8      	; 0x6b24 <_hStabilization+0x37e>
    6b2c:	e8 1b       	sub	r30, r24
    6b2e:	f9 0b       	sbc	r31, r25
    6b30:	ef 52       	subi	r30, 0x2F	; 47
    6b32:	f9 4f       	sbci	r31, 0xF9	; 249
    6b34:	40 8d       	ldd	r20, Z+24	; 0x18
    6b36:	51 8d       	ldd	r21, Z+25	; 0x19
    6b38:	01 e0       	ldi	r16, 0x01	; 1
    6b3a:	80 91 36 05 	lds	r24, 0x0536
    6b3e:	86 30       	cpi	r24, 0x06	; 6
    6b40:	09 f0       	breq	.+2      	; 0x6b44 <_hStabilization+0x39e>
    6b42:	00 e0       	ldi	r16, 0x00	; 0
    6b44:	83 e0       	ldi	r24, 0x03	; 3
    6b46:	64 e5       	ldi	r22, 0x54	; 84
    6b48:	23 e0       	ldi	r18, 0x03	; 3
    6b4a:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <LCD_WriteValue>
	LCD_WriteValue(4,84,Config.GyroParams[subindex].ComplementaryFilterAlpha,3,7==subpage);
    6b4e:	80 91 37 05 	lds	r24, 0x0537
    6b52:	90 e0       	ldi	r25, 0x00	; 0
    6b54:	88 0f       	add	r24, r24
    6b56:	99 1f       	adc	r25, r25
    6b58:	fc 01       	movw	r30, r24
    6b5a:	a3 e0       	ldi	r26, 0x03	; 3
    6b5c:	ee 0f       	add	r30, r30
    6b5e:	ff 1f       	adc	r31, r31
    6b60:	aa 95       	dec	r26
    6b62:	e1 f7       	brne	.-8      	; 0x6b5c <_hStabilization+0x3b6>
    6b64:	e8 1b       	sub	r30, r24
    6b66:	f9 0b       	sbc	r31, r25
    6b68:	ef 52       	subi	r30, 0x2F	; 47
    6b6a:	f9 4f       	sbci	r31, 0xF9	; 249
    6b6c:	42 8d       	ldd	r20, Z+26	; 0x1a
    6b6e:	53 8d       	ldd	r21, Z+27	; 0x1b
    6b70:	01 e0       	ldi	r16, 0x01	; 1
    6b72:	80 91 36 05 	lds	r24, 0x0536
    6b76:	87 30       	cpi	r24, 0x07	; 7
    6b78:	09 f0       	breq	.+2      	; 0x6b7c <_hStabilization+0x3d6>
    6b7a:	00 e0       	ldi	r16, 0x00	; 0
    6b7c:	84 e0       	ldi	r24, 0x04	; 4
    6b7e:	64 e5       	ldi	r22, 0x54	; 84
    6b80:	23 e0       	ldi	r18, 0x03	; 3
    6b82:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <LCD_WriteValue>
	
}
    6b86:	0f 91       	pop	r16
    6b88:	ef 90       	pop	r14
    6b8a:	08 95       	ret

00006b8c <_hMiscSettings>:
	_helper_DisplayBiStateText(4,84, strYes, strNo, (IS_MISC_SENSOR_SONAR_ENABLED ==true),(subpage==4));
}


void _hMiscSettings()
{
    6b8c:	0f 93       	push	r16
	NOKEYRETURN;
    6b8e:	80 91 bc 05 	lds	r24, 0x05BC
    6b92:	88 23       	and	r24, r24
    6b94:	09 f4       	brne	.+2      	; 0x6b98 <_hMiscSettings+0xc>
    6b96:	75 c0       	rjmp	.+234    	; 0x6c82 <_hMiscSettings+0xf6>
	PageKey(4);
    6b98:	84 e0       	ldi	r24, 0x04	; 4
    6b9a:	0e 94 11 31 	call	0x6222	; 0x6222 <PageKey>
	
		
	if (KEY4)
    6b9e:	20 91 bc 05 	lds	r18, 0x05BC
    6ba2:	24 ff       	sbrs	r18, 4
    6ba4:	33 c0       	rjmp	.+102    	; 0x6c0c <_hMiscSettings+0x80>
	{
		bValueChanged = true;
    6ba6:	81 e0       	ldi	r24, 0x01	; 1
    6ba8:	80 93 32 05 	sts	0x0532, r24
		currentPage.softkeys = _skMENUSAVE;
    6bac:	82 ee       	ldi	r24, 0xE2	; 226
    6bae:	9b e0       	ldi	r25, 0x0B	; 11
    6bb0:	90 93 45 05 	sts	0x0545, r25
    6bb4:	80 93 44 05 	sts	0x0544, r24
		
		switch (subpage)
    6bb8:	80 91 36 05 	lds	r24, 0x0536
    6bbc:	81 30       	cpi	r24, 0x01	; 1
    6bbe:	71 f0       	breq	.+28     	; 0x6bdc <_hMiscSettings+0x50>
    6bc0:	81 30       	cpi	r24, 0x01	; 1
    6bc2:	28 f0       	brcs	.+10     	; 0x6bce <_hMiscSettings+0x42>
    6bc4:	82 30       	cpi	r24, 0x02	; 2
    6bc6:	89 f0       	breq	.+34     	; 0x6bea <_hMiscSettings+0x5e>
    6bc8:	83 30       	cpi	r24, 0x03	; 3
    6bca:	01 f5       	brne	.+64     	; 0x6c0c <_hMiscSettings+0x80>
    6bcc:	15 c0       	rjmp	.+42     	; 0x6bf8 <_hMiscSettings+0x6c>
		{
			case 0: startEditMode(&(Config.AutoDisarm),0,10,TYPE_UINT8); return ;
    6bce:	86 ed       	ldi	r24, 0xD6	; 214
    6bd0:	96 e0       	ldi	r25, 0x06	; 6
    6bd2:	60 e0       	ldi	r22, 0x00	; 0
    6bd4:	70 e0       	ldi	r23, 0x00	; 0
    6bd6:	4a e0       	ldi	r20, 0x0A	; 10
    6bd8:	50 e0       	ldi	r21, 0x00	; 0
    6bda:	14 c0       	rjmp	.+40     	; 0x6c04 <_hMiscSettings+0x78>
			case 1: startEditMode(&(Config.VoltageAlarm),0,100,TYPE_UINT8);  return ;
    6bdc:	85 e2       	ldi	r24, 0x25	; 37
    6bde:	97 e0       	ldi	r25, 0x07	; 7
    6be0:	60 e0       	ldi	r22, 0x00	; 0
    6be2:	70 e0       	ldi	r23, 0x00	; 0
    6be4:	44 e6       	ldi	r20, 0x64	; 100
    6be6:	50 e0       	ldi	r21, 0x00	; 0
    6be8:	0d c0       	rjmp	.+26     	; 0x6c04 <_hMiscSettings+0x78>
			case 2: startEditMode(&(Config.ThrottleMin),0,255,TYPE_UINT8);  return ;
    6bea:	8c ed       	ldi	r24, 0xDC	; 220
    6bec:	96 e0       	ldi	r25, 0x06	; 6
    6bee:	60 e0       	ldi	r22, 0x00	; 0
    6bf0:	70 e0       	ldi	r23, 0x00	; 0
    6bf2:	4f ef       	ldi	r20, 0xFF	; 255
    6bf4:	50 e0       	ldi	r21, 0x00	; 0
    6bf6:	06 c0       	rjmp	.+12     	; 0x6c04 <_hMiscSettings+0x78>
			case 3: startEditMode(&(Config.StickScaling),1,20,TYPE_UINT8);  return ;
    6bf8:	8d ed       	ldi	r24, 0xDD	; 221
    6bfa:	96 e0       	ldi	r25, 0x06	; 6
    6bfc:	61 e0       	ldi	r22, 0x01	; 1
    6bfe:	70 e0       	ldi	r23, 0x00	; 0
    6c00:	44 e1       	ldi	r20, 0x14	; 20
    6c02:	50 e0       	ldi	r21, 0x00	; 0
    6c04:	22 e0       	ldi	r18, 0x02	; 2
    6c06:	0e 94 c3 30 	call	0x6186	; 0x6186 <startEditMode>
    6c0a:	3b c0       	rjmp	.+118    	; 0x6c82 <_hMiscSettings+0xf6>
		}
		
	}
	
	if (KEY1)
    6c0c:	27 ff       	sbrs	r18, 7
    6c0e:	02 c0       	rjmp	.+4      	; 0x6c14 <_hMiscSettings+0x88>
	{
		_helper_SaveinEEPROM_ifChanged();
    6c10:	0e 94 bb 2c 	call	0x5976	; 0x5976 <_helper_SaveinEEPROM_ifChanged>
	}
	
	LCD_WriteValue(0,84,Config.AutoDisarm,3,0==subpage);
    6c14:	40 91 d6 06 	lds	r20, 0x06D6
    6c18:	01 e0       	ldi	r16, 0x01	; 1
    6c1a:	80 91 36 05 	lds	r24, 0x0536
    6c1e:	81 11       	cpse	r24, r1
    6c20:	00 e0       	ldi	r16, 0x00	; 0
    6c22:	80 e0       	ldi	r24, 0x00	; 0
    6c24:	64 e5       	ldi	r22, 0x54	; 84
    6c26:	50 e0       	ldi	r21, 0x00	; 0
    6c28:	23 e0       	ldi	r18, 0x03	; 3
    6c2a:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <LCD_WriteValue>
	LCD_WriteValue(1,84,Config.VoltageAlarm,3,1==subpage);
    6c2e:	40 91 25 07 	lds	r20, 0x0725
    6c32:	01 e0       	ldi	r16, 0x01	; 1
    6c34:	80 91 36 05 	lds	r24, 0x0536
    6c38:	81 30       	cpi	r24, 0x01	; 1
    6c3a:	09 f0       	breq	.+2      	; 0x6c3e <_hMiscSettings+0xb2>
    6c3c:	00 e0       	ldi	r16, 0x00	; 0
    6c3e:	81 e0       	ldi	r24, 0x01	; 1
    6c40:	64 e5       	ldi	r22, 0x54	; 84
    6c42:	50 e0       	ldi	r21, 0x00	; 0
    6c44:	23 e0       	ldi	r18, 0x03	; 3
    6c46:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <LCD_WriteValue>
	LCD_WriteValue(2,84,Config.ThrottleMin,3,2==subpage);
    6c4a:	40 91 dc 06 	lds	r20, 0x06DC
    6c4e:	01 e0       	ldi	r16, 0x01	; 1
    6c50:	80 91 36 05 	lds	r24, 0x0536
    6c54:	82 30       	cpi	r24, 0x02	; 2
    6c56:	09 f0       	breq	.+2      	; 0x6c5a <_hMiscSettings+0xce>
    6c58:	00 e0       	ldi	r16, 0x00	; 0
    6c5a:	82 e0       	ldi	r24, 0x02	; 2
    6c5c:	64 e5       	ldi	r22, 0x54	; 84
    6c5e:	50 e0       	ldi	r21, 0x00	; 0
    6c60:	23 e0       	ldi	r18, 0x03	; 3
    6c62:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <LCD_WriteValue>
	LCD_WriteValue(3,84,Config.StickScaling,3,3==subpage);
    6c66:	40 91 dd 06 	lds	r20, 0x06DD
    6c6a:	01 e0       	ldi	r16, 0x01	; 1
    6c6c:	80 91 36 05 	lds	r24, 0x0536
    6c70:	83 30       	cpi	r24, 0x03	; 3
    6c72:	09 f0       	breq	.+2      	; 0x6c76 <_hMiscSettings+0xea>
    6c74:	00 e0       	ldi	r16, 0x00	; 0
    6c76:	83 e0       	ldi	r24, 0x03	; 3
    6c78:	64 e5       	ldi	r22, 0x54	; 84
    6c7a:	50 e0       	ldi	r21, 0x00	; 0
    6c7c:	23 e0       	ldi	r18, 0x03	; 3
    6c7e:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <LCD_WriteValue>
		
}
    6c82:	0f 91       	pop	r16
    6c84:	08 95       	ret

00006c86 <_hModeSettings>:
	
}

bool bNeedRestart=false;
void _hModeSettings ()
{
    6c86:	cf 92       	push	r12
    6c88:	ef 92       	push	r14
    6c8a:	ff 92       	push	r15
    6c8c:	0f 93       	push	r16
    6c8e:	1f 93       	push	r17
	NOKEYRETURN;
    6c90:	80 91 bc 05 	lds	r24, 0x05BC
    6c94:	88 23       	and	r24, r24
    6c96:	09 f4       	brne	.+2      	; 0x6c9a <_hModeSettings+0x14>
    6c98:	db c0       	rjmp	.+438    	; 0x6e50 <_hModeSettings+0x1ca>
	PageKey(5);
    6c9a:	85 e0       	ldi	r24, 0x05	; 5
    6c9c:	0e 94 11 31 	call	0x6222	; 0x6222 <PageKey>
	
	if ((KEY1) && (bValueChanged==true))
    6ca0:	80 91 bc 05 	lds	r24, 0x05BC
    6ca4:	87 ff       	sbrs	r24, 7
    6ca6:	0f c0       	rjmp	.+30     	; 0x6cc6 <_hModeSettings+0x40>
    6ca8:	90 91 32 05 	lds	r25, 0x0532
    6cac:	91 30       	cpi	r25, 0x01	; 1
    6cae:	59 f4       	brne	.+22     	; 0x6cc6 <_hModeSettings+0x40>
	{
		_helper_SaveinEEPROM_ifChanged();
    6cb0:	0e 94 bb 2c 	call	0x5976	; 0x5976 <_helper_SaveinEEPROM_ifChanged>
		if (bNeedRestart==true) Menu_LoadPage(PAGE_RESTART);
    6cb4:	80 91 33 05 	lds	r24, 0x0533
    6cb8:	88 23       	and	r24, r24
    6cba:	09 f4       	brne	.+2      	; 0x6cbe <_hModeSettings+0x38>
    6cbc:	c9 c0       	rjmp	.+402    	; 0x6e50 <_hModeSettings+0x1ca>
    6cbe:	84 e0       	ldi	r24, 0x04	; 4
    6cc0:	0e 94 de 2e 	call	0x5dbc	; 0x5dbc <Menu_LoadPage>
    6cc4:	c5 c0       	rjmp	.+394    	; 0x6e50 <_hModeSettings+0x1ca>
		return;
	}
	
	if (KEY4)
    6cc6:	84 ff       	sbrs	r24, 4
    6cc8:	3d c0       	rjmp	.+122    	; 0x6d44 <_hModeSettings+0xbe>
	{
		bValueChanged = true;
    6cca:	91 e0       	ldi	r25, 0x01	; 1
    6ccc:	90 93 32 05 	sts	0x0532, r25
		//currentPage.softkeys = _skMENUSAVE;
		switch (subpage)
    6cd0:	80 91 36 05 	lds	r24, 0x0536
    6cd4:	82 30       	cpi	r24, 0x02	; 2
    6cd6:	f9 f0       	breq	.+62     	; 0x6d16 <_hModeSettings+0x90>
    6cd8:	83 30       	cpi	r24, 0x03	; 3
    6cda:	28 f4       	brcc	.+10     	; 0x6ce6 <_hModeSettings+0x60>
    6cdc:	88 23       	and	r24, r24
    6cde:	41 f0       	breq	.+16     	; 0x6cf0 <_hModeSettings+0x6a>
    6ce0:	81 30       	cpi	r24, 0x01	; 1
    6ce2:	81 f5       	brne	.+96     	; 0x6d44 <_hModeSettings+0xbe>
    6ce4:	10 c0       	rjmp	.+32     	; 0x6d06 <_hModeSettings+0x80>
    6ce6:	83 30       	cpi	r24, 0x03	; 3
    6ce8:	f1 f0       	breq	.+60     	; 0x6d26 <_hModeSettings+0xa0>
    6cea:	84 30       	cpi	r24, 0x04	; 4
    6cec:	59 f5       	brne	.+86     	; 0x6d44 <_hModeSettings+0xbe>
    6cee:	23 c0       	rjmp	.+70     	; 0x6d36 <_hModeSettings+0xb0>
		{
			case 0: if (Config.FrameType==FRAMETYPE_QUADCOPTER) Config.FrameType=FRAMETYPE_TRICOPTER; else Config.FrameType=FRAMETYPE_QUADCOPTER; break;
    6cf0:	80 91 d8 06 	lds	r24, 0x06D8
    6cf4:	81 30       	cpi	r24, 0x01	; 1
    6cf6:	21 f4       	brne	.+8      	; 0x6d00 <_hModeSettings+0x7a>
    6cf8:	82 e0       	ldi	r24, 0x02	; 2
    6cfa:	80 93 d8 06 	sts	0x06D8, r24
    6cfe:	22 c0       	rjmp	.+68     	; 0x6d44 <_hModeSettings+0xbe>
    6d00:	90 93 d8 06 	sts	0x06D8, r25
    6d04:	1f c0       	rjmp	.+62     	; 0x6d44 <_hModeSettings+0xbe>
			case 1: Config.RX_mode=~Config.RX_mode; bNeedRestart = true; break;
    6d06:	90 91 d3 06 	lds	r25, 0x06D3
    6d0a:	90 95       	com	r25
    6d0c:	90 93 d3 06 	sts	0x06D3, r25
    6d10:	80 93 33 05 	sts	0x0533, r24
    6d14:	17 c0       	rjmp	.+46     	; 0x6d44 <_hModeSettings+0xbe>
			case 2: Config.BoardOrientationMode=((~Config.BoardOrientationMode) & 0x01); /* value either 0 or 1*/break;
    6d16:	90 91 d9 06 	lds	r25, 0x06D9
    6d1a:	81 e0       	ldi	r24, 0x01	; 1
    6d1c:	90 fd       	sbrc	r25, 0
    6d1e:	80 e0       	ldi	r24, 0x00	; 0
    6d20:	80 93 d9 06 	sts	0x06D9, r24
    6d24:	0f c0       	rjmp	.+30     	; 0x6d44 <_hModeSettings+0xbe>
			case 3: Config.QuadFlyingMode = ((~Config.QuadFlyingMode) & 0x01); /* value either 0 or 1*/break;
    6d26:	90 91 da 06 	lds	r25, 0x06DA
    6d2a:	81 e0       	ldi	r24, 0x01	; 1
    6d2c:	90 fd       	sbrc	r25, 0
    6d2e:	80 e0       	ldi	r24, 0x00	; 0
    6d30:	80 93 da 06 	sts	0x06DA, r24
    6d34:	07 c0       	rjmp	.+14     	; 0x6d44 <_hModeSettings+0xbe>
			case 4: Config.MiscSensors =  ((~Config.MiscSensors) & 0x01); break; // this condition should be rewritten if another sensor is added.
    6d36:	90 91 de 06 	lds	r25, 0x06DE
    6d3a:	81 e0       	ldi	r24, 0x01	; 1
    6d3c:	90 fd       	sbrc	r25, 0
    6d3e:	80 e0       	ldi	r24, 0x00	; 0
    6d40:	80 93 de 06 	sts	0x06DE, r24
		}
	}
	
	_helper_Words  (0,84,(subpage==0),(Config.FrameType== FRAMETYPE_QUADCOPTER),PSTR("Quad"),PSTR("TRI "),5);
    6d44:	41 e0       	ldi	r20, 0x01	; 1
    6d46:	80 91 36 05 	lds	r24, 0x0536
    6d4a:	81 11       	cpse	r24, r1
    6d4c:	40 e0       	ldi	r20, 0x00	; 0
    6d4e:	21 e0       	ldi	r18, 0x01	; 1
    6d50:	80 91 d8 06 	lds	r24, 0x06D8
    6d54:	81 30       	cpi	r24, 0x01	; 1
    6d56:	09 f0       	breq	.+2      	; 0x6d5a <_hModeSettings+0xd4>
    6d58:	20 e0       	ldi	r18, 0x00	; 0
    6d5a:	80 e0       	ldi	r24, 0x00	; 0
    6d5c:	64 e5       	ldi	r22, 0x54	; 84
    6d5e:	09 ed       	ldi	r16, 0xD9	; 217
    6d60:	1c e0       	ldi	r17, 0x0C	; 12
    6d62:	e4 ed       	ldi	r30, 0xD4	; 212
    6d64:	ee 2e       	mov	r14, r30
    6d66:	ec e0       	ldi	r30, 0x0C	; 12
    6d68:	fe 2e       	mov	r15, r30
    6d6a:	75 e0       	ldi	r23, 0x05	; 5
    6d6c:	c7 2e       	mov	r12, r23
    6d6e:	0e 94 c8 2e 	call	0x5d90	; 0x5d90 <_helper_Words>
	_helper_Words  (1,84,(subpage==1),(Config.RX_mode== RX_mode_BuddyMode),PSTR("Buddy"),PSTR("UART "),5);
    6d72:	41 e0       	ldi	r20, 0x01	; 1
    6d74:	80 91 36 05 	lds	r24, 0x0536
    6d78:	81 30       	cpi	r24, 0x01	; 1
    6d7a:	09 f0       	breq	.+2      	; 0x6d7e <_hModeSettings+0xf8>
    6d7c:	40 e0       	ldi	r20, 0x00	; 0
    6d7e:	21 e0       	ldi	r18, 0x01	; 1
    6d80:	80 91 d3 06 	lds	r24, 0x06D3
    6d84:	81 11       	cpse	r24, r1
    6d86:	20 e0       	ldi	r18, 0x00	; 0
    6d88:	81 e0       	ldi	r24, 0x01	; 1
    6d8a:	64 e5       	ldi	r22, 0x54	; 84
    6d8c:	0e ec       	ldi	r16, 0xCE	; 206
    6d8e:	1c e0       	ldi	r17, 0x0C	; 12
    6d90:	58 ec       	ldi	r21, 0xC8	; 200
    6d92:	e5 2e       	mov	r14, r21
    6d94:	5c e0       	ldi	r21, 0x0C	; 12
    6d96:	f5 2e       	mov	r15, r21
    6d98:	35 e0       	ldi	r19, 0x05	; 5
    6d9a:	c3 2e       	mov	r12, r19
    6d9c:	0e 94 c8 2e 	call	0x5d90	; 0x5d90 <_helper_Words>
	_helper_Words (2,84,(subpage==2),(Config.BoardOrientationMode == QuadFlyingMode_PLUS),PSTR("+ Quad"),PSTR("X Quad"),6);
    6da0:	41 e0       	ldi	r20, 0x01	; 1
    6da2:	80 91 36 05 	lds	r24, 0x0536
    6da6:	82 30       	cpi	r24, 0x02	; 2
    6da8:	09 f0       	breq	.+2      	; 0x6dac <_hModeSettings+0x126>
    6daa:	40 e0       	ldi	r20, 0x00	; 0
    6dac:	21 e0       	ldi	r18, 0x01	; 1
    6dae:	80 91 d9 06 	lds	r24, 0x06D9
    6db2:	81 11       	cpse	r24, r1
    6db4:	20 e0       	ldi	r18, 0x00	; 0
    6db6:	82 e0       	ldi	r24, 0x02	; 2
    6db8:	64 e5       	ldi	r22, 0x54	; 84
    6dba:	01 ec       	ldi	r16, 0xC1	; 193
    6dbc:	1c e0       	ldi	r17, 0x0C	; 12
    6dbe:	9a eb       	ldi	r25, 0xBA	; 186
    6dc0:	e9 2e       	mov	r14, r25
    6dc2:	9c e0       	ldi	r25, 0x0C	; 12
    6dc4:	f9 2e       	mov	r15, r25
    6dc6:	b6 e0       	ldi	r27, 0x06	; 6
    6dc8:	cb 2e       	mov	r12, r27
    6dca:	0e 94 c8 2e 	call	0x5d90	; 0x5d90 <_helper_Words>
	if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    6dce:	90 91 d8 06 	lds	r25, 0x06D8
    6dd2:	80 91 36 05 	lds	r24, 0x0536
    6dd6:	91 30       	cpi	r25, 0x01	; 1
    6dd8:	91 f4       	brne	.+36     	; 0x6dfe <_hModeSettings+0x178>
	{
		_helper_Words (3,84,(subpage==3),(Config.QuadFlyingMode == QuadFlyingMode_PLUS),PSTR("+ Quad"),PSTR("X Quad"),6);
    6dda:	41 e0       	ldi	r20, 0x01	; 1
    6ddc:	83 30       	cpi	r24, 0x03	; 3
    6dde:	09 f0       	breq	.+2      	; 0x6de2 <_hModeSettings+0x15c>
    6de0:	40 e0       	ldi	r20, 0x00	; 0
    6de2:	21 e0       	ldi	r18, 0x01	; 1
    6de4:	80 91 da 06 	lds	r24, 0x06DA
    6de8:	81 11       	cpse	r24, r1
    6dea:	20 e0       	ldi	r18, 0x00	; 0
    6dec:	83 e0       	ldi	r24, 0x03	; 3
    6dee:	64 e5       	ldi	r22, 0x54	; 84
    6df0:	03 eb       	ldi	r16, 0xB3	; 179
    6df2:	1c e0       	ldi	r17, 0x0C	; 12
    6df4:	ac ea       	ldi	r26, 0xAC	; 172
    6df6:	ea 2e       	mov	r14, r26
    6df8:	ac e0       	ldi	r26, 0x0C	; 12
    6dfa:	fa 2e       	mov	r15, r26
    6dfc:	11 c0       	rjmp	.+34     	; 0x6e20 <_hModeSettings+0x19a>
	}
	else
	{
		_helper_Words (3,84,(subpage==3),(Config.QuadFlyingMode == QuadFlyingMode_PLUS),PSTR("Y Tri "),PSTR("A Tri "),6);
    6dfe:	41 e0       	ldi	r20, 0x01	; 1
    6e00:	83 30       	cpi	r24, 0x03	; 3
    6e02:	09 f0       	breq	.+2      	; 0x6e06 <_hModeSettings+0x180>
    6e04:	40 e0       	ldi	r20, 0x00	; 0
    6e06:	21 e0       	ldi	r18, 0x01	; 1
    6e08:	80 91 da 06 	lds	r24, 0x06DA
    6e0c:	81 11       	cpse	r24, r1
    6e0e:	20 e0       	ldi	r18, 0x00	; 0
    6e10:	83 e0       	ldi	r24, 0x03	; 3
    6e12:	64 e5       	ldi	r22, 0x54	; 84
    6e14:	05 ea       	ldi	r16, 0xA5	; 165
    6e16:	1c e0       	ldi	r17, 0x0C	; 12
    6e18:	fe e9       	ldi	r31, 0x9E	; 158
    6e1a:	ef 2e       	mov	r14, r31
    6e1c:	fc e0       	ldi	r31, 0x0C	; 12
    6e1e:	ff 2e       	mov	r15, r31
    6e20:	e6 e0       	ldi	r30, 0x06	; 6
    6e22:	ce 2e       	mov	r12, r30
    6e24:	0e 94 c8 2e 	call	0x5d90	; 0x5d90 <_helper_Words>
	}	
	_helper_DisplayBiStateText(4,84, strYes, strNo, (IS_MISC_SENSOR_SONAR_ENABLED ==true),(subpage==4));
    6e28:	00 91 de 06 	lds	r16, 0x06DE
    6e2c:	10 e0       	ldi	r17, 0x00	; 0
    6e2e:	01 70       	andi	r16, 0x01	; 1
    6e30:	10 70       	andi	r17, 0x00	; 0
    6e32:	91 e0       	ldi	r25, 0x01	; 1
    6e34:	80 91 36 05 	lds	r24, 0x0536
    6e38:	84 30       	cpi	r24, 0x04	; 4
    6e3a:	09 f0       	breq	.+2      	; 0x6e3e <_hModeSettings+0x1b8>
    6e3c:	90 e0       	ldi	r25, 0x00	; 0
    6e3e:	84 e0       	ldi	r24, 0x04	; 4
    6e40:	64 e5       	ldi	r22, 0x54	; 84
    6e42:	46 e9       	ldi	r20, 0x96	; 150
    6e44:	5c e0       	ldi	r21, 0x0C	; 12
    6e46:	2a e9       	ldi	r18, 0x9A	; 154
    6e48:	3c e0       	ldi	r19, 0x0C	; 12
    6e4a:	e9 2e       	mov	r14, r25
    6e4c:	0e 94 8f 2c 	call	0x591e	; 0x591e <_helper_DisplayBiStateText>
}
    6e50:	1f 91       	pop	r17
    6e52:	0f 91       	pop	r16
    6e54:	ff 90       	pop	r15
    6e56:	ef 90       	pop	r14
    6e58:	cf 90       	pop	r12
    6e5a:	08 95       	ret

00006e5c <doMenu>:

/*
//	Draw the menu
*/
uint8_t doMenu(menu_t *menu)
{
    6e5c:	ef 92       	push	r14
    6e5e:	ff 92       	push	r15
    6e60:	0f 93       	push	r16
    6e62:	1f 93       	push	r17
    6e64:	cf 93       	push	r28
    6e66:	df 93       	push	r29
    6e68:	ec 01       	movw	r28, r24
	UIEnableStickCommands=true;
    6e6a:	81 e0       	ldi	r24, 0x01	; 1
    6e6c:	80 93 e7 05 	sts	0x05E7, r24
	
	if (!_mykey) return 0;
    6e70:	80 91 bc 05 	lds	r24, 0x05BC
    6e74:	88 23       	and	r24, r24
    6e76:	09 f4       	brne	.+2      	; 0x6e7a <doMenu+0x1e>
    6e78:	70 c0       	rjmp	.+224    	; 0x6f5a <doMenu+0xfe>
	
	// key handling
	if (KEY2)		// UP
    6e7a:	86 ff       	sbrs	r24, 6
    6e7c:	06 c0       	rjmp	.+12     	; 0x6e8a <doMenu+0x2e>
	{
		if (menu->marked > 0) 
    6e7e:	8c 81       	ldd	r24, Y+4	; 0x04
    6e80:	88 23       	and	r24, r24
    6e82:	99 f0       	breq	.+38     	; 0x6eaa <doMenu+0x4e>
			menu->marked--;
    6e84:	81 50       	subi	r24, 0x01	; 1
    6e86:	8c 83       	std	Y+4, r24	; 0x04
    6e88:	10 c0       	rjmp	.+32     	; 0x6eaa <doMenu+0x4e>
	}
	else if (KEY3)		// DOWN
    6e8a:	85 ff       	sbrs	r24, 5
    6e8c:	0c c0       	rjmp	.+24     	; 0x6ea6 <doMenu+0x4a>
	{
		if (menu->marked < menu->len - 1) 
    6e8e:	4c 81       	ldd	r20, Y+4	; 0x04
    6e90:	24 2f       	mov	r18, r20
    6e92:	30 e0       	ldi	r19, 0x00	; 0
    6e94:	88 81       	ld	r24, Y
    6e96:	90 e0       	ldi	r25, 0x00	; 0
    6e98:	01 97       	sbiw	r24, 0x01	; 1
    6e9a:	28 17       	cp	r18, r24
    6e9c:	39 07       	cpc	r19, r25
    6e9e:	2c f4       	brge	.+10     	; 0x6eaa <doMenu+0x4e>
			menu->marked++;
    6ea0:	4f 5f       	subi	r20, 0xFF	; 255
    6ea2:	4c 83       	std	Y+4, r20	; 0x04
    6ea4:	02 c0       	rjmp	.+4      	; 0x6eaa <doMenu+0x4e>
	}
	else if (KEY4)		// ENTER
    6ea6:	84 fd       	sbrc	r24, 4
    6ea8:	56 c0       	rjmp	.+172    	; 0x6f56 <doMenu+0xfa>
		return 1;

	if (menu->marked < menu->top)
    6eaa:	2c 81       	ldd	r18, Y+4	; 0x04
    6eac:	3b 81       	ldd	r19, Y+3	; 0x03
    6eae:	23 17       	cp	r18, r19
    6eb0:	40 f0       	brcs	.+16     	; 0x6ec2 <doMenu+0x66>
		menu->top = menu->marked;
	else if (menu->marked - menu->top >= 5)
    6eb2:	82 2f       	mov	r24, r18
    6eb4:	90 e0       	ldi	r25, 0x00	; 0
    6eb6:	83 1b       	sub	r24, r19
    6eb8:	91 09       	sbc	r25, r1
    6eba:	85 30       	cpi	r24, 0x05	; 5
    6ebc:	91 05       	cpc	r25, r1
    6ebe:	14 f0       	brlt	.+4      	; 0x6ec4 <doMenu+0x68>
		menu->top = menu->marked - 4;
    6ec0:	24 50       	subi	r18, 0x04	; 4
    6ec2:	2b 83       	std	Y+3, r18	; 0x03
	
	// text output
	LCD_SetPos(0, 58);
    6ec4:	80 e0       	ldi	r24, 0x00	; 0
    6ec6:	6a e3       	ldi	r22, 0x3A	; 58
    6ec8:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <LCD_SetPos>
	if (menu->top > 0)
    6ecc:	8b 81       	ldd	r24, Y+3	; 0x03
    6ece:	88 23       	and	r24, r24
    6ed0:	29 f0       	breq	.+10     	; 0x6edc <doMenu+0x80>
		lcdWriteGlyph_P(&glyArrowUp, 0);
    6ed2:	8c e7       	ldi	r24, 0x7C	; 124
    6ed4:	99 e0       	ldi	r25, 0x09	; 9
    6ed6:	60 e0       	ldi	r22, 0x00	; 0
    6ed8:	0e 94 a7 0c 	call	0x194e	; 0x194e <lcdWriteGlyph_P>

/*
//	Draw the menu
*/
uint8_t doMenu(menu_t *menu)
{
    6edc:	00 e0       	ldi	r16, 0x00	; 0
    6ede:	10 e0       	ldi	r17, 0x00	; 0
    6ee0:	21 c0       	rjmp	.+66     	; 0x6f24 <doMenu+0xc8>
	if (menu->top > 0)
		lcdWriteGlyph_P(&glyArrowUp, 0);
		
	for (uint8_t i = 0; i < 5 && i < menu->len; i++)
	{
		LCD_SetPos(i + 1, 0);
    6ee2:	8e 2d       	mov	r24, r14
    6ee4:	8f 5f       	subi	r24, 0xFF	; 255
    6ee6:	60 e0       	ldi	r22, 0x00	; 0
    6ee8:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <LCD_SetPos>
		PGM_P item = menu->textSelector(menu->top + i);
    6eec:	8b 81       	ldd	r24, Y+3	; 0x03
    6eee:	e9 81       	ldd	r30, Y+1	; 0x01
    6ef0:	fa 81       	ldd	r31, Y+2	; 0x02
    6ef2:	8e 0d       	add	r24, r14
    6ef4:	09 95       	icall
    6ef6:	7c 01       	movw	r14, r24
		lcdReverse(menu->top + i == menu->marked);
    6ef8:	8b 81       	ldd	r24, Y+3	; 0x03
    6efa:	a8 01       	movw	r20, r16
    6efc:	48 0f       	add	r20, r24
    6efe:	51 1d       	adc	r21, r1
    6f00:	2c 81       	ldd	r18, Y+4	; 0x04
    6f02:	30 e0       	ldi	r19, 0x00	; 0
    6f04:	81 e0       	ldi	r24, 0x01	; 1
    6f06:	42 17       	cp	r20, r18
    6f08:	53 07       	cpc	r21, r19
    6f0a:	09 f0       	breq	.+2      	; 0x6f0e <doMenu+0xb2>
    6f0c:	80 e0       	ldi	r24, 0x00	; 0
    6f0e:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <lcdReverse>
		LCD_WritePadded_P(item, 21);
    6f12:	c7 01       	movw	r24, r14
    6f14:	65 e1       	ldi	r22, 0x15	; 21
    6f16:	0e 94 53 0d 	call	0x1aa6	; 0x1aa6 <LCD_WritePadded_P>
    6f1a:	0f 5f       	subi	r16, 0xFF	; 255
    6f1c:	1f 4f       	sbci	r17, 0xFF	; 255
	// text output
	LCD_SetPos(0, 58);
	if (menu->top > 0)
		lcdWriteGlyph_P(&glyArrowUp, 0);
		
	for (uint8_t i = 0; i < 5 && i < menu->len; i++)
    6f1e:	05 30       	cpi	r16, 0x05	; 5
    6f20:	11 05       	cpc	r17, r1
    6f22:	21 f0       	breq	.+8      	; 0x6f2c <doMenu+0xd0>
    6f24:	e0 2e       	mov	r14, r16
    6f26:	88 81       	ld	r24, Y
    6f28:	08 17       	cp	r16, r24
    6f2a:	d8 f2       	brcs	.-74     	; 0x6ee2 <doMenu+0x86>
		PGM_P item = menu->textSelector(menu->top + i);
		lcdReverse(menu->top + i == menu->marked);
		LCD_WritePadded_P(item, 21);
	}

	lcdReverse(0);
    6f2c:	80 e0       	ldi	r24, 0x00	; 0
    6f2e:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <lcdReverse>


	LCD_SetPos(6, 58);
    6f32:	86 e0       	ldi	r24, 0x06	; 6
    6f34:	6a e3       	ldi	r22, 0x3A	; 58
    6f36:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <LCD_SetPos>
	if (menu->top < menu->len - 5)
    6f3a:	2b 81       	ldd	r18, Y+3	; 0x03
    6f3c:	30 e0       	ldi	r19, 0x00	; 0
    6f3e:	88 81       	ld	r24, Y
    6f40:	90 e0       	ldi	r25, 0x00	; 0
    6f42:	05 97       	sbiw	r24, 0x05	; 5
    6f44:	28 17       	cp	r18, r24
    6f46:	39 07       	cpc	r19, r25
    6f48:	44 f4       	brge	.+16     	; 0x6f5a <doMenu+0xfe>
		lcdWriteGlyph_P(&glyArrowDown, 0);
    6f4a:	86 e8       	ldi	r24, 0x86	; 134
    6f4c:	99 e0       	ldi	r25, 0x09	; 9
    6f4e:	60 e0       	ldi	r22, 0x00	; 0
    6f50:	0e 94 a7 0c 	call	0x194e	; 0x194e <lcdWriteGlyph_P>
    6f54:	02 c0       	rjmp	.+4      	; 0x6f5a <doMenu+0xfe>
	{
		if (menu->marked < menu->len - 1) 
			menu->marked++;
	}
	else if (KEY4)		// ENTER
		return 1;
    6f56:	81 e0       	ldi	r24, 0x01	; 1
    6f58:	01 c0       	rjmp	.+2      	; 0x6f5c <doMenu+0x100>

	LCD_SetPos(6, 58);
	if (menu->top < menu->len - 5)
		lcdWriteGlyph_P(&glyArrowDown, 0);
	
	return 0;
    6f5a:	80 e0       	ldi	r24, 0x00	; 0
}
    6f5c:	df 91       	pop	r29
    6f5e:	cf 91       	pop	r28
    6f60:	1f 91       	pop	r17
    6f62:	0f 91       	pop	r16
    6f64:	ff 90       	pop	r15
    6f66:	ef 90       	pop	r14
    6f68:	08 95       	ret

00006f6a <_hMenu>:


void _hMenu()
{
	if (doMenu(&mnuMain))
    6f6a:	8e e0       	ldi	r24, 0x0E	; 14
    6f6c:	91 e0       	ldi	r25, 0x01	; 1
    6f6e:	0e 94 2e 37 	call	0x6e5c	; 0x6e5c <doMenu>
    6f72:	88 23       	and	r24, r24
    6f74:	91 f0       	breq	.+36     	; 0x6f9a <_hMenu+0x30>
	{	// if menu item selected then open it if...
		if (menuEnabled[mnuMain.marked + MENU_START_INDEX]==1)
    6f76:	80 91 12 01 	lds	r24, 0x0112
    6f7a:	e8 2f       	mov	r30, r24
    6f7c:	f0 e0       	ldi	r31, 0x00	; 0
    6f7e:	e1 56       	subi	r30, 0x61	; 97
    6f80:	f8 4f       	sbci	r31, 0xF8	; 248
    6f82:	95 81       	ldd	r25, Z+5	; 0x05
    6f84:	91 30       	cpi	r25, 0x01	; 1
    6f86:	21 f4       	brne	.+8      	; 0x6f90 <_hMenu+0x26>
		{ //... the menu item is enabled 
			Menu_LoadPage(mnuMain.marked + MENU_START_INDEX);
    6f88:	8b 5f       	subi	r24, 0xFB	; 251
    6f8a:	0e 94 de 2e 	call	0x5dbc	; 0x5dbc <Menu_LoadPage>
    6f8e:	08 95       	ret
		}
		else
		{ //... else flash light and ignore command
			LED_FlashOrangeLED(LED_SHORT_TOGGLE,2);
    6f90:	8e e1       	ldi	r24, 0x1E	; 30
    6f92:	90 e0       	ldi	r25, 0x00	; 0
    6f94:	62 e0       	ldi	r22, 0x02	; 2
    6f96:	0e 94 75 0e 	call	0x1cea	; 0x1cea <LED_FlashOrangeLED>
    6f9a:	08 95       	ret

00006f9c <Menu_MenuShow>:

void Menu_MenuShow()
{
	
	
	_mykey = Keyboard_Read();
    6f9c:	0e 94 97 0b 	call	0x172e	; 0x172e <Keyboard_Read>
	_mykey = _mykey | _TXKeys;
    6fa0:	90 91 c4 06 	lds	r25, 0x06C4
    6fa4:	98 2b       	or	r25, r24
    6fa6:	90 93 bc 05 	sts	0x05BC, r25

	
	LCD_Disable();
    6faa:	0e 94 1c 0e 	call	0x1c38	; 0x1c38 <LCD_Disable>
	if (oldPage != page)
    6fae:	90 91 35 05 	lds	r25, 0x0535
    6fb2:	80 91 34 05 	lds	r24, 0x0534
    6fb6:	89 17       	cp	r24, r25
    6fb8:	59 f0       	breq	.+22     	; 0x6fd0 <Menu_MenuShow+0x34>
	{	// if this is a new page then KEY_INIT = true
		_mykey |= KEY_INIT;
    6fba:	80 91 bc 05 	lds	r24, 0x05BC
    6fbe:	81 60       	ori	r24, 0x01	; 1
    6fc0:	80 93 bc 05 	sts	0x05BC, r24
		subpage = 0;
    6fc4:	10 92 36 05 	sts	0x0536, r1
		subindex = 0;
    6fc8:	10 92 37 05 	sts	0x0537, r1
		oldPage = page;
    6fcc:	90 93 34 05 	sts	0x0534, r25
	}
	defaultHandler();
    6fd0:	0e 94 1a 30 	call	0x6034	; 0x6034 <defaultHandler>
	LCD_Enable();
    6fd4:	0e 94 13 0e 	call	0x1c26	; 0x1c26 <LCD_Enable>

	
	
	if (KEY1 && !editMode)	// BACK
    6fd8:	80 91 bc 05 	lds	r24, 0x05BC
    6fdc:	87 ff       	sbrs	r24, 7
    6fde:	15 c0       	rjmp	.+42     	; 0x700a <Menu_MenuShow+0x6e>
    6fe0:	80 91 b5 07 	lds	r24, 0x07B5
    6fe4:	88 23       	and	r24, r24
    6fe6:	89 f4       	brne	.+34     	; 0x700a <Menu_MenuShow+0x6e>
	{
		if (page > PAGE_MENU) // if any page then go to main menu
    6fe8:	80 91 35 05 	lds	r24, 0x0535
    6fec:	82 30       	cpi	r24, 0x02	; 2
    6fee:	10 f0       	brcs	.+4      	; 0x6ff4 <Menu_MenuShow+0x58>
			Menu_LoadPage(PAGE_MENU);
    6ff0:	81 e0       	ldi	r24, 0x01	; 1
    6ff2:	09 c0       	rjmp	.+18     	; 0x7006 <Menu_MenuShow+0x6a>
		else if (page == PAGE_MENU)  // if menu page then goto HomePage
    6ff4:	81 30       	cpi	r24, 0x01	; 1
    6ff6:	49 f4       	brne	.+18     	; 0x700a <Menu_MenuShow+0x6e>
			{
				if (IsArmed == true)
    6ff8:	80 91 85 07 	lds	r24, 0x0785
    6ffc:	81 30       	cpi	r24, 0x01	; 1
    6ffe:	11 f4       	brne	.+4      	; 0x7004 <Menu_MenuShow+0x68>
				{
					Menu_LoadPage(PAGE_HOME_ARMED);
    7000:	82 e0       	ldi	r24, 0x02	; 2
    7002:	01 c0       	rjmp	.+2      	; 0x7006 <Menu_MenuShow+0x6a>
				}
				else
				{
					Menu_LoadPage(PAGE_HOME);
    7004:	80 e0       	ldi	r24, 0x00	; 0
    7006:	0e 94 de 2e 	call	0x5dbc	; 0x5dbc <Menu_LoadPage>
				}
			}							
	}
	
	
	if (KEYPRESS)
    700a:	80 91 bc 05 	lds	r24, 0x05BC
    700e:	80 7f       	andi	r24, 0xF0	; 240
    7010:	29 f0       	breq	.+10     	; 0x701c <Menu_MenuShow+0x80>
		Beeper_Beep(BEEP_KEY,1);
    7012:	86 e4       	ldi	r24, 0x46	; 70
    7014:	90 e0       	ldi	r25, 0x00	; 0
    7016:	61 e0       	ldi	r22, 0x01	; 1
    7018:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <Beeper_Beep>
		
	_TXKeys = 0; // No Key Pressed
    701c:	10 92 c4 06 	sts	0x06C4, r1
}
    7020:	08 95       	ret

00007022 <Menu_MenuInit>:

void Menu_MenuInit()
{
	oldPage=0xff;
    7022:	8f ef       	ldi	r24, 0xFF	; 255
    7024:	80 93 34 05 	sts	0x0534, r24
	Menu_LoadPage(PAGE_HOME);
    7028:	80 e0       	ldi	r24, 0x00	; 0
    702a:	0e 94 de 2e 	call	0x5dbc	; 0x5dbc <Menu_LoadPage>
}
    702e:	08 95       	ret

00007030 <tsmLoadModelLayout>:
}

PGM_P tsmLoadModelLayout(uint8_t index)
{
	//return (PGM_P)pgm_read_word(&mixerTable[index].Name);
}
    7030:	08 95       	ret

00007032 <Menu_EnableAllItems>:


void Menu_EnableAllItems ()
{
    7032:	ef e9       	ldi	r30, 0x9F	; 159
    7034:	f7 e0       	ldi	r31, 0x07	; 7
	
	for (int i=0;i <MENU_ITEMS_COUNT;++i)
	{
		
		menuEnabled[i]=1;
    7036:	81 e0       	ldi	r24, 0x01	; 1
    7038:	81 93       	st	Z+, r24


void Menu_EnableAllItems ()
{
	
	for (int i=0;i <MENU_ITEMS_COUNT;++i)
    703a:	97 e0       	ldi	r25, 0x07	; 7
    703c:	e0 3b       	cpi	r30, 0xB0	; 176
    703e:	f9 07       	cpc	r31, r25
    7040:	d9 f7       	brne	.-10     	; 0x7038 <Menu_EnableAllItems+0x6>
	{
		
		menuEnabled[i]=1;
	}
	menuEnabled[PAGE_DEBUG]=1;
    7042:	80 93 ae 07 	sts	0x07AE, r24
	
    7046:	08 95       	ret

00007048 <__subsf3>:
    7048:	50 58       	subi	r21, 0x80	; 128

0000704a <__addsf3>:
    704a:	bb 27       	eor	r27, r27
    704c:	aa 27       	eor	r26, r26
    704e:	0e d0       	rcall	.+28     	; 0x706c <__addsf3x>
    7050:	75 c1       	rjmp	.+746    	; 0x733c <__fp_round>
    7052:	66 d1       	rcall	.+716    	; 0x7320 <__fp_pscA>
    7054:	30 f0       	brcs	.+12     	; 0x7062 <__addsf3+0x18>
    7056:	6b d1       	rcall	.+726    	; 0x732e <__fp_pscB>
    7058:	20 f0       	brcs	.+8      	; 0x7062 <__addsf3+0x18>
    705a:	31 f4       	brne	.+12     	; 0x7068 <__addsf3+0x1e>
    705c:	9f 3f       	cpi	r25, 0xFF	; 255
    705e:	11 f4       	brne	.+4      	; 0x7064 <__addsf3+0x1a>
    7060:	1e f4       	brtc	.+6      	; 0x7068 <__addsf3+0x1e>
    7062:	5b c1       	rjmp	.+694    	; 0x731a <__fp_nan>
    7064:	0e f4       	brtc	.+2      	; 0x7068 <__addsf3+0x1e>
    7066:	e0 95       	com	r30
    7068:	e7 fb       	bst	r30, 7
    706a:	51 c1       	rjmp	.+674    	; 0x730e <__fp_inf>

0000706c <__addsf3x>:
    706c:	e9 2f       	mov	r30, r25
    706e:	77 d1       	rcall	.+750    	; 0x735e <__fp_split3>
    7070:	80 f3       	brcs	.-32     	; 0x7052 <__addsf3+0x8>
    7072:	ba 17       	cp	r27, r26
    7074:	62 07       	cpc	r22, r18
    7076:	73 07       	cpc	r23, r19
    7078:	84 07       	cpc	r24, r20
    707a:	95 07       	cpc	r25, r21
    707c:	18 f0       	brcs	.+6      	; 0x7084 <__addsf3x+0x18>
    707e:	71 f4       	brne	.+28     	; 0x709c <__addsf3x+0x30>
    7080:	9e f5       	brtc	.+102    	; 0x70e8 <__addsf3x+0x7c>
    7082:	8f c1       	rjmp	.+798    	; 0x73a2 <__fp_zero>
    7084:	0e f4       	brtc	.+2      	; 0x7088 <__addsf3x+0x1c>
    7086:	e0 95       	com	r30
    7088:	0b 2e       	mov	r0, r27
    708a:	ba 2f       	mov	r27, r26
    708c:	a0 2d       	mov	r26, r0
    708e:	0b 01       	movw	r0, r22
    7090:	b9 01       	movw	r22, r18
    7092:	90 01       	movw	r18, r0
    7094:	0c 01       	movw	r0, r24
    7096:	ca 01       	movw	r24, r20
    7098:	a0 01       	movw	r20, r0
    709a:	11 24       	eor	r1, r1
    709c:	ff 27       	eor	r31, r31
    709e:	59 1b       	sub	r21, r25
    70a0:	99 f0       	breq	.+38     	; 0x70c8 <__addsf3x+0x5c>
    70a2:	59 3f       	cpi	r21, 0xF9	; 249
    70a4:	50 f4       	brcc	.+20     	; 0x70ba <__addsf3x+0x4e>
    70a6:	50 3e       	cpi	r21, 0xE0	; 224
    70a8:	68 f1       	brcs	.+90     	; 0x7104 <__addsf3x+0x98>
    70aa:	1a 16       	cp	r1, r26
    70ac:	f0 40       	sbci	r31, 0x00	; 0
    70ae:	a2 2f       	mov	r26, r18
    70b0:	23 2f       	mov	r18, r19
    70b2:	34 2f       	mov	r19, r20
    70b4:	44 27       	eor	r20, r20
    70b6:	58 5f       	subi	r21, 0xF8	; 248
    70b8:	f3 cf       	rjmp	.-26     	; 0x70a0 <__addsf3x+0x34>
    70ba:	46 95       	lsr	r20
    70bc:	37 95       	ror	r19
    70be:	27 95       	ror	r18
    70c0:	a7 95       	ror	r26
    70c2:	f0 40       	sbci	r31, 0x00	; 0
    70c4:	53 95       	inc	r21
    70c6:	c9 f7       	brne	.-14     	; 0x70ba <__addsf3x+0x4e>
    70c8:	7e f4       	brtc	.+30     	; 0x70e8 <__addsf3x+0x7c>
    70ca:	1f 16       	cp	r1, r31
    70cc:	ba 0b       	sbc	r27, r26
    70ce:	62 0b       	sbc	r22, r18
    70d0:	73 0b       	sbc	r23, r19
    70d2:	84 0b       	sbc	r24, r20
    70d4:	ba f0       	brmi	.+46     	; 0x7104 <__addsf3x+0x98>
    70d6:	91 50       	subi	r25, 0x01	; 1
    70d8:	a1 f0       	breq	.+40     	; 0x7102 <__addsf3x+0x96>
    70da:	ff 0f       	add	r31, r31
    70dc:	bb 1f       	adc	r27, r27
    70de:	66 1f       	adc	r22, r22
    70e0:	77 1f       	adc	r23, r23
    70e2:	88 1f       	adc	r24, r24
    70e4:	c2 f7       	brpl	.-16     	; 0x70d6 <__addsf3x+0x6a>
    70e6:	0e c0       	rjmp	.+28     	; 0x7104 <__addsf3x+0x98>
    70e8:	ba 0f       	add	r27, r26
    70ea:	62 1f       	adc	r22, r18
    70ec:	73 1f       	adc	r23, r19
    70ee:	84 1f       	adc	r24, r20
    70f0:	48 f4       	brcc	.+18     	; 0x7104 <__addsf3x+0x98>
    70f2:	87 95       	ror	r24
    70f4:	77 95       	ror	r23
    70f6:	67 95       	ror	r22
    70f8:	b7 95       	ror	r27
    70fa:	f7 95       	ror	r31
    70fc:	9e 3f       	cpi	r25, 0xFE	; 254
    70fe:	08 f0       	brcs	.+2      	; 0x7102 <__addsf3x+0x96>
    7100:	b3 cf       	rjmp	.-154    	; 0x7068 <__addsf3+0x1e>
    7102:	93 95       	inc	r25
    7104:	88 0f       	add	r24, r24
    7106:	08 f0       	brcs	.+2      	; 0x710a <__addsf3x+0x9e>
    7108:	99 27       	eor	r25, r25
    710a:	ee 0f       	add	r30, r30
    710c:	97 95       	ror	r25
    710e:	87 95       	ror	r24
    7110:	08 95       	ret

00007112 <__cmpsf2>:
    7112:	d9 d0       	rcall	.+434    	; 0x72c6 <__fp_cmp>
    7114:	08 f4       	brcc	.+2      	; 0x7118 <__cmpsf2+0x6>
    7116:	81 e0       	ldi	r24, 0x01	; 1
    7118:	08 95       	ret

0000711a <__divsf3>:
    711a:	0c d0       	rcall	.+24     	; 0x7134 <__divsf3x>
    711c:	0f c1       	rjmp	.+542    	; 0x733c <__fp_round>
    711e:	07 d1       	rcall	.+526    	; 0x732e <__fp_pscB>
    7120:	40 f0       	brcs	.+16     	; 0x7132 <__divsf3+0x18>
    7122:	fe d0       	rcall	.+508    	; 0x7320 <__fp_pscA>
    7124:	30 f0       	brcs	.+12     	; 0x7132 <__divsf3+0x18>
    7126:	21 f4       	brne	.+8      	; 0x7130 <__divsf3+0x16>
    7128:	5f 3f       	cpi	r21, 0xFF	; 255
    712a:	19 f0       	breq	.+6      	; 0x7132 <__divsf3+0x18>
    712c:	f0 c0       	rjmp	.+480    	; 0x730e <__fp_inf>
    712e:	51 11       	cpse	r21, r1
    7130:	39 c1       	rjmp	.+626    	; 0x73a4 <__fp_szero>
    7132:	f3 c0       	rjmp	.+486    	; 0x731a <__fp_nan>

00007134 <__divsf3x>:
    7134:	14 d1       	rcall	.+552    	; 0x735e <__fp_split3>
    7136:	98 f3       	brcs	.-26     	; 0x711e <__divsf3+0x4>

00007138 <__divsf3_pse>:
    7138:	99 23       	and	r25, r25
    713a:	c9 f3       	breq	.-14     	; 0x712e <__divsf3+0x14>
    713c:	55 23       	and	r21, r21
    713e:	b1 f3       	breq	.-20     	; 0x712c <__divsf3+0x12>
    7140:	95 1b       	sub	r25, r21
    7142:	55 0b       	sbc	r21, r21
    7144:	bb 27       	eor	r27, r27
    7146:	aa 27       	eor	r26, r26
    7148:	62 17       	cp	r22, r18
    714a:	73 07       	cpc	r23, r19
    714c:	84 07       	cpc	r24, r20
    714e:	38 f0       	brcs	.+14     	; 0x715e <__divsf3_pse+0x26>
    7150:	9f 5f       	subi	r25, 0xFF	; 255
    7152:	5f 4f       	sbci	r21, 0xFF	; 255
    7154:	22 0f       	add	r18, r18
    7156:	33 1f       	adc	r19, r19
    7158:	44 1f       	adc	r20, r20
    715a:	aa 1f       	adc	r26, r26
    715c:	a9 f3       	breq	.-22     	; 0x7148 <__divsf3_pse+0x10>
    715e:	33 d0       	rcall	.+102    	; 0x71c6 <__divsf3_pse+0x8e>
    7160:	0e 2e       	mov	r0, r30
    7162:	3a f0       	brmi	.+14     	; 0x7172 <__divsf3_pse+0x3a>
    7164:	e0 e8       	ldi	r30, 0x80	; 128
    7166:	30 d0       	rcall	.+96     	; 0x71c8 <__divsf3_pse+0x90>
    7168:	91 50       	subi	r25, 0x01	; 1
    716a:	50 40       	sbci	r21, 0x00	; 0
    716c:	e6 95       	lsr	r30
    716e:	00 1c       	adc	r0, r0
    7170:	ca f7       	brpl	.-14     	; 0x7164 <__divsf3_pse+0x2c>
    7172:	29 d0       	rcall	.+82     	; 0x71c6 <__divsf3_pse+0x8e>
    7174:	fe 2f       	mov	r31, r30
    7176:	27 d0       	rcall	.+78     	; 0x71c6 <__divsf3_pse+0x8e>
    7178:	66 0f       	add	r22, r22
    717a:	77 1f       	adc	r23, r23
    717c:	88 1f       	adc	r24, r24
    717e:	bb 1f       	adc	r27, r27
    7180:	26 17       	cp	r18, r22
    7182:	37 07       	cpc	r19, r23
    7184:	48 07       	cpc	r20, r24
    7186:	ab 07       	cpc	r26, r27
    7188:	b0 e8       	ldi	r27, 0x80	; 128
    718a:	09 f0       	breq	.+2      	; 0x718e <__divsf3_pse+0x56>
    718c:	bb 0b       	sbc	r27, r27
    718e:	80 2d       	mov	r24, r0
    7190:	bf 01       	movw	r22, r30
    7192:	ff 27       	eor	r31, r31
    7194:	93 58       	subi	r25, 0x83	; 131
    7196:	5f 4f       	sbci	r21, 0xFF	; 255
    7198:	2a f0       	brmi	.+10     	; 0x71a4 <__divsf3_pse+0x6c>
    719a:	9e 3f       	cpi	r25, 0xFE	; 254
    719c:	51 05       	cpc	r21, r1
    719e:	68 f0       	brcs	.+26     	; 0x71ba <__divsf3_pse+0x82>
    71a0:	b6 c0       	rjmp	.+364    	; 0x730e <__fp_inf>
    71a2:	00 c1       	rjmp	.+512    	; 0x73a4 <__fp_szero>
    71a4:	5f 3f       	cpi	r21, 0xFF	; 255
    71a6:	ec f3       	brlt	.-6      	; 0x71a2 <__divsf3_pse+0x6a>
    71a8:	98 3e       	cpi	r25, 0xE8	; 232
    71aa:	dc f3       	brlt	.-10     	; 0x71a2 <__divsf3_pse+0x6a>
    71ac:	86 95       	lsr	r24
    71ae:	77 95       	ror	r23
    71b0:	67 95       	ror	r22
    71b2:	b7 95       	ror	r27
    71b4:	f7 95       	ror	r31
    71b6:	9f 5f       	subi	r25, 0xFF	; 255
    71b8:	c9 f7       	brne	.-14     	; 0x71ac <__divsf3_pse+0x74>
    71ba:	88 0f       	add	r24, r24
    71bc:	91 1d       	adc	r25, r1
    71be:	96 95       	lsr	r25
    71c0:	87 95       	ror	r24
    71c2:	97 f9       	bld	r25, 7
    71c4:	08 95       	ret
    71c6:	e1 e0       	ldi	r30, 0x01	; 1
    71c8:	66 0f       	add	r22, r22
    71ca:	77 1f       	adc	r23, r23
    71cc:	88 1f       	adc	r24, r24
    71ce:	bb 1f       	adc	r27, r27
    71d0:	62 17       	cp	r22, r18
    71d2:	73 07       	cpc	r23, r19
    71d4:	84 07       	cpc	r24, r20
    71d6:	ba 07       	cpc	r27, r26
    71d8:	20 f0       	brcs	.+8      	; 0x71e2 <__divsf3_pse+0xaa>
    71da:	62 1b       	sub	r22, r18
    71dc:	73 0b       	sbc	r23, r19
    71de:	84 0b       	sbc	r24, r20
    71e0:	ba 0b       	sbc	r27, r26
    71e2:	ee 1f       	adc	r30, r30
    71e4:	88 f7       	brcc	.-30     	; 0x71c8 <__divsf3_pse+0x90>
    71e6:	e0 95       	com	r30
    71e8:	08 95       	ret

000071ea <__fixsfsi>:
    71ea:	04 d0       	rcall	.+8      	; 0x71f4 <__fixunssfsi>
    71ec:	68 94       	set
    71ee:	b1 11       	cpse	r27, r1
    71f0:	d9 c0       	rjmp	.+434    	; 0x73a4 <__fp_szero>
    71f2:	08 95       	ret

000071f4 <__fixunssfsi>:
    71f4:	bc d0       	rcall	.+376    	; 0x736e <__fp_splitA>
    71f6:	88 f0       	brcs	.+34     	; 0x721a <__fixunssfsi+0x26>
    71f8:	9f 57       	subi	r25, 0x7F	; 127
    71fa:	90 f0       	brcs	.+36     	; 0x7220 <__fixunssfsi+0x2c>
    71fc:	b9 2f       	mov	r27, r25
    71fe:	99 27       	eor	r25, r25
    7200:	b7 51       	subi	r27, 0x17	; 23
    7202:	a0 f0       	brcs	.+40     	; 0x722c <__fixunssfsi+0x38>
    7204:	d1 f0       	breq	.+52     	; 0x723a <__fixunssfsi+0x46>
    7206:	66 0f       	add	r22, r22
    7208:	77 1f       	adc	r23, r23
    720a:	88 1f       	adc	r24, r24
    720c:	99 1f       	adc	r25, r25
    720e:	1a f0       	brmi	.+6      	; 0x7216 <__fixunssfsi+0x22>
    7210:	ba 95       	dec	r27
    7212:	c9 f7       	brne	.-14     	; 0x7206 <__fixunssfsi+0x12>
    7214:	12 c0       	rjmp	.+36     	; 0x723a <__fixunssfsi+0x46>
    7216:	b1 30       	cpi	r27, 0x01	; 1
    7218:	81 f0       	breq	.+32     	; 0x723a <__fixunssfsi+0x46>
    721a:	c3 d0       	rcall	.+390    	; 0x73a2 <__fp_zero>
    721c:	b1 e0       	ldi	r27, 0x01	; 1
    721e:	08 95       	ret
    7220:	c0 c0       	rjmp	.+384    	; 0x73a2 <__fp_zero>
    7222:	67 2f       	mov	r22, r23
    7224:	78 2f       	mov	r23, r24
    7226:	88 27       	eor	r24, r24
    7228:	b8 5f       	subi	r27, 0xF8	; 248
    722a:	39 f0       	breq	.+14     	; 0x723a <__fixunssfsi+0x46>
    722c:	b9 3f       	cpi	r27, 0xF9	; 249
    722e:	cc f3       	brlt	.-14     	; 0x7222 <__fixunssfsi+0x2e>
    7230:	86 95       	lsr	r24
    7232:	77 95       	ror	r23
    7234:	67 95       	ror	r22
    7236:	b3 95       	inc	r27
    7238:	d9 f7       	brne	.-10     	; 0x7230 <__fixunssfsi+0x3c>
    723a:	3e f4       	brtc	.+14     	; 0x724a <__fixunssfsi+0x56>
    723c:	90 95       	com	r25
    723e:	80 95       	com	r24
    7240:	70 95       	com	r23
    7242:	61 95       	neg	r22
    7244:	7f 4f       	sbci	r23, 0xFF	; 255
    7246:	8f 4f       	sbci	r24, 0xFF	; 255
    7248:	9f 4f       	sbci	r25, 0xFF	; 255
    724a:	08 95       	ret

0000724c <__floatunsisf>:
    724c:	e8 94       	clt
    724e:	09 c0       	rjmp	.+18     	; 0x7262 <__floatsisf+0x12>

00007250 <__floatsisf>:
    7250:	97 fb       	bst	r25, 7
    7252:	3e f4       	brtc	.+14     	; 0x7262 <__floatsisf+0x12>
    7254:	90 95       	com	r25
    7256:	80 95       	com	r24
    7258:	70 95       	com	r23
    725a:	61 95       	neg	r22
    725c:	7f 4f       	sbci	r23, 0xFF	; 255
    725e:	8f 4f       	sbci	r24, 0xFF	; 255
    7260:	9f 4f       	sbci	r25, 0xFF	; 255
    7262:	99 23       	and	r25, r25
    7264:	a9 f0       	breq	.+42     	; 0x7290 <__floatsisf+0x40>
    7266:	f9 2f       	mov	r31, r25
    7268:	96 e9       	ldi	r25, 0x96	; 150
    726a:	bb 27       	eor	r27, r27
    726c:	93 95       	inc	r25
    726e:	f6 95       	lsr	r31
    7270:	87 95       	ror	r24
    7272:	77 95       	ror	r23
    7274:	67 95       	ror	r22
    7276:	b7 95       	ror	r27
    7278:	f1 11       	cpse	r31, r1
    727a:	f8 cf       	rjmp	.-16     	; 0x726c <__floatsisf+0x1c>
    727c:	fa f4       	brpl	.+62     	; 0x72bc <__floatsisf+0x6c>
    727e:	bb 0f       	add	r27, r27
    7280:	11 f4       	brne	.+4      	; 0x7286 <__floatsisf+0x36>
    7282:	60 ff       	sbrs	r22, 0
    7284:	1b c0       	rjmp	.+54     	; 0x72bc <__floatsisf+0x6c>
    7286:	6f 5f       	subi	r22, 0xFF	; 255
    7288:	7f 4f       	sbci	r23, 0xFF	; 255
    728a:	8f 4f       	sbci	r24, 0xFF	; 255
    728c:	9f 4f       	sbci	r25, 0xFF	; 255
    728e:	16 c0       	rjmp	.+44     	; 0x72bc <__floatsisf+0x6c>
    7290:	88 23       	and	r24, r24
    7292:	11 f0       	breq	.+4      	; 0x7298 <__floatsisf+0x48>
    7294:	96 e9       	ldi	r25, 0x96	; 150
    7296:	11 c0       	rjmp	.+34     	; 0x72ba <__floatsisf+0x6a>
    7298:	77 23       	and	r23, r23
    729a:	21 f0       	breq	.+8      	; 0x72a4 <__floatsisf+0x54>
    729c:	9e e8       	ldi	r25, 0x8E	; 142
    729e:	87 2f       	mov	r24, r23
    72a0:	76 2f       	mov	r23, r22
    72a2:	05 c0       	rjmp	.+10     	; 0x72ae <__floatsisf+0x5e>
    72a4:	66 23       	and	r22, r22
    72a6:	71 f0       	breq	.+28     	; 0x72c4 <__floatsisf+0x74>
    72a8:	96 e8       	ldi	r25, 0x86	; 134
    72aa:	86 2f       	mov	r24, r22
    72ac:	70 e0       	ldi	r23, 0x00	; 0
    72ae:	60 e0       	ldi	r22, 0x00	; 0
    72b0:	2a f0       	brmi	.+10     	; 0x72bc <__floatsisf+0x6c>
    72b2:	9a 95       	dec	r25
    72b4:	66 0f       	add	r22, r22
    72b6:	77 1f       	adc	r23, r23
    72b8:	88 1f       	adc	r24, r24
    72ba:	da f7       	brpl	.-10     	; 0x72b2 <__floatsisf+0x62>
    72bc:	88 0f       	add	r24, r24
    72be:	96 95       	lsr	r25
    72c0:	87 95       	ror	r24
    72c2:	97 f9       	bld	r25, 7
    72c4:	08 95       	ret

000072c6 <__fp_cmp>:
    72c6:	99 0f       	add	r25, r25
    72c8:	00 08       	sbc	r0, r0
    72ca:	55 0f       	add	r21, r21
    72cc:	aa 0b       	sbc	r26, r26
    72ce:	e0 e8       	ldi	r30, 0x80	; 128
    72d0:	fe ef       	ldi	r31, 0xFE	; 254
    72d2:	16 16       	cp	r1, r22
    72d4:	17 06       	cpc	r1, r23
    72d6:	e8 07       	cpc	r30, r24
    72d8:	f9 07       	cpc	r31, r25
    72da:	c0 f0       	brcs	.+48     	; 0x730c <__fp_cmp+0x46>
    72dc:	12 16       	cp	r1, r18
    72de:	13 06       	cpc	r1, r19
    72e0:	e4 07       	cpc	r30, r20
    72e2:	f5 07       	cpc	r31, r21
    72e4:	98 f0       	brcs	.+38     	; 0x730c <__fp_cmp+0x46>
    72e6:	62 1b       	sub	r22, r18
    72e8:	73 0b       	sbc	r23, r19
    72ea:	84 0b       	sbc	r24, r20
    72ec:	95 0b       	sbc	r25, r21
    72ee:	39 f4       	brne	.+14     	; 0x72fe <__fp_cmp+0x38>
    72f0:	0a 26       	eor	r0, r26
    72f2:	61 f0       	breq	.+24     	; 0x730c <__fp_cmp+0x46>
    72f4:	23 2b       	or	r18, r19
    72f6:	24 2b       	or	r18, r20
    72f8:	25 2b       	or	r18, r21
    72fa:	21 f4       	brne	.+8      	; 0x7304 <__fp_cmp+0x3e>
    72fc:	08 95       	ret
    72fe:	0a 26       	eor	r0, r26
    7300:	09 f4       	brne	.+2      	; 0x7304 <__fp_cmp+0x3e>
    7302:	a1 40       	sbci	r26, 0x01	; 1
    7304:	a6 95       	lsr	r26
    7306:	8f ef       	ldi	r24, 0xFF	; 255
    7308:	81 1d       	adc	r24, r1
    730a:	81 1d       	adc	r24, r1
    730c:	08 95       	ret

0000730e <__fp_inf>:
    730e:	97 f9       	bld	r25, 7
    7310:	9f 67       	ori	r25, 0x7F	; 127
    7312:	80 e8       	ldi	r24, 0x80	; 128
    7314:	70 e0       	ldi	r23, 0x00	; 0
    7316:	60 e0       	ldi	r22, 0x00	; 0
    7318:	08 95       	ret

0000731a <__fp_nan>:
    731a:	9f ef       	ldi	r25, 0xFF	; 255
    731c:	80 ec       	ldi	r24, 0xC0	; 192
    731e:	08 95       	ret

00007320 <__fp_pscA>:
    7320:	00 24       	eor	r0, r0
    7322:	0a 94       	dec	r0
    7324:	16 16       	cp	r1, r22
    7326:	17 06       	cpc	r1, r23
    7328:	18 06       	cpc	r1, r24
    732a:	09 06       	cpc	r0, r25
    732c:	08 95       	ret

0000732e <__fp_pscB>:
    732e:	00 24       	eor	r0, r0
    7330:	0a 94       	dec	r0
    7332:	12 16       	cp	r1, r18
    7334:	13 06       	cpc	r1, r19
    7336:	14 06       	cpc	r1, r20
    7338:	05 06       	cpc	r0, r21
    733a:	08 95       	ret

0000733c <__fp_round>:
    733c:	09 2e       	mov	r0, r25
    733e:	03 94       	inc	r0
    7340:	00 0c       	add	r0, r0
    7342:	11 f4       	brne	.+4      	; 0x7348 <__fp_round+0xc>
    7344:	88 23       	and	r24, r24
    7346:	52 f0       	brmi	.+20     	; 0x735c <__fp_round+0x20>
    7348:	bb 0f       	add	r27, r27
    734a:	40 f4       	brcc	.+16     	; 0x735c <__fp_round+0x20>
    734c:	bf 2b       	or	r27, r31
    734e:	11 f4       	brne	.+4      	; 0x7354 <__fp_round+0x18>
    7350:	60 ff       	sbrs	r22, 0
    7352:	04 c0       	rjmp	.+8      	; 0x735c <__fp_round+0x20>
    7354:	6f 5f       	subi	r22, 0xFF	; 255
    7356:	7f 4f       	sbci	r23, 0xFF	; 255
    7358:	8f 4f       	sbci	r24, 0xFF	; 255
    735a:	9f 4f       	sbci	r25, 0xFF	; 255
    735c:	08 95       	ret

0000735e <__fp_split3>:
    735e:	57 fd       	sbrc	r21, 7
    7360:	90 58       	subi	r25, 0x80	; 128
    7362:	44 0f       	add	r20, r20
    7364:	55 1f       	adc	r21, r21
    7366:	59 f0       	breq	.+22     	; 0x737e <__fp_splitA+0x10>
    7368:	5f 3f       	cpi	r21, 0xFF	; 255
    736a:	71 f0       	breq	.+28     	; 0x7388 <__fp_splitA+0x1a>
    736c:	47 95       	ror	r20

0000736e <__fp_splitA>:
    736e:	88 0f       	add	r24, r24
    7370:	97 fb       	bst	r25, 7
    7372:	99 1f       	adc	r25, r25
    7374:	61 f0       	breq	.+24     	; 0x738e <__fp_splitA+0x20>
    7376:	9f 3f       	cpi	r25, 0xFF	; 255
    7378:	79 f0       	breq	.+30     	; 0x7398 <__fp_splitA+0x2a>
    737a:	87 95       	ror	r24
    737c:	08 95       	ret
    737e:	12 16       	cp	r1, r18
    7380:	13 06       	cpc	r1, r19
    7382:	14 06       	cpc	r1, r20
    7384:	55 1f       	adc	r21, r21
    7386:	f2 cf       	rjmp	.-28     	; 0x736c <__fp_split3+0xe>
    7388:	46 95       	lsr	r20
    738a:	f1 df       	rcall	.-30     	; 0x736e <__fp_splitA>
    738c:	08 c0       	rjmp	.+16     	; 0x739e <__fp_splitA+0x30>
    738e:	16 16       	cp	r1, r22
    7390:	17 06       	cpc	r1, r23
    7392:	18 06       	cpc	r1, r24
    7394:	99 1f       	adc	r25, r25
    7396:	f1 cf       	rjmp	.-30     	; 0x737a <__fp_splitA+0xc>
    7398:	86 95       	lsr	r24
    739a:	71 05       	cpc	r23, r1
    739c:	61 05       	cpc	r22, r1
    739e:	08 94       	sec
    73a0:	08 95       	ret

000073a2 <__fp_zero>:
    73a2:	e8 94       	clt

000073a4 <__fp_szero>:
    73a4:	bb 27       	eor	r27, r27
    73a6:	66 27       	eor	r22, r22
    73a8:	77 27       	eor	r23, r23
    73aa:	cb 01       	movw	r24, r22
    73ac:	97 f9       	bld	r25, 7
    73ae:	08 95       	ret

000073b0 <__gesf2>:
    73b0:	8a df       	rcall	.-236    	; 0x72c6 <__fp_cmp>
    73b2:	08 f4       	brcc	.+2      	; 0x73b6 <__gesf2+0x6>
    73b4:	8f ef       	ldi	r24, 0xFF	; 255
    73b6:	08 95       	ret

000073b8 <__mulsf3>:
    73b8:	0b d0       	rcall	.+22     	; 0x73d0 <__mulsf3x>
    73ba:	c0 cf       	rjmp	.-128    	; 0x733c <__fp_round>
    73bc:	b1 df       	rcall	.-158    	; 0x7320 <__fp_pscA>
    73be:	28 f0       	brcs	.+10     	; 0x73ca <__mulsf3+0x12>
    73c0:	b6 df       	rcall	.-148    	; 0x732e <__fp_pscB>
    73c2:	18 f0       	brcs	.+6      	; 0x73ca <__mulsf3+0x12>
    73c4:	95 23       	and	r25, r21
    73c6:	09 f0       	breq	.+2      	; 0x73ca <__mulsf3+0x12>
    73c8:	a2 cf       	rjmp	.-188    	; 0x730e <__fp_inf>
    73ca:	a7 cf       	rjmp	.-178    	; 0x731a <__fp_nan>
    73cc:	11 24       	eor	r1, r1
    73ce:	ea cf       	rjmp	.-44     	; 0x73a4 <__fp_szero>

000073d0 <__mulsf3x>:
    73d0:	c6 df       	rcall	.-116    	; 0x735e <__fp_split3>
    73d2:	a0 f3       	brcs	.-24     	; 0x73bc <__mulsf3+0x4>

000073d4 <__mulsf3_pse>:
    73d4:	95 9f       	mul	r25, r21
    73d6:	d1 f3       	breq	.-12     	; 0x73cc <__mulsf3+0x14>
    73d8:	95 0f       	add	r25, r21
    73da:	50 e0       	ldi	r21, 0x00	; 0
    73dc:	55 1f       	adc	r21, r21
    73de:	62 9f       	mul	r22, r18
    73e0:	f0 01       	movw	r30, r0
    73e2:	72 9f       	mul	r23, r18
    73e4:	bb 27       	eor	r27, r27
    73e6:	f0 0d       	add	r31, r0
    73e8:	b1 1d       	adc	r27, r1
    73ea:	63 9f       	mul	r22, r19
    73ec:	aa 27       	eor	r26, r26
    73ee:	f0 0d       	add	r31, r0
    73f0:	b1 1d       	adc	r27, r1
    73f2:	aa 1f       	adc	r26, r26
    73f4:	64 9f       	mul	r22, r20
    73f6:	66 27       	eor	r22, r22
    73f8:	b0 0d       	add	r27, r0
    73fa:	a1 1d       	adc	r26, r1
    73fc:	66 1f       	adc	r22, r22
    73fe:	82 9f       	mul	r24, r18
    7400:	22 27       	eor	r18, r18
    7402:	b0 0d       	add	r27, r0
    7404:	a1 1d       	adc	r26, r1
    7406:	62 1f       	adc	r22, r18
    7408:	73 9f       	mul	r23, r19
    740a:	b0 0d       	add	r27, r0
    740c:	a1 1d       	adc	r26, r1
    740e:	62 1f       	adc	r22, r18
    7410:	83 9f       	mul	r24, r19
    7412:	a0 0d       	add	r26, r0
    7414:	61 1d       	adc	r22, r1
    7416:	22 1f       	adc	r18, r18
    7418:	74 9f       	mul	r23, r20
    741a:	33 27       	eor	r19, r19
    741c:	a0 0d       	add	r26, r0
    741e:	61 1d       	adc	r22, r1
    7420:	23 1f       	adc	r18, r19
    7422:	84 9f       	mul	r24, r20
    7424:	60 0d       	add	r22, r0
    7426:	21 1d       	adc	r18, r1
    7428:	82 2f       	mov	r24, r18
    742a:	76 2f       	mov	r23, r22
    742c:	6a 2f       	mov	r22, r26
    742e:	11 24       	eor	r1, r1
    7430:	9f 57       	subi	r25, 0x7F	; 127
    7432:	50 40       	sbci	r21, 0x00	; 0
    7434:	8a f0       	brmi	.+34     	; 0x7458 <__mulsf3_pse+0x84>
    7436:	e1 f0       	breq	.+56     	; 0x7470 <__mulsf3_pse+0x9c>
    7438:	88 23       	and	r24, r24
    743a:	4a f0       	brmi	.+18     	; 0x744e <__mulsf3_pse+0x7a>
    743c:	ee 0f       	add	r30, r30
    743e:	ff 1f       	adc	r31, r31
    7440:	bb 1f       	adc	r27, r27
    7442:	66 1f       	adc	r22, r22
    7444:	77 1f       	adc	r23, r23
    7446:	88 1f       	adc	r24, r24
    7448:	91 50       	subi	r25, 0x01	; 1
    744a:	50 40       	sbci	r21, 0x00	; 0
    744c:	a9 f7       	brne	.-22     	; 0x7438 <__mulsf3_pse+0x64>
    744e:	9e 3f       	cpi	r25, 0xFE	; 254
    7450:	51 05       	cpc	r21, r1
    7452:	70 f0       	brcs	.+28     	; 0x7470 <__mulsf3_pse+0x9c>
    7454:	5c cf       	rjmp	.-328    	; 0x730e <__fp_inf>
    7456:	a6 cf       	rjmp	.-180    	; 0x73a4 <__fp_szero>
    7458:	5f 3f       	cpi	r21, 0xFF	; 255
    745a:	ec f3       	brlt	.-6      	; 0x7456 <__mulsf3_pse+0x82>
    745c:	98 3e       	cpi	r25, 0xE8	; 232
    745e:	dc f3       	brlt	.-10     	; 0x7456 <__mulsf3_pse+0x82>
    7460:	86 95       	lsr	r24
    7462:	77 95       	ror	r23
    7464:	67 95       	ror	r22
    7466:	b7 95       	ror	r27
    7468:	f7 95       	ror	r31
    746a:	e7 95       	ror	r30
    746c:	9f 5f       	subi	r25, 0xFF	; 255
    746e:	c1 f7       	brne	.-16     	; 0x7460 <__mulsf3_pse+0x8c>
    7470:	fe 2b       	or	r31, r30
    7472:	88 0f       	add	r24, r24
    7474:	91 1d       	adc	r25, r1
    7476:	96 95       	lsr	r25
    7478:	87 95       	ror	r24
    747a:	97 f9       	bld	r25, 7
    747c:	08 95       	ret
    747e:	11 f4       	brne	.+4      	; 0x7484 <__mulsf3_pse+0xb0>
    7480:	0e f4       	brtc	.+2      	; 0x7484 <__mulsf3_pse+0xb0>
    7482:	4b cf       	rjmp	.-362    	; 0x731a <__fp_nan>
    7484:	3e c0       	rjmp	.+124    	; 0x7502 <__fp_mpack>

00007486 <sqrt>:
    7486:	73 df       	rcall	.-282    	; 0x736e <__fp_splitA>
    7488:	d0 f3       	brcs	.-12     	; 0x747e <__mulsf3_pse+0xaa>
    748a:	99 23       	and	r25, r25
    748c:	d9 f3       	breq	.-10     	; 0x7484 <__mulsf3_pse+0xb0>
    748e:	ce f3       	brts	.-14     	; 0x7482 <__mulsf3_pse+0xae>
    7490:	9f 57       	subi	r25, 0x7F	; 127
    7492:	55 0b       	sbc	r21, r21
    7494:	87 ff       	sbrs	r24, 7
    7496:	43 d0       	rcall	.+134    	; 0x751e <__fp_norm2>
    7498:	00 24       	eor	r0, r0
    749a:	a0 e6       	ldi	r26, 0x60	; 96
    749c:	40 ea       	ldi	r20, 0xA0	; 160
    749e:	90 01       	movw	r18, r0
    74a0:	80 58       	subi	r24, 0x80	; 128
    74a2:	56 95       	lsr	r21
    74a4:	97 95       	ror	r25
    74a6:	28 f4       	brcc	.+10     	; 0x74b2 <sqrt+0x2c>
    74a8:	80 5c       	subi	r24, 0xC0	; 192
    74aa:	66 0f       	add	r22, r22
    74ac:	77 1f       	adc	r23, r23
    74ae:	88 1f       	adc	r24, r24
    74b0:	20 f0       	brcs	.+8      	; 0x74ba <sqrt+0x34>
    74b2:	26 17       	cp	r18, r22
    74b4:	37 07       	cpc	r19, r23
    74b6:	48 07       	cpc	r20, r24
    74b8:	30 f4       	brcc	.+12     	; 0x74c6 <sqrt+0x40>
    74ba:	62 1b       	sub	r22, r18
    74bc:	73 0b       	sbc	r23, r19
    74be:	84 0b       	sbc	r24, r20
    74c0:	20 29       	or	r18, r0
    74c2:	31 29       	or	r19, r1
    74c4:	4a 2b       	or	r20, r26
    74c6:	a6 95       	lsr	r26
    74c8:	17 94       	ror	r1
    74ca:	07 94       	ror	r0
    74cc:	20 25       	eor	r18, r0
    74ce:	31 25       	eor	r19, r1
    74d0:	4a 27       	eor	r20, r26
    74d2:	58 f7       	brcc	.-42     	; 0x74aa <sqrt+0x24>
    74d4:	66 0f       	add	r22, r22
    74d6:	77 1f       	adc	r23, r23
    74d8:	88 1f       	adc	r24, r24
    74da:	20 f0       	brcs	.+8      	; 0x74e4 <sqrt+0x5e>
    74dc:	26 17       	cp	r18, r22
    74de:	37 07       	cpc	r19, r23
    74e0:	48 07       	cpc	r20, r24
    74e2:	30 f4       	brcc	.+12     	; 0x74f0 <sqrt+0x6a>
    74e4:	62 0b       	sbc	r22, r18
    74e6:	73 0b       	sbc	r23, r19
    74e8:	84 0b       	sbc	r24, r20
    74ea:	20 0d       	add	r18, r0
    74ec:	31 1d       	adc	r19, r1
    74ee:	41 1d       	adc	r20, r1
    74f0:	a0 95       	com	r26
    74f2:	81 f7       	brne	.-32     	; 0x74d4 <sqrt+0x4e>
    74f4:	b9 01       	movw	r22, r18
    74f6:	84 2f       	mov	r24, r20
    74f8:	91 58       	subi	r25, 0x81	; 129
    74fa:	88 0f       	add	r24, r24
    74fc:	96 95       	lsr	r25
    74fe:	87 95       	ror	r24
    7500:	08 95       	ret

00007502 <__fp_mpack>:
    7502:	9f 3f       	cpi	r25, 0xFF	; 255
    7504:	31 f0       	breq	.+12     	; 0x7512 <__fp_mpack_finite+0xc>

00007506 <__fp_mpack_finite>:
    7506:	91 50       	subi	r25, 0x01	; 1
    7508:	20 f4       	brcc	.+8      	; 0x7512 <__fp_mpack_finite+0xc>
    750a:	87 95       	ror	r24
    750c:	77 95       	ror	r23
    750e:	67 95       	ror	r22
    7510:	b7 95       	ror	r27
    7512:	88 0f       	add	r24, r24
    7514:	91 1d       	adc	r25, r1
    7516:	96 95       	lsr	r25
    7518:	87 95       	ror	r24
    751a:	97 f9       	bld	r25, 7
    751c:	08 95       	ret

0000751e <__fp_norm2>:
    751e:	91 50       	subi	r25, 0x01	; 1
    7520:	50 40       	sbci	r21, 0x00	; 0
    7522:	66 0f       	add	r22, r22
    7524:	77 1f       	adc	r23, r23
    7526:	88 1f       	adc	r24, r24
    7528:	d2 f7       	brpl	.-12     	; 0x751e <__fp_norm2>
    752a:	08 95       	ret

0000752c <__udivmodhi4>:
    752c:	aa 1b       	sub	r26, r26
    752e:	bb 1b       	sub	r27, r27
    7530:	51 e1       	ldi	r21, 0x11	; 17
    7532:	07 c0       	rjmp	.+14     	; 0x7542 <__udivmodhi4_ep>

00007534 <__udivmodhi4_loop>:
    7534:	aa 1f       	adc	r26, r26
    7536:	bb 1f       	adc	r27, r27
    7538:	a6 17       	cp	r26, r22
    753a:	b7 07       	cpc	r27, r23
    753c:	10 f0       	brcs	.+4      	; 0x7542 <__udivmodhi4_ep>
    753e:	a6 1b       	sub	r26, r22
    7540:	b7 0b       	sbc	r27, r23

00007542 <__udivmodhi4_ep>:
    7542:	88 1f       	adc	r24, r24
    7544:	99 1f       	adc	r25, r25
    7546:	5a 95       	dec	r21
    7548:	a9 f7       	brne	.-22     	; 0x7534 <__udivmodhi4_loop>
    754a:	80 95       	com	r24
    754c:	90 95       	com	r25
    754e:	bc 01       	movw	r22, r24
    7550:	cd 01       	movw	r24, r26
    7552:	08 95       	ret

00007554 <__divmodhi4>:
    7554:	97 fb       	bst	r25, 7
    7556:	09 2e       	mov	r0, r25
    7558:	07 26       	eor	r0, r23
    755a:	0a d0       	rcall	.+20     	; 0x7570 <__divmodhi4_neg1>
    755c:	77 fd       	sbrc	r23, 7
    755e:	04 d0       	rcall	.+8      	; 0x7568 <__divmodhi4_neg2>
    7560:	e5 df       	rcall	.-54     	; 0x752c <__udivmodhi4>
    7562:	06 d0       	rcall	.+12     	; 0x7570 <__divmodhi4_neg1>
    7564:	00 20       	and	r0, r0
    7566:	1a f4       	brpl	.+6      	; 0x756e <__divmodhi4_exit>

00007568 <__divmodhi4_neg2>:
    7568:	70 95       	com	r23
    756a:	61 95       	neg	r22
    756c:	7f 4f       	sbci	r23, 0xFF	; 255

0000756e <__divmodhi4_exit>:
    756e:	08 95       	ret

00007570 <__divmodhi4_neg1>:
    7570:	f6 f7       	brtc	.-4      	; 0x756e <__divmodhi4_exit>
    7572:	90 95       	com	r25
    7574:	81 95       	neg	r24
    7576:	9f 4f       	sbci	r25, 0xFF	; 255
    7578:	08 95       	ret

0000757a <abs>:
    757a:	28 2f       	mov	r18, r24
    757c:	39 2f       	mov	r19, r25
    757e:	37 ff       	sbrs	r19, 7
    7580:	03 c0       	rjmp	.+6      	; 0x7588 <abs+0xe>
    7582:	30 95       	com	r19
    7584:	21 95       	neg	r18
    7586:	3f 4f       	sbci	r19, 0xFF	; 255
    7588:	c9 01       	movw	r24, r18
    758a:	08 95       	ret

0000758c <dtostrf>:
    758c:	ef 92       	push	r14
    758e:	ff 92       	push	r15
    7590:	0f 93       	push	r16
    7592:	1f 93       	push	r17
    7594:	32 2f       	mov	r19, r18
    7596:	f0 2e       	mov	r15, r16
    7598:	47 ff       	sbrs	r20, 7
    759a:	02 c0       	rjmp	.+4      	; 0x75a0 <dtostrf+0x14>
    759c:	a4 e1       	ldi	r26, 0x14	; 20
    759e:	01 c0       	rjmp	.+2      	; 0x75a2 <dtostrf+0x16>
    75a0:	a4 e0       	ldi	r26, 0x04	; 4
    75a2:	e4 2f       	mov	r30, r20
    75a4:	ff 27       	eor	r31, r31
    75a6:	e7 fd       	sbrc	r30, 7
    75a8:	f0 95       	com	r31
    75aa:	f7 ff       	sbrs	r31, 7
    75ac:	03 c0       	rjmp	.+6      	; 0x75b4 <dtostrf+0x28>
    75ae:	f0 95       	com	r31
    75b0:	e1 95       	neg	r30
    75b2:	ff 4f       	sbci	r31, 0xFF	; 255
    75b4:	4f 2d       	mov	r20, r15
    75b6:	51 2f       	mov	r21, r17
    75b8:	2e 2f       	mov	r18, r30
    75ba:	03 2f       	mov	r16, r19
    75bc:	ea 2e       	mov	r14, r26
    75be:	0e 94 72 3b 	call	0x76e4	; 0x76e4 <dtoa_prf>
    75c2:	8f 2d       	mov	r24, r15
    75c4:	91 2f       	mov	r25, r17
    75c6:	1f 91       	pop	r17
    75c8:	0f 91       	pop	r16
    75ca:	ff 90       	pop	r15
    75cc:	ef 90       	pop	r14
    75ce:	08 95       	ret

000075d0 <memcpy_P>:
    75d0:	fb 01       	movw	r30, r22
    75d2:	dc 01       	movw	r26, r24
    75d4:	02 c0       	rjmp	.+4      	; 0x75da <memcpy_P+0xa>
    75d6:	05 90       	lpm	r0, Z+
    75d8:	0d 92       	st	X+, r0
    75da:	41 50       	subi	r20, 0x01	; 1
    75dc:	50 40       	sbci	r21, 0x00	; 0
    75de:	d8 f7       	brcc	.-10     	; 0x75d6 <memcpy_P+0x6>
    75e0:	08 95       	ret

000075e2 <strcpy_P>:
    75e2:	fb 01       	movw	r30, r22
    75e4:	dc 01       	movw	r26, r24
    75e6:	05 90       	lpm	r0, Z+
    75e8:	0d 92       	st	X+, r0
    75ea:	00 20       	and	r0, r0
    75ec:	e1 f7       	brne	.-8      	; 0x75e6 <strcpy_P+0x4>
    75ee:	08 95       	ret

000075f0 <strlen_P>:
    75f0:	fc 01       	movw	r30, r24
    75f2:	05 90       	lpm	r0, Z+
    75f4:	00 20       	and	r0, r0
    75f6:	e9 f7       	brne	.-6      	; 0x75f2 <strlen_P+0x2>
    75f8:	80 95       	com	r24
    75fa:	90 95       	com	r25
    75fc:	8e 0f       	add	r24, r30
    75fe:	9f 1f       	adc	r25, r31
    7600:	08 95       	ret

00007602 <memcpy>:
    7602:	fb 01       	movw	r30, r22
    7604:	dc 01       	movw	r26, r24
    7606:	02 c0       	rjmp	.+4      	; 0x760c <memcpy+0xa>
    7608:	01 90       	ld	r0, Z+
    760a:	0d 92       	st	X+, r0
    760c:	41 50       	subi	r20, 0x01	; 1
    760e:	50 40       	sbci	r21, 0x00	; 0
    7610:	d8 f7       	brcc	.-10     	; 0x7608 <memcpy+0x6>
    7612:	08 95       	ret

00007614 <strcat>:
    7614:	fb 01       	movw	r30, r22
    7616:	dc 01       	movw	r26, r24
    7618:	0d 90       	ld	r0, X+
    761a:	00 20       	and	r0, r0
    761c:	e9 f7       	brne	.-6      	; 0x7618 <strcat+0x4>
    761e:	11 97       	sbiw	r26, 0x01	; 1
    7620:	01 90       	ld	r0, Z+
    7622:	0d 92       	st	X+, r0
    7624:	00 20       	and	r0, r0
    7626:	e1 f7       	brne	.-8      	; 0x7620 <strcat+0xc>
    7628:	08 95       	ret

0000762a <itoa>:
    762a:	fb 01       	movw	r30, r22
    762c:	9f 01       	movw	r18, r30
    762e:	e8 94       	clt
    7630:	42 30       	cpi	r20, 0x02	; 2
    7632:	c4 f0       	brlt	.+48     	; 0x7664 <itoa+0x3a>
    7634:	45 32       	cpi	r20, 0x25	; 37
    7636:	b4 f4       	brge	.+44     	; 0x7664 <itoa+0x3a>
    7638:	4a 30       	cpi	r20, 0x0A	; 10
    763a:	29 f4       	brne	.+10     	; 0x7646 <itoa+0x1c>
    763c:	97 fb       	bst	r25, 7
    763e:	1e f4       	brtc	.+6      	; 0x7646 <itoa+0x1c>
    7640:	90 95       	com	r25
    7642:	81 95       	neg	r24
    7644:	9f 4f       	sbci	r25, 0xFF	; 255
    7646:	64 2f       	mov	r22, r20
    7648:	77 27       	eor	r23, r23
    764a:	0e 94 96 3a 	call	0x752c	; 0x752c <__udivmodhi4>
    764e:	80 5d       	subi	r24, 0xD0	; 208
    7650:	8a 33       	cpi	r24, 0x3A	; 58
    7652:	0c f0       	brlt	.+2      	; 0x7656 <itoa+0x2c>
    7654:	89 5d       	subi	r24, 0xD9	; 217
    7656:	81 93       	st	Z+, r24
    7658:	cb 01       	movw	r24, r22
    765a:	00 97       	sbiw	r24, 0x00	; 0
    765c:	a1 f7       	brne	.-24     	; 0x7646 <itoa+0x1c>
    765e:	16 f4       	brtc	.+4      	; 0x7664 <itoa+0x3a>
    7660:	5d e2       	ldi	r21, 0x2D	; 45
    7662:	51 93       	st	Z+, r21
    7664:	10 82       	st	Z, r1
    7666:	c9 01       	movw	r24, r18
    7668:	0c 94 a1 3d 	jmp	0x7b42	; 0x7b42 <strrev>

0000766c <utoa>:
    766c:	fb 01       	movw	r30, r22
    766e:	9f 01       	movw	r18, r30
    7670:	42 30       	cpi	r20, 0x02	; 2
    7672:	74 f0       	brlt	.+28     	; 0x7690 <utoa+0x24>
    7674:	45 32       	cpi	r20, 0x25	; 37
    7676:	64 f4       	brge	.+24     	; 0x7690 <utoa+0x24>
    7678:	64 2f       	mov	r22, r20
    767a:	77 27       	eor	r23, r23
    767c:	0e 94 96 3a 	call	0x752c	; 0x752c <__udivmodhi4>
    7680:	80 5d       	subi	r24, 0xD0	; 208
    7682:	8a 33       	cpi	r24, 0x3A	; 58
    7684:	0c f0       	brlt	.+2      	; 0x7688 <utoa+0x1c>
    7686:	89 5d       	subi	r24, 0xD9	; 217
    7688:	81 93       	st	Z+, r24
    768a:	cb 01       	movw	r24, r22
    768c:	00 97       	sbiw	r24, 0x00	; 0
    768e:	a1 f7       	brne	.-24     	; 0x7678 <utoa+0xc>
    7690:	10 82       	st	Z, r1
    7692:	c9 01       	movw	r24, r18
    7694:	0c 94 a1 3d 	jmp	0x7b42	; 0x7b42 <strrev>

00007698 <__eerd_block_m324pa>:
    7698:	dc 01       	movw	r26, r24
    769a:	cb 01       	movw	r24, r22

0000769c <__eerd_blraw_m324pa>:
    769c:	fc 01       	movw	r30, r24
    769e:	f9 99       	sbic	0x1f, 1	; 31
    76a0:	fe cf       	rjmp	.-4      	; 0x769e <__eerd_blraw_m324pa+0x2>
    76a2:	06 c0       	rjmp	.+12     	; 0x76b0 <__eerd_blraw_m324pa+0x14>
    76a4:	f2 bd       	out	0x22, r31	; 34
    76a6:	e1 bd       	out	0x21, r30	; 33
    76a8:	f8 9a       	sbi	0x1f, 0	; 31
    76aa:	31 96       	adiw	r30, 0x01	; 1
    76ac:	00 b4       	in	r0, 0x20	; 32
    76ae:	0d 92       	st	X+, r0
    76b0:	41 50       	subi	r20, 0x01	; 1
    76b2:	50 40       	sbci	r21, 0x00	; 0
    76b4:	b8 f7       	brcc	.-18     	; 0x76a4 <__eerd_blraw_m324pa+0x8>
    76b6:	08 95       	ret

000076b8 <__eerd_byte_m324pa>:
    76b8:	f9 99       	sbic	0x1f, 1	; 31
    76ba:	fe cf       	rjmp	.-4      	; 0x76b8 <__eerd_byte_m324pa>
    76bc:	92 bd       	out	0x22, r25	; 34
    76be:	81 bd       	out	0x21, r24	; 33
    76c0:	f8 9a       	sbi	0x1f, 0	; 31
    76c2:	99 27       	eor	r25, r25
    76c4:	80 b5       	in	r24, 0x20	; 32
    76c6:	08 95       	ret

000076c8 <__eewr_byte_m324pa>:
    76c8:	26 2f       	mov	r18, r22

000076ca <__eewr_r18_m324pa>:
    76ca:	f9 99       	sbic	0x1f, 1	; 31
    76cc:	fe cf       	rjmp	.-4      	; 0x76ca <__eewr_r18_m324pa>
    76ce:	1f ba       	out	0x1f, r1	; 31
    76d0:	92 bd       	out	0x22, r25	; 34
    76d2:	81 bd       	out	0x21, r24	; 33
    76d4:	20 bd       	out	0x20, r18	; 32
    76d6:	0f b6       	in	r0, 0x3f	; 63
    76d8:	f8 94       	cli
    76da:	fa 9a       	sbi	0x1f, 2	; 31
    76dc:	f9 9a       	sbi	0x1f, 1	; 31
    76de:	0f be       	out	0x3f, r0	; 63
    76e0:	01 96       	adiw	r24, 0x01	; 1
    76e2:	08 95       	ret

000076e4 <dtoa_prf>:
    76e4:	a9 e0       	ldi	r26, 0x09	; 9
    76e6:	b0 e0       	ldi	r27, 0x00	; 0
    76e8:	e8 e7       	ldi	r30, 0x78	; 120
    76ea:	fb e3       	ldi	r31, 0x3B	; 59
    76ec:	0c 94 b9 3d 	jmp	0x7b72	; 0x7b72 <__prologue_saves__+0x10>
    76f0:	6a 01       	movw	r12, r20
    76f2:	f2 2e       	mov	r15, r18
    76f4:	10 2f       	mov	r17, r16
    76f6:	0c 33       	cpi	r16, 0x3C	; 60
    76f8:	18 f4       	brcc	.+6      	; 0x7700 <dtoa_prf+0x1c>
    76fa:	b0 2e       	mov	r11, r16
    76fc:	b3 94       	inc	r11
    76fe:	02 c0       	rjmp	.+4      	; 0x7704 <dtoa_prf+0x20>
    7700:	ec e3       	ldi	r30, 0x3C	; 60
    7702:	be 2e       	mov	r11, r30
    7704:	ae 01       	movw	r20, r28
    7706:	4f 5f       	subi	r20, 0xFF	; 255
    7708:	5f 4f       	sbci	r21, 0xFF	; 255
    770a:	27 e0       	ldi	r18, 0x07	; 7
    770c:	0b 2d       	mov	r16, r11
    770e:	0e 94 c9 3c 	call	0x7992	; 0x7992 <__ftoa_engine>
    7712:	29 81       	ldd	r18, Y+1	; 0x01
    7714:	30 e0       	ldi	r19, 0x00	; 0
    7716:	a9 01       	movw	r20, r18
    7718:	49 70       	andi	r20, 0x09	; 9
    771a:	50 70       	andi	r21, 0x00	; 0
    771c:	41 30       	cpi	r20, 0x01	; 1
    771e:	51 05       	cpc	r21, r1
    7720:	31 f0       	breq	.+12     	; 0x772e <dtoa_prf+0x4a>
    7722:	e1 fc       	sbrc	r14, 1
    7724:	06 c0       	rjmp	.+12     	; 0x7732 <dtoa_prf+0x4e>
    7726:	e0 fe       	sbrs	r14, 0
    7728:	06 c0       	rjmp	.+12     	; 0x7736 <dtoa_prf+0x52>
    772a:	e0 e2       	ldi	r30, 0x20	; 32
    772c:	05 c0       	rjmp	.+10     	; 0x7738 <dtoa_prf+0x54>
    772e:	ed e2       	ldi	r30, 0x2D	; 45
    7730:	03 c0       	rjmp	.+6      	; 0x7738 <dtoa_prf+0x54>
    7732:	eb e2       	ldi	r30, 0x2B	; 43
    7734:	01 c0       	rjmp	.+2      	; 0x7738 <dtoa_prf+0x54>
    7736:	e0 e0       	ldi	r30, 0x00	; 0
    7738:	23 ff       	sbrs	r18, 3
    773a:	37 c0       	rjmp	.+110    	; 0x77aa <dtoa_prf+0xc6>
    773c:	ee 23       	and	r30, r30
    773e:	11 f0       	breq	.+4      	; 0x7744 <dtoa_prf+0x60>
    7740:	84 e0       	ldi	r24, 0x04	; 4
    7742:	01 c0       	rjmp	.+2      	; 0x7746 <dtoa_prf+0x62>
    7744:	83 e0       	ldi	r24, 0x03	; 3
    7746:	8f 15       	cp	r24, r15
    7748:	18 f4       	brcc	.+6      	; 0x7750 <dtoa_prf+0x6c>
    774a:	f8 1a       	sub	r15, r24
    774c:	8f 2d       	mov	r24, r15
    774e:	01 c0       	rjmp	.+2      	; 0x7752 <dtoa_prf+0x6e>
    7750:	80 e0       	ldi	r24, 0x00	; 0
    7752:	e4 fc       	sbrc	r14, 4
    7754:	0b c0       	rjmp	.+22     	; 0x776c <dtoa_prf+0x88>
    7756:	98 2f       	mov	r25, r24
    7758:	d6 01       	movw	r26, r12
    775a:	20 e2       	ldi	r18, 0x20	; 32
    775c:	02 c0       	rjmp	.+4      	; 0x7762 <dtoa_prf+0x7e>
    775e:	2d 93       	st	X+, r18
    7760:	91 50       	subi	r25, 0x01	; 1
    7762:	99 23       	and	r25, r25
    7764:	e1 f7       	brne	.-8      	; 0x775e <dtoa_prf+0x7a>
    7766:	c8 0e       	add	r12, r24
    7768:	d1 1c       	adc	r13, r1
    776a:	80 e0       	ldi	r24, 0x00	; 0
    776c:	ee 23       	and	r30, r30
    776e:	19 f0       	breq	.+6      	; 0x7776 <dtoa_prf+0x92>
    7770:	d6 01       	movw	r26, r12
    7772:	ed 93       	st	X+, r30
    7774:	6d 01       	movw	r12, r26
    7776:	f6 01       	movw	r30, r12
    7778:	31 96       	adiw	r30, 0x01	; 1
    777a:	e2 fe       	sbrs	r14, 2
    777c:	05 c0       	rjmp	.+10     	; 0x7788 <dtoa_prf+0xa4>
    777e:	9e e4       	ldi	r25, 0x4E	; 78
    7780:	d6 01       	movw	r26, r12
    7782:	9c 93       	st	X, r25
    7784:	21 e4       	ldi	r18, 0x41	; 65
    7786:	04 c0       	rjmp	.+8      	; 0x7790 <dtoa_prf+0xac>
    7788:	9e e6       	ldi	r25, 0x6E	; 110
    778a:	d6 01       	movw	r26, r12
    778c:	9c 93       	st	X, r25
    778e:	21 e6       	ldi	r18, 0x61	; 97
    7790:	11 96       	adiw	r26, 0x01	; 1
    7792:	2c 93       	st	X, r18
    7794:	91 83       	std	Z+1, r25	; 0x01
    7796:	32 96       	adiw	r30, 0x02	; 2
    7798:	98 2f       	mov	r25, r24
    779a:	df 01       	movw	r26, r30
    779c:	20 e2       	ldi	r18, 0x20	; 32
    779e:	02 c0       	rjmp	.+4      	; 0x77a4 <dtoa_prf+0xc0>
    77a0:	2d 93       	st	X+, r18
    77a2:	91 50       	subi	r25, 0x01	; 1
    77a4:	99 23       	and	r25, r25
    77a6:	e1 f7       	brne	.-8      	; 0x77a0 <dtoa_prf+0xbc>
    77a8:	3d c0       	rjmp	.+122    	; 0x7824 <dtoa_prf+0x140>
    77aa:	22 ff       	sbrs	r18, 2
    77ac:	41 c0       	rjmp	.+130    	; 0x7830 <dtoa_prf+0x14c>
    77ae:	ee 23       	and	r30, r30
    77b0:	11 f0       	breq	.+4      	; 0x77b6 <dtoa_prf+0xd2>
    77b2:	84 e0       	ldi	r24, 0x04	; 4
    77b4:	01 c0       	rjmp	.+2      	; 0x77b8 <dtoa_prf+0xd4>
    77b6:	83 e0       	ldi	r24, 0x03	; 3
    77b8:	8f 15       	cp	r24, r15
    77ba:	18 f4       	brcc	.+6      	; 0x77c2 <dtoa_prf+0xde>
    77bc:	f8 1a       	sub	r15, r24
    77be:	8f 2d       	mov	r24, r15
    77c0:	01 c0       	rjmp	.+2      	; 0x77c4 <dtoa_prf+0xe0>
    77c2:	80 e0       	ldi	r24, 0x00	; 0
    77c4:	e4 fc       	sbrc	r14, 4
    77c6:	0b c0       	rjmp	.+22     	; 0x77de <dtoa_prf+0xfa>
    77c8:	98 2f       	mov	r25, r24
    77ca:	d6 01       	movw	r26, r12
    77cc:	20 e2       	ldi	r18, 0x20	; 32
    77ce:	02 c0       	rjmp	.+4      	; 0x77d4 <dtoa_prf+0xf0>
    77d0:	2d 93       	st	X+, r18
    77d2:	91 50       	subi	r25, 0x01	; 1
    77d4:	99 23       	and	r25, r25
    77d6:	e1 f7       	brne	.-8      	; 0x77d0 <dtoa_prf+0xec>
    77d8:	c8 0e       	add	r12, r24
    77da:	d1 1c       	adc	r13, r1
    77dc:	80 e0       	ldi	r24, 0x00	; 0
    77de:	ee 23       	and	r30, r30
    77e0:	19 f0       	breq	.+6      	; 0x77e8 <dtoa_prf+0x104>
    77e2:	d6 01       	movw	r26, r12
    77e4:	ed 93       	st	X+, r30
    77e6:	6d 01       	movw	r12, r26
    77e8:	f6 01       	movw	r30, r12
    77ea:	31 96       	adiw	r30, 0x01	; 1
    77ec:	e2 fe       	sbrs	r14, 2
    77ee:	09 c0       	rjmp	.+18     	; 0x7802 <dtoa_prf+0x11e>
    77f0:	99 e4       	ldi	r25, 0x49	; 73
    77f2:	d6 01       	movw	r26, r12
    77f4:	9c 93       	st	X, r25
    77f6:	9e e4       	ldi	r25, 0x4E	; 78
    77f8:	11 96       	adiw	r26, 0x01	; 1
    77fa:	9c 93       	st	X, r25
    77fc:	11 97       	sbiw	r26, 0x01	; 1
    77fe:	96 e4       	ldi	r25, 0x46	; 70
    7800:	07 c0       	rjmp	.+14     	; 0x7810 <dtoa_prf+0x12c>
    7802:	99 e6       	ldi	r25, 0x69	; 105
    7804:	d6 01       	movw	r26, r12
    7806:	9c 93       	st	X, r25
    7808:	9e e6       	ldi	r25, 0x6E	; 110
    780a:	11 96       	adiw	r26, 0x01	; 1
    780c:	9c 93       	st	X, r25
    780e:	96 e6       	ldi	r25, 0x66	; 102
    7810:	91 83       	std	Z+1, r25	; 0x01
    7812:	32 96       	adiw	r30, 0x02	; 2
    7814:	98 2f       	mov	r25, r24
    7816:	df 01       	movw	r26, r30
    7818:	20 e2       	ldi	r18, 0x20	; 32
    781a:	02 c0       	rjmp	.+4      	; 0x7820 <dtoa_prf+0x13c>
    781c:	2d 93       	st	X+, r18
    781e:	91 50       	subi	r25, 0x01	; 1
    7820:	99 23       	and	r25, r25
    7822:	e1 f7       	brne	.-8      	; 0x781c <dtoa_prf+0x138>
    7824:	e8 0f       	add	r30, r24
    7826:	f1 1d       	adc	r31, r1
    7828:	10 82       	st	Z, r1
    782a:	2e ef       	ldi	r18, 0xFE	; 254
    782c:	3f ef       	ldi	r19, 0xFF	; 255
    782e:	ac c0       	rjmp	.+344    	; 0x7988 <dtoa_prf+0x2a4>
    7830:	41 e0       	ldi	r20, 0x01	; 1
    7832:	50 e0       	ldi	r21, 0x00	; 0
    7834:	ee 23       	and	r30, r30
    7836:	11 f4       	brne	.+4      	; 0x783c <dtoa_prf+0x158>
    7838:	40 e0       	ldi	r20, 0x00	; 0
    783a:	50 e0       	ldi	r21, 0x00	; 0
    783c:	18 16       	cp	r1, r24
    783e:	19 06       	cpc	r1, r25
    7840:	24 f4       	brge	.+8      	; 0x784a <dtoa_prf+0x166>
    7842:	bc 01       	movw	r22, r24
    7844:	6f 5f       	subi	r22, 0xFF	; 255
    7846:	7f 4f       	sbci	r23, 0xFF	; 255
    7848:	02 c0       	rjmp	.+4      	; 0x784e <dtoa_prf+0x16a>
    784a:	61 e0       	ldi	r22, 0x01	; 1
    784c:	70 e0       	ldi	r23, 0x00	; 0
    784e:	64 0f       	add	r22, r20
    7850:	75 1f       	adc	r23, r21
    7852:	11 23       	and	r17, r17
    7854:	29 f0       	breq	.+10     	; 0x7860 <dtoa_prf+0x17c>
    7856:	41 2f       	mov	r20, r17
    7858:	50 e0       	ldi	r21, 0x00	; 0
    785a:	4f 5f       	subi	r20, 0xFF	; 255
    785c:	5f 4f       	sbci	r21, 0xFF	; 255
    785e:	02 c0       	rjmp	.+4      	; 0x7864 <dtoa_prf+0x180>
    7860:	40 e0       	ldi	r20, 0x00	; 0
    7862:	50 e0       	ldi	r21, 0x00	; 0
    7864:	46 0f       	add	r20, r22
    7866:	57 1f       	adc	r21, r23
    7868:	6f 2d       	mov	r22, r15
    786a:	70 e0       	ldi	r23, 0x00	; 0
    786c:	46 17       	cp	r20, r22
    786e:	57 07       	cpc	r21, r23
    7870:	1c f4       	brge	.+6      	; 0x7878 <dtoa_prf+0x194>
    7872:	0f 2d       	mov	r16, r15
    7874:	04 1b       	sub	r16, r20
    7876:	01 c0       	rjmp	.+2      	; 0x787a <dtoa_prf+0x196>
    7878:	00 e0       	ldi	r16, 0x00	; 0
    787a:	ff 24       	eor	r15, r15
    787c:	a7 01       	movw	r20, r14
    787e:	40 71       	andi	r20, 0x10	; 16
    7880:	50 70       	andi	r21, 0x00	; 0
    7882:	e4 fc       	sbrc	r14, 4
    7884:	0d c0       	rjmp	.+26     	; 0x78a0 <dtoa_prf+0x1bc>
    7886:	e3 fc       	sbrc	r14, 3
    7888:	0b c0       	rjmp	.+22     	; 0x78a0 <dtoa_prf+0x1bc>
    788a:	60 2f       	mov	r22, r16
    788c:	d6 01       	movw	r26, r12
    788e:	70 e2       	ldi	r23, 0x20	; 32
    7890:	02 c0       	rjmp	.+4      	; 0x7896 <dtoa_prf+0x1b2>
    7892:	7d 93       	st	X+, r23
    7894:	61 50       	subi	r22, 0x01	; 1
    7896:	66 23       	and	r22, r22
    7898:	e1 f7       	brne	.-8      	; 0x7892 <dtoa_prf+0x1ae>
    789a:	c0 0e       	add	r12, r16
    789c:	d1 1c       	adc	r13, r1
    789e:	00 e0       	ldi	r16, 0x00	; 0
    78a0:	ee 23       	and	r30, r30
    78a2:	19 f0       	breq	.+6      	; 0x78aa <dtoa_prf+0x1c6>
    78a4:	d6 01       	movw	r26, r12
    78a6:	ed 93       	st	X+, r30
    78a8:	6d 01       	movw	r12, r26
    78aa:	41 15       	cp	r20, r1
    78ac:	51 05       	cpc	r21, r1
    78ae:	59 f4       	brne	.+22     	; 0x78c6 <dtoa_prf+0x1e2>
    78b0:	40 2f       	mov	r20, r16
    78b2:	f6 01       	movw	r30, r12
    78b4:	50 e3       	ldi	r21, 0x30	; 48
    78b6:	02 c0       	rjmp	.+4      	; 0x78bc <dtoa_prf+0x1d8>
    78b8:	51 93       	st	Z+, r21
    78ba:	41 50       	subi	r20, 0x01	; 1
    78bc:	44 23       	and	r20, r20
    78be:	e1 f7       	brne	.-8      	; 0x78b8 <dtoa_prf+0x1d4>
    78c0:	c0 0e       	add	r12, r16
    78c2:	d1 1c       	adc	r13, r1
    78c4:	00 e0       	ldi	r16, 0x00	; 0
    78c6:	b8 0e       	add	r11, r24
    78c8:	fa 80       	ldd	r15, Y+2	; 0x02
    78ca:	a9 01       	movw	r20, r18
    78cc:	40 71       	andi	r20, 0x10	; 16
    78ce:	50 70       	andi	r21, 0x00	; 0
    78d0:	24 ff       	sbrs	r18, 4
    78d2:	04 c0       	rjmp	.+8      	; 0x78dc <dtoa_prf+0x1f8>
    78d4:	bf 2d       	mov	r27, r15
    78d6:	b1 33       	cpi	r27, 0x31	; 49
    78d8:	09 f4       	brne	.+2      	; 0x78dc <dtoa_prf+0x1f8>
    78da:	ba 94       	dec	r11
    78dc:	1b 14       	cp	r1, r11
    78de:	2c f4       	brge	.+10     	; 0x78ea <dtoa_prf+0x206>
    78e0:	ab 2d       	mov	r26, r11
    78e2:	a9 30       	cpi	r26, 0x09	; 9
    78e4:	18 f0       	brcs	.+6      	; 0x78ec <dtoa_prf+0x208>
    78e6:	a8 e0       	ldi	r26, 0x08	; 8
    78e8:	01 c0       	rjmp	.+2      	; 0x78ec <dtoa_prf+0x208>
    78ea:	a1 e0       	ldi	r26, 0x01	; 1
    78ec:	9c 01       	movw	r18, r24
    78ee:	97 ff       	sbrs	r25, 7
    78f0:	02 c0       	rjmp	.+4      	; 0x78f6 <dtoa_prf+0x212>
    78f2:	20 e0       	ldi	r18, 0x00	; 0
    78f4:	30 e0       	ldi	r19, 0x00	; 0
    78f6:	bc 01       	movw	r22, r24
    78f8:	6f 5f       	subi	r22, 0xFF	; 255
    78fa:	7f 4f       	sbci	r23, 0xFF	; 255
    78fc:	62 1b       	sub	r22, r18
    78fe:	73 0b       	sbc	r23, r19
    7900:	fe 01       	movw	r30, r28
    7902:	31 96       	adiw	r30, 0x01	; 1
    7904:	e6 0f       	add	r30, r22
    7906:	f7 1f       	adc	r31, r23
    7908:	6e e2       	ldi	r22, 0x2E	; 46
    790a:	e6 2e       	mov	r14, r22
    790c:	bc 01       	movw	r22, r24
    790e:	6a 1b       	sub	r22, r26
    7910:	71 09       	sbc	r23, r1
    7912:	a1 2f       	mov	r26, r17
    7914:	b0 e0       	ldi	r27, 0x00	; 0
    7916:	aa 24       	eor	r10, r10
    7918:	bb 24       	eor	r11, r11
    791a:	aa 1a       	sub	r10, r26
    791c:	bb 0a       	sbc	r11, r27
    791e:	1f ef       	ldi	r17, 0xFF	; 255
    7920:	2f 3f       	cpi	r18, 0xFF	; 255
    7922:	31 07       	cpc	r19, r17
    7924:	19 f4       	brne	.+6      	; 0x792c <dtoa_prf+0x248>
    7926:	d6 01       	movw	r26, r12
    7928:	ed 92       	st	X+, r14
    792a:	6d 01       	movw	r12, r26
    792c:	82 17       	cp	r24, r18
    792e:	93 07       	cpc	r25, r19
    7930:	2c f0       	brlt	.+10     	; 0x793c <dtoa_prf+0x258>
    7932:	62 17       	cp	r22, r18
    7934:	73 07       	cpc	r23, r19
    7936:	14 f4       	brge	.+4      	; 0x793c <dtoa_prf+0x258>
    7938:	10 81       	ld	r17, Z
    793a:	01 c0       	rjmp	.+2      	; 0x793e <dtoa_prf+0x25a>
    793c:	10 e3       	ldi	r17, 0x30	; 48
    793e:	21 50       	subi	r18, 0x01	; 1
    7940:	30 40       	sbci	r19, 0x00	; 0
    7942:	31 96       	adiw	r30, 0x01	; 1
    7944:	2a 15       	cp	r18, r10
    7946:	3b 05       	cpc	r19, r11
    7948:	24 f0       	brlt	.+8      	; 0x7952 <dtoa_prf+0x26e>
    794a:	d6 01       	movw	r26, r12
    794c:	1d 93       	st	X+, r17
    794e:	6d 01       	movw	r12, r26
    7950:	e6 cf       	rjmp	.-52     	; 0x791e <dtoa_prf+0x23a>
    7952:	28 17       	cp	r18, r24
    7954:	39 07       	cpc	r19, r25
    7956:	49 f4       	brne	.+18     	; 0x796a <dtoa_prf+0x286>
    7958:	bf 2d       	mov	r27, r15
    795a:	b6 33       	cpi	r27, 0x36	; 54
    795c:	28 f4       	brcc	.+10     	; 0x7968 <dtoa_prf+0x284>
    795e:	b5 33       	cpi	r27, 0x35	; 53
    7960:	21 f4       	brne	.+8      	; 0x796a <dtoa_prf+0x286>
    7962:	41 15       	cp	r20, r1
    7964:	51 05       	cpc	r21, r1
    7966:	09 f4       	brne	.+2      	; 0x796a <dtoa_prf+0x286>
    7968:	11 e3       	ldi	r17, 0x31	; 49
    796a:	f6 01       	movw	r30, r12
    796c:	11 93       	st	Z+, r17
    796e:	80 2f       	mov	r24, r16
    7970:	df 01       	movw	r26, r30
    7972:	90 e2       	ldi	r25, 0x20	; 32
    7974:	02 c0       	rjmp	.+4      	; 0x797a <dtoa_prf+0x296>
    7976:	9d 93       	st	X+, r25
    7978:	81 50       	subi	r24, 0x01	; 1
    797a:	88 23       	and	r24, r24
    797c:	e1 f7       	brne	.-8      	; 0x7976 <dtoa_prf+0x292>
    797e:	e0 0f       	add	r30, r16
    7980:	f1 1d       	adc	r31, r1
    7982:	10 82       	st	Z, r1
    7984:	20 e0       	ldi	r18, 0x00	; 0
    7986:	30 e0       	ldi	r19, 0x00	; 0
    7988:	c9 01       	movw	r24, r18
    798a:	29 96       	adiw	r28, 0x09	; 9
    798c:	ea e0       	ldi	r30, 0x0A	; 10
    798e:	0c 94 d5 3d 	jmp	0x7baa	; 0x7baa <__epilogue_restores__+0x10>

00007992 <__ftoa_engine>:
    7992:	28 30       	cpi	r18, 0x08	; 8
    7994:	08 f0       	brcs	.+2      	; 0x7998 <__ftoa_engine+0x6>
    7996:	27 e0       	ldi	r18, 0x07	; 7
    7998:	33 27       	eor	r19, r19
    799a:	da 01       	movw	r26, r20
    799c:	99 0f       	add	r25, r25
    799e:	31 1d       	adc	r19, r1
    79a0:	87 fd       	sbrc	r24, 7
    79a2:	91 60       	ori	r25, 0x01	; 1
    79a4:	00 96       	adiw	r24, 0x00	; 0
    79a6:	61 05       	cpc	r22, r1
    79a8:	71 05       	cpc	r23, r1
    79aa:	39 f4       	brne	.+14     	; 0x79ba <__ftoa_engine+0x28>
    79ac:	32 60       	ori	r19, 0x02	; 2
    79ae:	2e 5f       	subi	r18, 0xFE	; 254
    79b0:	3d 93       	st	X+, r19
    79b2:	30 e3       	ldi	r19, 0x30	; 48
    79b4:	2a 95       	dec	r18
    79b6:	e1 f7       	brne	.-8      	; 0x79b0 <__ftoa_engine+0x1e>
    79b8:	08 95       	ret
    79ba:	9f 3f       	cpi	r25, 0xFF	; 255
    79bc:	30 f0       	brcs	.+12     	; 0x79ca <__ftoa_engine+0x38>
    79be:	80 38       	cpi	r24, 0x80	; 128
    79c0:	71 05       	cpc	r23, r1
    79c2:	61 05       	cpc	r22, r1
    79c4:	09 f0       	breq	.+2      	; 0x79c8 <__ftoa_engine+0x36>
    79c6:	3c 5f       	subi	r19, 0xFC	; 252
    79c8:	3c 5f       	subi	r19, 0xFC	; 252
    79ca:	3d 93       	st	X+, r19
    79cc:	91 30       	cpi	r25, 0x01	; 1
    79ce:	08 f0       	brcs	.+2      	; 0x79d2 <__ftoa_engine+0x40>
    79d0:	80 68       	ori	r24, 0x80	; 128
    79d2:	91 1d       	adc	r25, r1
    79d4:	df 93       	push	r29
    79d6:	cf 93       	push	r28
    79d8:	1f 93       	push	r17
    79da:	0f 93       	push	r16
    79dc:	ff 92       	push	r15
    79de:	ef 92       	push	r14
    79e0:	19 2f       	mov	r17, r25
    79e2:	98 7f       	andi	r25, 0xF8	; 248
    79e4:	96 95       	lsr	r25
    79e6:	e9 2f       	mov	r30, r25
    79e8:	96 95       	lsr	r25
    79ea:	96 95       	lsr	r25
    79ec:	e9 0f       	add	r30, r25
    79ee:	ff 27       	eor	r31, r31
    79f0:	ec 55       	subi	r30, 0x5C	; 92
    79f2:	fe 4e       	sbci	r31, 0xEE	; 238
    79f4:	99 27       	eor	r25, r25
    79f6:	33 27       	eor	r19, r19
    79f8:	ee 24       	eor	r14, r14
    79fa:	ff 24       	eor	r15, r15
    79fc:	a7 01       	movw	r20, r14
    79fe:	e7 01       	movw	r28, r14
    7a00:	05 90       	lpm	r0, Z+
    7a02:	08 94       	sec
    7a04:	07 94       	ror	r0
    7a06:	28 f4       	brcc	.+10     	; 0x7a12 <__ftoa_engine+0x80>
    7a08:	36 0f       	add	r19, r22
    7a0a:	e7 1e       	adc	r14, r23
    7a0c:	f8 1e       	adc	r15, r24
    7a0e:	49 1f       	adc	r20, r25
    7a10:	51 1d       	adc	r21, r1
    7a12:	66 0f       	add	r22, r22
    7a14:	77 1f       	adc	r23, r23
    7a16:	88 1f       	adc	r24, r24
    7a18:	99 1f       	adc	r25, r25
    7a1a:	06 94       	lsr	r0
    7a1c:	a1 f7       	brne	.-24     	; 0x7a06 <__ftoa_engine+0x74>
    7a1e:	05 90       	lpm	r0, Z+
    7a20:	07 94       	ror	r0
    7a22:	28 f4       	brcc	.+10     	; 0x7a2e <__ftoa_engine+0x9c>
    7a24:	e7 0e       	add	r14, r23
    7a26:	f8 1e       	adc	r15, r24
    7a28:	49 1f       	adc	r20, r25
    7a2a:	56 1f       	adc	r21, r22
    7a2c:	c1 1d       	adc	r28, r1
    7a2e:	77 0f       	add	r23, r23
    7a30:	88 1f       	adc	r24, r24
    7a32:	99 1f       	adc	r25, r25
    7a34:	66 1f       	adc	r22, r22
    7a36:	06 94       	lsr	r0
    7a38:	a1 f7       	brne	.-24     	; 0x7a22 <__ftoa_engine+0x90>
    7a3a:	05 90       	lpm	r0, Z+
    7a3c:	07 94       	ror	r0
    7a3e:	28 f4       	brcc	.+10     	; 0x7a4a <__ftoa_engine+0xb8>
    7a40:	f8 0e       	add	r15, r24
    7a42:	49 1f       	adc	r20, r25
    7a44:	56 1f       	adc	r21, r22
    7a46:	c7 1f       	adc	r28, r23
    7a48:	d1 1d       	adc	r29, r1
    7a4a:	88 0f       	add	r24, r24
    7a4c:	99 1f       	adc	r25, r25
    7a4e:	66 1f       	adc	r22, r22
    7a50:	77 1f       	adc	r23, r23
    7a52:	06 94       	lsr	r0
    7a54:	a1 f7       	brne	.-24     	; 0x7a3e <__ftoa_engine+0xac>
    7a56:	05 90       	lpm	r0, Z+
    7a58:	07 94       	ror	r0
    7a5a:	20 f4       	brcc	.+8      	; 0x7a64 <__ftoa_engine+0xd2>
    7a5c:	49 0f       	add	r20, r25
    7a5e:	56 1f       	adc	r21, r22
    7a60:	c7 1f       	adc	r28, r23
    7a62:	d8 1f       	adc	r29, r24
    7a64:	99 0f       	add	r25, r25
    7a66:	66 1f       	adc	r22, r22
    7a68:	77 1f       	adc	r23, r23
    7a6a:	88 1f       	adc	r24, r24
    7a6c:	06 94       	lsr	r0
    7a6e:	a9 f7       	brne	.-22     	; 0x7a5a <__ftoa_engine+0xc8>
    7a70:	84 91       	lpm	r24, Z+
    7a72:	10 95       	com	r17
    7a74:	17 70       	andi	r17, 0x07	; 7
    7a76:	41 f0       	breq	.+16     	; 0x7a88 <__ftoa_engine+0xf6>
    7a78:	d6 95       	lsr	r29
    7a7a:	c7 95       	ror	r28
    7a7c:	57 95       	ror	r21
    7a7e:	47 95       	ror	r20
    7a80:	f7 94       	ror	r15
    7a82:	e7 94       	ror	r14
    7a84:	1a 95       	dec	r17
    7a86:	c1 f7       	brne	.-16     	; 0x7a78 <__ftoa_engine+0xe6>
    7a88:	ea e4       	ldi	r30, 0x4A	; 74
    7a8a:	f1 e1       	ldi	r31, 0x11	; 17
    7a8c:	68 94       	set
    7a8e:	15 90       	lpm	r1, Z+
    7a90:	15 91       	lpm	r17, Z+
    7a92:	35 91       	lpm	r19, Z+
    7a94:	65 91       	lpm	r22, Z+
    7a96:	95 91       	lpm	r25, Z+
    7a98:	05 90       	lpm	r0, Z+
    7a9a:	7f e2       	ldi	r23, 0x2F	; 47
    7a9c:	73 95       	inc	r23
    7a9e:	e1 18       	sub	r14, r1
    7aa0:	f1 0a       	sbc	r15, r17
    7aa2:	43 0b       	sbc	r20, r19
    7aa4:	56 0b       	sbc	r21, r22
    7aa6:	c9 0b       	sbc	r28, r25
    7aa8:	d0 09       	sbc	r29, r0
    7aaa:	c0 f7       	brcc	.-16     	; 0x7a9c <__ftoa_engine+0x10a>
    7aac:	e1 0c       	add	r14, r1
    7aae:	f1 1e       	adc	r15, r17
    7ab0:	43 1f       	adc	r20, r19
    7ab2:	56 1f       	adc	r21, r22
    7ab4:	c9 1f       	adc	r28, r25
    7ab6:	d0 1d       	adc	r29, r0
    7ab8:	7e f4       	brtc	.+30     	; 0x7ad8 <__ftoa_engine+0x146>
    7aba:	70 33       	cpi	r23, 0x30	; 48
    7abc:	11 f4       	brne	.+4      	; 0x7ac2 <__ftoa_engine+0x130>
    7abe:	8a 95       	dec	r24
    7ac0:	e6 cf       	rjmp	.-52     	; 0x7a8e <__ftoa_engine+0xfc>
    7ac2:	e8 94       	clt
    7ac4:	01 50       	subi	r16, 0x01	; 1
    7ac6:	30 f0       	brcs	.+12     	; 0x7ad4 <__ftoa_engine+0x142>
    7ac8:	08 0f       	add	r16, r24
    7aca:	0a f4       	brpl	.+2      	; 0x7ace <__ftoa_engine+0x13c>
    7acc:	00 27       	eor	r16, r16
    7ace:	02 17       	cp	r16, r18
    7ad0:	08 f4       	brcc	.+2      	; 0x7ad4 <__ftoa_engine+0x142>
    7ad2:	20 2f       	mov	r18, r16
    7ad4:	23 95       	inc	r18
    7ad6:	02 2f       	mov	r16, r18
    7ad8:	7a 33       	cpi	r23, 0x3A	; 58
    7ada:	28 f0       	brcs	.+10     	; 0x7ae6 <__ftoa_engine+0x154>
    7adc:	79 e3       	ldi	r23, 0x39	; 57
    7ade:	7d 93       	st	X+, r23
    7ae0:	2a 95       	dec	r18
    7ae2:	e9 f7       	brne	.-6      	; 0x7ade <__ftoa_engine+0x14c>
    7ae4:	10 c0       	rjmp	.+32     	; 0x7b06 <__ftoa_engine+0x174>
    7ae6:	7d 93       	st	X+, r23
    7ae8:	2a 95       	dec	r18
    7aea:	89 f6       	brne	.-94     	; 0x7a8e <__ftoa_engine+0xfc>
    7aec:	06 94       	lsr	r0
    7aee:	97 95       	ror	r25
    7af0:	67 95       	ror	r22
    7af2:	37 95       	ror	r19
    7af4:	17 95       	ror	r17
    7af6:	17 94       	ror	r1
    7af8:	e1 18       	sub	r14, r1
    7afa:	f1 0a       	sbc	r15, r17
    7afc:	43 0b       	sbc	r20, r19
    7afe:	56 0b       	sbc	r21, r22
    7b00:	c9 0b       	sbc	r28, r25
    7b02:	d0 09       	sbc	r29, r0
    7b04:	98 f0       	brcs	.+38     	; 0x7b2c <__ftoa_engine+0x19a>
    7b06:	23 95       	inc	r18
    7b08:	7e 91       	ld	r23, -X
    7b0a:	73 95       	inc	r23
    7b0c:	7a 33       	cpi	r23, 0x3A	; 58
    7b0e:	08 f0       	brcs	.+2      	; 0x7b12 <__ftoa_engine+0x180>
    7b10:	70 e3       	ldi	r23, 0x30	; 48
    7b12:	7c 93       	st	X, r23
    7b14:	20 13       	cpse	r18, r16
    7b16:	b8 f7       	brcc	.-18     	; 0x7b06 <__ftoa_engine+0x174>
    7b18:	7e 91       	ld	r23, -X
    7b1a:	70 61       	ori	r23, 0x10	; 16
    7b1c:	7d 93       	st	X+, r23
    7b1e:	30 f0       	brcs	.+12     	; 0x7b2c <__ftoa_engine+0x19a>
    7b20:	83 95       	inc	r24
    7b22:	71 e3       	ldi	r23, 0x31	; 49
    7b24:	7d 93       	st	X+, r23
    7b26:	70 e3       	ldi	r23, 0x30	; 48
    7b28:	2a 95       	dec	r18
    7b2a:	e1 f7       	brne	.-8      	; 0x7b24 <__ftoa_engine+0x192>
    7b2c:	11 24       	eor	r1, r1
    7b2e:	ef 90       	pop	r14
    7b30:	ff 90       	pop	r15
    7b32:	0f 91       	pop	r16
    7b34:	1f 91       	pop	r17
    7b36:	cf 91       	pop	r28
    7b38:	df 91       	pop	r29
    7b3a:	99 27       	eor	r25, r25
    7b3c:	87 fd       	sbrc	r24, 7
    7b3e:	90 95       	com	r25
    7b40:	08 95       	ret

00007b42 <strrev>:
    7b42:	dc 01       	movw	r26, r24
    7b44:	fc 01       	movw	r30, r24
    7b46:	67 2f       	mov	r22, r23
    7b48:	71 91       	ld	r23, Z+
    7b4a:	77 23       	and	r23, r23
    7b4c:	e1 f7       	brne	.-8      	; 0x7b46 <strrev+0x4>
    7b4e:	32 97       	sbiw	r30, 0x02	; 2
    7b50:	04 c0       	rjmp	.+8      	; 0x7b5a <strrev+0x18>
    7b52:	7c 91       	ld	r23, X
    7b54:	6d 93       	st	X+, r22
    7b56:	70 83       	st	Z, r23
    7b58:	62 91       	ld	r22, -Z
    7b5a:	ae 17       	cp	r26, r30
    7b5c:	bf 07       	cpc	r27, r31
    7b5e:	c8 f3       	brcs	.-14     	; 0x7b52 <strrev+0x10>
    7b60:	08 95       	ret

00007b62 <__prologue_saves__>:
    7b62:	2f 92       	push	r2
    7b64:	3f 92       	push	r3
    7b66:	4f 92       	push	r4
    7b68:	5f 92       	push	r5
    7b6a:	6f 92       	push	r6
    7b6c:	7f 92       	push	r7
    7b6e:	8f 92       	push	r8
    7b70:	9f 92       	push	r9
    7b72:	af 92       	push	r10
    7b74:	bf 92       	push	r11
    7b76:	cf 92       	push	r12
    7b78:	df 92       	push	r13
    7b7a:	ef 92       	push	r14
    7b7c:	ff 92       	push	r15
    7b7e:	0f 93       	push	r16
    7b80:	1f 93       	push	r17
    7b82:	cf 93       	push	r28
    7b84:	df 93       	push	r29
    7b86:	cd b7       	in	r28, 0x3d	; 61
    7b88:	de b7       	in	r29, 0x3e	; 62
    7b8a:	ca 1b       	sub	r28, r26
    7b8c:	db 0b       	sbc	r29, r27
    7b8e:	0f b6       	in	r0, 0x3f	; 63
    7b90:	f8 94       	cli
    7b92:	de bf       	out	0x3e, r29	; 62
    7b94:	0f be       	out	0x3f, r0	; 63
    7b96:	cd bf       	out	0x3d, r28	; 61
    7b98:	09 94       	ijmp

00007b9a <__epilogue_restores__>:
    7b9a:	2a 88       	ldd	r2, Y+18	; 0x12
    7b9c:	39 88       	ldd	r3, Y+17	; 0x11
    7b9e:	48 88       	ldd	r4, Y+16	; 0x10
    7ba0:	5f 84       	ldd	r5, Y+15	; 0x0f
    7ba2:	6e 84       	ldd	r6, Y+14	; 0x0e
    7ba4:	7d 84       	ldd	r7, Y+13	; 0x0d
    7ba6:	8c 84       	ldd	r8, Y+12	; 0x0c
    7ba8:	9b 84       	ldd	r9, Y+11	; 0x0b
    7baa:	aa 84       	ldd	r10, Y+10	; 0x0a
    7bac:	b9 84       	ldd	r11, Y+9	; 0x09
    7bae:	c8 84       	ldd	r12, Y+8	; 0x08
    7bb0:	df 80       	ldd	r13, Y+7	; 0x07
    7bb2:	ee 80       	ldd	r14, Y+6	; 0x06
    7bb4:	fd 80       	ldd	r15, Y+5	; 0x05
    7bb6:	0c 81       	ldd	r16, Y+4	; 0x04
    7bb8:	1b 81       	ldd	r17, Y+3	; 0x03
    7bba:	aa 81       	ldd	r26, Y+2	; 0x02
    7bbc:	b9 81       	ldd	r27, Y+1	; 0x01
    7bbe:	ce 0f       	add	r28, r30
    7bc0:	d1 1d       	adc	r29, r1
    7bc2:	0f b6       	in	r0, 0x3f	; 63
    7bc4:	f8 94       	cli
    7bc6:	de bf       	out	0x3e, r29	; 62
    7bc8:	0f be       	out	0x3f, r0	; 63
    7bca:	cd bf       	out	0x3d, r28	; 61
    7bcc:	ed 01       	movw	r28, r26
    7bce:	08 95       	ret

00007bd0 <_exit>:
    7bd0:	f8 94       	cli

00007bd2 <__stop_program>:
    7bd2:	ff cf       	rjmp	.-2      	; 0x7bd2 <__stop_program>
