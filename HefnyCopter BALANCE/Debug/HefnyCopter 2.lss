
HefnyCopter 2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000022  00800100  00007b06  00007b9a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00007b06  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000725  00800122  00800122  00007bbc  2**0
                  ALLOC
  3 .stab         00003ea0  00000000  00000000  00007bbc  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00001073  00000000  00000000  0000ba5c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000338  00000000  00000000  0000cacf  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00003f0f  00000000  00000000  0000ce07  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000d6fd  00000000  00000000  00010d16  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00002576  00000000  00000000  0001e413  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00006595  00000000  00000000  00020989  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000a40  00000000  00000000  00026f20  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000019d8  00000000  00000000  00027960  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00002139  00000000  00000000  00029338  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubtypes 00000b71  00000000  00000000  0002b471  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000130  00000000  00000000  0002bfe2  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 89 0b 	jmp	0x1712	; 0x1712 <__ctors_end>
       4:	0c 94 8a 0a 	jmp	0x1514	; 0x1514 <__vector_1>
       8:	0c 94 4c 0a 	jmp	0x1498	; 0x1498 <__vector_2>
       c:	0c 94 f9 0a 	jmp	0x15f2	; 0x15f2 <__vector_3>
      10:	0c 94 a6 0b 	jmp	0x174c	; 0x174c <__bad_interrupt>
      14:	0c 94 4d 0b 	jmp	0x169a	; 0x169a <__vector_5>
      18:	0c 94 b3 09 	jmp	0x1366	; 0x1366 <__vector_6>
      1c:	0c 94 c8 0a 	jmp	0x1590	; 0x1590 <__vector_7>
      20:	0c 94 a6 0b 	jmp	0x174c	; 0x174c <__bad_interrupt>
      24:	0c 94 a6 0b 	jmp	0x174c	; 0x174c <__bad_interrupt>
      28:	0c 94 a6 0b 	jmp	0x174c	; 0x174c <__bad_interrupt>
      2c:	0c 94 3d 10 	jmp	0x207a	; 0x207a <__vector_11>
      30:	0c 94 a6 0b 	jmp	0x174c	; 0x174c <__bad_interrupt>
      34:	0c 94 a6 0b 	jmp	0x174c	; 0x174c <__bad_interrupt>
      38:	0c 94 a6 0b 	jmp	0x174c	; 0x174c <__bad_interrupt>
      3c:	0c 94 26 10 	jmp	0x204c	; 0x204c <__vector_15>
      40:	0c 94 a6 0b 	jmp	0x174c	; 0x174c <__bad_interrupt>
      44:	0c 94 a6 0b 	jmp	0x174c	; 0x174c <__bad_interrupt>
      48:	0c 94 5a 09 	jmp	0x12b4	; 0x12b4 <__vector_18>
      4c:	0c 94 a6 0b 	jmp	0x174c	; 0x174c <__bad_interrupt>
      50:	0c 94 a6 0b 	jmp	0x174c	; 0x174c <__bad_interrupt>
      54:	0c 94 a6 0b 	jmp	0x174c	; 0x174c <__bad_interrupt>
      58:	0c 94 a6 0b 	jmp	0x174c	; 0x174c <__bad_interrupt>
      5c:	0c 94 a6 0b 	jmp	0x174c	; 0x174c <__bad_interrupt>
      60:	0c 94 c4 29 	jmp	0x5388	; 0x5388 <__vector_24>
      64:	0c 94 a6 0b 	jmp	0x174c	; 0x174c <__bad_interrupt>
      68:	0c 94 a6 0b 	jmp	0x174c	; 0x174c <__bad_interrupt>
      6c:	0c 94 a6 0b 	jmp	0x174c	; 0x174c <__bad_interrupt>
      70:	0c 94 0e 11 	jmp	0x221c	; 0x221c <__vector_28>
      74:	0c 94 a6 0b 	jmp	0x174c	; 0x174c <__bad_interrupt>
      78:	0c 94 a6 0b 	jmp	0x174c	; 0x174c <__bad_interrupt>
      7c:	05 a8       	ldd	r0, Z+53	; 0x35
      7e:	4c cd       	rjmp	.-1384   	; 0xfffffb18 <__eeprom_end+0xff7efb18>
      80:	b2 d4       	rcall	.+2404   	; 0x9e6 <glyBall+0xf>
      82:	4e b9       	out	0x0e, r20	; 14
      84:	38 36       	cpi	r19, 0x68	; 104
      86:	a9 02       	muls	r26, r25
      88:	0c 50       	subi	r16, 0x0C	; 12
      8a:	b9 91       	ld	r27, Y+
      8c:	86 88       	ldd	r8, Z+22	; 0x16
      8e:	08 3c       	cpi	r16, 0xC8	; 200
      90:	a6 aa       	std	Z+54, r10	; 0x36
      92:	aa 2a       	or	r10, r26
      94:	be 00       	.word	0x00be	; ????
      96:	00 00       	nop
      98:	80 3f       	cpi	r24, 0xF0	; 240

0000009a <_initSeq>:
      9a:	a2 a0 c8 40 a6 a4 2f 24 81 20 af 00                 ...@../$. ..

000000a6 <masks.1995>:
      a6:	01 02 04 08 10 20 40 80                             ..... @.

000000ae <defaultConfig>:
      ae:	fe 90 01 00 ff 00 00 03 00 01 00 00 00 96 08 00     ................
      be:	19 00 64 00 00 00 00 00 fd ff 14 00 00 00 19 00     ..d.............
      ce:	64 00 00 00 00 00 fd ff 14 00 00 00 32 00 5a 00     d...........2.Z.
      de:	32 00 5a 00 00 00 14 00 c8 00 0a 00 5a 00 14 00     2.Z.........Z...
      ee:	0f 00 fe ff 32 00 e3 03 0a 00 5a 00 14 00 0f 00     ....2.....Z.....
      fe:	fe ff 32 00 e3 03 0f 00 1e 00 00 00 00 00 00 00     ..2.............
     10e:	00 00 58 02 0f 00 19 00 00 00 00 00 00 00 00 00     ..X.............
	...
     172:	00 00 00 01 00                                      .....

00000177 <font12x16>:
     177:	0c 10 9f 11                                         ....

0000017b <_font12x16map>:
	...
     19b:	7c 00 ff 33 ff 33 7c 00 00 00 00 00 00 00 00 00     |..3.3|.........
     1ab:	00 00 00 00 00 00 3c 00 3c 00 00 00 00 00 3c 00     ......<.<.....<.
     1bb:	3c 00 00 00 00 00 00 00 00 00 00 02 10 1e 90 1f     <...............
     1cb:	f0 03 7e 02 1e 1e 90 1f f0 03 7e 02 1e 00 10 00     ..~.......~.....
     1db:	00 00 00 00 78 04 fc 0c cc 0c ff 3f ff 3f cc 0c     ....x......?.?..
     1eb:	cc 0f 88 07 00 00 00 00 00 00 00 30 38 38 38 1c     ...........0888.
     1fb:	38 0e 00 07 80 03 c0 01 e0 38 70 38 38 38 1c 00     8........8p888..
     20b:	00 00 00 00 00 1f b8 3f fc 31 c6 21 e2 37 3e 1e     .......?.1.!.7>.
     21b:	1c 1c 00 36 00 22 00 00 00 00 00 00 00 00 00 00     ...6."..........
     22b:	27 00 3f 00 1f 00 00 00 00 00 00 00 00 00 00 00     '.?.............
     23b:	00 00 00 00 00 00 f0 03 fc 0f fe 1f 07 38 01 20     .............8. 
     24b:	01 20 00 00 00 00 00 00 00 00 00 00 00 00 01 20     . ............. 
     25b:	01 20 07 38 fe 1f fc 0f f0 03 00 00 00 00 00 00     . .8............
     26b:	00 00 00 00 98 0c b8 0e e0 03 f8 0f f8 0f e0 03     ................
     27b:	b8 0e 98 0c 00 00 00 00 00 00 00 00 80 01 80 01     ................
     28b:	80 01 f0 0f f0 0f 80 01 80 01 80 01 00 00 00 00     ................
	...
     2a3:	00 b8 00 f8 00 78 00 00 00 00 00 00 00 00 00 00     .....x..........
     2b3:	00 00 00 00 80 01 80 01 80 01 80 01 80 01 80 01     ................
     2c3:	80 01 80 01 00 00 00 00 00 00 00 00 00 00 00 00     ................
     2d3:	00 38 00 38 00 38 00 00 00 00 00 00 00 00 00 00     .8.8.8..........
     2e3:	00 00 00 18 00 1c 00 0e 00 07 80 03 c0 01 e0 00     ................
     2f3:	70 00 38 00 1c 00 0e 00 00 00 f8 07 fe 1f 06 1e     p.8.............
     303:	03 33 83 31 c3 30 63 30 33 30 1e 18 fe 1f f8 07     .3.1.0c030......
     313:	00 00 00 00 00 00 0c 30 0c 30 0e 30 ff 3f ff 3f     .......0.0.0.?.?
     323:	00 30 00 30 00 30 00 00 00 00 1c 30 1e 38 07 3c     .0.0.0.....0.8.<
     333:	03 3e 03 37 83 33 c3 31 e3 30 77 30 3e 30 1c 30     .>.7.3.1.0w0>0.0
     343:	00 00 0c 0c 0e 1c 07 38 c3 30 c3 30 c3 30 c3 30     .......8.0.0.0.0
     353:	c3 30 e7 39 7e 1f 3c 0e 00 00 c0 03 e0 03 70 03     .0.9~.<.......p.
     363:	38 03 1c 03 0e 03 07 03 ff 3f ff 3f 00 03 00 03     8........?.?....
     373:	00 00 3f 0c 7f 1c 63 38 63 30 63 30 63 30 63 30     ..?...c8c0c0c0c0
     383:	63 30 e3 38 c3 1f 83 0f 00 00 c0 0f f0 1f f8 39     c0.8...........9
     393:	dc 30 ce 30 c7 30 c3 30 c3 30 c3 39 80 1f 00 0f     .0.0.0.0.0.9....
     3a3:	00 00 03 00 03 00 03 00 03 30 03 3c 03 0f c3 03     .........0.<....
     3b3:	f3 00 3f 00 0f 00 03 00 00 00 00 0f bc 1f fe 39     ..?............9
     3c3:	e7 30 c3 30 c3 30 c3 30 e7 30 fe 39 bc 1f 00 0f     .0.0.0.0.0.9....
     3d3:	00 00 3c 00 7e 00 e7 30 c3 30 c3 30 c3 38 c3 1c     ..<.~..0.0.0.8..
     3e3:	c3 0e e7 07 fe 03 fc 00 00 00 00 00 00 00 00 00     ................
     3f3:	70 1c 70 1c 70 1c 00 00 00 00 00 00 00 00 00 00     p.p.p...........
	...
     40b:	70 9c 70 fc 70 7c 00 00 00 00 00 00 00 00 00 00     p.p.p|..........
     41b:	00 00 00 00 c0 00 e0 01 f0 03 38 07 1c 0e 0e 1c     ..........8.....
     42b:	07 38 03 30 00 00 00 00 00 00 00 00 60 06 60 06     .8.0........`.`.
     43b:	60 06 60 06 60 06 60 06 60 06 60 06 60 06 00 00     `.`.`.`.`.`.`...
     44b:	00 00 00 00 03 30 07 38 0e 1c 1c 0e 38 07 f0 03     .....0.8....8...
     45b:	e0 01 c0 00 00 00 00 00 00 00 1c 00 1e 00 07 00     ................
     46b:	03 00 83 37 c3 37 e3 00 77 00 3e 00 1c 00 00 00     ...7.7..w.>.....
     47b:	00 00 f8 0f fe 1f 07 18 f3 33 fb 37 1b 36 fb 37     .........3.7.6.7
     48b:	fb 37 07 36 fe 03 f8 01 00 00 00 38 00 3f e0 07     .7.6.......8.?..
     49b:	fc 06 1f 06 1f 06 fc 06 e0 07 00 3f 00 38 00 00     ...........?.8..
     4ab:	00 00 ff 3f ff 3f c3 30 c3 30 c3 30 c3 30 e7 30     ...?.?.0.0.0.0.0
     4bb:	fe 39 bc 1f 00 0f 00 00 00 00 f0 03 fc 0f 0e 1c     .9..............
     4cb:	07 38 03 30 03 30 03 30 07 38 0e 1c 0c 0c 00 00     .8.0.0.0.8......
     4db:	00 00 ff 3f ff 3f 03 30 03 30 03 30 03 30 07 38     ...?.?.0.0.0.0.8
     4eb:	0e 1c fc 0f f0 03 00 00 00 00 ff 3f ff 3f c3 30     ...........?.?.0
     4fb:	c3 30 c3 30 c3 30 c3 30 c3 30 03 30 03 30 00 00     .0.0.0.0.0.0.0..
     50b:	00 00 ff 3f ff 3f c3 00 c3 00 c3 00 c3 00 c3 00     ...?.?..........
     51b:	c3 00 03 00 03 00 00 00 00 00 f0 03 fc 0f 0e 1c     ................
     52b:	07 38 03 30 c3 30 c3 30 c3 30 c7 3f c6 3f 00 00     .8.0.0.0.0.?.?..
     53b:	00 00 ff 3f ff 3f c0 00 c0 00 c0 00 c0 00 c0 00     ...?.?..........
     54b:	c0 00 ff 3f ff 3f 00 00 00 00 00 00 00 00 03 30     ...?.?.........0
     55b:	03 30 ff 3f ff 3f 03 30 03 30 00 00 00 00 00 00     .0.?.?.0.0......
     56b:	00 00 00 0e 00 1e 00 38 00 30 00 30 00 30 00 30     .......8.0.0.0.0
     57b:	00 38 ff 1f ff 07 00 00 00 00 ff 3f ff 3f c0 00     .8.........?.?..
     58b:	e0 01 f0 03 38 07 1c 0e 0e 1c 07 38 03 30 00 00     ....8......8.0..
     59b:	00 00 ff 3f ff 3f 00 30 00 30 00 30 00 30 00 30     ...?.?.0.0.0.0.0
     5ab:	00 30 00 30 00 30 00 00 00 00 ff 3f ff 3f 1e 00     .0.0.0.....?.?..
     5bb:	78 00 e0 01 e0 01 78 00 1e 00 ff 3f ff 3f 00 00     x.....x....?.?..
     5cb:	00 00 ff 3f ff 3f 0e 00 38 00 f0 00 c0 03 00 07     ...?.?..8.......
     5db:	00 1c ff 3f ff 3f 00 00 00 00 f0 03 fc 0f 0e 1c     ...?.?..........
     5eb:	07 38 03 30 03 30 07 38 0e 1c fc 0f f0 03 00 00     .8.0.0.8........
     5fb:	00 00 ff 3f ff 3f 83 01 83 01 83 01 83 01 83 01     ...?.?..........
     60b:	c7 01 fe 00 7c 00 00 00 00 00 f0 03 fc 0f 0e 1c     ....|...........
     61b:	07 38 03 30 03 36 07 3e 0e 1c fc 3f f0 33 00 00     .8.0.6.>...?.3..
     62b:	00 00 ff 3f ff 3f 83 01 83 01 83 03 83 07 83 0f     ...?.?..........
     63b:	c7 1d fe 38 7c 30 00 00 00 00 3c 0c 7e 1c e7 38     ...8|0....<.~..8
     64b:	c3 30 c3 30 c3 30 c3 30 c7 39 8e 1f 0c 0f 00 00     .0.0.0.0.9......
     65b:	00 00 00 00 03 00 03 00 03 00 ff 3f ff 3f 03 00     ...........?.?..
     66b:	03 00 03 00 00 00 00 00 00 00 ff 07 ff 1f 00 38     ...............8
     67b:	00 30 00 30 00 30 00 30 00 38 ff 1f ff 07 00 00     .0.0.0.0.8......
     68b:	00 00 07 00 3f 00 f8 01 c0 0f 00 3e 00 3e c0 0f     ....?......>.>..
     69b:	f8 01 3f 00 07 00 00 00 00 00 ff 3f ff 3f 00 1c     ..?........?.?..
     6ab:	00 06 80 03 80 03 00 06 00 1c ff 3f ff 3f 00 00     ...........?.?..
     6bb:	00 00 03 30 0f 3c 1c 0e 30 03 e0 01 e0 01 30 03     ...0.<..0.....0.
     6cb:	1c 0e 0f 3c 03 30 00 00 00 00 03 00 0f 00 3c 00     ...<.0........<.
     6db:	f0 00 c0 3f c0 3f f0 00 3c 00 0f 00 03 00 00 00     ...?.?..<.......
     6eb:	00 00 03 30 03 3c 03 3e 03 33 c3 31 e3 30 33 30     ...0.<.>.3.1.030
     6fb:	1f 30 0f 30 03 30 00 00 00 00 00 00 00 00 ff 3f     .0.0.0.........?
     70b:	ff 3f 03 30 03 30 03 30 03 30 00 00 00 00 00 00     .?.0.0.0.0......
     71b:	00 00 0e 00 1c 00 38 00 70 00 e0 00 c0 01 80 03     ......8.p.......
     72b:	00 07 00 0e 00 1c 00 18 00 00 00 00 00 00 03 30     ...............0
     73b:	03 30 03 30 03 30 ff 3f ff 3f 00 00 00 00 00 00     .0.0.0.?.?......
     74b:	00 00 60 00 70 00 38 00 1c 00 0e 00 07 00 0e 00     ..`.p.8.........
     75b:	1c 00 38 00 70 00 60 00 00 00 00 c0 00 c0 00 c0     ..8.p.`.........
     76b:	00 c0 00 c0 00 c0 00 c0 00 c0 00 c0 00 c0 00 c0     ................

0000077b <font6x8>:
     77b:	06 08 af 11                                         ....

0000077f <_font6x8map>:
	...
     787:	06 5f 06 00 00 07 03 00 07 03 00 24 7e 24 7e 24     ._.........$~$~$
     797:	00 24 2b 6a 12 00 00 63 13 08 64 63 00 36 49 56     .$+j...c..dc.6IV
     7a7:	20 50 00 00 07 03 00 00 00 00 3e 41 00 00 00 00      P........>A....
     7b7:	41 3e 00 00 00 08 3e 1c 3e 08 00 08 08 3e 08 08     A>....>.>....>..
     7c7:	00 00 e0 60 00 00 00 08 08 08 08 08 00 00 60 60     ...`..........``
     7d7:	00 00 00 20 10 08 04 02 00 3e 51 49 45 3e 00 00     ... .....>QIE>..
     7e7:	42 7f 40 00 00 62 51 49 49 46 00 22 49 49 49 36     B.@..bQIIF."III6
     7f7:	00 18 14 12 7f 10 00 2f 49 49 49 31 00 3c 4a 49     ......./III1.<JI
     807:	49 30 00 01 71 09 05 03 00 36 49 49 49 36 00 06     I0..q....6III6..
     817:	49 49 29 1e 00 00 6c 6c 00 00 00 00 ec 6c 00 00     II)...ll.....l..
     827:	00 08 14 22 41 00 00 24 24 24 24 24 00 00 41 22     ..."A..$$$$$..A"
     837:	14 08 00 02 01 59 09 06 00 3e 41 5d 55 1e 00 7e     .....Y...>A]U..~
     847:	11 11 11 7e 00 7f 49 49 49 36 00 3e 41 41 41 22     ...~..III6.>AAA"
     857:	00 7f 41 41 41 3e 00 7f 49 49 49 41 00 7f 09 09     ..AAA>..IIIA....
     867:	09 01 00 3e 41 49 49 7a 00 7f 08 08 08 7f 00 00     ...>AIIz........
     877:	41 7f 41 00 00 30 40 40 40 3f 00 7f 08 14 22 41     A.A..0@@@?...."A
     887:	00 7f 40 40 40 40 00 7f 02 04 02 7f 00 7f 02 04     ..@@@@..........
     897:	08 7f 00 3e 41 41 41 3e 00 7f 09 09 09 06 00 3e     ...>AAA>.......>
     8a7:	41 51 21 5e 00 7f 09 09 19 66 00 26 49 49 49 32     AQ!^.....f.&III2
     8b7:	00 01 01 7f 01 01 00 3f 40 40 40 3f 00 1f 20 40     .......?@@@?.. @
     8c7:	20 1f 00 3f 40 3c 40 3f 00 63 14 08 14 63 00 07      ..?@<@?.c...c..
     8d7:	08 70 08 07 00 71 49 45 43 00 00 00 7f 41 41 00     .p...qIEC....AA.
     8e7:	00 02 04 08 10 20 00 00 41 41 7f 00 00 04 02 01     ..... ..AA......
     8f7:	02 04 80 80 80 80 80 80 00 00 03 07 00 00 00 20     ............... 
     907:	54 54 54 78 00 7f 44 44 44 38 00 38 44 44 44 28     TTTx..DDD8.8DDD(
     917:	00 38 44 44 44 7f 00 38 54 54 54 08 00 08 7e 09     .8DDD..8TTT...~.
     927:	09 00 00 18 a4 a4 a4 7c 00 7f 04 04 78 00 00 00     .......|....x...
     937:	00 7d 40 00 00 40 80 84 7d 00 00 7f 10 28 44 00     .}@..@..}....(D.
     947:	00 00 00 7f 40 00 00 7c 04 18 04 78 00 7c 04 04     ....@..|...x.|..
     957:	78 00 00 38 44 44 44 38 00 fc 44 44 44 38 00 38     x..8DDD8..DDD8.8
     967:	44 44 44 fc 00 44 78 44 04 08 00 08 54 54 54 20     DDD..DxD....TTT 
     977:	00 04 3e 44 24 00 00 3c 40 20 7c 00 00 1c 20 40     ..>D$..<@ |... @
     987:	20 1c 00 3c 60 30 60 3c 00 6c 10 10 6c 00 00 9c      ..<`0`<.l..l...
     997:	a0 60 3c 00 00 64 54 54 4c 00 00 08 3e 41 41 00     .`<..dTTL...>AA.
     9a7:	00 00 00 77 00 00 00 00 41 41 3e 08 00 02 01 02     ...w....AA>.....
     9b7:	01 00 00 3c 26 23 26 3c                             ...<&#&<

000009bf <fonts>:
     9bf:	7b 07 77 01                                         {.w.

000009c3 <glyArrowUp>:
     9c3:	08 08 30 38 3c 3e 3e 3c 38 30                       ..08<>><80

000009cd <glyArrowDown>:
     9cd:	08 08 06 0e 1e 3e 3e 1e 0e 06                       .....>>...

000009d7 <glyBall>:
     9d7:	09 09 38 00 fe 00 fe 00 ff 01 ff 01 ff 01 fe 00     ..8.............
     9e7:	fe 00 38 00                                         ..8.

000009eb <glyDirCW>:
     9eb:	09 03 00 00 00 00 02 02 02 07 02                    ...........

000009f6 <glyDirCCW>:
     9f6:	05 03 02 07 02 02 02                                .......

000009fd <glyLogo>:
     9fd:	40 40 00 00 00 00 01 03 03 03 03 03 03 03 03 03     @@..............
     a0d:	03 03 03 03 03 03 07 0f 1f 1f 3f 3f 7f 7f 7f 7f     ..........??....
     a1d:	7f 3f 1f 0f 00 03 03 03 03 03 03 03 03 03 03 03     .?..............
     a2d:	03 03 03 03 03 07 07 07 07 07 07 07 03 03 01 00     ................
     a3d:	00 00 00 00 00 00 ff ff 00 00 00 00 00 00 00 00     ................
     a4d:	00 01 1f 7f ff ff ff ff ff e7 c3 e7 ff ff ff ff     ................
     a5d:	ff ff fe f0 00 00 00 00 00 00 00 00 00 07 0f 3f     ...............?
     a6d:	7f ff ff ff fc fc ff ff ff ff ff ff ff ff 7c c3     ..............|.
     a7d:	00 00 00 00 00 00 ff ff 00 00 00 00 00 00 00 00     ................
     a8d:	00 00 f0 f8 fc fe fe fe fe fc fc fd fb f7 f7 ef     ................
     a9d:	df 0b 00 00 00 00 00 00 00 01 03 03 ff ff ff ff     ................
     aad:	ff ff ff ff 7f 7f ff ff ff fe fc f8 e0 80 7f ff     ................
     abd:	00 00 00 00 00 00 ff ff 00 00 00 00 00 00 00 00     ................
	...
     ad5:	00 00 00 80 fd ff ff ff ff ff 7f 1f 3f 7f 7f fe     ............?...
     ae5:	fe fc f8 f8 f0 f0 e0 c0 c0 e0 c0 c0 c0 c0 80 80     ................
     af5:	00 00 00 00 00 00 ff ff 00 00 00 00 00 00 ff ff     ................
     b05:	00 00 01 01 03 03 07 07 07 0f 07 07 07 03 03 07     ................
     b15:	0f 0f 3f 7f ff ff fe fe ff ff ff ff ff af 03 00     ..?.............
	...
     b39:	00 00 ff ff 00 00 00 00 00 00 ff ff 3f 7f ff ff     ............?...
     b49:	fc f8 fc ff ff ff ff ff ff ff ff e8 c0 c0 80 80     ................
     b59:	00 00 00 00 80 f9 ff ff ff ff ff 7f 7f 7f 7f ff     ................
     b69:	7f 7f 7f 3f 1f 01 00 00 00 00 00 00 00 00 00 00     ...?............
     b79:	00 00 ff ff 00 00 00 00 00 fe ff ff ff ff ff ff     ................
     b89:	ff 7f ff ff ff ff fe fc f0 e0 00 00 00 00 00 00     ................
     b99:	00 00 01 1f 7f ff ff ff ff ff c7 c7 cf ff ff ff     ................
     ba9:	ff ff ff fe f0 00 00 00 00 00 00 00 00 00 00 00     ................
     bb9:	00 00 ff ff 00 00 00 00 00 00 f0 f8 d8 d8 f8 d8     ................
     bc9:	d8 d8 d8 98 18 18 18 18 18 18 18 18 18 18 18 18     ................
     bd9:	18 18 18 f8 f8 fc fc fc fe fc fc fc fc f8 f0 f0     ................
     be9:	d8 d8 18 18 18 18 18 18 18 18 18 18 18 18 18 18     ................
     bf9:	18 18 f8 f0 00 00                                   ......

00000bff <scrESCCal>:
     bff:	27 0e 91 0e                                         '...

00000c03 <lstMenu>:
     c03:	c5 0e d5 0e e3 0e f1 0e ff 0e 0e 0f 1a 0f 28 0f     ..............(.
     c13:	3b 0f 4b 0f 5b 0f 61 0f                             ;.K.[.a.

00000c1b <strAreYouSure>:
     c1b:	41 72 65 20 79 6f 75 20 73 75 72 65 3f 00           Are you sure?.

00000c29 <__c.2278>:
     c29:	4d 65 61 73 00                                      Meas.

00000c2e <_skMENUSAVE>:
     c2e:	53 41 56 45 20 55 50 20 20 20 44 4f 57 4e 20 20     SAVE UP   DOWN  
     c3e:	45 4e 54 45 52 00                                   ENTER.

00000c44 <__c.2269>:
     c44:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
	...

00000c55 <_skEDIT>:
     c55:	43 41 4e 43 45 4c 20 20 44 4f 57 4e 20 20 20 55     CANCEL  DOWN   U
     c65:	50 20 20 4f 4b 00                                   P  OK.

00000c6b <__c.2259>:
     c6b:	41 43 43 2d 5a 20 64 61 6d 70 69 6e 67 00           ACC-Z damping.

00000c79 <__c.2246>:
     c79:	54 72 69 6d 20 50 3a 20 20 20 20 52 3a 00           Trim P:    R:.

00000c87 <__c.2244>:
     c87:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
	...

00000c98 <__c.2239>:
     c98:	52 00                                               R.

00000c9a <__c.2237>:
     c9a:	4e 00                                               N.

00000c9c <__c.2235>:
     c9c:	52 65 76 65 72 73 65 20 47 59 52 4f 00              Reverse GYRO.

00000ca9 <__c.2233>:
     ca9:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
	...

00000cba <__c.2218>:
     cba:	6e 6f 20 00                                         no .

00000cbe <__c.2216>:
     cbe:	79 65 73 00                                         yes.

00000cc2 <strYes>:
     cc2:	59 65 73 00                                         Yes.

00000cc6 <strNo>:
     cc6:	4e 6f 20 00                                         No .

00000cca <__c.2205>:
     cca:	41 20 54 72 69 20 00                                A Tri .

00000cd1 <__c.2203>:
     cd1:	59 20 54 72 69 20 00                                Y Tri .

00000cd8 <__c.2201>:
     cd8:	58 20 51 75 61 64 00                                X Quad.

00000cdf <__c.2199>:
     cdf:	2b 20 51 75 61 64 00                                + Quad.

00000ce6 <__c.2197>:
     ce6:	58 20 51 75 61 64 00                                X Quad.

00000ced <__c.2195>:
     ced:	2b 20 51 75 61 64 00                                + Quad.

00000cf4 <__c.2193>:
     cf4:	55 41 52 54 20 00                                   UART .

00000cfa <__c.2191>:
     cfa:	42 75 64 64 79 00                                   Buddy.

00000d00 <__c.2189>:
     d00:	54 52 49 20 00                                      TRI .

00000d05 <__c.2187>:
     d05:	51 75 61 64 00                                      Quad.

00000d0a <_skBACK>:
     d0a:	42 41 43 4b 20 20 20 20 20 20 20 20 20 20 20 20     BACK            
     d1a:	20 20 20 20 20 00                                        .

00000d20 <strSPC1>:
     d20:	20 00                                                .

00000d22 <strErr>:
     d22:	45 72 72 00                                         Err.

00000d26 <strSPC4>:
     d26:	20 20 20 20 00                                          .

00000d2b <__c.2160>:
     d2b:	4e 41 00                                            NA.

00000d2e <strARMED>:
     d2e:	41 52 4d 45 44 00                                   ARMED.

00000d34 <strVersionInfo>:
     d34:	48 65 66 6e 79 43 6f 70 74 65 72 32 20 76 31 2e     HefnyCopter2 v1.
     d44:	30 2e 30 00                                         0.0.

00000d48 <strOK>:
     d48:	4f 4b 20 00                                         OK .

00000d4c <str1>:
     d4c:	31 00                                               1.

00000d4e <strX>:
     d4e:	58 00                                               X.

00000d50 <str2>:
     d50:	32 00                                               2.

00000d52 <__c.2127>:
     d52:	2b 00                                               +.

00000d54 <__c.2125>:
     d54:	58 00                                               X.

00000d56 <__c.2123>:
     d56:	59 00                                               Y.

00000d58 <__c.2121>:
     d58:	2b 00                                               +.

00000d5a <__c.2119>:
     d5a:	41 00                                               A.

00000d5c <__c.2117>:
     d5c:	58 00                                               X.

00000d5e <__c.2115>:
     d5e:	55 41 52 54 20 00                                   UART .

00000d64 <__c.2113>:
     d64:	42 75 64 64 79 00                                   Buddy.

00000d6a <__c.2111>:
     d6a:	54 52 49 20 00                                      TRI .

00000d6f <__c.2109>:
     d6f:	51 75 61 64 00                                      Quad.

00000d74 <__c.2107>:
     d74:	41 4c 54 48 4c 44 00                                ALTHLD.

00000d7b <__c.2105>:
     d7b:	53 54 41 42 4c 45 00                                STABLE.

00000d82 <__c.2103>:
     d82:	41 43 52 4f 20 20 00                                ACRO  .

00000d89 <pages>:
     d89:	6f 0f 74 2e 85 0f b9 0f 22 37 00 00 6f 0f 58 2e     o.t....."7..o.X.
     d99:	cf 0f d3 0f 29 2b e9 0f d3 0f 08 2a 1e 10 b9 0f     ....)+.....*....
     da9:	13 33 33 10 b9 0f 0c 31 33 10 b9 0f 62 30 33 10     .33....13...b03.
     db9:	b9 0f b0 35 7a 10 b1 10 f8 34 c7 10 0a 0d 09 2b     ...5z....4.....+
     dc9:	11 11 0a 0d bf 2d 47 11 77 11 cb 2a 11 11 8d 11     .....-G.w..*....
     dd9:	37 2c 47 11 77 11 3b 2e 27 0e 0a 0d 2e 2a 00 00     7,G.w.;.'....*..
     de9:	a3 11 2a 2e 00 00                                   ..*...

00000def <__c.2036>:
     def:	59 41 57 20 20 20 20 20 20 20 20 20 20 00           YAW          .

00000dfd <__c.2033>:
     dfd:	52 6f 6c 6c 20 20 20 20 20 20 20 20 20 00           Roll         .

00000e0b <__c.2029>:
     e0b:	50 69 74 63 68 20 26 20 52 6f 6c 6c 20 00           Pitch & Roll .

00000e19 <__c.2027>:
     e19:	50 69 74 63 68 20 20 20 20 20 20 20 20 00           Pitch        .

00000e27 <scrESCCal0>:
     e27:	2d 54 41 4b 45 20 4f 46 46 20 50 52 4f 50 45 4c     -TAKE OFF PROPEL
     e37:	4c 45 52 53 21 21 0a 2d 50 72 65 73 73 20 63 6f     LERS!!.-Press co
     e47:	6e 74 69 6e 75 65 0a 2d 54 75 72 6e 20 4f 66 66     ntinue.-Turn Off
     e57:	20 51 75 61 64 63 6f 70 74 65 72 2e 0a 0a 2d 51      Quadcopter...-Q
     e67:	75 61 64 20 77 69 6c 6c 20 73 74 61 72 74 65 64     uad will started
     e77:	0a 69 6e 20 41 52 4d 45 44 20 54 41 4b 45 43 41     .in ARMED TAKECA
     e87:	52 45 20 73 74 61 74 65 0a 00                       RE state..

00000e91 <scrESCCal1>:
     e91:	50 72 65 73 73 20 43 6f 6e 74 69 6e 75 65 20 61     Press Continue a
     ea1:	66 74 65 72 20 63 61 6c 69 62 72 61 74 69 6f 6e     fter calibration
     eb1:	2e 0a 0a 75 6e 70 6c 75 67 20 62 61 74 74 65 72     ...unplug batter
     ec1:	79 2e 0a 00                                         y...

00000ec5 <strStabilization>:
     ec5:	47 79 72 6f 20 50 49 44 20 45 64 69 74 6f 72 00     Gyro PID Editor.

00000ed5 <strSelflevel>:
     ed5:	53 65 6c 66 20 4c 65 76 65 6c 69 6e 67 00           Self Leveling.

00000ee3 <strAltitudeHold>:
     ee3:	41 6c 74 69 74 75 64 65 20 48 6f 6c 64 00           Altitude Hold.

00000ef1 <strModeSettings>:
     ef1:	4d 6f 64 65 20 53 65 74 74 69 6e 67 73 00           Mode Settings.

00000eff <strMiscSettings>:
     eff:	4d 69 73 63 2e 20 53 65 74 74 69 6e 67 73 00        Misc. Settings.

00000f0e <strSensorTest>:
     f0e:	53 65 6e 73 6f 72 20 54 65 73 74 00                 Sensor Test.

00000f1a <strReceiverTest>:
     f1a:	52 65 63 65 69 76 65 72 20 54 65 73 74 00           Receiver Test.

00000f28 <strSensorCalibration>:
     f28:	53 65 6e 73 6f 72 20 43 61 6c 69 62 72 61 74 69     Sensor Calibrati
     f38:	6f 6e 00                                            on.

00000f3b <strRadioCalibration>:
     f3b:	53 74 69 63 6b 20 43 65 6e 74 65 72 69 6e 67 00     Stick Centering.

00000f4b <strESCCalibration>:
     f4b:	45 53 43 20 43 61 6c 69 62 72 61 74 69 6f 6e 00     ESC Calibration.

00000f5b <strDebug>:
     f5b:	44 65 62 75 67 00                                   Debug.

00000f61 <strFactoryReset>:
     f61:	46 61 63 74 6f 72 79 20 52 65 73 65 74 00           Factory Reset.

00000f6f <_skHOME>:
     f6f:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     f7f:	20 4d 45 4e 55 00                                    MENU.

00000f85 <scrHomePage>:
     f85:	0a 0a 42 61 74 74 3a 20 20 20 20 20 20 20 76 0a     ..Batt:       v.
     f95:	0a 0a 52 58 3a 20 2d 20 20 53 4e 3a 20 20 20 20     ..RX: -  SN:    
     fa5:	53 54 3a 20 2d 0a 46 6c 79 3a 20 20 20 42 6f 61     ST: -.Fly:   Boa
     fb5:	72 64 3a 00                                         rd:.

00000fb9 <_skMENU>:
     fb9:	42 41 43 4b 20 55 50 20 20 20 44 4f 57 4e 20 20     BACK UP   DOWN  
     fc9:	45 4e 54 45 52 00                                   ENTER.

00000fcf <scrHomePageArmed>:
     fcf:	0a 0a 0a 00                                         ....

00000fd3 <_skSAVE>:
     fd3:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     fe3:	20 44 4f 4e 45 00                                    DONE.

00000fe9 <scrHomePageArmedESCCalibration>:
     fe9:	0a 0a 0a 4d 31 3a 20 20 20 20 20 20 20 4d 34 3a     ...M1:       M4:
     ff9:	0a 4d 32 3a 20 20 20 20 20 20 20 4d 33 3a 0a 45     .M2:       M3:.E
    1009:	53 43 20 43 61 6c 69 62 72 61 74 69 6f 6e 20 6d     SC Calibration m
    1019:	6f 64 65 0a 00                                      ode..

0000101e <scrHomePageRestart>:
    101e:	0a 52 45 53 54 41 52 54 0a 20 20 20 20 20 20 42     .RESTART.      B
    102e:	4f 41 52 44 00                                      OARD.

00001033 <scrStabilization>:
    1033:	0a 50 3a 20 20 20 20 20 20 20 4c 69 6d 3a 0a 49     .P:       Lim:.I
    1043:	3a 20 20 20 20 20 20 20 4c 69 6d 3a 0a 44 3a 20     :       Lim:.D: 
    1053:	20 20 20 20 20 20 4c 69 6d 3a 0a 4e 6f 69 73 65           Lim:.Noise
    1063:	20 46 69 6c 74 65 72 3a 0a 54 72 69 6d 20 50 3a      Filter:.Trim P:
    1073:	20 20 20 20 52 3a 00                                    R:.

0000107a <scrModeSettings>:
    107a:	46 72 61 6d 65 20 54 79 70 65 3a 0a 42 75 64 64     Frame Type:.Budd
    108a:	79 20 53 79 73 74 65 6d 3a 0a 42 6f 61 72 64 20     y System:.Board 
    109a:	44 69 72 3a 0a 46 6c 79 20 20 20 44 69 72 3a 0a     Dir:.Fly   Dir:.
    10aa:	53 6f 6e 61 72 3a 00                                Sonar:.

000010b1 <_skPAGE>:
    10b1:	42 41 43 4b 20 50 52 45 56 20 4e 45 58 54 20 43     BACK PREV NEXT C
    10c1:	48 41 4e 47 45 00                                   HANGE.

000010c7 <scrMiscSettings>:
    10c7:	41 75 74 6f 20 44 69 73 61 72 6d 3a 0a 56 6f 6c     Auto Disarm:.Vol
    10d7:	74 20 41 6c 61 72 6d 3a 20 20 20 20 20 20 2f 31     t Alarm:      /1
    10e7:	30 76 0a 54 68 72 6f 74 74 6c 65 20 6d 69 6e 3a     0v.Throttle min:
    10f7:	0a 53 74 69 63 6b 20 53 63 61 6c 65 3a 0a 50 2d     .Stick Scale:.P-
    1107:	52 20 4c 69 6e 6b 65 64 3a 00                       R Linked:.

00001111 <scrSensorTest>:
    1111:	47 79 72 6f 20 52 3a 0a 47 79 72 6f 20 50 3a 0a     Gyro R:.Gyro P:.
    1121:	47 79 72 6f 20 59 3a 0a 41 63 63 20 20 50 3a 0a     Gyro Y:.Acc  P:.
    1131:	41 63 63 20 20 52 3a 0a 41 63 63 20 20 5a 3a 0a     Acc  R:.Acc  Z:.
    1141:	42 61 74 74 3a 00                                   Batt:.

00001147 <scrReceiverTest>:
    1147:	20 43 48 20 20 20 52 58 2d 31 20 20 20 20 52 58      CH   RX-1    RX
    1157:	2d 32 0a 41 69 6c 3a 0a 45 6c 65 3a 0a 52 75 64     -2.Ail:.Ele:.Rud
    1167:	3a 0a 54 68 72 3a 0a 41 75 78 3a 0a 52 58 3a 00     :.Thr:.Aux:.RX:.

00001177 <_skCONTINUE>:
    1177:	42 41 43 4b 20 20 20 20 20 20 20 20 20 43 4f 4e     BACK         CON
    1187:	54 49 4e 55 45 00                                   TINUE.

0000118d <_skCLRDONE>:
    118d:	42 41 43 4b 20 43 4c 52 20 20 20 20 20 20 20 20     BACK CLR        
    119d:	20 44 4f 4e 45 00                                    DONE.

000011a3 <_skCANCELYES>:
    11a3:	4e 4f 20 20 20 20 20 20 20 20 20 20 20 20 20 20     NO              
    11b3:	20 20 59 45 53 00 00 40 7a 10 f3 5a 00 a0 72 4e       YES..@z..Z..rN
    11c3:	18 09 00 10 a5 d4 e8 00 00 e8 76 48 17 00 00 e4     ..........vH....
    11d3:	0b 54 02 00 00 ca 9a 3b 00 00 00 e1 f5 05 00 00     .T.....;........
    11e3:	80 96 98 00 00 00 40 42 0f 00 00 00 a0 86 01 00     ......@B........
    11f3:	00 00 10 27 00 00 00 00 e8 03 00 00 00 00 64 00     ...'..........d.
    1203:	00 00 00 00 0a 00 00 00 00 00 01 00 00 00 00 00     ................
    1213:	2c 76 d8 88 dc 67 4f 08 23 df c1 df ae 59 e1 b1     ,v...gO.#....Y..
    1223:	b7 96 e5 e3 e4 53 c6 3a e6 51 99 76 96 e8 e6 c2     .....S.:.Q.v....
    1233:	84 26 eb 89 8c 9b 62 ed 40 7c 6f fc ef bc 9c 9f     .&....b.@|o.....
    1243:	40 f2 ba a5 6f a5 f4 90 05 5a 2a f7 5c 93 6b 6c     @...o....Z*.\.kl
    1253:	f9 67 6d c1 1b fc e0 e4 0d 47 fe f5 20 e6 b5 00     .gm......G.. ...
    1263:	d0 ed 90 2e 03 00 94 35 77 05 00 80 84 1e 08 00     .......5w.......
    1273:	00 20 4e 0a 00 00 00 c8 0c 33 33 33 33 0f 98 6e     . N......3333..n
    1283:	12 83 11 41 ef 8d 21 14 89 3b e6 55 16 cf fe e6     ...A..!..;.U....
    1293:	db 18 d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb e4 24     ....K8..|......$
    12a3:	20 32 84 72 5e 22 81 00 c9 f1 24 ec a1 e5 3d 27      2.r^"....$...='
	...

000012b4 <__vector_18>:
	sendData(column & 0x0f, LCD_COMMAND);
}

__attribute__ ((section(".lowtext")))
ISR(TIMER0_OVF_vect, ISR_NOBLOCK)
{
    12b4:	78 94       	sei
    12b6:	1f 92       	push	r1
    12b8:	0f 92       	push	r0
    12ba:	0f b6       	in	r0, 0x3f	; 63
    12bc:	0f 92       	push	r0
    12be:	11 24       	eor	r1, r1
    12c0:	2f 93       	push	r18
    12c2:	3f 93       	push	r19
    12c4:	4f 93       	push	r20
    12c6:	5f 93       	push	r21
    12c8:	6f 93       	push	r22
    12ca:	7f 93       	push	r23
    12cc:	8f 93       	push	r24
    12ce:	9f 93       	push	r25
    12d0:	af 93       	push	r26
    12d2:	bf 93       	push	r27
    12d4:	cf 93       	push	r28
    12d6:	df 93       	push	r29
    12d8:	ef 93       	push	r30
    12da:	ff 93       	push	r31
	TCNT0_X +=1;
    12dc:	80 91 b8 05 	lds	r24, 0x05B8
    12e0:	90 91 b9 05 	lds	r25, 0x05B9
    12e4:	01 96       	adiw	r24, 0x01	; 1
    12e6:	90 93 b9 05 	sts	0x05B9, r25
    12ea:	80 93 b8 05 	sts	0x05B8, r24
	static uint16_t offset;
	
	if (offset % LCDWIDTH == 0)
    12ee:	c0 91 2b 05 	lds	r28, 0x052B
    12f2:	d0 91 2c 05 	lds	r29, 0x052C
    12f6:	ce 01       	movw	r24, r28
    12f8:	8f 77       	andi	r24, 0x7F	; 127
    12fa:	90 70       	andi	r25, 0x00	; 0
    12fc:	00 97       	sbiw	r24, 0x00	; 0
    12fe:	99 f4       	brne	.+38     	; 0x1326 <__vector_18+0x72>
		setPos(offset / LCDWIDTH, 0);
    1300:	ce 01       	movw	r24, r28
    1302:	88 0f       	add	r24, r24
    1304:	89 2f       	mov	r24, r25
    1306:	88 1f       	adc	r24, r24
    1308:	99 0b       	sbc	r25, r25
    130a:	91 95       	neg	r25
	LCD_CS = 1;
}

static void setPos(uint8_t line, uint8_t column)
{
	sendData(0xB0 | (line & 0x07), LCD_COMMAND);
    130c:	87 70       	andi	r24, 0x07	; 7
    130e:	80 6b       	ori	r24, 0xB0	; 176
    1310:	60 e0       	ldi	r22, 0x00	; 0
    1312:	0e 94 09 0c 	call	0x1812	; 0x1812 <sendData>
	sendData(0x10 | (column >> 4), LCD_COMMAND);
    1316:	80 e1       	ldi	r24, 0x10	; 16
    1318:	60 e0       	ldi	r22, 0x00	; 0
    131a:	0e 94 09 0c 	call	0x1812	; 0x1812 <sendData>
	sendData(column & 0x0f, LCD_COMMAND);
    131e:	80 e0       	ldi	r24, 0x00	; 0
    1320:	60 e0       	ldi	r22, 0x00	; 0
    1322:	0e 94 09 0c 	call	0x1812	; 0x1812 <sendData>
	static uint16_t offset;
	
	if (offset % LCDWIDTH == 0)
		setPos(offset / LCDWIDTH, 0);
		
	sendData(*(_screen + offset++), LCD_DATA);
    1326:	fe 01       	movw	r30, r28
    1328:	e5 5d       	subi	r30, 0xD5	; 213
    132a:	fe 4f       	sbci	r31, 0xFE	; 254
    132c:	80 81       	ld	r24, Z
    132e:	61 e0       	ldi	r22, 0x01	; 1
    1330:	0e 94 09 0c 	call	0x1812	; 0x1812 <sendData>
    1334:	21 96       	adiw	r28, 0x01	; 1
	offset %= sizeof(_screen);
    1336:	d3 70       	andi	r29, 0x03	; 3
    1338:	d0 93 2c 05 	sts	0x052C, r29
    133c:	c0 93 2b 05 	sts	0x052B, r28
}
    1340:	ff 91       	pop	r31
    1342:	ef 91       	pop	r30
    1344:	df 91       	pop	r29
    1346:	cf 91       	pop	r28
    1348:	bf 91       	pop	r27
    134a:	af 91       	pop	r26
    134c:	9f 91       	pop	r25
    134e:	8f 91       	pop	r24
    1350:	7f 91       	pop	r23
    1352:	6f 91       	pop	r22
    1354:	5f 91       	pop	r21
    1356:	4f 91       	pop	r20
    1358:	3f 91       	pop	r19
    135a:	2f 91       	pop	r18
    135c:	0f 90       	pop	r0
    135e:	0f be       	out	0x3f, r0	; 63
    1360:	0f 90       	pop	r0
    1362:	1f 90       	pop	r1
    1364:	18 95       	reti

00001366 <__vector_6>:
 
 uint8_t OldPortCValue;

__attribute__ ((section(".lowtext")))
ISR (RX2_ALL_vect)
{
    1366:	1f 92       	push	r1
    1368:	0f 92       	push	r0
    136a:	0f b6       	in	r0, 0x3f	; 63
    136c:	0f 92       	push	r0
    136e:	11 24       	eor	r1, r1
    1370:	0f 93       	push	r16
    1372:	1f 93       	push	r17
    1374:	2f 93       	push	r18
    1376:	3f 93       	push	r19
    1378:	4f 93       	push	r20
    137a:	5f 93       	push	r21
    137c:	6f 93       	push	r22
    137e:	7f 93       	push	r23
    1380:	8f 93       	push	r24
    1382:	9f 93       	push	r25
    1384:	af 93       	push	r26
    1386:	bf 93       	push	r27
    1388:	cf 93       	push	r28
    138a:	df 93       	push	r29
    138c:	ef 93       	push	r30
    138e:	ff 93       	push	r31
	uint8_t Changes = PINC ^ OldPortCValue;  // capture changed bit
    1390:	16 b1       	in	r17, 0x06	; 6
    1392:	80 91 1f 08 	lds	r24, 0x081F
    1396:	18 27       	eor	r17, r24
	OldPortCValue = PINC;
    1398:	86 b1       	in	r24, 0x06	; 6
    139a:	80 93 1f 08 	sts	0x081F, r24
	uint16_t TCNT1_TEMP = TCNT1;
    139e:	c0 91 84 00 	lds	r28, 0x0084
    13a2:	d0 91 85 00 	lds	r29, 0x0085
	// if there is a signal change in ROLL
	if ((Changes & RX2_ROLL_PIN)!=0)
    13a6:	01 2f       	mov	r16, r17
    13a8:	15 ff       	sbrs	r17, 5
    13aa:	18 c0       	rjmp	.+48     	; 0x13dc <__vector_6+0x76>
	{
		if (RX2_ROLL)
    13ac:	86 b1       	in	r24, 0x06	; 6
    13ae:	85 ff       	sbrs	r24, 5
    13b0:	05 c0       	rjmp	.+10     	; 0x13bc <__vector_6+0x56>
		{
			RX_raw[1][RXChannel_AIL]=TCNT1_TEMP;
    13b2:	d0 93 2d 08 	sts	0x082D, r29
    13b6:	c0 93 2c 08 	sts	0x082C, r28
    13ba:	10 c0       	rjmp	.+32     	; 0x13dc <__vector_6+0x76>
		}
		else
		{
			CalculateSignalLength2 (RXChannel_AIL);
    13bc:	80 e0       	ldi	r24, 0x00	; 0
    13be:	0e 94 70 25 	call	0x4ae0	; 0x4ae0 <CalculateSignalLength2>
			
			RX2_LastValidSignal_timestampAux = TCNT1_X;
    13c2:	80 91 70 06 	lds	r24, 0x0670
    13c6:	90 91 71 06 	lds	r25, 0x0671
    13ca:	90 93 14 08 	sts	0x0814, r25
    13ce:	80 93 13 08 	sts	0x0813, r24
			RX_Good = TX2_FOUND_ERR;  // CLR bit 6 ---  Status = OK
    13d2:	80 91 fb 07 	lds	r24, 0x07FB
    13d6:	8f 71       	andi	r24, 0x1F	; 31
    13d8:	80 93 fb 07 	sts	0x07FB, r24
		}	
	}
	// if there is a signal change in PITCH
	if ((Changes & RX2_PITCH_PIN)!=0)
    13dc:	00 ff       	sbrs	r16, 0
    13de:	0b c0       	rjmp	.+22     	; 0x13f6 <__vector_6+0x90>
	{
		if (RX2_PITCH)
    13e0:	86 b1       	in	r24, 0x06	; 6
    13e2:	80 ff       	sbrs	r24, 0
    13e4:	05 c0       	rjmp	.+10     	; 0x13f0 <__vector_6+0x8a>
		{
			RX_raw[1][RXChannel_ELE]=TCNT1_TEMP;
    13e6:	d0 93 2f 08 	sts	0x082F, r29
    13ea:	c0 93 2e 08 	sts	0x082E, r28
    13ee:	03 c0       	rjmp	.+6      	; 0x13f6 <__vector_6+0x90>
		}
		else
		{
			CalculateSignalLength2 (RXChannel_ELE);
    13f0:	81 e0       	ldi	r24, 0x01	; 1
    13f2:	0e 94 70 25 	call	0x4ae0	; 0x4ae0 <CalculateSignalLength2>
		}	
	}
	// if there is a signal change in THR
	if ((Changes & RX2_COLL_PIN)!=0)
    13f6:	17 ff       	sbrs	r17, 7
    13f8:	2d c0       	rjmp	.+90     	; 0x1454 <__vector_6+0xee>
    13fa:	80 91 ef 06 	lds	r24, 0x06EF
	{
		if (RX2_COLL)
    13fe:	37 9b       	sbis	0x06, 7	; 6
    1400:	0b c0       	rjmp	.+22     	; 0x1418 <__vector_6+0xb2>
		{
			RX_raw[1][RXChannel_THR]=TCNT1_TEMP;
    1402:	d0 93 33 08 	sts	0x0833, r29
    1406:	c0 93 32 08 	sts	0x0832, r28
			
			if (Config.IsESCCalibration==ESCCalibration_ON)
    140a:	81 30       	cpi	r24, 0x01	; 1
    140c:	19 f5       	brne	.+70     	; 0x1454 <__vector_6+0xee>
			{ 
				M1=1;M2=1;M3=1;M4=1;
    140e:	46 9a       	sbi	0x08, 6	; 8
    1410:	44 9a       	sbi	0x08, 4	; 8
    1412:	42 9a       	sbi	0x08, 2	; 8
    1414:	43 9a       	sbi	0x08, 3	; 8
    1416:	1e c0       	rjmp	.+60     	; 0x1454 <__vector_6+0xee>
			}
		}
		else
		{
			if ((Config.IsESCCalibration==ESCCalibration_ON) && (IS_TX2_GOOD) && (!IS_SYS_ACT_DISARM))
    1418:	81 30       	cpi	r24, 0x01	; 1
    141a:	61 f4       	brne	.+24     	; 0x1434 <__vector_6+0xce>
    141c:	80 91 fb 07 	lds	r24, 0x07FB
    1420:	80 7f       	andi	r24, 0xF0	; 240
    1422:	41 f4       	brne	.+16     	; 0x1434 <__vector_6+0xce>
    1424:	80 91 4d 05 	lds	r24, 0x054D
    1428:	81 fd       	sbrc	r24, 1
    142a:	04 c0       	rjmp	.+8      	; 0x1434 <__vector_6+0xce>
			{
				M1=0;M2=0;M3=0;M4=0;
    142c:	46 98       	cbi	0x08, 6	; 8
    142e:	44 98       	cbi	0x08, 4	; 8
    1430:	42 98       	cbi	0x08, 2	; 8
    1432:	43 98       	cbi	0x08, 3	; 8
			}
				
			CalculateSignalLength2 (RXChannel_THR);
    1434:	83 e0       	ldi	r24, 0x03	; 3
    1436:	0e 94 70 25 	call	0x4ae0	; 0x4ae0 <CalculateSignalLength2>
			RX2_LastValidSignal_timestamp = TCNT1_X;
    143a:	80 91 70 06 	lds	r24, 0x0670
    143e:	90 91 71 06 	lds	r25, 0x0671
    1442:	90 93 18 08 	sts	0x0818, r25
    1446:	80 93 17 08 	sts	0x0817, r24
			RX_Good = TX2_CONNECTED_ERR;  // CLR bit 5 ---  Status = OK
    144a:	80 91 fb 07 	lds	r24, 0x07FB
    144e:	8f 72       	andi	r24, 0x2F	; 47
    1450:	80 93 fb 07 	sts	0x07FB, r24
		}	
	}
	// if there is a signal change in YAW
	if ((Changes & RX2_YAW_PIN) !=0)
    1454:	01 ff       	sbrs	r16, 1
    1456:	0b c0       	rjmp	.+22     	; 0x146e <__vector_6+0x108>
	{
		if (RX2_YAW)
    1458:	86 b1       	in	r24, 0x06	; 6
    145a:	81 ff       	sbrs	r24, 1
    145c:	05 c0       	rjmp	.+10     	; 0x1468 <__vector_6+0x102>
		{
			RX_raw[1][RXChannel_RUD]=TCNT1_TEMP;
    145e:	d0 93 31 08 	sts	0x0831, r29
    1462:	c0 93 30 08 	sts	0x0830, r28
    1466:	03 c0       	rjmp	.+6      	; 0x146e <__vector_6+0x108>
		}
		else
		{
			CalculateSignalLength2 (RXChannel_RUD);
    1468:	82 e0       	ldi	r24, 0x02	; 2
    146a:	0e 94 70 25 	call	0x4ae0	; 0x4ae0 <CalculateSignalLength2>
			
		}	
	}
	
}
    146e:	ff 91       	pop	r31
    1470:	ef 91       	pop	r30
    1472:	df 91       	pop	r29
    1474:	cf 91       	pop	r28
    1476:	bf 91       	pop	r27
    1478:	af 91       	pop	r26
    147a:	9f 91       	pop	r25
    147c:	8f 91       	pop	r24
    147e:	7f 91       	pop	r23
    1480:	6f 91       	pop	r22
    1482:	5f 91       	pop	r21
    1484:	4f 91       	pop	r20
    1486:	3f 91       	pop	r19
    1488:	2f 91       	pop	r18
    148a:	1f 91       	pop	r17
    148c:	0f 91       	pop	r16
    148e:	0f 90       	pop	r0
    1490:	0f be       	out	0x3f, r0	; 63
    1492:	0f 90       	pop	r0
    1494:	1f 90       	pop	r1
    1496:	18 95       	reti

00001498 <__vector_2>:

#ifdef PRIMARY_INPUT_RX

__attribute__ ((section(".lowtext")))
ISR (RX1_COLL_vect)
{
    1498:	1f 92       	push	r1
    149a:	0f 92       	push	r0
    149c:	0f b6       	in	r0, 0x3f	; 63
    149e:	0f 92       	push	r0
    14a0:	11 24       	eor	r1, r1
    14a2:	2f 93       	push	r18
    14a4:	3f 93       	push	r19
    14a6:	4f 93       	push	r20
    14a8:	5f 93       	push	r21
    14aa:	6f 93       	push	r22
    14ac:	7f 93       	push	r23
    14ae:	8f 93       	push	r24
    14b0:	9f 93       	push	r25
    14b2:	af 93       	push	r26
    14b4:	bf 93       	push	r27
    14b6:	ef 93       	push	r30
    14b8:	ff 93       	push	r31
	if (RX1_COLL)
    14ba:	89 b1       	in	r24, 0x09	; 9
    14bc:	83 ff       	sbrs	r24, 3
    14be:	09 c0       	rjmp	.+18     	; 0x14d2 <__vector_2+0x3a>
	{
		RX_raw[0][RXChannel_THR]=TCNT1;
    14c0:	80 91 84 00 	lds	r24, 0x0084
    14c4:	90 91 85 00 	lds	r25, 0x0085
    14c8:	90 93 29 08 	sts	0x0829, r25
    14cc:	80 93 28 08 	sts	0x0828, r24
    14d0:	10 c0       	rjmp	.+32     	; 0x14f2 <__vector_2+0x5a>

	}
	else
	{
		CalculateSignalLength1(RXChannel_THR);
    14d2:	83 e0       	ldi	r24, 0x03	; 3
    14d4:	0e 94 47 25 	call	0x4a8e	; 0x4a8e <CalculateSignalLength1>
		
		RX1_LastValidSignal_timestamp = TCNT1_X;
    14d8:	80 91 70 06 	lds	r24, 0x0670
    14dc:	90 91 71 06 	lds	r25, 0x0671
    14e0:	90 93 1a 08 	sts	0x081A, r25
    14e4:	80 93 19 08 	sts	0x0819, r24
		RX_Good = TX1_CONNECTED_ERR;		// CLR bit 0 ---  Status = OK
    14e8:	80 91 fb 07 	lds	r24, 0x07FB
    14ec:	82 7f       	andi	r24, 0xF2	; 242
    14ee:	80 93 fb 07 	sts	0x07FB, r24
	}
	
}
    14f2:	ff 91       	pop	r31
    14f4:	ef 91       	pop	r30
    14f6:	bf 91       	pop	r27
    14f8:	af 91       	pop	r26
    14fa:	9f 91       	pop	r25
    14fc:	8f 91       	pop	r24
    14fe:	7f 91       	pop	r23
    1500:	6f 91       	pop	r22
    1502:	5f 91       	pop	r21
    1504:	4f 91       	pop	r20
    1506:	3f 91       	pop	r19
    1508:	2f 91       	pop	r18
    150a:	0f 90       	pop	r0
    150c:	0f be       	out	0x3f, r0	; 63
    150e:	0f 90       	pop	r0
    1510:	1f 90       	pop	r1
    1512:	18 95       	reti

00001514 <__vector_1>:



__attribute__ ((section(".lowtext")))
ISR (RX1_ROLL_vect)
{
    1514:	1f 92       	push	r1
    1516:	0f 92       	push	r0
    1518:	0f b6       	in	r0, 0x3f	; 63
    151a:	0f 92       	push	r0
    151c:	11 24       	eor	r1, r1
    151e:	2f 93       	push	r18
    1520:	3f 93       	push	r19
    1522:	4f 93       	push	r20
    1524:	5f 93       	push	r21
    1526:	6f 93       	push	r22
    1528:	7f 93       	push	r23
    152a:	8f 93       	push	r24
    152c:	9f 93       	push	r25
    152e:	af 93       	push	r26
    1530:	bf 93       	push	r27
    1532:	ef 93       	push	r30
    1534:	ff 93       	push	r31
	if (RX1_ROLL)
    1536:	89 b1       	in	r24, 0x09	; 9
    1538:	82 ff       	sbrs	r24, 2
    153a:	09 c0       	rjmp	.+18     	; 0x154e <__vector_1+0x3a>
	{
		RX_raw[0][RXChannel_AIL]=TCNT1;
    153c:	80 91 84 00 	lds	r24, 0x0084
    1540:	90 91 85 00 	lds	r25, 0x0085
    1544:	90 93 23 08 	sts	0x0823, r25
    1548:	80 93 22 08 	sts	0x0822, r24
    154c:	10 c0       	rjmp	.+32     	; 0x156e <__vector_1+0x5a>
	}
	else
	{
		CalculateSignalLength1(RXChannel_AIL);
    154e:	80 e0       	ldi	r24, 0x00	; 0
    1550:	0e 94 47 25 	call	0x4a8e	; 0x4a8e <CalculateSignalLength1>
		
		RX1_LastValidSignal_timestampAux = TCNT1_X;
    1554:	80 91 70 06 	lds	r24, 0x0670
    1558:	90 91 71 06 	lds	r25, 0x0671
    155c:	90 93 1c 08 	sts	0x081C, r25
    1560:	80 93 1b 08 	sts	0x081B, r24
		RX_Good = TX1_FOUND_ERR;			// CLR bit 1 ---  Status = OK
    1564:	80 91 fb 07 	lds	r24, 0x07FB
    1568:	81 7f       	andi	r24, 0xF1	; 241
    156a:	80 93 fb 07 	sts	0x07FB, r24

		
	}
	
}
    156e:	ff 91       	pop	r31
    1570:	ef 91       	pop	r30
    1572:	bf 91       	pop	r27
    1574:	af 91       	pop	r26
    1576:	9f 91       	pop	r25
    1578:	8f 91       	pop	r24
    157a:	7f 91       	pop	r23
    157c:	6f 91       	pop	r22
    157e:	5f 91       	pop	r21
    1580:	4f 91       	pop	r20
    1582:	3f 91       	pop	r19
    1584:	2f 91       	pop	r18
    1586:	0f 90       	pop	r0
    1588:	0f be       	out	0x3f, r0	; 63
    158a:	0f 90       	pop	r0
    158c:	1f 90       	pop	r1
    158e:	18 95       	reti

00001590 <__vector_7>:


__attribute__ ((section(".lowtext")))
ISR (RX1_PITCH_vect)
{
    1590:	1f 92       	push	r1
    1592:	0f 92       	push	r0
    1594:	0f b6       	in	r0, 0x3f	; 63
    1596:	0f 92       	push	r0
    1598:	11 24       	eor	r1, r1
    159a:	2f 93       	push	r18
    159c:	3f 93       	push	r19
    159e:	4f 93       	push	r20
    15a0:	5f 93       	push	r21
    15a2:	6f 93       	push	r22
    15a4:	7f 93       	push	r23
    15a6:	8f 93       	push	r24
    15a8:	9f 93       	push	r25
    15aa:	af 93       	push	r26
    15ac:	bf 93       	push	r27
    15ae:	ef 93       	push	r30
    15b0:	ff 93       	push	r31
	if (RX1_PITCH)
    15b2:	89 b1       	in	r24, 0x09	; 9
    15b4:	80 ff       	sbrs	r24, 0
    15b6:	09 c0       	rjmp	.+18     	; 0x15ca <__vector_7+0x3a>
	{
		RX_raw[0][RXChannel_ELE]=TCNT1;
    15b8:	80 91 84 00 	lds	r24, 0x0084
    15bc:	90 91 85 00 	lds	r25, 0x0085
    15c0:	90 93 25 08 	sts	0x0825, r25
    15c4:	80 93 24 08 	sts	0x0824, r24
    15c8:	03 c0       	rjmp	.+6      	; 0x15d0 <__vector_7+0x40>
	}
	else
	{
		CalculateSignalLength1(RXChannel_ELE);
    15ca:	81 e0       	ldi	r24, 0x01	; 1
    15cc:	0e 94 47 25 	call	0x4a8e	; 0x4a8e <CalculateSignalLength1>
	}
}
    15d0:	ff 91       	pop	r31
    15d2:	ef 91       	pop	r30
    15d4:	bf 91       	pop	r27
    15d6:	af 91       	pop	r26
    15d8:	9f 91       	pop	r25
    15da:	8f 91       	pop	r24
    15dc:	7f 91       	pop	r23
    15de:	6f 91       	pop	r22
    15e0:	5f 91       	pop	r21
    15e2:	4f 91       	pop	r20
    15e4:	3f 91       	pop	r19
    15e6:	2f 91       	pop	r18
    15e8:	0f 90       	pop	r0
    15ea:	0f be       	out	0x3f, r0	; 63
    15ec:	0f 90       	pop	r0
    15ee:	1f 90       	pop	r1
    15f0:	18 95       	reti

000015f2 <__vector_3>:

volatile uint16_t LongTime;
volatile uint16_t ShortTime;
__attribute__ ((section(".lowtext")))
ISR (RX1_YAW_vect)
{   
    15f2:	1f 92       	push	r1
    15f4:	0f 92       	push	r0
    15f6:	0f b6       	in	r0, 0x3f	; 63
    15f8:	0f 92       	push	r0
    15fa:	11 24       	eor	r1, r1
    15fc:	2f 93       	push	r18
    15fe:	3f 93       	push	r19
    1600:	4f 93       	push	r20
    1602:	5f 93       	push	r21
    1604:	6f 93       	push	r22
    1606:	7f 93       	push	r23
    1608:	8f 93       	push	r24
    160a:	9f 93       	push	r25
    160c:	af 93       	push	r26
    160e:	bf 93       	push	r27
    1610:	ef 93       	push	r30
    1612:	ff 93       	push	r31
	// SONAR IS HERE IN UART MODE
	// SONAR RAW VALUE = RX_Length[0][RXChannel_RUD]
	if ((Config.RX_mode==RX_mode_UARTMode) && (IS_MISC_SENSOR_SONAR_ENABLED==true))
    1614:	80 91 eb 06 	lds	r24, 0x06EB
    1618:	8f 3f       	cpi	r24, 0xFF	; 255
    161a:	f9 f4       	brne	.+62     	; 0x165a <__vector_3+0x68>
    161c:	80 91 f6 06 	lds	r24, 0x06F6
    1620:	80 ff       	sbrs	r24, 0
    1622:	1b c0       	rjmp	.+54     	; 0x165a <__vector_3+0x68>
	{
		if (RX1_YAW)
    1624:	83 b1       	in	r24, 0x03	; 3
    1626:	82 ff       	sbrs	r24, 2
    1628:	09 c0       	rjmp	.+18     	; 0x163c <__vector_3+0x4a>
		{
			//ShortTime = TCNT1;
			LongTime = TCNT0_X;
    162a:	80 91 b8 05 	lds	r24, 0x05B8
    162e:	90 91 b9 05 	lds	r25, 0x05B9
    1632:	90 93 21 08 	sts	0x0821, r25
    1636:	80 93 20 08 	sts	0x0820, r24
    163a:	1e c0       	rjmp	.+60     	; 0x1678 <__vector_3+0x86>
		}
		else
		{
			RX_Length[0][RXChannel_RUD] = (TCNT0_X - LongTime) ; // * SONAR_TO_cm_Convert_BIG + (TCNT1 - ShortTime) * SONAR_TO_cm_Convert;
    163c:	80 91 b8 05 	lds	r24, 0x05B8
    1640:	90 91 b9 05 	lds	r25, 0x05B9
    1644:	20 91 20 08 	lds	r18, 0x0820
    1648:	30 91 21 08 	lds	r19, 0x0821
    164c:	82 1b       	sub	r24, r18
    164e:	93 0b       	sbc	r25, r19
    1650:	90 93 d1 05 	sts	0x05D1, r25
    1654:	80 93 d0 05 	sts	0x05D0, r24
    1658:	0f c0       	rjmp	.+30     	; 0x1678 <__vector_3+0x86>

	}
	else
	{
		
		if (RX1_YAW)
    165a:	83 b1       	in	r24, 0x03	; 3
    165c:	82 ff       	sbrs	r24, 2
    165e:	09 c0       	rjmp	.+18     	; 0x1672 <__vector_3+0x80>
		{
			RX_raw[0][RXChannel_RUD]=TCNT1;
    1660:	80 91 84 00 	lds	r24, 0x0084
    1664:	90 91 85 00 	lds	r25, 0x0085
    1668:	90 93 27 08 	sts	0x0827, r25
    166c:	80 93 26 08 	sts	0x0826, r24
    1670:	03 c0       	rjmp	.+6      	; 0x1678 <__vector_3+0x86>
		}
		else
		{
			CalculateSignalLength1(RXChannel_RUD);
    1672:	82 e0       	ldi	r24, 0x02	; 2
    1674:	0e 94 47 25 	call	0x4a8e	; 0x4a8e <CalculateSignalLength1>
		}
	}	
}
    1678:	ff 91       	pop	r31
    167a:	ef 91       	pop	r30
    167c:	bf 91       	pop	r27
    167e:	af 91       	pop	r26
    1680:	9f 91       	pop	r25
    1682:	8f 91       	pop	r24
    1684:	7f 91       	pop	r23
    1686:	6f 91       	pop	r22
    1688:	5f 91       	pop	r21
    168a:	4f 91       	pop	r20
    168c:	3f 91       	pop	r19
    168e:	2f 91       	pop	r18
    1690:	0f 90       	pop	r0
    1692:	0f be       	out	0x3f, r0	; 63
    1694:	0f 90       	pop	r0
    1696:	1f 90       	pop	r1
    1698:	18 95       	reti

0000169a <__vector_5>:



__attribute__ ((section(".lowtext")))
ISR (RX_AUX_vect)
{
    169a:	1f 92       	push	r1
    169c:	0f 92       	push	r0
    169e:	0f b6       	in	r0, 0x3f	; 63
    16a0:	0f 92       	push	r0
    16a2:	11 24       	eor	r1, r1
    16a4:	2f 93       	push	r18
    16a6:	3f 93       	push	r19
    16a8:	4f 93       	push	r20
    16aa:	5f 93       	push	r21
    16ac:	6f 93       	push	r22
    16ae:	7f 93       	push	r23
    16b0:	8f 93       	push	r24
    16b2:	9f 93       	push	r25
    16b4:	af 93       	push	r26
    16b6:	bf 93       	push	r27
    16b8:	ef 93       	push	r30
    16ba:	ff 93       	push	r31
	// There is only ONE AUX PORT - usually assigned to Secondary RX 
	if (RX_AUX)
    16bc:	83 b1       	in	r24, 0x03	; 3
    16be:	80 ff       	sbrs	r24, 0
    16c0:	0c c0       	rjmp	.+24     	; 0x16da <__vector_5+0x40>
	{
		RX_raw[1][RXChannel_AUX]=TCNT1;
    16c2:	80 91 84 00 	lds	r24, 0x0084
    16c6:	90 91 85 00 	lds	r25, 0x0085
    16ca:	90 93 35 08 	sts	0x0835, r25
    16ce:	80 93 34 08 	sts	0x0834, r24
		UpdateServo=true;
    16d2:	81 e0       	ldi	r24, 0x01	; 1
    16d4:	80 93 e4 06 	sts	0x06E4, r24
    16d8:	0b c0       	rjmp	.+22     	; 0x16f0 <__vector_5+0x56>
	}
	else
	{
		CalculateSignalLength2(RXChannel_AUX);
    16da:	84 e0       	ldi	r24, 0x04	; 4
    16dc:	0e 94 70 25 	call	0x4ae0	; 0x4ae0 <CalculateSignalLength2>
		RX_Length[0][RXChannel_AUX]=RX_Length[1][RXChannel_AUX];
    16e0:	80 91 de 05 	lds	r24, 0x05DE
    16e4:	90 91 df 05 	lds	r25, 0x05DF
    16e8:	90 93 d5 05 	sts	0x05D5, r25
    16ec:	80 93 d4 05 	sts	0x05D4, r24
	}

}
    16f0:	ff 91       	pop	r31
    16f2:	ef 91       	pop	r30
    16f4:	bf 91       	pop	r27
    16f6:	af 91       	pop	r26
    16f8:	9f 91       	pop	r25
    16fa:	8f 91       	pop	r24
    16fc:	7f 91       	pop	r23
    16fe:	6f 91       	pop	r22
    1700:	5f 91       	pop	r21
    1702:	4f 91       	pop	r20
    1704:	3f 91       	pop	r19
    1706:	2f 91       	pop	r18
    1708:	0f 90       	pop	r0
    170a:	0f be       	out	0x3f, r0	; 63
    170c:	0f 90       	pop	r0
    170e:	1f 90       	pop	r1
    1710:	18 95       	reti

00001712 <__ctors_end>:
    1712:	11 24       	eor	r1, r1
    1714:	1f be       	out	0x3f, r1	; 63
    1716:	cf ef       	ldi	r28, 0xFF	; 255
    1718:	d8 e0       	ldi	r29, 0x08	; 8
    171a:	de bf       	out	0x3e, r29	; 62
    171c:	cd bf       	out	0x3d, r28	; 61

0000171e <__do_copy_data>:
    171e:	11 e0       	ldi	r17, 0x01	; 1
    1720:	a0 e0       	ldi	r26, 0x00	; 0
    1722:	b1 e0       	ldi	r27, 0x01	; 1
    1724:	e6 e0       	ldi	r30, 0x06	; 6
    1726:	fb e7       	ldi	r31, 0x7B	; 123
    1728:	02 c0       	rjmp	.+4      	; 0x172e <__do_copy_data+0x10>
    172a:	05 90       	lpm	r0, Z+
    172c:	0d 92       	st	X+, r0
    172e:	a2 32       	cpi	r26, 0x22	; 34
    1730:	b1 07       	cpc	r27, r17
    1732:	d9 f7       	brne	.-10     	; 0x172a <__do_copy_data+0xc>

00001734 <__do_clear_bss>:
    1734:	18 e0       	ldi	r17, 0x08	; 8
    1736:	a2 e2       	ldi	r26, 0x22	; 34
    1738:	b1 e0       	ldi	r27, 0x01	; 1
    173a:	01 c0       	rjmp	.+2      	; 0x173e <.do_clear_bss_start>

0000173c <.do_clear_bss_loop>:
    173c:	1d 92       	st	X+, r1

0000173e <.do_clear_bss_start>:
    173e:	a7 34       	cpi	r26, 0x47	; 71
    1740:	b1 07       	cpc	r27, r17
    1742:	e1 f7       	brne	.-8      	; 0x173c <.do_clear_bss_loop>
    1744:	0e 94 c7 18 	call	0x318e	; 0x318e <main>
    1748:	0c 94 81 3d 	jmp	0x7b02	; 0x7b02 <_exit>

0000174c <__bad_interrupt>:
    174c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00001750 <Beeper_Beep>:
#include "../Include/Misc.h"
#include "../Include/IO_config.h"


void Beeper_Beep (uint16_t msDuration, uint8_t Times)
{
    1750:	ef 92       	push	r14
    1752:	ff 92       	push	r15
    1754:	0f 93       	push	r16
    1756:	1f 93       	push	r17
    1758:	cf 93       	push	r28
    175a:	df 93       	push	r29
    175c:	ec 01       	movw	r28, r24
	
	//bool CurrentBuzzer_Status = Buzzer;
	
	for (int i=0; i< Times; ++i)
    175e:	00 e0       	ldi	r16, 0x00	; 0
    1760:	10 e0       	ldi	r17, 0x00	; 0
    1762:	e6 2e       	mov	r14, r22
    1764:	ff 24       	eor	r15, r15
    1766:	0a c0       	rjmp	.+20     	; 0x177c <Beeper_Beep+0x2c>
	{
		Buzzer = ON;
    1768:	29 9a       	sbi	0x05, 1	; 5
		delay_ms(msDuration);
    176a:	ce 01       	movw	r24, r28
    176c:	0e 94 0c 0f 	call	0x1e18	; 0x1e18 <delay_ms>
		Buzzer = OFF;
    1770:	29 98       	cbi	0x05, 1	; 5
		delay_ms(msDuration);		
    1772:	ce 01       	movw	r24, r28
    1774:	0e 94 0c 0f 	call	0x1e18	; 0x1e18 <delay_ms>
void Beeper_Beep (uint16_t msDuration, uint8_t Times)
{
	
	//bool CurrentBuzzer_Status = Buzzer;
	
	for (int i=0; i< Times; ++i)
    1778:	0f 5f       	subi	r16, 0xFF	; 255
    177a:	1f 4f       	sbci	r17, 0xFF	; 255
    177c:	0e 15       	cp	r16, r14
    177e:	1f 05       	cpc	r17, r15
    1780:	9c f3       	brlt	.-26     	; 0x1768 <Beeper_Beep+0x18>
		delay_ms(msDuration);		
	}
	
	//Buzzer = CurrentBuzzer_Status;
	
}
    1782:	df 91       	pop	r29
    1784:	cf 91       	pop	r28
    1786:	1f 91       	pop	r17
    1788:	0f 91       	pop	r16
    178a:	ff 90       	pop	r15
    178c:	ef 90       	pop	r14
    178e:	08 95       	ret

00001790 <KeyBoard_Init>:

void KeyBoard_Init (void)
{

	// key pins to input
	KEYBOARD_DDR |= ALLKEYS;
    1790:	84 b1       	in	r24, 0x04	; 4
    1792:	80 6f       	ori	r24, 0xF0	; 240
    1794:	84 b9       	out	0x04, r24	; 4

	
	// pull up resistors on
	KEYBOARD_PORT |= ALLKEYS;
    1796:	85 b1       	in	r24, 0x05	; 5
    1798:	80 6f       	ori	r24, 0xF0	; 240
    179a:	85 b9       	out	0x05, r24	; 5
	
}
    179c:	08 95       	ret

0000179e <Keyboard_Read>:

uint16_t TCNT_X_snapshot3=0;
uint8_t Keyboard_Read()
{
    179e:	0f 93       	push	r16
    17a0:	1f 93       	push	r17
	uint8_t keys = ~KEYBOARD_PIN & ALLKEYS;
    17a2:	13 b1       	in	r17, 0x03	; 3
    17a4:	10 95       	com	r17
    17a6:	10 7f       	andi	r17, 0xF0	; 240
	uint8_t newkeys = keys & ~lastKeys; // always equal to ZERO  for repeated buttons.
    17a8:	00 91 bd 05 	lds	r16, 0x05BD
	_keyrepeat = KEYBOARD_NO_REPEAT;
    17ac:	10 92 cb 05 	sts	0x05CB, r1
	if (keys !=0) // if any key pressed even repeated.
    17b0:	11 23       	and	r17, r17
    17b2:	21 f1       	breq	.+72     	; 0x17fc <Keyboard_Read+0x5e>
	{
		if (IsArmed==true) Disarm(); // this is for your own safety.
    17b4:	80 91 c8 07 	lds	r24, 0x07C8
    17b8:	81 30       	cpi	r24, 0x01	; 1
    17ba:	11 f4       	brne	.+4      	; 0x17c0 <Keyboard_Read+0x22>
    17bc:	0e 94 29 0f 	call	0x1e52	; 0x1e52 <Disarm>
		
		if ((lastKeys!=keys))
    17c0:	80 91 bd 05 	lds	r24, 0x05BD
    17c4:	81 17       	cp	r24, r17
    17c6:	59 f0       	breq	.+22     	; 0x17de <Keyboard_Read+0x40>
		{	// Reset Timer if not the same key.
			TCNT_X_snapshot3 = TCNT1_X+300;
    17c8:	80 91 70 06 	lds	r24, 0x0670
    17cc:	90 91 71 06 	lds	r25, 0x0671
    17d0:	84 5d       	subi	r24, 0xD4	; 212
    17d2:	9e 4f       	sbci	r25, 0xFE	; 254
    17d4:	90 93 23 01 	sts	0x0123, r25
    17d8:	80 93 22 01 	sts	0x0122, r24
    17dc:	0f c0       	rjmp	.+30     	; 0x17fc <Keyboard_Read+0x5e>
		}
		else
		{	// Count to measure the key press duration.
			if ((TCNT_X_snapshot3 < TCNT1_X)) // some racing condition might happen here but not a problem we  dont need an atomic read for UI btn click.
    17de:	20 91 70 06 	lds	r18, 0x0670
    17e2:	30 91 71 06 	lds	r19, 0x0671
    17e6:	40 91 22 01 	lds	r20, 0x0122
    17ea:	50 91 23 01 	lds	r21, 0x0123
    17ee:	42 17       	cp	r20, r18
    17f0:	53 07       	cpc	r21, r19
    17f2:	20 f4       	brcc	.+8      	; 0x17fc <Keyboard_Read+0x5e>
			{
				_keyrepeat = KEYBOARD_REPEAT;
    17f4:	91 e0       	ldi	r25, 0x01	; 1
    17f6:	90 93 cb 05 	sts	0x05CB, r25
				return keys; // re-press keys and set the repeated flag for more GUI handling.
    17fa:	05 c0       	rjmp	.+10     	; 0x1806 <Keyboard_Read+0x68>

uint16_t TCNT_X_snapshot3=0;
uint8_t Keyboard_Read()
{
	uint8_t keys = ~KEYBOARD_PIN & ALLKEYS;
	uint8_t newkeys = keys & ~lastKeys; // always equal to ZERO  for repeated buttons.
    17fc:	80 2f       	mov	r24, r16
    17fe:	80 95       	com	r24
				_keyrepeat = KEYBOARD_REPEAT;
				return keys; // re-press keys and set the repeated flag for more GUI handling.
			}
		}
	}	
	lastKeys = keys;
    1800:	10 93 bd 05 	sts	0x05BD, r17
	return newkeys;
    1804:	81 23       	and	r24, r17
}
    1806:	1f 91       	pop	r17
    1808:	0f 91       	pop	r16
    180a:	08 95       	ret

0000180c <Keyboard_State>:


inline uint8_t Keyboard_State()
{
	return lastKeys;
}
    180c:	80 91 bd 05 	lds	r24, 0x05BD
    1810:	08 95       	ret

00001812 <sendData>:
	//LCD_CS = 1;
//}

static void sendData(uint8_t data, uint8_t CommandorData)
{
	LCD_CS = 0;
    1812:	5d 98       	cbi	0x0b, 5	; 11
	LCD_A0 = CommandorData;
    1814:	67 95       	ror	r22
    1816:	66 27       	eor	r22, r22
    1818:	67 95       	ror	r22
    181a:	9b b1       	in	r25, 0x0b	; 11
    181c:	9f 77       	andi	r25, 0x7F	; 127
    181e:	96 2b       	or	r25, r22
    1820:	9b b9       	out	0x0b, r25	; 11
    1822:	98 e0       	ldi	r25, 0x08	; 8

static void sendByte(uint8_t byte)
{
	for (uint8_t i = 8; i; i--)
	{
		LCD_SCL = 0;
    1824:	5c 98       	cbi	0x0b, 4	; 11
		
		if (byte & 0x80) // read MSB [& b10000000]
    1826:	87 ff       	sbrs	r24, 7
    1828:	02 c0       	rjmp	.+4      	; 0x182e <sendData+0x1c>
			LCD_SDA = 1;
    182a:	59 9a       	sbi	0x0b, 1	; 11
    182c:	01 c0       	rjmp	.+2      	; 0x1830 <sendData+0x1e>
		else
			LCD_SDA = 0;
    182e:	59 98       	cbi	0x0b, 1	; 11
		
		LCD_SCL = 1;
    1830:	5c 9a       	sbi	0x0b, 4	; 11
    1832:	91 50       	subi	r25, 0x01	; 1
static uint8_t _curx, _cury;
static fontdescriptor_t _font;

static void sendByte(uint8_t byte)
{
	for (uint8_t i = 8; i; i--)
    1834:	11 f0       	breq	.+4      	; 0x183a <sendData+0x28>
			LCD_SDA = 1;
		else
			LCD_SDA = 0;
		
		LCD_SCL = 1;
		byte <<= 1;
    1836:	88 0f       	add	r24, r24
    1838:	f5 cf       	rjmp	.-22     	; 0x1824 <sendData+0x12>
static void sendData(uint8_t data, uint8_t CommandorData)
{
	LCD_CS = 0;
	LCD_A0 = CommandorData;
	sendByte(data);
	LCD_CS = 1;
    183a:	5d 9a       	sbi	0x0b, 5	; 11
}
    183c:	08 95       	ret

0000183e <LCD_SetPos>:
	offset %= sizeof(_screen);
}

void LCD_SetPos(uint8_t line, uint8_t column)
{
	_curx = column % LCDWIDTH;
    183e:	6f 77       	andi	r22, 0x7F	; 127
    1840:	60 93 2a 01 	sts	0x012A, r22
	_cury = line * 8;
    1844:	88 0f       	add	r24, r24
    1846:	88 0f       	add	r24, r24
    1848:	88 0f       	add	r24, r24
    184a:	80 93 29 01 	sts	0x0129, r24
}
    184e:	08 95       	ret

00001850 <lcdXY>:

void lcdXY(uint8_t x, uint8_t y)
{
	_curx = x;
    1850:	80 93 2a 01 	sts	0x012A, r24
	_cury = y;
    1854:	60 93 29 01 	sts	0x0129, r22
}
    1858:	08 95       	ret

0000185a <lcdSetPixel>:

void lcdSetPixel(uint8_t x, uint8_t y, uint8_t on)
{
	static const prog_char masks[8] = {0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80};
	uint8_t *scr = _screen + x + (y / 8 * LCDWIDTH); 
    185a:	26 2f       	mov	r18, r22
    185c:	26 95       	lsr	r18
    185e:	26 95       	lsr	r18
    1860:	26 95       	lsr	r18
    1862:	30 e0       	ldi	r19, 0x00	; 0
    1864:	36 95       	lsr	r19
    1866:	32 2f       	mov	r19, r18
    1868:	22 27       	eor	r18, r18
    186a:	37 95       	ror	r19
    186c:	27 95       	ror	r18
    186e:	28 0f       	add	r18, r24
    1870:	31 1d       	adc	r19, r1
	uint8_t mask = pgm_read_byte(&masks[y % 8]);
    1872:	e6 2f       	mov	r30, r22
    1874:	f0 e0       	ldi	r31, 0x00	; 0
    1876:	e7 70       	andi	r30, 0x07	; 7
    1878:	f0 70       	andi	r31, 0x00	; 0
    187a:	ea 55       	subi	r30, 0x5A	; 90
    187c:	ff 4f       	sbci	r31, 0xFF	; 255
    187e:	e4 91       	lpm	r30, Z+
	if ((_flags & REVERSED) ^ !on)
    1880:	91 e0       	ldi	r25, 0x01	; 1
    1882:	41 11       	cpse	r20, r1
    1884:	90 e0       	ldi	r25, 0x00	; 0
    1886:	80 91 28 01 	lds	r24, 0x0128
    188a:	81 70       	andi	r24, 0x01	; 1
    188c:	d9 01       	movw	r26, r18
    188e:	a5 5d       	subi	r26, 0xD5	; 213
    1890:	be 4f       	sbci	r27, 0xFE	; 254
    1892:	89 17       	cp	r24, r25
    1894:	29 f0       	breq	.+10     	; 0x18a0 <lcdSetPixel+0x46>
		*scr = *scr & ~mask;
    1896:	e0 95       	com	r30
    1898:	8c 91       	ld	r24, X
    189a:	e8 23       	and	r30, r24
    189c:	ec 93       	st	X, r30
    189e:	08 95       	ret
	else
		*scr = *scr | mask;
    18a0:	8c 91       	ld	r24, X
    18a2:	8e 2b       	or	r24, r30
    18a4:	8c 93       	st	X, r24
    18a6:	08 95       	ret

000018a8 <LCD_Line>:
			////
		////e2 = 2 * err;
		////if (e2 > dy) { err += dy; x0 += sx; } /* e_xy + e_x > 0 */
		////if (e2 < dx) { err += dx; y0 += sy; } /* e_xy + e_y < 0 */
	////}
}
    18a8:	08 95       	ret

000018aa <LCD_Rectangle>:
	//for (a = y0; a <= y1; a++)
	//{
		//lcdSetPixel(x0, a, color);
		//lcdSetPixel(x1, a, color);
	//}
}
    18aa:	08 95       	ret

000018ac <LCD_FillRectangle>:
	//if (x0 > x1) { a = x0; x0 = x1; x1 = a;}
	//if (y0 > y1) { a = y0; y0 = y1; y1 = a;}
	//for (a = y0; a <= y1; a++)
		//for(uint8_t i = x0; i <= x1; i++)
			//lcdSetPixel(i, a, color);
}
    18ac:	08 95       	ret

000018ae <LCD_Clear>:
 
void LCD_Clear()
{
	memset(_screen, 0, sizeof(_screen));
    18ae:	80 e0       	ldi	r24, 0x00	; 0
    18b0:	94 e0       	ldi	r25, 0x04	; 4
    18b2:	eb e2       	ldi	r30, 0x2B	; 43
    18b4:	f1 e0       	ldi	r31, 0x01	; 1
    18b6:	df 01       	movw	r26, r30
    18b8:	9c 01       	movw	r18, r24
    18ba:	1d 92       	st	X+, r1
    18bc:	21 50       	subi	r18, 0x01	; 1
    18be:	30 40       	sbci	r19, 0x00	; 0
    18c0:	e1 f7       	brne	.-8      	; 0x18ba <LCD_Clear+0xc>
	LCD_SetPos(0, 0);
    18c2:	80 e0       	ldi	r24, 0x00	; 0
    18c4:	60 e0       	ldi	r22, 0x00	; 0
    18c6:	0e 94 1f 0c 	call	0x183e	; 0x183e <LCD_SetPos>
	_flags = 0;
    18ca:	10 92 28 01 	sts	0x0128, r1
}
    18ce:	08 95       	ret

000018d0 <lcdWriteSprite_P>:

void lcdWriteSprite_P(PGM_P sprite, uint8_t sizeX, uint8_t sizeY, uint8_t mode)
{
    18d0:	8f 92       	push	r8
    18d2:	9f 92       	push	r9
    18d4:	bf 92       	push	r11
    18d6:	cf 92       	push	r12
    18d8:	df 92       	push	r13
    18da:	ef 92       	push	r14
    18dc:	ff 92       	push	r15
    18de:	0f 93       	push	r16
    18e0:	1f 93       	push	r17
    18e2:	df 93       	push	r29
    18e4:	cf 93       	push	r28
    18e6:	0f 92       	push	r0
    18e8:	cd b7       	in	r28, 0x3d	; 61
    18ea:	de b7       	in	r29, 0x3e	; 62
    18ec:	4c 01       	movw	r8, r24
    18ee:	e6 2e       	mov	r14, r22
    18f0:	f4 2e       	mov	r15, r20
    18f2:	c2 2e       	mov	r12, r18
	uint8_t b = 0;
	for (uint8_t i = 0; i < sizeX; i++)
    18f4:	dd 24       	eor	r13, r13
	_flags = 0;
}

void lcdWriteSprite_P(PGM_P sprite, uint8_t sizeX, uint8_t sizeY, uint8_t mode)
{
	uint8_t b = 0;
    18f6:	bb 24       	eor	r11, r11
			if (j % 8 == 0)
					b = pgm_read_byte(sprite++);
					
			if (mode == ROP_COPY)
			{
				if ((_cury % 8 == 0) && (sizeY - j >= 8))
    18f8:	04 2f       	mov	r16, r20
    18fa:	10 e0       	ldi	r17, 0x00	; 0
}

void lcdWriteSprite_P(PGM_P sprite, uint8_t sizeX, uint8_t sizeY, uint8_t mode)
{
	uint8_t b = 0;
	for (uint8_t i = 0; i < sizeX; i++)
    18fc:	4f c0       	rjmp	.+158    	; 0x199c <lcdWriteSprite_P+0xcc>
	{
		for (uint8_t j = 0; j < sizeY; j++)
		{
			if (j % 8 == 0)
    18fe:	83 2f       	mov	r24, r19
    1900:	87 70       	andi	r24, 0x07	; 7
    1902:	29 f4       	brne	.+10     	; 0x190e <lcdWriteSprite_P+0x3e>
					b = pgm_read_byte(sprite++);
    1904:	f4 01       	movw	r30, r8
    1906:	08 94       	sec
    1908:	81 1c       	adc	r8, r1
    190a:	91 1c       	adc	r9, r1
    190c:	b4 90       	lpm	r11, Z+
					
			if (mode == ROP_COPY)
    190e:	cc 20       	and	r12, r12
    1910:	79 f5       	brne	.+94     	; 0x1970 <lcdWriteSprite_P+0xa0>
			{
				if ((_cury % 8 == 0) && (sizeY - j >= 8))
    1912:	60 91 29 01 	lds	r22, 0x0129
    1916:	86 2f       	mov	r24, r22
    1918:	87 70       	andi	r24, 0x07	; 7
    191a:	19 f5       	brne	.+70     	; 0x1962 <lcdWriteSprite_P+0x92>
    191c:	c8 01       	movw	r24, r16
    191e:	83 1b       	sub	r24, r19
    1920:	91 09       	sbc	r25, r1
    1922:	88 30       	cpi	r24, 0x08	; 8
    1924:	91 05       	cpc	r25, r1
    1926:	ec f0       	brlt	.+58     	; 0x1962 <lcdWriteSprite_P+0x92>
				{
					lcdSetByte(_curx + i, _cury + j, b);
    1928:	63 0f       	add	r22, r19
		*scr = *scr | mask;
}

static void lcdSetByte(uint8_t x, uint8_t y, uint8_t b)
{
	uint8_t *scr = _screen + x + (y / 8 * LCDWIDTH); 
    192a:	66 95       	lsr	r22
    192c:	66 95       	lsr	r22
    192e:	66 95       	lsr	r22
    1930:	a6 2f       	mov	r26, r22
    1932:	b0 e0       	ldi	r27, 0x00	; 0
    1934:	b6 95       	lsr	r27
    1936:	ba 2f       	mov	r27, r26
    1938:	aa 27       	eor	r26, r26
    193a:	b7 95       	ror	r27
    193c:	a7 95       	ror	r26
					
			if (mode == ROP_COPY)
			{
				if ((_cury % 8 == 0) && (sizeY - j >= 8))
				{
					lcdSetByte(_curx + i, _cury + j, b);
    193e:	80 91 2a 01 	lds	r24, 0x012A
    1942:	8d 0d       	add	r24, r13
		*scr = *scr | mask;
}

static void lcdSetByte(uint8_t x, uint8_t y, uint8_t b)
{
	uint8_t *scr = _screen + x + (y / 8 * LCDWIDTH); 
    1944:	a8 0f       	add	r26, r24
    1946:	b1 1d       	adc	r27, r1
	if (_flags & REVERSED)
    1948:	80 91 28 01 	lds	r24, 0x0128
    194c:	a5 5d       	subi	r26, 0xD5	; 213
    194e:	be 4f       	sbci	r27, 0xFE	; 254
    1950:	80 ff       	sbrs	r24, 0
    1952:	04 c0       	rjmp	.+8      	; 0x195c <lcdWriteSprite_P+0x8c>
		*scr = ~b;
    1954:	8b 2d       	mov	r24, r11
    1956:	80 95       	com	r24
    1958:	8c 93       	st	X, r24
    195a:	01 c0       	rjmp	.+2      	; 0x195e <lcdWriteSprite_P+0x8e>
	else
		*scr = b;
    195c:	bc 92       	st	X, r11
			if (mode == ROP_COPY)
			{
				if ((_cury % 8 == 0) && (sizeY - j >= 8))
				{
					lcdSetByte(_curx + i, _cury + j, b);
					j += 7; // just +7 b/c the loop increments anyway
    195e:	39 5f       	subi	r19, 0xF9	; 249
    1960:	17 c0       	rjmp	.+46     	; 0x1990 <lcdWriteSprite_P+0xc0>
				}
				else
					lcdSetPixel(_curx + i, _cury + j, b & 0x01);
    1962:	80 91 2a 01 	lds	r24, 0x012A
    1966:	63 0f       	add	r22, r19
    1968:	4b 2d       	mov	r20, r11
    196a:	41 70       	andi	r20, 0x01	; 1
    196c:	8d 0d       	add	r24, r13
    196e:	0c c0       	rjmp	.+24     	; 0x1988 <lcdWriteSprite_P+0xb8>
			}				
			else if (mode == ROP_PAINT)
    1970:	8c 2d       	mov	r24, r12
    1972:	81 30       	cpi	r24, 0x01	; 1
    1974:	69 f4       	brne	.+26     	; 0x1990 <lcdWriteSprite_P+0xc0>
			{
				if (b & 0x01)
    1976:	b0 fe       	sbrs	r11, 0
    1978:	0b c0       	rjmp	.+22     	; 0x1990 <lcdWriteSprite_P+0xc0>
					lcdSetPixel(_curx + i, _cury + j, 1);
    197a:	80 91 2a 01 	lds	r24, 0x012A
    197e:	60 91 29 01 	lds	r22, 0x0129
    1982:	63 0f       	add	r22, r19
    1984:	8d 0d       	add	r24, r13
    1986:	41 e0       	ldi	r20, 0x01	; 1
    1988:	39 83       	std	Y+1, r19	; 0x01
    198a:	0e 94 2d 0c 	call	0x185a	; 0x185a <lcdSetPixel>
    198e:	39 81       	ldd	r19, Y+1	; 0x01
			}			
			b >>= 1;
    1990:	b6 94       	lsr	r11
void lcdWriteSprite_P(PGM_P sprite, uint8_t sizeX, uint8_t sizeY, uint8_t mode)
{
	uint8_t b = 0;
	for (uint8_t i = 0; i < sizeX; i++)
	{
		for (uint8_t j = 0; j < sizeY; j++)
    1992:	3f 5f       	subi	r19, 0xFF	; 255
    1994:	3f 15       	cp	r19, r15
    1996:	08 f4       	brcc	.+2      	; 0x199a <lcdWriteSprite_P+0xca>
    1998:	b2 cf       	rjmp	.-156    	; 0x18fe <lcdWriteSprite_P+0x2e>
}

void lcdWriteSprite_P(PGM_P sprite, uint8_t sizeX, uint8_t sizeY, uint8_t mode)
{
	uint8_t b = 0;
	for (uint8_t i = 0; i < sizeX; i++)
    199a:	d3 94       	inc	r13
    199c:	de 14       	cp	r13, r14
    199e:	10 f4       	brcc	.+4      	; 0x19a4 <lcdWriteSprite_P+0xd4>
    19a0:	30 e0       	ldi	r19, 0x00	; 0
    19a2:	f8 cf       	rjmp	.-16     	; 0x1994 <lcdWriteSprite_P+0xc4>
					lcdSetPixel(_curx + i, _cury + j, 1);
			}			
			b >>= 1;
		}
	}	
}
    19a4:	0f 90       	pop	r0
    19a6:	cf 91       	pop	r28
    19a8:	df 91       	pop	r29
    19aa:	1f 91       	pop	r17
    19ac:	0f 91       	pop	r16
    19ae:	ff 90       	pop	r15
    19b0:	ef 90       	pop	r14
    19b2:	df 90       	pop	r13
    19b4:	cf 90       	pop	r12
    19b6:	bf 90       	pop	r11
    19b8:	9f 90       	pop	r9
    19ba:	8f 90       	pop	r8
    19bc:	08 95       	ret

000019be <lcdWriteGlyph_P>:

void lcdWriteGlyph_P(const glyph_t *glyph, uint8_t mode)
{
    19be:	26 2f       	mov	r18, r22
	uint8_t sizeX = pgm_read_byte(&glyph->sizeX);
    19c0:	fc 01       	movw	r30, r24
    19c2:	64 91       	lpm	r22, Z+
	uint8_t sizeY = pgm_read_byte(&glyph->sizeY);
    19c4:	31 96       	adiw	r30, 0x01	; 1
    19c6:	44 91       	lpm	r20, Z+
	lcdWriteSprite_P((PGM_P)&glyph->glyph, sizeX, sizeY, mode);
    19c8:	02 96       	adiw	r24, 0x02	; 2
    19ca:	0e 94 68 0c 	call	0x18d0	; 0x18d0 <lcdWriteSprite_P>
}
    19ce:	08 95       	ret

000019d0 <lcdWriteChar>:

void lcdWriteChar(char c)
{
	if (c == '\n')
    19d0:	8a 30       	cpi	r24, 0x0A	; 10
    19d2:	51 f4       	brne	.+20     	; 0x19e8 <lcdWriteChar+0x18>
	{
		_cury += _font.sizeY;
    19d4:	80 91 29 01 	lds	r24, 0x0129
    19d8:	90 91 25 01 	lds	r25, 0x0125
    19dc:	89 0f       	add	r24, r25
    19de:	80 93 29 01 	sts	0x0129, r24
		_curx = 0;
    19e2:	10 92 2a 01 	sts	0x012A, r1
    19e6:	08 95       	ret
	}
	else
	{
		lcdWriteSprite_P(_font.selector(c), _font.sizeX, _font.sizeY, 0);
    19e8:	e0 91 26 01 	lds	r30, 0x0126
    19ec:	f0 91 27 01 	lds	r31, 0x0127
    19f0:	09 95       	icall
    19f2:	60 91 24 01 	lds	r22, 0x0124
    19f6:	40 91 25 01 	lds	r20, 0x0125
    19fa:	20 e0       	ldi	r18, 0x00	; 0
    19fc:	0e 94 68 0c 	call	0x18d0	; 0x18d0 <lcdWriteSprite_P>
		_curx += _font.sizeX;
    1a00:	80 91 2a 01 	lds	r24, 0x012A
    1a04:	90 91 24 01 	lds	r25, 0x0124
    1a08:	89 0f       	add	r24, r25
    1a0a:	80 93 2a 01 	sts	0x012A, r24
    1a0e:	08 95       	ret

00001a10 <LCD_WriteString>:
	}
}

void LCD_WriteString(char *s)
{
    1a10:	ef 92       	push	r14
    1a12:	ff 92       	push	r15
    1a14:	cf 93       	push	r28
    1a16:	df 93       	push	r29
    1a18:	e8 2e       	mov	r14, r24
    1a1a:	e7 01       	movw	r28, r14
    1a1c:	7e 01       	movw	r14, r28
    1a1e:	f9 2e       	mov	r15, r25
    1a20:	e7 01       	movw	r28, r14
	while (*s)
    1a22:	02 c0       	rjmp	.+4      	; 0x1a28 <LCD_WriteString+0x18>
	{
		lcdWriteChar(*s);
    1a24:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <lcdWriteChar>
	}
}

void LCD_WriteString(char *s)
{
	while (*s)
    1a28:	89 91       	ld	r24, Y+
    1a2a:	88 23       	and	r24, r24
    1a2c:	d9 f7       	brne	.-10     	; 0x1a24 <LCD_WriteString+0x14>
	{
		lcdWriteChar(*s);
		s++;
	}		
}
    1a2e:	df 91       	pop	r29
    1a30:	cf 91       	pop	r28
    1a32:	ff 90       	pop	r15
    1a34:	ef 90       	pop	r14
    1a36:	08 95       	ret

00001a38 <LCD_WriteString_P>:
}



void LCD_WriteString_P(PGM_P s)
{
    1a38:	cf 93       	push	r28
    1a3a:	df 93       	push	r29
    1a3c:	ec 01       	movw	r28, r24
	char c;
	while ((c = pgm_read_byte(s++)))
    1a3e:	02 c0       	rjmp	.+4      	; 0x1a44 <LCD_WriteString_P+0xc>
		lcdWriteChar(c);
    1a40:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <lcdWriteChar>
    1a44:	fe 01       	movw	r30, r28


void LCD_WriteString_P(PGM_P s)
{
	char c;
	while ((c = pgm_read_byte(s++)))
    1a46:	21 96       	adiw	r28, 0x01	; 1
    1a48:	84 91       	lpm	r24, Z+
    1a4a:	88 23       	and	r24, r24
    1a4c:	c9 f7       	brne	.-14     	; 0x1a40 <LCD_WriteString_P+0x8>
		lcdWriteChar(c);
}
    1a4e:	df 91       	pop	r29
    1a50:	cf 91       	pop	r28
    1a52:	08 95       	ret

00001a54 <lcdReverse>:
	lcdReverse(0);
}


void lcdReverse(uint8_t reversed)
{
    1a54:	90 91 28 01 	lds	r25, 0x0128
	if (reversed)
    1a58:	88 23       	and	r24, r24
    1a5a:	11 f0       	breq	.+4      	; 0x1a60 <lcdReverse+0xc>
		_flags |= REVERSED;
    1a5c:	91 60       	ori	r25, 0x01	; 1
    1a5e:	01 c0       	rjmp	.+2      	; 0x1a62 <lcdReverse+0xe>
	else
		_flags &= ~REVERSED;
    1a60:	9e 7f       	andi	r25, 0xFE	; 254
    1a62:	90 93 28 01 	sts	0x0128, r25
    1a66:	08 95       	ret

00001a68 <LCD_WriteStringex>:
}



void LCD_WriteStringex(uint8_t x, uint8_t y, char *str, BOOL LCDReverse)
{
    1a68:	ef 92       	push	r14
    1a6a:	ff 92       	push	r15
    1a6c:	0f 93       	push	r16
    1a6e:	1f 93       	push	r17
    1a70:	df 93       	push	r29
    1a72:	cf 93       	push	r28
    1a74:	00 d0       	rcall	.+0      	; 0x1a76 <LCD_WriteStringex+0xe>
    1a76:	0f 92       	push	r0
    1a78:	cd b7       	in	r28, 0x3d	; 61
    1a7a:	de b7       	in	r29, 0x3e	; 62
    1a7c:	18 2f       	mov	r17, r24
    1a7e:	82 2f       	mov	r24, r18
	lcdReverse(LCDReverse);
    1a80:	4a 83       	std	Y+2, r20	; 0x02
    1a82:	5b 83       	std	Y+3, r21	; 0x03
    1a84:	69 83       	std	Y+1, r22	; 0x01
    1a86:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <lcdReverse>
	LCD_SetPos(x, y);
    1a8a:	81 2f       	mov	r24, r17
    1a8c:	69 81       	ldd	r22, Y+1	; 0x01
    1a8e:	0e 94 1f 0c 	call	0x183e	; 0x183e <LCD_SetPos>
    1a92:	4a 81       	ldd	r20, Y+2	; 0x02
    1a94:	5b 81       	ldd	r21, Y+3	; 0x03
    1a96:	8a 01       	movw	r16, r20
	while (*str)
    1a98:	02 c0       	rjmp	.+4      	; 0x1a9e <LCD_WriteStringex+0x36>
	{
		lcdWriteChar(*str);
    1a9a:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <lcdWriteChar>

void LCD_WriteStringex(uint8_t x, uint8_t y, char *str, BOOL LCDReverse)
{
	lcdReverse(LCDReverse);
	LCD_SetPos(x, y);
	while (*str)
    1a9e:	f8 01       	movw	r30, r16
    1aa0:	81 91       	ld	r24, Z+
    1aa2:	8f 01       	movw	r16, r30
    1aa4:	88 23       	and	r24, r24
    1aa6:	c9 f7       	brne	.-14     	; 0x1a9a <LCD_WriteStringex+0x32>
	{
		lcdWriteChar(*str);
		str++;
	}		
	lcdReverse(0);
    1aa8:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <lcdReverse>
}
    1aac:	0f 90       	pop	r0
    1aae:	0f 90       	pop	r0
    1ab0:	0f 90       	pop	r0
    1ab2:	cf 91       	pop	r28
    1ab4:	df 91       	pop	r29
    1ab6:	1f 91       	pop	r17
    1ab8:	0f 91       	pop	r16
    1aba:	ff 90       	pop	r15
    1abc:	ef 90       	pop	r14
    1abe:	08 95       	ret

00001ac0 <LCD_WriteSpace>:
		_flags &= ~REVERSED;
}


void LCD_WriteSpace(uint8_t len)
{
    1ac0:	0f 93       	push	r16
    1ac2:	1f 93       	push	r17
    1ac4:	08 2f       	mov	r16, r24
	for (uint8_t i = 0; i < len; i++)
    1ac6:	10 e0       	ldi	r17, 0x00	; 0
    1ac8:	04 c0       	rjmp	.+8      	; 0x1ad2 <LCD_WriteSpace+0x12>
		lcdWriteChar(32);
    1aca:	80 e2       	ldi	r24, 0x20	; 32
    1acc:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <lcdWriteChar>
}


void LCD_WriteSpace(uint8_t len)
{
	for (uint8_t i = 0; i < len; i++)
    1ad0:	1f 5f       	subi	r17, 0xFF	; 255
    1ad2:	10 17       	cp	r17, r16
    1ad4:	d0 f3       	brcs	.-12     	; 0x1aca <LCD_WriteSpace+0xa>
		lcdWriteChar(32);
}
    1ad6:	1f 91       	pop	r17
    1ad8:	0f 91       	pop	r16
    1ada:	08 95       	ret

00001adc <LCD_WritePadded>:

void LCD_WritePadded(char *s, uint8_t len)
{
    1adc:	0f 93       	push	r16
    1ade:	1f 93       	push	r17
    1ae0:	df 93       	push	r29
    1ae2:	cf 93       	push	r28
    1ae4:	0f 92       	push	r0
    1ae6:	cd b7       	in	r28, 0x3d	; 61
    1ae8:	de b7       	in	r29, 0x3e	; 62
    1aea:	8c 01       	movw	r16, r24
	LCD_WriteString(s);
    1aec:	69 83       	std	Y+1, r22	; 0x01
    1aee:	0e 94 08 0d 	call	0x1a10	; 0x1a10 <LCD_WriteString>
	LCD_WriteSpace(len - strlen(s));
    1af2:	f8 01       	movw	r30, r16
    1af4:	01 90       	ld	r0, Z+
    1af6:	00 20       	and	r0, r0
    1af8:	e9 f7       	brne	.-6      	; 0x1af4 <LCD_WritePadded+0x18>
    1afa:	31 97       	sbiw	r30, 0x01	; 1
    1afc:	e0 1b       	sub	r30, r16
    1afe:	f1 0b       	sbc	r31, r17
    1b00:	69 81       	ldd	r22, Y+1	; 0x01
    1b02:	86 2f       	mov	r24, r22
    1b04:	8e 1b       	sub	r24, r30
    1b06:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <LCD_WriteSpace>
}
    1b0a:	0f 90       	pop	r0
    1b0c:	cf 91       	pop	r28
    1b0e:	df 91       	pop	r29
    1b10:	1f 91       	pop	r17
    1b12:	0f 91       	pop	r16
    1b14:	08 95       	ret

00001b16 <LCD_WritePadded_P>:


void LCD_WritePadded_P(const char *s, uint8_t len)
{
    1b16:	0f 93       	push	r16
    1b18:	1f 93       	push	r17
    1b1a:	df 93       	push	r29
    1b1c:	cf 93       	push	r28
    1b1e:	0f 92       	push	r0
    1b20:	cd b7       	in	r28, 0x3d	; 61
    1b22:	de b7       	in	r29, 0x3e	; 62
    1b24:	8c 01       	movw	r16, r24
	LCD_WriteString_P(s);
    1b26:	69 83       	std	Y+1, r22	; 0x01
    1b28:	0e 94 1c 0d 	call	0x1a38	; 0x1a38 <LCD_WriteString_P>
	LCD_WriteSpace(len - strlen_P(s));
    1b2c:	c8 01       	movw	r24, r16
    1b2e:	0e 94 91 3a 	call	0x7522	; 0x7522 <strlen_P>
    1b32:	69 81       	ldd	r22, Y+1	; 0x01
    1b34:	68 1b       	sub	r22, r24
    1b36:	86 2f       	mov	r24, r22
    1b38:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <LCD_WriteSpace>
}
    1b3c:	0f 90       	pop	r0
    1b3e:	cf 91       	pop	r28
    1b40:	df 91       	pop	r29
    1b42:	1f 91       	pop	r17
    1b44:	0f 91       	pop	r16
    1b46:	08 95       	ret

00001b48 <LCD_WriteString_Pex>:
		lcdWriteChar(c);
}


void LCD_WriteString_Pex(uint8_t x, uint8_t y, PGM_P str, uint8_t len, BOOL LCDReverse)
{
    1b48:	ef 92       	push	r14
    1b4a:	ff 92       	push	r15
    1b4c:	0f 93       	push	r16
    1b4e:	1f 93       	push	r17
    1b50:	df 93       	push	r29
    1b52:	cf 93       	push	r28
    1b54:	00 d0       	rcall	.+0      	; 0x1b56 <LCD_WriteString_Pex+0xe>
    1b56:	cd b7       	in	r28, 0x3d	; 61
    1b58:	de b7       	in	r29, 0x3e	; 62
    1b5a:	18 2f       	mov	r17, r24
    1b5c:	7a 01       	movw	r14, r20
    1b5e:	80 2f       	mov	r24, r16
	lcdReverse(LCDReverse);
    1b60:	2a 83       	std	Y+2, r18	; 0x02
    1b62:	69 83       	std	Y+1, r22	; 0x01
    1b64:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <lcdReverse>
	LCD_SetPos(x, y);
    1b68:	81 2f       	mov	r24, r17
    1b6a:	69 81       	ldd	r22, Y+1	; 0x01
    1b6c:	0e 94 1f 0c 	call	0x183e	; 0x183e <LCD_SetPos>
	LCD_WritePadded_P(str, len);
    1b70:	c7 01       	movw	r24, r14
    1b72:	2a 81       	ldd	r18, Y+2	; 0x02
    1b74:	62 2f       	mov	r22, r18
    1b76:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <LCD_WritePadded_P>
	lcdReverse(0);
    1b7a:	80 e0       	ldi	r24, 0x00	; 0
    1b7c:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <lcdReverse>
}
    1b80:	0f 90       	pop	r0
    1b82:	0f 90       	pop	r0
    1b84:	cf 91       	pop	r28
    1b86:	df 91       	pop	r29
    1b88:	1f 91       	pop	r17
    1b8a:	0f 91       	pop	r16
    1b8c:	ff 90       	pop	r15
    1b8e:	ef 90       	pop	r14
    1b90:	08 95       	ret

00001b92 <LCD_WriteValue_double_ex>:
	LCD_WriteString_P(s);
	LCD_WriteSpace(len - strlen_P(s));
}

void LCD_WriteValue_double_ex(uint8_t x, uint8_t y, double value, int8_t len, BOOL LCDReverse)
{
    1b92:	bf 92       	push	r11
    1b94:	cf 92       	push	r12
    1b96:	df 92       	push	r13
    1b98:	ef 92       	push	r14
    1b9a:	ff 92       	push	r15
    1b9c:	0f 93       	push	r16
    1b9e:	1f 93       	push	r17
    1ba0:	df 93       	push	r29
    1ba2:	cf 93       	push	r28
    1ba4:	cd b7       	in	r28, 0x3d	; 61
    1ba6:	de b7       	in	r29, 0x3e	; 62
    1ba8:	62 97       	sbiw	r28, 0x12	; 18
    1baa:	0f b6       	in	r0, 0x3f	; 63
    1bac:	f8 94       	cli
    1bae:	de bf       	out	0x3e, r29	; 62
    1bb0:	0f be       	out	0x3f, r0	; 63
    1bb2:	cd bf       	out	0x3d, r28	; 61
    1bb4:	f8 2e       	mov	r15, r24
    1bb6:	b6 2e       	mov	r11, r22
    1bb8:	ca 01       	movw	r24, r20
    1bba:	b9 01       	movw	r22, r18
    1bbc:	30 2f       	mov	r19, r16
	char s[17];
	dtostrf(value, len-2,2, s);
    1bbe:	32 50       	subi	r19, 0x02	; 2
    1bc0:	43 2f       	mov	r20, r19
    1bc2:	22 e0       	ldi	r18, 0x02	; 2
    1bc4:	6e 01       	movw	r12, r28
    1bc6:	08 94       	sec
    1bc8:	c1 1c       	adc	r12, r1
    1bca:	d1 1c       	adc	r13, r1
    1bcc:	86 01       	movw	r16, r12
    1bce:	3a 8b       	std	Y+18, r19	; 0x12
    1bd0:	0e 94 5f 3a 	call	0x74be	; 0x74be <dtostrf>
	//itoa(value, s, 10);
	lcdReverse(LCDReverse);
    1bd4:	8e 2d       	mov	r24, r14
    1bd6:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <lcdReverse>
	LCD_SetPos(x, y);
    1bda:	8f 2d       	mov	r24, r15
    1bdc:	6b 2d       	mov	r22, r11
    1bde:	0e 94 1f 0c 	call	0x183e	; 0x183e <LCD_SetPos>
	LCD_WritePadded(s, len-2);
    1be2:	c6 01       	movw	r24, r12
    1be4:	3a 89       	ldd	r19, Y+18	; 0x12
    1be6:	63 2f       	mov	r22, r19
    1be8:	0e 94 6e 0d 	call	0x1adc	; 0x1adc <LCD_WritePadded>
	lcdReverse(0);
    1bec:	80 e0       	ldi	r24, 0x00	; 0
    1bee:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <lcdReverse>

}
    1bf2:	62 96       	adiw	r28, 0x12	; 18
    1bf4:	0f b6       	in	r0, 0x3f	; 63
    1bf6:	f8 94       	cli
    1bf8:	de bf       	out	0x3e, r29	; 62
    1bfa:	0f be       	out	0x3f, r0	; 63
    1bfc:	cd bf       	out	0x3d, r28	; 61
    1bfe:	cf 91       	pop	r28
    1c00:	df 91       	pop	r29
    1c02:	1f 91       	pop	r17
    1c04:	0f 91       	pop	r16
    1c06:	ff 90       	pop	r15
    1c08:	ef 90       	pop	r14
    1c0a:	df 90       	pop	r13
    1c0c:	cf 90       	pop	r12
    1c0e:	bf 90       	pop	r11
    1c10:	08 95       	ret

00001c12 <LCD_WriteValue_double>:
void LCD_WriteValue_double(uint8_t x, uint8_t y, double value,  BOOL LCDReverse)
{
    1c12:	ef 92       	push	r14
    1c14:	0f 93       	push	r16
    1c16:	e0 2e       	mov	r14, r16
	LCD_WriteValue_double_ex(x,y,value,5,LCDReverse);
    1c18:	05 e0       	ldi	r16, 0x05	; 5
    1c1a:	0e 94 c9 0d 	call	0x1b92	; 0x1b92 <LCD_WriteValue_double_ex>
}
    1c1e:	0f 91       	pop	r16
    1c20:	ef 90       	pop	r14
    1c22:	08 95       	ret

00001c24 <LCD_WriteValue>:

void LCD_WriteValue(uint8_t x, uint8_t y, int16_t value, uint8_t len, BOOL LCDReverse)
{
    1c24:	df 92       	push	r13
    1c26:	ef 92       	push	r14
    1c28:	ff 92       	push	r15
    1c2a:	0f 93       	push	r16
    1c2c:	1f 93       	push	r17
    1c2e:	df 93       	push	r29
    1c30:	cf 93       	push	r28
    1c32:	cd b7       	in	r28, 0x3d	; 61
    1c34:	de b7       	in	r29, 0x3e	; 62
    1c36:	28 97       	sbiw	r28, 0x08	; 8
    1c38:	0f b6       	in	r0, 0x3f	; 63
    1c3a:	f8 94       	cli
    1c3c:	de bf       	out	0x3e, r29	; 62
    1c3e:	0f be       	out	0x3f, r0	; 63
    1c40:	cd bf       	out	0x3d, r28	; 61
    1c42:	d8 2e       	mov	r13, r24
    1c44:	16 2f       	mov	r17, r22
	char s[7];
	itoa(value, s, 10);
    1c46:	ca 01       	movw	r24, r20
    1c48:	7e 01       	movw	r14, r28
    1c4a:	08 94       	sec
    1c4c:	e1 1c       	adc	r14, r1
    1c4e:	f1 1c       	adc	r15, r1
    1c50:	b7 01       	movw	r22, r14
    1c52:	4a e0       	ldi	r20, 0x0A	; 10
    1c54:	50 e0       	ldi	r21, 0x00	; 0
    1c56:	28 87       	std	Y+8, r18	; 0x08
    1c58:	0e 94 ae 3a 	call	0x755c	; 0x755c <itoa>
	lcdReverse(LCDReverse);
    1c5c:	80 2f       	mov	r24, r16
    1c5e:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <lcdReverse>
	LCD_SetPos(x, y);
    1c62:	8d 2d       	mov	r24, r13
    1c64:	61 2f       	mov	r22, r17
    1c66:	0e 94 1f 0c 	call	0x183e	; 0x183e <LCD_SetPos>
	LCD_WritePadded(s, len);
    1c6a:	c7 01       	movw	r24, r14
    1c6c:	28 85       	ldd	r18, Y+8	; 0x08
    1c6e:	62 2f       	mov	r22, r18
    1c70:	0e 94 6e 0d 	call	0x1adc	; 0x1adc <LCD_WritePadded>
	lcdReverse(0);
    1c74:	80 e0       	ldi	r24, 0x00	; 0
    1c76:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <lcdReverse>
}
    1c7a:	28 96       	adiw	r28, 0x08	; 8
    1c7c:	0f b6       	in	r0, 0x3f	; 63
    1c7e:	f8 94       	cli
    1c80:	de bf       	out	0x3e, r29	; 62
    1c82:	0f be       	out	0x3f, r0	; 63
    1c84:	cd bf       	out	0x3d, r28	; 61
    1c86:	cf 91       	pop	r28
    1c88:	df 91       	pop	r29
    1c8a:	1f 91       	pop	r17
    1c8c:	0f 91       	pop	r16
    1c8e:	ff 90       	pop	r15
    1c90:	ef 90       	pop	r14
    1c92:	df 90       	pop	r13
    1c94:	08 95       	ret

00001c96 <LCD_Enable>:
}

void LCD_Enable()
{
	// reset timer0 to avoid re-entrant call of ISR b/c it is non blocking
	TCNT0 = 0;
    1c96:	16 bc       	out	0x26, r1	; 38
	TIFR0 = _BV(TOV0);
    1c98:	81 e0       	ldi	r24, 0x01	; 1
    1c9a:	85 bb       	out	0x15, r24	; 21
	TIMSK0 |= _BV(TOIE0);	// enable interrupt on overflow
    1c9c:	ee e6       	ldi	r30, 0x6E	; 110
    1c9e:	f0 e0       	ldi	r31, 0x00	; 0
    1ca0:	80 81       	ld	r24, Z
    1ca2:	81 60       	ori	r24, 0x01	; 1
    1ca4:	80 83       	st	Z, r24
}
    1ca6:	08 95       	ret

00001ca8 <LCD_Disable>:

void LCD_Disable()
{
	TIMSK0 &= ~_BV(TOIE0);	// disable overflow interrupt
    1ca8:	ee e6       	ldi	r30, 0x6E	; 110
    1caa:	f0 e0       	ldi	r31, 0x00	; 0
    1cac:	80 81       	ld	r24, Z
    1cae:	8e 7f       	andi	r24, 0xFE	; 254
    1cb0:	80 83       	st	Z, r24
}
    1cb2:	08 95       	ret

00001cb4 <lcdSetContrast>:
	LCD_WritePadded(s, len);
	lcdReverse(0);
}

void lcdSetContrast(uint8_t contrast)
{
    1cb4:	0f 93       	push	r16
    1cb6:	1f 93       	push	r17
    1cb8:	cf 93       	push	r28
    1cba:	df 93       	push	r29
    1cbc:	08 2f       	mov	r16, r24
	uint8_t t = TIMSK0;
    1cbe:	ce e6       	ldi	r28, 0x6E	; 110
    1cc0:	d0 e0       	ldi	r29, 0x00	; 0
    1cc2:	18 81       	ld	r17, Y
	LCD_Disable();
    1cc4:	0e 94 54 0e 	call	0x1ca8	; 0x1ca8 <LCD_Disable>
	sendData(0x81, LCD_COMMAND);
    1cc8:	81 e8       	ldi	r24, 0x81	; 129
    1cca:	60 e0       	ldi	r22, 0x00	; 0
    1ccc:	0e 94 09 0c 	call	0x1812	; 0x1812 <sendData>
	sendData(contrast & 0x3F, LCD_COMMAND); 
    1cd0:	80 2f       	mov	r24, r16
    1cd2:	8f 73       	andi	r24, 0x3F	; 63
    1cd4:	60 e0       	ldi	r22, 0x00	; 0
    1cd6:	0e 94 09 0c 	call	0x1812	; 0x1812 <sendData>
	TIMSK0 = t;
    1cda:	18 83       	st	Y, r17
}
    1cdc:	df 91       	pop	r29
    1cde:	cf 91       	pop	r28
    1ce0:	1f 91       	pop	r17
    1ce2:	0f 91       	pop	r16
    1ce4:	08 95       	ret

00001ce6 <LCD_SelectFont>:
{
	TIMSK0 &= ~_BV(TOIE0);	// disable overflow interrupt
}

void LCD_SelectFont(const fontdescriptor_t *font)
{
    1ce6:	bc 01       	movw	r22, r24
	if (font == NULL)
    1ce8:	00 97       	sbiw	r24, 0x00	; 0
    1cea:	11 f4       	brne	.+4      	; 0x1cf0 <LCD_SelectFont+0xa>
		font = &font6x8;
    1cec:	6b e7       	ldi	r22, 0x7B	; 123
    1cee:	77 e0       	ldi	r23, 0x07	; 7
	memcpy_P(&_font, font, sizeof(_font));
    1cf0:	84 e2       	ldi	r24, 0x24	; 36
    1cf2:	91 e0       	ldi	r25, 0x01	; 1
    1cf4:	44 e0       	ldi	r20, 0x04	; 4
    1cf6:	50 e0       	ldi	r21, 0x00	; 0
    1cf8:	0e 94 81 3a 	call	0x7502	; 0x7502 <memcpy_P>
}
    1cfc:	08 95       	ret

00001cfe <LCD_Init>:
	0xff // end of array
	*/
};

void LCD_Init()
{
    1cfe:	cf 93       	push	r28
    1d00:	df 93       	push	r29
	// pins
	LCD_CS_DIR = OUTPUT;
    1d02:	55 9a       	sbi	0x0a, 5	; 10
	LCD_RST_DIR = OUTPUT;
    1d04:	56 9a       	sbi	0x0a, 6	; 10
	LCD_A0_DIR = OUTPUT;
    1d06:	57 9a       	sbi	0x0a, 7	; 10
	LCD_SCL_DIR = OUTPUT;
    1d08:	54 9a       	sbi	0x0a, 4	; 10
	LCD_SDA_DIR = OUTPUT;
    1d0a:	51 9a       	sbi	0x0a, 1	; 10

	// init display
	LCD_RST = 0;
    1d0c:	5e 98       	cbi	0x0b, 6	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1d0e:	89 ef       	ldi	r24, 0xF9	; 249
    1d10:	90 e0       	ldi	r25, 0x00	; 0
    1d12:	01 97       	sbiw	r24, 0x01	; 1
    1d14:	f1 f7       	brne	.-4      	; 0x1d12 <LCD_Init+0x14>
    1d16:	00 c0       	rjmp	.+0      	; 0x1d18 <LCD_Init+0x1a>
    1d18:	00 00       	nop
	_delay_ms(1);	// version 0.9.9
	LCD_RST = 1;
    1d1a:	5e 9a       	sbi	0x0b, 6	; 11
    1d1c:	89 ef       	ldi	r24, 0xF9	; 249
    1d1e:	90 e0       	ldi	r25, 0x00	; 0
    1d20:	01 97       	sbiw	r24, 0x01	; 1
    1d22:	f1 f7       	brne	.-4      	; 0x1d20 <LCD_Init+0x22>
    1d24:	00 c0       	rjmp	.+0      	; 0x1d26 <LCD_Init+0x28>
    1d26:	00 00       	nop
	_delay_ms(1); // version 0.9.9
	
	const unsigned char* ptr = _initSeq;
    1d28:	ca e9       	ldi	r28, 0x9A	; 154
    1d2a:	d0 e0       	ldi	r29, 0x00	; 0
	uint8_t c;
	while ((c = pgm_read_byte(ptr++)))
    1d2c:	03 c0       	rjmp	.+6      	; 0x1d34 <LCD_Init+0x36>
	{
		sendData(c, LCD_COMMAND);
    1d2e:	60 e0       	ldi	r22, 0x00	; 0
    1d30:	0e 94 09 0c 	call	0x1812	; 0x1812 <sendData>
    1d34:	fe 01       	movw	r30, r28
	LCD_RST = 1;
	_delay_ms(1); // version 0.9.9
	
	const unsigned char* ptr = _initSeq;
	uint8_t c;
	while ((c = pgm_read_byte(ptr++)))
    1d36:	21 96       	adiw	r28, 0x01	; 1
    1d38:	84 91       	lpm	r24, Z+
    1d3a:	88 23       	and	r24, r24
    1d3c:	c1 f7       	brne	.-16     	; 0x1d2e <LCD_Init+0x30>
	{
		sendData(c, LCD_COMMAND);
	}	
	LCD_SelectFont(NULL);		// select default font
    1d3e:	80 e0       	ldi	r24, 0x00	; 0
    1d40:	90 e0       	ldi	r25, 0x00	; 0
    1d42:	0e 94 73 0e 	call	0x1ce6	; 0x1ce6 <LCD_SelectFont>
	
	// use timer0 with clk/8 and overflow
	// at 256 as interrupt based output of data bytes
	// ie every 1024us one byte is send to display. whole screen takes about 105ms
	TCCR0B = _BV(CS01);		// clk/8
    1d46:	82 e0       	ldi	r24, 0x02	; 2
    1d48:	85 bd       	out	0x25, r24	; 37
	LCD_Enable();
    1d4a:	0e 94 4b 0e 	call	0x1c96	; 0x1c96 <LCD_Enable>
}
    1d4e:	df 91       	pop	r29
    1d50:	cf 91       	pop	r28
    1d52:	08 95       	ret

00001d54 <LED_FlashOrangeLED>:
#include "../Include/Misc.h"
#include "../Include/IO_config.h"


void LED_FlashOrangeLED (uint16_t msDuration, uint8_t Times)
{
    1d54:	cf 92       	push	r12
    1d56:	df 92       	push	r13
    1d58:	ef 92       	push	r14
    1d5a:	ff 92       	push	r15
    1d5c:	0f 93       	push	r16
    1d5e:	1f 93       	push	r17
    1d60:	df 93       	push	r29
    1d62:	cf 93       	push	r28
    1d64:	0f 92       	push	r0
    1d66:	cd b7       	in	r28, 0x3d	; 61
    1d68:	de b7       	in	r29, 0x3e	; 62
    1d6a:	6c 01       	movw	r12, r24
	bool CurrentLED_Status = LED_Orange;
    1d6c:	25 b1       	in	r18, 0x05	; 5
    1d6e:	26 95       	lsr	r18
    1d70:	26 95       	lsr	r18
    1d72:	26 95       	lsr	r18
    1d74:	21 70       	andi	r18, 0x01	; 1
	
	for (int i=0; i< Times; ++i)
    1d76:	00 e0       	ldi	r16, 0x00	; 0
    1d78:	10 e0       	ldi	r17, 0x00	; 0
    1d7a:	e6 2e       	mov	r14, r22
    1d7c:	ff 24       	eor	r15, r15
    1d7e:	24 c0       	rjmp	.+72     	; 0x1dc8 <LED_FlashOrangeLED+0x74>
	{
		LED_Orange = ~LED_Orange;
    1d80:	85 b1       	in	r24, 0x05	; 5
    1d82:	86 95       	lsr	r24
    1d84:	86 95       	lsr	r24
    1d86:	86 95       	lsr	r24
    1d88:	80 95       	com	r24
    1d8a:	81 70       	andi	r24, 0x01	; 1
    1d8c:	88 0f       	add	r24, r24
    1d8e:	88 0f       	add	r24, r24
    1d90:	88 0f       	add	r24, r24
    1d92:	95 b1       	in	r25, 0x05	; 5
    1d94:	97 7f       	andi	r25, 0xF7	; 247
    1d96:	98 2b       	or	r25, r24
    1d98:	95 b9       	out	0x05, r25	; 5
		delay_ms(msDuration);
    1d9a:	c6 01       	movw	r24, r12
    1d9c:	29 83       	std	Y+1, r18	; 0x01
    1d9e:	0e 94 0c 0f 	call	0x1e18	; 0x1e18 <delay_ms>
		LED_Orange = ~LED_Orange;
    1da2:	85 b1       	in	r24, 0x05	; 5
    1da4:	86 95       	lsr	r24
    1da6:	86 95       	lsr	r24
    1da8:	86 95       	lsr	r24
    1daa:	80 95       	com	r24
    1dac:	81 70       	andi	r24, 0x01	; 1
    1dae:	88 0f       	add	r24, r24
    1db0:	88 0f       	add	r24, r24
    1db2:	88 0f       	add	r24, r24
    1db4:	95 b1       	in	r25, 0x05	; 5
    1db6:	97 7f       	andi	r25, 0xF7	; 247
    1db8:	98 2b       	or	r25, r24
    1dba:	95 b9       	out	0x05, r25	; 5
		delay_ms(msDuration);		
    1dbc:	c6 01       	movw	r24, r12
    1dbe:	0e 94 0c 0f 	call	0x1e18	; 0x1e18 <delay_ms>

void LED_FlashOrangeLED (uint16_t msDuration, uint8_t Times)
{
	bool CurrentLED_Status = LED_Orange;
	
	for (int i=0; i< Times; ++i)
    1dc2:	0f 5f       	subi	r16, 0xFF	; 255
    1dc4:	1f 4f       	sbci	r17, 0xFF	; 255
    1dc6:	29 81       	ldd	r18, Y+1	; 0x01
    1dc8:	0e 15       	cp	r16, r14
    1dca:	1f 05       	cpc	r17, r15
    1dcc:	cc f2       	brlt	.-78     	; 0x1d80 <LED_FlashOrangeLED+0x2c>
		delay_ms(msDuration);
		LED_Orange = ~LED_Orange;
		delay_ms(msDuration);		
	}
	
	LED_Orange = CurrentLED_Status;
    1dce:	21 70       	andi	r18, 0x01	; 1
    1dd0:	22 0f       	add	r18, r18
    1dd2:	22 0f       	add	r18, r18
    1dd4:	22 0f       	add	r18, r18
    1dd6:	85 b1       	in	r24, 0x05	; 5
    1dd8:	87 7f       	andi	r24, 0xF7	; 247
    1dda:	82 2b       	or	r24, r18
    1ddc:	85 b9       	out	0x05, r24	; 5
	
    1dde:	0f 90       	pop	r0
    1de0:	cf 91       	pop	r28
    1de2:	df 91       	pop	r29
    1de4:	1f 91       	pop	r17
    1de6:	0f 91       	pop	r16
    1de8:	ff 90       	pop	r15
    1dea:	ef 90       	pop	r14
    1dec:	df 90       	pop	r13
    1dee:	cf 90       	pop	r12
    1df0:	08 95       	ret

00001df2 <delay_us>:



void delay_us(uint16_t time)            /* time delay for us */
{ 
 while(time--)
    1df2:	0f c0       	rjmp	.+30     	; 0x1e12 <delay_us+0x20>
	...
	asm volatile ("NOP"); asm volatile ("NOP"); 
	asm volatile ("NOP"); 
	asm volatile ("NOP"); asm volatile ("NOP"); 
	asm volatile ("NOP"); asm volatile ("NOP"); 
	asm volatile ("NOP"); asm volatile ("NOP"); 
	asm volatile ("NOP"); 
    1e10:	01 97       	sbiw	r24, 0x01	; 1



void delay_us(uint16_t time)            /* time delay for us */
{ 
 while(time--)
    1e12:	00 97       	sbiw	r24, 0x00	; 0
    1e14:	79 f7       	brne	.-34     	; 0x1df4 <delay_us+0x2>
	asm volatile ("NOP"); asm volatile ("NOP"); 
	asm volatile ("NOP"); asm volatile ("NOP"); 
	asm volatile ("NOP"); asm volatile ("NOP"); 
	asm volatile ("NOP"); 
 }
}
    1e16:	08 95       	ret

00001e18 <delay_ms>:

void delay_ms(uint16_t time)
{
    1e18:	1f 93       	push	r17
    1e1a:	cf 93       	push	r28
    1e1c:	df 93       	push	r29
    1e1e:	ec 01       	movw	r28, r24
	uint8_t i;
	while(time--)
    1e20:	08 c0       	rjmp	.+16     	; 0x1e32 <delay_ms+0x1a>
    1e22:	1a e0       	ldi	r17, 0x0A	; 10
	{
		for(i=0;i<10;i++) delay_us(100);
    1e24:	84 e6       	ldi	r24, 0x64	; 100
    1e26:	90 e0       	ldi	r25, 0x00	; 0
    1e28:	0e 94 f9 0e 	call	0x1df2	; 0x1df2 <delay_us>
    1e2c:	11 50       	subi	r17, 0x01	; 1
    1e2e:	d1 f7       	brne	.-12     	; 0x1e24 <delay_ms+0xc>
    1e30:	21 97       	sbiw	r28, 0x01	; 1
}

void delay_ms(uint16_t time)
{
	uint8_t i;
	while(time--)
    1e32:	20 97       	sbiw	r28, 0x00	; 0
    1e34:	b1 f7       	brne	.-20     	; 0x1e22 <delay_ms+0xa>
	{
		for(i=0;i<10;i++) delay_us(100);
	}
}
    1e36:	df 91       	pop	r29
    1e38:	cf 91       	pop	r28
    1e3a:	1f 91       	pop	r17
    1e3c:	08 95       	ret

00001e3e <Ultrasonic_Init>:
#include "..\Include\Ultrasonic.h"


void Ultrasonic_Init ()
{
	RX_SONAR_TRIGGER_DIR = OUTPUT;
    1e3e:	50 9a       	sbi	0x0a, 0	; 10
	RX_SONAR_TRIGGER=HIGH;   // Active LOW
    1e40:	48 9a       	sbi	0x09, 0	; 9
	RX_SONAR_DIR = INPUT;
    1e42:	22 98       	cbi	0x04, 2	; 4
	
	// enable interrupts
	EICRA  = _BV(ISC20);	// any edge on INT2
    1e44:	80 e1       	ldi	r24, 0x10	; 16
    1e46:	80 93 69 00 	sts	0x0069, r24
	EIMSK  = _BV(INT2);	// enable interrupt for INT0, INT1 and INT2
    1e4a:	84 e0       	ldi	r24, 0x04	; 4
    1e4c:	8d bb       	out	0x1d, r24	; 29
	EIFR   = _BV(INTF2);	// clear interrupts
    1e4e:	8c bb       	out	0x1c, r24	; 28
		
	
}
    1e50:	08 95       	ret

00001e52 <Disarm>:
#include "Include/Beeper.h"


void Disarm (void)
{
	IsArmed = false;
    1e52:	10 92 c8 07 	sts	0x07C8, r1
	//LED_FlashOrangeLED (LED_SHORT_TOGGLE,4);
	LED_Orange = OFF;
    1e56:	2b 98       	cbi	0x05, 3	; 5
	
	TCNT1_X_snapshot1 =0; // reset timer
    1e58:	10 92 e7 05 	sts	0x05E7, r1
    1e5c:	10 92 e6 05 	sts	0x05E6, r1
	Beeper_Beep(BEEP_SHORT,2);				
    1e60:	86 e4       	ldi	r24, 0x46	; 70
    1e62:	90 e0       	ldi	r25, 0x00	; 0
    1e64:	62 e0       	ldi	r22, 0x02	; 2
    1e66:	0e 94 a8 0b 	call	0x1750	; 0x1750 <Beeper_Beep>
	Menu_LoadPage (PAGE_HOME);
    1e6a:	80 e0       	ldi	r24, 0x00	; 0
    1e6c:	90 e0       	ldi	r25, 0x00	; 0
    1e6e:	0e 94 18 2e 	call	0x5c30	; 0x5c30 <Menu_LoadPage>
}
    1e72:	08 95       	ret

00001e74 <Arm>:


void Arm (void)
{
	if ((Config.FrameType == FRAMETYPE_TRICOPTER) && (Config.BoardOrientationMode==QuadFlyingMode_X))
    1e74:	80 91 f0 06 	lds	r24, 0x06F0
    1e78:	82 30       	cpi	r24, 0x02	; 2
    1e7a:	39 f4       	brne	.+14     	; 0x1e8a <Arm+0x16>
    1e7c:	80 91 f1 06 	lds	r24, 0x06F1
    1e80:	81 30       	cpi	r24, 0x01	; 1
    1e82:	19 f4       	brne	.+6      	; 0x1e8a <Arm+0x16>
	{ // NOT VALID CONFIGURATION
		Disarm();
    1e84:	0e 94 29 0f 	call	0x1e52	; 0x1e52 <Disarm>
		
		return;
    1e88:	08 95       	ret
	}
	
			
	IsArmed = true;
    1e8a:	81 e0       	ldi	r24, 0x01	; 1
    1e8c:	80 93 c8 07 	sts	0x07C8, r24
	LED_FlashOrangeLED (LED_SHORT_TOGGLE,4);
    1e90:	8e e1       	ldi	r24, 0x1E	; 30
    1e92:	90 e0       	ldi	r25, 0x00	; 0
    1e94:	64 e0       	ldi	r22, 0x04	; 4
    1e96:	70 e0       	ldi	r23, 0x00	; 0
    1e98:	0e 94 aa 0e 	call	0x1d54	; 0x1d54 <LED_FlashOrangeLED>
	LED_Orange = ON;
    1e9c:	2b 9a       	sbi	0x05, 3	; 5
	Beeper_Beep(BEEP_LONG,1);				
    1e9e:	8c eb       	ldi	r24, 0xBC	; 188
    1ea0:	92 e0       	ldi	r25, 0x02	; 2
    1ea2:	61 e0       	ldi	r22, 0x01	; 1
    1ea4:	0e 94 a8 0b 	call	0x1750	; 0x1750 <Beeper_Beep>
	
	TCNT1_X_snapshot1 =0; // reset timer
    1ea8:	10 92 e7 05 	sts	0x05E7, r1
    1eac:	10 92 e6 05 	sts	0x05E6, r1
	TCNT_X_snapshotAutoDisarm=0;				
    1eb0:	10 92 1c 06 	sts	0x061C, r1
    1eb4:	10 92 1b 06 	sts	0x061B, r1
	Menu_LoadPage (PAGE_HOME_ARMED);
    1eb8:	82 e0       	ldi	r24, 0x02	; 2
    1eba:	90 e0       	ldi	r25, 0x00	; 0
    1ebc:	0e 94 18 2e 	call	0x5c30	; 0x5c30 <Menu_LoadPage>
	
	PID_GyroTerms[PITCH_INDEX].I=0;
    1ec0:	80 e0       	ldi	r24, 0x00	; 0
    1ec2:	90 e0       	ldi	r25, 0x00	; 0
    1ec4:	dc 01       	movw	r26, r24
    1ec6:	80 93 7a 06 	sts	0x067A, r24
    1eca:	90 93 7b 06 	sts	0x067B, r25
    1ece:	a0 93 7c 06 	sts	0x067C, r26
    1ed2:	b0 93 7d 06 	sts	0x067D, r27
	PID_GyroTerms[ROLL_INDEX].I=0;
    1ed6:	80 93 92 06 	sts	0x0692, r24
    1eda:	90 93 93 06 	sts	0x0693, r25
    1ede:	a0 93 94 06 	sts	0x0694, r26
    1ee2:	b0 93 95 06 	sts	0x0695, r27
	PID_GyroTerms[YAW_INDEX].I=0;
    1ee6:	80 93 aa 06 	sts	0x06AA, r24
    1eea:	90 93 ab 06 	sts	0x06AB, r25
    1eee:	a0 93 ac 06 	sts	0x06AC, r26
    1ef2:	b0 93 ad 06 	sts	0x06AD, r27
	PID_AccTerms [PITCH_INDEX].I=0;
    1ef6:	80 93 52 05 	sts	0x0552, r24
    1efa:	90 93 53 05 	sts	0x0553, r25
    1efe:	a0 93 54 05 	sts	0x0554, r26
    1f02:	b0 93 55 05 	sts	0x0555, r27
	PID_AccTerms [ROLL_INDEX].I=0;
    1f06:	80 93 6a 05 	sts	0x056A, r24
    1f0a:	90 93 6b 05 	sts	0x056B, r25
    1f0e:	a0 93 6c 05 	sts	0x056C, r26
    1f12:	b0 93 6d 05 	sts	0x056D, r27
	PID_AccTerms [Z_INDEX].I=0;
    1f16:	80 93 82 05 	sts	0x0582, r24
    1f1a:	90 93 83 05 	sts	0x0583, r25
    1f1e:	a0 93 84 05 	sts	0x0584, r26
    1f22:	b0 93 85 05 	sts	0x0585, r27
    1f26:	08 95       	ret

00001f28 <Set_EEPROM_Default_Config>:
	Save_Config_to_EEPROM();
}

void Set_EEPROM_Default_Config(void)
{
	memcpy_P ( &Config, &defaultConfig, sizeof(config_t));
    1f28:	87 ee       	ldi	r24, 0xE7	; 231
    1f2a:	96 e0       	ldi	r25, 0x06	; 6
    1f2c:	6e ea       	ldi	r22, 0xAE	; 174
    1f2e:	70 e0       	ldi	r23, 0x00	; 0
    1f30:	49 ec       	ldi	r20, 0xC9	; 201
    1f32:	50 e0       	ldi	r21, 0x00	; 0
    1f34:	0e 94 81 3a 	call	0x7502	; 0x7502 <memcpy_P>
}
    1f38:	08 95       	ret

00001f3a <eeprom_write_byte_changed>:
	}
}


void eeprom_write_byte_changed( uint8_t * addr, uint8_t value )
{ 
    1f3a:	0f 93       	push	r16
    1f3c:	1f 93       	push	r17
    1f3e:	df 93       	push	r29
    1f40:	cf 93       	push	r28
    1f42:	0f 92       	push	r0
    1f44:	cd b7       	in	r28, 0x3d	; 61
    1f46:	de b7       	in	r29, 0x3e	; 62
    1f48:	8c 01       	movw	r16, r24
	if(eeprom_read_byte(addr) != value)
    1f4a:	69 83       	std	Y+1, r22	; 0x01
    1f4c:	0e 94 f5 3a 	call	0x75ea	; 0x75ea <__eerd_byte_m324pa>
    1f50:	69 81       	ldd	r22, Y+1	; 0x01
    1f52:	86 17       	cp	r24, r22
    1f54:	19 f0       	breq	.+6      	; 0x1f5c <eeprom_write_byte_changed+0x22>
	{
		eeprom_write_byte( addr, value );
    1f56:	c8 01       	movw	r24, r16
    1f58:	0e 94 fd 3a 	call	0x75fa	; 0x75fa <__eewr_byte_m324pa>
	}
}
    1f5c:	0f 90       	pop	r0
    1f5e:	cf 91       	pop	r28
    1f60:	df 91       	pop	r29
    1f62:	1f 91       	pop	r17
    1f64:	0f 91       	pop	r16
    1f66:	08 95       	ret

00001f68 <eeprom_write_block_changes>:
	eeprom_write_block_changes( (const void*) &Config, (void*) EEPROM_DATA_START_POS, sizeof(config_t));	//current_config CONFIG_STRUCT
	
}

void eeprom_write_block_changes( const uint8_t * src, void * dest, size_t size )
{ 
    1f68:	cf 92       	push	r12
    1f6a:	df 92       	push	r13
    1f6c:	ef 92       	push	r14
    1f6e:	ff 92       	push	r15
    1f70:	0f 93       	push	r16
    1f72:	1f 93       	push	r17
    1f74:	cf 93       	push	r28
    1f76:	df 93       	push	r29
    1f78:	ec 01       	movw	r28, r24
    1f7a:	7b 01       	movw	r14, r22
    1f7c:	6a 01       	movw	r12, r20
	size_t len;

	for(len=0;len<size;len++)
    1f7e:	00 e0       	ldi	r16, 0x00	; 0
    1f80:	10 e0       	ldi	r17, 0x00	; 0
    1f82:	08 c0       	rjmp	.+16     	; 0x1f94 <eeprom_write_block_changes+0x2c>
	{
		eeprom_write_byte_changed( dest,  *src );
    1f84:	c7 01       	movw	r24, r14
    1f86:	80 0f       	add	r24, r16
    1f88:	91 1f       	adc	r25, r17
    1f8a:	69 91       	ld	r22, Y+
    1f8c:	0e 94 9d 0f 	call	0x1f3a	; 0x1f3a <eeprom_write_byte_changed>

void eeprom_write_block_changes( const uint8_t * src, void * dest, size_t size )
{ 
	size_t len;

	for(len=0;len<size;len++)
    1f90:	0f 5f       	subi	r16, 0xFF	; 255
    1f92:	1f 4f       	sbci	r17, 0xFF	; 255
    1f94:	0c 15       	cp	r16, r12
    1f96:	1d 05       	cpc	r17, r13
    1f98:	a8 f3       	brcs	.-22     	; 0x1f84 <eeprom_write_block_changes+0x1c>
		eeprom_write_byte_changed( dest,  *src );

		src++;
		dest++;
	}
}
    1f9a:	df 91       	pop	r29
    1f9c:	cf 91       	pop	r28
    1f9e:	1f 91       	pop	r17
    1fa0:	0f 91       	pop	r16
    1fa2:	ff 90       	pop	r15
    1fa4:	ef 90       	pop	r14
    1fa6:	df 90       	pop	r13
    1fa8:	cf 90       	pop	r12
    1faa:	08 95       	ret

00001fac <Load_Config_from_EEPROM>:

void Load_Config_from_EEPROM(void)
{
	// write to eeProm
	
	eeprom_write_block_changes( (const void*) &Config, (void*) EEPROM_DATA_START_POS, sizeof(config_t));	//current_config CONFIG_STRUCT
    1fac:	87 ee       	ldi	r24, 0xE7	; 231
    1fae:	96 e0       	ldi	r25, 0x06	; 6
    1fb0:	60 e0       	ldi	r22, 0x00	; 0
    1fb2:	70 e0       	ldi	r23, 0x00	; 0
    1fb4:	49 ec       	ldi	r20, 0xC9	; 201
    1fb6:	50 e0       	ldi	r21, 0x00	; 0
    1fb8:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <eeprom_write_block_changes>
	
}
    1fbc:	08 95       	ret

00001fbe <Save_Config_to_EEPROM>:
}

void Save_Config_to_EEPROM(void)
{
	// write to eeProm
	cli();
    1fbe:	f8 94       	cli
	eeprom_write_block_changes( (const void*) &Config, (void*) EEPROM_DATA_START_POS, sizeof(config_t));	//current_config CONFIG_STRUCT
    1fc0:	87 ee       	ldi	r24, 0xE7	; 231
    1fc2:	96 e0       	ldi	r25, 0x06	; 6
    1fc4:	60 e0       	ldi	r22, 0x00	; 0
    1fc6:	70 e0       	ldi	r23, 0x00	; 0
    1fc8:	49 ec       	ldi	r20, 0xC9	; 201
    1fca:	50 e0       	ldi	r21, 0x00	; 0
    1fcc:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <eeprom_write_block_changes>
	sei();
    1fd0:	78 94       	sei
	
	Beeper_Beep(BEEP_LONG,1);	
    1fd2:	8c eb       	ldi	r24, 0xBC	; 188
    1fd4:	92 e0       	ldi	r25, 0x02	; 2
    1fd6:	61 e0       	ldi	r22, 0x01	; 1
    1fd8:	0e 94 a8 0b 	call	0x1750	; 0x1750 <Beeper_Beep>
}
    1fdc:	08 95       	ret

00001fde <Save_Default_Config_to_EEPROM>:

void Save_Default_Config_to_EEPROM (void)
{
	
	// copy default config to config.
	Set_EEPROM_Default_Config();
    1fde:	0e 94 94 0f 	call	0x1f28	; 0x1f28 <Set_EEPROM_Default_Config>
    1fe2:	ec e5       	ldi	r30, 0x5C	; 92
    1fe4:	f7 e0       	ldi	r31, 0x07	; 7

	// Init values.
	for (uint8_t i = 0; i < RXChannels; i++)
	{
		Config.RX_Mid[0][i] = PWM_MID;
    1fe6:	20 ef       	ldi	r18, 0xF0	; 240
    1fe8:	35 e0       	ldi	r19, 0x05	; 5
		Config.RX_Min[0][i] = PWM_LOW;
    1fea:	80 e6       	ldi	r24, 0x60	; 96
    1fec:	94 e0       	ldi	r25, 0x04	; 4
	Set_EEPROM_Default_Config();

	// Init values.
	for (uint8_t i = 0; i < RXChannels; i++)
	{
		Config.RX_Mid[0][i] = PWM_MID;
    1fee:	21 93       	st	Z+, r18
    1ff0:	31 93       	st	Z+, r19
		Config.RX_Min[0][i] = PWM_LOW;
    1ff2:	93 8b       	std	Z+19, r25	; 0x13
    1ff4:	82 8b       	std	Z+18, r24	; 0x12
		Config.RX_Mid[1][i] = PWM_MID;
    1ff6:	31 87       	std	Z+9, r19	; 0x09
    1ff8:	20 87       	std	Z+8, r18	; 0x08
		Config.RX_Min[1][i] = PWM_LOW;
    1ffa:	95 8f       	std	Z+29, r25	; 0x1d
    1ffc:	84 8f       	std	Z+28, r24	; 0x1c
	
	// copy default config to config.
	Set_EEPROM_Default_Config();

	// Init values.
	for (uint8_t i = 0; i < RXChannels; i++)
    1ffe:	47 e0       	ldi	r20, 0x07	; 7
    2000:	e6 36       	cpi	r30, 0x66	; 102
    2002:	f4 07       	cpc	r31, r20
    2004:	a1 f7       	brne	.-24     	; 0x1fee <Save_Default_Config_to_EEPROM+0x10>
		Config.RX_Min[1][i] = PWM_LOW;
	}
	
	
	// write to eeProm
	Save_Config_to_EEPROM();
    2006:	0e 94 df 0f 	call	0x1fbe	; 0x1fbe <Save_Config_to_EEPROM>
}
    200a:	08 95       	ret

0000200c <Initial_EEPROM_Config_Load>:


void Initial_EEPROM_Config_Load(void)
{
	
	eeprom_read_block(&Config, (void*) EEPROM_DATA_START_POS, sizeof(config_t)); 
    200c:	87 ee       	ldi	r24, 0xE7	; 231
    200e:	96 e0       	ldi	r25, 0x06	; 6
    2010:	60 e0       	ldi	r22, 0x00	; 0
    2012:	70 e0       	ldi	r23, 0x00	; 0
    2014:	49 ec       	ldi	r20, 0xC9	; 201
    2016:	50 e0       	ldi	r21, 0x00	; 0
    2018:	0e 94 e5 3a 	call	0x75ca	; 0x75ca <__eerd_block_m324pa>
	
	// load up last settings from EEPROM
	if(
    201c:	80 91 e7 06 	lds	r24, 0x06E7
    2020:	8e 3f       	cpi	r24, 0xFE	; 254
    2022:	41 f4       	brne	.+16     	; 0x2034 <Initial_EEPROM_Config_Load+0x28>
		(Config.signature != HEFNYCOPTER2_SIGNATURE)
		#ifdef REQUIRE_FACTORY_RESET
		||		
    2024:	80 91 e8 06 	lds	r24, 0x06E8
    2028:	90 91 e9 06 	lds	r25, 0x06E9
    202c:	21 e0       	ldi	r18, 0x01	; 1
    202e:	80 39       	cpi	r24, 0x90	; 144
    2030:	92 07       	cpc	r25, r18
    2032:	19 f0       	breq	.+6      	; 0x203a <Initial_EEPROM_Config_Load+0x2e>
		(Config.Version  != VERSION_16INT)
		#endif
	  )		
	{
		Save_Default_Config_to_EEPROM();
    2034:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <Save_Default_Config_to_EEPROM>
    2038:	08 95       	ret
		
	} else {
		// read eeprom
		eeprom_read_block(&Config, (void*) EEPROM_DATA_START_POS, sizeof(config_t)); 
    203a:	87 ee       	ldi	r24, 0xE7	; 231
    203c:	96 e0       	ldi	r25, 0x06	; 6
    203e:	60 e0       	ldi	r22, 0x00	; 0
    2040:	70 e0       	ldi	r23, 0x00	; 0
    2042:	49 ec       	ldi	r20, 0xC9	; 201
    2044:	50 e0       	ldi	r21, 0x00	; 0
    2046:	0e 94 e5 3a 	call	0x75ca	; 0x75ca <__eerd_block_m324pa>
    204a:	08 95       	ret

0000204c <__vector_15>:
*/

//volatile uint32_t x=0;

ISR(TIMER1_OVF_vect)
{
    204c:	1f 92       	push	r1
    204e:	0f 92       	push	r0
    2050:	0f b6       	in	r0, 0x3f	; 63
    2052:	0f 92       	push	r0
    2054:	11 24       	eor	r1, r1
    2056:	8f 93       	push	r24
    2058:	9f 93       	push	r25
	
	TCNT1_X++; // click every 0.0032768 sec [1 sec = 305.17578125 TCNT1_X] overflows every 214.7483648 sec = 3.579 min
    205a:	80 91 70 06 	lds	r24, 0x0670
    205e:	90 91 71 06 	lds	r25, 0x0671
    2062:	01 96       	adiw	r24, 0x01	; 1
    2064:	90 93 71 06 	sts	0x0671, r25
    2068:	80 93 70 06 	sts	0x0670, r24
	//TCNT1_X_GlobalTimer +=32;  // 0.0032768
}
    206c:	9f 91       	pop	r25
    206e:	8f 91       	pop	r24
    2070:	0f 90       	pop	r0
    2072:	0f be       	out	0x3f, r0	; 63
    2074:	0f 90       	pop	r0
    2076:	1f 90       	pop	r1
    2078:	18 95       	reti

0000207a <__vector_11>:


ISR(TIMER2_OVF_vect)
{
    207a:	1f 92       	push	r1
    207c:	0f 92       	push	r0
    207e:	0f b6       	in	r0, 0x3f	; 63
    2080:	0f 92       	push	r0
    2082:	11 24       	eor	r1, r1
    2084:	8f 93       	push	r24
    2086:	9f 93       	push	r25
	TCNT2_X++; 
    2088:	80 91 bb 05 	lds	r24, 0x05BB
    208c:	90 91 bc 05 	lds	r25, 0x05BC
    2090:	01 96       	adiw	r24, 0x01	; 1
    2092:	90 93 bc 05 	sts	0x05BC, r25
    2096:	80 93 bb 05 	sts	0x05BB, r24
}	
    209a:	9f 91       	pop	r25
    209c:	8f 91       	pop	r24
    209e:	0f 90       	pop	r0
    20a0:	0f be       	out	0x3f, r0	; 63
    20a2:	0f 90       	pop	r0
    20a4:	1f 90       	pop	r1
    20a6:	18 95       	reti

000020a8 <Timer_Init>:
{
	
	//TIMER ZERO is RESERVED for LCD DISPLAY.	
	
	// Timer1 @20MHz with overflow interrupt
	TCCR1B = _BV(CS10);
    20a8:	81 e0       	ldi	r24, 0x01	; 1
    20aa:	80 93 81 00 	sts	0x0081, r24
	TIMSK1 = _BV(TOIE1);
    20ae:	80 93 6f 00 	sts	0x006F, r24
	TCNT1_X =0;
    20b2:	10 92 71 06 	sts	0x0671, r1
    20b6:	10 92 70 06 	sts	0x0670, r1
			1 0 0		clkT2S/64 (From prescaler)
			1 0 1		clkT2S/128 (From prescaler)
			1 1 0		clkT2S/256 (From prescaler)
			1 1 1		clkT2S/1024 (From prescaler)
	*/
	TCCR2B  = (1 << CS21) | (1 << CS20);	//  div by 32	
    20ba:	93 e0       	ldi	r25, 0x03	; 3
    20bc:	90 93 b1 00 	sts	0x00B1, r25
	TIMSK2  = _BV(TOIE2); 
    20c0:	80 93 70 00 	sts	0x0070, r24
	TIFR2   = 0;
    20c4:	17 ba       	out	0x17, r1	; 23
	TCNT2	= 0;		// this overflows every  1.6us x 0xff = 409.6 us,  value tick 1.6us
    20c6:	10 92 b2 00 	sts	0x00B2, r1
	TCNT2_X = 0;
    20ca:	10 92 bc 05 	sts	0x05BC, r1
    20ce:	10 92 bb 05 	sts	0x05BB, r1
	/* IMPORTANT TCNT2 is used completly by motor and is reset during ESC pulse generation so you cannot depend on it for other purpose
	unless it is not time critical and no accuracy is required such as UI delays*/
	// tick: 12.8u  ov:3.2768ms	: TCNT2_X OV:  214.7483648 sec

    20d2:	08 95       	ret

000020d4 <UART_Init>:
	
}

void UART_Init( unsigned int ubrr)
{
	if (Config.RX_mode==RX_mode_UARTMode)
    20d4:	20 91 eb 06 	lds	r18, 0x06EB
    20d8:	2f 3f       	cpi	r18, 0xFF	; 255
    20da:	61 f4       	brne	.+24     	; 0x20f4 <UART_Init+0x20>
	{
		//memcpy(DisplayBuffer,"STR",3);
		RXIndex=0;
    20dc:	10 92 2d 05 	sts	0x052D, r1
		/*Set baud rate */
		UBRR1H = (unsigned char)(ubrr>>8);	
    20e0:	90 93 cd 00 	sts	0x00CD, r25
		UBRR1L = (unsigned char)ubrr;
    20e4:	80 93 cc 00 	sts	0x00CC, r24
		
		//UCSR1A = (1 << U2X1); // doubling divisor rate;
		// Set frame format to 8 data bits, no parity, 1 stop bit
		UCSR1C = (0<<USBS1)|(1<<UCSZ11)|(1<<UCSZ10);
    20e8:	86 e0       	ldi	r24, 0x06	; 6
    20ea:	80 93 ca 00 	sts	0x00CA, r24
		// Enable receiver and transmitter
		UCSR1B =  (1<<TXEN1)	// Enable USART TX
    20ee:	88 e9       	ldi	r24, 0x98	; 152
    20f0:	80 93 c9 00 	sts	0x00C9, r24
    20f4:	08 95       	ret

000020f6 <send_byte>:

void send_byte(uint8_t u8Data)
{

	// Wait if a byte is being transmitted
	while((UCSR1A & (1<<UDRE1)) == 0);
    20f6:	90 91 c8 00 	lds	r25, 0x00C8
    20fa:	95 ff       	sbrs	r25, 5
    20fc:	fc cf       	rjmp	.-8      	; 0x20f6 <send_byte>
	// Transmit data
	/////////delay_ms(10);
	UDR1 = u8Data;
    20fe:	80 93 ce 00 	sts	0x00CE, r24
}
    2102:	08 95       	ret

00002104 <Send_Data>:


void Send_Data (void * msg, uint8_t len)
{
    2104:	ef 92       	push	r14
    2106:	ff 92       	push	r15
    2108:	0f 93       	push	r16
    210a:	1f 93       	push	r17
    210c:	cf 93       	push	r28
    210e:	df 93       	push	r29
	
	for (int i=0; i<len;++i)
    2110:	08 2f       	mov	r16, r24
    2112:	19 2f       	mov	r17, r25
    2114:	c0 e0       	ldi	r28, 0x00	; 0
    2116:	d0 e0       	ldi	r29, 0x00	; 0
    2118:	e6 2e       	mov	r14, r22
    211a:	ff 24       	eor	r15, r15
    211c:	06 c0       	rjmp	.+12     	; 0x212a <Send_Data+0x26>
	{
		send_byte (((uint8_t *)msg)[i]);
    211e:	f8 01       	movw	r30, r16
    2120:	81 91       	ld	r24, Z+
    2122:	8f 01       	movw	r16, r30
    2124:	0e 94 7b 10 	call	0x20f6	; 0x20f6 <send_byte>


void Send_Data (void * msg, uint8_t len)
{
	
	for (int i=0; i<len;++i)
    2128:	21 96       	adiw	r28, 0x01	; 1
    212a:	ce 15       	cp	r28, r14
    212c:	df 05       	cpc	r29, r15
    212e:	bc f3       	brlt	.-18     	; 0x211e <Send_Data+0x1a>
	{
		send_byte (((uint8_t *)msg)[i]);
	}
	
	
}
    2130:	df 91       	pop	r29
    2132:	cf 91       	pop	r28
    2134:	1f 91       	pop	r17
    2136:	0f 91       	pop	r16
    2138:	ff 90       	pop	r15
    213a:	ef 90       	pop	r14
    213c:	08 95       	ret

0000213e <ParseCommand>:
}


void ParseCommand ()
{
	if (IsArmed==true)
    213e:	80 91 c8 07 	lds	r24, 0x07C8
    2142:	81 30       	cpi	r24, 0x01	; 1
    2144:	09 f4       	brne	.+2      	; 0x2148 <ParseCommand+0xa>
    2146:	69 c0       	rjmp	.+210    	; 0x221a <ParseCommand+0xdc>
    2148:	80 e0       	ldi	r24, 0x00	; 0
    214a:	90 e0       	ldi	r25, 0x00	; 0
    214c:	20 e0       	ldi	r18, 0x00	; 0
		return ;
	}		
	int8_t CRC=0;
	for (int i=0;i < SERIAL_BUFFERSIZE_1; ++i)
	{
		CRC +=RXBuffer[i];
    214e:	fc 01       	movw	r30, r24
    2150:	e7 52       	subi	r30, 0x27	; 39
    2152:	f8 4f       	sbci	r31, 0xF8	; 248
    2154:	30 81       	ld	r19, Z
    2156:	23 0f       	add	r18, r19
	{
		//Just ignore for safty reasons....some commands generate beeps or flash led that call delay function which will crash your quadcopter if called.
		return ;
	}		
	int8_t CRC=0;
	for (int i=0;i < SERIAL_BUFFERSIZE_1; ++i)
    2158:	01 96       	adiw	r24, 0x01	; 1
    215a:	88 30       	cpi	r24, 0x08	; 8
    215c:	91 05       	cpc	r25, r1
    215e:	b9 f7       	brne	.-18     	; 0x214e <ParseCommand+0x10>
	{
		CRC +=RXBuffer[i];
	}
	if (CRC == (int8_t)RXBuffer[SERIAL_CRC_OFFSET])
    2160:	80 91 e1 07 	lds	r24, 0x07E1
    2164:	28 17       	cp	r18, r24
    2166:	09 f0       	breq	.+2      	; 0x216a <ParseCommand+0x2c>
    2168:	58 c0       	rjmp	.+176    	; 0x221a <ParseCommand+0xdc>
	{
		switch (RXBuffer[SERIAL_HEADER])
    216a:	80 91 d9 07 	lds	r24, 0x07D9
    216e:	83 34       	cpi	r24, 0x43	; 67
    2170:	21 f0       	breq	.+8      	; 0x217a <ParseCommand+0x3c>
    2172:	86 35       	cpi	r24, 0x56	; 86
    2174:	09 f0       	breq	.+2      	; 0x2178 <ParseCommand+0x3a>
    2176:	51 c0       	rjmp	.+162    	; 0x221a <ParseCommand+0xdc>
    2178:	37 c0       	rjmp	.+110    	; 0x21e8 <ParseCommand+0xaa>
		{
			case SERIAL_HEADER_DOCMD:
				switch (RXBuffer[SERIAL_CMD_ID])
    217a:	80 91 da 07 	lds	r24, 0x07DA
    217e:	85 30       	cpi	r24, 0x05	; 5
    2180:	e9 f0       	breq	.+58     	; 0x21bc <ParseCommand+0x7e>
    2182:	86 30       	cpi	r24, 0x06	; 6
    2184:	30 f4       	brcc	.+12     	; 0x2192 <ParseCommand+0x54>
    2186:	81 30       	cpi	r24, 0x01	; 1
    2188:	51 f0       	breq	.+20     	; 0x219e <ParseCommand+0x60>
    218a:	82 30       	cpi	r24, 0x02	; 2
    218c:	09 f0       	breq	.+2      	; 0x2190 <ParseCommand+0x52>
    218e:	45 c0       	rjmp	.+138    	; 0x221a <ParseCommand+0xdc>
    2190:	0c c0       	rjmp	.+24     	; 0x21aa <ParseCommand+0x6c>
    2192:	86 30       	cpi	r24, 0x06	; 6
    2194:	19 f1       	breq	.+70     	; 0x21dc <ParseCommand+0x9e>
    2196:	87 30       	cpi	r24, 0x07	; 7
    2198:	09 f0       	breq	.+2      	; 0x219c <ParseCommand+0x5e>
    219a:	3f c0       	rjmp	.+126    	; 0x221a <ParseCommand+0xdc>
    219c:	22 c0       	rjmp	.+68     	; 0x21e2 <ParseCommand+0xa4>
				{
					case SERIAL_CMD_LED_BLINK: // never  call while ARMED .... calling delay function will affect motor speed.
						LED_FlashOrangeLED (LED_SHORT_TOGGLE,4);
    219e:	8e e1       	ldi	r24, 0x1E	; 30
    21a0:	90 e0       	ldi	r25, 0x00	; 0
    21a2:	64 e0       	ldi	r22, 0x04	; 4
    21a4:	0e 94 aa 0e 	call	0x1d54	; 0x1d54 <LED_FlashOrangeLED>
					break;
    21a8:	08 95       	ret
					case SERIAL_CMD_PID_CONFIG:
						Send_Data("C",1);
    21aa:	80 e0       	ldi	r24, 0x00	; 0
    21ac:	91 e0       	ldi	r25, 0x01	; 1
    21ae:	61 e0       	ldi	r22, 0x01	; 1
    21b0:	0e 94 82 10 	call	0x2104	; 0x2104 <Send_Data>
						Send_Data(&(Config.GyroParams),98);
    21b4:	87 ef       	ldi	r24, 0xF7	; 247
    21b6:	96 e0       	ldi	r25, 0x06	; 6
    21b8:	62 e6       	ldi	r22, 0x62	; 98
    21ba:	08 c0       	rjmp	.+16     	; 0x21cc <ParseCommand+0x8e>
						Send_Data("E",1);
					break;
					case SERIAL_CMD_READ_CONFIG: // BAD
						Send_Data("C",1);
    21bc:	80 e0       	ldi	r24, 0x00	; 0
    21be:	91 e0       	ldi	r25, 0x01	; 1
    21c0:	61 e0       	ldi	r22, 0x01	; 1
    21c2:	0e 94 82 10 	call	0x2104	; 0x2104 <Send_Data>
						Send_Data(&Config,86);
    21c6:	87 ee       	ldi	r24, 0xE7	; 231
    21c8:	96 e0       	ldi	r25, 0x06	; 6
    21ca:	66 e5       	ldi	r22, 0x56	; 86
    21cc:	0e 94 82 10 	call	0x2104	; 0x2104 <Send_Data>
						Send_Data("E",1);
    21d0:	82 e0       	ldi	r24, 0x02	; 2
    21d2:	91 e0       	ldi	r25, 0x01	; 1
    21d4:	61 e0       	ldi	r22, 0x01	; 1
    21d6:	0e 94 82 10 	call	0x2104	; 0x2104 <Send_Data>
					break;
    21da:	08 95       	ret
					case SERIAL_CMD_SAVE_CONFIG:
						Save_Config_to_EEPROM();
    21dc:	0e 94 df 0f 	call	0x1fbe	; 0x1fbe <Save_Config_to_EEPROM>
					break;
    21e0:	08 95       	ret
					case SERIAL_CMD_CALIBRATE_ACC:
						Sensors_Calibrate();								
    21e2:	0e 94 5b 28 	call	0x50b6	; 0x50b6 <Sensors_Calibrate>
					break;
    21e6:	08 95       	ret
				}
			break;
			case SERIAL_HEADER_SETVALUE:
				//LED_FlashOrangeLED (LED_SHORT_TOGGLE,4);
				memcpy ((void *)&Config + RXBuffer[SERIAL_DATA_OFFSET] + (RXBuffer[SERIAL_DATA_OFFSET+1] * 0xff),(void *) &RXBuffer[SERIAL_DATA_VALUE], (int8_t) RXBuffer[SERIAL_DATA_LENGHT]);
    21e8:	80 91 da 07 	lds	r24, 0x07DA
    21ec:	60 91 db 07 	lds	r22, 0x07DB
    21f0:	40 91 dc 07 	lds	r20, 0x07DC
    21f4:	9f ef       	ldi	r25, 0xFF	; 255
    21f6:	69 9f       	mul	r22, r25
    21f8:	b0 01       	movw	r22, r0
    21fa:	11 24       	eor	r1, r1
    21fc:	68 0f       	add	r22, r24
    21fe:	71 1d       	adc	r23, r1
    2200:	69 51       	subi	r22, 0x19	; 25
    2202:	79 4f       	sbci	r23, 0xF9	; 249
    2204:	24 2f       	mov	r18, r20
    2206:	33 27       	eor	r19, r19
    2208:	27 fd       	sbrc	r18, 7
    220a:	30 95       	com	r19
    220c:	ed ed       	ldi	r30, 0xDD	; 221
    220e:	f7 e0       	ldi	r31, 0x07	; 7
    2210:	cb 01       	movw	r24, r22
    2212:	bf 01       	movw	r22, r30
    2214:	53 2f       	mov	r21, r19
    2216:	0e 94 9a 3a 	call	0x7534	; 0x7534 <memcpy>
    221a:	08 95       	ret

0000221c <__vector_28>:
  
  
void ParseCommand();

ISR (USART1_RX_vect)
{
    221c:	1f 92       	push	r1
    221e:	0f 92       	push	r0
    2220:	0f b6       	in	r0, 0x3f	; 63
    2222:	0f 92       	push	r0
    2224:	11 24       	eor	r1, r1
    2226:	2f 93       	push	r18
    2228:	3f 93       	push	r19
    222a:	4f 93       	push	r20
    222c:	5f 93       	push	r21
    222e:	6f 93       	push	r22
    2230:	7f 93       	push	r23
    2232:	8f 93       	push	r24
    2234:	9f 93       	push	r25
    2236:	af 93       	push	r26
    2238:	bf 93       	push	r27
    223a:	ef 93       	push	r30
    223c:	ff 93       	push	r31
	 while ( !(UCSR1A & (1<<RXC1))); 
    223e:	80 91 c8 00 	lds	r24, 0x00C8
    2242:	87 ff       	sbrs	r24, 7
    2244:	fc cf       	rjmp	.-8      	; 0x223e <__vector_28+0x22>
	 RXChar = UDR1;
    2246:	80 91 ce 00 	lds	r24, 0x00CE
    224a:	80 93 d4 07 	sts	0x07D4, r24
	 
	  if ((c_state!=IDLE) && (TCNT1_X - LastRXTime) > 20) 
    224e:	80 91 2e 05 	lds	r24, 0x052E
    2252:	88 23       	and	r24, r24
    2254:	99 f0       	breq	.+38     	; 0x227c <__vector_28+0x60>
    2256:	80 91 70 06 	lds	r24, 0x0670
    225a:	90 91 71 06 	lds	r25, 0x0671
    225e:	20 91 d5 07 	lds	r18, 0x07D5
    2262:	30 91 d6 07 	lds	r19, 0x07D6
    2266:	82 1b       	sub	r24, r18
    2268:	93 0b       	sbc	r25, r19
    226a:	85 31       	cpi	r24, 0x15	; 21
    226c:	91 05       	cpc	r25, r1
    226e:	30 f0       	brcs	.+12     	; 0x227c <__vector_28+0x60>
	   {
		   // timeout ..
		   c_state = IDLE;
    2270:	10 92 2e 05 	sts	0x052E, r1
		   RXIndex =0;
    2274:	10 92 2d 05 	sts	0x052D, r1
		   DisplayBuffer[4]=0;
    2278:	10 92 ce 07 	sts	0x07CE, r1
		   //memcpy(DisplayBuffer,"OUT",3);
		   //return ;
	   }
	   RXBuffer[RXIndex]=RXChar;
    227c:	e0 91 2d 05 	lds	r30, 0x052D
    2280:	f0 e0       	ldi	r31, 0x00	; 0
    2282:	80 91 d4 07 	lds	r24, 0x07D4
    2286:	e7 52       	subi	r30, 0x27	; 39
    2288:	f8 4f       	sbci	r31, 0xF8	; 248
    228a:	80 83       	st	Z, r24
	   switch (c_state)
    228c:	80 91 2e 05 	lds	r24, 0x052E
    2290:	88 23       	and	r24, r24
    2292:	19 f0       	breq	.+6      	; 0x229a <__vector_28+0x7e>
    2294:	81 30       	cpi	r24, 0x01	; 1
    2296:	c1 f4       	brne	.+48     	; 0x22c8 <__vector_28+0xac>
    2298:	06 c0       	rjmp	.+12     	; 0x22a6 <__vector_28+0x8a>
	   {
		   case IDLE:
		   // Waiting for new command
			   RXIndex=0;
    229a:	10 92 2d 05 	sts	0x052D, r1
			   
			   
			   c_state = HEADER_RX;
    229e:	81 e0       	ldi	r24, 0x01	; 1
    22a0:	80 93 2e 05 	sts	0x052E, r24
    22a4:	07 c0       	rjmp	.+14     	; 0x22b4 <__vector_28+0x98>
		   break;
		   
		   case HEADER_RX:
		   // Copy Data
				
			    if (RXIndex==SERIAL_BUFFERSIZE_1)
    22a6:	80 91 2d 05 	lds	r24, 0x052D
    22aa:	88 30       	cpi	r24, 0x08	; 8
    22ac:	19 f4       	brne	.+6      	; 0x22b4 <__vector_28+0x98>
				{
					ParseCommand();
    22ae:	0e 94 9f 10 	call	0x213e	; 0x213e <ParseCommand>
    22b2:	0a c0       	rjmp	.+20     	; 0x22c8 <__vector_28+0xac>
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    22b4:	f8 94       	cli
				}
				else
				{
					ATOMIC_BLOCK(ATOMIC_FORCEON)
				   {
					 LastRXTime = TCNT1_X;
    22b6:	80 91 70 06 	lds	r24, 0x0670
    22ba:	90 91 71 06 	lds	r25, 0x0671
    22be:	90 93 d6 07 	sts	0x07D6, r25
    22c2:	80 93 d5 07 	sts	0x07D5, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    22c6:	78 94       	sei
				   }
				}								
		   break;
	   }
	
	 RXIndex+=1;
    22c8:	80 91 2d 05 	lds	r24, 0x052D
    22cc:	8f 5f       	subi	r24, 0xFF	; 255
    22ce:	80 93 2d 05 	sts	0x052D, r24
	 if (RXIndex==SERIAL_BUFFERSIZE) 
    22d2:	80 91 2d 05 	lds	r24, 0x052D
    22d6:	89 30       	cpi	r24, 0x09	; 9
    22d8:	21 f4       	brne	.+8      	; 0x22e2 <__vector_28+0xc6>
	 {
		RXIndex=0;
    22da:	10 92 2d 05 	sts	0x052D, r1
		c_state = IDLE;
    22de:	10 92 2e 05 	sts	0x052E, r1
	 }		
}
    22e2:	ff 91       	pop	r31
    22e4:	ef 91       	pop	r30
    22e6:	bf 91       	pop	r27
    22e8:	af 91       	pop	r26
    22ea:	9f 91       	pop	r25
    22ec:	8f 91       	pop	r24
    22ee:	7f 91       	pop	r23
    22f0:	6f 91       	pop	r22
    22f2:	5f 91       	pop	r21
    22f4:	4f 91       	pop	r20
    22f6:	3f 91       	pop	r19
    22f8:	2f 91       	pop	r18
    22fa:	0f 90       	pop	r0
    22fc:	0f be       	out	0x3f, r0	; 63
    22fe:	0f 90       	pop	r0
    2300:	1f 90       	pop	r1
    2302:	18 95       	reti

00002304 <Send_Data_TEST>:
	
	
}

void Send_Data_TEST (void * msg, uint8_t len)
{
    2304:	ef 92       	push	r14
    2306:	ff 92       	push	r15
    2308:	0f 93       	push	r16
    230a:	1f 93       	push	r17
    230c:	cf 93       	push	r28
    230e:	df 93       	push	r29
	for (int i=0; i<len;++i)
    2310:	08 2f       	mov	r16, r24
    2312:	19 2f       	mov	r17, r25
    2314:	c0 e0       	ldi	r28, 0x00	; 0
    2316:	d0 e0       	ldi	r29, 0x00	; 0
    2318:	e6 2e       	mov	r14, r22
    231a:	ff 24       	eor	r15, r15
    231c:	06 c0       	rjmp	.+12     	; 0x232a <Send_Data_TEST+0x26>
	{
		send_byte (((uint8_t *)msg)[i]);
    231e:	f8 01       	movw	r30, r16
    2320:	81 91       	ld	r24, Z+
    2322:	8f 01       	movw	r16, r30
    2324:	0e 94 7b 10 	call	0x20f6	; 0x20f6 <send_byte>
	
}

void Send_Data_TEST (void * msg, uint8_t len)
{
	for (int i=0; i<len;++i)
    2328:	21 96       	adiw	r28, 0x01	; 1
    232a:	ce 15       	cp	r28, r14
    232c:	df 05       	cpc	r29, r15
    232e:	bc f3       	brlt	.-18     	; 0x231e <Send_Data_TEST+0x1a>
	{
		send_byte (((uint8_t *)msg)[i]);
	}
	
    2330:	df 91       	pop	r29
    2332:	cf 91       	pop	r28
    2334:	1f 91       	pop	r17
    2336:	0f 91       	pop	r16
    2338:	ff 90       	pop	r15
    233a:	ef 90       	pop	r14
    233c:	08 95       	ret

0000233e <_font12x16selector>:
	*/
};

static PGM_P _font12x16selector(unsigned char c)
{
	return (PGM_P) _font12x16map + (c - 0x20) * BYTESPERCHAR;
    233e:	90 e0       	ldi	r25, 0x00	; 0
    2340:	80 97       	sbiw	r24, 0x20	; 32
    2342:	9c 01       	movw	r18, r24
    2344:	22 0f       	add	r18, r18
    2346:	33 1f       	adc	r19, r19
    2348:	28 0f       	add	r18, r24
    234a:	39 1f       	adc	r19, r25
    234c:	83 e0       	ldi	r24, 0x03	; 3
    234e:	22 0f       	add	r18, r18
    2350:	33 1f       	adc	r19, r19
    2352:	8a 95       	dec	r24
    2354:	e1 f7       	brne	.-8      	; 0x234e <_font12x16selector+0x10>
    2356:	25 58       	subi	r18, 0x85	; 133
    2358:	3e 4f       	sbci	r19, 0xFE	; 254
}
    235a:	c9 01       	movw	r24, r18
    235c:	08 95       	ret

0000235e <_font6x8selector>:
	*/
};

static PGM_P _font6x8selector(unsigned char c)
{
	return (PGM_P) _font6x8map + (c - 0x20) * BYTESPERCHAR;
    235e:	90 e0       	ldi	r25, 0x00	; 0
    2360:	80 97       	sbiw	r24, 0x20	; 32
    2362:	9c 01       	movw	r18, r24
    2364:	22 0f       	add	r18, r18
    2366:	33 1f       	adc	r19, r19
    2368:	28 0f       	add	r18, r24
    236a:	39 1f       	adc	r19, r25
    236c:	22 0f       	add	r18, r18
    236e:	33 1f       	adc	r19, r19
    2370:	21 58       	subi	r18, 0x81	; 129
    2372:	38 4f       	sbci	r19, 0xF8	; 248
}
    2374:	c9 01       	movw	r24, r18
    2376:	08 95       	ret

00002378 <Setup>:
static uint8_t FlyingModesToggle;

void Setup (void)
{
	
	Menu_EnableAllItems();
    2378:	0e 94 86 37 	call	0x6f0c	; 0x6f0c <Menu_EnableAllItems>
	
	Initial_EEPROM_Config_Load();
    237c:	0e 94 06 10 	call	0x200c	; 0x200c <Initial_EEPROM_Config_Load>
	
	//Config.QuadFlyingMode = QuadFlyingMode_PLUS;
	
	RX_Init();
    2380:	0e 94 95 25 	call	0x4b2a	; 0x4b2a <RX_Init>
	if ((Config.RX_mode==RX_mode_UARTMode) && (IS_MISC_SENSOR_SONAR_ENABLED==true))
    2384:	80 91 eb 06 	lds	r24, 0x06EB
    2388:	8f 3f       	cpi	r24, 0xFF	; 255
    238a:	31 f4       	brne	.+12     	; 0x2398 <Setup+0x20>
    238c:	80 91 f6 06 	lds	r24, 0x06F6
    2390:	80 ff       	sbrs	r24, 0
    2392:	02 c0       	rjmp	.+4      	; 0x2398 <Setup+0x20>
	{
		Ultrasonic_Init();
    2394:	0e 94 1f 0f 	call	0x1e3e	; 0x1e3e <Ultrasonic_Init>
	}		
	// Motors
	M1_DIR = OUTPUT;
    2398:	3e 9a       	sbi	0x07, 6	; 7
	M2_DIR = OUTPUT;
    239a:	3c 9a       	sbi	0x07, 4	; 7
	M3_DIR = OUTPUT;
    239c:	3a 9a       	sbi	0x07, 2	; 7
	M4_DIR = OUTPUT;
    239e:	3b 9a       	sbi	0x07, 3	; 7
	M1 = 0;
    23a0:	46 98       	cbi	0x08, 6	; 8
	M2 = 0;
    23a2:	44 98       	cbi	0x08, 4	; 8
	M3 = 0;
    23a4:	42 98       	cbi	0x08, 2	; 8
	M4 = 0;
    23a6:	43 98       	cbi	0x08, 3	; 8
	
	Buzzer_DIR = OUTPUT;
    23a8:	21 9a       	sbi	0x04, 1	; 4
	LED_Orange_DIR = OUTPUT;
    23aa:	23 9a       	sbi	0x04, 3	; 4
	
	
	// Sensors
	V_BAT  = INPUT;
    23ac:	13 98       	cbi	0x02, 3	; 2
	
	
	
	// Timers
	TCCR1A = 0;	//Set timer 1 to run at 2.5MHz
    23ae:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;
    23b2:	10 92 81 00 	sts	0x0081, r1
	TCCR1C = 0;
    23b6:	10 92 82 00 	sts	0x0082, r1
	

if (Config.RX_mode==RX_mode_UARTMode)
    23ba:	80 91 eb 06 	lds	r24, 0x06EB
    23be:	8f 3f       	cpi	r24, 0xFF	; 255
    23c0:	21 f4       	brne	.+8      	; 0x23ca <Setup+0x52>
{
	UART_Init(SERIAL_BAUD_RATE); //57600 = 20   115200=10
    23c2:	8a e0       	ldi	r24, 0x0A	; 10
    23c4:	90 e0       	ldi	r25, 0x00	; 0
    23c6:	0e 94 6a 10 	call	0x20d4	; 0x20d4 <UART_Init>
}	



	ADCPort_Init();
    23ca:	0e 94 f3 29 	call	0x53e6	; 0x53e6 <ADCPort_Init>
	Sensors_Init();
    23ce:	0e 94 1c 28 	call	0x5038	; 0x5038 <Sensors_Init>
	KeyBoard_Init();
    23d2:	0e 94 c8 0b 	call	0x1790	; 0x1790 <KeyBoard_Init>
	Timer_Init();
    23d6:	0e 94 54 10 	call	0x20a8	; 0x20a8 <Timer_Init>
	
	LCD_Init();
    23da:	0e 94 7f 0e 	call	0x1cfe	; 0x1cfe <LCD_Init>
	LCD_Clear();
    23de:	0e 94 57 0c 	call	0x18ae	; 0x18ae <LCD_Clear>
	
	Menu_MenuInit();
    23e2:	0e 94 7e 37 	call	0x6efc	; 0x6efc <Menu_MenuInit>
	
		
	
	
	sei();
    23e6:	78 94       	sei
	
	delay_ms(30);
    23e8:	8e e1       	ldi	r24, 0x1E	; 30
    23ea:	90 e0       	ldi	r25, 0x00	; 0
    23ec:	0e 94 0c 0f 	call	0x1e18	; 0x1e18 <delay_ms>
    
}
    23f0:	08 95       	ret

000023f2 <Loop>:
	We are in this loop because the system is not calibrated.
	This is the minimum functionality.
*/
void Loop(void)
{
	RX_CopyLatestReceiverValues(); // update RX_Latest also IS_TXn_GOOD
    23f2:	0e 94 cc 26 	call	0x4d98	; 0x4d98 <RX_CopyLatestReceiverValues>
	
	if (TCNT_X_snapshot2==0) TCNT_X_snapshot2 = TCNT2_X;
    23f6:	80 91 e8 05 	lds	r24, 0x05E8
    23fa:	90 91 e9 05 	lds	r25, 0x05E9
    23fe:	00 97       	sbiw	r24, 0x00	; 0
    2400:	41 f4       	brne	.+16     	; 0x2412 <Loop+0x20>
    2402:	80 91 bb 05 	lds	r24, 0x05BB
    2406:	90 91 bc 05 	lds	r25, 0x05BC
    240a:	90 93 e9 05 	sts	0x05E9, r25
    240e:	80 93 e8 05 	sts	0x05E8, r24
	if ( (TCNT2_X- TCNT_X_snapshot2) > LCD_RefreashRate )  
    2412:	80 91 bb 05 	lds	r24, 0x05BB
    2416:	90 91 bc 05 	lds	r25, 0x05BC
    241a:	20 91 e8 05 	lds	r18, 0x05E8
    241e:	30 91 e9 05 	lds	r19, 0x05E9
    2422:	82 1b       	sub	r24, r18
    2424:	93 0b       	sbc	r25, r19
    2426:	8b 30       	cpi	r24, 0x0B	; 11
    2428:	91 05       	cpc	r25, r1
    242a:	30 f0       	brcs	.+12     	; 0x2438 <Loop+0x46>
	{
		Menu_MenuShow();	
    242c:	0e 94 3b 37 	call	0x6e76	; 0x6e76 <Menu_MenuShow>
		TCNT_X_snapshot2=0;
    2430:	10 92 e9 05 	sts	0x05E9, r1
    2434:	10 92 e8 05 	sts	0x05E8, r1
    2438:	08 95       	ret

0000243a <LoopESCCalibration>:
}

void LoopESCCalibration (void)
{
	
	Menu_LoadPage(PAGE_HOME_ESC_CALIBRATION);
    243a:	83 e0       	ldi	r24, 0x03	; 3
    243c:	0e 94 18 2e 	call	0x5c30	; 0x5c30 <Menu_LoadPage>
	while (1)
	{
		Loop();
    2440:	0e 94 f9 11 	call	0x23f2	; 0x23f2 <Loop>
    2444:	fd cf       	rjmp	.-6      	; 0x2440 <LoopESCCalibration+0x6>

00002446 <LoopCalibration>:
// Never go to MainLoop "fly loop" unless Sensors & RX is calibrated.
// This loop to protect against any bug that might make the quad start or KB stick click
// as in this case crash is a must.
void LoopCalibration (void)
{
	menuEnabled[PAGE_STABILIZATION] =0;
    2446:	10 92 e7 07 	sts	0x07E7, r1
	menuEnabled[PAGE_SELF_LEVELING] =0;
    244a:	10 92 e8 07 	sts	0x07E8, r1
	menuEnabled[PAGE_ALT_HOLD]		=0;
    244e:	10 92 e9 07 	sts	0x07E9, r1
	menuEnabled[PAGE_MISC_SETTING]  =0;
    2452:	10 92 eb 07 	sts	0x07EB, r1
	menuEnabled[PAGE_ESC_CALIBRATION]=0; // u cannot make ESC Calibration as sticks are not ready for testing.
    2456:	10 92 f0 07 	sts	0x07F0, r1
		
	while (!(Config.IsCalibrated & CALIBRATED_SENSOR) || !(Config.IsCalibrated & CALIBRATED_Stick_SECONDARY))
    245a:	02 c0       	rjmp	.+4      	; 0x2460 <LoopCalibration+0x1a>
	{	
		Loop();
    245c:	0e 94 f9 11 	call	0x23f2	; 0x23f2 <Loop>
	menuEnabled[PAGE_SELF_LEVELING] =0;
	menuEnabled[PAGE_ALT_HOLD]		=0;
	menuEnabled[PAGE_MISC_SETTING]  =0;
	menuEnabled[PAGE_ESC_CALIBRATION]=0; // u cannot make ESC Calibration as sticks are not ready for testing.
		
	while (!(Config.IsCalibrated & CALIBRATED_SENSOR) || !(Config.IsCalibrated & CALIBRATED_Stick_SECONDARY))
    2460:	80 91 ea 06 	lds	r24, 0x06EA
    2464:	82 ff       	sbrs	r24, 2
    2466:	fa cf       	rjmp	.-12     	; 0x245c <LoopCalibration+0x16>
    2468:	81 ff       	sbrs	r24, 1
    246a:	f8 cf       	rjmp	.-16     	; 0x245c <LoopCalibration+0x16>
	{	
		Loop();
	}
}
    246c:	08 95       	ret

0000246e <HandleSticksForArming>:
// This function is never called if there is a calibration issue.
// called in true section of if (RX_Snapshot[RXChannel_THR] < STICKThrottle_ARMING) 
void HandleSticksForArming (void)
{
	
	if ((UIEnableStickCommands==false) || (ActiveRXIndex!=1) || (!IS_TX2_GOOD)) return ; // you cannot use Primary to Arm and Disarm
    246e:	80 91 e5 05 	lds	r24, 0x05E5
    2472:	88 23       	and	r24, r24
    2474:	09 f4       	brne	.+2      	; 0x2478 <HandleSticksForArming+0xa>
    2476:	6c c1       	rjmp	.+728    	; 0x2750 <HandleSticksForArming+0x2e2>
    2478:	80 91 ca 05 	lds	r24, 0x05CA
    247c:	81 30       	cpi	r24, 0x01	; 1
    247e:	09 f0       	breq	.+2      	; 0x2482 <HandleSticksForArming+0x14>
    2480:	67 c1       	rjmp	.+718    	; 0x2750 <HandleSticksForArming+0x2e2>
    2482:	80 91 fb 07 	lds	r24, 0x07FB
    2486:	80 7f       	andi	r24, 0xF0	; 240
    2488:	09 f0       	breq	.+2      	; 0x248c <HandleSticksForArming+0x1e>
    248a:	62 c1       	rjmp	.+708    	; 0x2750 <HandleSticksForArming+0x2e2>
	SystemErrorType = CLR_SYS_ERR_SIGNAL;
    248c:	80 91 d7 06 	lds	r24, 0x06D7
    2490:	8e 7f       	andi	r24, 0xFE	; 254
    2492:	80 93 d7 06 	sts	0x06D7, r24
	
	if (TCNT1_X_snapshot1==0)  TCNT1_X_snapshot1 = CurrentTCNT1_X; // start counting
    2496:	80 91 e6 05 	lds	r24, 0x05E6
    249a:	90 91 e7 05 	lds	r25, 0x05E7
    249e:	00 97       	sbiw	r24, 0x00	; 0
    24a0:	41 f4       	brne	.+16     	; 0x24b2 <HandleSticksForArming+0x44>
    24a2:	80 91 6a 06 	lds	r24, 0x066A
    24a6:	90 91 6b 06 	lds	r25, 0x066B
    24aa:	90 93 e7 05 	sts	0x05E7, r25
    24ae:	80 93 e6 05 	sts	0x05E6, r24
		
		// DisArm Check
		if (IsArmed == true) 
    24b2:	80 91 c8 07 	lds	r24, 0x07C8
    24b6:	81 30       	cpi	r24, 0x01	; 1
    24b8:	09 f0       	breq	.+2      	; 0x24bc <HandleSticksForArming+0x4e>
    24ba:	54 c0       	rjmp	.+168    	; 0x2564 <HandleSticksForArming+0xf6>
		{
			if (RX_Latest[ActiveRXIndex][RXChannel_RUD] > STICK_LEFT)
    24bc:	20 91 ca 05 	lds	r18, 0x05CA
    24c0:	82 2f       	mov	r24, r18
    24c2:	90 e0       	ldi	r25, 0x00	; 0
    24c4:	fc 01       	movw	r30, r24
    24c6:	ee 0f       	add	r30, r30
    24c8:	ff 1f       	adc	r31, r31
    24ca:	43 e0       	ldi	r20, 0x03	; 3
    24cc:	88 0f       	add	r24, r24
    24ce:	99 1f       	adc	r25, r25
    24d0:	4a 95       	dec	r20
    24d2:	e1 f7       	brne	.-8      	; 0x24cc <HandleSticksForArming+0x5e>
    24d4:	e8 0f       	add	r30, r24
    24d6:	f9 1f       	adc	r31, r25
    24d8:	ee 5f       	subi	r30, 0xFE	; 254
    24da:	f9 4f       	sbci	r31, 0xF9	; 249
    24dc:	84 81       	ldd	r24, Z+4	; 0x04
    24de:	95 81       	ldd	r25, Z+5	; 0x05
    24e0:	21 e0       	ldi	r18, 0x01	; 1
    24e2:	81 39       	cpi	r24, 0x91	; 145
    24e4:	92 07       	cpc	r25, r18
    24e6:	84 f0       	brlt	.+32     	; 0x2508 <HandleSticksForArming+0x9a>
			{ // Check DisArming manually.
				bResetTCNR1_X  = false;
    24e8:	10 92 65 06 	sts	0x0665, r1
				if ( (CurrentTCNT1_X - TCNT1_X_snapshot1) > STICKPOSITION_LONG_TIME )
    24ec:	80 91 6a 06 	lds	r24, 0x066A
    24f0:	90 91 6b 06 	lds	r25, 0x066B
    24f4:	20 91 e6 05 	lds	r18, 0x05E6
    24f8:	30 91 e7 05 	lds	r19, 0x05E7
    24fc:	82 1b       	sub	r24, r18
    24fe:	93 0b       	sbc	r25, r19
    2500:	21 e0       	ldi	r18, 0x01	; 1
    2502:	82 33       	cpi	r24, 0x32	; 50
    2504:	92 07       	cpc	r25, r18
    2506:	58 f5       	brcc	.+86     	; 0x255e <HandleSticksForArming+0xf0>
					Disarm();
					return ;
				}
			}
			
			if (Config.AutoDisarm!=0)
    2508:	60 91 ee 06 	lds	r22, 0x06EE
    250c:	66 23       	and	r22, r22
    250e:	09 f4       	brne	.+2      	; 0x2512 <HandleSticksForArming+0xa4>
    2510:	1f c1       	rjmp	.+574    	; 0x2750 <HandleSticksForArming+0x2e2>
			{ // check auto disArm
				if (TCNT_X_snapshotAutoDisarm==0) TCNT_X_snapshotAutoDisarm = CurrentTCNT1_X;
    2512:	80 91 1b 06 	lds	r24, 0x061B
    2516:	90 91 1c 06 	lds	r25, 0x061C
    251a:	00 97       	sbiw	r24, 0x00	; 0
    251c:	41 f4       	brne	.+16     	; 0x252e <HandleSticksForArming+0xc0>
    251e:	80 91 6a 06 	lds	r24, 0x066A
    2522:	90 91 6b 06 	lds	r25, 0x066B
    2526:	90 93 1c 06 	sts	0x061C, r25
    252a:	80 93 1b 06 	sts	0x061B, r24
				if ((CurrentTCNT1_X - TCNT_X_snapshotAutoDisarm) > (DISARM_TIME * Config.AutoDisarm))
    252e:	80 91 6a 06 	lds	r24, 0x066A
    2532:	90 91 6b 06 	lds	r25, 0x066B
    2536:	20 91 1b 06 	lds	r18, 0x061B
    253a:	30 91 1c 06 	lds	r19, 0x061C
    253e:	82 1b       	sub	r24, r18
    2540:	93 0b       	sbc	r25, r19
    2542:	70 e0       	ldi	r23, 0x00	; 0
    2544:	48 ee       	ldi	r20, 0xE8	; 232
    2546:	53 e0       	ldi	r21, 0x03	; 3
    2548:	64 9f       	mul	r22, r20
    254a:	90 01       	movw	r18, r0
    254c:	65 9f       	mul	r22, r21
    254e:	30 0d       	add	r19, r0
    2550:	74 9f       	mul	r23, r20
    2552:	30 0d       	add	r19, r0
    2554:	11 24       	eor	r1, r1
    2556:	28 17       	cp	r18, r24
    2558:	39 07       	cpc	r19, r25
    255a:	08 f0       	brcs	.+2      	; 0x255e <HandleSticksForArming+0xf0>
    255c:	f9 c0       	rjmp	.+498    	; 0x2750 <HandleSticksForArming+0x2e2>
				{
					Disarm();
    255e:	0e 94 29 0f 	call	0x1e52	; 0x1e52 <Disarm>
					return ;
    2562:	08 95       	ret
				}
			}
			
		}			
		
		if (IsArmed == false) 
    2564:	88 23       	and	r24, r24
    2566:	09 f0       	breq	.+2      	; 0x256a <HandleSticksForArming+0xfc>
    2568:	f3 c0       	rjmp	.+486    	; 0x2750 <HandleSticksForArming+0x2e2>
		{
			//int16_t Stick = (Config.RX_Mid[ActiveRXIndex][RXChannel_RUD] + RX_Latest[ActiveRXIndex][RXChannel_RUD] * RX_Div_Factor);
			if (RX_Latest[ActiveRXIndex][RXChannel_RUD]  < STICK_RIGHT)
    256a:	20 91 ca 05 	lds	r18, 0x05CA
    256e:	82 2f       	mov	r24, r18
    2570:	90 e0       	ldi	r25, 0x00	; 0
    2572:	fc 01       	movw	r30, r24
    2574:	ee 0f       	add	r30, r30
    2576:	ff 1f       	adc	r31, r31
    2578:	23 e0       	ldi	r18, 0x03	; 3
    257a:	88 0f       	add	r24, r24
    257c:	99 1f       	adc	r25, r25
    257e:	2a 95       	dec	r18
    2580:	e1 f7       	brne	.-8      	; 0x257a <HandleSticksForArming+0x10c>
    2582:	e8 0f       	add	r30, r24
    2584:	f9 1f       	adc	r31, r25
    2586:	ee 5f       	subi	r30, 0xFE	; 254
    2588:	f9 4f       	sbci	r31, 0xF9	; 249
    258a:	84 81       	ldd	r24, Z+4	; 0x04
    258c:	95 81       	ldd	r25, Z+5	; 0x05
    258e:	2e ef       	ldi	r18, 0xFE	; 254
    2590:	80 37       	cpi	r24, 0x70	; 112
    2592:	92 07       	cpc	r25, r18
    2594:	fc f4       	brge	.+62     	; 0x25d4 <HandleSticksForArming+0x166>
			{	// Armin Check
				bResetTCNR1_X = false;
    2596:	10 92 65 06 	sts	0x0665, r1
				if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_LONG_TIME )
    259a:	80 91 6a 06 	lds	r24, 0x066A
    259e:	90 91 6b 06 	lds	r25, 0x066B
    25a2:	20 91 e6 05 	lds	r18, 0x05E6
    25a6:	30 91 e7 05 	lds	r19, 0x05E7
    25aa:	82 1b       	sub	r24, r18
    25ac:	93 0b       	sbc	r25, r19
    25ae:	21 e0       	ldi	r18, 0x01	; 1
    25b0:	82 33       	cpi	r24, 0x32	; 50
    25b2:	92 07       	cpc	r25, r18
    25b4:	78 f0       	brcs	.+30     	; 0x25d4 <HandleSticksForArming+0x166>
				{
					if ((Config.RX_mode==RX_mode_BuddyMode) && (!IS_TX1_GOOD)) return; 
    25b6:	80 91 eb 06 	lds	r24, 0x06EB
    25ba:	88 23       	and	r24, r24
    25bc:	41 f4       	brne	.+16     	; 0x25ce <HandleSticksForArming+0x160>
    25be:	80 91 fb 07 	lds	r24, 0x07FB
    25c2:	90 e0       	ldi	r25, 0x00	; 0
    25c4:	8f 70       	andi	r24, 0x0F	; 15
    25c6:	90 70       	andi	r25, 0x00	; 0
    25c8:	00 97       	sbiw	r24, 0x00	; 0
    25ca:	09 f0       	breq	.+2      	; 0x25ce <HandleSticksForArming+0x160>
    25cc:	c1 c0       	rjmp	.+386    	; 0x2750 <HandleSticksForArming+0x2e2>
					// in Buddy mode you cannot arm is there is no signal from TX1
					
					Arm();
    25ce:	0e 94 3a 0f 	call	0x1e74	; 0x1e74 <Arm>
					return ;
    25d2:	08 95       	ret
				}
			}					
		
			//set modes Quad , X-Quad
		
			if (RX_Latest[ActiveRXIndex][RXChannel_AIL]  > STICK_LEFT)
    25d4:	20 91 ca 05 	lds	r18, 0x05CA
    25d8:	82 2f       	mov	r24, r18
    25da:	90 e0       	ldi	r25, 0x00	; 0
    25dc:	fc 01       	movw	r30, r24
    25de:	ee 0f       	add	r30, r30
    25e0:	ff 1f       	adc	r31, r31
    25e2:	a3 e0       	ldi	r26, 0x03	; 3
    25e4:	88 0f       	add	r24, r24
    25e6:	99 1f       	adc	r25, r25
    25e8:	aa 95       	dec	r26
    25ea:	e1 f7       	brne	.-8      	; 0x25e4 <HandleSticksForArming+0x176>
    25ec:	e8 0f       	add	r30, r24
    25ee:	f9 1f       	adc	r31, r25
    25f0:	ee 5f       	subi	r30, 0xFE	; 254
    25f2:	f9 4f       	sbci	r31, 0xF9	; 249
    25f4:	80 81       	ld	r24, Z
    25f6:	91 81       	ldd	r25, Z+1	; 0x01
    25f8:	21 e0       	ldi	r18, 0x01	; 1
    25fa:	81 39       	cpi	r24, 0x91	; 145
    25fc:	92 07       	cpc	r25, r18
    25fe:	ac f0       	brlt	.+42     	; 0x262a <HandleSticksForArming+0x1bc>
			{// X-QUAD MODE
				bResetTCNR1_X = false;
    2600:	10 92 65 06 	sts	0x0665, r1
				if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_LONG_TIME )
    2604:	80 91 6a 06 	lds	r24, 0x066A
    2608:	90 91 6b 06 	lds	r25, 0x066B
    260c:	20 91 e6 05 	lds	r18, 0x05E6
    2610:	30 91 e7 05 	lds	r19, 0x05E7
    2614:	82 1b       	sub	r24, r18
    2616:	93 0b       	sbc	r25, r19
    2618:	21 e0       	ldi	r18, 0x01	; 1
    261a:	82 33       	cpi	r24, 0x32	; 50
    261c:	92 07       	cpc	r25, r18
    261e:	08 f4       	brcc	.+2      	; 0x2622 <HandleSticksForArming+0x1b4>
    2620:	97 c0       	rjmp	.+302    	; 0x2750 <HandleSticksForArming+0x2e2>
				{
					Config.QuadFlyingMode=QuadFlyingMode_X;
    2622:	81 e0       	ldi	r24, 0x01	; 1
    2624:	80 93 f2 06 	sts	0x06F2, r24
    2628:	57 c0       	rjmp	.+174    	; 0x26d8 <HandleSticksForArming+0x26a>
					LED_FlashOrangeLED (LED_LONG_TOGGLE,8);
					TCNT1_X_snapshot1 =0; // reset timer
				}
			}			
			else if ((RX_Latest[ActiveRXIndex][RXChannel_AIL]  < STICK_RIGHT))
    262a:	20 91 ca 05 	lds	r18, 0x05CA
    262e:	82 2f       	mov	r24, r18
    2630:	90 e0       	ldi	r25, 0x00	; 0
    2632:	fc 01       	movw	r30, r24
    2634:	ee 0f       	add	r30, r30
    2636:	ff 1f       	adc	r31, r31
    2638:	63 e0       	ldi	r22, 0x03	; 3
    263a:	88 0f       	add	r24, r24
    263c:	99 1f       	adc	r25, r25
    263e:	6a 95       	dec	r22
    2640:	e1 f7       	brne	.-8      	; 0x263a <HandleSticksForArming+0x1cc>
    2642:	e8 0f       	add	r30, r24
    2644:	f9 1f       	adc	r31, r25
    2646:	ee 5f       	subi	r30, 0xFE	; 254
    2648:	f9 4f       	sbci	r31, 0xF9	; 249
    264a:	80 81       	ld	r24, Z
    264c:	91 81       	ldd	r25, Z+1	; 0x01
    264e:	2e ef       	ldi	r18, 0xFE	; 254
    2650:	80 37       	cpi	r24, 0x70	; 112
    2652:	92 07       	cpc	r25, r18
    2654:	bc f4       	brge	.+46     	; 0x2684 <HandleSticksForArming+0x216>
				{	// QUAD COPTER MODE
					bResetTCNR1_X = false;
    2656:	10 92 65 06 	sts	0x0665, r1
					if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_LONG_TIME )
    265a:	80 91 6a 06 	lds	r24, 0x066A
    265e:	90 91 6b 06 	lds	r25, 0x066B
    2662:	20 91 e6 05 	lds	r18, 0x05E6
    2666:	30 91 e7 05 	lds	r19, 0x05E7
    266a:	82 1b       	sub	r24, r18
    266c:	93 0b       	sbc	r25, r19
    266e:	21 e0       	ldi	r18, 0x01	; 1
    2670:	82 33       	cpi	r24, 0x32	; 50
    2672:	92 07       	cpc	r25, r18
    2674:	08 f4       	brcc	.+2      	; 0x2678 <HandleSticksForArming+0x20a>
    2676:	6c c0       	rjmp	.+216    	; 0x2750 <HandleSticksForArming+0x2e2>
					{
						Config.QuadFlyingMode=QuadFlyingMode_PLUS;
    2678:	10 92 f2 06 	sts	0x06F2, r1
						LED_FlashOrangeLED (LED_LONG_TOGGLE,4);
    267c:	80 e5       	ldi	r24, 0x50	; 80
    267e:	90 e0       	ldi	r25, 0x00	; 0
    2680:	64 e0       	ldi	r22, 0x04	; 4
    2682:	2d c0       	rjmp	.+90     	; 0x26de <HandleSticksForArming+0x270>
					}		
			
				} 
				
			// set mode ACRO , Leveling
			else if ((RX_Latest[ActiveRXIndex][RXChannel_ELE]  < STICK_RIGHT))
    2684:	20 91 ca 05 	lds	r18, 0x05CA
    2688:	82 2f       	mov	r24, r18
    268a:	90 e0       	ldi	r25, 0x00	; 0
    268c:	fc 01       	movw	r30, r24
    268e:	ee 0f       	add	r30, r30
    2690:	ff 1f       	adc	r31, r31
    2692:	43 e0       	ldi	r20, 0x03	; 3
    2694:	88 0f       	add	r24, r24
    2696:	99 1f       	adc	r25, r25
    2698:	4a 95       	dec	r20
    269a:	e1 f7       	brne	.-8      	; 0x2694 <HandleSticksForArming+0x226>
    269c:	e8 0f       	add	r30, r24
    269e:	f9 1f       	adc	r31, r25
    26a0:	ee 5f       	subi	r30, 0xFE	; 254
    26a2:	f9 4f       	sbci	r31, 0xF9	; 249
    26a4:	82 81       	ldd	r24, Z+2	; 0x02
    26a6:	93 81       	ldd	r25, Z+3	; 0x03
    26a8:	2e ef       	ldi	r18, 0xFE	; 254
    26aa:	80 37       	cpi	r24, 0x70	; 112
    26ac:	92 07       	cpc	r25, r18
    26ae:	f4 f4       	brge	.+60     	; 0x26ec <HandleSticksForArming+0x27e>
				{	//nFlyingModes = FLYINGMODE_LEVEL;
					bResetTCNR1_X = false;
    26b0:	10 92 65 06 	sts	0x0665, r1
					if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_LONG_TIME )
    26b4:	80 91 6a 06 	lds	r24, 0x066A
    26b8:	90 91 6b 06 	lds	r25, 0x066B
    26bc:	20 91 e6 05 	lds	r18, 0x05E6
    26c0:	30 91 e7 05 	lds	r19, 0x05E7
    26c4:	82 1b       	sub	r24, r18
    26c6:	93 0b       	sbc	r25, r19
    26c8:	21 e0       	ldi	r18, 0x01	; 1
    26ca:	82 33       	cpi	r24, 0x32	; 50
    26cc:	92 07       	cpc	r25, r18
    26ce:	08 f4       	brcc	.+2      	; 0x26d2 <HandleSticksForArming+0x264>
    26d0:	3f c0       	rjmp	.+126    	; 0x2750 <HandleSticksForArming+0x2e2>
					{
						nFlyingModes = FLYINGMODE_LEVEL;
    26d2:	82 e0       	ldi	r24, 0x02	; 2
    26d4:	80 93 1a 06 	sts	0x061A, r24
						LED_FlashOrangeLED (LED_LONG_TOGGLE,8);
    26d8:	80 e5       	ldi	r24, 0x50	; 80
    26da:	90 e0       	ldi	r25, 0x00	; 0
    26dc:	68 e0       	ldi	r22, 0x08	; 8
    26de:	0e 94 aa 0e 	call	0x1d54	; 0x1d54 <LED_FlashOrangeLED>
						TCNT1_X_snapshot1 =0; // reset timer
    26e2:	10 92 e7 05 	sts	0x05E7, r1
    26e6:	10 92 e6 05 	sts	0x05E6, r1
    26ea:	08 95       	ret
					}		
			
				} 
			else if ((RX_Latest[ActiveRXIndex][RXChannel_ELE]  > STICK_LEFT))
    26ec:	20 91 ca 05 	lds	r18, 0x05CA
    26f0:	82 2f       	mov	r24, r18
    26f2:	90 e0       	ldi	r25, 0x00	; 0
    26f4:	fc 01       	movw	r30, r24
    26f6:	ee 0f       	add	r30, r30
    26f8:	ff 1f       	adc	r31, r31
    26fa:	23 e0       	ldi	r18, 0x03	; 3
    26fc:	88 0f       	add	r24, r24
    26fe:	99 1f       	adc	r25, r25
    2700:	2a 95       	dec	r18
    2702:	e1 f7       	brne	.-8      	; 0x26fc <HandleSticksForArming+0x28e>
    2704:	e8 0f       	add	r30, r24
    2706:	f9 1f       	adc	r31, r25
    2708:	ee 5f       	subi	r30, 0xFE	; 254
    270a:	f9 4f       	sbci	r31, 0xF9	; 249
    270c:	82 81       	ldd	r24, Z+2	; 0x02
    270e:	93 81       	ldd	r25, Z+3	; 0x03
    2710:	21 e0       	ldi	r18, 0x01	; 1
    2712:	81 39       	cpi	r24, 0x91	; 145
    2714:	92 07       	cpc	r25, r18
    2716:	e4 f0       	brlt	.+56     	; 0x2750 <HandleSticksForArming+0x2e2>
				{	//nFlyingModes = FLYINGMODE_ACRO;
					bResetTCNR1_X = false;
    2718:	10 92 65 06 	sts	0x0665, r1
					if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_LONG_TIME )
    271c:	80 91 6a 06 	lds	r24, 0x066A
    2720:	90 91 6b 06 	lds	r25, 0x066B
    2724:	20 91 e6 05 	lds	r18, 0x05E6
    2728:	30 91 e7 05 	lds	r19, 0x05E7
    272c:	82 1b       	sub	r24, r18
    272e:	93 0b       	sbc	r25, r19
    2730:	21 e0       	ldi	r18, 0x01	; 1
    2732:	82 33       	cpi	r24, 0x32	; 50
    2734:	92 07       	cpc	r25, r18
    2736:	60 f0       	brcs	.+24     	; 0x2750 <HandleSticksForArming+0x2e2>
					{
						nFlyingModes = FLYINGMODE_ACRO;
    2738:	81 e0       	ldi	r24, 0x01	; 1
    273a:	80 93 1a 06 	sts	0x061A, r24
						LED_FlashOrangeLED (LED_LONG_TOGGLE,4);
    273e:	80 e5       	ldi	r24, 0x50	; 80
    2740:	90 e0       	ldi	r25, 0x00	; 0
    2742:	64 e0       	ldi	r22, 0x04	; 4
    2744:	0e 94 aa 0e 	call	0x1d54	; 0x1d54 <LED_FlashOrangeLED>
						TCNT1_X_snapshot1 =0; // reset timer
    2748:	10 92 e7 05 	sts	0x05E7, r1
    274c:	10 92 e6 05 	sts	0x05E6, r1
    2750:	08 95       	ret

00002752 <HandleSticksAsKeys>:

// This function is never called if there is a calibration issue.
// called in FALSE section of if (RX_Snapshot[RXChannel_THR] < STICKThrottle_ARMING) 
void HandleSticksAsKeys (void)
{
		if ((UIEnableStickCommands==false) || (!IS_TX2_GOOD))  return ; // you cannot use Primary as keys
    2752:	80 91 e5 05 	lds	r24, 0x05E5
    2756:	88 23       	and	r24, r24
    2758:	09 f4       	brne	.+2      	; 0x275c <HandleSticksAsKeys+0xa>
    275a:	87 c0       	rjmp	.+270    	; 0x286a <HandleSticksAsKeys+0x118>
    275c:	80 91 fb 07 	lds	r24, 0x07FB
    2760:	80 7f       	andi	r24, 0xF0	; 240
    2762:	09 f0       	breq	.+2      	; 0x2766 <HandleSticksAsKeys+0x14>
    2764:	82 c0       	rjmp	.+260    	; 0x286a <HandleSticksAsKeys+0x118>

		// if Throttle is high and stick are calibrated
		
		if (TCNT1_X_snapshot1==0)  TCNT1_X_snapshot1 = CurrentTCNT1_X; // start counting
    2766:	80 91 e6 05 	lds	r24, 0x05E6
    276a:	90 91 e7 05 	lds	r25, 0x05E7
    276e:	00 97       	sbiw	r24, 0x00	; 0
    2770:	41 f4       	brne	.+16     	; 0x2782 <HandleSticksAsKeys+0x30>
    2772:	80 91 6a 06 	lds	r24, 0x066A
    2776:	90 91 6b 06 	lds	r25, 0x066B
    277a:	90 93 e7 05 	sts	0x05E7, r25
    277e:	80 93 e6 05 	sts	0x05E6, r24
				
	 	if ((RX_Latest[RX_MAIN][RXChannel_ELE]) > STICK_LEFT) 
    2782:	80 91 0e 06 	lds	r24, 0x060E
    2786:	90 91 0f 06 	lds	r25, 0x060F
    278a:	21 e0       	ldi	r18, 0x01	; 1
    278c:	81 39       	cpi	r24, 0x91	; 145
    278e:	92 07       	cpc	r25, r18
    2790:	8c f0       	brlt	.+34     	; 0x27b4 <HandleSticksAsKeys+0x62>
		{
			bResetTCNR1_X = false;
    2792:	10 92 65 06 	sts	0x0665, r1
			if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_SHORT_TIME )
    2796:	80 91 6a 06 	lds	r24, 0x066A
    279a:	90 91 6b 06 	lds	r25, 0x066B
    279e:	20 91 e6 05 	lds	r18, 0x05E6
    27a2:	30 91 e7 05 	lds	r19, 0x05E7
    27a6:	82 1b       	sub	r24, r18
    27a8:	93 0b       	sbc	r25, r19
    27aa:	81 35       	cpi	r24, 0x51	; 81
    27ac:	91 05       	cpc	r25, r1
    27ae:	00 f1       	brcs	.+64     	; 0x27f0 <HandleSticksAsKeys+0x9e>
			{
				_TXKeys = KEY_3;
    27b0:	80 e2       	ldi	r24, 0x20	; 32
    27b2:	18 c0       	rjmp	.+48     	; 0x27e4 <HandleSticksAsKeys+0x92>
				TCNT1_X_snapshot1 =0; // reset timer
			}		
		
		}
		else if ((RX_Latest[RX_MAIN][RXChannel_ELE]) < STICK_RIGHT) 
    27b4:	80 91 0e 06 	lds	r24, 0x060E
    27b8:	90 91 0f 06 	lds	r25, 0x060F
    27bc:	2e ef       	ldi	r18, 0xFE	; 254
    27be:	80 37       	cpi	r24, 0x70	; 112
    27c0:	92 07       	cpc	r25, r18
    27c2:	b4 f4       	brge	.+44     	; 0x27f0 <HandleSticksAsKeys+0x9e>
		{
			bResetTCNR1_X = false;
    27c4:	10 92 65 06 	sts	0x0665, r1
			if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_SHORT_TIME )
    27c8:	80 91 6a 06 	lds	r24, 0x066A
    27cc:	90 91 6b 06 	lds	r25, 0x066B
    27d0:	20 91 e6 05 	lds	r18, 0x05E6
    27d4:	30 91 e7 05 	lds	r19, 0x05E7
    27d8:	82 1b       	sub	r24, r18
    27da:	93 0b       	sbc	r25, r19
    27dc:	81 35       	cpi	r24, 0x51	; 81
    27de:	91 05       	cpc	r25, r1
    27e0:	38 f0       	brcs	.+14     	; 0x27f0 <HandleSticksAsKeys+0x9e>
			{
				_TXKeys = KEY_2;
    27e2:	80 e4       	ldi	r24, 0x40	; 64
    27e4:	80 93 d6 06 	sts	0x06D6, r24
				TCNT1_X_snapshot1 =0; // reset timer
    27e8:	10 92 e7 05 	sts	0x05E7, r1
    27ec:	10 92 e6 05 	sts	0x05E6, r1
			}		
		
		}		 	 
		
		if ((RX_Latest[RX_MAIN][RXChannel_AIL]) > STICK_LEFT) 
    27f0:	80 91 0c 06 	lds	r24, 0x060C
    27f4:	90 91 0d 06 	lds	r25, 0x060D
    27f8:	21 e0       	ldi	r18, 0x01	; 1
    27fa:	81 39       	cpi	r24, 0x91	; 145
    27fc:	92 07       	cpc	r25, r18
    27fe:	bc f0       	brlt	.+46     	; 0x282e <HandleSticksAsKeys+0xdc>
		{
			bResetTCNR1_X = false;
    2800:	10 92 65 06 	sts	0x0665, r1
			if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_SHORT_TIME )
    2804:	80 91 6a 06 	lds	r24, 0x066A
    2808:	90 91 6b 06 	lds	r25, 0x066B
    280c:	20 91 e6 05 	lds	r18, 0x05E6
    2810:	30 91 e7 05 	lds	r19, 0x05E7
    2814:	82 1b       	sub	r24, r18
    2816:	93 0b       	sbc	r25, r19
    2818:	81 35       	cpi	r24, 0x51	; 81
    281a:	91 05       	cpc	r25, r1
    281c:	30 f1       	brcs	.+76     	; 0x286a <HandleSticksAsKeys+0x118>
			{
				_TXKeys = KEY_4;
    281e:	80 e1       	ldi	r24, 0x10	; 16
    2820:	80 93 d6 06 	sts	0x06D6, r24
				TCNT1_X_snapshot1 =0; // reset timer
    2824:	10 92 e7 05 	sts	0x05E7, r1
    2828:	10 92 e6 05 	sts	0x05E6, r1
    282c:	08 95       	ret
			}		
		
		}
		else if ((RX_Latest[RX_MAIN][RXChannel_AIL]) < STICK_RIGHT) 
    282e:	80 91 0c 06 	lds	r24, 0x060C
    2832:	90 91 0d 06 	lds	r25, 0x060D
    2836:	2e ef       	ldi	r18, 0xFE	; 254
    2838:	80 37       	cpi	r24, 0x70	; 112
    283a:	92 07       	cpc	r25, r18
    283c:	b4 f4       	brge	.+44     	; 0x286a <HandleSticksAsKeys+0x118>
		{
			bResetTCNR1_X = false;
    283e:	10 92 65 06 	sts	0x0665, r1
			if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_SHORT_TIME )
    2842:	80 91 6a 06 	lds	r24, 0x066A
    2846:	90 91 6b 06 	lds	r25, 0x066B
    284a:	20 91 e6 05 	lds	r18, 0x05E6
    284e:	30 91 e7 05 	lds	r19, 0x05E7
    2852:	82 1b       	sub	r24, r18
    2854:	93 0b       	sbc	r25, r19
    2856:	81 35       	cpi	r24, 0x51	; 81
    2858:	91 05       	cpc	r25, r1
    285a:	38 f0       	brcs	.+14     	; 0x286a <HandleSticksAsKeys+0x118>
			{
				_TXKeys = KEY_1;
    285c:	80 e8       	ldi	r24, 0x80	; 128
    285e:	80 93 d6 06 	sts	0x06D6, r24
				TCNT1_X_snapshot1 =0; // reset timer
    2862:	10 92 e7 05 	sts	0x05E7, r1
    2866:	10 92 e6 05 	sts	0x05E6, r1
    286a:	08 95       	ret

0000286c <ZEROMotors>:
/*
// STOPS MOTORS IMMEDIATLY
*/
void ZEROMotors()
{
	MotorOut[0] = 0;
    286c:	10 92 97 05 	sts	0x0597, r1
    2870:	10 92 96 05 	sts	0x0596, r1
	MotorOut[1] = 0;
    2874:	10 92 99 05 	sts	0x0599, r1
    2878:	10 92 98 05 	sts	0x0598, r1
	MotorOut[2] = 0;
    287c:	10 92 9b 05 	sts	0x059B, r1
    2880:	10 92 9a 05 	sts	0x059A, r1
	if (Config.FrameType == FRAMETYPE_TRICOPTER)
    2884:	80 91 f0 06 	lds	r24, 0x06F0
    2888:	82 30       	cpi	r24, 0x02	; 2
    288a:	39 f4       	brne	.+14     	; 0x289a <ZEROMotors+0x2e>
	{
		MotorOut[3] = SERVO_IN_MIDDLE;
    288c:	86 e2       	ldi	r24, 0x26	; 38
    288e:	92 e0       	ldi	r25, 0x02	; 2
    2890:	90 93 9d 05 	sts	0x059D, r25
    2894:	80 93 9c 05 	sts	0x059C, r24
    2898:	04 c0       	rjmp	.+8      	; 0x28a2 <ZEROMotors+0x36>
	}	
	else
	{
		MotorOut[3] = 0;
    289a:	10 92 9d 05 	sts	0x059D, r1
    289e:	10 92 9c 05 	sts	0x059C, r1
	}		
		
	Motor_GenerateOutputSignal();
    28a2:	0e 94 1e 24 	call	0x483c	; 0x483c <Motor_GenerateOutputSignal>
    28a6:	08 95       	ret

000028a8 <MainLoop>:
	This is the main loop of the application.
*/

static uint16_t LowpassOutYaw;
void MainLoop(void)
{
    28a8:	8f 92       	push	r8
    28aa:	9f 92       	push	r9
    28ac:	af 92       	push	r10
    28ae:	bf 92       	push	r11
    28b0:	cf 92       	push	r12
    28b2:	df 92       	push	r13
    28b4:	ef 92       	push	r14
    28b6:	ff 92       	push	r15
    28b8:	0f 93       	push	r16
    28ba:	1f 93       	push	r17
    28bc:	cf 93       	push	r28
    28be:	df 93       	push	r29
	
	RX_CopyLatestReceiverValues();
    28c0:	0e 94 cc 26 	call	0x4d98	; 0x4d98 <RX_CopyLatestReceiverValues>
	//RX_Snapshot_1 [RXChannel_THR]= RX_Snapshot[RXChannel_THR];
	RX_Snapshot   [RXChannel_THR]= RX_Latest[ActiveRXIndex][RXChannel_THR];
    28c4:	20 91 ca 05 	lds	r18, 0x05CA
    28c8:	82 2f       	mov	r24, r18
    28ca:	90 e0       	ldi	r25, 0x00	; 0
    28cc:	fc 01       	movw	r30, r24
    28ce:	ee 0f       	add	r30, r30
    28d0:	ff 1f       	adc	r31, r31
    28d2:	23 e0       	ldi	r18, 0x03	; 3
    28d4:	88 0f       	add	r24, r24
    28d6:	99 1f       	adc	r25, r25
    28d8:	2a 95       	dec	r18
    28da:	e1 f7       	brne	.-8      	; 0x28d4 <MainLoop+0x2c>
    28dc:	e8 0f       	add	r30, r24
    28de:	f9 1f       	adc	r31, r25
    28e0:	ee 5f       	subi	r30, 0xFE	; 254
    28e2:	f9 4f       	sbci	r31, 0xF9	; 249
    28e4:	86 81       	ldd	r24, Z+6	; 0x06
    28e6:	97 81       	ldd	r25, Z+7	; 0x07
    28e8:	90 93 c5 05 	sts	0x05C5, r25
    28ec:	80 93 c4 05 	sts	0x05C4, r24
	Sensors_ReadAll();	
    28f0:	0e 94 16 29 	call	0x522c	; 0x522c <Sensors_ReadAll>
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    28f4:	f8 94       	cli
	
	
	
	ATOMIC_BLOCK(ATOMIC_FORCEON)
    {
      CurrentTCNT1_X = TCNT1_X;
    28f6:	80 91 70 06 	lds	r24, 0x0670
    28fa:	90 91 71 06 	lds	r25, 0x0671
    28fe:	90 93 6b 06 	sts	0x066B, r25
    2902:	80 93 6a 06 	sts	0x066A, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    2906:	78 94       	sei
    }

	IMU();
    2908:	0e 94 c3 1c 	call	0x3986	; 0x3986 <IMU>
 
	bResetTCNR1_X = true;
    290c:	21 e0       	ldi	r18, 0x01	; 1
    290e:	20 93 65 06 	sts	0x0665, r18
	
	
	if (Config.RX_mode==RX_mode_BuddyMode)
    2912:	80 91 eb 06 	lds	r24, 0x06EB
    2916:	88 23       	and	r24, r24
    2918:	89 f4       	brne	.+34     	; 0x293c <MainLoop+0x94>
	{   // in Buddy mode AUX channel is used for instance switching.
		if (IS_TX2_GOOD)
    291a:	80 91 fb 07 	lds	r24, 0x07FB
    291e:	80 7f       	andi	r24, 0xF0	; 240
    2920:	69 f4       	brne	.+26     	; 0x293c <MainLoop+0x94>
		{
			if (RX_Latest[RX_MAIN][RXChannel_AUX] < STICK_RIGHT)
    2922:	80 91 14 06 	lds	r24, 0x0614
    2926:	90 91 15 06 	lds	r25, 0x0615
    292a:	3e ef       	ldi	r19, 0xFE	; 254
    292c:	80 37       	cpi	r24, 0x70	; 112
    292e:	93 07       	cpc	r25, r19
    2930:	1c f4       	brge	.+6      	; 0x2938 <MainLoop+0x90>
			{
				ActiveRXIndex = 0;		// use Primary RX
    2932:	10 92 ca 05 	sts	0x05CA, r1
    2936:	02 c0       	rjmp	.+4      	; 0x293c <MainLoop+0x94>
			}
			else
			{
				ActiveRXIndex = 1;		// use Secondary RX
    2938:	20 93 ca 05 	sts	0x05CA, r18
	
		
	////////// Slow Actions inside
	// HINT: you can try to skip this if flying to save time for more useful tasks as user cannot access menu when flying
	
	if (TCNT_X_snapshot2==0) TCNT_X_snapshot2 = CurrentTCNT1_X;
    293c:	80 91 e8 05 	lds	r24, 0x05E8
    2940:	90 91 e9 05 	lds	r25, 0x05E9
    2944:	20 91 6a 06 	lds	r18, 0x066A
    2948:	30 91 6b 06 	lds	r19, 0x066B
    294c:	00 97       	sbiw	r24, 0x00	; 0
    294e:	29 f4       	brne	.+10     	; 0x295a <MainLoop+0xb2>
    2950:	30 93 e9 05 	sts	0x05E9, r19
    2954:	20 93 e8 05 	sts	0x05E8, r18
    2958:	79 c0       	rjmp	.+242    	; 0x2a4c <MainLoop+0x1a4>
	else if ( ((CurrentTCNT1_X- TCNT_X_snapshot2) > 4) )  // TCNT1_X ticks in 32.768us
    295a:	28 1b       	sub	r18, r24
    295c:	39 0b       	sbc	r19, r25
    295e:	25 30       	cpi	r18, 0x05	; 5
    2960:	31 05       	cpc	r19, r1
    2962:	08 f4       	brcc	.+2      	; 0x2966 <MainLoop+0xbe>
    2964:	73 c0       	rjmp	.+230    	; 0x2a4c <MainLoop+0x1a4>
	{
		Menu_MenuShow();
    2966:	0e 94 3b 37 	call	0x6e76	; 0x6e76 <Menu_MenuShow>
		
		if (Config.VoltageAlarm > 0)
    296a:	60 91 59 07 	lds	r22, 0x0759
    296e:	66 23       	and	r22, r22
    2970:	f1 f0       	breq	.+60     	; 0x29ae <MainLoop+0x106>
		{
			//Sensor_GetBattery();
			if (Sensors_Latest[V_BAT_Index] < Config.VoltageAlarm)
    2972:	e0 90 53 06 	lds	r14, 0x0653
    2976:	f0 90 54 06 	lds	r15, 0x0654
    297a:	00 91 55 06 	lds	r16, 0x0655
    297e:	10 91 56 06 	lds	r17, 0x0656
    2982:	70 e0       	ldi	r23, 0x00	; 0
    2984:	88 27       	eor	r24, r24
    2986:	77 fd       	sbrc	r23, 7
    2988:	80 95       	com	r24
    298a:	98 2f       	mov	r25, r24
    298c:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    2990:	9b 01       	movw	r18, r22
    2992:	ac 01       	movw	r20, r24
    2994:	c8 01       	movw	r24, r16
    2996:	b7 01       	movw	r22, r14
    2998:	0e 94 f6 37 	call	0x6fec	; 0x6fec <__cmpsf2>
    299c:	90 91 d7 06 	lds	r25, 0x06D7
    29a0:	87 ff       	sbrs	r24, 7
    29a2:	02 c0       	rjmp	.+4      	; 0x29a8 <MainLoop+0x100>
			{
				
				SystemErrorType = SET_SYS_ERR_VOLTAGE;
    29a4:	92 60       	ori	r25, 0x02	; 2
    29a6:	01 c0       	rjmp	.+2      	; 0x29aa <MainLoop+0x102>
			}
			else
			{
				SystemErrorType = CLR_SYS_ERR_VOLTAGE;
    29a8:	9d 7f       	andi	r25, 0xFD	; 253
    29aa:	90 93 d7 06 	sts	0x06D7, r25
				
			}
		}	
		if (SystemErrorType != SYS_ERR_NON)
    29ae:	80 91 d7 06 	lds	r24, 0x06D7
    29b2:	88 23       	and	r24, r24
    29b4:	51 f0       	breq	.+20     	; 0x29ca <MainLoop+0x122>
		{
			Buzzer =~Buzzer ;	
    29b6:	85 b1       	in	r24, 0x05	; 5
    29b8:	86 95       	lsr	r24
    29ba:	80 95       	com	r24
    29bc:	81 70       	andi	r24, 0x01	; 1
    29be:	88 0f       	add	r24, r24
    29c0:	95 b1       	in	r25, 0x05	; 5
    29c2:	9d 7f       	andi	r25, 0xFD	; 253
    29c4:	98 2b       	or	r25, r24
    29c6:	95 b9       	out	0x05, r25	; 5
    29c8:	01 c0       	rjmp	.+2      	; 0x29cc <MainLoop+0x124>
		}
		else
		{
			Buzzer = OFF;
    29ca:	29 98       	cbi	0x05, 1	; 5
		}
		
		if (Config.RX_mode==RX_mode_UARTMode)
    29cc:	80 91 eb 06 	lds	r24, 0x06EB
    29d0:	8f 3f       	cpi	r24, 0xFF	; 255
    29d2:	c1 f5       	brne	.+112    	; 0x2a44 <MainLoop+0x19c>
		{
				if ((FlyingModesToggle != LOW) && ( RX_Latest[RX_MAIN][RXChannel_AUX] < STICK_RIGHT ))
    29d4:	20 91 2f 05 	lds	r18, 0x052F
    29d8:	22 23       	and	r18, r18
    29da:	81 f0       	breq	.+32     	; 0x29fc <MainLoop+0x154>
    29dc:	80 91 14 06 	lds	r24, 0x0614
    29e0:	90 91 15 06 	lds	r25, 0x0615
    29e4:	4e ef       	ldi	r20, 0xFE	; 254
    29e6:	80 37       	cpi	r24, 0x70	; 112
    29e8:	94 07       	cpc	r25, r20
    29ea:	34 f4       	brge	.+12     	; 0x29f8 <MainLoop+0x150>
				{
					nFlyingModes = FLYINGMODE_ALTHOLD;
    29ec:	84 e0       	ldi	r24, 0x04	; 4
    29ee:	80 93 1a 06 	sts	0x061A, r24
					FlyingModesToggle = LOW;
    29f2:	10 92 2f 05 	sts	0x052F, r1
    29f6:	26 c0       	rjmp	.+76     	; 0x2a44 <MainLoop+0x19c>
				} else
				if ((FlyingModesToggle != HIGH) && (RX_Latest[RX_MAIN][RXChannel_AUX] > STICK_LEFT ))
    29f8:	21 30       	cpi	r18, 0x01	; 1
    29fa:	71 f0       	breq	.+28     	; 0x2a18 <MainLoop+0x170>
    29fc:	80 91 14 06 	lds	r24, 0x0614
    2a00:	90 91 15 06 	lds	r25, 0x0615
    2a04:	51 e0       	ldi	r21, 0x01	; 1
    2a06:	81 39       	cpi	r24, 0x91	; 145
    2a08:	95 07       	cpc	r25, r21
    2a0a:	24 f0       	brlt	.+8      	; 0x2a14 <MainLoop+0x16c>
				{
					//LED_Orange=ON;
					nFlyingModes = FLYINGMODE_ACRO;
    2a0c:	81 e0       	ldi	r24, 0x01	; 1
    2a0e:	80 93 1a 06 	sts	0x061A, r24
    2a12:	16 c0       	rjmp	.+44     	; 0x2a40 <MainLoop+0x198>
					FlyingModesToggle = HIGH;
				} else
				if ((FlyingModesToggle != MID) && (RX_Latest[RX_MAIN][RXChannel_AUX]< STICK_LEFT) && ( RX_Latest[RX_MAIN][RXChannel_AUX] > STICK_RIGHT ))
    2a14:	2b 30       	cpi	r18, 0x0B	; 11
    2a16:	b1 f0       	breq	.+44     	; 0x2a44 <MainLoop+0x19c>
    2a18:	80 91 14 06 	lds	r24, 0x0614
    2a1c:	90 91 15 06 	lds	r25, 0x0615
    2a20:	21 e0       	ldi	r18, 0x01	; 1
    2a22:	80 39       	cpi	r24, 0x90	; 144
    2a24:	92 07       	cpc	r25, r18
    2a26:	74 f4       	brge	.+28     	; 0x2a44 <MainLoop+0x19c>
    2a28:	80 91 14 06 	lds	r24, 0x0614
    2a2c:	90 91 15 06 	lds	r25, 0x0615
    2a30:	3e ef       	ldi	r19, 0xFE	; 254
    2a32:	81 37       	cpi	r24, 0x71	; 113
    2a34:	93 07       	cpc	r25, r19
    2a36:	34 f0       	brlt	.+12     	; 0x2a44 <MainLoop+0x19c>
				{
					nFlyingModes = FLYINGMODE_LEVEL;
    2a38:	82 e0       	ldi	r24, 0x02	; 2
    2a3a:	80 93 1a 06 	sts	0x061A, r24
					FlyingModesToggle = MID;
    2a3e:	8b e0       	ldi	r24, 0x0B	; 11
    2a40:	80 93 2f 05 	sts	0x052F, r24
		}		
		//if ((IsArmed == true) && (RX_Snapshot[RXChannel_THR] < STICKThrottle_ARMING+160))
		//{ // calibrate when start flying
			//DynamicCalibration();
		//}			
		TCNT_X_snapshot2=0;
    2a44:	10 92 e9 05 	sts	0x05E9, r1
    2a48:	10 92 e8 05 	sts	0x05E8, r1
	}		
	
	//////////////// EOF Slow Loop
	
	if (RX_Snapshot[RXChannel_THR] < STICKThrottle_ARMING) 
    2a4c:	c0 91 c4 05 	lds	r28, 0x05C4
    2a50:	d0 91 c5 05 	lds	r29, 0x05C5
    2a54:	c2 33       	cpi	r28, 0x32	; 50
    2a56:	d1 05       	cpc	r29, r1
    2a58:	2c f4       	brge	.+10     	; 0x2a64 <MainLoop+0x1bc>
	{	
		
		// Throttle is LOW
		// Here you can add code without caring about delays. As there quad is already off and on land.
		// here we test different positions of sticks to enable arm/disarm, Quad/X-Quad
		HandleSticksForArming();
    2a5a:	0e 94 37 12 	call	0x246e	; 0x246e <HandleSticksForArming>
		
		// Stop motors if Throttle Stick is less than minimum.
		ZEROMotors();
    2a5e:	0e 94 36 14 	call	0x286c	; 0x286c <ZEROMotors>
    2a62:	6b c3       	rjmp	.+1750   	; 0x313a <MainLoop+0x892>
		// DEBUG ONLY //IMU_Reset(); // reset angles for gyro [STABLE MODE]
	}
	else
	{	// Throttle stick is NOT Down .... TAKE CARE
		
		if (IsArmed==false)
    2a64:	80 91 c8 07 	lds	r24, 0x07C8
    2a68:	88 23       	and	r24, r24
    2a6a:	29 f4       	brne	.+10     	; 0x2a76 <MainLoop+0x1ce>
		{  // However we are still DisArmed
			ZEROMotors();
    2a6c:	0e 94 36 14 	call	0x286c	; 0x286c <ZEROMotors>
			
			// Sticks as Keyboard --- we are already disarmed to reach here.
			HandleSticksAsKeys();
    2a70:	0e 94 a9 13 	call	0x2752	; 0x2752 <HandleSticksAsKeys>
    2a74:	62 c3       	rjmp	.+1732   	; 0x313a <MainLoop+0x892>
		}
		else
		{	// MOTORS ARE ON HERE .... DANGEROUS
			
			
			TCNT_X_snapshotAutoDisarm = 0; // ZERO [user may disarm then fly slowly..in this case the qud will disarm once he turned off the stick...because the counter counts once the quad is armed..e.g. if it takes n sec to disarm automatically..user took n-1 sec keeping the stick low after arming then it will take 1 sec to disarm again after lowing the stick under STICKThrottle_ARMING
    2a76:	10 92 1c 06 	sts	0x061C, r1
    2a7a:	10 92 1b 06 	sts	0x061B, r1
			
			// Armed & Throttle Stick > MIN . . . We should Fly now.
			//RX_Snapshot_1 [RXChannel_AIL]= RX_Snapshot[RXChannel_AIL];
			//RX_Snapshot_1 [RXChannel_ELE]= RX_Snapshot[RXChannel_ELE];
			//RX_Snapshot_1 [RXChannel_RUD]= RX_Snapshot[RXChannel_RUD];
			RX_Snapshot	  [RXChannel_AIL] = (RX_Latest[ActiveRXIndex][RXChannel_AIL] * Config.StickScaling * 0.05 );
    2a7e:	20 91 ca 05 	lds	r18, 0x05CA
    2a82:	82 2f       	mov	r24, r18
    2a84:	90 e0       	ldi	r25, 0x00	; 0
    2a86:	fc 01       	movw	r30, r24
    2a88:	ee 0f       	add	r30, r30
    2a8a:	ff 1f       	adc	r31, r31
    2a8c:	13 e0       	ldi	r17, 0x03	; 3
    2a8e:	88 0f       	add	r24, r24
    2a90:	99 1f       	adc	r25, r25
    2a92:	1a 95       	dec	r17
    2a94:	e1 f7       	brne	.-8      	; 0x2a8e <MainLoop+0x1e6>
    2a96:	e8 0f       	add	r30, r24
    2a98:	f9 1f       	adc	r31, r25
    2a9a:	ee 5f       	subi	r30, 0xFE	; 254
    2a9c:	f9 4f       	sbci	r31, 0xF9	; 249
    2a9e:	80 81       	ld	r24, Z
    2aa0:	91 81       	ldd	r25, Z+1	; 0x01
    2aa2:	e0 90 f5 06 	lds	r14, 0x06F5
    2aa6:	ff 24       	eor	r15, r15
    2aa8:	e8 9e       	mul	r14, r24
    2aaa:	b0 01       	movw	r22, r0
    2aac:	e9 9e       	mul	r14, r25
    2aae:	70 0d       	add	r23, r0
    2ab0:	f8 9e       	mul	r15, r24
    2ab2:	70 0d       	add	r23, r0
    2ab4:	11 24       	eor	r1, r1
    2ab6:	88 27       	eor	r24, r24
    2ab8:	77 fd       	sbrc	r23, 7
    2aba:	80 95       	com	r24
    2abc:	98 2f       	mov	r25, r24
    2abe:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    2ac2:	2d ec       	ldi	r18, 0xCD	; 205
    2ac4:	3c ec       	ldi	r19, 0xCC	; 204
    2ac6:	4c e4       	ldi	r20, 0x4C	; 76
    2ac8:	5d e3       	ldi	r21, 0x3D	; 61
    2aca:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    2ace:	0e 94 62 38 	call	0x70c4	; 0x70c4 <__fixsfsi>
    2ad2:	70 93 bf 05 	sts	0x05BF, r23
    2ad6:	60 93 be 05 	sts	0x05BE, r22
			RX_Snapshot   [RXChannel_ELE] = (RX_Latest[ActiveRXIndex][RXChannel_ELE] * Config.StickScaling * 0.05 ); 
    2ada:	20 91 ca 05 	lds	r18, 0x05CA
    2ade:	82 2f       	mov	r24, r18
    2ae0:	90 e0       	ldi	r25, 0x00	; 0
    2ae2:	fc 01       	movw	r30, r24
    2ae4:	ee 0f       	add	r30, r30
    2ae6:	ff 1f       	adc	r31, r31
    2ae8:	a3 e0       	ldi	r26, 0x03	; 3
    2aea:	88 0f       	add	r24, r24
    2aec:	99 1f       	adc	r25, r25
    2aee:	aa 95       	dec	r26
    2af0:	e1 f7       	brne	.-8      	; 0x2aea <MainLoop+0x242>
    2af2:	e8 0f       	add	r30, r24
    2af4:	f9 1f       	adc	r31, r25
    2af6:	ee 5f       	subi	r30, 0xFE	; 254
    2af8:	f9 4f       	sbci	r31, 0xF9	; 249
    2afa:	82 81       	ldd	r24, Z+2	; 0x02
    2afc:	93 81       	ldd	r25, Z+3	; 0x03
    2afe:	e8 9e       	mul	r14, r24
    2b00:	b0 01       	movw	r22, r0
    2b02:	e9 9e       	mul	r14, r25
    2b04:	70 0d       	add	r23, r0
    2b06:	f8 9e       	mul	r15, r24
    2b08:	70 0d       	add	r23, r0
    2b0a:	11 24       	eor	r1, r1
    2b0c:	88 27       	eor	r24, r24
    2b0e:	77 fd       	sbrc	r23, 7
    2b10:	80 95       	com	r24
    2b12:	98 2f       	mov	r25, r24
    2b14:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    2b18:	2d ec       	ldi	r18, 0xCD	; 205
    2b1a:	3c ec       	ldi	r19, 0xCC	; 204
    2b1c:	4c e4       	ldi	r20, 0x4C	; 76
    2b1e:	5d e3       	ldi	r21, 0x3D	; 61
    2b20:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    2b24:	0e 94 62 38 	call	0x70c4	; 0x70c4 <__fixsfsi>
    2b28:	70 93 c1 05 	sts	0x05C1, r23
    2b2c:	60 93 c0 05 	sts	0x05C0, r22
			RX_Snapshot   [RXChannel_RUD] = (RX_Latest[ActiveRXIndex][RXChannel_RUD] * Config.StickScaling * 0.05 ); // version 0.9.9 
    2b30:	20 91 ca 05 	lds	r18, 0x05CA
    2b34:	82 2f       	mov	r24, r18
    2b36:	90 e0       	ldi	r25, 0x00	; 0
    2b38:	fc 01       	movw	r30, r24
    2b3a:	ee 0f       	add	r30, r30
    2b3c:	ff 1f       	adc	r31, r31
    2b3e:	63 e0       	ldi	r22, 0x03	; 3
    2b40:	88 0f       	add	r24, r24
    2b42:	99 1f       	adc	r25, r25
    2b44:	6a 95       	dec	r22
    2b46:	e1 f7       	brne	.-8      	; 0x2b40 <MainLoop+0x298>
    2b48:	e8 0f       	add	r30, r24
    2b4a:	f9 1f       	adc	r31, r25
    2b4c:	ee 5f       	subi	r30, 0xFE	; 254
    2b4e:	f9 4f       	sbci	r31, 0xF9	; 249
    2b50:	84 81       	ldd	r24, Z+4	; 0x04
    2b52:	95 81       	ldd	r25, Z+5	; 0x05
    2b54:	e8 9e       	mul	r14, r24
    2b56:	b0 01       	movw	r22, r0
    2b58:	e9 9e       	mul	r14, r25
    2b5a:	70 0d       	add	r23, r0
    2b5c:	f8 9e       	mul	r15, r24
    2b5e:	70 0d       	add	r23, r0
    2b60:	11 24       	eor	r1, r1
    2b62:	88 27       	eor	r24, r24
    2b64:	77 fd       	sbrc	r23, 7
    2b66:	80 95       	com	r24
    2b68:	98 2f       	mov	r25, r24
    2b6a:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    2b6e:	2d ec       	ldi	r18, 0xCD	; 205
    2b70:	3c ec       	ldi	r19, 0xCC	; 204
    2b72:	4c e4       	ldi	r20, 0x4C	; 76
    2b74:	5d e3       	ldi	r21, 0x3D	; 61
    2b76:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    2b7a:	0e 94 62 38 	call	0x70c4	; 0x70c4 <__fixsfsi>
    2b7e:	70 93 c3 05 	sts	0x05C3, r23
    2b82:	60 93 c2 05 	sts	0x05C2, r22
		
			
			// Add Throttle to Motors
			MotorOut[0] = RX_Snapshot[RXChannel_THR];
			MotorOut[1] = RX_Snapshot[RXChannel_THR];
			if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    2b86:	80 91 f0 06 	lds	r24, 0x06F0
    2b8a:	81 30       	cpi	r24, 0x01	; 1
    2b8c:	71 f4       	brne	.+28     	; 0x2baa <MainLoop+0x302>
				* The logic below depends on board orientation i.e. sensor orientation compared to motor directions.
				* the IMU in ACHRO mode is totally independent from user sticks ... so it does not matter how the user
				* flies his quad i.e. in X or PLUS .... it does not matter because it is handled in another code lines not here.
				* here we handle board orientation only.
				*/
				if (Config.BoardOrientationMode==QuadFlyingMode_X)
    2b8e:	40 91 f1 06 	lds	r20, 0x06F1
    2b92:	80 91 35 06 	lds	r24, 0x0635
    2b96:	90 91 36 06 	lds	r25, 0x0636
    2b9a:	20 91 b6 05 	lds	r18, 0x05B6
    2b9e:	30 91 b7 05 	lds	r19, 0x05B7
    2ba2:	41 30       	cpi	r20, 0x01	; 1
    2ba4:	09 f0       	breq	.+2      	; 0x2ba8 <MainLoop+0x300>
    2ba6:	57 c0       	rjmp	.+174    	; 0x2c56 <MainLoop+0x3ae>
    2ba8:	34 c0       	rjmp	.+104    	; 0x2c12 <MainLoop+0x36a>
			}
			else
			{	// Balance Tri-Copter
				// NOT VALID if Board Orientation is X
					
				MotorOut[2] += gyroPitch; // * 1.0;
    2baa:	60 91 35 06 	lds	r22, 0x0635
    2bae:	70 91 36 06 	lds	r23, 0x0636
    2bb2:	cb 01       	movw	r24, r22
    2bb4:	8c 0f       	add	r24, r28
    2bb6:	9d 1f       	adc	r25, r29
    2bb8:	90 93 9b 05 	sts	0x059B, r25
    2bbc:	80 93 9a 05 	sts	0x059A, r24
					
				gyroPitch    = gyroPitch * 0.5; // distribute pitch on two front motors .... half the effect. 
    2bc0:	88 27       	eor	r24, r24
    2bc2:	77 fd       	sbrc	r23, 7
    2bc4:	80 95       	com	r24
    2bc6:	98 2f       	mov	r25, r24
    2bc8:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    2bcc:	20 e0       	ldi	r18, 0x00	; 0
    2bce:	30 e0       	ldi	r19, 0x00	; 0
    2bd0:	40 e0       	ldi	r20, 0x00	; 0
    2bd2:	5f e3       	ldi	r21, 0x3F	; 63
    2bd4:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    2bd8:	0e 94 62 38 	call	0x70c4	; 0x70c4 <__fixsfsi>
    2bdc:	9b 01       	movw	r18, r22
    2bde:	70 93 36 06 	sts	0x0636, r23
    2be2:	60 93 35 06 	sts	0x0635, r22
				MotorOut[0] -= gyroPitch  ;
				MotorOut[1] -= gyroPitch  ;
					
				gyroRoll = gyroRoll; // * 0.85;
    2be6:	40 91 b6 05 	lds	r20, 0x05B6
    2bea:	50 91 b7 05 	lds	r21, 0x05B7
				// NOT VALID if Board Orientation is X
					
				MotorOut[2] += gyroPitch; // * 1.0;
					
				gyroPitch    = gyroPitch * 0.5; // distribute pitch on two front motors .... half the effect. 
				MotorOut[0] -= gyroPitch  ;
    2bee:	ce 01       	movw	r24, r28
    2bf0:	82 1b       	sub	r24, r18
    2bf2:	93 0b       	sbc	r25, r19
				MotorOut[1] -= gyroPitch  ;
					
				gyroRoll = gyroRoll; // * 0.85;
				MotorOut[0] -= gyroRoll  ;
    2bf4:	84 1b       	sub	r24, r20
    2bf6:	95 0b       	sbc	r25, r21
    2bf8:	90 93 97 05 	sts	0x0597, r25
    2bfc:	80 93 96 05 	sts	0x0596, r24
					
				MotorOut[2] += gyroPitch; // * 1.0;
					
				gyroPitch    = gyroPitch * 0.5; // distribute pitch on two front motors .... half the effect. 
				MotorOut[0] -= gyroPitch  ;
				MotorOut[1] -= gyroPitch  ;
    2c00:	c4 0f       	add	r28, r20
    2c02:	d5 1f       	adc	r29, r21
					
				gyroRoll = gyroRoll; // * 0.85;
				MotorOut[0] -= gyroRoll  ;
				MotorOut[1] += gyroRoll  ;
    2c04:	c2 1b       	sub	r28, r18
    2c06:	d3 0b       	sbc	r29, r19
    2c08:	d0 93 99 05 	sts	0x0599, r29
    2c0c:	c0 93 98 05 	sts	0x0598, r28
    2c10:	3d c0       	rjmp	.+122    	; 0x2c8c <MainLoop+0x3e4>
				if (Config.BoardOrientationMode==QuadFlyingMode_X)
				{	// Board Orientation in X-Mode
					// {-1,1,1,-1} QUAD_ROL_X
					MotorOut[0] -= gyroRoll ;
					MotorOut[3] -= gyroRoll ;
					MotorOut[1] += gyroRoll ;
    2c12:	b9 01       	movw	r22, r18
    2c14:	6c 0f       	add	r22, r28
    2c16:	7d 1f       	adc	r23, r29
				* here we handle board orientation only.
				*/
				if (Config.BoardOrientationMode==QuadFlyingMode_X)
				{	// Board Orientation in X-Mode
					// {-1,1,1,-1} QUAD_ROL_X
					MotorOut[0] -= gyroRoll ;
    2c18:	ae 01       	movw	r20, r28
    2c1a:	42 1b       	sub	r20, r18
    2c1c:	53 0b       	sbc	r21, r19
					MotorOut[3] -= gyroRoll ;
					MotorOut[1] += gyroRoll ;
					MotorOut[2] += gyroRoll ;
					
					// {-1,-1,1,1} QUAD_AIL_X
					MotorOut[0] -= gyroPitch;
    2c1e:	48 1b       	sub	r20, r24
    2c20:	59 0b       	sbc	r21, r25
    2c22:	50 93 97 05 	sts	0x0597, r21
    2c26:	40 93 96 05 	sts	0x0596, r20
					MotorOut[1] -= gyroPitch;
    2c2a:	ab 01       	movw	r20, r22
    2c2c:	48 1b       	sub	r20, r24
    2c2e:	59 0b       	sbc	r21, r25
    2c30:	50 93 99 05 	sts	0x0599, r21
    2c34:	40 93 98 05 	sts	0x0598, r20
					MotorOut[2] += gyroPitch;
    2c38:	68 0f       	add	r22, r24
    2c3a:	79 1f       	adc	r23, r25
    2c3c:	70 93 9b 05 	sts	0x059B, r23
    2c40:	60 93 9a 05 	sts	0x059A, r22
				*/
				if (Config.BoardOrientationMode==QuadFlyingMode_X)
				{	// Board Orientation in X-Mode
					// {-1,1,1,-1} QUAD_ROL_X
					MotorOut[0] -= gyroRoll ;
					MotorOut[3] -= gyroRoll ;
    2c44:	c8 0f       	add	r28, r24
    2c46:	d9 1f       	adc	r29, r25
					
					// {-1,-1,1,1} QUAD_AIL_X
					MotorOut[0] -= gyroPitch;
					MotorOut[1] -= gyroPitch;
					MotorOut[2] += gyroPitch;
					MotorOut[3] += gyroPitch;
    2c48:	c2 1b       	sub	r28, r18
    2c4a:	d3 0b       	sbc	r29, r19
    2c4c:	d0 93 9d 05 	sts	0x059D, r29
    2c50:	c0 93 9c 05 	sts	0x059C, r28
    2c54:	1b c0       	rjmp	.+54     	; 0x2c8c <MainLoop+0x3e4>
					
				}
				else
				{	// Board Orientation in Plus-Mode
					// {0,1,0,-1} QUAD_ROL_PLUS
					MotorOut[1] += gyroRoll  ;
    2c56:	a9 01       	movw	r20, r18
    2c58:	4c 0f       	add	r20, r28
    2c5a:	5d 1f       	adc	r21, r29
    2c5c:	50 93 99 05 	sts	0x0599, r21
    2c60:	40 93 98 05 	sts	0x0598, r20
					MotorOut[3] -= gyroRoll  ;
    2c64:	ae 01       	movw	r20, r28
    2c66:	42 1b       	sub	r20, r18
    2c68:	53 0b       	sbc	r21, r19
    2c6a:	50 93 9d 05 	sts	0x059D, r21
    2c6e:	40 93 9c 05 	sts	0x059C, r20
				
					// {-1,0,1,0} QUAD_AIL_PLUS
					MotorOut[0] -= gyroPitch ;
    2c72:	9e 01       	movw	r18, r28
    2c74:	28 1b       	sub	r18, r24
    2c76:	39 0b       	sbc	r19, r25
    2c78:	30 93 97 05 	sts	0x0597, r19
    2c7c:	20 93 96 05 	sts	0x0596, r18
					MotorOut[2] += gyroPitch ; 
    2c80:	c8 0f       	add	r28, r24
    2c82:	d9 1f       	adc	r29, r25
    2c84:	d0 93 9b 05 	sts	0x059B, r29
    2c88:	c0 93 9a 05 	sts	0x059A, r28
			*
			*	Pilot Control Logic.
			*	Handles signals from remote control in ACRO mode.
			*	in stabilization mode controls are added in IMU logic as angles.
			*/
			if (nFlyingModes == FLYINGMODE_ACRO)
    2c8c:	80 91 1a 06 	lds	r24, 0x061A
    2c90:	81 30       	cpi	r24, 0x01	; 1
    2c92:	09 f0       	breq	.+2      	; 0x2c96 <MainLoop+0x3ee>
    2c94:	2e c1       	rjmp	.+604    	; 0x2ef2 <MainLoop+0x64a>
			{
				if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    2c96:	90 91 f0 06 	lds	r25, 0x06F0
    2c9a:	80 91 f2 06 	lds	r24, 0x06F2
    2c9e:	91 30       	cpi	r25, 0x01	; 1
    2ca0:	09 f0       	breq	.+2      	; 0x2ca4 <MainLoop+0x3fc>
    2ca2:	a3 c0       	rjmp	.+326    	; 0x2dea <MainLoop+0x542>
    2ca4:	60 91 be 05 	lds	r22, 0x05BE
    2ca8:	70 91 bf 05 	lds	r23, 0x05BF
    2cac:	e0 90 c0 05 	lds	r14, 0x05C0
    2cb0:	f0 90 c1 05 	lds	r15, 0x05C1
    2cb4:	80 90 9c 05 	lds	r8, 0x059C
    2cb8:	90 90 9d 05 	lds	r9, 0x059D
    2cbc:	a0 90 98 05 	lds	r10, 0x0598
    2cc0:	b0 90 99 05 	lds	r11, 0x0599
    2cc4:	c0 90 9a 05 	lds	r12, 0x059A
    2cc8:	d0 90 9b 05 	lds	r13, 0x059B
    2ccc:	00 91 96 05 	lds	r16, 0x0596
    2cd0:	10 91 97 05 	lds	r17, 0x0597
				{
				
					if (Config.QuadFlyingMode==QuadFlyingMode_X)
    2cd4:	81 30       	cpi	r24, 0x01	; 1
    2cd6:	09 f0       	breq	.+2      	; 0x2cda <MainLoop+0x432>
    2cd8:	49 c0       	rjmp	.+146    	; 0x2d6c <MainLoop+0x4c4>
					{
						RX_Snapshot[RXChannel_AIL] = RX_Snapshot[RXChannel_AIL] * 0.63;		// because we fly X
    2cda:	88 27       	eor	r24, r24
    2cdc:	77 fd       	sbrc	r23, 7
    2cde:	80 95       	com	r24
    2ce0:	98 2f       	mov	r25, r24
    2ce2:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    2ce6:	2e ea       	ldi	r18, 0xAE	; 174
    2ce8:	37 e4       	ldi	r19, 0x47	; 71
    2cea:	41 e2       	ldi	r20, 0x21	; 33
    2cec:	5f e3       	ldi	r21, 0x3F	; 63
    2cee:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    2cf2:	0e 94 62 38 	call	0x70c4	; 0x70c4 <__fixsfsi>
    2cf6:	eb 01       	movw	r28, r22
    2cf8:	70 93 bf 05 	sts	0x05BF, r23
    2cfc:	60 93 be 05 	sts	0x05BE, r22
						RX_Snapshot[RXChannel_ELE] = RX_Snapshot[RXChannel_ELE] * 0.63;
    2d00:	b7 01       	movw	r22, r14
    2d02:	88 27       	eor	r24, r24
    2d04:	77 fd       	sbrc	r23, 7
    2d06:	80 95       	com	r24
    2d08:	98 2f       	mov	r25, r24
    2d0a:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    2d0e:	2e ea       	ldi	r18, 0xAE	; 174
    2d10:	37 e4       	ldi	r19, 0x47	; 71
    2d12:	41 e2       	ldi	r20, 0x21	; 33
    2d14:	5f e3       	ldi	r21, 0x3F	; 63
    2d16:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    2d1a:	0e 94 62 38 	call	0x70c4	; 0x70c4 <__fixsfsi>
    2d1e:	9b 01       	movw	r18, r22
    2d20:	70 93 c1 05 	sts	0x05C1, r23
    2d24:	60 93 c0 05 	sts	0x05C0, r22
					
						// {0.63,-0.63,-0.63,0.63} QUAD_AIL_X
						MotorOut[0] += RX_Snapshot[RXChannel_AIL] ;
						MotorOut[3] += RX_Snapshot[RXChannel_AIL] ;
    2d28:	8c 0e       	add	r8, r28
    2d2a:	9d 1e       	adc	r9, r29
						MotorOut[1] -= RX_Snapshot[RXChannel_AIL] ;
						MotorOut[2] -= RX_Snapshot[RXChannel_AIL] ;
    2d2c:	cc 1a       	sub	r12, r28
    2d2e:	dd 0a       	sbc	r13, r29
					{
						RX_Snapshot[RXChannel_AIL] = RX_Snapshot[RXChannel_AIL] * 0.63;		// because we fly X
						RX_Snapshot[RXChannel_ELE] = RX_Snapshot[RXChannel_ELE] * 0.63;
					
						// {0.63,-0.63,-0.63,0.63} QUAD_AIL_X
						MotorOut[0] += RX_Snapshot[RXChannel_AIL] ;
    2d30:	ce 01       	movw	r24, r28
    2d32:	82 0f       	add	r24, r18
    2d34:	93 1f       	adc	r25, r19
						MotorOut[3] += RX_Snapshot[RXChannel_AIL] ;
						MotorOut[1] -= RX_Snapshot[RXChannel_AIL] ;
						MotorOut[2] -= RX_Snapshot[RXChannel_AIL] ;
				
						// {0.63,0.63,-0.63,-0.63} QUAD_ELE_X
						MotorOut[0] += RX_Snapshot[RXChannel_ELE];
    2d36:	80 0f       	add	r24, r16
    2d38:	91 1f       	adc	r25, r17
    2d3a:	90 93 97 05 	sts	0x0597, r25
    2d3e:	80 93 96 05 	sts	0x0596, r24
						RX_Snapshot[RXChannel_ELE] = RX_Snapshot[RXChannel_ELE] * 0.63;
					
						// {0.63,-0.63,-0.63,0.63} QUAD_AIL_X
						MotorOut[0] += RX_Snapshot[RXChannel_AIL] ;
						MotorOut[3] += RX_Snapshot[RXChannel_AIL] ;
						MotorOut[1] -= RX_Snapshot[RXChannel_AIL] ;
    2d42:	a2 0e       	add	r10, r18
    2d44:	b3 1e       	adc	r11, r19
						MotorOut[2] -= RX_Snapshot[RXChannel_AIL] ;
				
						// {0.63,0.63,-0.63,-0.63} QUAD_ELE_X
						MotorOut[0] += RX_Snapshot[RXChannel_ELE];
						MotorOut[1] += RX_Snapshot[RXChannel_ELE];
    2d46:	ac 1a       	sub	r10, r28
    2d48:	bd 0a       	sbc	r11, r29
    2d4a:	b0 92 99 05 	sts	0x0599, r11
    2d4e:	a0 92 98 05 	sts	0x0598, r10
						MotorOut[2] -= RX_Snapshot[RXChannel_ELE];
    2d52:	c2 1a       	sub	r12, r18
    2d54:	d3 0a       	sbc	r13, r19
    2d56:	d0 92 9b 05 	sts	0x059B, r13
    2d5a:	c0 92 9a 05 	sts	0x059A, r12
						MotorOut[3] -= RX_Snapshot[RXChannel_ELE];
    2d5e:	82 1a       	sub	r8, r18
    2d60:	93 0a       	sbc	r9, r19
    2d62:	90 92 9d 05 	sts	0x059D, r9
    2d66:	80 92 9c 05 	sts	0x059C, r8
    2d6a:	2e c1       	rjmp	.+604    	; 0x2fc8 <MainLoop+0x720>
					
					}
					else
					{
				
						RX_Snapshot[RXChannel_AIL] = RX_Snapshot[RXChannel_AIL] * 0.9;		// 0.9: to reduce sensitivity more than STABLE mode
    2d6c:	88 27       	eor	r24, r24
    2d6e:	77 fd       	sbrc	r23, 7
    2d70:	80 95       	com	r24
    2d72:	98 2f       	mov	r25, r24
    2d74:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    2d78:	26 e6       	ldi	r18, 0x66	; 102
    2d7a:	36 e6       	ldi	r19, 0x66	; 102
    2d7c:	46 e6       	ldi	r20, 0x66	; 102
    2d7e:	5f e3       	ldi	r21, 0x3F	; 63
    2d80:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    2d84:	0e 94 62 38 	call	0x70c4	; 0x70c4 <__fixsfsi>
    2d88:	eb 01       	movw	r28, r22
    2d8a:	70 93 bf 05 	sts	0x05BF, r23
    2d8e:	60 93 be 05 	sts	0x05BE, r22
						RX_Snapshot[RXChannel_ELE] = RX_Snapshot[RXChannel_ELE] * 0.9;
    2d92:	b7 01       	movw	r22, r14
    2d94:	88 27       	eor	r24, r24
    2d96:	77 fd       	sbrc	r23, 7
    2d98:	80 95       	com	r24
    2d9a:	98 2f       	mov	r25, r24
    2d9c:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    2da0:	26 e6       	ldi	r18, 0x66	; 102
    2da2:	36 e6       	ldi	r19, 0x66	; 102
    2da4:	46 e6       	ldi	r20, 0x66	; 102
    2da6:	5f e3       	ldi	r21, 0x3F	; 63
    2da8:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    2dac:	0e 94 62 38 	call	0x70c4	; 0x70c4 <__fixsfsi>
    2db0:	70 93 c1 05 	sts	0x05C1, r23
    2db4:	60 93 c0 05 	sts	0x05C0, r22
						// {0.9,0,-0.9,0} QUAD_ELE_PLUS
						MotorOut[0] += RX_Snapshot[RXChannel_ELE] ; 
    2db8:	06 0f       	add	r16, r22
    2dba:	17 1f       	adc	r17, r23
    2dbc:	10 93 97 05 	sts	0x0597, r17
    2dc0:	00 93 96 05 	sts	0x0596, r16
						MotorOut[2] -= RX_Snapshot[RXChannel_ELE] ; 
    2dc4:	c6 1a       	sub	r12, r22
    2dc6:	d7 0a       	sbc	r13, r23
    2dc8:	d0 92 9b 05 	sts	0x059B, r13
    2dcc:	c0 92 9a 05 	sts	0x059A, r12
						// {0,-0.9,0,0.9} QUAD_AIL_PLUS	
						MotorOut[1] -= RX_Snapshot[RXChannel_AIL] ; 
    2dd0:	ac 1a       	sub	r10, r28
    2dd2:	bd 0a       	sbc	r11, r29
    2dd4:	b0 92 99 05 	sts	0x0599, r11
    2dd8:	a0 92 98 05 	sts	0x0598, r10
						MotorOut[3] += RX_Snapshot[RXChannel_AIL] ;  
    2ddc:	c8 0d       	add	r28, r8
    2dde:	d9 1d       	adc	r29, r9
    2de0:	d0 93 9d 05 	sts	0x059D, r29
    2de4:	c0 93 9c 05 	sts	0x059C, r28
    2de8:	ef c0       	rjmp	.+478    	; 0x2fc8 <MainLoop+0x720>
				}
				else
				{ // TRICopter
					
						int8_t inv=1; // Flying in Y mode
						if (Config.QuadFlyingMode==QuadFlyingMode_X)
    2dea:	81 30       	cpi	r24, 0x01	; 1
    2dec:	11 f0       	breq	.+4      	; 0x2df2 <MainLoop+0x54a>
					}
				}
				else
				{ // TRICopter
					
						int8_t inv=1; // Flying in Y mode
    2dee:	01 e0       	ldi	r16, 0x01	; 1
    2df0:	01 c0       	rjmp	.+2      	; 0x2df4 <MainLoop+0x54c>
						if (Config.QuadFlyingMode==QuadFlyingMode_X)
						{ // Flying in A mode
							inv = -1;
    2df2:	0f ef       	ldi	r16, 0xFF	; 255
						}							
							// {0.5,0.5,1.1,X} TRI_ELE_FRONT
							MotorOut[2] -= inv * (RX_Snapshot[RXChannel_ELE] * 1.1); 
    2df4:	c0 91 c0 05 	lds	r28, 0x05C0
    2df8:	d0 91 c1 05 	lds	r29, 0x05C1
    2dfc:	60 91 9a 05 	lds	r22, 0x059A
    2e00:	70 91 9b 05 	lds	r23, 0x059B
    2e04:	88 27       	eor	r24, r24
    2e06:	77 fd       	sbrc	r23, 7
    2e08:	80 95       	com	r24
    2e0a:	98 2f       	mov	r25, r24
    2e0c:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    2e10:	4b 01       	movw	r8, r22
    2e12:	5c 01       	movw	r10, r24
    2e14:	60 2f       	mov	r22, r16
    2e16:	77 27       	eor	r23, r23
    2e18:	67 fd       	sbrc	r22, 7
    2e1a:	70 95       	com	r23
    2e1c:	87 2f       	mov	r24, r23
    2e1e:	97 2f       	mov	r25, r23
    2e20:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    2e24:	6b 01       	movw	r12, r22
    2e26:	7c 01       	movw	r14, r24
    2e28:	be 01       	movw	r22, r28
    2e2a:	88 27       	eor	r24, r24
    2e2c:	77 fd       	sbrc	r23, 7
    2e2e:	80 95       	com	r24
    2e30:	98 2f       	mov	r25, r24
    2e32:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    2e36:	2d ec       	ldi	r18, 0xCD	; 205
    2e38:	3c ec       	ldi	r19, 0xCC	; 204
    2e3a:	4c e8       	ldi	r20, 0x8C	; 140
    2e3c:	5f e3       	ldi	r21, 0x3F	; 63
    2e3e:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    2e42:	9b 01       	movw	r18, r22
    2e44:	ac 01       	movw	r20, r24
    2e46:	c7 01       	movw	r24, r14
    2e48:	b6 01       	movw	r22, r12
    2e4a:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    2e4e:	9b 01       	movw	r18, r22
    2e50:	ac 01       	movw	r20, r24
    2e52:	c5 01       	movw	r24, r10
    2e54:	b4 01       	movw	r22, r8
    2e56:	0e 94 91 37 	call	0x6f22	; 0x6f22 <__subsf3>
    2e5a:	0e 94 62 38 	call	0x70c4	; 0x70c4 <__fixsfsi>
    2e5e:	70 93 9b 05 	sts	0x059B, r23
    2e62:	60 93 9a 05 	sts	0x059A, r22
							RX_Snapshot[RXChannel_ELE] = inv * RX_Snapshot[RXChannel_ELE] * 0.5;
    2e66:	e0 2e       	mov	r14, r16
    2e68:	ff 24       	eor	r15, r15
    2e6a:	e7 fc       	sbrc	r14, 7
    2e6c:	f0 94       	com	r15
    2e6e:	ec 9e       	mul	r14, r28
    2e70:	b0 01       	movw	r22, r0
    2e72:	ed 9e       	mul	r14, r29
    2e74:	70 0d       	add	r23, r0
    2e76:	fc 9e       	mul	r15, r28
    2e78:	70 0d       	add	r23, r0
    2e7a:	11 24       	eor	r1, r1
    2e7c:	88 27       	eor	r24, r24
    2e7e:	77 fd       	sbrc	r23, 7
    2e80:	80 95       	com	r24
    2e82:	98 2f       	mov	r25, r24
    2e84:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    2e88:	20 e0       	ldi	r18, 0x00	; 0
    2e8a:	30 e0       	ldi	r19, 0x00	; 0
    2e8c:	40 e0       	ldi	r20, 0x00	; 0
    2e8e:	5f e3       	ldi	r21, 0x3F	; 63
    2e90:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    2e94:	0e 94 62 38 	call	0x70c4	; 0x70c4 <__fixsfsi>
    2e98:	fb 01       	movw	r30, r22
    2e9a:	70 93 c1 05 	sts	0x05C1, r23
    2e9e:	60 93 c0 05 	sts	0x05C0, r22
							MotorOut[0] += RX_Snapshot[RXChannel_ELE] ; 
    2ea2:	20 91 96 05 	lds	r18, 0x0596
    2ea6:	30 91 97 05 	lds	r19, 0x0597
							MotorOut[1] += RX_Snapshot[RXChannel_ELE] ; 
    2eaa:	80 91 98 05 	lds	r24, 0x0598
    2eae:	90 91 99 05 	lds	r25, 0x0599
						
							// {1,-1,0,X} TRI_AIL_FRONT
							RX_Snapshot[RXChannel_AIL] = inv * RX_Snapshot[RXChannel_AIL];
    2eb2:	60 91 be 05 	lds	r22, 0x05BE
    2eb6:	70 91 bf 05 	lds	r23, 0x05BF
    2eba:	e6 9e       	mul	r14, r22
    2ebc:	a0 01       	movw	r20, r0
    2ebe:	e7 9e       	mul	r14, r23
    2ec0:	50 0d       	add	r21, r0
    2ec2:	f6 9e       	mul	r15, r22
    2ec4:	50 0d       	add	r21, r0
    2ec6:	11 24       	eor	r1, r1
    2ec8:	50 93 bf 05 	sts	0x05BF, r21
    2ecc:	40 93 be 05 	sts	0x05BE, r20
							inv = -1;
						}							
							// {0.5,0.5,1.1,X} TRI_ELE_FRONT
							MotorOut[2] -= inv * (RX_Snapshot[RXChannel_ELE] * 1.1); 
							RX_Snapshot[RXChannel_ELE] = inv * RX_Snapshot[RXChannel_ELE] * 0.5;
							MotorOut[0] += RX_Snapshot[RXChannel_ELE] ; 
    2ed0:	24 0f       	add	r18, r20
    2ed2:	35 1f       	adc	r19, r21
							MotorOut[1] += RX_Snapshot[RXChannel_ELE] ; 
						
							// {1,-1,0,X} TRI_AIL_FRONT
							RX_Snapshot[RXChannel_AIL] = inv * RX_Snapshot[RXChannel_AIL];
							MotorOut[0] += RX_Snapshot[RXChannel_AIL] ; 
    2ed4:	2e 0f       	add	r18, r30
    2ed6:	3f 1f       	adc	r19, r31
    2ed8:	30 93 97 05 	sts	0x0597, r19
    2edc:	20 93 96 05 	sts	0x0596, r18
						}							
							// {0.5,0.5,1.1,X} TRI_ELE_FRONT
							MotorOut[2] -= inv * (RX_Snapshot[RXChannel_ELE] * 1.1); 
							RX_Snapshot[RXChannel_ELE] = inv * RX_Snapshot[RXChannel_ELE] * 0.5;
							MotorOut[0] += RX_Snapshot[RXChannel_ELE] ; 
							MotorOut[1] += RX_Snapshot[RXChannel_ELE] ; 
    2ee0:	84 1b       	sub	r24, r20
    2ee2:	95 0b       	sbc	r25, r21
						
							// {1,-1,0,X} TRI_AIL_FRONT
							RX_Snapshot[RXChannel_AIL] = inv * RX_Snapshot[RXChannel_AIL];
							MotorOut[0] += RX_Snapshot[RXChannel_AIL] ; 
							MotorOut[1] -= RX_Snapshot[RXChannel_AIL] ;  
    2ee4:	8e 0f       	add	r24, r30
    2ee6:	9f 1f       	adc	r25, r31
    2ee8:	90 93 99 05 	sts	0x0599, r25
    2eec:	80 93 98 05 	sts	0x0598, r24
    2ef0:	6b c0       	rjmp	.+214    	; 0x2fc8 <MainLoop+0x720>
			{
				// in stabilization mode ... activate Acc-Z & Sonar if enabled.
				
				double Landing;
				
				Landing = IMU_HeightKeeping();
    2ef2:	0e 94 e5 20 	call	0x41ca	; 0x41ca <IMU_HeightKeeping>
    2ef6:	7b 01       	movw	r14, r22
    2ef8:	8c 01       	movw	r16, r24
				MotorOut[0] += Landing;
    2efa:	60 91 96 05 	lds	r22, 0x0596
    2efe:	70 91 97 05 	lds	r23, 0x0597
    2f02:	88 27       	eor	r24, r24
    2f04:	77 fd       	sbrc	r23, 7
    2f06:	80 95       	com	r24
    2f08:	98 2f       	mov	r25, r24
    2f0a:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    2f0e:	a8 01       	movw	r20, r16
    2f10:	97 01       	movw	r18, r14
    2f12:	0e 94 92 37 	call	0x6f24	; 0x6f24 <__addsf3>
    2f16:	0e 94 62 38 	call	0x70c4	; 0x70c4 <__fixsfsi>
    2f1a:	70 93 97 05 	sts	0x0597, r23
    2f1e:	60 93 96 05 	sts	0x0596, r22
				MotorOut[1] += Landing;
    2f22:	60 91 98 05 	lds	r22, 0x0598
    2f26:	70 91 99 05 	lds	r23, 0x0599
    2f2a:	88 27       	eor	r24, r24
    2f2c:	77 fd       	sbrc	r23, 7
    2f2e:	80 95       	com	r24
    2f30:	98 2f       	mov	r25, r24
    2f32:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    2f36:	a8 01       	movw	r20, r16
    2f38:	97 01       	movw	r18, r14
    2f3a:	0e 94 92 37 	call	0x6f24	; 0x6f24 <__addsf3>
    2f3e:	0e 94 62 38 	call	0x70c4	; 0x70c4 <__fixsfsi>
    2f42:	70 93 99 05 	sts	0x0599, r23
    2f46:	60 93 98 05 	sts	0x0598, r22
				if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    2f4a:	80 91 f0 06 	lds	r24, 0x06F0
    2f4e:	c0 90 9a 05 	lds	r12, 0x059A
    2f52:	d0 90 9b 05 	lds	r13, 0x059B
    2f56:	81 30       	cpi	r24, 0x01	; 1
    2f58:	31 f5       	brne	.+76     	; 0x2fa6 <MainLoop+0x6fe>
				{
					
					MotorOut[2] += Landing;
    2f5a:	b6 01       	movw	r22, r12
    2f5c:	88 27       	eor	r24, r24
    2f5e:	77 fd       	sbrc	r23, 7
    2f60:	80 95       	com	r24
    2f62:	98 2f       	mov	r25, r24
    2f64:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    2f68:	a8 01       	movw	r20, r16
    2f6a:	97 01       	movw	r18, r14
    2f6c:	0e 94 92 37 	call	0x6f24	; 0x6f24 <__addsf3>
    2f70:	0e 94 62 38 	call	0x70c4	; 0x70c4 <__fixsfsi>
    2f74:	70 93 9b 05 	sts	0x059B, r23
    2f78:	60 93 9a 05 	sts	0x059A, r22
					MotorOut[3] += Landing;		
    2f7c:	60 91 9c 05 	lds	r22, 0x059C
    2f80:	70 91 9d 05 	lds	r23, 0x059D
    2f84:	88 27       	eor	r24, r24
    2f86:	77 fd       	sbrc	r23, 7
    2f88:	80 95       	com	r24
    2f8a:	98 2f       	mov	r25, r24
    2f8c:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    2f90:	a8 01       	movw	r20, r16
    2f92:	97 01       	movw	r18, r14
    2f94:	0e 94 92 37 	call	0x6f24	; 0x6f24 <__addsf3>
    2f98:	0e 94 62 38 	call	0x70c4	; 0x70c4 <__fixsfsi>
    2f9c:	70 93 9d 05 	sts	0x059D, r23
    2fa0:	60 93 9c 05 	sts	0x059C, r22
    2fa4:	11 c0       	rjmp	.+34     	; 0x2fc8 <MainLoop+0x720>
				}
				else
				{
					MotorOut[2] += Landing;
    2fa6:	b6 01       	movw	r22, r12
    2fa8:	88 27       	eor	r24, r24
    2faa:	77 fd       	sbrc	r23, 7
    2fac:	80 95       	com	r24
    2fae:	98 2f       	mov	r25, r24
    2fb0:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    2fb4:	a8 01       	movw	r20, r16
    2fb6:	97 01       	movw	r18, r14
    2fb8:	0e 94 92 37 	call	0x6f24	; 0x6f24 <__addsf3>
    2fbc:	0e 94 62 38 	call	0x70c4	; 0x70c4 <__fixsfsi>
    2fc0:	70 93 9b 05 	sts	0x059B, r23
    2fc4:	60 93 9a 05 	sts	0x059A, r22
													
										
			}
			
									
			if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    2fc8:	00 91 f0 06 	lds	r16, 0x06F0
    2fcc:	80 91 e5 06 	lds	r24, 0x06E5
    2fd0:	90 91 e6 06 	lds	r25, 0x06E6
    2fd4:	01 30       	cpi	r16, 0x01	; 1
    2fd6:	49 f5       	brne	.+82     	; 0x302a <MainLoop+0x782>
			{
				MotorOut[0] -= gyroYaw;
    2fd8:	20 91 96 05 	lds	r18, 0x0596
    2fdc:	30 91 97 05 	lds	r19, 0x0597
    2fe0:	28 1b       	sub	r18, r24
    2fe2:	39 0b       	sbc	r19, r25
    2fe4:	30 93 97 05 	sts	0x0597, r19
    2fe8:	20 93 96 05 	sts	0x0596, r18
				MotorOut[2] -= gyroYaw;
    2fec:	20 91 9a 05 	lds	r18, 0x059A
    2ff0:	30 91 9b 05 	lds	r19, 0x059B
    2ff4:	28 1b       	sub	r18, r24
    2ff6:	39 0b       	sbc	r19, r25
    2ff8:	30 93 9b 05 	sts	0x059B, r19
    2ffc:	20 93 9a 05 	sts	0x059A, r18
				MotorOut[1] += gyroYaw;
    3000:	20 91 98 05 	lds	r18, 0x0598
    3004:	30 91 99 05 	lds	r19, 0x0599
    3008:	28 0f       	add	r18, r24
    300a:	39 1f       	adc	r19, r25
    300c:	30 93 99 05 	sts	0x0599, r19
    3010:	20 93 98 05 	sts	0x0598, r18
				MotorOut[3] += gyroYaw;
    3014:	20 91 9c 05 	lds	r18, 0x059C
    3018:	30 91 9d 05 	lds	r19, 0x059D
    301c:	28 0f       	add	r18, r24
    301e:	39 1f       	adc	r19, r25
    3020:	30 93 9d 05 	sts	0x059D, r19
    3024:	20 93 9c 05 	sts	0x059C, r18
    3028:	3a c0       	rjmp	.+116    	; 0x309e <MainLoop+0x7f6>
			}
			else
			{
			
				MotorOut[3]  = (Config.ReverseYAW * gyroYaw) + SERVO_IN_MIDDLE; 
    302a:	20 91 ae 07 	lds	r18, 0x07AE
    302e:	c2 2f       	mov	r28, r18
    3030:	dd 27       	eor	r29, r29
    3032:	c7 fd       	sbrc	r28, 7
    3034:	d0 95       	com	r29
    3036:	c8 9f       	mul	r28, r24
    3038:	b0 01       	movw	r22, r0
    303a:	c9 9f       	mul	r28, r25
    303c:	70 0d       	add	r23, r0
    303e:	d8 9f       	mul	r29, r24
    3040:	70 0d       	add	r23, r0
    3042:	11 24       	eor	r1, r1
    3044:	6a 5d       	subi	r22, 0xDA	; 218
    3046:	7d 4f       	sbci	r23, 0xFD	; 253
				MotorOut[3]  = MotorOut[3] - (Config.ReverseYAW * RX_Snapshot[RXChannel_RUD] * 0.2);
    3048:	88 27       	eor	r24, r24
    304a:	77 fd       	sbrc	r23, 7
    304c:	80 95       	com	r24
    304e:	98 2f       	mov	r25, r24
    3050:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    3054:	6b 01       	movw	r12, r22
    3056:	7c 01       	movw	r14, r24
    3058:	80 91 c2 05 	lds	r24, 0x05C2
    305c:	90 91 c3 05 	lds	r25, 0x05C3
    3060:	c8 9f       	mul	r28, r24
    3062:	b0 01       	movw	r22, r0
    3064:	c9 9f       	mul	r28, r25
    3066:	70 0d       	add	r23, r0
    3068:	d8 9f       	mul	r29, r24
    306a:	70 0d       	add	r23, r0
    306c:	11 24       	eor	r1, r1
    306e:	88 27       	eor	r24, r24
    3070:	77 fd       	sbrc	r23, 7
    3072:	80 95       	com	r24
    3074:	98 2f       	mov	r25, r24
    3076:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    307a:	2d ec       	ldi	r18, 0xCD	; 205
    307c:	3c ec       	ldi	r19, 0xCC	; 204
    307e:	4c e4       	ldi	r20, 0x4C	; 76
    3080:	5e e3       	ldi	r21, 0x3E	; 62
    3082:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    3086:	9b 01       	movw	r18, r22
    3088:	ac 01       	movw	r20, r24
    308a:	c7 01       	movw	r24, r14
    308c:	b6 01       	movw	r22, r12
    308e:	0e 94 91 37 	call	0x6f22	; 0x6f22 <__subsf3>
    3092:	0e 94 62 38 	call	0x70c4	; 0x70c4 <__fixsfsi>
    3096:	70 93 9d 05 	sts	0x059D, r23
    309a:	60 93 9c 05 	sts	0x059C, r22
			}						
			
			// Save motors from turning-off
            if (MotorOut[0]<MOTORS_IDLE_VALUE) MotorOut[0]=MOTORS_IDLE_VALUE;
    309e:	80 91 96 05 	lds	r24, 0x0596
    30a2:	90 91 97 05 	lds	r25, 0x0597
    30a6:	84 36       	cpi	r24, 0x64	; 100
    30a8:	91 05       	cpc	r25, r1
    30aa:	34 f4       	brge	.+12     	; 0x30b8 <MainLoop+0x810>
    30ac:	84 e6       	ldi	r24, 0x64	; 100
    30ae:	90 e0       	ldi	r25, 0x00	; 0
    30b0:	90 93 97 05 	sts	0x0597, r25
    30b4:	80 93 96 05 	sts	0x0596, r24
            if (MotorOut[1]<MOTORS_IDLE_VALUE) MotorOut[1]=MOTORS_IDLE_VALUE;
    30b8:	80 91 98 05 	lds	r24, 0x0598
    30bc:	90 91 99 05 	lds	r25, 0x0599
    30c0:	84 36       	cpi	r24, 0x64	; 100
    30c2:	91 05       	cpc	r25, r1
    30c4:	34 f4       	brge	.+12     	; 0x30d2 <MainLoop+0x82a>
    30c6:	84 e6       	ldi	r24, 0x64	; 100
    30c8:	90 e0       	ldi	r25, 0x00	; 0
    30ca:	90 93 99 05 	sts	0x0599, r25
    30ce:	80 93 98 05 	sts	0x0598, r24
            if (MotorOut[2]<MOTORS_IDLE_VALUE) MotorOut[2]=MOTORS_IDLE_VALUE;
    30d2:	80 91 9a 05 	lds	r24, 0x059A
    30d6:	90 91 9b 05 	lds	r25, 0x059B
    30da:	84 36       	cpi	r24, 0x64	; 100
    30dc:	91 05       	cpc	r25, r1
    30de:	34 f4       	brge	.+12     	; 0x30ec <MainLoop+0x844>
    30e0:	84 e6       	ldi	r24, 0x64	; 100
    30e2:	90 e0       	ldi	r25, 0x00	; 0
    30e4:	90 93 9b 05 	sts	0x059B, r25
    30e8:	80 93 9a 05 	sts	0x059A, r24
            
									
			if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    30ec:	01 30       	cpi	r16, 0x01	; 1
    30ee:	69 f4       	brne	.+26     	; 0x310a <MainLoop+0x862>
			{
				if (MotorOut[3]<MOTORS_IDLE_VALUE) MotorOut[3]=MOTORS_IDLE_VALUE;
    30f0:	80 91 9c 05 	lds	r24, 0x059C
    30f4:	90 91 9d 05 	lds	r25, 0x059D
    30f8:	84 36       	cpi	r24, 0x64	; 100
    30fa:	91 05       	cpc	r25, r1
    30fc:	34 f4       	brge	.+12     	; 0x310a <MainLoop+0x862>
    30fe:	84 e6       	ldi	r24, 0x64	; 100
    3100:	90 e0       	ldi	r25, 0x00	; 0
    3102:	90 93 9d 05 	sts	0x059D, r25
    3106:	80 93 9c 05 	sts	0x059C, r24
			}
			
		
			// Sending Sensors & Motor Data 
			if (Config.RX_mode==RX_mode_UARTMode)
    310a:	80 91 eb 06 	lds	r24, 0x06EB
    310e:	8f 3f       	cpi	r24, 0xFF	; 255
    3110:	a1 f4       	brne	.+40     	; 0x313a <MainLoop+0x892>
			{
				//LED_Orange=~LED_Orange;
				Send_Data("S",1);
    3112:	84 e0       	ldi	r24, 0x04	; 4
    3114:	91 e0       	ldi	r25, 0x01	; 1
    3116:	61 e0       	ldi	r22, 0x01	; 1
    3118:	0e 94 82 10 	call	0x2104	; 0x2104 <Send_Data>
				Send_Data(Sensors_Latest,12);
    311c:	8b e3       	ldi	r24, 0x3B	; 59
    311e:	96 e0       	ldi	r25, 0x06	; 6
    3120:	6c e0       	ldi	r22, 0x0C	; 12
    3122:	0e 94 82 10 	call	0x2104	; 0x2104 <Send_Data>
				Send_Data(MotorOut,8);
    3126:	86 e9       	ldi	r24, 0x96	; 150
    3128:	95 e0       	ldi	r25, 0x05	; 5
    312a:	68 e0       	ldi	r22, 0x08	; 8
    312c:	0e 94 82 10 	call	0x2104	; 0x2104 <Send_Data>
				Send_Data("E",1);
    3130:	86 e0       	ldi	r24, 0x06	; 6
    3132:	91 e0       	ldi	r25, 0x01	; 1
    3134:	61 e0       	ldi	r22, 0x01	; 1
    3136:	0e 94 82 10 	call	0x2104	; 0x2104 <Send_Data>
		} // End of ARMED & Throttle > Minimum
				
			
	}  // End of Throttle stick is NOT Down [Armed Could be True or not]
	
	if ((!IS_TX2_GOOD)) // if no signal and there is no AutoLandingMode.
    313a:	80 91 fb 07 	lds	r24, 0x07FB
    313e:	80 7f       	andi	r24, 0xF0	; 240
    3140:	79 f0       	breq	.+30     	; 0x3160 <MainLoop+0x8b8>
	{
		ZEROMotors();
    3142:	0e 94 36 14 	call	0x286c	; 0x286c <ZEROMotors>
		if (IsArmed==true)
    3146:	80 91 c8 07 	lds	r24, 0x07C8
    314a:	81 30       	cpi	r24, 0x01	; 1
    314c:	49 f4       	brne	.+18     	; 0x3160 <MainLoop+0x8b8>
		{
			Motor_GenerateOutputSignal();	
    314e:	0e 94 1e 24 	call	0x483c	; 0x483c <Motor_GenerateOutputSignal>
			Disarm();	
    3152:	0e 94 29 0f 	call	0x1e52	; 0x1e52 <Disarm>
			SystemErrorType = SET_SYS_ERR_SIGNAL; // only error if signal lost while arming
    3156:	80 91 d7 06 	lds	r24, 0x06D7
    315a:	81 60       	ori	r24, 0x01	; 1
    315c:	80 93 d7 06 	sts	0x06D7, r24
		
		
		//return ; // Do nothing all below depends on TX.
	}
	
	Motor_GenerateOutputSignal();	
    3160:	0e 94 1e 24 	call	0x483c	; 0x483c <Motor_GenerateOutputSignal>
	
	if (bResetTCNR1_X==true)
    3164:	80 91 65 06 	lds	r24, 0x0665
    3168:	81 30       	cpi	r24, 0x01	; 1
    316a:	21 f4       	brne	.+8      	; 0x3174 <MainLoop+0x8cc>
	{
		TCNT1_X_snapshot1= 0; // reset timeout
    316c:	10 92 e7 05 	sts	0x05E7, r1
    3170:	10 92 e6 05 	sts	0x05E6, r1
	}
	
	
}	
    3174:	df 91       	pop	r29
    3176:	cf 91       	pop	r28
    3178:	1f 91       	pop	r17
    317a:	0f 91       	pop	r16
    317c:	ff 90       	pop	r15
    317e:	ef 90       	pop	r14
    3180:	df 90       	pop	r13
    3182:	cf 90       	pop	r12
    3184:	bf 90       	pop	r11
    3186:	af 90       	pop	r10
    3188:	9f 90       	pop	r9
    318a:	8f 90       	pop	r8
    318c:	08 95       	ret

0000318e <main>:

int main(void)
{
	// Stick Commands are only available for Secondary Receiver and when Stick is calibrated.
	
	UIEnableStickCommands=false;  
    318e:	10 92 e5 05 	sts	0x05E5, r1
	Setup();
    3192:	0e 94 bc 11 	call	0x2378	; 0x2378 <Setup>
	SystemActions = SYS_ACT_NON;
    3196:	10 92 4d 05 	sts	0x054D, r1
    SystemErrorType = SYS_ERR_NON;
    319a:	10 92 d7 06 	sts	0x06D7, r1
	nFlyingModes = FLYINGMODE_ACRO;
    319e:	81 e0       	ldi	r24, 0x01	; 1
    31a0:	80 93 1a 06 	sts	0x061A, r24
	FlyingModesToggle = HIGH;
    31a4:	80 93 2f 05 	sts	0x052F, r24
	
	DataPtr = (uint8_t *) (&Sensors_Latest);
    31a8:	8b e3       	ldi	r24, 0x3B	; 59
    31aa:	96 e0       	ldi	r25, 0x06	; 6
    31ac:	90 93 d8 07 	sts	0x07D8, r25
    31b0:	80 93 d7 07 	sts	0x07D7, r24
	DataCounter=0;
    31b4:	10 92 c9 07 	sts	0x07C9, r1
	
	
	TCNT1H_OLD = TCNT1H;
    31b8:	80 91 85 00 	lds	r24, 0x0085
    31bc:	90 e0       	ldi	r25, 0x00	; 0
    31be:	90 93 dd 06 	sts	0x06DD, r25
    31c2:	80 93 dc 06 	sts	0x06DC, r24
	// Never go to MainLoop "fly loop" unless Sensors & RX is calibrated.
	// This loop to protect against any bug that might make the quad start or KB stick click
	// as in this case crash is a must.
	LoopCalibration ();
    31c6:	0e 94 23 12 	call	0x2446	; 0x2446 <LoopCalibration>

	
	
	// This loop better be under the sensor/stick loop to avoid entering this mode is sticks are not calibrated.
	// This is no longer a condition after adding menuEnabled[PAGE_ESC_CALIBRATION]=0
	if (Config.IsESCCalibration==ESCCalibration_ON)		
    31ca:	80 91 ef 06 	lds	r24, 0x06EF
    31ce:	81 30       	cpi	r24, 0x01	; 1
    31d0:	11 f4       	brne	.+4      	; 0x31d6 <main+0x48>
	{
		LoopESCCalibration ();
    31d2:	0e 94 1d 12 	call	0x243a	; 0x243a <LoopESCCalibration>
	Mixer[Mixer_Quad_PLUS].Roll[4]  = {0,-1.0,0,1.0};
//#define Mixer_Quad_X		1
//#define Mixer_TRI			2
*/

	Menu_EnableAllItems();
    31d6:	0e 94 86 37 	call	0x6f0c	; 0x6f0c <Menu_EnableAllItems>
	
	Menu_LoadPage(PAGE_DEBUG);
    31da:	8f e0       	ldi	r24, 0x0F	; 15
    31dc:	0e 94 18 2e 	call	0x5c30	; 0x5c30 <Menu_LoadPage>
	
	while(1)
    {
		//LoopESCCalibration();
    	MainLoop();
    31e0:	0e 94 54 14 	call	0x28a8	; 0x28a8 <MainLoop>
    31e4:	fd cf       	rjmp	.-6      	; 0x31e0 <main+0x52>

000031e6 <PID_Calculate_ACC>:




float PID_Calculate_ACC (const pid_param_t PID_Params, pid_terms_t *PID_Term, const double  Value)
{
    31e6:	6f 92       	push	r6
    31e8:	7f 92       	push	r7
    31ea:	8f 92       	push	r8
    31ec:	9f 92       	push	r9
    31ee:	af 92       	push	r10
    31f0:	bf 92       	push	r11
    31f2:	cf 92       	push	r12
    31f4:	df 92       	push	r13
    31f6:	ef 92       	push	r14
    31f8:	ff 92       	push	r15
    31fa:	0f 93       	push	r16
    31fc:	1f 93       	push	r17
    31fe:	df 93       	push	r29
    3200:	cf 93       	push	r28
    3202:	cd b7       	in	r28, 0x3d	; 61
    3204:	de b7       	in	r29, 0x3e	; 62
    3206:	2e 97       	sbiw	r28, 0x0e	; 14
    3208:	0f b6       	in	r0, 0x3f	; 63
    320a:	f8 94       	cli
    320c:	de bf       	out	0x3e, r29	; 62
    320e:	0f be       	out	0x3f, r0	; 63
    3210:	cd bf       	out	0x3d, r28	; 61
    3212:	c9 82       	std	Y+1, r12	; 0x01
    3214:	da 82       	std	Y+2, r13	; 0x02
    3216:	eb 82       	std	Y+3, r14	; 0x03
    3218:	fc 82       	std	Y+4, r15	; 0x04
    321a:	0d 83       	std	Y+5, r16	; 0x05
    321c:	1e 83       	std	Y+6, r17	; 0x06
    321e:	2f 83       	std	Y+7, r18	; 0x07
    3220:	38 87       	std	Y+8, r19	; 0x08
    3222:	49 87       	std	Y+9, r20	; 0x09
    3224:	5a 87       	std	Y+10, r21	; 0x0a
    3226:	6b 87       	std	Y+11, r22	; 0x0b
    3228:	7c 87       	std	Y+12, r23	; 0x0c
    322a:	8d 87       	std	Y+13, r24	; 0x0d
    322c:	9e 87       	std	Y+14, r25	; 0x0e
    322e:	ef 8c       	ldd	r14, Y+31	; 0x1f
    3230:	f8 a0       	ldd	r15, Y+32	; 0x20
    3232:	09 a1       	ldd	r16, Y+33	; 0x21
    3234:	1a a1       	ldd	r17, Y+34	; 0x22
    3236:	6d 80       	ldd	r6, Y+5	; 0x05
    3238:	7e 80       	ldd	r7, Y+6	; 0x06
	#define ACC_I_MIN	4
		
	float Output;
		
		double AbsValue = abs (Value);
    323a:	c8 01       	movw	r24, r16
    323c:	b7 01       	movw	r22, r14
    323e:	0e 94 56 3a 	call	0x74ac	; 0x74ac <abs>
    3242:	9c 01       	movw	r18, r24
    3244:	b9 01       	movw	r22, r18
    3246:	88 27       	eor	r24, r24
    3248:	77 fd       	sbrc	r23, 7
    324a:	80 95       	com	r24
    324c:	98 2f       	mov	r25, r24
    324e:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
		// Calculate Terms 
		if (AbsValue > 1)
    3252:	20 e0       	ldi	r18, 0x00	; 0
    3254:	30 e0       	ldi	r19, 0x00	; 0
    3256:	40 e8       	ldi	r20, 0x80	; 128
    3258:	5f e3       	ldi	r21, 0x3F	; 63
    325a:	0e 94 45 39 	call	0x728a	; 0x728a <__gesf2>
    325e:	18 16       	cp	r1, r24
    3260:	cc f4       	brge	.+50     	; 0x3294 <PID_Calculate_ACC+0xae>
	    PID_Term->P  = ((float)(Value * PID_Params._P) / 10.0f);						
    3262:	69 81       	ldd	r22, Y+1	; 0x01
    3264:	7a 81       	ldd	r23, Y+2	; 0x02
    3266:	88 27       	eor	r24, r24
    3268:	77 fd       	sbrc	r23, 7
    326a:	80 95       	com	r24
    326c:	98 2f       	mov	r25, r24
    326e:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    3272:	9b 01       	movw	r18, r22
    3274:	ac 01       	movw	r20, r24
    3276:	c8 01       	movw	r24, r16
    3278:	b7 01       	movw	r22, r14
    327a:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    327e:	20 e0       	ldi	r18, 0x00	; 0
    3280:	30 e0       	ldi	r19, 0x00	; 0
    3282:	40 e2       	ldi	r20, 0x20	; 32
    3284:	51 e4       	ldi	r21, 0x41	; 65
    3286:	0e 94 fa 37 	call	0x6ff4	; 0x6ff4 <__divsf3>
    328a:	f5 01       	movw	r30, r10
    328c:	60 83       	st	Z, r22
    328e:	71 83       	std	Z+1, r23	; 0x01
    3290:	82 83       	std	Z+2, r24	; 0x02
    3292:	93 83       	std	Z+3, r25	; 0x03
		//if ((abs(Value - PID_Term->Error) > AbsValue ) || (Value ==0))
		//{  // Zero I if different signs.
			//PID_Term->I =0; ..... removed because it nakes whobbles.S
		//}
		//else 
		int16_t DeltaError = (Value - PID_Term->Error);
    3294:	c8 01       	movw	r24, r16
    3296:	b7 01       	movw	r22, r14
    3298:	f5 01       	movw	r30, r10
    329a:	24 85       	ldd	r18, Z+12	; 0x0c
    329c:	35 85       	ldd	r19, Z+13	; 0x0d
    329e:	46 85       	ldd	r20, Z+14	; 0x0e
    32a0:	57 85       	ldd	r21, Z+15	; 0x0f
    32a2:	0e 94 91 37 	call	0x6f22	; 0x6f22 <__subsf3>
    32a6:	0e 94 62 38 	call	0x70c4	; 0x70c4 <__fixsfsi>
    32aa:	6b 01       	movw	r12, r22
		if (Value > ACC_I_MIN)
    32ac:	c8 01       	movw	r24, r16
    32ae:	b7 01       	movw	r22, r14
    32b0:	20 e0       	ldi	r18, 0x00	; 0
    32b2:	30 e0       	ldi	r19, 0x00	; 0
    32b4:	40 e8       	ldi	r20, 0x80	; 128
    32b6:	50 e4       	ldi	r21, 0x40	; 64
    32b8:	0e 94 45 39 	call	0x728a	; 0x728a <__gesf2>
    32bc:	18 16       	cp	r1, r24
    32be:	bc f4       	brge	.+46     	; 0x32ee <PID_Calculate_ACC+0x108>
		{
			PID_Term->I += (float)(PID_Params._I / 100.0f);						    		
    32c0:	b3 01       	movw	r22, r6
    32c2:	88 27       	eor	r24, r24
    32c4:	77 fd       	sbrc	r23, 7
    32c6:	80 95       	com	r24
    32c8:	98 2f       	mov	r25, r24
    32ca:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    32ce:	20 e0       	ldi	r18, 0x00	; 0
    32d0:	30 e0       	ldi	r19, 0x00	; 0
    32d2:	48 ec       	ldi	r20, 0xC8	; 200
    32d4:	52 e4       	ldi	r21, 0x42	; 66
    32d6:	0e 94 fa 37 	call	0x6ff4	; 0x6ff4 <__divsf3>
    32da:	9b 01       	movw	r18, r22
    32dc:	ac 01       	movw	r20, r24
    32de:	f5 01       	movw	r30, r10
    32e0:	64 81       	ldd	r22, Z+4	; 0x04
    32e2:	75 81       	ldd	r23, Z+5	; 0x05
    32e4:	86 81       	ldd	r24, Z+6	; 0x06
    32e6:	97 81       	ldd	r25, Z+7	; 0x07
    32e8:	0e 94 92 37 	call	0x6f24	; 0x6f24 <__addsf3>
    32ec:	32 c0       	rjmp	.+100    	; 0x3352 <PID_Calculate_ACC+0x16c>
		}
		else if (Value < -ACC_I_MIN)
    32ee:	c8 01       	movw	r24, r16
    32f0:	b7 01       	movw	r22, r14
    32f2:	20 e0       	ldi	r18, 0x00	; 0
    32f4:	30 e0       	ldi	r19, 0x00	; 0
    32f6:	40 e8       	ldi	r20, 0x80	; 128
    32f8:	50 ec       	ldi	r21, 0xC0	; 192
    32fa:	0e 94 f6 37 	call	0x6fec	; 0x6fec <__cmpsf2>
    32fe:	87 ff       	sbrs	r24, 7
    3300:	15 c0       	rjmp	.+42     	; 0x332c <PID_Calculate_ACC+0x146>
		{	
			PID_Term->I -= (float)(PID_Params._I / 100.0f );						    		
    3302:	b3 01       	movw	r22, r6
    3304:	88 27       	eor	r24, r24
    3306:	77 fd       	sbrc	r23, 7
    3308:	80 95       	com	r24
    330a:	98 2f       	mov	r25, r24
    330c:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    3310:	20 e0       	ldi	r18, 0x00	; 0
    3312:	30 e0       	ldi	r19, 0x00	; 0
    3314:	48 ec       	ldi	r20, 0xC8	; 200
    3316:	52 e4       	ldi	r21, 0x42	; 66
    3318:	0e 94 fa 37 	call	0x6ff4	; 0x6ff4 <__divsf3>
    331c:	9b 01       	movw	r18, r22
    331e:	ac 01       	movw	r20, r24
    3320:	f5 01       	movw	r30, r10
    3322:	64 81       	ldd	r22, Z+4	; 0x04
    3324:	75 81       	ldd	r23, Z+5	; 0x05
    3326:	86 81       	ldd	r24, Z+6	; 0x06
    3328:	97 81       	ldd	r25, Z+7	; 0x07
    332a:	11 c0       	rjmp	.+34     	; 0x334e <PID_Calculate_ACC+0x168>
		}
		else
		{
			PID_Term->I -= (float)(PID_Term->I * PID_I_LEAK_RATE);
    332c:	f5 01       	movw	r30, r10
    332e:	64 80       	ldd	r6, Z+4	; 0x04
    3330:	75 80       	ldd	r7, Z+5	; 0x05
    3332:	86 80       	ldd	r8, Z+6	; 0x06
    3334:	97 80       	ldd	r9, Z+7	; 0x07
    3336:	c4 01       	movw	r24, r8
    3338:	b3 01       	movw	r22, r6
    333a:	2a e0       	ldi	r18, 0x0A	; 10
    333c:	37 ed       	ldi	r19, 0xD7	; 215
    333e:	43 e2       	ldi	r20, 0x23	; 35
    3340:	5c e3       	ldi	r21, 0x3C	; 60
    3342:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    3346:	9b 01       	movw	r18, r22
    3348:	ac 01       	movw	r20, r24
    334a:	c4 01       	movw	r24, r8
    334c:	b3 01       	movw	r22, r6
    334e:	0e 94 91 37 	call	0x6f22	; 0x6f22 <__subsf3>
    3352:	f5 01       	movw	r30, r10
    3354:	64 83       	std	Z+4, r22	; 0x04
    3356:	75 83       	std	Z+5, r23	; 0x05
    3358:	86 83       	std	Z+6, r24	; 0x06
    335a:	97 83       	std	Z+7, r25	; 0x07
		}			
				
		
		PID_Term->D= (float)((float)(DeltaError) * (float)PID_Params._D) / 20.0f ;
    335c:	b6 01       	movw	r22, r12
    335e:	88 27       	eor	r24, r24
    3360:	77 fd       	sbrc	r23, 7
    3362:	80 95       	com	r24
    3364:	98 2f       	mov	r25, r24
    3366:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    336a:	3b 01       	movw	r6, r22
    336c:	4c 01       	movw	r8, r24
    336e:	69 85       	ldd	r22, Y+9	; 0x09
    3370:	7a 85       	ldd	r23, Y+10	; 0x0a
    3372:	88 27       	eor	r24, r24
    3374:	77 fd       	sbrc	r23, 7
    3376:	80 95       	com	r24
    3378:	98 2f       	mov	r25, r24
    337a:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    337e:	9b 01       	movw	r18, r22
    3380:	ac 01       	movw	r20, r24
    3382:	c4 01       	movw	r24, r8
    3384:	b3 01       	movw	r22, r6
    3386:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    338a:	20 e0       	ldi	r18, 0x00	; 0
    338c:	30 e0       	ldi	r19, 0x00	; 0
    338e:	40 ea       	ldi	r20, 0xA0	; 160
    3390:	51 e4       	ldi	r21, 0x41	; 65
    3392:	0e 94 fa 37 	call	0x6ff4	; 0x6ff4 <__divsf3>
    3396:	f5 01       	movw	r30, r10
    3398:	60 87       	std	Z+8, r22	; 0x08
    339a:	71 87       	std	Z+9, r23	; 0x09
    339c:	82 87       	std	Z+10, r24	; 0x0a
    339e:	93 87       	std	Z+11, r25	; 0x0b
		PID_Term->Error = Value;	
    33a0:	e4 86       	std	Z+12, r14	; 0x0c
    33a2:	f5 86       	std	Z+13, r15	; 0x0d
    33a4:	06 87       	std	Z+14, r16	; 0x0e
    33a6:	17 87       	std	Z+15, r17	; 0x0f
		
				
		// Limit boundaries to custom values defined by user.
		PID_Term->I= Limiterf(PID_Term->I, PID_Params._ILimit);
    33a8:	e4 80       	ldd	r14, Z+4	; 0x04
    33aa:	f5 80       	ldd	r15, Z+5	; 0x05
    33ac:	06 81       	ldd	r16, Z+6	; 0x06
    33ae:	17 81       	ldd	r17, Z+7	; 0x07
    33b0:	6f 81       	ldd	r22, Y+7	; 0x07
    33b2:	78 85       	ldd	r23, Y+8	; 0x08
    33b4:	88 27       	eor	r24, r24
    33b6:	77 fd       	sbrc	r23, 7
    33b8:	80 95       	com	r24
    33ba:	98 2f       	mov	r25, r24
    33bc:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    33c0:	9b 01       	movw	r18, r22
    33c2:	ac 01       	movw	r20, r24
    33c4:	c8 01       	movw	r24, r16
    33c6:	b7 01       	movw	r22, r14
    33c8:	0e 94 db 22 	call	0x45b6	; 0x45b6 <Limiterf>
    33cc:	f5 01       	movw	r30, r10
    33ce:	64 83       	std	Z+4, r22	; 0x04
    33d0:	75 83       	std	Z+5, r23	; 0x05
    33d2:	86 83       	std	Z+6, r24	; 0x06
    33d4:	97 83       	std	Z+7, r25	; 0x07
		PID_Term->P= Limiterf(PID_Term->P, PID_Params._PLimit);
    33d6:	e0 80       	ld	r14, Z
    33d8:	f1 80       	ldd	r15, Z+1	; 0x01
    33da:	02 81       	ldd	r16, Z+2	; 0x02
    33dc:	13 81       	ldd	r17, Z+3	; 0x03
    33de:	6b 81       	ldd	r22, Y+3	; 0x03
    33e0:	7c 81       	ldd	r23, Y+4	; 0x04
    33e2:	88 27       	eor	r24, r24
    33e4:	77 fd       	sbrc	r23, 7
    33e6:	80 95       	com	r24
    33e8:	98 2f       	mov	r25, r24
    33ea:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    33ee:	9b 01       	movw	r18, r22
    33f0:	ac 01       	movw	r20, r24
    33f2:	c8 01       	movw	r24, r16
    33f4:	b7 01       	movw	r22, r14
    33f6:	0e 94 db 22 	call	0x45b6	; 0x45b6 <Limiterf>
    33fa:	f5 01       	movw	r30, r10
    33fc:	60 83       	st	Z, r22
    33fe:	71 83       	std	Z+1, r23	; 0x01
    3400:	82 83       	std	Z+2, r24	; 0x02
    3402:	93 83       	std	Z+3, r25	; 0x03
	    PID_Term->D= Limiterf(PID_Term->D, PID_Params._DLimit);
    3404:	e0 84       	ldd	r14, Z+8	; 0x08
    3406:	f1 84       	ldd	r15, Z+9	; 0x09
    3408:	02 85       	ldd	r16, Z+10	; 0x0a
    340a:	13 85       	ldd	r17, Z+11	; 0x0b
    340c:	6b 85       	ldd	r22, Y+11	; 0x0b
    340e:	7c 85       	ldd	r23, Y+12	; 0x0c
    3410:	88 27       	eor	r24, r24
    3412:	77 fd       	sbrc	r23, 7
    3414:	80 95       	com	r24
    3416:	98 2f       	mov	r25, r24
    3418:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    341c:	9b 01       	movw	r18, r22
    341e:	ac 01       	movw	r20, r24
    3420:	c8 01       	movw	r24, r16
    3422:	b7 01       	movw	r22, r14
    3424:	0e 94 db 22 	call	0x45b6	; 0x45b6 <Limiterf>
    3428:	7b 01       	movw	r14, r22
    342a:	8c 01       	movw	r16, r24
    342c:	f5 01       	movw	r30, r10
    342e:	60 87       	std	Z+8, r22	; 0x08
    3430:	71 87       	std	Z+9, r23	; 0x09
    3432:	82 87       	std	Z+10, r24	; 0x0a
    3434:	93 87       	std	Z+11, r25	; 0x0b
	
		Output = (PID_Term->P + PID_Term->I + PID_Term->D);	// P + I + D
    3436:	60 81       	ld	r22, Z
    3438:	71 81       	ldd	r23, Z+1	; 0x01
    343a:	82 81       	ldd	r24, Z+2	; 0x02
    343c:	93 81       	ldd	r25, Z+3	; 0x03
    343e:	24 81       	ldd	r18, Z+4	; 0x04
    3440:	35 81       	ldd	r19, Z+5	; 0x05
    3442:	46 81       	ldd	r20, Z+6	; 0x06
    3444:	57 81       	ldd	r21, Z+7	; 0x07
    3446:	0e 94 92 37 	call	0x6f24	; 0x6f24 <__addsf3>
    344a:	a8 01       	movw	r20, r16
    344c:	97 01       	movw	r18, r14
    344e:	0e 94 92 37 	call	0x6f24	; 0x6f24 <__addsf3>
		return  Output; 
}
    3452:	2e 96       	adiw	r28, 0x0e	; 14
    3454:	0f b6       	in	r0, 0x3f	; 63
    3456:	f8 94       	cli
    3458:	de bf       	out	0x3e, r29	; 62
    345a:	0f be       	out	0x3f, r0	; 63
    345c:	cd bf       	out	0x3d, r28	; 61
    345e:	cf 91       	pop	r28
    3460:	df 91       	pop	r29
    3462:	1f 91       	pop	r17
    3464:	0f 91       	pop	r16
    3466:	ff 90       	pop	r15
    3468:	ef 90       	pop	r14
    346a:	df 90       	pop	r13
    346c:	cf 90       	pop	r12
    346e:	bf 90       	pop	r11
    3470:	af 90       	pop	r10
    3472:	9f 90       	pop	r9
    3474:	8f 90       	pop	r8
    3476:	7f 90       	pop	r7
    3478:	6f 90       	pop	r6
    347a:	08 95       	ret

0000347c <PID_Calculate>:

float PID_Calculate (const pid_param_t PID_Params, pid_terms_t *PID_Term, const double  Value)
{
    347c:	af 92       	push	r10
    347e:	bf 92       	push	r11
    3480:	cf 92       	push	r12
    3482:	df 92       	push	r13
    3484:	ef 92       	push	r14
    3486:	ff 92       	push	r15
    3488:	0f 93       	push	r16
    348a:	1f 93       	push	r17
    348c:	df 93       	push	r29
    348e:	cf 93       	push	r28
    3490:	cd b7       	in	r28, 0x3d	; 61
    3492:	de b7       	in	r29, 0x3e	; 62
    3494:	2e 97       	sbiw	r28, 0x0e	; 14
    3496:	0f b6       	in	r0, 0x3f	; 63
    3498:	f8 94       	cli
    349a:	de bf       	out	0x3e, r29	; 62
    349c:	0f be       	out	0x3f, r0	; 63
    349e:	cd bf       	out	0x3d, r28	; 61
    34a0:	c9 82       	std	Y+1, r12	; 0x01
    34a2:	da 82       	std	Y+2, r13	; 0x02
    34a4:	eb 82       	std	Y+3, r14	; 0x03
    34a6:	fc 82       	std	Y+4, r15	; 0x04
    34a8:	0d 83       	std	Y+5, r16	; 0x05
    34aa:	1e 83       	std	Y+6, r17	; 0x06
    34ac:	2f 83       	std	Y+7, r18	; 0x07
    34ae:	38 87       	std	Y+8, r19	; 0x08
    34b0:	49 87       	std	Y+9, r20	; 0x09
    34b2:	5a 87       	std	Y+10, r21	; 0x0a
    34b4:	6b 87       	std	Y+11, r22	; 0x0b
    34b6:	7c 87       	std	Y+12, r23	; 0x0c
    34b8:	8d 87       	std	Y+13, r24	; 0x0d
    34ba:	9e 87       	std	Y+14, r25	; 0x0e
    34bc:	eb 8c       	ldd	r14, Y+27	; 0x1b
    34be:	fc 8c       	ldd	r15, Y+28	; 0x1c
    34c0:	0d 8d       	ldd	r16, Y+29	; 0x1d
    34c2:	1e 8d       	ldd	r17, Y+30	; 0x1e
		float Output;
		
		// Calculate Terms 
	    PID_Term->P  = ((float)(Value * PID_Params._P) / 20.0f);						
    34c4:	69 81       	ldd	r22, Y+1	; 0x01
    34c6:	7a 81       	ldd	r23, Y+2	; 0x02
    34c8:	88 27       	eor	r24, r24
    34ca:	77 fd       	sbrc	r23, 7
    34cc:	80 95       	com	r24
    34ce:	98 2f       	mov	r25, r24
    34d0:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    34d4:	9b 01       	movw	r18, r22
    34d6:	ac 01       	movw	r20, r24
    34d8:	c8 01       	movw	r24, r16
    34da:	b7 01       	movw	r22, r14
    34dc:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    34e0:	20 e0       	ldi	r18, 0x00	; 0
    34e2:	30 e0       	ldi	r19, 0x00	; 0
    34e4:	40 ea       	ldi	r20, 0xA0	; 160
    34e6:	51 e4       	ldi	r21, 0x41	; 65
    34e8:	0e 94 fa 37 	call	0x6ff4	; 0x6ff4 <__divsf3>
    34ec:	f5 01       	movw	r30, r10
    34ee:	60 83       	st	Z, r22
    34f0:	71 83       	std	Z+1, r23	; 0x01
    34f2:	82 83       	std	Z+2, r24	; 0x02
    34f4:	93 83       	std	Z+3, r25	; 0x03
		
		
		
		int16_t DeltaError = (Value - PID_Term->Error);
    34f6:	c8 01       	movw	r24, r16
    34f8:	b7 01       	movw	r22, r14
    34fa:	24 85       	ldd	r18, Z+12	; 0x0c
    34fc:	35 85       	ldd	r19, Z+13	; 0x0d
    34fe:	46 85       	ldd	r20, Z+14	; 0x0e
    3500:	57 85       	ldd	r21, Z+15	; 0x0f
    3502:	0e 94 91 37 	call	0x6f22	; 0x6f22 <__subsf3>
    3506:	0e 94 62 38 	call	0x70c4	; 0x70c4 <__fixsfsi>
    350a:	6b 01       	movw	r12, r22
		/*
		// I Logic here:
		// DEAD band = 2
		// Increment or Decrement by Value * PID_Params._I 
		*/
		if ((Value > 1) || (Value < -1))
    350c:	c8 01       	movw	r24, r16
    350e:	b7 01       	movw	r22, r14
    3510:	20 e0       	ldi	r18, 0x00	; 0
    3512:	30 e0       	ldi	r19, 0x00	; 0
    3514:	40 e8       	ldi	r20, 0x80	; 128
    3516:	5f e3       	ldi	r21, 0x3F	; 63
    3518:	0e 94 45 39 	call	0x728a	; 0x728a <__gesf2>
    351c:	18 16       	cp	r1, r24
    351e:	54 f0       	brlt	.+20     	; 0x3534 <PID_Calculate+0xb8>
    3520:	c8 01       	movw	r24, r16
    3522:	b7 01       	movw	r22, r14
    3524:	20 e0       	ldi	r18, 0x00	; 0
    3526:	30 e0       	ldi	r19, 0x00	; 0
    3528:	40 e8       	ldi	r20, 0x80	; 128
    352a:	5f eb       	ldi	r21, 0xBF	; 191
    352c:	0e 94 f6 37 	call	0x6fec	; 0x6fec <__cmpsf2>
    3530:	87 ff       	sbrs	r24, 7
    3532:	22 c0       	rjmp	.+68     	; 0x3578 <PID_Calculate+0xfc>
		{	// only increment I when the Value is increasing compared to the old one, also use [-2,2] as deadband.
			PID_Term->I += (float)((float)(Value * PID_Params._I) / 200.0f) ;	// try to replace Value with DeltaError
    3534:	6d 81       	ldd	r22, Y+5	; 0x05
    3536:	7e 81       	ldd	r23, Y+6	; 0x06
    3538:	88 27       	eor	r24, r24
    353a:	77 fd       	sbrc	r23, 7
    353c:	80 95       	com	r24
    353e:	98 2f       	mov	r25, r24
    3540:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    3544:	9b 01       	movw	r18, r22
    3546:	ac 01       	movw	r20, r24
    3548:	c8 01       	movw	r24, r16
    354a:	b7 01       	movw	r22, r14
    354c:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    3550:	20 e0       	ldi	r18, 0x00	; 0
    3552:	30 e0       	ldi	r19, 0x00	; 0
    3554:	48 e4       	ldi	r20, 0x48	; 72
    3556:	53 e4       	ldi	r21, 0x43	; 67
    3558:	0e 94 fa 37 	call	0x6ff4	; 0x6ff4 <__divsf3>
    355c:	9b 01       	movw	r18, r22
    355e:	ac 01       	movw	r20, r24
    3560:	f5 01       	movw	r30, r10
    3562:	64 81       	ldd	r22, Z+4	; 0x04
    3564:	75 81       	ldd	r23, Z+5	; 0x05
    3566:	86 81       	ldd	r24, Z+6	; 0x06
    3568:	97 81       	ldd	r25, Z+7	; 0x07
    356a:	0e 94 92 37 	call	0x6f24	; 0x6f24 <__addsf3>
    356e:	f5 01       	movw	r30, r10
    3570:	64 83       	std	Z+4, r22	; 0x04
    3572:	75 83       	std	Z+5, r23	; 0x05
    3574:	86 83       	std	Z+6, r24	; 0x06
    3576:	97 83       	std	Z+7, r25	; 0x07
			//PID_Term->I -= (float)(PID_Term->I * PID_I_LEAK_RATE);
		//}	
		
		
		
		PID_Term->D= (float)(DeltaError * PID_Params._D) / 20.0f ;
    3578:	89 85       	ldd	r24, Y+9	; 0x09
    357a:	9a 85       	ldd	r25, Y+10	; 0x0a
    357c:	c8 9e       	mul	r12, r24
    357e:	b0 01       	movw	r22, r0
    3580:	c9 9e       	mul	r12, r25
    3582:	70 0d       	add	r23, r0
    3584:	d8 9e       	mul	r13, r24
    3586:	70 0d       	add	r23, r0
    3588:	11 24       	eor	r1, r1
    358a:	88 27       	eor	r24, r24
    358c:	77 fd       	sbrc	r23, 7
    358e:	80 95       	com	r24
    3590:	98 2f       	mov	r25, r24
    3592:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    3596:	20 e0       	ldi	r18, 0x00	; 0
    3598:	30 e0       	ldi	r19, 0x00	; 0
    359a:	40 ea       	ldi	r20, 0xA0	; 160
    359c:	51 e4       	ldi	r21, 0x41	; 65
    359e:	0e 94 fa 37 	call	0x6ff4	; 0x6ff4 <__divsf3>
    35a2:	f5 01       	movw	r30, r10
    35a4:	60 87       	std	Z+8, r22	; 0x08
    35a6:	71 87       	std	Z+9, r23	; 0x09
    35a8:	82 87       	std	Z+10, r24	; 0x0a
    35aa:	93 87       	std	Z+11, r25	; 0x0b
		PID_Term->Error = Value;	
    35ac:	e4 86       	std	Z+12, r14	; 0x0c
    35ae:	f5 86       	std	Z+13, r15	; 0x0d
    35b0:	06 87       	std	Z+14, r16	; 0x0e
    35b2:	17 87       	std	Z+15, r17	; 0x0f
		
				
		// Limit boundaries to custom values defined by user.
		PID_Term->I= Limiterf(PID_Term->I, PID_Params._ILimit);
    35b4:	e4 80       	ldd	r14, Z+4	; 0x04
    35b6:	f5 80       	ldd	r15, Z+5	; 0x05
    35b8:	06 81       	ldd	r16, Z+6	; 0x06
    35ba:	17 81       	ldd	r17, Z+7	; 0x07
    35bc:	6f 81       	ldd	r22, Y+7	; 0x07
    35be:	78 85       	ldd	r23, Y+8	; 0x08
    35c0:	88 27       	eor	r24, r24
    35c2:	77 fd       	sbrc	r23, 7
    35c4:	80 95       	com	r24
    35c6:	98 2f       	mov	r25, r24
    35c8:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    35cc:	9b 01       	movw	r18, r22
    35ce:	ac 01       	movw	r20, r24
    35d0:	c8 01       	movw	r24, r16
    35d2:	b7 01       	movw	r22, r14
    35d4:	0e 94 db 22 	call	0x45b6	; 0x45b6 <Limiterf>
    35d8:	f5 01       	movw	r30, r10
    35da:	64 83       	std	Z+4, r22	; 0x04
    35dc:	75 83       	std	Z+5, r23	; 0x05
    35de:	86 83       	std	Z+6, r24	; 0x06
    35e0:	97 83       	std	Z+7, r25	; 0x07
		PID_Term->P= Limiterf(PID_Term->P, PID_Params._PLimit);
    35e2:	e0 80       	ld	r14, Z
    35e4:	f1 80       	ldd	r15, Z+1	; 0x01
    35e6:	02 81       	ldd	r16, Z+2	; 0x02
    35e8:	13 81       	ldd	r17, Z+3	; 0x03
    35ea:	6b 81       	ldd	r22, Y+3	; 0x03
    35ec:	7c 81       	ldd	r23, Y+4	; 0x04
    35ee:	88 27       	eor	r24, r24
    35f0:	77 fd       	sbrc	r23, 7
    35f2:	80 95       	com	r24
    35f4:	98 2f       	mov	r25, r24
    35f6:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    35fa:	9b 01       	movw	r18, r22
    35fc:	ac 01       	movw	r20, r24
    35fe:	c8 01       	movw	r24, r16
    3600:	b7 01       	movw	r22, r14
    3602:	0e 94 db 22 	call	0x45b6	; 0x45b6 <Limiterf>
    3606:	f5 01       	movw	r30, r10
    3608:	60 83       	st	Z, r22
    360a:	71 83       	std	Z+1, r23	; 0x01
    360c:	82 83       	std	Z+2, r24	; 0x02
    360e:	93 83       	std	Z+3, r25	; 0x03
	    PID_Term->D= Limiterf(PID_Term->D, PID_Params._DLimit);
    3610:	e0 84       	ldd	r14, Z+8	; 0x08
    3612:	f1 84       	ldd	r15, Z+9	; 0x09
    3614:	02 85       	ldd	r16, Z+10	; 0x0a
    3616:	13 85       	ldd	r17, Z+11	; 0x0b
    3618:	6b 85       	ldd	r22, Y+11	; 0x0b
    361a:	7c 85       	ldd	r23, Y+12	; 0x0c
    361c:	88 27       	eor	r24, r24
    361e:	77 fd       	sbrc	r23, 7
    3620:	80 95       	com	r24
    3622:	98 2f       	mov	r25, r24
    3624:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    3628:	9b 01       	movw	r18, r22
    362a:	ac 01       	movw	r20, r24
    362c:	c8 01       	movw	r24, r16
    362e:	b7 01       	movw	r22, r14
    3630:	0e 94 db 22 	call	0x45b6	; 0x45b6 <Limiterf>
    3634:	7b 01       	movw	r14, r22
    3636:	8c 01       	movw	r16, r24
    3638:	f5 01       	movw	r30, r10
    363a:	60 87       	std	Z+8, r22	; 0x08
    363c:	71 87       	std	Z+9, r23	; 0x09
    363e:	82 87       	std	Z+10, r24	; 0x0a
    3640:	93 87       	std	Z+11, r25	; 0x0b
	
		Output = (PID_Term->P + PID_Term->I + PID_Term->D);	// P + I + D
    3642:	60 81       	ld	r22, Z
    3644:	71 81       	ldd	r23, Z+1	; 0x01
    3646:	82 81       	ldd	r24, Z+2	; 0x02
    3648:	93 81       	ldd	r25, Z+3	; 0x03
    364a:	24 81       	ldd	r18, Z+4	; 0x04
    364c:	35 81       	ldd	r19, Z+5	; 0x05
    364e:	46 81       	ldd	r20, Z+6	; 0x06
    3650:	57 81       	ldd	r21, Z+7	; 0x07
    3652:	0e 94 92 37 	call	0x6f24	; 0x6f24 <__addsf3>
    3656:	a8 01       	movw	r20, r16
    3658:	97 01       	movw	r18, r14
    365a:	0e 94 92 37 	call	0x6f24	; 0x6f24 <__addsf3>
		//Output = Output / 10;
		return  Output; //Limiter(Output,(int16_t)300);
}		
    365e:	2e 96       	adiw	r28, 0x0e	; 14
    3660:	0f b6       	in	r0, 0x3f	; 63
    3662:	f8 94       	cli
    3664:	de bf       	out	0x3e, r29	; 62
    3666:	0f be       	out	0x3f, r0	; 63
    3668:	cd bf       	out	0x3d, r28	; 61
    366a:	cf 91       	pop	r28
    366c:	df 91       	pop	r29
    366e:	1f 91       	pop	r17
    3670:	0f 91       	pop	r16
    3672:	ff 90       	pop	r15
    3674:	ef 90       	pop	r14
    3676:	df 90       	pop	r13
    3678:	cf 90       	pop	r12
    367a:	bf 90       	pop	r11
    367c:	af 90       	pop	r10
    367e:	08 95       	ret

00003680 <ZERO_Is>:

void ZERO_Is()
{
	PID_GyroTerms[PITCH_INDEX].I=0;
    3680:	80 e0       	ldi	r24, 0x00	; 0
    3682:	90 e0       	ldi	r25, 0x00	; 0
    3684:	dc 01       	movw	r26, r24
    3686:	80 93 7a 06 	sts	0x067A, r24
    368a:	90 93 7b 06 	sts	0x067B, r25
    368e:	a0 93 7c 06 	sts	0x067C, r26
    3692:	b0 93 7d 06 	sts	0x067D, r27
	PID_GyroTerms[ROLL_INDEX].I=0;
    3696:	80 93 92 06 	sts	0x0692, r24
    369a:	90 93 93 06 	sts	0x0693, r25
    369e:	a0 93 94 06 	sts	0x0694, r26
    36a2:	b0 93 95 06 	sts	0x0695, r27
	PID_GyroTerms[YAW_INDEX].I=0;
    36a6:	80 93 aa 06 	sts	0x06AA, r24
    36aa:	90 93 ab 06 	sts	0x06AB, r25
    36ae:	a0 93 ac 06 	sts	0x06AC, r26
    36b2:	b0 93 ad 06 	sts	0x06AD, r27
	PID_AccTerms[PITCH_INDEX].I=0;
    36b6:	80 93 52 05 	sts	0x0552, r24
    36ba:	90 93 53 05 	sts	0x0553, r25
    36be:	a0 93 54 05 	sts	0x0554, r26
    36c2:	b0 93 55 05 	sts	0x0555, r27
	PID_AccTerms[ROLL_INDEX].I=0;
    36c6:	80 93 6a 05 	sts	0x056A, r24
    36ca:	90 93 6b 05 	sts	0x056B, r25
    36ce:	a0 93 6c 05 	sts	0x056C, r26
    36d2:	b0 93 6d 05 	sts	0x056D, r27
	PID_AccTerms[Z_INDEX].I=0;
    36d6:	80 93 82 05 	sts	0x0582, r24
    36da:	90 93 83 05 	sts	0x0583, r25
    36de:	a0 93 84 05 	sts	0x0584, r26
    36e2:	b0 93 85 05 	sts	0x0585, r27

	PID_SonarTerms[0].I=0;
    36e6:	80 93 b4 07 	sts	0x07B4, r24
    36ea:	90 93 b5 07 	sts	0x07B5, r25
    36ee:	a0 93 b6 07 	sts	0x07B6, r26
    36f2:	b0 93 b7 07 	sts	0x07B7, r27
}
    36f6:	08 95       	ret

000036f8 <RotateV>:
//#include "../Include/DCM.h"


// Rotate Estimated vector(s) with small angle approximation, according to the gyro data
void RotateV() 
{
    36f8:	2f 92       	push	r2
    36fa:	3f 92       	push	r3
    36fc:	4f 92       	push	r4
    36fe:	5f 92       	push	r5
    3700:	6f 92       	push	r6
    3702:	7f 92       	push	r7
    3704:	8f 92       	push	r8
    3706:	9f 92       	push	r9
    3708:	af 92       	push	r10
    370a:	bf 92       	push	r11
    370c:	cf 92       	push	r12
    370e:	df 92       	push	r13
    3710:	ef 92       	push	r14
    3712:	ff 92       	push	r15
    3714:	0f 93       	push	r16
    3716:	1f 93       	push	r17
    3718:	df 93       	push	r29
    371a:	cf 93       	push	r28
    371c:	cd b7       	in	r28, 0x3d	; 61
    371e:	de b7       	in	r29, 0x3e	; 62
    3720:	28 97       	sbiw	r28, 0x08	; 8
    3722:	0f b6       	in	r0, 0x3f	; 63
    3724:	f8 94       	cli
    3726:	de bf       	out	0x3e, r29	; 62
    3728:	0f be       	out	0x3f, r0	; 63
    372a:	cd bf       	out	0x3d, r28	; 61
	  //v->Y += delta[PITCH] * v_tmp.Z + delta[YAW]   * v_tmp.X; 
	//*/
	//double oAnglePitch = AnglePitch;
	//double oAngleRoll = AngleRoll;
	//double oAngleZ     = AngleZ     ;
	AngleZ     -= (CompGyroRoll  * AngleRoll )  * GYRO_RATE + ( CompGyroPitch * AnglePitch) * GYRO_RATE;
    372c:	20 90 6c 06 	lds	r2, 0x066C
    3730:	30 90 6d 06 	lds	r3, 0x066D
    3734:	40 90 6e 06 	lds	r4, 0x066E
    3738:	50 90 6f 06 	lds	r5, 0x066F
    373c:	60 90 72 06 	lds	r6, 0x0672
    3740:	70 90 73 06 	lds	r7, 0x0673
    3744:	80 90 74 06 	lds	r8, 0x0674
    3748:	90 90 75 06 	lds	r9, 0x0675
    374c:	20 91 de 06 	lds	r18, 0x06DE
    3750:	30 91 df 06 	lds	r19, 0x06DF
    3754:	40 91 e0 06 	lds	r20, 0x06E0
    3758:	50 91 e1 06 	lds	r21, 0x06E1
    375c:	80 91 e0 05 	lds	r24, 0x05E0
    3760:	90 91 e1 05 	lds	r25, 0x05E1
    3764:	a0 91 e2 05 	lds	r26, 0x05E2
    3768:	b0 91 e3 05 	lds	r27, 0x05E3
    376c:	89 83       	std	Y+1, r24	; 0x01
    376e:	9a 83       	std	Y+2, r25	; 0x02
    3770:	ab 83       	std	Y+3, r26	; 0x03
    3772:	bc 83       	std	Y+4, r27	; 0x04
    3774:	e0 90 16 06 	lds	r14, 0x0616
    3778:	f0 90 17 06 	lds	r15, 0x0617
    377c:	00 91 18 06 	lds	r16, 0x0618
    3780:	10 91 19 06 	lds	r17, 0x0619
    3784:	c4 01       	movw	r24, r8
    3786:	b3 01       	movw	r22, r6
    3788:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    378c:	23 ed       	ldi	r18, 0xD3	; 211
    378e:	39 ed       	ldi	r19, 0xD9	; 217
    3790:	49 e4       	ldi	r20, 0x49	; 73
    3792:	5a e3       	ldi	r21, 0x3A	; 58
    3794:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    3798:	5b 01       	movw	r10, r22
    379a:	6c 01       	movw	r12, r24
    379c:	69 81       	ldd	r22, Y+1	; 0x01
    379e:	7a 81       	ldd	r23, Y+2	; 0x02
    37a0:	8b 81       	ldd	r24, Y+3	; 0x03
    37a2:	9c 81       	ldd	r25, Y+4	; 0x04
    37a4:	a8 01       	movw	r20, r16
    37a6:	97 01       	movw	r18, r14
    37a8:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    37ac:	23 ed       	ldi	r18, 0xD3	; 211
    37ae:	39 ed       	ldi	r19, 0xD9	; 217
    37b0:	49 e4       	ldi	r20, 0x49	; 73
    37b2:	5a e3       	ldi	r21, 0x3A	; 58
    37b4:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    37b8:	9b 01       	movw	r18, r22
    37ba:	ac 01       	movw	r20, r24
    37bc:	c6 01       	movw	r24, r12
    37be:	b5 01       	movw	r22, r10
    37c0:	0e 94 92 37 	call	0x6f24	; 0x6f24 <__addsf3>
    37c4:	9b 01       	movw	r18, r22
    37c6:	ac 01       	movw	r20, r24
    37c8:	c2 01       	movw	r24, r4
    37ca:	b1 01       	movw	r22, r2
    37cc:	0e 94 91 37 	call	0x6f22	; 0x6f22 <__subsf3>
    37d0:	9b 01       	movw	r18, r22
    37d2:	ac 01       	movw	r20, r24
    37d4:	20 93 6c 06 	sts	0x066C, r18
    37d8:	30 93 6d 06 	sts	0x066D, r19
    37dc:	40 93 6e 06 	sts	0x066E, r20
    37e0:	50 93 6f 06 	sts	0x066F, r21
	AngleRoll  += (CompGyroRoll  * AngleZ )     * GYRO_RATE - ( CompGyroZ     * AnglePitch) * GYRO_RATE;
    37e4:	80 91 de 06 	lds	r24, 0x06DE
    37e8:	90 91 df 06 	lds	r25, 0x06DF
    37ec:	a0 91 e0 06 	lds	r26, 0x06E0
    37f0:	b0 91 e1 06 	lds	r27, 0x06E1
    37f4:	8d 83       	std	Y+5, r24	; 0x05
    37f6:	9e 83       	std	Y+6, r25	; 0x06
    37f8:	af 83       	std	Y+7, r26	; 0x07
    37fa:	b8 87       	std	Y+8, r27	; 0x08
    37fc:	20 91 6c 06 	lds	r18, 0x066C
    3800:	30 91 6d 06 	lds	r19, 0x066D
    3804:	40 91 6e 06 	lds	r20, 0x066E
    3808:	50 91 6f 06 	lds	r21, 0x066F
    380c:	20 90 1d 06 	lds	r2, 0x061D
    3810:	30 90 1e 06 	lds	r3, 0x061E
    3814:	40 90 1f 06 	lds	r4, 0x061F
    3818:	50 90 20 06 	lds	r5, 0x0620
    381c:	e0 90 16 06 	lds	r14, 0x0616
    3820:	f0 90 17 06 	lds	r15, 0x0617
    3824:	00 91 18 06 	lds	r16, 0x0618
    3828:	10 91 19 06 	lds	r17, 0x0619
    382c:	c4 01       	movw	r24, r8
    382e:	b3 01       	movw	r22, r6
    3830:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    3834:	23 ed       	ldi	r18, 0xD3	; 211
    3836:	39 ed       	ldi	r19, 0xD9	; 217
    3838:	49 e4       	ldi	r20, 0x49	; 73
    383a:	5a e3       	ldi	r21, 0x3A	; 58
    383c:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    3840:	5b 01       	movw	r10, r22
    3842:	6c 01       	movw	r12, r24
    3844:	c2 01       	movw	r24, r4
    3846:	b1 01       	movw	r22, r2
    3848:	a8 01       	movw	r20, r16
    384a:	97 01       	movw	r18, r14
    384c:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    3850:	23 ed       	ldi	r18, 0xD3	; 211
    3852:	39 ed       	ldi	r19, 0xD9	; 217
    3854:	49 e4       	ldi	r20, 0x49	; 73
    3856:	5a e3       	ldi	r21, 0x3A	; 58
    3858:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    385c:	9b 01       	movw	r18, r22
    385e:	ac 01       	movw	r20, r24
    3860:	c6 01       	movw	r24, r12
    3862:	b5 01       	movw	r22, r10
    3864:	0e 94 91 37 	call	0x6f22	; 0x6f22 <__subsf3>
    3868:	9b 01       	movw	r18, r22
    386a:	ac 01       	movw	r20, r24
    386c:	6d 81       	ldd	r22, Y+5	; 0x05
    386e:	7e 81       	ldd	r23, Y+6	; 0x06
    3870:	8f 81       	ldd	r24, Y+7	; 0x07
    3872:	98 85       	ldd	r25, Y+8	; 0x08
    3874:	0e 94 92 37 	call	0x6f24	; 0x6f24 <__addsf3>
    3878:	9b 01       	movw	r18, r22
    387a:	ac 01       	movw	r20, r24
    387c:	20 93 de 06 	sts	0x06DE, r18
    3880:	30 93 df 06 	sts	0x06DF, r19
    3884:	40 93 e0 06 	sts	0x06E0, r20
    3888:	50 93 e1 06 	sts	0x06E1, r21
	AnglePitch += (CompGyroPitch * AngleZ )		* GYRO_RATE + ( CompGyroZ     * AngleRoll ) * GYRO_RATE;
    388c:	60 90 16 06 	lds	r6, 0x0616
    3890:	70 90 17 06 	lds	r7, 0x0617
    3894:	80 90 18 06 	lds	r8, 0x0618
    3898:	90 90 19 06 	lds	r9, 0x0619
    389c:	20 91 6c 06 	lds	r18, 0x066C
    38a0:	30 91 6d 06 	lds	r19, 0x066D
    38a4:	40 91 6e 06 	lds	r20, 0x066E
    38a8:	50 91 6f 06 	lds	r21, 0x066F
    38ac:	e0 90 de 06 	lds	r14, 0x06DE
    38b0:	f0 90 df 06 	lds	r15, 0x06DF
    38b4:	00 91 e0 06 	lds	r16, 0x06E0
    38b8:	10 91 e1 06 	lds	r17, 0x06E1
    38bc:	69 81       	ldd	r22, Y+1	; 0x01
    38be:	7a 81       	ldd	r23, Y+2	; 0x02
    38c0:	8b 81       	ldd	r24, Y+3	; 0x03
    38c2:	9c 81       	ldd	r25, Y+4	; 0x04
    38c4:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    38c8:	23 ed       	ldi	r18, 0xD3	; 211
    38ca:	39 ed       	ldi	r19, 0xD9	; 217
    38cc:	49 e4       	ldi	r20, 0x49	; 73
    38ce:	5a e3       	ldi	r21, 0x3A	; 58
    38d0:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    38d4:	5b 01       	movw	r10, r22
    38d6:	6c 01       	movw	r12, r24
    38d8:	c2 01       	movw	r24, r4
    38da:	b1 01       	movw	r22, r2
    38dc:	a8 01       	movw	r20, r16
    38de:	97 01       	movw	r18, r14
    38e0:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    38e4:	23 ed       	ldi	r18, 0xD3	; 211
    38e6:	39 ed       	ldi	r19, 0xD9	; 217
    38e8:	49 e4       	ldi	r20, 0x49	; 73
    38ea:	5a e3       	ldi	r21, 0x3A	; 58
    38ec:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    38f0:	9b 01       	movw	r18, r22
    38f2:	ac 01       	movw	r20, r24
    38f4:	c6 01       	movw	r24, r12
    38f6:	b5 01       	movw	r22, r10
    38f8:	0e 94 92 37 	call	0x6f24	; 0x6f24 <__addsf3>
    38fc:	9b 01       	movw	r18, r22
    38fe:	ac 01       	movw	r20, r24
    3900:	c4 01       	movw	r24, r8
    3902:	b3 01       	movw	r22, r6
    3904:	0e 94 92 37 	call	0x6f24	; 0x6f24 <__addsf3>
    3908:	9b 01       	movw	r18, r22
    390a:	ac 01       	movw	r20, r24
    390c:	20 93 16 06 	sts	0x0616, r18
    3910:	30 93 17 06 	sts	0x0617, r19
    3914:	40 93 18 06 	sts	0x0618, r20
    3918:	50 93 19 06 	sts	0x0619, r21

}
    391c:	28 96       	adiw	r28, 0x08	; 8
    391e:	0f b6       	in	r0, 0x3f	; 63
    3920:	f8 94       	cli
    3922:	de bf       	out	0x3e, r29	; 62
    3924:	0f be       	out	0x3f, r0	; 63
    3926:	cd bf       	out	0x3d, r28	; 61
    3928:	cf 91       	pop	r28
    392a:	df 91       	pop	r29
    392c:	1f 91       	pop	r17
    392e:	0f 91       	pop	r16
    3930:	ff 90       	pop	r15
    3932:	ef 90       	pop	r14
    3934:	df 90       	pop	r13
    3936:	cf 90       	pop	r12
    3938:	bf 90       	pop	r11
    393a:	af 90       	pop	r10
    393c:	9f 90       	pop	r9
    393e:	8f 90       	pop	r8
    3940:	7f 90       	pop	r7
    3942:	6f 90       	pop	r6
    3944:	5f 90       	pop	r5
    3946:	4f 90       	pop	r4
    3948:	3f 90       	pop	r3
    394a:	2f 90       	pop	r2
    394c:	08 95       	ret

0000394e <IMU_Reset>:


void IMU_Reset()
{
	
	AnglePitch=0;
    394e:	80 e0       	ldi	r24, 0x00	; 0
    3950:	90 e0       	ldi	r25, 0x00	; 0
    3952:	dc 01       	movw	r26, r24
    3954:	80 93 16 06 	sts	0x0616, r24
    3958:	90 93 17 06 	sts	0x0617, r25
    395c:	a0 93 18 06 	sts	0x0618, r26
    3960:	b0 93 19 06 	sts	0x0619, r27
	AngleRoll=0;
    3964:	80 93 de 06 	sts	0x06DE, r24
    3968:	90 93 df 06 	sts	0x06DF, r25
    396c:	a0 93 e0 06 	sts	0x06E0, r26
    3970:	b0 93 e1 06 	sts	0x06E1, r27
	AngleZ=0;
    3974:	80 93 6c 06 	sts	0x066C, r24
    3978:	90 93 6d 06 	sts	0x066D, r25
    397c:	a0 93 6e 06 	sts	0x066E, r26
    3980:	b0 93 6f 06 	sts	0x066F, r27
	
}
    3984:	08 95       	ret

00003986 <IMU>:
//////////////////////////////////////////////////////////////////////////
// inspired by link: http://scolton.blogspot.com/2012/09/a-bit-more-kk20-modding.html
// Although I implement PID and super position in http://hefnycopter.net/index.php/developing-source-code/22-quadcopter-control-function-layers.html
void IMU (void)
{
    3986:	2f 92       	push	r2
    3988:	3f 92       	push	r3
    398a:	4f 92       	push	r4
    398c:	5f 92       	push	r5
    398e:	6f 92       	push	r6
    3990:	7f 92       	push	r7
    3992:	8f 92       	push	r8
    3994:	9f 92       	push	r9
    3996:	af 92       	push	r10
    3998:	bf 92       	push	r11
    399a:	cf 92       	push	r12
    399c:	df 92       	push	r13
    399e:	ef 92       	push	r14
    39a0:	ff 92       	push	r15
    39a2:	0f 93       	push	r16
    39a4:	1f 93       	push	r17
    39a6:	df 93       	push	r29
    39a8:	cf 93       	push	r28
    39aa:	cd b7       	in	r28, 0x3d	; 61
    39ac:	de b7       	in	r29, 0x3e	; 62
    39ae:	2c 97       	sbiw	r28, 0x0c	; 12
    39b0:	0f b6       	in	r0, 0x3f	; 63
    39b2:	f8 94       	cli
    39b4:	de bf       	out	0x3e, r29	; 62
    39b6:	0f be       	out	0x3f, r0	; 63
    39b8:	cd bf       	out	0x3d, r28	; 61
	
		double Alpha;	
		double Beta;
	
	    // calculate ACC-Z
		Alpha = Config.AccParams[Z_INDEX].ComplementaryFilterAlpha / 1000.0;
    39ba:	60 91 49 07 	lds	r22, 0x0749
    39be:	70 91 4a 07 	lds	r23, 0x074A
    39c2:	88 27       	eor	r24, r24
    39c4:	77 fd       	sbrc	r23, 7
    39c6:	80 95       	com	r24
    39c8:	98 2f       	mov	r25, r24
    39ca:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    39ce:	20 e0       	ldi	r18, 0x00	; 0
    39d0:	30 e0       	ldi	r19, 0x00	; 0
    39d2:	4a e7       	ldi	r20, 0x7A	; 122
    39d4:	54 e4       	ldi	r21, 0x44	; 68
    39d6:	0e 94 fa 37 	call	0x6ff4	; 0x6ff4 <__divsf3>
    39da:	7b 01       	movw	r14, r22
    39dc:	8c 01       	movw	r16, r24
		Beta = 1- Alpha; // complementary filter to remove noise
		CompAccZ = (double) (Alpha * CompAccZ) + (double) (Beta * Sensors_Latest[ACC_Z_Index]);
    39de:	a0 90 4f 06 	lds	r10, 0x064F
    39e2:	b0 90 50 06 	lds	r11, 0x0650
    39e6:	c0 90 51 06 	lds	r12, 0x0651
    39ea:	d0 90 52 06 	lds	r13, 0x0652
    39ee:	7f 2d       	mov	r23, r15
    39f0:	91 2f       	mov	r25, r17
    39f2:	20 91 37 06 	lds	r18, 0x0637
    39f6:	30 91 38 06 	lds	r19, 0x0638
    39fa:	40 91 39 06 	lds	r20, 0x0639
    39fe:	50 91 3a 06 	lds	r21, 0x063A
    3a02:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    3a06:	3b 01       	movw	r6, r22
    3a08:	4c 01       	movw	r8, r24
		double Alpha;	
		double Beta;
	
	    // calculate ACC-Z
		Alpha = Config.AccParams[Z_INDEX].ComplementaryFilterAlpha / 1000.0;
		Beta = 1- Alpha; // complementary filter to remove noise
    3a0a:	60 e0       	ldi	r22, 0x00	; 0
    3a0c:	70 e0       	ldi	r23, 0x00	; 0
    3a0e:	80 e8       	ldi	r24, 0x80	; 128
    3a10:	9f e3       	ldi	r25, 0x3F	; 63
    3a12:	2e 2d       	mov	r18, r14
    3a14:	3f 2d       	mov	r19, r15
    3a16:	40 2f       	mov	r20, r16
    3a18:	51 2f       	mov	r21, r17
    3a1a:	0e 94 91 37 	call	0x6f22	; 0x6f22 <__subsf3>
		CompAccZ = (double) (Alpha * CompAccZ) + (double) (Beta * Sensors_Latest[ACC_Z_Index]);
    3a1e:	a6 01       	movw	r20, r12
    3a20:	95 01       	movw	r18, r10
    3a22:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    3a26:	9b 01       	movw	r18, r22
    3a28:	ac 01       	movw	r20, r24
    3a2a:	c4 01       	movw	r24, r8
    3a2c:	b3 01       	movw	r22, r6
    3a2e:	0e 94 92 37 	call	0x6f24	; 0x6f24 <__addsf3>
    3a32:	60 93 37 06 	sts	0x0637, r22
    3a36:	70 93 38 06 	sts	0x0638, r23
    3a3a:	80 93 39 06 	sts	0x0639, r24
    3a3e:	90 93 3a 06 	sts	0x063A, r25
		
		// calculate YAW
		Alpha = Config.GyroParams[YAW_INDEX].ComplementaryFilterAlpha / 1000.0;
    3a42:	60 91 1f 07 	lds	r22, 0x071F
    3a46:	70 91 20 07 	lds	r23, 0x0720
    3a4a:	88 27       	eor	r24, r24
    3a4c:	77 fd       	sbrc	r23, 7
    3a4e:	80 95       	com	r24
    3a50:	98 2f       	mov	r25, r24
    3a52:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    3a56:	20 e0       	ldi	r18, 0x00	; 0
    3a58:	30 e0       	ldi	r19, 0x00	; 0
    3a5a:	4a e7       	ldi	r20, 0x7A	; 122
    3a5c:	54 e4       	ldi	r21, 0x44	; 68
    3a5e:	0e 94 fa 37 	call	0x6ff4	; 0x6ff4 <__divsf3>
    3a62:	7b 01       	movw	r14, r22
    3a64:	8c 01       	movw	r16, r24
		Beta = 1- Alpha; // complementary filter to remove noise
		CompGyroZ = (double) (Alpha * CompGyroZ) + (double) (Beta * Sensors_Latest[GYRO_Z_Index]);
    3a66:	a0 90 43 06 	lds	r10, 0x0643
    3a6a:	b0 90 44 06 	lds	r11, 0x0644
    3a6e:	c0 90 45 06 	lds	r12, 0x0645
    3a72:	d0 90 46 06 	lds	r13, 0x0646
    3a76:	7f 2d       	mov	r23, r15
    3a78:	91 2f       	mov	r25, r17
    3a7a:	20 91 1d 06 	lds	r18, 0x061D
    3a7e:	30 91 1e 06 	lds	r19, 0x061E
    3a82:	40 91 1f 06 	lds	r20, 0x061F
    3a86:	50 91 20 06 	lds	r21, 0x0620
    3a8a:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    3a8e:	3b 01       	movw	r6, r22
    3a90:	4c 01       	movw	r8, r24
		Beta = 1- Alpha; // complementary filter to remove noise
		CompAccZ = (double) (Alpha * CompAccZ) + (double) (Beta * Sensors_Latest[ACC_Z_Index]);
		
		// calculate YAW
		Alpha = Config.GyroParams[YAW_INDEX].ComplementaryFilterAlpha / 1000.0;
		Beta = 1- Alpha; // complementary filter to remove noise
    3a92:	60 e0       	ldi	r22, 0x00	; 0
    3a94:	70 e0       	ldi	r23, 0x00	; 0
    3a96:	80 e8       	ldi	r24, 0x80	; 128
    3a98:	9f e3       	ldi	r25, 0x3F	; 63
    3a9a:	2e 2d       	mov	r18, r14
    3a9c:	3f 2d       	mov	r19, r15
    3a9e:	40 2f       	mov	r20, r16
    3aa0:	51 2f       	mov	r21, r17
    3aa2:	0e 94 91 37 	call	0x6f22	; 0x6f22 <__subsf3>
		CompGyroZ = (double) (Alpha * CompGyroZ) + (double) (Beta * Sensors_Latest[GYRO_Z_Index]);
    3aa6:	a6 01       	movw	r20, r12
    3aa8:	95 01       	movw	r18, r10
    3aaa:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    3aae:	9b 01       	movw	r18, r22
    3ab0:	ac 01       	movw	r20, r24
    3ab2:	c4 01       	movw	r24, r8
    3ab4:	b3 01       	movw	r22, r6
    3ab6:	0e 94 92 37 	call	0x6f24	; 0x6f24 <__addsf3>
    3aba:	60 93 1d 06 	sts	0x061D, r22
    3abe:	70 93 1e 06 	sts	0x061E, r23
    3ac2:	80 93 1f 06 	sts	0x061F, r24
    3ac6:	90 93 20 06 	sts	0x0620, r25
		
		Alpha = Config.GyroParams[PITCH_INDEX].ComplementaryFilterAlpha / 1000.0;
    3aca:	60 91 03 07 	lds	r22, 0x0703
    3ace:	70 91 04 07 	lds	r23, 0x0704
    3ad2:	88 27       	eor	r24, r24
    3ad4:	77 fd       	sbrc	r23, 7
    3ad6:	80 95       	com	r24
    3ad8:	98 2f       	mov	r25, r24
    3ada:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    3ade:	20 e0       	ldi	r18, 0x00	; 0
    3ae0:	30 e0       	ldi	r19, 0x00	; 0
    3ae2:	4a e7       	ldi	r20, 0x7A	; 122
    3ae4:	54 e4       	ldi	r21, 0x44	; 68
    3ae6:	0e 94 fa 37 	call	0x6ff4	; 0x6ff4 <__divsf3>
    3aea:	7b 01       	movw	r14, r22
    3aec:	8c 01       	movw	r16, r24
		Beta = 1- Alpha; // complementary filter to remove noise
		CompGyroPitch = (double) (Alpha * CompGyroPitch) + (double) (Beta * Sensors_Latest[GYRO_PITCH_Index]);
    3aee:	a0 90 3f 06 	lds	r10, 0x063F
    3af2:	b0 90 40 06 	lds	r11, 0x0640
    3af6:	c0 90 41 06 	lds	r12, 0x0641
    3afa:	d0 90 42 06 	lds	r13, 0x0642
    3afe:	7f 2d       	mov	r23, r15
    3b00:	91 2f       	mov	r25, r17
    3b02:	20 91 e0 05 	lds	r18, 0x05E0
    3b06:	30 91 e1 05 	lds	r19, 0x05E1
    3b0a:	40 91 e2 05 	lds	r20, 0x05E2
    3b0e:	50 91 e3 05 	lds	r21, 0x05E3
    3b12:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    3b16:	3b 01       	movw	r6, r22
    3b18:	4c 01       	movw	r8, r24
		Alpha = Config.GyroParams[YAW_INDEX].ComplementaryFilterAlpha / 1000.0;
		Beta = 1- Alpha; // complementary filter to remove noise
		CompGyroZ = (double) (Alpha * CompGyroZ) + (double) (Beta * Sensors_Latest[GYRO_Z_Index]);
		
		Alpha = Config.GyroParams[PITCH_INDEX].ComplementaryFilterAlpha / 1000.0;
		Beta = 1- Alpha; // complementary filter to remove noise
    3b1a:	60 e0       	ldi	r22, 0x00	; 0
    3b1c:	70 e0       	ldi	r23, 0x00	; 0
    3b1e:	80 e8       	ldi	r24, 0x80	; 128
    3b20:	9f e3       	ldi	r25, 0x3F	; 63
    3b22:	2e 2d       	mov	r18, r14
    3b24:	3f 2d       	mov	r19, r15
    3b26:	40 2f       	mov	r20, r16
    3b28:	51 2f       	mov	r21, r17
    3b2a:	0e 94 91 37 	call	0x6f22	; 0x6f22 <__subsf3>
		CompGyroPitch = (double) (Alpha * CompGyroPitch) + (double) (Beta * Sensors_Latest[GYRO_PITCH_Index]);
    3b2e:	a6 01       	movw	r20, r12
    3b30:	95 01       	movw	r18, r10
    3b32:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    3b36:	9b 01       	movw	r18, r22
    3b38:	ac 01       	movw	r20, r24
    3b3a:	c4 01       	movw	r24, r8
    3b3c:	b3 01       	movw	r22, r6
    3b3e:	0e 94 92 37 	call	0x6f24	; 0x6f24 <__addsf3>
    3b42:	d6 2e       	mov	r13, r22
    3b44:	c7 2e       	mov	r12, r23
    3b46:	b8 2e       	mov	r11, r24
    3b48:	a9 2e       	mov	r10, r25
    3b4a:	a6 01       	movw	r20, r12
    3b4c:	95 01       	movw	r18, r10
    3b4e:	85 2f       	mov	r24, r21
    3b50:	94 2f       	mov	r25, r20
    3b52:	a3 2f       	mov	r26, r19
    3b54:	b2 2f       	mov	r27, r18
    3b56:	80 93 e0 05 	sts	0x05E0, r24
    3b5a:	90 93 e1 05 	sts	0x05E1, r25
    3b5e:	a0 93 e2 05 	sts	0x05E2, r26
    3b62:	b0 93 e3 05 	sts	0x05E3, r27
		Alpha = Config.GyroParams[ROLL_INDEX].ComplementaryFilterAlpha / 1000.0;
    3b66:	60 91 11 07 	lds	r22, 0x0711
    3b6a:	70 91 12 07 	lds	r23, 0x0712
    3b6e:	88 27       	eor	r24, r24
    3b70:	77 fd       	sbrc	r23, 7
    3b72:	80 95       	com	r24
    3b74:	98 2f       	mov	r25, r24
    3b76:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    3b7a:	20 e0       	ldi	r18, 0x00	; 0
    3b7c:	30 e0       	ldi	r19, 0x00	; 0
    3b7e:	4a e7       	ldi	r20, 0x7A	; 122
    3b80:	54 e4       	ldi	r21, 0x44	; 68
    3b82:	0e 94 fa 37 	call	0x6ff4	; 0x6ff4 <__divsf3>
    3b86:	7b 01       	movw	r14, r22
    3b88:	8c 01       	movw	r16, r24
		Beta = 1- Alpha; // complementary filter to remove noise
		CompGyroRoll  = (double) (Alpha * CompGyroRoll)  + (double) (Beta * Sensors_Latest[GYRO_ROLL_Index]);
    3b8a:	60 90 3b 06 	lds	r6, 0x063B
    3b8e:	70 90 3c 06 	lds	r7, 0x063C
    3b92:	80 90 3d 06 	lds	r8, 0x063D
    3b96:	90 90 3e 06 	lds	r9, 0x063E
    3b9a:	7f 2d       	mov	r23, r15
    3b9c:	91 2f       	mov	r25, r17
    3b9e:	20 91 72 06 	lds	r18, 0x0672
    3ba2:	30 91 73 06 	lds	r19, 0x0673
    3ba6:	40 91 74 06 	lds	r20, 0x0674
    3baa:	50 91 75 06 	lds	r21, 0x0675
    3bae:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    3bb2:	1b 01       	movw	r2, r22
    3bb4:	2c 01       	movw	r4, r24
		
		Alpha = Config.GyroParams[PITCH_INDEX].ComplementaryFilterAlpha / 1000.0;
		Beta = 1- Alpha; // complementary filter to remove noise
		CompGyroPitch = (double) (Alpha * CompGyroPitch) + (double) (Beta * Sensors_Latest[GYRO_PITCH_Index]);
		Alpha = Config.GyroParams[ROLL_INDEX].ComplementaryFilterAlpha / 1000.0;
		Beta = 1- Alpha; // complementary filter to remove noise
    3bb6:	60 e0       	ldi	r22, 0x00	; 0
    3bb8:	70 e0       	ldi	r23, 0x00	; 0
    3bba:	80 e8       	ldi	r24, 0x80	; 128
    3bbc:	9f e3       	ldi	r25, 0x3F	; 63
    3bbe:	2e 2d       	mov	r18, r14
    3bc0:	3f 2d       	mov	r19, r15
    3bc2:	40 2f       	mov	r20, r16
    3bc4:	51 2f       	mov	r21, r17
    3bc6:	0e 94 91 37 	call	0x6f22	; 0x6f22 <__subsf3>
		CompGyroRoll  = (double) (Alpha * CompGyroRoll)  + (double) (Beta * Sensors_Latest[GYRO_ROLL_Index]);
    3bca:	a4 01       	movw	r20, r8
    3bcc:	93 01       	movw	r18, r6
    3bce:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    3bd2:	9b 01       	movw	r18, r22
    3bd4:	ac 01       	movw	r20, r24
    3bd6:	c2 01       	movw	r24, r4
    3bd8:	b1 01       	movw	r22, r2
    3bda:	0e 94 92 37 	call	0x6f24	; 0x6f24 <__addsf3>
    3bde:	60 93 72 06 	sts	0x0672, r22
    3be2:	70 93 73 06 	sts	0x0673, r23
    3be6:	80 93 74 06 	sts	0x0674, r24
    3bea:	90 93 75 06 	sts	0x0675, r25
		
					
		// GYRO Always calculated.
		gyroPitch =	PID_Calculate (Config.GyroParams[PITCH_INDEX],	&PID_GyroTerms[PITCH_INDEX],CompGyroPitch);	
    3bee:	00 d0       	rcall	.+0      	; 0x3bf0 <IMU+0x26a>
    3bf0:	00 d0       	rcall	.+0      	; 0x3bf2 <IMU+0x26c>
    3bf2:	a6 01       	movw	r20, r12
    3bf4:	95 01       	movw	r18, r10
    3bf6:	85 2f       	mov	r24, r21
    3bf8:	94 2f       	mov	r25, r20
    3bfa:	a3 2f       	mov	r26, r19
    3bfc:	b2 2f       	mov	r27, r18
    3bfe:	ed b7       	in	r30, 0x3d	; 61
    3c00:	fe b7       	in	r31, 0x3e	; 62
    3c02:	81 83       	std	Z+1, r24	; 0x01
    3c04:	92 83       	std	Z+2, r25	; 0x02
    3c06:	a3 83       	std	Z+3, r26	; 0x03
    3c08:	b4 83       	std	Z+4, r27	; 0x04
    3c0a:	c0 90 f7 06 	lds	r12, 0x06F7
    3c0e:	d0 90 f8 06 	lds	r13, 0x06F8
    3c12:	e0 90 f9 06 	lds	r14, 0x06F9
    3c16:	f0 90 fa 06 	lds	r15, 0x06FA
    3c1a:	00 91 fb 06 	lds	r16, 0x06FB
    3c1e:	10 91 fc 06 	lds	r17, 0x06FC
    3c22:	20 91 fd 06 	lds	r18, 0x06FD
    3c26:	30 91 fe 06 	lds	r19, 0x06FE
    3c2a:	40 91 ff 06 	lds	r20, 0x06FF
    3c2e:	50 91 00 07 	lds	r21, 0x0700
    3c32:	60 91 01 07 	lds	r22, 0x0701
    3c36:	70 91 02 07 	lds	r23, 0x0702
    3c3a:	80 91 03 07 	lds	r24, 0x0703
    3c3e:	90 91 04 07 	lds	r25, 0x0704
    3c42:	a6 e7       	ldi	r26, 0x76	; 118
    3c44:	aa 2e       	mov	r10, r26
    3c46:	a6 e0       	ldi	r26, 0x06	; 6
    3c48:	ba 2e       	mov	r11, r26
    3c4a:	0e 94 3e 1a 	call	0x347c	; 0x347c <PID_Calculate>
    3c4e:	0e 94 62 38 	call	0x70c4	; 0x70c4 <__fixsfsi>
    3c52:	70 93 36 06 	sts	0x0636, r23
    3c56:	60 93 35 06 	sts	0x0635, r22
		gyroRoll  = PID_Calculate (Config.GyroParams[ROLL_INDEX],	&PID_GyroTerms[ROLL_INDEX],CompGyroRoll); 
    3c5a:	80 91 72 06 	lds	r24, 0x0672
    3c5e:	90 91 73 06 	lds	r25, 0x0673
    3c62:	a0 91 74 06 	lds	r26, 0x0674
    3c66:	b0 91 75 06 	lds	r27, 0x0675
    3c6a:	ed b7       	in	r30, 0x3d	; 61
    3c6c:	fe b7       	in	r31, 0x3e	; 62
    3c6e:	81 83       	std	Z+1, r24	; 0x01
    3c70:	92 83       	std	Z+2, r25	; 0x02
    3c72:	a3 83       	std	Z+3, r26	; 0x03
    3c74:	b4 83       	std	Z+4, r27	; 0x04
    3c76:	c0 90 05 07 	lds	r12, 0x0705
    3c7a:	d0 90 06 07 	lds	r13, 0x0706
    3c7e:	e0 90 07 07 	lds	r14, 0x0707
    3c82:	f0 90 08 07 	lds	r15, 0x0708
    3c86:	00 91 09 07 	lds	r16, 0x0709
    3c8a:	10 91 0a 07 	lds	r17, 0x070A
    3c8e:	20 91 0b 07 	lds	r18, 0x070B
    3c92:	30 91 0c 07 	lds	r19, 0x070C
    3c96:	40 91 0d 07 	lds	r20, 0x070D
    3c9a:	50 91 0e 07 	lds	r21, 0x070E
    3c9e:	60 91 0f 07 	lds	r22, 0x070F
    3ca2:	70 91 10 07 	lds	r23, 0x0710
    3ca6:	80 91 11 07 	lds	r24, 0x0711
    3caa:	90 91 12 07 	lds	r25, 0x0712
    3cae:	fe e8       	ldi	r31, 0x8E	; 142
    3cb0:	af 2e       	mov	r10, r31
    3cb2:	f6 e0       	ldi	r31, 0x06	; 6
    3cb4:	bf 2e       	mov	r11, r31
    3cb6:	0e 94 3e 1a 	call	0x347c	; 0x347c <PID_Calculate>
    3cba:	0e 94 62 38 	call	0x70c4	; 0x70c4 <__fixsfsi>
    3cbe:	70 93 b7 05 	sts	0x05B7, r23
    3cc2:	60 93 b6 05 	sts	0x05B6, r22
		gyroYaw   = PID_Calculate (Config.GyroParams[YAW_INDEX],	&PID_GyroTerms[YAW_INDEX],CompGyroZ -((double)((float)RX_Snapshot[RXChannel_RUD]  * 0.5f))); 
    3cc6:	0d b7       	in	r16, 0x3d	; 61
    3cc8:	1e b7       	in	r17, 0x3e	; 62
    3cca:	0f 5f       	subi	r16, 0xFF	; 255
    3ccc:	1f 4f       	sbci	r17, 0xFF	; 255
    3cce:	60 91 c2 05 	lds	r22, 0x05C2
    3cd2:	70 91 c3 05 	lds	r23, 0x05C3
    3cd6:	88 27       	eor	r24, r24
    3cd8:	77 fd       	sbrc	r23, 7
    3cda:	80 95       	com	r24
    3cdc:	98 2f       	mov	r25, r24
    3cde:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    3ce2:	20 e0       	ldi	r18, 0x00	; 0
    3ce4:	30 e0       	ldi	r19, 0x00	; 0
    3ce6:	40 e0       	ldi	r20, 0x00	; 0
    3ce8:	5f e3       	ldi	r21, 0x3F	; 63
    3cea:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    3cee:	9b 01       	movw	r18, r22
    3cf0:	ac 01       	movw	r20, r24
    3cf2:	60 91 1d 06 	lds	r22, 0x061D
    3cf6:	70 91 1e 06 	lds	r23, 0x061E
    3cfa:	80 91 1f 06 	lds	r24, 0x061F
    3cfe:	90 91 20 06 	lds	r25, 0x0620
    3d02:	0e 94 91 37 	call	0x6f22	; 0x6f22 <__subsf3>
    3d06:	f8 01       	movw	r30, r16
    3d08:	60 83       	st	Z, r22
    3d0a:	71 83       	std	Z+1, r23	; 0x01
    3d0c:	82 83       	std	Z+2, r24	; 0x02
    3d0e:	93 83       	std	Z+3, r25	; 0x03
    3d10:	c0 90 13 07 	lds	r12, 0x0713
    3d14:	d0 90 14 07 	lds	r13, 0x0714
    3d18:	e0 90 15 07 	lds	r14, 0x0715
    3d1c:	f0 90 16 07 	lds	r15, 0x0716
    3d20:	00 91 17 07 	lds	r16, 0x0717
    3d24:	10 91 18 07 	lds	r17, 0x0718
    3d28:	20 91 19 07 	lds	r18, 0x0719
    3d2c:	30 91 1a 07 	lds	r19, 0x071A
    3d30:	40 91 1b 07 	lds	r20, 0x071B
    3d34:	50 91 1c 07 	lds	r21, 0x071C
    3d38:	60 91 1d 07 	lds	r22, 0x071D
    3d3c:	70 91 1e 07 	lds	r23, 0x071E
    3d40:	80 91 1f 07 	lds	r24, 0x071F
    3d44:	90 91 20 07 	lds	r25, 0x0720
    3d48:	e6 ea       	ldi	r30, 0xA6	; 166
    3d4a:	ae 2e       	mov	r10, r30
    3d4c:	e6 e0       	ldi	r30, 0x06	; 6
    3d4e:	be 2e       	mov	r11, r30
    3d50:	0e 94 3e 1a 	call	0x347c	; 0x347c <PID_Calculate>
    3d54:	0e 94 62 38 	call	0x70c4	; 0x70c4 <__fixsfsi>
    3d58:	70 93 e6 06 	sts	0x06E6, r23
    3d5c:	60 93 e5 06 	sts	0x06E5, r22
	
			
		// Read ACC and Trims
		// ACC directions are same as GYRO direction [we added "-" for this purpose] 
		double APitch = - Sensors_Latest[ACC_PITCH_Index] - Config.Acc_Pitch_Trim;
    3d60:	e0 90 47 06 	lds	r14, 0x0647
    3d64:	f0 90 48 06 	lds	r15, 0x0648
    3d68:	00 91 49 06 	lds	r16, 0x0649
    3d6c:	10 91 4a 06 	lds	r17, 0x064A
    3d70:	17 fb       	bst	r17, 7
    3d72:	10 95       	com	r17
    3d74:	17 f9       	bld	r17, 7
    3d76:	10 95       	com	r17
    3d78:	60 91 5a 07 	lds	r22, 0x075A
    3d7c:	77 27       	eor	r23, r23
    3d7e:	67 fd       	sbrc	r22, 7
    3d80:	70 95       	com	r23
    3d82:	87 2f       	mov	r24, r23
    3d84:	97 2f       	mov	r25, r23
    3d86:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    3d8a:	9b 01       	movw	r18, r22
    3d8c:	ac 01       	movw	r20, r24
    3d8e:	c8 01       	movw	r24, r16
    3d90:	b7 01       	movw	r22, r14
    3d92:	0e 94 91 37 	call	0x6f22	; 0x6f22 <__subsf3>
    3d96:	69 83       	std	Y+1, r22	; 0x01
    3d98:	7a 83       	std	Y+2, r23	; 0x02
    3d9a:	8b 83       	std	Y+3, r24	; 0x03
    3d9c:	9c 83       	std	Y+4, r25	; 0x04
		double ARoll  = - Sensors_Latest[ACC_ROLL_Index]  - Config.Acc_Roll_Trim;
    3d9e:	e0 90 4b 06 	lds	r14, 0x064B
    3da2:	f0 90 4c 06 	lds	r15, 0x064C
    3da6:	00 91 4d 06 	lds	r16, 0x064D
    3daa:	10 91 4e 06 	lds	r17, 0x064E
    3dae:	17 fb       	bst	r17, 7
    3db0:	10 95       	com	r17
    3db2:	17 f9       	bld	r17, 7
    3db4:	10 95       	com	r17
    3db6:	60 91 5b 07 	lds	r22, 0x075B
    3dba:	77 27       	eor	r23, r23
    3dbc:	67 fd       	sbrc	r22, 7
    3dbe:	70 95       	com	r23
    3dc0:	87 2f       	mov	r24, r23
    3dc2:	97 2f       	mov	r25, r23
    3dc4:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    3dc8:	9b 01       	movw	r18, r22
    3dca:	ac 01       	movw	r20, r24
    3dcc:	c8 01       	movw	r24, r16
    3dce:	b7 01       	movw	r22, r14
    3dd0:	0e 94 91 37 	call	0x6f22	; 0x6f22 <__subsf3>
    3dd4:	6d 83       	std	Y+5, r22	; 0x05
    3dd6:	7e 83       	std	Y+6, r23	; 0x06
    3dd8:	8f 83       	std	Y+7, r24	; 0x07
    3dda:	98 87       	std	Y+8, r25	; 0x08
		double DT_YAW =  (double)Sensors_Latest[GYRO_Z_Index] * GYRO_RATE * TimeDef * 0.001; 
    3ddc:	60 91 43 06 	lds	r22, 0x0643
    3de0:	70 91 44 06 	lds	r23, 0x0644
    3de4:	80 91 45 06 	lds	r24, 0x0645
    3de8:	90 91 46 06 	lds	r25, 0x0646
    3dec:	23 ed       	ldi	r18, 0xD3	; 211
    3dee:	39 ed       	ldi	r19, 0xD9	; 217
    3df0:	49 e4       	ldi	r20, 0x49	; 73
    3df2:	5a e3       	ldi	r21, 0x3A	; 58
    3df4:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    3df8:	7b 01       	movw	r14, r22
    3dfa:	8c 01       	movw	r16, r24
    3dfc:	60 91 e2 06 	lds	r22, 0x06E2
    3e00:	70 91 e3 06 	lds	r23, 0x06E3
    3e04:	80 e0       	ldi	r24, 0x00	; 0
    3e06:	90 e0       	ldi	r25, 0x00	; 0
    3e08:	0e 94 93 38 	call	0x7126	; 0x7126 <__floatunsisf>
    3e0c:	9b 01       	movw	r18, r22
    3e0e:	ac 01       	movw	r20, r24
    3e10:	c8 01       	movw	r24, r16
    3e12:	b7 01       	movw	r22, r14
    3e14:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    3e18:	2f e6       	ldi	r18, 0x6F	; 111
    3e1a:	32 e1       	ldi	r19, 0x12	; 18
    3e1c:	43 e8       	ldi	r20, 0x83	; 131
    3e1e:	5a e3       	ldi	r21, 0x3A	; 58
    3e20:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    3e24:	69 87       	std	Y+9, r22	; 0x09
    3e26:	7a 87       	std	Y+10, r23	; 0x0a
    3e28:	8b 87       	std	Y+11, r24	; 0x0b
    3e2a:	9c 87       	std	Y+12, r25	; 0x0c
		
		if ( TCNT1H > TCNT1H_OLD) 
    3e2c:	20 91 85 00 	lds	r18, 0x0085
    3e30:	80 91 dc 06 	lds	r24, 0x06DC
    3e34:	90 91 dd 06 	lds	r25, 0x06DD
    3e38:	30 e0       	ldi	r19, 0x00	; 0
    3e3a:	0f 90       	pop	r0
    3e3c:	0f 90       	pop	r0
    3e3e:	0f 90       	pop	r0
    3e40:	0f 90       	pop	r0
    3e42:	82 17       	cp	r24, r18
    3e44:	93 07       	cpc	r25, r19
    3e46:	50 f4       	brcc	.+20     	; 0x3e5c <IMU+0x4d6>
		{
			TimeDef = TCNT1H - TCNT1H_OLD;
    3e48:	80 91 85 00 	lds	r24, 0x0085
    3e4c:	20 91 dc 06 	lds	r18, 0x06DC
    3e50:	30 91 dd 06 	lds	r19, 0x06DD
    3e54:	90 e0       	ldi	r25, 0x00	; 0
    3e56:	82 1b       	sub	r24, r18
    3e58:	93 0b       	sbc	r25, r19
    3e5a:	0a c0       	rjmp	.+20     	; 0x3e70 <IMU+0x4ea>
		}
		else
		{
			TimeDef = 0xffff - TCNT1H_OLD + TCNT1H ;
    3e5c:	80 91 dc 06 	lds	r24, 0x06DC
    3e60:	90 91 dd 06 	lds	r25, 0x06DD
    3e64:	20 91 85 00 	lds	r18, 0x0085
    3e68:	80 95       	com	r24
    3e6a:	90 95       	com	r25
    3e6c:	82 0f       	add	r24, r18
    3e6e:	91 1d       	adc	r25, r1
    3e70:	90 93 e3 06 	sts	0x06E3, r25
    3e74:	80 93 e2 06 	sts	0x06E2, r24
		}
		TCNT1H_OLD += TimeDef;
    3e78:	80 91 dc 06 	lds	r24, 0x06DC
    3e7c:	90 91 dd 06 	lds	r25, 0x06DD
    3e80:	60 91 e2 06 	lds	r22, 0x06E2
    3e84:	70 91 e3 06 	lds	r23, 0x06E3
    3e88:	86 0f       	add	r24, r22
    3e8a:	97 1f       	adc	r25, r23
    3e8c:	90 93 dd 06 	sts	0x06DD, r25
    3e90:	80 93 dc 06 	sts	0x06DC, r24
		
		//// Do the Magic of IMU LEVELING here
		//// check also : http://scolton.blogspot.com/2012/09/fun-with-complementary-filter-multiwii.html
		AnglePitch = AnglePitch
				   + (double)Sensors_Latest[GYRO_PITCH_Index] * GYRO_RATE * TimeDef * 0.001
    3e94:	a0 90 16 06 	lds	r10, 0x0616
    3e98:	b0 90 17 06 	lds	r11, 0x0617
    3e9c:	c0 90 18 06 	lds	r12, 0x0618
    3ea0:	d0 90 19 06 	lds	r13, 0x0619
    3ea4:	e0 90 3f 06 	lds	r14, 0x063F
    3ea8:	f0 90 40 06 	lds	r15, 0x0640
    3eac:	00 91 41 06 	lds	r16, 0x0641
    3eb0:	10 91 42 06 	lds	r17, 0x0642
    3eb4:	80 e0       	ldi	r24, 0x00	; 0
    3eb6:	90 e0       	ldi	r25, 0x00	; 0
    3eb8:	0e 94 93 38 	call	0x7126	; 0x7126 <__floatunsisf>
    3ebc:	1b 01       	movw	r2, r22
    3ebe:	2c 01       	movw	r4, r24
					   + (sin(AngleRoll * DEG_TO_RAD) * DT_YAW)  // integrate component of yaw rate into pitch angle
    3ec0:	60 91 de 06 	lds	r22, 0x06DE
    3ec4:	70 91 df 06 	lds	r23, 0x06DF
    3ec8:	80 91 e0 06 	lds	r24, 0x06E0
    3ecc:	90 91 e1 06 	lds	r25, 0x06E1
    3ed0:	2f e7       	ldi	r18, 0x7F	; 127
    3ed2:	3d e4       	ldi	r19, 0x4D	; 77
    3ed4:	46 e5       	ldi	r20, 0x56	; 86
    3ed6:	5c e3       	ldi	r21, 0x3C	; 60
    3ed8:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    3edc:	0e 94 ac 39 	call	0x7358	; 0x7358 <sin>
    3ee0:	3b 01       	movw	r6, r22
    3ee2:	4c 01       	movw	r8, r24
		TCNT1H_OLD += TimeDef;
		
		//// Do the Magic of IMU LEVELING here
		//// check also : http://scolton.blogspot.com/2012/09/fun-with-complementary-filter-multiwii.html
		AnglePitch = AnglePitch
				   + (double)Sensors_Latest[GYRO_PITCH_Index] * GYRO_RATE * TimeDef * 0.001
    3ee4:	c8 01       	movw	r24, r16
    3ee6:	b7 01       	movw	r22, r14
    3ee8:	23 ed       	ldi	r18, 0xD3	; 211
    3eea:	39 ed       	ldi	r19, 0xD9	; 217
    3eec:	49 e4       	ldi	r20, 0x49	; 73
    3eee:	5a e3       	ldi	r21, 0x3A	; 58
    3ef0:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    3ef4:	a2 01       	movw	r20, r4
    3ef6:	91 01       	movw	r18, r2
    3ef8:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    3efc:	2f e6       	ldi	r18, 0x6F	; 111
    3efe:	32 e1       	ldi	r19, 0x12	; 18
    3f00:	43 e8       	ldi	r20, 0x83	; 131
    3f02:	5a e3       	ldi	r21, 0x3A	; 58
    3f04:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    3f08:	9b 01       	movw	r18, r22
    3f0a:	ac 01       	movw	r20, r24
    3f0c:	c6 01       	movw	r24, r12
    3f0e:	b5 01       	movw	r22, r10
    3f10:	0e 94 92 37 	call	0x6f24	; 0x6f24 <__addsf3>
    3f14:	7b 01       	movw	r14, r22
    3f16:	8c 01       	movw	r16, r24
					   + (sin(AngleRoll * DEG_TO_RAD) * DT_YAW)  // integrate component of yaw rate into pitch angle
    3f18:	c4 01       	movw	r24, r8
    3f1a:	b3 01       	movw	r22, r6
    3f1c:	b9 85       	ldd	r27, Y+9	; 0x09
    3f1e:	aa 85       	ldd	r26, Y+10	; 0x0a
    3f20:	db 84       	ldd	r13, Y+11	; 0x0b
    3f22:	cc 84       	ldd	r12, Y+12	; 0x0c
    3f24:	2b 2f       	mov	r18, r27
    3f26:	3a 2f       	mov	r19, r26
    3f28:	4d 2d       	mov	r20, r13
    3f2a:	5c 2d       	mov	r21, r12
    3f2c:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    3f30:	9b 01       	movw	r18, r22
    3f32:	ac 01       	movw	r20, r24
    3f34:	c8 01       	movw	r24, r16
    3f36:	b7 01       	movw	r22, r14
    3f38:	0e 94 92 37 	call	0x6f24	; 0x6f24 <__addsf3>
    3f3c:	9b 01       	movw	r18, r22
    3f3e:	ac 01       	movw	r20, r24
		}
		TCNT1H_OLD += TimeDef;
		
		//// Do the Magic of IMU LEVELING here
		//// check also : http://scolton.blogspot.com/2012/09/fun-with-complementary-filter-multiwii.html
		AnglePitch = AnglePitch
    3f40:	20 93 16 06 	sts	0x0616, r18
    3f44:	30 93 17 06 	sts	0x0617, r19
    3f48:	40 93 18 06 	sts	0x0618, r20
    3f4c:	50 93 19 06 	sts	0x0619, r21
				   + (double)Sensors_Latest[GYRO_PITCH_Index] * GYRO_RATE * TimeDef * 0.001
					   + (sin(AngleRoll * DEG_TO_RAD) * DT_YAW)  // integrate component of yaw rate into pitch angle
						;
		AngleRoll = AngleRoll  
				  + (double)Sensors_Latest[GYRO_ROLL_Index]  * GYRO_RATE * TimeDef * 0.001
    3f50:	a0 90 de 06 	lds	r10, 0x06DE
    3f54:	b0 90 df 06 	lds	r11, 0x06DF
    3f58:	c0 90 e0 06 	lds	r12, 0x06E0
    3f5c:	d0 90 e1 06 	lds	r13, 0x06E1
    3f60:	e0 90 3b 06 	lds	r14, 0x063B
    3f64:	f0 90 3c 06 	lds	r15, 0x063C
    3f68:	00 91 3d 06 	lds	r16, 0x063D
    3f6c:	10 91 3e 06 	lds	r17, 0x063E
					  - (sin(AnglePitch * DEG_TO_RAD) * DT_YAW)  // integrate component of yaw rate into roll angle
    3f70:	60 91 16 06 	lds	r22, 0x0616
    3f74:	70 91 17 06 	lds	r23, 0x0617
    3f78:	80 91 18 06 	lds	r24, 0x0618
    3f7c:	90 91 19 06 	lds	r25, 0x0619
    3f80:	2f e7       	ldi	r18, 0x7F	; 127
    3f82:	3d e4       	ldi	r19, 0x4D	; 77
    3f84:	46 e5       	ldi	r20, 0x56	; 86
    3f86:	5c e3       	ldi	r21, 0x3C	; 60
    3f88:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    3f8c:	0e 94 ac 39 	call	0x7358	; 0x7358 <sin>
    3f90:	3b 01       	movw	r6, r22
    3f92:	4c 01       	movw	r8, r24
		AnglePitch = AnglePitch
				   + (double)Sensors_Latest[GYRO_PITCH_Index] * GYRO_RATE * TimeDef * 0.001
					   + (sin(AngleRoll * DEG_TO_RAD) * DT_YAW)  // integrate component of yaw rate into pitch angle
						;
		AngleRoll = AngleRoll  
				  + (double)Sensors_Latest[GYRO_ROLL_Index]  * GYRO_RATE * TimeDef * 0.001
    3f94:	c8 01       	movw	r24, r16
    3f96:	b7 01       	movw	r22, r14
    3f98:	23 ed       	ldi	r18, 0xD3	; 211
    3f9a:	39 ed       	ldi	r19, 0xD9	; 217
    3f9c:	49 e4       	ldi	r20, 0x49	; 73
    3f9e:	5a e3       	ldi	r21, 0x3A	; 58
    3fa0:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    3fa4:	a2 01       	movw	r20, r4
    3fa6:	91 01       	movw	r18, r2
    3fa8:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    3fac:	2f e6       	ldi	r18, 0x6F	; 111
    3fae:	32 e1       	ldi	r19, 0x12	; 18
    3fb0:	43 e8       	ldi	r20, 0x83	; 131
    3fb2:	5a e3       	ldi	r21, 0x3A	; 58
    3fb4:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    3fb8:	9b 01       	movw	r18, r22
    3fba:	ac 01       	movw	r20, r24
    3fbc:	c6 01       	movw	r24, r12
    3fbe:	b5 01       	movw	r22, r10
    3fc0:	0e 94 92 37 	call	0x6f24	; 0x6f24 <__addsf3>
    3fc4:	7b 01       	movw	r14, r22
    3fc6:	8c 01       	movw	r16, r24
					  - (sin(AnglePitch * DEG_TO_RAD) * DT_YAW)  // integrate component of yaw rate into roll angle
    3fc8:	c4 01       	movw	r24, r8
    3fca:	b3 01       	movw	r22, r6
    3fcc:	b9 85       	ldd	r27, Y+9	; 0x09
    3fce:	aa 85       	ldd	r26, Y+10	; 0x0a
    3fd0:	db 84       	ldd	r13, Y+11	; 0x0b
    3fd2:	cc 84       	ldd	r12, Y+12	; 0x0c
    3fd4:	2b 2f       	mov	r18, r27
    3fd6:	3a 2f       	mov	r19, r26
    3fd8:	4d 2d       	mov	r20, r13
    3fda:	5c 2d       	mov	r21, r12
    3fdc:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    3fe0:	9b 01       	movw	r18, r22
    3fe2:	ac 01       	movw	r20, r24
    3fe4:	c8 01       	movw	r24, r16
    3fe6:	b7 01       	movw	r22, r14
    3fe8:	0e 94 91 37 	call	0x6f22	; 0x6f22 <__subsf3>
    3fec:	9b 01       	movw	r18, r22
    3fee:	ac 01       	movw	r20, r24
		//// check also : http://scolton.blogspot.com/2012/09/fun-with-complementary-filter-multiwii.html
		AnglePitch = AnglePitch
				   + (double)Sensors_Latest[GYRO_PITCH_Index] * GYRO_RATE * TimeDef * 0.001
					   + (sin(AngleRoll * DEG_TO_RAD) * DT_YAW)  // integrate component of yaw rate into pitch angle
						;
		AngleRoll = AngleRoll  
    3ff0:	20 93 de 06 	sts	0x06DE, r18
    3ff4:	30 93 df 06 	sts	0x06DF, r19
    3ff8:	40 93 e0 06 	sts	0x06E0, r20
    3ffc:	50 93 e1 06 	sts	0x06E1, r21
				  + (double)Sensors_Latest[GYRO_ROLL_Index]  * GYRO_RATE * TimeDef * 0.001
					  - (sin(AnglePitch * DEG_TO_RAD) * DT_YAW)  // integrate component of yaw rate into roll angle
					   ; 
		//RotateV();	
		// Correct Drift using ACC
		Alpha = Config.AccParams[PITCH_INDEX].ComplementaryFilterAlpha / 1000.0; // TODO: optimize
    4000:	00 91 2d 07 	lds	r16, 0x072D
    4004:	10 91 2e 07 	lds	r17, 0x072E
		Beta = 1- Alpha;
		#define ACC_SMALL_ANGLE	140
		//// if small angle then correct using ACC
		if ((APitch < ACC_SMALL_ANGLE) && (APitch > -ACC_SMALL_ANGLE)) 
    4008:	59 81       	ldd	r21, Y+1	; 0x01
    400a:	4a 81       	ldd	r20, Y+2	; 0x02
    400c:	3b 81       	ldd	r19, Y+3	; 0x03
    400e:	2c 81       	ldd	r18, Y+4	; 0x04
    4010:	65 2f       	mov	r22, r21
    4012:	74 2f       	mov	r23, r20
    4014:	83 2f       	mov	r24, r19
    4016:	92 2f       	mov	r25, r18
    4018:	20 e0       	ldi	r18, 0x00	; 0
    401a:	30 e0       	ldi	r19, 0x00	; 0
    401c:	4c e0       	ldi	r20, 0x0C	; 12
    401e:	53 e4       	ldi	r21, 0x43	; 67
    4020:	0e 94 f6 37 	call	0x6fec	; 0x6fec <__cmpsf2>
    4024:	87 ff       	sbrs	r24, 7
    4026:	52 c0       	rjmp	.+164    	; 0x40cc <IMU+0x746>
    4028:	59 81       	ldd	r21, Y+1	; 0x01
    402a:	4a 81       	ldd	r20, Y+2	; 0x02
    402c:	3b 81       	ldd	r19, Y+3	; 0x03
    402e:	2c 81       	ldd	r18, Y+4	; 0x04
    4030:	65 2f       	mov	r22, r21
    4032:	74 2f       	mov	r23, r20
    4034:	83 2f       	mov	r24, r19
    4036:	92 2f       	mov	r25, r18
    4038:	20 e0       	ldi	r18, 0x00	; 0
    403a:	30 e0       	ldi	r19, 0x00	; 0
    403c:	4c e0       	ldi	r20, 0x0C	; 12
    403e:	53 ec       	ldi	r21, 0xC3	; 195
    4040:	0e 94 45 39 	call	0x728a	; 0x728a <__gesf2>
    4044:	18 16       	cp	r1, r24
    4046:	0c f0       	brlt	.+2      	; 0x404a <IMU+0x6c4>
    4048:	41 c0       	rjmp	.+130    	; 0x40cc <IMU+0x746>
				  + (double)Sensors_Latest[GYRO_ROLL_Index]  * GYRO_RATE * TimeDef * 0.001
					  - (sin(AnglePitch * DEG_TO_RAD) * DT_YAW)  // integrate component of yaw rate into roll angle
					   ; 
		//RotateV();	
		// Correct Drift using ACC
		Alpha = Config.AccParams[PITCH_INDEX].ComplementaryFilterAlpha / 1000.0; // TODO: optimize
    404a:	b8 01       	movw	r22, r16
    404c:	88 27       	eor	r24, r24
    404e:	77 fd       	sbrc	r23, 7
    4050:	80 95       	com	r24
    4052:	98 2f       	mov	r25, r24
    4054:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    4058:	20 e0       	ldi	r18, 0x00	; 0
    405a:	30 e0       	ldi	r19, 0x00	; 0
    405c:	4a e7       	ldi	r20, 0x7A	; 122
    405e:	54 e4       	ldi	r21, 0x44	; 68
    4060:	0e 94 fa 37 	call	0x6ff4	; 0x6ff4 <__divsf3>
    4064:	f6 2e       	mov	r15, r22
    4066:	07 2f       	mov	r16, r23
    4068:	18 2f       	mov	r17, r24
    406a:	e9 2e       	mov	r14, r25
		Beta = 1- Alpha;
		#define ACC_SMALL_ANGLE	140
		//// if small angle then correct using ACC
		if ((APitch < ACC_SMALL_ANGLE) && (APitch > -ACC_SMALL_ANGLE)) 
		{
			AnglePitch = Alpha * AnglePitch + Beta * APitch ;
    406c:	20 91 16 06 	lds	r18, 0x0616
    4070:	30 91 17 06 	lds	r19, 0x0617
    4074:	40 91 18 06 	lds	r20, 0x0618
    4078:	50 91 19 06 	lds	r21, 0x0619
    407c:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    4080:	5b 01       	movw	r10, r22
    4082:	6c 01       	movw	r12, r24
					  - (sin(AnglePitch * DEG_TO_RAD) * DT_YAW)  // integrate component of yaw rate into roll angle
					   ; 
		//RotateV();	
		// Correct Drift using ACC
		Alpha = Config.AccParams[PITCH_INDEX].ComplementaryFilterAlpha / 1000.0; // TODO: optimize
		Beta = 1- Alpha;
    4084:	60 e0       	ldi	r22, 0x00	; 0
    4086:	70 e0       	ldi	r23, 0x00	; 0
    4088:	80 e8       	ldi	r24, 0x80	; 128
    408a:	9f e3       	ldi	r25, 0x3F	; 63
    408c:	2f 2d       	mov	r18, r15
    408e:	30 2f       	mov	r19, r16
    4090:	41 2f       	mov	r20, r17
    4092:	5e 2d       	mov	r21, r14
    4094:	0e 94 91 37 	call	0x6f22	; 0x6f22 <__subsf3>
		#define ACC_SMALL_ANGLE	140
		//// if small angle then correct using ACC
		if ((APitch < ACC_SMALL_ANGLE) && (APitch > -ACC_SMALL_ANGLE)) 
		{
			AnglePitch = Alpha * AnglePitch + Beta * APitch ;
    4098:	b9 81       	ldd	r27, Y+1	; 0x01
    409a:	aa 81       	ldd	r26, Y+2	; 0x02
    409c:	1b 81       	ldd	r17, Y+3	; 0x03
    409e:	0c 81       	ldd	r16, Y+4	; 0x04
    40a0:	2b 2f       	mov	r18, r27
    40a2:	3a 2f       	mov	r19, r26
    40a4:	41 2f       	mov	r20, r17
    40a6:	50 2f       	mov	r21, r16
    40a8:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    40ac:	9b 01       	movw	r18, r22
    40ae:	ac 01       	movw	r20, r24
    40b0:	c6 01       	movw	r24, r12
    40b2:	b5 01       	movw	r22, r10
    40b4:	0e 94 92 37 	call	0x6f24	; 0x6f24 <__addsf3>
    40b8:	9b 01       	movw	r18, r22
    40ba:	ac 01       	movw	r20, r24
    40bc:	20 93 16 06 	sts	0x0616, r18
    40c0:	30 93 17 06 	sts	0x0617, r19
    40c4:	40 93 18 06 	sts	0x0618, r20
    40c8:	50 93 19 06 	sts	0x0619, r21
		}
		
		Alpha = Config.AccParams[ROLL_INDEX].ComplementaryFilterAlpha / 1000.0; // TODO: optimize
    40cc:	00 91 3b 07 	lds	r16, 0x073B
    40d0:	10 91 3c 07 	lds	r17, 0x073C
		Beta = 1- Alpha;
		if ((ARoll  < ACC_SMALL_ANGLE) && (ARoll  > -ACC_SMALL_ANGLE))
    40d4:	5d 81       	ldd	r21, Y+5	; 0x05
    40d6:	4e 81       	ldd	r20, Y+6	; 0x06
    40d8:	3f 81       	ldd	r19, Y+7	; 0x07
    40da:	28 85       	ldd	r18, Y+8	; 0x08
    40dc:	65 2f       	mov	r22, r21
    40de:	74 2f       	mov	r23, r20
    40e0:	83 2f       	mov	r24, r19
    40e2:	92 2f       	mov	r25, r18
    40e4:	20 e0       	ldi	r18, 0x00	; 0
    40e6:	30 e0       	ldi	r19, 0x00	; 0
    40e8:	4c e0       	ldi	r20, 0x0C	; 12
    40ea:	53 e4       	ldi	r21, 0x43	; 67
    40ec:	0e 94 f6 37 	call	0x6fec	; 0x6fec <__cmpsf2>
    40f0:	87 ff       	sbrs	r24, 7
    40f2:	52 c0       	rjmp	.+164    	; 0x4198 <IMU+0x812>
    40f4:	5d 81       	ldd	r21, Y+5	; 0x05
    40f6:	4e 81       	ldd	r20, Y+6	; 0x06
    40f8:	3f 81       	ldd	r19, Y+7	; 0x07
    40fa:	28 85       	ldd	r18, Y+8	; 0x08
    40fc:	65 2f       	mov	r22, r21
    40fe:	74 2f       	mov	r23, r20
    4100:	83 2f       	mov	r24, r19
    4102:	92 2f       	mov	r25, r18
    4104:	20 e0       	ldi	r18, 0x00	; 0
    4106:	30 e0       	ldi	r19, 0x00	; 0
    4108:	4c e0       	ldi	r20, 0x0C	; 12
    410a:	53 ec       	ldi	r21, 0xC3	; 195
    410c:	0e 94 45 39 	call	0x728a	; 0x728a <__gesf2>
    4110:	18 16       	cp	r1, r24
    4112:	0c f0       	brlt	.+2      	; 0x4116 <IMU+0x790>
    4114:	41 c0       	rjmp	.+130    	; 0x4198 <IMU+0x812>
		if ((APitch < ACC_SMALL_ANGLE) && (APitch > -ACC_SMALL_ANGLE)) 
		{
			AnglePitch = Alpha * AnglePitch + Beta * APitch ;
		}
		
		Alpha = Config.AccParams[ROLL_INDEX].ComplementaryFilterAlpha / 1000.0; // TODO: optimize
    4116:	b8 01       	movw	r22, r16
    4118:	88 27       	eor	r24, r24
    411a:	77 fd       	sbrc	r23, 7
    411c:	80 95       	com	r24
    411e:	98 2f       	mov	r25, r24
    4120:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    4124:	20 e0       	ldi	r18, 0x00	; 0
    4126:	30 e0       	ldi	r19, 0x00	; 0
    4128:	4a e7       	ldi	r20, 0x7A	; 122
    412a:	54 e4       	ldi	r21, 0x44	; 68
    412c:	0e 94 fa 37 	call	0x6ff4	; 0x6ff4 <__divsf3>
    4130:	f6 2e       	mov	r15, r22
    4132:	07 2f       	mov	r16, r23
    4134:	18 2f       	mov	r17, r24
    4136:	e9 2e       	mov	r14, r25
		Beta = 1- Alpha;
		if ((ARoll  < ACC_SMALL_ANGLE) && (ARoll  > -ACC_SMALL_ANGLE))
		{
			AngleRoll =  Alpha * AngleRoll + Beta * ARoll ;
    4138:	20 91 de 06 	lds	r18, 0x06DE
    413c:	30 91 df 06 	lds	r19, 0x06DF
    4140:	40 91 e0 06 	lds	r20, 0x06E0
    4144:	50 91 e1 06 	lds	r21, 0x06E1
    4148:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    414c:	5b 01       	movw	r10, r22
    414e:	6c 01       	movw	r12, r24
		{
			AnglePitch = Alpha * AnglePitch + Beta * APitch ;
		}
		
		Alpha = Config.AccParams[ROLL_INDEX].ComplementaryFilterAlpha / 1000.0; // TODO: optimize
		Beta = 1- Alpha;
    4150:	60 e0       	ldi	r22, 0x00	; 0
    4152:	70 e0       	ldi	r23, 0x00	; 0
    4154:	80 e8       	ldi	r24, 0x80	; 128
    4156:	9f e3       	ldi	r25, 0x3F	; 63
    4158:	2f 2d       	mov	r18, r15
    415a:	30 2f       	mov	r19, r16
    415c:	41 2f       	mov	r20, r17
    415e:	5e 2d       	mov	r21, r14
    4160:	0e 94 91 37 	call	0x6f22	; 0x6f22 <__subsf3>
		if ((ARoll  < ACC_SMALL_ANGLE) && (ARoll  > -ACC_SMALL_ANGLE))
		{
			AngleRoll =  Alpha * AngleRoll + Beta * ARoll ;
    4164:	bd 81       	ldd	r27, Y+5	; 0x05
    4166:	ae 81       	ldd	r26, Y+6	; 0x06
    4168:	1f 81       	ldd	r17, Y+7	; 0x07
    416a:	08 85       	ldd	r16, Y+8	; 0x08
    416c:	2b 2f       	mov	r18, r27
    416e:	3a 2f       	mov	r19, r26
    4170:	41 2f       	mov	r20, r17
    4172:	50 2f       	mov	r21, r16
    4174:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    4178:	9b 01       	movw	r18, r22
    417a:	ac 01       	movw	r20, r24
    417c:	c6 01       	movw	r24, r12
    417e:	b5 01       	movw	r22, r10
    4180:	0e 94 92 37 	call	0x6f24	; 0x6f24 <__addsf3>
    4184:	9b 01       	movw	r18, r22
    4186:	ac 01       	movw	r20, r24
    4188:	20 93 de 06 	sts	0x06DE, r18
    418c:	30 93 df 06 	sts	0x06DF, r19
    4190:	40 93 e0 06 	sts	0x06E0, r20
    4194:	50 93 e1 06 	sts	0x06E1, r21
			gyroRoll += PID_Calculate_ACC (Config.AccParams[ROLL_INDEX], &PID_AccTerms[ROLL_INDEX],NavX); //AngleRoll); 
		 
		}
		
	
}
    4198:	2c 96       	adiw	r28, 0x0c	; 12
    419a:	0f b6       	in	r0, 0x3f	; 63
    419c:	f8 94       	cli
    419e:	de bf       	out	0x3e, r29	; 62
    41a0:	0f be       	out	0x3f, r0	; 63
    41a2:	cd bf       	out	0x3d, r28	; 61
    41a4:	cf 91       	pop	r28
    41a6:	df 91       	pop	r29
    41a8:	1f 91       	pop	r17
    41aa:	0f 91       	pop	r16
    41ac:	ff 90       	pop	r15
    41ae:	ef 90       	pop	r14
    41b0:	df 90       	pop	r13
    41b2:	cf 90       	pop	r12
    41b4:	bf 90       	pop	r11
    41b6:	af 90       	pop	r10
    41b8:	9f 90       	pop	r9
    41ba:	8f 90       	pop	r8
    41bc:	7f 90       	pop	r7
    41be:	6f 90       	pop	r6
    41c0:	5f 90       	pop	r5
    41c2:	4f 90       	pop	r4
    41c4:	3f 90       	pop	r3
    41c6:	2f 90       	pop	r2
    41c8:	08 95       	ret

000041ca <IMU_HeightKeeping>:

	

	
double IMU_HeightKeeping ()
{
    41ca:	af 92       	push	r10
    41cc:	bf 92       	push	r11
    41ce:	cf 92       	push	r12
    41d0:	df 92       	push	r13
    41d2:	ef 92       	push	r14
    41d4:	ff 92       	push	r15
    41d6:	0f 93       	push	r16
    41d8:	1f 93       	push	r17
	double Temp;
//	ThrottleTemp = RX_Snapshot[RXChannel_THR];
	
	// calculate damping
	
	Landing = PID_Calculate (Config.AccParams[Z_INDEX], &PID_AccTerms[Z_INDEX],-CompAccZ) ;
    41da:	00 d0       	rcall	.+0      	; 0x41dc <IMU_HeightKeeping+0x12>
    41dc:	00 d0       	rcall	.+0      	; 0x41de <IMU_HeightKeeping+0x14>
    41de:	80 91 37 06 	lds	r24, 0x0637
    41e2:	90 91 38 06 	lds	r25, 0x0638
    41e6:	a0 91 39 06 	lds	r26, 0x0639
    41ea:	b0 91 3a 06 	lds	r27, 0x063A
    41ee:	b0 58       	subi	r27, 0x80	; 128
    41f0:	ed b7       	in	r30, 0x3d	; 61
    41f2:	fe b7       	in	r31, 0x3e	; 62
    41f4:	81 83       	std	Z+1, r24	; 0x01
    41f6:	92 83       	std	Z+2, r25	; 0x02
    41f8:	a3 83       	std	Z+3, r26	; 0x03
    41fa:	b4 83       	std	Z+4, r27	; 0x04
    41fc:	c0 90 3d 07 	lds	r12, 0x073D
    4200:	d0 90 3e 07 	lds	r13, 0x073E
    4204:	e0 90 3f 07 	lds	r14, 0x073F
    4208:	f0 90 40 07 	lds	r15, 0x0740
    420c:	00 91 41 07 	lds	r16, 0x0741
    4210:	10 91 42 07 	lds	r17, 0x0742
    4214:	20 91 43 07 	lds	r18, 0x0743
    4218:	30 91 44 07 	lds	r19, 0x0744
    421c:	40 91 45 07 	lds	r20, 0x0745
    4220:	50 91 46 07 	lds	r21, 0x0746
    4224:	60 91 47 07 	lds	r22, 0x0747
    4228:	70 91 48 07 	lds	r23, 0x0748
    422c:	80 91 49 07 	lds	r24, 0x0749
    4230:	90 91 4a 07 	lds	r25, 0x074A
    4234:	ee e7       	ldi	r30, 0x7E	; 126
    4236:	ae 2e       	mov	r10, r30
    4238:	e5 e0       	ldi	r30, 0x05	; 5
    423a:	be 2e       	mov	r11, r30
    423c:	0e 94 3e 1a 	call	0x347c	; 0x347c <PID_Calculate>
    4240:	60 93 66 06 	sts	0x0666, r22
    4244:	70 93 67 06 	sts	0x0667, r23
    4248:	80 93 68 06 	sts	0x0668, r24
    424c:	90 93 69 06 	sts	0x0669, r25
			
			
	// Calculate Altitude Hold
	if ((Config.RX_mode==RX_mode_UARTMode) && (IS_MISC_SENSOR_SONAR_ENABLED==true) && (nFlyingModes == FLYINGMODE_ALTHOLD))
    4250:	0f 90       	pop	r0
    4252:	0f 90       	pop	r0
    4254:	0f 90       	pop	r0
    4256:	0f 90       	pop	r0
    4258:	80 91 eb 06 	lds	r24, 0x06EB
    425c:	8f 3f       	cpi	r24, 0xFF	; 255
    425e:	09 f0       	breq	.+2      	; 0x4262 <IMU_HeightKeeping+0x98>
    4260:	f4 c0       	rjmp	.+488    	; 0x444a <IMU_HeightKeeping+0x280>
    4262:	80 91 f6 06 	lds	r24, 0x06F6
    4266:	80 ff       	sbrs	r24, 0
    4268:	f0 c0       	rjmp	.+480    	; 0x444a <IMU_HeightKeeping+0x280>
    426a:	80 91 1a 06 	lds	r24, 0x061A
    426e:	84 30       	cpi	r24, 0x04	; 4
    4270:	09 f0       	breq	.+2      	; 0x4274 <IMU_HeightKeeping+0xaa>
    4272:	eb c0       	rjmp	.+470    	; 0x444a <IMU_HeightKeeping+0x280>
	{
		RX_SONAR_TRIGGER = HIGH;
    4274:	48 9a       	sbi	0x09, 0	; 9
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    4276:	f8 94       	cli
		ATOMIC_BLOCK(ATOMIC_FORCEON)
		{	
			Temp = RX_SONAR_RAW; 
    4278:	60 91 d0 05 	lds	r22, 0x05D0
    427c:	70 91 d1 05 	lds	r23, 0x05D1
    4280:	80 e0       	ldi	r24, 0x00	; 0
    4282:	90 e0       	ldi	r25, 0x00	; 0
    4284:	0e 94 93 38 	call	0x7126	; 0x7126 <__floatunsisf>
    4288:	7b 01       	movw	r14, r22
    428a:	8c 01       	movw	r16, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    428c:	78 94       	sei
		}
	
		if (Temp < 550) // if SONAR Reading is VALID - not BEYOND maximum range
    428e:	7f 2d       	mov	r23, r15
    4290:	91 2f       	mov	r25, r17
    4292:	20 e0       	ldi	r18, 0x00	; 0
    4294:	30 e8       	ldi	r19, 0x80	; 128
    4296:	49 e0       	ldi	r20, 0x09	; 9
    4298:	54 e4       	ldi	r21, 0x44	; 68
    429a:	0e 94 f6 37 	call	0x6fec	; 0x6fec <__cmpsf2>
    429e:	87 ff       	sbrs	r24, 7
    42a0:	b4 c0       	rjmp	.+360    	; 0x440a <IMU_HeightKeeping+0x240>
		{
			
			if ((bALTHOLD == false))
    42a2:	80 91 35 05 	lds	r24, 0x0535
    42a6:	88 23       	and	r24, r24
    42a8:	29 f5       	brne	.+74     	; 0x42f4 <IMU_HeightKeeping+0x12a>
			{   
				if (ThrottleTemp<3)
    42aa:	80 91 33 05 	lds	r24, 0x0533
    42ae:	90 91 34 05 	lds	r25, 0x0534
    42b2:	83 30       	cpi	r24, 0x03	; 3
    42b4:	91 05       	cpc	r25, r1
    42b6:	34 f4       	brge	.+12     	; 0x42c4 <IMU_HeightKeeping+0xfa>
				{ // current altitude is the old one so skip readings till update.
					ThrottleTemp+=1;
    42b8:	01 96       	adiw	r24, 0x01	; 1
    42ba:	90 93 34 05 	sts	0x0534, r25
    42be:	80 93 33 05 	sts	0x0533, r24
    42c2:	c9 c0       	rjmp	.+402    	; 0x4456 <IMU_HeightKeeping+0x28c>
					return Landing ;
				}
				// first time to switch to ALTHOLD
				LastAltitudeHold = Temp; // measure Altitude
    42c4:	6e 2d       	mov	r22, r14
    42c6:	7f 2d       	mov	r23, r15
    42c8:	80 2f       	mov	r24, r16
    42ca:	91 2f       	mov	r25, r17
    42cc:	0e 94 67 38 	call	0x70ce	; 0x70ce <__fixunssfsi>
    42d0:	70 93 db 06 	sts	0x06DB, r23
    42d4:	60 93 da 06 	sts	0x06DA, r22
				PID_SonarTerms[0].I=0;   // ZERO I
    42d8:	80 e0       	ldi	r24, 0x00	; 0
    42da:	90 e0       	ldi	r25, 0x00	; 0
    42dc:	dc 01       	movw	r26, r24
    42de:	80 93 b4 07 	sts	0x07B4, r24
    42e2:	90 93 b5 07 	sts	0x07B5, r25
    42e6:	a0 93 b6 07 	sts	0x07B6, r26
    42ea:	b0 93 b7 07 	sts	0x07B7, r27
				bALTHOLD = true;
    42ee:	81 e0       	ldi	r24, 0x01	; 1
    42f0:	80 93 35 05 	sts	0x0535, r24
			}
			
			AltDiff = LastAltitudeHold - Temp;
    42f4:	60 91 da 06 	lds	r22, 0x06DA
    42f8:	70 91 db 06 	lds	r23, 0x06DB
    42fc:	80 e0       	ldi	r24, 0x00	; 0
    42fe:	90 e0       	ldi	r25, 0x00	; 0
    4300:	0e 94 93 38 	call	0x7126	; 0x7126 <__floatunsisf>
    4304:	2e 2d       	mov	r18, r14
    4306:	3f 2d       	mov	r19, r15
    4308:	40 2f       	mov	r20, r16
    430a:	51 2f       	mov	r21, r17
    430c:	0e 94 91 37 	call	0x6f22	; 0x6f22 <__subsf3>
    4310:	f6 2e       	mov	r15, r22
    4312:	07 2f       	mov	r16, r23
    4314:	18 2f       	mov	r17, r24
    4316:	e9 2e       	mov	r14, r25
    4318:	86 2f       	mov	r24, r22
    431a:	90 2f       	mov	r25, r16
    431c:	a1 2f       	mov	r26, r17
    431e:	be 2d       	mov	r27, r14
    4320:	80 93 be 06 	sts	0x06BE, r24
    4324:	90 93 bf 06 	sts	0x06BF, r25
    4328:	a0 93 c0 06 	sts	0x06C0, r26
    432c:	b0 93 c1 06 	sts	0x06C1, r27
			if ((AltDiff<50) && (AltDiff>-50)) // no sudden change or false read
    4330:	6f 2d       	mov	r22, r15
    4332:	70 2f       	mov	r23, r16
    4334:	81 2f       	mov	r24, r17
    4336:	9e 2d       	mov	r25, r14
    4338:	20 e0       	ldi	r18, 0x00	; 0
    433a:	30 e0       	ldi	r19, 0x00	; 0
    433c:	48 e4       	ldi	r20, 0x48	; 72
    433e:	52 e4       	ldi	r21, 0x42	; 66
    4340:	0e 94 f6 37 	call	0x6fec	; 0x6fec <__cmpsf2>
    4344:	87 ff       	sbrs	r24, 7
    4346:	5c c0       	rjmp	.+184    	; 0x4400 <IMU_HeightKeeping+0x236>
    4348:	6f 2d       	mov	r22, r15
    434a:	70 2f       	mov	r23, r16
    434c:	81 2f       	mov	r24, r17
    434e:	9e 2d       	mov	r25, r14
    4350:	20 e0       	ldi	r18, 0x00	; 0
    4352:	30 e0       	ldi	r19, 0x00	; 0
    4354:	48 e4       	ldi	r20, 0x48	; 72
    4356:	52 ec       	ldi	r21, 0xC2	; 194
    4358:	0e 94 45 39 	call	0x728a	; 0x728a <__gesf2>
    435c:	18 16       	cp	r1, r24
    435e:	0c f0       	brlt	.+2      	; 0x4362 <IMU_HeightKeeping+0x198>
    4360:	4f c0       	rjmp	.+158    	; 0x4400 <IMU_HeightKeeping+0x236>
			{
				IgnoreTimeOut=0;
    4362:	10 92 30 05 	sts	0x0530, r1
				ThrottleTemp = PID_Calculate (Config.SonarParams[0], &PID_SonarTerms[0],AltDiff) ;	
    4366:	00 d0       	rcall	.+0      	; 0x4368 <IMU_HeightKeeping+0x19e>
    4368:	00 d0       	rcall	.+0      	; 0x436a <IMU_HeightKeeping+0x1a0>
    436a:	8f 2d       	mov	r24, r15
    436c:	90 2f       	mov	r25, r16
    436e:	a1 2f       	mov	r26, r17
    4370:	be 2d       	mov	r27, r14
    4372:	ed b7       	in	r30, 0x3d	; 61
    4374:	fe b7       	in	r31, 0x3e	; 62
    4376:	81 83       	std	Z+1, r24	; 0x01
    4378:	92 83       	std	Z+2, r25	; 0x02
    437a:	a3 83       	std	Z+3, r26	; 0x03
    437c:	b4 83       	std	Z+4, r27	; 0x04
    437e:	c0 90 4b 07 	lds	r12, 0x074B
    4382:	d0 90 4c 07 	lds	r13, 0x074C
    4386:	e0 90 4d 07 	lds	r14, 0x074D
    438a:	f0 90 4e 07 	lds	r15, 0x074E
    438e:	00 91 4f 07 	lds	r16, 0x074F
    4392:	10 91 50 07 	lds	r17, 0x0750
    4396:	20 91 51 07 	lds	r18, 0x0751
    439a:	30 91 52 07 	lds	r19, 0x0752
    439e:	40 91 53 07 	lds	r20, 0x0753
    43a2:	50 91 54 07 	lds	r21, 0x0754
    43a6:	60 91 55 07 	lds	r22, 0x0755
    43aa:	70 91 56 07 	lds	r23, 0x0756
    43ae:	80 91 57 07 	lds	r24, 0x0757
    43b2:	90 91 58 07 	lds	r25, 0x0758
    43b6:	b0 eb       	ldi	r27, 0xB0	; 176
    43b8:	ab 2e       	mov	r10, r27
    43ba:	b7 e0       	ldi	r27, 0x07	; 7
    43bc:	bb 2e       	mov	r11, r27
    43be:	0e 94 3e 1a 	call	0x347c	; 0x347c <PID_Calculate>
    43c2:	0e 94 62 38 	call	0x70c4	; 0x70c4 <__fixsfsi>
    43c6:	7b 01       	movw	r14, r22
    43c8:	8c 01       	movw	r16, r24
    43ca:	70 93 34 05 	sts	0x0534, r23
    43ce:	60 93 33 05 	sts	0x0533, r22
				if (AltDiff==0) 
    43d2:	0f 90       	pop	r0
    43d4:	0f 90       	pop	r0
    43d6:	0f 90       	pop	r0
    43d8:	0f 90       	pop	r0
    43da:	60 91 be 06 	lds	r22, 0x06BE
    43de:	70 91 bf 06 	lds	r23, 0x06BF
    43e2:	80 91 c0 06 	lds	r24, 0x06C0
    43e6:	90 91 c1 06 	lds	r25, 0x06C1
    43ea:	20 e0       	ldi	r18, 0x00	; 0
    43ec:	30 e0       	ldi	r19, 0x00	; 0
    43ee:	a9 01       	movw	r20, r18
    43f0:	0e 94 f6 37 	call	0x6fec	; 0x6fec <__cmpsf2>
    43f4:	88 23       	and	r24, r24
    43f6:	21 f4       	brne	.+8      	; 0x4400 <IMU_HeightKeeping+0x236>
				{
					ThrottleZERO = ThrottleTemp;
    43f8:	f0 92 32 05 	sts	0x0532, r15
    43fc:	e0 92 31 05 	sts	0x0531, r14
						
				}
			}
										
			Landing += ThrottleTemp;
    4400:	60 91 33 05 	lds	r22, 0x0533
    4404:	70 91 34 05 	lds	r23, 0x0534
    4408:	04 c0       	rjmp	.+8      	; 0x4412 <IMU_HeightKeeping+0x248>
		}
		else
		{
			Landing += ThrottleZERO;
    440a:	60 91 31 05 	lds	r22, 0x0531
    440e:	70 91 32 05 	lds	r23, 0x0532
    4412:	88 27       	eor	r24, r24
    4414:	77 fd       	sbrc	r23, 7
    4416:	80 95       	com	r24
    4418:	98 2f       	mov	r25, r24
    441a:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    441e:	9b 01       	movw	r18, r22
    4420:	ac 01       	movw	r20, r24
    4422:	60 91 66 06 	lds	r22, 0x0666
    4426:	70 91 67 06 	lds	r23, 0x0667
    442a:	80 91 68 06 	lds	r24, 0x0668
    442e:	90 91 69 06 	lds	r25, 0x0669
    4432:	0e 94 92 37 	call	0x6f24	; 0x6f24 <__addsf3>
    4436:	60 93 66 06 	sts	0x0666, r22
    443a:	70 93 67 06 	sts	0x0667, r23
    443e:	80 93 68 06 	sts	0x0668, r24
    4442:	90 93 69 06 	sts	0x0669, r25
		}
		
		RX_SONAR_TRIGGER = LOW;
    4446:	48 98       	cbi	0x09, 0	; 9
    4448:	06 c0       	rjmp	.+12     	; 0x4456 <IMU_HeightKeeping+0x28c>
	}
	else
	{
			ThrottleTemp=0;
    444a:	10 92 34 05 	sts	0x0534, r1
    444e:	10 92 33 05 	sts	0x0533, r1
			bALTHOLD=false;
    4452:	10 92 35 05 	sts	0x0535, r1
	}
	
	
	return Landing;
    4456:	70 91 66 06 	lds	r23, 0x0666
    445a:	60 91 67 06 	lds	r22, 0x0667
    445e:	90 91 68 06 	lds	r25, 0x0668
    4462:	80 91 69 06 	lds	r24, 0x0669
    4466:	ab 01       	movw	r20, r22
    4468:	9c 01       	movw	r18, r24
    446a:	65 2f       	mov	r22, r21
    446c:	74 2f       	mov	r23, r20
    446e:	83 2f       	mov	r24, r19
    4470:	92 2f       	mov	r25, r18
    4472:	1f 91       	pop	r17
    4474:	0f 91       	pop	r16
    4476:	ff 90       	pop	r15
    4478:	ef 90       	pop	r14
    447a:	df 90       	pop	r13
    447c:	cf 90       	pop	r12
    447e:	bf 90       	pop	r11
    4480:	af 90       	pop	r10
    4482:	08 95       	ret

00004484 <arctan2>:
  //}
  //z *= (180.0f / PI * 10); 
  //return z;
//}

int arctan2(int y, int x) {                                    // http://www.dspguru.com/comp.dsp/tricks/alg/fxdatan2.htm
    4484:	6f 92       	push	r6
    4486:	7f 92       	push	r7
    4488:	8f 92       	push	r8
    448a:	9f 92       	push	r9
    448c:	af 92       	push	r10
    448e:	bf 92       	push	r11
    4490:	cf 92       	push	r12
    4492:	df 92       	push	r13
    4494:	ef 92       	push	r14
    4496:	ff 92       	push	r15
    4498:	0f 93       	push	r16
    449a:	1f 93       	push	r17
    449c:	cf 93       	push	r28
    449e:	df 93       	push	r29
    44a0:	ec 01       	movw	r28, r24
    44a2:	6b 01       	movw	r12, r22
   int coeff_1 = 128;                                          // angle in Quids (1024 Quids=360) <<<<<<<<<<<<<<
   int coeff_2 = 3*coeff_1;
   float abs_y = abs(y)+1e-10;
    44a4:	bc 01       	movw	r22, r24
    44a6:	97 ff       	sbrs	r25, 7
    44a8:	04 c0       	rjmp	.+8      	; 0x44b2 <arctan2+0x2e>
    44aa:	66 27       	eor	r22, r22
    44ac:	77 27       	eor	r23, r23
    44ae:	68 1b       	sub	r22, r24
    44b0:	79 0b       	sbc	r23, r25
    44b2:	88 27       	eor	r24, r24
    44b4:	77 fd       	sbrc	r23, 7
    44b6:	80 95       	com	r24
    44b8:	98 2f       	mov	r25, r24
    44ba:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    44be:	2f ef       	ldi	r18, 0xFF	; 255
    44c0:	36 ee       	ldi	r19, 0xE6	; 230
    44c2:	4b ed       	ldi	r20, 0xDB	; 219
    44c4:	5e e2       	ldi	r21, 0x2E	; 46
    44c6:	0e 94 92 37 	call	0x6f24	; 0x6f24 <__addsf3>
    44ca:	16 2f       	mov	r17, r22
    44cc:	07 2f       	mov	r16, r23
    44ce:	f8 2e       	mov	r15, r24
    44d0:	e9 2e       	mov	r14, r25
    44d2:	b6 01       	movw	r22, r12
    44d4:	88 27       	eor	r24, r24
    44d6:	77 fd       	sbrc	r23, 7
    44d8:	80 95       	com	r24
    44da:	98 2f       	mov	r25, r24
   float r, angle;

   if (x >= 0) {
    44dc:	d7 fc       	sbrc	r13, 7
    44de:	2b c0       	rjmp	.+86     	; 0x4536 <arctan2+0xb2>
     r = (x - abs_y) / (x + abs_y);
    44e0:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    44e4:	5b 01       	movw	r10, r22
    44e6:	6c 01       	movw	r12, r24
    44e8:	d8 01       	movw	r26, r16
    44ea:	f7 01       	movw	r30, r14
    44ec:	2b 2f       	mov	r18, r27
    44ee:	3a 2f       	mov	r19, r26
    44f0:	4f 2f       	mov	r20, r31
    44f2:	5e 2f       	mov	r21, r30
    44f4:	0e 94 91 37 	call	0x6f22	; 0x6f22 <__subsf3>
    44f8:	3b 01       	movw	r6, r22
    44fa:	4c 01       	movw	r8, r24
    44fc:	c6 01       	movw	r24, r12
    44fe:	b5 01       	movw	r22, r10
    4500:	d8 01       	movw	r26, r16
    4502:	f7 01       	movw	r30, r14
    4504:	2b 2f       	mov	r18, r27
    4506:	3a 2f       	mov	r19, r26
    4508:	4f 2f       	mov	r20, r31
    450a:	5e 2f       	mov	r21, r30
    450c:	0e 94 92 37 	call	0x6f24	; 0x6f24 <__addsf3>
    4510:	9b 01       	movw	r18, r22
    4512:	ac 01       	movw	r20, r24
    4514:	c4 01       	movw	r24, r8
    4516:	b3 01       	movw	r22, r6
    4518:	0e 94 fa 37 	call	0x6ff4	; 0x6ff4 <__divsf3>
     angle = coeff_1 - coeff_1 * r;
    451c:	20 e0       	ldi	r18, 0x00	; 0
    451e:	30 e0       	ldi	r19, 0x00	; 0
    4520:	40 e0       	ldi	r20, 0x00	; 0
    4522:	53 e4       	ldi	r21, 0x43	; 67
    4524:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    4528:	9b 01       	movw	r18, r22
    452a:	ac 01       	movw	r20, r24
    452c:	60 e0       	ldi	r22, 0x00	; 0
    452e:	70 e0       	ldi	r23, 0x00	; 0
    4530:	80 e0       	ldi	r24, 0x00	; 0
    4532:	93 e4       	ldi	r25, 0x43	; 67
    4534:	2a c0       	rjmp	.+84     	; 0x458a <arctan2+0x106>
   }  else {
     r = (x + abs_y) / (abs_y - x);
    4536:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    453a:	5b 01       	movw	r10, r22
    453c:	6c 01       	movw	r12, r24
    453e:	d8 01       	movw	r26, r16
    4540:	f7 01       	movw	r30, r14
    4542:	2b 2f       	mov	r18, r27
    4544:	3a 2f       	mov	r19, r26
    4546:	4f 2f       	mov	r20, r31
    4548:	5e 2f       	mov	r21, r30
    454a:	0e 94 92 37 	call	0x6f24	; 0x6f24 <__addsf3>
    454e:	3b 01       	movw	r6, r22
    4550:	4c 01       	movw	r8, r24
    4552:	a8 01       	movw	r20, r16
    4554:	97 01       	movw	r18, r14
    4556:	65 2f       	mov	r22, r21
    4558:	74 2f       	mov	r23, r20
    455a:	83 2f       	mov	r24, r19
    455c:	92 2f       	mov	r25, r18
    455e:	a6 01       	movw	r20, r12
    4560:	95 01       	movw	r18, r10
    4562:	0e 94 91 37 	call	0x6f22	; 0x6f22 <__subsf3>
    4566:	9b 01       	movw	r18, r22
    4568:	ac 01       	movw	r20, r24
    456a:	c4 01       	movw	r24, r8
    456c:	b3 01       	movw	r22, r6
    456e:	0e 94 fa 37 	call	0x6ff4	; 0x6ff4 <__divsf3>
     angle = coeff_2 - coeff_1 * r;
    4572:	20 e0       	ldi	r18, 0x00	; 0
    4574:	30 e0       	ldi	r19, 0x00	; 0
    4576:	40 e0       	ldi	r20, 0x00	; 0
    4578:	53 e4       	ldi	r21, 0x43	; 67
    457a:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    457e:	9b 01       	movw	r18, r22
    4580:	ac 01       	movw	r20, r24
    4582:	60 e0       	ldi	r22, 0x00	; 0
    4584:	70 e0       	ldi	r23, 0x00	; 0
    4586:	80 ec       	ldi	r24, 0xC0	; 192
    4588:	93 e4       	ldi	r25, 0x43	; 67
    458a:	0e 94 91 37 	call	0x6f22	; 0x6f22 <__subsf3>
   }
   if (y < 0)      return (int)(-angle);
    458e:	d7 fd       	sbrc	r29, 7
    4590:	90 58       	subi	r25, 0x80	; 128
   else            return (int)(angle);
    4592:	0e 94 62 38 	call	0x70c4	; 0x70c4 <__fixsfsi>
}
    4596:	cb 01       	movw	r24, r22
    4598:	df 91       	pop	r29
    459a:	cf 91       	pop	r28
    459c:	1f 91       	pop	r17
    459e:	0f 91       	pop	r16
    45a0:	ff 90       	pop	r15
    45a2:	ef 90       	pop	r14
    45a4:	df 90       	pop	r13
    45a6:	cf 90       	pop	r12
    45a8:	bf 90       	pop	r11
    45aa:	af 90       	pop	r10
    45ac:	9f 90       	pop	r9
    45ae:	8f 90       	pop	r8
    45b0:	7f 90       	pop	r7
    45b2:	6f 90       	pop	r6
    45b4:	08 95       	ret

000045b6 <Limiterf>:


float Limiterf (float Value, float Limit)
{
    45b6:	af 92       	push	r10
    45b8:	bf 92       	push	r11
    45ba:	cf 92       	push	r12
    45bc:	df 92       	push	r13
    45be:	ef 92       	push	r14
    45c0:	ff 92       	push	r15
    45c2:	0f 93       	push	r16
    45c4:	1f 93       	push	r17
    45c6:	d6 2e       	mov	r13, r22
    45c8:	c7 2e       	mov	r12, r23
    45ca:	b8 2e       	mov	r11, r24
    45cc:	a9 2e       	mov	r10, r25
    45ce:	79 01       	movw	r14, r18
    45d0:	8a 01       	movw	r16, r20
	if (Value > Limit) return   Limit;
    45d2:	a6 01       	movw	r20, r12
    45d4:	95 01       	movw	r18, r10
    45d6:	65 2f       	mov	r22, r21
    45d8:	74 2f       	mov	r23, r20
    45da:	83 2f       	mov	r24, r19
    45dc:	92 2f       	mov	r25, r18
    45de:	a8 01       	movw	r20, r16
    45e0:	97 01       	movw	r18, r14
    45e2:	0e 94 45 39 	call	0x728a	; 0x728a <__gesf2>
    45e6:	18 16       	cp	r1, r24
    45e8:	b4 f0       	brlt	.+44     	; 0x4616 <Limiterf+0x60>
	if (Value < -Limit) return -Limit;
    45ea:	17 fb       	bst	r17, 7
    45ec:	10 95       	com	r17
    45ee:	17 f9       	bld	r17, 7
    45f0:	10 95       	com	r17
    45f2:	a6 01       	movw	r20, r12
    45f4:	95 01       	movw	r18, r10
    45f6:	65 2f       	mov	r22, r21
    45f8:	74 2f       	mov	r23, r20
    45fa:	83 2f       	mov	r24, r19
    45fc:	92 2f       	mov	r25, r18
    45fe:	a8 01       	movw	r20, r16
    4600:	97 01       	movw	r18, r14
    4602:	0e 94 f6 37 	call	0x6fec	; 0x6fec <__cmpsf2>
    4606:	87 fd       	sbrc	r24, 7
    4608:	06 c0       	rjmp	.+12     	; 0x4616 <Limiterf+0x60>
	
	return Value;
    460a:	96 01       	movw	r18, r12
    460c:	c5 01       	movw	r24, r10
    460e:	e3 2e       	mov	r14, r19
    4610:	f2 2e       	mov	r15, r18
    4612:	09 2f       	mov	r16, r25
    4614:	18 2f       	mov	r17, r24
}
    4616:	6e 2d       	mov	r22, r14
    4618:	7f 2d       	mov	r23, r15
    461a:	80 2f       	mov	r24, r16
    461c:	91 2f       	mov	r25, r17
    461e:	1f 91       	pop	r17
    4620:	0f 91       	pop	r16
    4622:	ff 90       	pop	r15
    4624:	ef 90       	pop	r14
    4626:	df 90       	pop	r13
    4628:	cf 90       	pop	r12
    462a:	bf 90       	pop	r11
    462c:	af 90       	pop	r10
    462e:	08 95       	ret

00004630 <Limiter>:

int16_t Limiter (int16_t Value, int16_t Limit)
{
	if (Value > Limit) return   Limit;
    4630:	68 17       	cp	r22, r24
    4632:	79 07       	cpc	r23, r25
    4634:	3c f0       	brlt	.+14     	; 0x4644 <Limiter+0x14>
	if (Value < -Limit) return -Limit;
    4636:	70 95       	com	r23
    4638:	61 95       	neg	r22
    463a:	7f 4f       	sbci	r23, 0xFF	; 255
    463c:	68 17       	cp	r22, r24
    463e:	79 07       	cpc	r23, r25
    4640:	0c f4       	brge	.+2      	; 0x4644 <Limiter+0x14>
    4642:	bc 01       	movw	r22, r24
	
	return Value;
}
    4644:	cb 01       	movw	r24, r22
    4646:	08 95       	ret

00004648 <ScaleSensor>:
			 return (int16_t) y;
		}
	   }	
		*/
	return 0;	
}
    4648:	80 e0       	ldi	r24, 0x00	; 0
    464a:	90 e0       	ldi	r25, 0x00	; 0
    464c:	08 95       	ret

0000464e <_atan2>:



int16_t _atan2(int32_t y, int32_t x)
{
    464e:	2f 92       	push	r2
    4650:	3f 92       	push	r3
    4652:	4f 92       	push	r4
    4654:	5f 92       	push	r5
    4656:	6f 92       	push	r6
    4658:	7f 92       	push	r7
    465a:	8f 92       	push	r8
    465c:	9f 92       	push	r9
    465e:	af 92       	push	r10
    4660:	bf 92       	push	r11
    4662:	cf 92       	push	r12
    4664:	df 92       	push	r13
    4666:	ef 92       	push	r14
    4668:	ff 92       	push	r15
    466a:	0f 93       	push	r16
    466c:	1f 93       	push	r17
    466e:	5b 01       	movw	r10, r22
    4670:	6c 01       	movw	r12, r24
    4672:	39 01       	movw	r6, r18
    4674:	4a 01       	movw	r8, r20
	float z = (float)y / x;
    4676:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    467a:	7b 01       	movw	r14, r22
    467c:	8c 01       	movw	r16, r24
    467e:	c4 01       	movw	r24, r8
    4680:	b3 01       	movw	r22, r6
    4682:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    4686:	9b 01       	movw	r18, r22
    4688:	ac 01       	movw	r20, r24
    468a:	c8 01       	movw	r24, r16
    468c:	b7 01       	movw	r22, r14
    468e:	0e 94 fa 37 	call	0x6ff4	; 0x6ff4 <__divsf3>
    4692:	f6 2e       	mov	r15, r22
    4694:	07 2f       	mov	r16, r23
    4696:	18 2f       	mov	r17, r24
    4698:	e9 2e       	mov	r14, r25
	int16_t a;
	if ( abs(y) < abs(x) ){
    469a:	95 01       	movw	r18, r10
    469c:	b7 fe       	sbrs	r11, 7
    469e:	03 c0       	rjmp	.+6      	; 0x46a6 <_atan2+0x58>
    46a0:	30 95       	com	r19
    46a2:	21 95       	neg	r18
    46a4:	3f 4f       	sbci	r19, 0xFF	; 255
    46a6:	c3 01       	movw	r24, r6
    46a8:	77 fe       	sbrs	r7, 7
    46aa:	03 c0       	rjmp	.+6      	; 0x46b2 <_atan2+0x64>
    46ac:	90 95       	com	r25
    46ae:	81 95       	neg	r24
    46b0:	9f 4f       	sbci	r25, 0xFF	; 255
    46b2:	28 17       	cp	r18, r24
    46b4:	39 07       	cpc	r19, r25
    46b6:	8c f5       	brge	.+98     	; 0x471a <_atan2+0xcc>
		a = 573 * z / (1.0f + 0.28f * z * z);
    46b8:	6f 2d       	mov	r22, r15
    46ba:	70 2f       	mov	r23, r16
    46bc:	81 2f       	mov	r24, r17
    46be:	9e 2d       	mov	r25, r14
    46c0:	20 e0       	ldi	r18, 0x00	; 0
    46c2:	30 e4       	ldi	r19, 0x40	; 64
    46c4:	4f e0       	ldi	r20, 0x0F	; 15
    46c6:	54 e4       	ldi	r21, 0x44	; 68
    46c8:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    46cc:	1b 01       	movw	r2, r22
    46ce:	2c 01       	movw	r4, r24
    46d0:	6f 2d       	mov	r22, r15
    46d2:	70 2f       	mov	r23, r16
    46d4:	81 2f       	mov	r24, r17
    46d6:	9e 2d       	mov	r25, r14
    46d8:	29 e2       	ldi	r18, 0x29	; 41
    46da:	3c e5       	ldi	r19, 0x5C	; 92
    46dc:	4f e8       	ldi	r20, 0x8F	; 143
    46de:	5e e3       	ldi	r21, 0x3E	; 62
    46e0:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    46e4:	2f 2d       	mov	r18, r15
    46e6:	30 2f       	mov	r19, r16
    46e8:	41 2f       	mov	r20, r17
    46ea:	5e 2d       	mov	r21, r14
    46ec:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    46f0:	20 e0       	ldi	r18, 0x00	; 0
    46f2:	30 e0       	ldi	r19, 0x00	; 0
    46f4:	40 e8       	ldi	r20, 0x80	; 128
    46f6:	5f e3       	ldi	r21, 0x3F	; 63
    46f8:	0e 94 92 37 	call	0x6f24	; 0x6f24 <__addsf3>
    46fc:	9b 01       	movw	r18, r22
    46fe:	ac 01       	movw	r20, r24
    4700:	c2 01       	movw	r24, r4
    4702:	b1 01       	movw	r22, r2
    4704:	0e 94 fa 37 	call	0x6ff4	; 0x6ff4 <__divsf3>
    4708:	0e 94 62 38 	call	0x70c4	; 0x70c4 <__fixsfsi>
		if (x<0) {
    470c:	97 fe       	sbrs	r9, 7
    470e:	35 c0       	rjmp	.+106    	; 0x477a <_atan2+0x12c>
			if (y<0) a -= 1800;
    4710:	d7 fc       	sbrc	r13, 7
    4712:	31 c0       	rjmp	.+98     	; 0x4776 <_atan2+0x128>
			else a += 1800;
    4714:	68 5f       	subi	r22, 0xF8	; 248
    4716:	78 4f       	sbci	r23, 0xF8	; 248
    4718:	30 c0       	rjmp	.+96     	; 0x477a <_atan2+0x12c>
		}
	} else {
		a = 900 - 573 * z / (z * z + 0.28f);
    471a:	6f 2d       	mov	r22, r15
    471c:	70 2f       	mov	r23, r16
    471e:	81 2f       	mov	r24, r17
    4720:	9e 2d       	mov	r25, r14
    4722:	20 e0       	ldi	r18, 0x00	; 0
    4724:	30 e4       	ldi	r19, 0x40	; 64
    4726:	4f e0       	ldi	r20, 0x0F	; 15
    4728:	54 e4       	ldi	r21, 0x44	; 68
    472a:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    472e:	3b 01       	movw	r6, r22
    4730:	4c 01       	movw	r8, r24
    4732:	6f 2d       	mov	r22, r15
    4734:	70 2f       	mov	r23, r16
    4736:	81 2f       	mov	r24, r17
    4738:	9e 2d       	mov	r25, r14
    473a:	2f 2d       	mov	r18, r15
    473c:	30 2f       	mov	r19, r16
    473e:	41 2f       	mov	r20, r17
    4740:	5e 2d       	mov	r21, r14
    4742:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    4746:	29 e2       	ldi	r18, 0x29	; 41
    4748:	3c e5       	ldi	r19, 0x5C	; 92
    474a:	4f e8       	ldi	r20, 0x8F	; 143
    474c:	5e e3       	ldi	r21, 0x3E	; 62
    474e:	0e 94 92 37 	call	0x6f24	; 0x6f24 <__addsf3>
    4752:	9b 01       	movw	r18, r22
    4754:	ac 01       	movw	r20, r24
    4756:	c4 01       	movw	r24, r8
    4758:	b3 01       	movw	r22, r6
    475a:	0e 94 fa 37 	call	0x6ff4	; 0x6ff4 <__divsf3>
    475e:	9b 01       	movw	r18, r22
    4760:	ac 01       	movw	r20, r24
    4762:	60 e0       	ldi	r22, 0x00	; 0
    4764:	70 e0       	ldi	r23, 0x00	; 0
    4766:	81 e6       	ldi	r24, 0x61	; 97
    4768:	94 e4       	ldi	r25, 0x44	; 68
    476a:	0e 94 91 37 	call	0x6f22	; 0x6f22 <__subsf3>
    476e:	0e 94 62 38 	call	0x70c4	; 0x70c4 <__fixsfsi>
		if (y<0) a -= 1800;
    4772:	d7 fe       	sbrs	r13, 7
    4774:	02 c0       	rjmp	.+4      	; 0x477a <_atan2+0x12c>
    4776:	68 50       	subi	r22, 0x08	; 8
    4778:	77 40       	sbci	r23, 0x07	; 7
	}
	return a;
}
    477a:	cb 01       	movw	r24, r22
    477c:	1f 91       	pop	r17
    477e:	0f 91       	pop	r16
    4780:	ff 90       	pop	r15
    4782:	ef 90       	pop	r14
    4784:	df 90       	pop	r13
    4786:	cf 90       	pop	r12
    4788:	bf 90       	pop	r11
    478a:	af 90       	pop	r10
    478c:	9f 90       	pop	r9
    478e:	8f 90       	pop	r8
    4790:	7f 90       	pop	r7
    4792:	6f 90       	pop	r6
    4794:	5f 90       	pop	r5
    4796:	4f 90       	pop	r4
    4798:	3f 90       	pop	r3
    479a:	2f 90       	pop	r2
    479c:	08 95       	ret

0000479e <InvSqrt>:

float InvSqrt (float x)
{
    479e:	6f 92       	push	r6
    47a0:	7f 92       	push	r7
    47a2:	8f 92       	push	r8
    47a4:	9f 92       	push	r9
    47a6:	af 92       	push	r10
    47a8:	bf 92       	push	r11
    47aa:	cf 92       	push	r12
    47ac:	df 92       	push	r13
    47ae:	ef 92       	push	r14
    47b0:	ff 92       	push	r15
    47b2:	0f 93       	push	r16
    47b4:	1f 93       	push	r17
    47b6:	5b 01       	movw	r10, r22
    47b8:	6c 01       	movw	r12, r24
	union{
		int32_t i;
		float   f;
	} conv;
	conv.f = x;
	conv.i = 0x5f3759df - (conv.i >> 1);
    47ba:	dc 01       	movw	r26, r24
    47bc:	cb 01       	movw	r24, r22
    47be:	b5 95       	asr	r27
    47c0:	a7 95       	ror	r26
    47c2:	97 95       	ror	r25
    47c4:	87 95       	ror	r24
    47c6:	2f ed       	ldi	r18, 0xDF	; 223
    47c8:	e2 2e       	mov	r14, r18
    47ca:	29 e5       	ldi	r18, 0x59	; 89
    47cc:	f2 2e       	mov	r15, r18
    47ce:	27 e3       	ldi	r18, 0x37	; 55
    47d0:	02 2f       	mov	r16, r18
    47d2:	2f e5       	ldi	r18, 0x5F	; 95
    47d4:	12 2f       	mov	r17, r18
    47d6:	e8 1a       	sub	r14, r24
    47d8:	f9 0a       	sbc	r15, r25
    47da:	0a 0b       	sbc	r16, r26
    47dc:	1b 0b       	sbc	r17, r27
	return 0.5f * conv.f * (3.0f - x * conv.f * conv.f);
    47de:	c8 01       	movw	r24, r16
    47e0:	b7 01       	movw	r22, r14
    47e2:	20 e0       	ldi	r18, 0x00	; 0
    47e4:	30 e0       	ldi	r19, 0x00	; 0
    47e6:	40 e0       	ldi	r20, 0x00	; 0
    47e8:	5f e3       	ldi	r21, 0x3F	; 63
    47ea:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    47ee:	3b 01       	movw	r6, r22
    47f0:	4c 01       	movw	r8, r24
    47f2:	c6 01       	movw	r24, r12
    47f4:	b5 01       	movw	r22, r10
    47f6:	a8 01       	movw	r20, r16
    47f8:	97 01       	movw	r18, r14
    47fa:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    47fe:	a8 01       	movw	r20, r16
    4800:	97 01       	movw	r18, r14
    4802:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
    4806:	9b 01       	movw	r18, r22
    4808:	ac 01       	movw	r20, r24
    480a:	60 e0       	ldi	r22, 0x00	; 0
    480c:	70 e0       	ldi	r23, 0x00	; 0
    480e:	80 e4       	ldi	r24, 0x40	; 64
    4810:	90 e4       	ldi	r25, 0x40	; 64
    4812:	0e 94 91 37 	call	0x6f22	; 0x6f22 <__subsf3>
    4816:	9b 01       	movw	r18, r22
    4818:	ac 01       	movw	r20, r24
    481a:	c4 01       	movw	r24, r8
    481c:	b3 01       	movw	r22, r6
    481e:	0e 94 49 39 	call	0x7292	; 0x7292 <__mulsf3>
}
    4822:	1f 91       	pop	r17
    4824:	0f 91       	pop	r16
    4826:	ff 90       	pop	r15
    4828:	ef 90       	pop	r14
    482a:	df 90       	pop	r13
    482c:	cf 90       	pop	r12
    482e:	bf 90       	pop	r11
    4830:	af 90       	pop	r10
    4832:	9f 90       	pop	r9
    4834:	8f 90       	pop	r8
    4836:	7f 90       	pop	r7
    4838:	6f 90       	pop	r6
    483a:	08 95       	ret

0000483c <Motor_GenerateOutputSignal>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    483c:	f8 94       	cli
	
	// Make sure we have spent enough time between pulses
	// Also, handle the odd case where the TCNT2_X rolls over and TCNT2_X < ElapsedTCNT2
	ATOMIC_BLOCK(ATOMIC_FORCEON)
   {
      CurrentTCNT2 = TCNT2_X;
    483e:	80 91 bb 05 	lds	r24, 0x05BB
    4842:	90 91 bc 05 	lds	r25, 0x05BC
    4846:	90 93 12 08 	sts	0x0812, r25
    484a:	80 93 11 08 	sts	0x0811, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    484e:	78 94       	sei
   }

   if (CurrentTCNT2 >= MotorStartTCNT) 
    4850:	20 91 11 08 	lds	r18, 0x0811
    4854:	30 91 12 08 	lds	r19, 0x0812
    4858:	80 91 04 08 	lds	r24, 0x0804
    485c:	90 91 05 08 	lds	r25, 0x0805
    4860:	28 17       	cp	r18, r24
    4862:	39 07       	cpc	r19, r25
    4864:	38 f0       	brcs	.+14     	; 0x4874 <Motor_GenerateOutputSignal+0x38>
   {
		ElapsedTCNT2 = CurrentTCNT2 - MotorStartTCNT;
    4866:	28 1b       	sub	r18, r24
    4868:	39 0b       	sbc	r19, r25
    486a:	30 93 ff 07 	sts	0x07FF, r19
    486e:	20 93 fe 07 	sts	0x07FE, r18
    4872:	08 c0       	rjmp	.+16     	; 0x4884 <Motor_GenerateOutputSignal+0x48>
   }
   else 
   {
		ElapsedTCNT2 = (0xffff - MotorStartTCNT) + CurrentTCNT2;
    4874:	80 95       	com	r24
    4876:	90 95       	com	r25
    4878:	82 0f       	add	r24, r18
    487a:	93 1f       	adc	r25, r19
    487c:	90 93 ff 07 	sts	0x07FF, r25
    4880:	80 93 fe 07 	sts	0x07FE, r24
	
	// If period less than 1/ESC_RATE, pad it out.
	// check Timer.c for timing table
	
	//interval in us
	PMW_Pulse_Interval = (PWM_LOW_PULSE_INTERVAL - ( ElapsedTCNT2 * 409)); // 409 = OV time of TCNT2
    4884:	40 91 fe 07 	lds	r20, 0x07FE
    4888:	50 91 ff 07 	lds	r21, 0x07FF
    488c:	89 e9       	ldi	r24, 0x99	; 153
    488e:	91 e0       	ldi	r25, 0x01	; 1
    4890:	48 9f       	mul	r20, r24
    4892:	90 01       	movw	r18, r0
    4894:	49 9f       	mul	r20, r25
    4896:	30 0d       	add	r19, r0
    4898:	58 9f       	mul	r21, r24
    489a:	30 0d       	add	r19, r0
    489c:	11 24       	eor	r1, r1
    489e:	80 ea       	ldi	r24, 0xA0	; 160
    48a0:	9f e0       	ldi	r25, 0x0F	; 15
    48a2:	82 1b       	sub	r24, r18
    48a4:	93 0b       	sbc	r25, r19
    48a6:	0d c0       	rjmp	.+26     	; 0x48c2 <Motor_GenerateOutputSignal+0x86>
	while (PMW_Pulse_Interval > 0)
	{
		//LED_Orange=~LED_Orange;
			TCNT2 =0;
    48a8:	10 92 b2 00 	sts	0x00B2, r1
			if (PMW_Pulse_Interval>100)
    48ac:	85 36       	cpi	r24, 0x65	; 101
    48ae:	91 05       	cpc	r25, r1
    48b0:	3c f0       	brlt	.+14     	; 0x48c0 <Motor_GenerateOutputSignal+0x84>
			{   // make big jumps if PWM_Low_Pulse_Interval is high
				// [more accurate to decrease the % between the while loop and the PWM_Low_Pulse_Interval -=80 execution time.]
				while (TCNT2 < 40); //=8us 1.50
    48b2:	20 91 b2 00 	lds	r18, 0x00B2
    48b6:	28 32       	cpi	r18, 0x28	; 40
    48b8:	e0 f3       	brcs	.-8      	; 0x48b2 <Motor_GenerateOutputSignal+0x76>
				PMW_Pulse_Interval -=80;	
    48ba:	80 55       	subi	r24, 0x50	; 80
    48bc:	90 40       	sbci	r25, 0x00	; 0
    48be:	01 c0       	rjmp	.+2      	; 0x48c2 <Motor_GenerateOutputSignal+0x86>
			}
			else
			{   //
				///////////while (TCNT2 < 5); //=8us
				PMW_Pulse_Interval -=1;
    48c0:	01 97       	sbiw	r24, 0x01	; 1
    48c2:	90 93 0a 08 	sts	0x080A, r25
    48c6:	80 93 09 08 	sts	0x0809, r24
	// If period less than 1/ESC_RATE, pad it out.
	// check Timer.c for timing table
	
	//interval in us
	PMW_Pulse_Interval = (PWM_LOW_PULSE_INTERVAL - ( ElapsedTCNT2 * 409)); // 409 = OV time of TCNT2
	while (PMW_Pulse_Interval > 0)
    48ca:	80 91 09 08 	lds	r24, 0x0809
    48ce:	90 91 0a 08 	lds	r25, 0x080A
    48d2:	18 16       	cp	r1, r24
    48d4:	19 06       	cpc	r1, r25
    48d6:	44 f3       	brlt	.-48     	; 0x48a8 <Motor_GenerateOutputSignal+0x6c>
				PMW_Pulse_Interval -=1;
			}
			
	}
	
	times+=1;
    48d8:	80 91 36 05 	lds	r24, 0x0536
    48dc:	8f 5f       	subi	r24, 0xFF	; 255
    48de:	80 93 36 05 	sts	0x0536, r24
	
	// Set motor limits (0 -> MOTORS_HIGH_VALUE)
	if ( MotorOut[0] < 0 ) m1 = 0;
    48e2:	80 91 96 05 	lds	r24, 0x0596
    48e6:	90 91 97 05 	lds	r25, 0x0597
    48ea:	97 ff       	sbrs	r25, 7
    48ec:	05 c0       	rjmp	.+10     	; 0x48f8 <Motor_GenerateOutputSignal+0xbc>
    48ee:	10 92 0c 08 	sts	0x080C, r1
    48f2:	10 92 0b 08 	sts	0x080B, r1
    48f6:	0a c0       	rjmp	.+20     	; 0x490c <Motor_GenerateOutputSignal+0xd0>
	else if ( MotorOut[0] > MOTORS_HIGH_VALUE ) m1 = MOTORS_HIGH_VALUE;
    48f8:	24 e0       	ldi	r18, 0x04	; 4
    48fa:	8f 37       	cpi	r24, 0x7F	; 127
    48fc:	92 07       	cpc	r25, r18
    48fe:	14 f0       	brlt	.+4      	; 0x4904 <Motor_GenerateOutputSignal+0xc8>
    4900:	8e e7       	ldi	r24, 0x7E	; 126
    4902:	94 e0       	ldi	r25, 0x04	; 4
	else m1 = MotorOut[0];
    4904:	90 93 0c 08 	sts	0x080C, r25
    4908:	80 93 0b 08 	sts	0x080B, r24
	
	if ( MotorOut[1] < 0 ) m2 = 0;
    490c:	80 91 98 05 	lds	r24, 0x0598
    4910:	90 91 99 05 	lds	r25, 0x0599
    4914:	97 ff       	sbrs	r25, 7
    4916:	05 c0       	rjmp	.+10     	; 0x4922 <Motor_GenerateOutputSignal+0xe6>
    4918:	10 92 03 08 	sts	0x0803, r1
    491c:	10 92 02 08 	sts	0x0802, r1
    4920:	0a c0       	rjmp	.+20     	; 0x4936 <Motor_GenerateOutputSignal+0xfa>
	else if ( MotorOut[1] > MOTORS_HIGH_VALUE ) m2 = MOTORS_HIGH_VALUE;
    4922:	24 e0       	ldi	r18, 0x04	; 4
    4924:	8f 37       	cpi	r24, 0x7F	; 127
    4926:	92 07       	cpc	r25, r18
    4928:	14 f0       	brlt	.+4      	; 0x492e <Motor_GenerateOutputSignal+0xf2>
    492a:	8e e7       	ldi	r24, 0x7E	; 126
    492c:	94 e0       	ldi	r25, 0x04	; 4
	else m2 = MotorOut[1];
    492e:	90 93 03 08 	sts	0x0803, r25
    4932:	80 93 02 08 	sts	0x0802, r24

	if ( MotorOut[2] < 0 ) m3 = 0;
    4936:	80 91 9a 05 	lds	r24, 0x059A
    493a:	90 91 9b 05 	lds	r25, 0x059B
    493e:	97 ff       	sbrs	r25, 7
    4940:	05 c0       	rjmp	.+10     	; 0x494c <Motor_GenerateOutputSignal+0x110>
    4942:	10 92 10 08 	sts	0x0810, r1
    4946:	10 92 0f 08 	sts	0x080F, r1
    494a:	0a c0       	rjmp	.+20     	; 0x4960 <Motor_GenerateOutputSignal+0x124>
	else if ( MotorOut[2] > MOTORS_HIGH_VALUE ) m3 = MOTORS_HIGH_VALUE;
    494c:	24 e0       	ldi	r18, 0x04	; 4
    494e:	8f 37       	cpi	r24, 0x7F	; 127
    4950:	92 07       	cpc	r25, r18
    4952:	14 f0       	brlt	.+4      	; 0x4958 <Motor_GenerateOutputSignal+0x11c>
    4954:	8e e7       	ldi	r24, 0x7E	; 126
    4956:	94 e0       	ldi	r25, 0x04	; 4
	else m3 = MotorOut[2];
    4958:	90 93 10 08 	sts	0x0810, r25
    495c:	80 93 0f 08 	sts	0x080F, r24

	if ( MotorOut[3] < 0 ) m4 = 0;
    4960:	80 91 9c 05 	lds	r24, 0x059C
    4964:	90 91 9d 05 	lds	r25, 0x059D
    4968:	97 ff       	sbrs	r25, 7
    496a:	05 c0       	rjmp	.+10     	; 0x4976 <Motor_GenerateOutputSignal+0x13a>
    496c:	10 92 01 08 	sts	0x0801, r1
    4970:	10 92 00 08 	sts	0x0800, r1
    4974:	0a c0       	rjmp	.+20     	; 0x498a <Motor_GenerateOutputSignal+0x14e>
	else if ( MotorOut[3] > MOTORS_HIGH_VALUE ) m4 = MOTORS_HIGH_VALUE;
    4976:	24 e0       	ldi	r18, 0x04	; 4
    4978:	8f 37       	cpi	r24, 0x7F	; 127
    497a:	92 07       	cpc	r25, r18
    497c:	14 f0       	brlt	.+4      	; 0x4982 <Motor_GenerateOutputSignal+0x146>
    497e:	8e e7       	ldi	r24, 0x7E	; 126
    4980:	94 e0       	ldi	r25, 0x04	; 4
	else m4 = MotorOut[3];
    4982:	90 93 01 08 	sts	0x0801, r25
    4986:	80 93 00 08 	sts	0x0800, r24
	
	
	// Minimum pulse we want to make is 1ms, max is 2ms
	// So to start, let's make the 1ms base pulse.
	// First, we switch on the motor outputs
	M1 = 1;
    498a:	46 9a       	sbi	0x08, 6	; 8
	M2 = 1;
    498c:	44 9a       	sbi	0x08, 4	; 8
	M3 = 1;
    498e:	42 9a       	sbi	0x08, 2	; 8
	if (Config.FrameType== FRAMETYPE_QUADCOPTER) 
    4990:	80 91 f0 06 	lds	r24, 0x06F0
    4994:	81 30       	cpi	r24, 0x01	; 1
    4996:	11 f4       	brne	.+4      	; 0x499c <Motor_GenerateOutputSignal+0x160>
	{
		M4 =1;
    4998:	43 9a       	sbi	0x08, 3	; 8
    499a:	09 c0       	rjmp	.+18     	; 0x49ae <Motor_GenerateOutputSignal+0x172>
	}
	else if (Config.FrameType== FRAMETYPE_TRICOPTER)
    499c:	82 30       	cpi	r24, 0x02	; 2
    499e:	39 f4       	brne	.+14     	; 0x49ae <Motor_GenerateOutputSignal+0x172>
	{
		if (times==5)
    49a0:	80 91 36 05 	lds	r24, 0x0536
    49a4:	85 30       	cpi	r24, 0x05	; 5
    49a6:	19 f4       	brne	.+6      	; 0x49ae <Motor_GenerateOutputSignal+0x172>
		{
			M4 = 1;		// time to update servo
    49a8:	43 9a       	sbi	0x08, 3	; 8
			//UpdateServo = FALSE;
			times=0;	// reset time divider
    49aa:	10 92 36 05 	sts	0x0536, r1
		} // else keep it zero.			
	} 
	
	
	// Minimum pulse width we want to make is 1ms, max is 2ms
	PMW_Pulse_Interval = BASE_PULSE + Config.ThrottleMin;
    49ae:	80 91 f4 06 	lds	r24, 0x06F4
    49b2:	90 e0       	ldi	r25, 0x00	; 0
    49b4:	80 5e       	subi	r24, 0xE0	; 224
    49b6:	9c 4f       	sbci	r25, 0xFC	; 252
    49b8:	0d c0       	rjmp	.+26     	; 0x49d4 <Motor_GenerateOutputSignal+0x198>
	while (PMW_Pulse_Interval > 0)
	{
			TCNT2 =0;
    49ba:	10 92 b2 00 	sts	0x00B2, r1
			if (PMW_Pulse_Interval>100)
    49be:	85 36       	cpi	r24, 0x65	; 101
    49c0:	91 05       	cpc	r25, r1
    49c2:	3c f0       	brlt	.+14     	; 0x49d2 <Motor_GenerateOutputSignal+0x196>
			{   // make big jumps if PWM_Low_Pulse_Interval is high
				// [more accurate to decrease the % between the while loop and the PWM_Low_Pulse_Interval -=80 execution time.]
				while (TCNT2 < 45); //=8us //1. 50
    49c4:	20 91 b2 00 	lds	r18, 0x00B2
    49c8:	2d 32       	cpi	r18, 0x2D	; 45
    49ca:	e0 f3       	brcs	.-8      	; 0x49c4 <Motor_GenerateOutputSignal+0x188>
				PMW_Pulse_Interval -=80;	
    49cc:	80 55       	subi	r24, 0x50	; 80
    49ce:	90 40       	sbci	r25, 0x00	; 0
    49d0:	01 c0       	rjmp	.+2      	; 0x49d4 <Motor_GenerateOutputSignal+0x198>
			}
			else
			{   //
				//////while (TCNT2 < 5); //=8us
				PMW_Pulse_Interval -=1;
    49d2:	01 97       	sbiw	r24, 0x01	; 1
    49d4:	90 93 0a 08 	sts	0x080A, r25
    49d8:	80 93 09 08 	sts	0x0809, r24
	} 
	
	
	// Minimum pulse width we want to make is 1ms, max is 2ms
	PMW_Pulse_Interval = BASE_PULSE + Config.ThrottleMin;
	while (PMW_Pulse_Interval > 0)
    49dc:	80 91 09 08 	lds	r24, 0x0809
    49e0:	90 91 0a 08 	lds	r25, 0x080A
    49e4:	18 16       	cp	r1, r24
    49e6:	19 06       	cpc	r1, r25
    49e8:	44 f3       	brlt	.-48     	; 0x49ba <Motor_GenerateOutputSignal+0x17e>
				PMW_Pulse_Interval -=1;
			}
	}
		
	
	for (i=0;i<MOTORS_HIGH_VALUE+4;i+=4)			// 1000 gives a max of 2200us 
    49ea:	10 92 08 08 	sts	0x0808, r1
    49ee:	10 92 07 08 	sts	0x0807, r1
    49f2:	39 c0       	rjmp	.+114    	; 0x4a66 <Motor_GenerateOutputSignal+0x22a>
		/*
		MOTORS_HIGH_VALUE+4
		in order to guarantee that all Ms are zeros when getting out of this loop.
		*/
		
		if (i>=m1) M1 = 0;
    49f4:	20 91 07 08 	lds	r18, 0x0807
    49f8:	30 91 08 08 	lds	r19, 0x0808
    49fc:	80 91 0b 08 	lds	r24, 0x080B
    4a00:	90 91 0c 08 	lds	r25, 0x080C
    4a04:	28 17       	cp	r18, r24
    4a06:	39 07       	cpc	r19, r25
    4a08:	08 f0       	brcs	.+2      	; 0x4a0c <Motor_GenerateOutputSignal+0x1d0>
    4a0a:	46 98       	cbi	0x08, 6	; 8
		if (i>=m2) M2 = 0;
    4a0c:	20 91 07 08 	lds	r18, 0x0807
    4a10:	30 91 08 08 	lds	r19, 0x0808
    4a14:	80 91 02 08 	lds	r24, 0x0802
    4a18:	90 91 03 08 	lds	r25, 0x0803
    4a1c:	28 17       	cp	r18, r24
    4a1e:	39 07       	cpc	r19, r25
    4a20:	08 f0       	brcs	.+2      	; 0x4a24 <Motor_GenerateOutputSignal+0x1e8>
    4a22:	44 98       	cbi	0x08, 4	; 8
		if (i>=m3) M3 = 0;
    4a24:	20 91 07 08 	lds	r18, 0x0807
    4a28:	30 91 08 08 	lds	r19, 0x0808
    4a2c:	80 91 0f 08 	lds	r24, 0x080F
    4a30:	90 91 10 08 	lds	r25, 0x0810
    4a34:	28 17       	cp	r18, r24
    4a36:	39 07       	cpc	r19, r25
    4a38:	08 f0       	brcs	.+2      	; 0x4a3c <Motor_GenerateOutputSignal+0x200>
    4a3a:	42 98       	cbi	0x08, 2	; 8
		if (i>=m4) M4 = 0;
    4a3c:	20 91 07 08 	lds	r18, 0x0807
    4a40:	30 91 08 08 	lds	r19, 0x0808
    4a44:	80 91 00 08 	lds	r24, 0x0800
    4a48:	90 91 01 08 	lds	r25, 0x0801
    4a4c:	28 17       	cp	r18, r24
    4a4e:	39 07       	cpc	r19, r25
    4a50:	08 f0       	brcs	.+2      	; 0x4a54 <Motor_GenerateOutputSignal+0x218>
    4a52:	43 98       	cbi	0x08, 3	; 8
				PMW_Pulse_Interval -=1;
			}
	}
		
	
	for (i=0;i<MOTORS_HIGH_VALUE+4;i+=4)			// 1000 gives a max of 2200us 
    4a54:	80 91 07 08 	lds	r24, 0x0807
    4a58:	90 91 08 08 	lds	r25, 0x0808
    4a5c:	04 96       	adiw	r24, 0x04	; 4
    4a5e:	90 93 08 08 	sts	0x0808, r25
    4a62:	80 93 07 08 	sts	0x0807, r24
    4a66:	80 91 07 08 	lds	r24, 0x0807
    4a6a:	90 91 08 08 	lds	r25, 0x0808
    4a6e:	24 e0       	ldi	r18, 0x04	; 4
    4a70:	82 38       	cpi	r24, 0x82	; 130
    4a72:	92 07       	cpc	r25, r18
    4a74:	08 f4       	brcc	.+2      	; 0x4a78 <Motor_GenerateOutputSignal+0x23c>
    4a76:	be cf       	rjmp	.-132    	; 0x49f4 <Motor_GenerateOutputSignal+0x1b8>
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    4a78:	f8 94       	cli
		if (i>=m4) M4 = 0;
	}
	// Measure period of ESC rate from here
    ATOMIC_BLOCK(ATOMIC_FORCEON)
    {
      MotorStartTCNT = TCNT2_X;
    4a7a:	80 91 bb 05 	lds	r24, 0x05BB
    4a7e:	90 91 bc 05 	lds	r25, 0x05BC
    4a82:	90 93 05 08 	sts	0x0805, r25
    4a86:	80 93 04 08 	sts	0x0804, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    4a8a:	78 94       	sei
    }
	
	
 }
    4a8c:	08 95       	ret

00004a8e <CalculateSignalLength1>:



void CalculateSignalLength1(uint8_t ChannelIndex)
{
	if (TCNT1 > RX_raw[0][ChannelIndex] )
    4a8e:	20 91 84 00 	lds	r18, 0x0084
    4a92:	30 91 85 00 	lds	r19, 0x0085
    4a96:	90 e0       	ldi	r25, 0x00	; 0
    4a98:	88 0f       	add	r24, r24
    4a9a:	99 1f       	adc	r25, r25
    4a9c:	fc 01       	movw	r30, r24
    4a9e:	ee 5d       	subi	r30, 0xDE	; 222
    4aa0:	f7 4f       	sbci	r31, 0xF7	; 247
    4aa2:	40 81       	ld	r20, Z
    4aa4:	51 81       	ldd	r21, Z+1	; 0x01
    4aa6:	dc 01       	movw	r26, r24
    4aa8:	a4 53       	subi	r26, 0x34	; 52
    4aaa:	ba 4f       	sbci	r27, 0xFA	; 250
    4aac:	42 17       	cp	r20, r18
    4aae:	53 07       	cpc	r21, r19
    4ab0:	48 f4       	brcc	.+18     	; 0x4ac4 <CalculateSignalLength1+0x36>
	{
		RX_Length[0][ChannelIndex] = TCNT1 - RX_raw[0][ChannelIndex] ;	
    4ab2:	20 91 84 00 	lds	r18, 0x0084
    4ab6:	30 91 85 00 	lds	r19, 0x0085
    4aba:	80 81       	ld	r24, Z
    4abc:	91 81       	ldd	r25, Z+1	; 0x01
    4abe:	28 1b       	sub	r18, r24
    4ac0:	39 0b       	sbc	r19, r25
    4ac2:	0a c0       	rjmp	.+20     	; 0x4ad8 <CalculateSignalLength1+0x4a>
	}
	else
	{
		RX_Length[0][ChannelIndex] = (0xffff - RX_raw[0][ChannelIndex] + TCNT1 );	
    4ac4:	20 81       	ld	r18, Z
    4ac6:	31 81       	ldd	r19, Z+1	; 0x01
    4ac8:	80 91 84 00 	lds	r24, 0x0084
    4acc:	90 91 85 00 	lds	r25, 0x0085
    4ad0:	20 95       	com	r18
    4ad2:	30 95       	com	r19
    4ad4:	28 0f       	add	r18, r24
    4ad6:	39 1f       	adc	r19, r25
    4ad8:	11 96       	adiw	r26, 0x01	; 1
    4ada:	3c 93       	st	X, r19
    4adc:	2e 93       	st	-X, r18
    4ade:	08 95       	ret

00004ae0 <CalculateSignalLength2>:
	}
	
}
void CalculateSignalLength2(uint8_t ChannelIndex)
{
	uint16_t TCNT1_TEMP = TCNT1;
    4ae0:	20 91 84 00 	lds	r18, 0x0084
    4ae4:	30 91 85 00 	lds	r19, 0x0085
	if (TCNT1_TEMP > RX_raw[1][ChannelIndex] )
    4ae8:	90 e0       	ldi	r25, 0x00	; 0
    4aea:	05 96       	adiw	r24, 0x05	; 5
    4aec:	88 0f       	add	r24, r24
    4aee:	99 1f       	adc	r25, r25
    4af0:	fc 01       	movw	r30, r24
    4af2:	ee 5d       	subi	r30, 0xDE	; 222
    4af4:	f7 4f       	sbci	r31, 0xF7	; 247
    4af6:	40 81       	ld	r20, Z
    4af8:	51 81       	ldd	r21, Z+1	; 0x01
    4afa:	dc 01       	movw	r26, r24
    4afc:	a4 53       	subi	r26, 0x34	; 52
    4afe:	ba 4f       	sbci	r27, 0xFA	; 250
    4b00:	42 17       	cp	r20, r18
    4b02:	53 07       	cpc	r21, r19
    4b04:	40 f4       	brcc	.+16     	; 0x4b16 <CalculateSignalLength2+0x36>
	{
		RX_Length[1][ChannelIndex] = TCNT1_TEMP - RX_raw[1][ChannelIndex] ;	
    4b06:	80 81       	ld	r24, Z
    4b08:	91 81       	ldd	r25, Z+1	; 0x01
    4b0a:	28 1b       	sub	r18, r24
    4b0c:	39 0b       	sbc	r19, r25
    4b0e:	11 96       	adiw	r26, 0x01	; 1
    4b10:	3c 93       	st	X, r19
    4b12:	2e 93       	st	-X, r18
    4b14:	08 95       	ret
	}
	else
	{
		RX_Length[1][ChannelIndex] = (0xffff - RX_raw[1][ChannelIndex] + TCNT1_TEMP);	
    4b16:	40 81       	ld	r20, Z
    4b18:	51 81       	ldd	r21, Z+1	; 0x01
    4b1a:	40 95       	com	r20
    4b1c:	50 95       	com	r21
    4b1e:	42 0f       	add	r20, r18
    4b20:	53 1f       	adc	r21, r19
    4b22:	11 96       	adiw	r26, 0x01	; 1
    4b24:	5c 93       	st	X, r21
    4b26:	4e 93       	st	-X, r20
    4b28:	08 95       	ret

00004b2a <RX_Init>:


void RX_Init(void)
{
	
	RX_AUX_DIR   	 	= INPUT;
    4b2a:	20 98       	cbi	0x04, 0	; 4

#ifdef PRIMARY_INPUT_RX

	if (Config.RX_mode==RX_mode_BuddyMode)
    4b2c:	80 91 eb 06 	lds	r24, 0x06EB
    4b30:	88 23       	and	r24, r24
    4b32:	f1 f4       	brne	.+60     	; 0x4b70 <RX_Init+0x46>
	{
	
		ActiveRXIndex=0;
    4b34:	10 92 ca 05 	sts	0x05CA, r1
		RX1_ROLL_DIR 		= INPUT;
    4b38:	52 98       	cbi	0x0a, 2	; 10
		RX1_PITCH_DIR 		= INPUT;
    4b3a:	50 98       	cbi	0x0a, 0	; 10
		RX1_COLL_DIR   		= INPUT;
    4b3c:	53 98       	cbi	0x0a, 3	; 10
		RX1_YAW_DIR   	 	= INPUT;
    4b3e:	22 98       	cbi	0x04, 2	; 4

		// enable interrupts
		EICRA  = _BV(ISC00) | _BV(ISC10) | _BV(ISC20);	// any edge on INT0, INT1 and INT2
    4b40:	85 e1       	ldi	r24, 0x15	; 21
    4b42:	80 93 69 00 	sts	0x0069, r24
		EIMSK  = _BV(INT0)  | _BV(INT1)  | _BV(INT2);	// enable interrupt for INT0, INT1 and INT2
    4b46:	87 e0       	ldi	r24, 0x07	; 7
    4b48:	8d bb       	out	0x1d, r24	; 29
		EIFR   = _BV(INTF0) | _BV(INTF1) | _BV(INTF2);	// clear interrupts
    4b4a:	8c bb       	out	0x1c, r24	; 28
		
		PCICR  |= _BV(PCIE1) | _BV(PCIE3);				// enable PCI1 and PCI3
    4b4c:	80 91 68 00 	lds	r24, 0x0068
    4b50:	8a 60       	ori	r24, 0x0A	; 10
    4b52:	80 93 68 00 	sts	0x0068, r24
		PCMSK1 |= _BV(PCINT8);							// enable PCINT8 (AUX) -> PCI1
    4b56:	80 91 6c 00 	lds	r24, 0x006C
    4b5a:	81 60       	ori	r24, 0x01	; 1
    4b5c:	80 93 6c 00 	sts	0x006C, r24
		PCMSK3 |= _BV(PCINT24);							// enable PCINT24 (THR) -> PCI3
    4b60:	80 91 73 00 	lds	r24, 0x0073
    4b64:	81 60       	ori	r24, 0x01	; 1
    4b66:	80 93 73 00 	sts	0x0073, r24
		PCIFR  |= _BV(PCIF1) | _BV(PCIF3);
    4b6a:	8b b3       	in	r24, 0x1b	; 27
    4b6c:	8a 60       	ori	r24, 0x0A	; 10
    4b6e:	8b bb       	out	0x1b, r24	; 27
#endif

	
#ifdef SECONDARY_INPUT_RX

	ActiveRXIndex=1;
    4b70:	81 e0       	ldi	r24, 0x01	; 1
    4b72:	80 93 ca 05 	sts	0x05CA, r24
	RX2_ROLL_DIR 		= INPUT;
    4b76:	3d 98       	cbi	0x07, 5	; 7
	RX2_PITCH_DIR 		= INPUT;
    4b78:	38 98       	cbi	0x07, 0	; 7
	RX2_COLL_DIR   		= INPUT;
    4b7a:	3f 98       	cbi	0x07, 7	; 7
	RX2_YAW_DIR   	 	= INPUT;
    4b7c:	39 98       	cbi	0x07, 1	; 7
	PCINT16 - PC0 - OUTPUT 6
	PCINT17 - PC1 - OUTPUT 5 
	PCINT21 - PC5 - OUTPUT 7
	PCINT23 - PC7 - OUTPUT 8 
	*/
	PCICR  |= _BV(PCIE1)   | _BV(PCIE2);														// enable PCI1 and PCI2
    4b7e:	80 91 68 00 	lds	r24, 0x0068
    4b82:	86 60       	ori	r24, 0x06	; 6
    4b84:	80 93 68 00 	sts	0x0068, r24
	PCMSK1 |= _BV(PCINT8);																		// enable PCINT8 (AUX) -> PCI1
    4b88:	80 91 6c 00 	lds	r24, 0x006C
    4b8c:	81 60       	ori	r24, 0x01	; 1
    4b8e:	80 93 6c 00 	sts	0x006C, r24
	PCMSK2 |= _BV(PCINT16) | _BV(PCINT17) | _BV(PCINT21) |_BV(PCINT23);							// enable PCINT24 (THR) -> PCI3
    4b92:	80 91 6d 00 	lds	r24, 0x006D
    4b96:	83 6a       	ori	r24, 0xA3	; 163
    4b98:	80 93 6d 00 	sts	0x006D, r24
	PCIFR  |= _BV(PCIF1)   | _BV(PCIF2);														// clear interrupts
    4b9c:	8b b3       	in	r24, 0x1b	; 27
    4b9e:	86 60       	ori	r24, 0x06	; 6
    4ba0:	8b bb       	out	0x1b, r24	; 27
#endif
	

		
	
	RX_Good =TX1_NOT_FOUND;
    4ba2:	80 91 fb 07 	lds	r24, 0x07FB
    4ba6:	81 60       	ori	r24, 0x01	; 1
    4ba8:	80 93 fb 07 	sts	0x07FB, r24
	RX_Good =TX2_NOT_FOUND;
    4bac:	80 91 fb 07 	lds	r24, 0x07FB
    4bb0:	80 61       	ori	r24, 0x10	; 16
    4bb2:	80 93 fb 07 	sts	0x07FB, r24
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    4bb6:	f8 94       	cli
	
	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		RX1_LastValidSignal_timestamp= TCNT1_X;
    4bb8:	80 91 70 06 	lds	r24, 0x0670
    4bbc:	90 91 71 06 	lds	r25, 0x0671
    4bc0:	90 93 1a 08 	sts	0x081A, r25
    4bc4:	80 93 19 08 	sts	0x0819, r24
		RX1_LastValidSignal_timestampAux= TCNT1_X;
    4bc8:	80 91 70 06 	lds	r24, 0x0670
    4bcc:	90 91 71 06 	lds	r25, 0x0671
    4bd0:	90 93 1c 08 	sts	0x081C, r25
    4bd4:	80 93 1b 08 	sts	0x081B, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    4bd8:	78 94       	sei
	}	
	
	RX2_LastValidSignal_timestamp= RX2_LastValidSignal_timestamp;
    4bda:	80 91 17 08 	lds	r24, 0x0817
    4bde:	90 91 18 08 	lds	r25, 0x0818
    4be2:	90 93 18 08 	sts	0x0818, r25
    4be6:	80 93 17 08 	sts	0x0817, r24
	RX2_LastValidSignal_timestampAux= RX2_LastValidSignal_timestampAux;	
    4bea:	80 91 13 08 	lds	r24, 0x0813
    4bee:	90 91 14 08 	lds	r25, 0x0814
    4bf2:	90 93 14 08 	sts	0x0814, r25
    4bf6:	80 93 13 08 	sts	0x0813, r24
}
    4bfa:	08 95       	ret

00004bfc <RX_raw_GetReceiverValues>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    4bfc:	f8 94       	cli
  uint16_t RX_raw_GetReceiverValues (uint8_t RXIndex, uint8_t Channel)
{
	uint16_t _t;
	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		_t = RX_Length[RXIndex][Channel];
    4bfe:	90 e0       	ldi	r25, 0x00	; 0
    4c00:	fc 01       	movw	r30, r24
    4c02:	ee 0f       	add	r30, r30
    4c04:	ff 1f       	adc	r31, r31
    4c06:	ee 0f       	add	r30, r30
    4c08:	ff 1f       	adc	r31, r31
    4c0a:	e8 0f       	add	r30, r24
    4c0c:	f9 1f       	adc	r31, r25
    4c0e:	e6 0f       	add	r30, r22
    4c10:	f1 1d       	adc	r31, r1
    4c12:	ee 0f       	add	r30, r30
    4c14:	ff 1f       	adc	r31, r31
    4c16:	e4 53       	subi	r30, 0x34	; 52
    4c18:	fa 4f       	sbci	r31, 0xFA	; 250
    4c1a:	20 81       	ld	r18, Z
    4c1c:	31 81       	ldd	r19, Z+1	; 0x01
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    4c1e:	78 94       	sei
	}		
	return _t;
}
    4c20:	c9 01       	movw	r24, r18
    4c22:	08 95       	ret

00004c24 <RX_GetReceiverValues>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    4c24:	f8 94       	cli
{
	int16_t _t;
	//////if (RX_Good != TX_GOOD) return 0;
	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		_t = ((int)(RX_Length[RXIndex][Channel]));
    4c26:	90 e0       	ldi	r25, 0x00	; 0
    4c28:	70 e0       	ldi	r23, 0x00	; 0
    4c2a:	9c 01       	movw	r18, r24
    4c2c:	22 0f       	add	r18, r18
    4c2e:	33 1f       	adc	r19, r19
    4c30:	22 0f       	add	r18, r18
    4c32:	33 1f       	adc	r19, r19
    4c34:	28 0f       	add	r18, r24
    4c36:	39 1f       	adc	r19, r25
    4c38:	a9 01       	movw	r20, r18
    4c3a:	46 0f       	add	r20, r22
    4c3c:	57 1f       	adc	r21, r23
    4c3e:	44 0f       	add	r20, r20
    4c40:	55 1f       	adc	r21, r21
    4c42:	fa 01       	movw	r30, r20
    4c44:	e4 53       	subi	r30, 0x34	; 52
    4c46:	fa 4f       	sbci	r31, 0xFA	; 250
    4c48:	80 81       	ld	r24, Z
    4c4a:	91 81       	ldd	r25, Z+1	; 0x01
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    4c4c:	78 94       	sei
	}		
	_t -= Config.RX_Mid[RXIndex][Channel];
    4c4e:	44 5a       	subi	r20, 0xA4	; 164
    4c50:	58 4f       	sbci	r21, 0xF8	; 248
    4c52:	fa 01       	movw	r30, r20
    4c54:	40 81       	ld	r20, Z
    4c56:	51 81       	ldd	r21, Z+1	; 0x01
    4c58:	84 1b       	sub	r24, r20
    4c5a:	95 0b       	sbc	r25, r21
	_t /=Config.RX_DiV_Value[RXIndex][Channel]; //RX_Div_Factor;
    4c5c:	26 0f       	add	r18, r22
    4c5e:	37 1f       	adc	r19, r23
    4c60:	2c 55       	subi	r18, 0x5C	; 92
    4c62:	38 4f       	sbci	r19, 0xF8	; 248
    4c64:	f9 01       	movw	r30, r18
    4c66:	60 81       	ld	r22, Z
    4c68:	77 27       	eor	r23, r23
    4c6a:	67 fd       	sbrc	r22, 7
    4c6c:	70 95       	com	r23
    4c6e:	0e 94 43 3a 	call	0x7486	; 0x7486 <__divmodhi4>
	return _t;
}
    4c72:	cb 01       	movw	r24, r22
    4c74:	08 95       	ret

00004c76 <RX_GetReceiverThrottleValue>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    4c76:	f8 94       	cli
	
	///if (RX_Good != TX_GOOD) return 0;
	
	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		if (RXIndex==0)
    4c78:	88 23       	and	r24, r24
    4c7a:	11 f5       	brne	.+68     	; 0x4cc0 <RX_GetReceiverThrottleValue+0x4a>
		{
			if ( (TCNT1_X - RX1_LastValidSignal_timestamp) > RX_SIGNAL_LOST_DURATION)
    4c7c:	40 91 70 06 	lds	r20, 0x0670
    4c80:	50 91 71 06 	lds	r21, 0x0671
    4c84:	60 91 19 08 	lds	r22, 0x0819
    4c88:	70 91 1a 08 	lds	r23, 0x081A
    4c8c:	46 1b       	sub	r20, r22
    4c8e:	57 0b       	sbc	r21, r23
    4c90:	45 31       	cpi	r20, 0x15	; 21
    4c92:	51 05       	cpc	r21, r1
    4c94:	20 f0       	brcs	.+8      	; 0x4c9e <RX_GetReceiverThrottleValue+0x28>
			{
				RX_Good =TX1_NOT_FOUND;
    4c96:	80 91 fb 07 	lds	r24, 0x07FB
    4c9a:	81 60       	ori	r24, 0x01	; 1
    4c9c:	34 c0       	rjmp	.+104    	; 0x4d06 <RX_GetReceiverThrottleValue+0x90>
				return 0;
			}	
		
			if ( (TCNT1_X - RX1_LastValidSignal_timestampAux) > RX_SIGNAL_LOST_DURATION)
    4c9e:	40 91 70 06 	lds	r20, 0x0670
    4ca2:	50 91 71 06 	lds	r21, 0x0671
    4ca6:	60 91 1b 08 	lds	r22, 0x081B
    4caa:	70 91 1c 08 	lds	r23, 0x081C
    4cae:	46 1b       	sub	r20, r22
    4cb0:	57 0b       	sbc	r21, r23
    4cb2:	45 31       	cpi	r20, 0x15	; 21
    4cb4:	51 05       	cpc	r21, r1
    4cb6:	68 f1       	brcs	.+90     	; 0x4d12 <RX_GetReceiverThrottleValue+0x9c>
			{
				RX_Good =TX1_DISCONNECTED;
    4cb8:	80 91 fb 07 	lds	r24, 0x07FB
    4cbc:	82 60       	ori	r24, 0x02	; 2
    4cbe:	23 c0       	rjmp	.+70     	; 0x4d06 <RX_GetReceiverThrottleValue+0x90>
				return 0;
			}
		}	
		if (RXIndex==1)
    4cc0:	81 30       	cpi	r24, 0x01	; 1
    4cc2:	39 f5       	brne	.+78     	; 0x4d12 <RX_GetReceiverThrottleValue+0x9c>
		{
			if ( (TCNT1_X - RX2_LastValidSignal_timestamp) > RX_SIGNAL_LOST_DURATION)
    4cc4:	40 91 70 06 	lds	r20, 0x0670
    4cc8:	50 91 71 06 	lds	r21, 0x0671
    4ccc:	60 91 17 08 	lds	r22, 0x0817
    4cd0:	70 91 18 08 	lds	r23, 0x0818
    4cd4:	46 1b       	sub	r20, r22
    4cd6:	57 0b       	sbc	r21, r23
    4cd8:	45 31       	cpi	r20, 0x15	; 21
    4cda:	51 05       	cpc	r21, r1
    4cdc:	20 f0       	brcs	.+8      	; 0x4ce6 <RX_GetReceiverThrottleValue+0x70>
			{
				RX_Good =TX2_NOT_FOUND;
    4cde:	80 91 fb 07 	lds	r24, 0x07FB
    4ce2:	80 61       	ori	r24, 0x10	; 16
    4ce4:	10 c0       	rjmp	.+32     	; 0x4d06 <RX_GetReceiverThrottleValue+0x90>
				return 0;
			}	
		
			if ( (TCNT1_X - RX2_LastValidSignal_timestampAux) > RX_SIGNAL_LOST_DURATION)
    4ce6:	40 91 70 06 	lds	r20, 0x0670
    4cea:	50 91 71 06 	lds	r21, 0x0671
    4cee:	60 91 13 08 	lds	r22, 0x0813
    4cf2:	70 91 14 08 	lds	r23, 0x0814
    4cf6:	46 1b       	sub	r20, r22
    4cf8:	57 0b       	sbc	r21, r23
    4cfa:	45 31       	cpi	r20, 0x15	; 21
    4cfc:	51 05       	cpc	r21, r1
    4cfe:	48 f0       	brcs	.+18     	; 0x4d12 <RX_GetReceiverThrottleValue+0x9c>
			{
				RX_Good =TX2_DISCONNECTED;
    4d00:	80 91 fb 07 	lds	r24, 0x07FB
    4d04:	80 62       	ori	r24, 0x20	; 32
    4d06:	80 93 fb 07 	sts	0x07FB, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    4d0a:	78 94       	sei
    __asm__ volatile ("" ::: "memory");
    4d0c:	20 e0       	ldi	r18, 0x00	; 0
    4d0e:	30 e0       	ldi	r19, 0x00	; 0
    4d10:	41 c0       	rjmp	.+130    	; 0x4d94 <RX_GetReceiverThrottleValue+0x11e>
				return 0;
			}
		}			
		
		
		iTemp16 = ((int)(RX_Length[RXIndex][RXChannel_THR]));
    4d12:	28 2f       	mov	r18, r24
    4d14:	30 e0       	ldi	r19, 0x00	; 0
    4d16:	c9 01       	movw	r24, r18
    4d18:	88 0f       	add	r24, r24
    4d1a:	99 1f       	adc	r25, r25
    4d1c:	a9 01       	movw	r20, r18
    4d1e:	b3 e0       	ldi	r27, 0x03	; 3
    4d20:	44 0f       	add	r20, r20
    4d22:	55 1f       	adc	r21, r21
    4d24:	ba 95       	dec	r27
    4d26:	e1 f7       	brne	.-8      	; 0x4d20 <RX_GetReceiverThrottleValue+0xaa>
    4d28:	84 0f       	add	r24, r20
    4d2a:	95 1f       	adc	r25, r21
    4d2c:	fc 01       	movw	r30, r24
    4d2e:	e4 53       	subi	r30, 0x34	; 52
    4d30:	fa 4f       	sbci	r31, 0xFA	; 250
    4d32:	46 81       	ldd	r20, Z+6	; 0x06
    4d34:	57 81       	ldd	r21, Z+7	; 0x07
    4d36:	50 93 1e 08 	sts	0x081E, r21
    4d3a:	40 93 1d 08 	sts	0x081D, r20
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    4d3e:	78 94       	sei
	}		
	
	iTemp16 -= Config.RX_Min[RXIndex][RXChannel_THR];
    4d40:	40 91 1d 08 	lds	r20, 0x081D
    4d44:	50 91 1e 08 	lds	r21, 0x081E
    4d48:	8a 58       	subi	r24, 0x8A	; 138
    4d4a:	98 4f       	sbci	r25, 0xF8	; 248
    4d4c:	fc 01       	movw	r30, r24
    4d4e:	80 81       	ld	r24, Z
    4d50:	91 81       	ldd	r25, Z+1	; 0x01
    4d52:	48 1b       	sub	r20, r24
    4d54:	59 0b       	sbc	r21, r25
    4d56:	50 93 1e 08 	sts	0x081E, r21
    4d5a:	40 93 1d 08 	sts	0x081D, r20
	iTemp16 /= Config.RX_DiV_Value[RXIndex][RXChannel_THR]; //RX_Div_Factor;
    4d5e:	80 91 1d 08 	lds	r24, 0x081D
    4d62:	90 91 1e 08 	lds	r25, 0x081E
    4d66:	f9 01       	movw	r30, r18
    4d68:	ee 0f       	add	r30, r30
    4d6a:	ff 1f       	adc	r31, r31
    4d6c:	ee 0f       	add	r30, r30
    4d6e:	ff 1f       	adc	r31, r31
    4d70:	e2 0f       	add	r30, r18
    4d72:	f3 1f       	adc	r31, r19
    4d74:	e9 55       	subi	r30, 0x59	; 89
    4d76:	f8 4f       	sbci	r31, 0xF8	; 248
    4d78:	60 81       	ld	r22, Z
    4d7a:	77 27       	eor	r23, r23
    4d7c:	67 fd       	sbrc	r22, 7
    4d7e:	70 95       	com	r23
    4d80:	0e 94 43 3a 	call	0x7486	; 0x7486 <__divmodhi4>
    4d84:	70 93 1e 08 	sts	0x081E, r23
    4d88:	60 93 1d 08 	sts	0x081D, r22
	 
	return iTemp16;
    4d8c:	20 91 1d 08 	lds	r18, 0x081D
    4d90:	30 91 1e 08 	lds	r19, 0x081E
}
    4d94:	c9 01       	movw	r24, r18
    4d96:	08 95       	ret

00004d98 <RX_CopyLatestReceiverValues>:
 
void RX_CopyLatestReceiverValues (void)
{
    4d98:	cf 92       	push	r12
    4d9a:	df 92       	push	r13
    4d9c:	ef 92       	push	r14
    4d9e:	ff 92       	push	r15
    4da0:	0f 93       	push	r16
    4da2:	1f 93       	push	r17
    4da4:	cf 93       	push	r28
    4da6:	df 93       	push	r29
	for (int ch=0;ch<2;++ch)
    4da8:	c0 e0       	ldi	r28, 0x00	; 0
    4daa:	d0 e0       	ldi	r29, 0x00	; 0
    4dac:	2d c0       	rjmp	.+90     	; 0x4e08 <RX_CopyLatestReceiverValues+0x70>
	{
		for (int i=0;i<RXChannels;++i)
		{
			if (i == RXChannel_THR)
    4dae:	03 30       	cpi	r16, 0x03	; 3
    4db0:	11 05       	cpc	r17, r1
    4db2:	39 f4       	brne	.+14     	; 0x4dc2 <RX_CopyLatestReceiverValues+0x2a>
			{
				RX_Latest[ch][i]= RX_GetReceiverThrottleValue(ch);	 
    4db4:	8c 2f       	mov	r24, r28
    4db6:	0e 94 3b 26 	call	0x4c76	; 0x4c76 <RX_GetReceiverThrottleValue>
    4dba:	f7 01       	movw	r30, r14
    4dbc:	91 83       	std	Z+1, r25	; 0x01
    4dbe:	80 83       	st	Z, r24
    4dc0:	1a c0       	rjmp	.+52     	; 0x4df6 <RX_CopyLatestReceiverValues+0x5e>
			}
			else
			{
				RX_Latest[ch][i]= RX_GetReceiverValues(ch,i);	 
    4dc2:	8c 2f       	mov	r24, r28
    4dc4:	60 2f       	mov	r22, r16
    4dc6:	0e 94 12 26 	call	0x4c24	; 0x4c24 <RX_GetReceiverValues>
    4dca:	f6 01       	movw	r30, r12
    4dcc:	e0 0f       	add	r30, r16
    4dce:	f1 1f       	adc	r31, r17
    4dd0:	ee 0f       	add	r30, r30
    4dd2:	ff 1f       	adc	r31, r31
    4dd4:	ee 5f       	subi	r30, 0xFE	; 254
    4dd6:	f9 4f       	sbci	r31, 0xF9	; 249
    4dd8:	91 83       	std	Z+1, r25	; 0x01
    4dda:	80 83       	st	Z, r24
				if ((RX_Latest[ch][i]<STICK_DEADBAND) && (RX_Latest[ch][i]>-STICK_DEADBAND)) RX_Latest[ch][i]=0;
    4ddc:	80 81       	ld	r24, Z
    4dde:	91 81       	ldd	r25, Z+1	; 0x01
    4de0:	8f 30       	cpi	r24, 0x0F	; 15
    4de2:	91 05       	cpc	r25, r1
    4de4:	44 f4       	brge	.+16     	; 0x4df6 <RX_CopyLatestReceiverValues+0x5e>
    4de6:	80 81       	ld	r24, Z
    4de8:	91 81       	ldd	r25, Z+1	; 0x01
    4dea:	3f ef       	ldi	r19, 0xFF	; 255
    4dec:	82 3f       	cpi	r24, 0xF2	; 242
    4dee:	93 07       	cpc	r25, r19
    4df0:	14 f0       	brlt	.+4      	; 0x4df6 <RX_CopyLatestReceiverValues+0x5e>
    4df2:	11 82       	std	Z+1, r1	; 0x01
    4df4:	10 82       	st	Z, r1
 
void RX_CopyLatestReceiverValues (void)
{
	for (int ch=0;ch<2;++ch)
	{
		for (int i=0;i<RXChannels;++i)
    4df6:	0f 5f       	subi	r16, 0xFF	; 255
    4df8:	1f 4f       	sbci	r17, 0xFF	; 255
    4dfa:	05 30       	cpi	r16, 0x05	; 5
    4dfc:	11 05       	cpc	r17, r1
    4dfe:	b9 f6       	brne	.-82     	; 0x4dae <RX_CopyLatestReceiverValues+0x16>
	return iTemp16;
}
 
void RX_CopyLatestReceiverValues (void)
{
	for (int ch=0;ch<2;++ch)
    4e00:	21 96       	adiw	r28, 0x01	; 1
    4e02:	c2 30       	cpi	r28, 0x02	; 2
    4e04:	d1 05       	cpc	r29, r1
    4e06:	c9 f0       	breq	.+50     	; 0x4e3a <RX_CopyLatestReceiverValues+0xa2>
	 
	return iTemp16;
}
 
void RX_CopyLatestReceiverValues (void)
{
    4e08:	00 e0       	ldi	r16, 0x00	; 0
    4e0a:	10 e0       	ldi	r17, 0x00	; 0
			{
				RX_Latest[ch][i]= RX_GetReceiverThrottleValue(ch);	 
			}
			else
			{
				RX_Latest[ch][i]= RX_GetReceiverValues(ch,i);	 
    4e0c:	6e 01       	movw	r12, r28
    4e0e:	cc 0c       	add	r12, r12
    4e10:	dd 1c       	adc	r13, r13
    4e12:	cc 0c       	add	r12, r12
    4e14:	dd 1c       	adc	r13, r13
    4e16:	cc 0e       	add	r12, r28
    4e18:	dd 1e       	adc	r13, r29
	{
		for (int i=0;i<RXChannels;++i)
		{
			if (i == RXChannel_THR)
			{
				RX_Latest[ch][i]= RX_GetReceiverThrottleValue(ch);	 
    4e1a:	7e 01       	movw	r14, r28
    4e1c:	ee 0c       	add	r14, r14
    4e1e:	ff 1c       	adc	r15, r15
    4e20:	ce 01       	movw	r24, r28
    4e22:	53 e0       	ldi	r21, 0x03	; 3
    4e24:	88 0f       	add	r24, r24
    4e26:	99 1f       	adc	r25, r25
    4e28:	5a 95       	dec	r21
    4e2a:	e1 f7       	brne	.-8      	; 0x4e24 <RX_CopyLatestReceiverValues+0x8c>
    4e2c:	e8 0e       	add	r14, r24
    4e2e:	f9 1e       	adc	r15, r25
    4e30:	88 e0       	ldi	r24, 0x08	; 8
    4e32:	96 e0       	ldi	r25, 0x06	; 6
    4e34:	e8 0e       	add	r14, r24
    4e36:	f9 1e       	adc	r15, r25
    4e38:	ba cf       	rjmp	.-140    	; 0x4dae <RX_CopyLatestReceiverValues+0x16>
				if ((RX_Latest[ch][i]<STICK_DEADBAND) && (RX_Latest[ch][i]>-STICK_DEADBAND)) RX_Latest[ch][i]=0;
			}
		}	
	}
				
}
    4e3a:	df 91       	pop	r29
    4e3c:	cf 91       	pop	r28
    4e3e:	1f 91       	pop	r17
    4e40:	0f 91       	pop	r16
    4e42:	ff 90       	pop	r15
    4e44:	ef 90       	pop	r14
    4e46:	df 90       	pop	r13
    4e48:	cf 90       	pop	r12
    4e4a:	08 95       	ret

00004e4c <RX_StickCenterCalibrationInit>:

void RX_StickCenterCalibrationInit(uint8_t RXIndex)
{
	for (int i=0; i<RXChannels; ++i)
	{
		RX_MAX_raw[RXIndex][i]=0;
    4e4c:	61 e2       	ldi	r22, 0x21	; 33
    4e4e:	76 e0       	ldi	r23, 0x06	; 6
    4e50:	28 2f       	mov	r18, r24
    4e52:	30 e0       	ldi	r19, 0x00	; 0
    4e54:	f9 01       	movw	r30, r18
    4e56:	ee 0f       	add	r30, r30
    4e58:	ff 1f       	adc	r31, r31
    4e5a:	93 e0       	ldi	r25, 0x03	; 3
    4e5c:	22 0f       	add	r18, r18
    4e5e:	33 1f       	adc	r19, r19
    4e60:	9a 95       	dec	r25
    4e62:	e1 f7       	brne	.-8      	; 0x4e5c <RX_StickCenterCalibrationInit+0x10>
    4e64:	e2 0f       	add	r30, r18
    4e66:	f3 1f       	adc	r31, r19
    4e68:	e6 0f       	add	r30, r22
    4e6a:	f7 1f       	adc	r31, r23
    4e6c:	11 82       	std	Z+1, r1	; 0x01
    4e6e:	10 82       	st	Z, r1
		RX_MIN_raw[RXIndex][i]=0xfffe;
    4e70:	42 ec       	ldi	r20, 0xC2	; 194
    4e72:	56 e0       	ldi	r21, 0x06	; 6
    4e74:	28 2f       	mov	r18, r24
    4e76:	30 e0       	ldi	r19, 0x00	; 0
    4e78:	f9 01       	movw	r30, r18
    4e7a:	ee 0f       	add	r30, r30
    4e7c:	ff 1f       	adc	r31, r31
    4e7e:	a3 e0       	ldi	r26, 0x03	; 3
    4e80:	22 0f       	add	r18, r18
    4e82:	33 1f       	adc	r19, r19
    4e84:	aa 95       	dec	r26
    4e86:	e1 f7       	brne	.-8      	; 0x4e80 <RX_StickCenterCalibrationInit+0x34>
    4e88:	e2 0f       	add	r30, r18
    4e8a:	f3 1f       	adc	r31, r19
    4e8c:	e4 0f       	add	r30, r20
    4e8e:	f5 1f       	adc	r31, r21
    4e90:	2e ef       	ldi	r18, 0xFE	; 254
    4e92:	3f ef       	ldi	r19, 0xFF	; 255
    4e94:	31 83       	std	Z+1, r19	; 0x01
    4e96:	20 83       	st	Z, r18

void RX_StickCenterCalibrationInit(uint8_t RXIndex)
{
	for (int i=0; i<RXChannels; ++i)
	{
		RX_MAX_raw[RXIndex][i]=0;
    4e98:	a8 2f       	mov	r26, r24
    4e9a:	b0 e0       	ldi	r27, 0x00	; 0
    4e9c:	fd 01       	movw	r30, r26
    4e9e:	ee 0f       	add	r30, r30
    4ea0:	ff 1f       	adc	r31, r31
    4ea2:	93 e0       	ldi	r25, 0x03	; 3
    4ea4:	aa 0f       	add	r26, r26
    4ea6:	bb 1f       	adc	r27, r27
    4ea8:	9a 95       	dec	r25
    4eaa:	e1 f7       	brne	.-8      	; 0x4ea4 <RX_StickCenterCalibrationInit+0x58>
    4eac:	ea 0f       	add	r30, r26
    4eae:	fb 1f       	adc	r31, r27
    4eb0:	e6 0f       	add	r30, r22
    4eb2:	f7 1f       	adc	r31, r23
    4eb4:	13 82       	std	Z+3, r1	; 0x03
    4eb6:	12 82       	std	Z+2, r1	; 0x02
		RX_MIN_raw[RXIndex][i]=0xfffe;
    4eb8:	a8 2f       	mov	r26, r24
    4eba:	b0 e0       	ldi	r27, 0x00	; 0
    4ebc:	fd 01       	movw	r30, r26
    4ebe:	ee 0f       	add	r30, r30
    4ec0:	ff 1f       	adc	r31, r31
    4ec2:	93 e0       	ldi	r25, 0x03	; 3
    4ec4:	aa 0f       	add	r26, r26
    4ec6:	bb 1f       	adc	r27, r27
    4ec8:	9a 95       	dec	r25
    4eca:	e1 f7       	brne	.-8      	; 0x4ec4 <RX_StickCenterCalibrationInit+0x78>
    4ecc:	ea 0f       	add	r30, r26
    4ece:	fb 1f       	adc	r31, r27
    4ed0:	e4 0f       	add	r30, r20
    4ed2:	f5 1f       	adc	r31, r21
    4ed4:	33 83       	std	Z+3, r19	; 0x03
    4ed6:	22 83       	std	Z+2, r18	; 0x02

void RX_StickCenterCalibrationInit(uint8_t RXIndex)
{
	for (int i=0; i<RXChannels; ++i)
	{
		RX_MAX_raw[RXIndex][i]=0;
    4ed8:	a8 2f       	mov	r26, r24
    4eda:	b0 e0       	ldi	r27, 0x00	; 0
    4edc:	fd 01       	movw	r30, r26
    4ede:	ee 0f       	add	r30, r30
    4ee0:	ff 1f       	adc	r31, r31
    4ee2:	93 e0       	ldi	r25, 0x03	; 3
    4ee4:	aa 0f       	add	r26, r26
    4ee6:	bb 1f       	adc	r27, r27
    4ee8:	9a 95       	dec	r25
    4eea:	e1 f7       	brne	.-8      	; 0x4ee4 <RX_StickCenterCalibrationInit+0x98>
    4eec:	ea 0f       	add	r30, r26
    4eee:	fb 1f       	adc	r31, r27
    4ef0:	e6 0f       	add	r30, r22
    4ef2:	f7 1f       	adc	r31, r23
    4ef4:	15 82       	std	Z+5, r1	; 0x05
    4ef6:	14 82       	std	Z+4, r1	; 0x04
		RX_MIN_raw[RXIndex][i]=0xfffe;
    4ef8:	a8 2f       	mov	r26, r24
    4efa:	b0 e0       	ldi	r27, 0x00	; 0
    4efc:	fd 01       	movw	r30, r26
    4efe:	ee 0f       	add	r30, r30
    4f00:	ff 1f       	adc	r31, r31
    4f02:	93 e0       	ldi	r25, 0x03	; 3
    4f04:	aa 0f       	add	r26, r26
    4f06:	bb 1f       	adc	r27, r27
    4f08:	9a 95       	dec	r25
    4f0a:	e1 f7       	brne	.-8      	; 0x4f04 <RX_StickCenterCalibrationInit+0xb8>
    4f0c:	ea 0f       	add	r30, r26
    4f0e:	fb 1f       	adc	r31, r27
    4f10:	e4 0f       	add	r30, r20
    4f12:	f5 1f       	adc	r31, r21
    4f14:	35 83       	std	Z+5, r19	; 0x05
    4f16:	24 83       	std	Z+4, r18	; 0x04

void RX_StickCenterCalibrationInit(uint8_t RXIndex)
{
	for (int i=0; i<RXChannels; ++i)
	{
		RX_MAX_raw[RXIndex][i]=0;
    4f18:	a8 2f       	mov	r26, r24
    4f1a:	b0 e0       	ldi	r27, 0x00	; 0
    4f1c:	fd 01       	movw	r30, r26
    4f1e:	ee 0f       	add	r30, r30
    4f20:	ff 1f       	adc	r31, r31
    4f22:	93 e0       	ldi	r25, 0x03	; 3
    4f24:	aa 0f       	add	r26, r26
    4f26:	bb 1f       	adc	r27, r27
    4f28:	9a 95       	dec	r25
    4f2a:	e1 f7       	brne	.-8      	; 0x4f24 <RX_StickCenterCalibrationInit+0xd8>
    4f2c:	ea 0f       	add	r30, r26
    4f2e:	fb 1f       	adc	r31, r27
    4f30:	e6 0f       	add	r30, r22
    4f32:	f7 1f       	adc	r31, r23
    4f34:	17 82       	std	Z+7, r1	; 0x07
    4f36:	16 82       	std	Z+6, r1	; 0x06
		RX_MIN_raw[RXIndex][i]=0xfffe;
    4f38:	a8 2f       	mov	r26, r24
    4f3a:	b0 e0       	ldi	r27, 0x00	; 0
    4f3c:	fd 01       	movw	r30, r26
    4f3e:	ee 0f       	add	r30, r30
    4f40:	ff 1f       	adc	r31, r31
    4f42:	93 e0       	ldi	r25, 0x03	; 3
    4f44:	aa 0f       	add	r26, r26
    4f46:	bb 1f       	adc	r27, r27
    4f48:	9a 95       	dec	r25
    4f4a:	e1 f7       	brne	.-8      	; 0x4f44 <RX_StickCenterCalibrationInit+0xf8>
    4f4c:	ea 0f       	add	r30, r26
    4f4e:	fb 1f       	adc	r31, r27
    4f50:	e4 0f       	add	r30, r20
    4f52:	f5 1f       	adc	r31, r21
    4f54:	37 83       	std	Z+7, r19	; 0x07
    4f56:	26 83       	std	Z+6, r18	; 0x06

void RX_StickCenterCalibrationInit(uint8_t RXIndex)
{
	for (int i=0; i<RXChannels; ++i)
	{
		RX_MAX_raw[RXIndex][i]=0;
    4f58:	a8 2f       	mov	r26, r24
    4f5a:	b0 e0       	ldi	r27, 0x00	; 0
    4f5c:	fd 01       	movw	r30, r26
    4f5e:	ee 0f       	add	r30, r30
    4f60:	ff 1f       	adc	r31, r31
    4f62:	93 e0       	ldi	r25, 0x03	; 3
    4f64:	aa 0f       	add	r26, r26
    4f66:	bb 1f       	adc	r27, r27
    4f68:	9a 95       	dec	r25
    4f6a:	e1 f7       	brne	.-8      	; 0x4f64 <RX_StickCenterCalibrationInit+0x118>
    4f6c:	ea 0f       	add	r30, r26
    4f6e:	fb 1f       	adc	r31, r27
    4f70:	e6 0f       	add	r30, r22
    4f72:	f7 1f       	adc	r31, r23
    4f74:	11 86       	std	Z+9, r1	; 0x09
    4f76:	10 86       	std	Z+8, r1	; 0x08
		RX_MIN_raw[RXIndex][i]=0xfffe;
    4f78:	68 2f       	mov	r22, r24
    4f7a:	70 e0       	ldi	r23, 0x00	; 0
    4f7c:	fb 01       	movw	r30, r22
    4f7e:	ee 0f       	add	r30, r30
    4f80:	ff 1f       	adc	r31, r31
    4f82:	b3 e0       	ldi	r27, 0x03	; 3
    4f84:	66 0f       	add	r22, r22
    4f86:	77 1f       	adc	r23, r23
    4f88:	ba 95       	dec	r27
    4f8a:	e1 f7       	brne	.-8      	; 0x4f84 <RX_StickCenterCalibrationInit+0x138>
    4f8c:	e6 0f       	add	r30, r22
    4f8e:	f7 1f       	adc	r31, r23
    4f90:	e4 0f       	add	r30, r20
    4f92:	f5 1f       	adc	r31, r21
    4f94:	31 87       	std	Z+9, r19	; 0x09
    4f96:	20 87       	std	Z+8, r18	; 0x08
	}
}
    4f98:	08 95       	ret

00004f9a <RX_StickCenterCalibration>:


void RX_StickCenterCalibration (uint8_t RXIndex)
{
    4f9a:	df 92       	push	r13
    4f9c:	ef 92       	push	r14
    4f9e:	ff 92       	push	r15
    4fa0:	0f 93       	push	r16
    4fa2:	1f 93       	push	r17
    4fa4:	cf 93       	push	r28
    4fa6:	df 93       	push	r29
    4fa8:	d8 2e       	mov	r13, r24
		RX_MIN_raw[RXIndex][i]=0xfffe;
	}
}


void RX_StickCenterCalibration (uint8_t RXIndex)
    4faa:	28 2f       	mov	r18, r24
    4fac:	30 e0       	ldi	r19, 0x00	; 0
    4fae:	89 01       	movw	r16, r18
    4fb0:	00 0f       	add	r16, r16
    4fb2:	11 1f       	adc	r17, r17
    4fb4:	73 e0       	ldi	r23, 0x03	; 3
    4fb6:	22 0f       	add	r18, r18
    4fb8:	33 1f       	adc	r19, r19
    4fba:	7a 95       	dec	r23
    4fbc:	e1 f7       	brne	.-8      	; 0x4fb6 <RX_StickCenterCalibration+0x1c>
    4fbe:	02 0f       	add	r16, r18
    4fc0:	13 1f       	adc	r17, r19
    4fc2:	0f 5d       	subi	r16, 0xDF	; 223
    4fc4:	19 4f       	sbci	r17, 0xF9	; 249
    4fc6:	28 2f       	mov	r18, r24
    4fc8:	30 e0       	ldi	r19, 0x00	; 0
    4fca:	e9 01       	movw	r28, r18
    4fcc:	cc 0f       	add	r28, r28
    4fce:	dd 1f       	adc	r29, r29
    4fd0:	53 e0       	ldi	r21, 0x03	; 3
    4fd2:	22 0f       	add	r18, r18
    4fd4:	33 1f       	adc	r19, r19
    4fd6:	5a 95       	dec	r21
    4fd8:	e1 f7       	brne	.-8      	; 0x4fd2 <RX_StickCenterCalibration+0x38>
    4fda:	c2 0f       	add	r28, r18
    4fdc:	d3 1f       	adc	r29, r19
    4fde:	ce 53       	subi	r28, 0x3E	; 62
    4fe0:	d9 4f       	sbci	r29, 0xF9	; 249
{
	
	uint16_t tempRX;
	for (int i=0;i<RXChannels;++i)
    4fe2:	ee 24       	eor	r14, r14
    4fe4:	ff 24       	eor	r15, r15
	{
		tempRX = RX_raw_GetReceiverValues(RXIndex,i);
    4fe6:	8d 2d       	mov	r24, r13
    4fe8:	6e 2d       	mov	r22, r14
    4fea:	0e 94 fe 25 	call	0x4bfc	; 0x4bfc <RX_raw_GetReceiverValues>
    4fee:	9c 01       	movw	r18, r24
		if (tempRX!=0)
    4ff0:	00 97       	sbiw	r24, 0x00	; 0
    4ff2:	81 f0       	breq	.+32     	; 0x5014 <RX_StickCenterCalibration+0x7a>
		{
			
			if ( tempRX > RX_MAX_raw[RXIndex][i]) 
    4ff4:	f8 01       	movw	r30, r16
    4ff6:	80 81       	ld	r24, Z
    4ff8:	91 81       	ldd	r25, Z+1	; 0x01
    4ffa:	82 17       	cp	r24, r18
    4ffc:	93 07       	cpc	r25, r19
    4ffe:	18 f4       	brcc	.+6      	; 0x5006 <RX_StickCenterCalibration+0x6c>
			{
				RX_MAX_raw[RXIndex][i] = tempRX;
    5000:	31 83       	std	Z+1, r19	; 0x01
    5002:	20 83       	st	Z, r18
    5004:	07 c0       	rjmp	.+14     	; 0x5014 <RX_StickCenterCalibration+0x7a>
			}
			else if (tempRX < RX_MIN_raw[RXIndex][i]) 
    5006:	88 81       	ld	r24, Y
    5008:	99 81       	ldd	r25, Y+1	; 0x01
    500a:	28 17       	cp	r18, r24
    500c:	39 07       	cpc	r19, r25
    500e:	10 f4       	brcc	.+4      	; 0x5014 <RX_StickCenterCalibration+0x7a>
			{
				RX_MIN_raw[RXIndex][i] = tempRX;
    5010:	39 83       	std	Y+1, r19	; 0x01
    5012:	28 83       	st	Y, r18

void RX_StickCenterCalibration (uint8_t RXIndex)
{
	
	uint16_t tempRX;
	for (int i=0;i<RXChannels;++i)
    5014:	08 94       	sec
    5016:	e1 1c       	adc	r14, r1
    5018:	f1 1c       	adc	r15, r1
    501a:	0e 5f       	subi	r16, 0xFE	; 254
    501c:	1f 4f       	sbci	r17, 0xFF	; 255
    501e:	22 96       	adiw	r28, 0x02	; 2
    5020:	f5 e0       	ldi	r31, 0x05	; 5
    5022:	ef 16       	cp	r14, r31
    5024:	f1 04       	cpc	r15, r1
    5026:	f9 f6       	brne	.-66     	; 0x4fe6 <RX_StickCenterCalibration+0x4c>
			{
				RX_MIN_raw[RXIndex][i] = tempRX;
			}
		}
	}				
    5028:	df 91       	pop	r29
    502a:	cf 91       	pop	r28
    502c:	1f 91       	pop	r17
    502e:	0f 91       	pop	r16
    5030:	ff 90       	pop	r15
    5032:	ef 90       	pop	r14
    5034:	df 90       	pop	r13
    5036:	08 95       	ret

00005038 <Sensors_Init>:
P_STR strOK[] ="OK  ";
P_STR strFail[] ="Fail";

void Sensors_Init(void)
{
	ACC_PITCH  = INPUT;
    5038:	15 98       	cbi	0x02, 5	; 2
	ACC_ROLL  = INPUT;
    503a:	16 98       	cbi	0x02, 6	; 2
	ACC_Z  = INPUT;
    503c:	17 98       	cbi	0x02, 7	; 2
	
	GYRO_ROLL = INPUT;
    503e:	11 98       	cbi	0x02, 1	; 2
	GYRO_PITCH = INPUT;
    5040:	14 98       	cbi	0x02, 4	; 2
	GYRO_Z = INPUT;
    5042:	12 98       	cbi	0x02, 2	; 2
	//{
		//
		//StabilityMatrix_GX[i]=0;
		//StabilityMatrix_GY[i]=0;
	//}
}
    5044:	08 95       	ret

00005046 <Sensors_Test>:

/*
// This function Test if sensors are working OK or not.
*/
char *Sensors_Test(uint8_t channel, uint16_t LowLimit ,uint16_t HighLimit)
{
    5046:	ef 92       	push	r14
    5048:	ff 92       	push	r15
    504a:	0f 93       	push	r16
    504c:	1f 93       	push	r17
    504e:	cf 93       	push	r28
    5050:	df 93       	push	r29
    5052:	8b 01       	movw	r16, r22
    5054:	7a 01       	movw	r14, r20
	
	nResult[channel] = ADCPort_Get(channel);
    5056:	c8 2f       	mov	r28, r24
    5058:	d0 e0       	ldi	r29, 0x00	; 0
    505a:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <ADCPort_Get>
    505e:	cc 0f       	add	r28, r28
    5060:	dd 1f       	adc	r29, r29
    5062:	c2 56       	subi	r28, 0x62	; 98
    5064:	da 4f       	sbci	r29, 0xFA	; 250
    5066:	99 83       	std	Y+1, r25	; 0x01
    5068:	88 83       	st	Y, r24
	  
	utoa (nResult[channel],Result,10);
    506a:	88 81       	ld	r24, Y
    506c:	99 81       	ldd	r25, Y+1	; 0x01
    506e:	6e ea       	ldi	r22, 0xAE	; 174
    5070:	75 e0       	ldi	r23, 0x05	; 5
    5072:	4a e0       	ldi	r20, 0x0A	; 10
    5074:	50 e0       	ldi	r21, 0x00	; 0
    5076:	0e 94 cf 3a 	call	0x759e	; 0x759e <utoa>
	
	if ((nResult[channel]  >= LowLimit)  
    507a:	88 81       	ld	r24, Y
    507c:	99 81       	ldd	r25, Y+1	; 0x01
    507e:	80 17       	cp	r24, r16
    5080:	91 07       	cpc	r25, r17
    5082:	50 f0       	brcs	.+20     	; 0x5098 <Sensors_Test+0x52>
	 && (nResult[channel]  <= HighLimit))
    5084:	88 81       	ld	r24, Y
    5086:	99 81       	ldd	r25, Y+1	; 0x01
    5088:	e8 16       	cp	r14, r24
    508a:	f9 06       	cpc	r15, r25
    508c:	28 f0       	brcs	.+10     	; 0x5098 <Sensors_Test+0x52>
	{
		strcat (Result, ("  "));  
    508e:	8e ea       	ldi	r24, 0xAE	; 174
    5090:	95 e0       	ldi	r25, 0x05	; 5
    5092:	68 e0       	ldi	r22, 0x08	; 8
    5094:	71 e0       	ldi	r23, 0x01	; 1
    5096:	04 c0       	rjmp	.+8      	; 0x50a0 <Sensors_Test+0x5a>
	}
	else
	{
		strcat (Result, (" X"));  
    5098:	8e ea       	ldi	r24, 0xAE	; 174
    509a:	95 e0       	ldi	r25, 0x05	; 5
    509c:	6b e0       	ldi	r22, 0x0B	; 11
    509e:	71 e0       	ldi	r23, 0x01	; 1
    50a0:	0e 94 a3 3a 	call	0x7546	; 0x7546 <strcat>
	}
	  
	return Result;
}
    50a4:	8e ea       	ldi	r24, 0xAE	; 174
    50a6:	95 e0       	ldi	r25, 0x05	; 5
    50a8:	df 91       	pop	r29
    50aa:	cf 91       	pop	r28
    50ac:	1f 91       	pop	r17
    50ae:	0f 91       	pop	r16
    50b0:	ff 90       	pop	r15
    50b2:	ef 90       	pop	r14
    50b4:	08 95       	ret

000050b6 <Sensors_Calibrate>:

/*
// Calibrate Sensors and return result in nResult global variable.
*/
void Sensors_Calibrate (void)
{
    50b6:	8f 92       	push	r8
    50b8:	9f 92       	push	r9
    50ba:	af 92       	push	r10
    50bc:	bf 92       	push	r11
    50be:	cf 92       	push	r12
    50c0:	df 92       	push	r13
    50c2:	ef 92       	push	r14
    50c4:	ff 92       	push	r15
    50c6:	0f 93       	push	r16
    50c8:	1f 93       	push	r17
    50ca:	df 93       	push	r29
    50cc:	cf 93       	push	r28
    50ce:	0f 92       	push	r0
    50d0:	cd b7       	in	r28, 0x3d	; 61
    50d2:	de b7       	in	r29, 0x3e	; 62
	
	BOOL LEDOLD = LED_Orange;
    50d4:	25 b1       	in	r18, 0x05	; 5
    50d6:	26 95       	lsr	r18
    50d8:	26 95       	lsr	r18
    50da:	26 95       	lsr	r18
    50dc:	21 70       	andi	r18, 0x01	; 1
	int i;
	for (i=0;i<6;++i)
	{
		nResult [i]=0;
    50de:	10 92 9f 05 	sts	0x059F, r1
    50e2:	10 92 9e 05 	sts	0x059E, r1
    50e6:	10 92 a1 05 	sts	0x05A1, r1
    50ea:	10 92 a0 05 	sts	0x05A0, r1
    50ee:	10 92 a3 05 	sts	0x05A3, r1
    50f2:	10 92 a2 05 	sts	0x05A2, r1
    50f6:	10 92 a5 05 	sts	0x05A5, r1
    50fa:	10 92 a4 05 	sts	0x05A4, r1
    50fe:	10 92 a7 05 	sts	0x05A7, r1
    5102:	10 92 a6 05 	sts	0x05A6, r1
    5106:	10 92 a9 05 	sts	0x05A9, r1
    510a:	10 92 a8 05 	sts	0x05A8, r1
    510e:	69 e1       	ldi	r22, 0x19	; 25
    5110:	c6 2e       	mov	r12, r22
    5112:	d1 2c       	mov	r13, r1
    5114:	34 c0       	rjmp	.+104    	; 0x517e <Sensors_Calibrate+0xc8>
		// check: http://www.x-firm.com/?page_id=191
		for (i=0;i<25;++i)
		{
			for (int s=0;s<SENSORS_ALL;++s)
			{
				nResult[s] += ADCPort_Get(SensorsIndex[s]);		
    5116:	84 01       	movw	r16, r8
    5118:	00 0f       	add	r16, r16
    511a:	11 1f       	adc	r17, r17
    511c:	02 56       	subi	r16, 0x62	; 98
    511e:	1a 4f       	sbci	r17, 0xFA	; 250
    5120:	f8 01       	movw	r30, r16
    5122:	e0 80       	ld	r14, Z
    5124:	f1 80       	ldd	r15, Z+1	; 0x01
    5126:	f5 01       	movw	r30, r10
    5128:	81 91       	ld	r24, Z+
    512a:	5f 01       	movw	r10, r30
    512c:	29 83       	std	Y+1, r18	; 0x01
    512e:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <ADCPort_Get>
    5132:	e8 0e       	add	r14, r24
    5134:	f9 1e       	adc	r15, r25
    5136:	f8 01       	movw	r30, r16
    5138:	f1 82       	std	Z+1, r15	; 0x01
    513a:	e0 82       	st	Z, r14
	
		
		// check: http://www.x-firm.com/?page_id=191
		for (i=0;i<25;++i)
		{
			for (int s=0;s<SENSORS_ALL;++s)
    513c:	08 94       	sec
    513e:	81 1c       	adc	r8, r1
    5140:	91 1c       	adc	r9, r1
    5142:	29 81       	ldd	r18, Y+1	; 0x01
    5144:	f7 e0       	ldi	r31, 0x07	; 7
    5146:	8f 16       	cp	r8, r31
    5148:	91 04       	cpc	r9, r1
    514a:	29 f7       	brne	.-54     	; 0x5116 <Sensors_Calibrate+0x60>
    514c:	8f e0       	ldi	r24, 0x0F	; 15
    514e:	97 e2       	ldi	r25, 0x27	; 39
    5150:	01 97       	sbiw	r24, 0x01	; 1
    5152:	f1 f7       	brne	.-4      	; 0x5150 <Sensors_Calibrate+0x9a>
    5154:	00 c0       	rjmp	.+0      	; 0x5156 <Sensors_Calibrate+0xa0>
    5156:	00 00       	nop
			{
				nResult[s] += ADCPort_Get(SensorsIndex[s]);		
			}
			_delay_ms(40);
			LED_Orange =~LED_Orange;
    5158:	85 b1       	in	r24, 0x05	; 5
    515a:	86 95       	lsr	r24
    515c:	86 95       	lsr	r24
    515e:	86 95       	lsr	r24
    5160:	80 95       	com	r24
    5162:	81 70       	andi	r24, 0x01	; 1
    5164:	88 0f       	add	r24, r24
    5166:	88 0f       	add	r24, r24
    5168:	88 0f       	add	r24, r24
    516a:	95 b1       	in	r25, 0x05	; 5
    516c:	97 7f       	andi	r25, 0xF7	; 247
    516e:	98 2b       	or	r25, r24
    5170:	95 b9       	out	0x05, r25	; 5
    5172:	08 94       	sec
    5174:	c1 08       	sbc	r12, r1
    5176:	d1 08       	sbc	r13, r1
		nResult [i]=0;
	}
	
		
		// check: http://www.x-firm.com/?page_id=191
		for (i=0;i<25;++i)
    5178:	c1 14       	cp	r12, r1
    517a:	d1 04       	cpc	r13, r1
    517c:	39 f0       	breq	.+14     	; 0x518c <Sensors_Calibrate+0xd6>
    517e:	4e e0       	ldi	r20, 0x0E	; 14
    5180:	a4 2e       	mov	r10, r20
    5182:	41 e0       	ldi	r20, 0x01	; 1
    5184:	b4 2e       	mov	r11, r20

/*
// Calibrate Sensors and return result in nResult global variable.
*/
void Sensors_Calibrate (void)
{
    5186:	88 24       	eor	r8, r8
    5188:	99 24       	eor	r9, r9
    518a:	c5 cf       	rjmp	.-118    	; 0x5116 <Sensors_Calibrate+0x60>
			}
			_delay_ms(40);
			LED_Orange =~LED_Orange;
		}
	
		LED_Orange = LEDOLD;
    518c:	21 70       	andi	r18, 0x01	; 1
    518e:	22 0f       	add	r18, r18
    5190:	22 0f       	add	r18, r18
    5192:	22 0f       	add	r18, r18
    5194:	85 b1       	in	r24, 0x05	; 5
    5196:	87 7f       	andi	r24, 0xF7	; 247
    5198:	82 2b       	or	r24, r18
    519a:	85 b9       	out	0x05, r24	; 5
    519c:	08 e8       	ldi	r16, 0x88	; 136
    519e:	17 e0       	ldi	r17, 0x07	; 7
	
		for (i=0;i<6;++i)
    51a0:	ee 24       	eor	r14, r14
    51a2:	ff 24       	eor	r15, r15
		{
			Config.Sensor_zero[i]  = (double)nResult[i] /25.0;
    51a4:	f7 01       	movw	r30, r14
    51a6:	ee 0f       	add	r30, r30
    51a8:	ff 1f       	adc	r31, r31
    51aa:	e2 56       	subi	r30, 0x62	; 98
    51ac:	fa 4f       	sbci	r31, 0xFA	; 250
    51ae:	60 81       	ld	r22, Z
    51b0:	71 81       	ldd	r23, Z+1	; 0x01
    51b2:	80 e0       	ldi	r24, 0x00	; 0
    51b4:	90 e0       	ldi	r25, 0x00	; 0
    51b6:	0e 94 93 38 	call	0x7126	; 0x7126 <__floatunsisf>
    51ba:	20 e0       	ldi	r18, 0x00	; 0
    51bc:	30 e0       	ldi	r19, 0x00	; 0
    51be:	48 ec       	ldi	r20, 0xC8	; 200
    51c0:	51 e4       	ldi	r21, 0x41	; 65
    51c2:	0e 94 fa 37 	call	0x6ff4	; 0x6ff4 <__divsf3>
    51c6:	f8 01       	movw	r30, r16
    51c8:	61 93       	st	Z+, r22
    51ca:	71 93       	st	Z+, r23
    51cc:	81 93       	st	Z+, r24
    51ce:	91 93       	st	Z+, r25
    51d0:	8f 01       	movw	r16, r30
			LED_Orange =~LED_Orange;
		}
	
		LED_Orange = LEDOLD;
	
		for (i=0;i<6;++i)
    51d2:	08 94       	sec
    51d4:	e1 1c       	adc	r14, r1
    51d6:	f1 1c       	adc	r15, r1
    51d8:	f6 e0       	ldi	r31, 0x06	; 6
    51da:	ef 16       	cp	r14, r31
    51dc:	f1 04       	cpc	r15, r1
    51de:	11 f7       	brne	.-60     	; 0x51a4 <Sensors_Calibrate+0xee>
		
	
	
			
	
	Config.IsCalibrated = (Config.IsCalibrated | CALIBRATED_SENSOR);
    51e0:	80 91 ea 06 	lds	r24, 0x06EA
    51e4:	84 60       	ori	r24, 0x04	; 4
    51e6:	80 93 ea 06 	sts	0x06EA, r24
		
	
	//nResult[ACC_Z_Index]-=100; // Sensor: horizontal, upward ... the caller of this function is responsible for updating Config.Sensor_zero[i] = nResult[i];
		
}
    51ea:	0f 90       	pop	r0
    51ec:	cf 91       	pop	r28
    51ee:	df 91       	pop	r29
    51f0:	1f 91       	pop	r17
    51f2:	0f 91       	pop	r16
    51f4:	ff 90       	pop	r15
    51f6:	ef 90       	pop	r14
    51f8:	df 90       	pop	r13
    51fa:	cf 90       	pop	r12
    51fc:	bf 90       	pop	r11
    51fe:	af 90       	pop	r10
    5200:	9f 90       	pop	r9
    5202:	8f 90       	pop	r8
    5204:	08 95       	ret

00005206 <Sensor_GetBattery>:
}*/

int16_t  Sensor_GetBattery(void)
{
	 // because the V_BAT is connected to a voltage divider R1 & R2
	return (ADCPort_Get(V_BAT_PNUM) *  BAT_VOLT_RATIO);
    5206:	83 e0       	ldi	r24, 0x03	; 3
    5208:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <ADCPort_Get>
    520c:	24 e6       	ldi	r18, 0x64	; 100
    520e:	30 e0       	ldi	r19, 0x00	; 0
    5210:	ac 01       	movw	r20, r24
    5212:	42 9f       	mul	r20, r18
    5214:	c0 01       	movw	r24, r0
    5216:	43 9f       	mul	r20, r19
    5218:	90 0d       	add	r25, r0
    521a:	52 9f       	mul	r21, r18
    521c:	90 0d       	add	r25, r0
    521e:	11 24       	eor	r1, r1
    5220:	64 e7       	ldi	r22, 0x74	; 116
    5222:	71 e0       	ldi	r23, 0x01	; 1
    5224:	0e 94 2f 3a 	call	0x745e	; 0x745e <__udivmodhi4>
} 
    5228:	cb 01       	movw	r24, r22
    522a:	08 95       	ret

0000522c <Sensors_ReadAll>:

#define DEAD_BAND_GYRO	4
//uint32_t LastLoopTime[2];
//uint16_t TX,TX1,TX2;
void Sensors_ReadAll (void)
{
    522c:	6f 92       	push	r6
    522e:	7f 92       	push	r7
    5230:	8f 92       	push	r8
    5232:	9f 92       	push	r9
    5234:	af 92       	push	r10
    5236:	bf 92       	push	r11
    5238:	cf 92       	push	r12
    523a:	df 92       	push	r13
    523c:	ef 92       	push	r14
    523e:	ff 92       	push	r15
    5240:	0f 93       	push	r16
    5242:	1f 93       	push	r17
    5244:	cf 93       	push	r28
    5246:	df 93       	push	r29
		//TX1= TCNT1;
		//TX= TCNT1_X;
   //}   
	//
	
	for (int i=0;i<3;++i)  // gyro
    5248:	0e e0       	ldi	r16, 0x0E	; 14
    524a:	11 e0       	ldi	r17, 0x01	; 1
    524c:	88 e8       	ldi	r24, 0x88	; 136
    524e:	e8 2e       	mov	r14, r24
    5250:	87 e0       	ldi	r24, 0x07	; 7
    5252:	f8 2e       	mov	r15, r24
    5254:	c0 e0       	ldi	r28, 0x00	; 0
    5256:	d0 e0       	ldi	r29, 0x00	; 0
	{
		Sensors_Latest[i] = ADCPort_Get(SensorsIndex[i])-Config.Sensor_zero[i]; 
		if (abs(Sensors_Latest[i]) <= DEAD_BAND_GYRO) Sensors_Latest[i]=0;
    5258:	0f 2e       	mov	r0, r31
    525a:	f0 e0       	ldi	r31, 0x00	; 0
    525c:	6f 2e       	mov	r6, r31
    525e:	f0 e0       	ldi	r31, 0x00	; 0
    5260:	7f 2e       	mov	r7, r31
    5262:	f0 e0       	ldi	r31, 0x00	; 0
    5264:	8f 2e       	mov	r8, r31
    5266:	f0 e0       	ldi	r31, 0x00	; 0
    5268:	9f 2e       	mov	r9, r31
    526a:	f0 2d       	mov	r31, r0
   //}   
	//
	
	for (int i=0;i<3;++i)  // gyro
	{
		Sensors_Latest[i] = ADCPort_Get(SensorsIndex[i])-Config.Sensor_zero[i]; 
    526c:	f8 01       	movw	r30, r16
    526e:	81 91       	ld	r24, Z+
    5270:	8f 01       	movw	r16, r30
    5272:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <ADCPort_Get>
    5276:	f7 01       	movw	r30, r14
    5278:	a1 90       	ld	r10, Z+
    527a:	b1 90       	ld	r11, Z+
    527c:	c1 90       	ld	r12, Z+
    527e:	d1 90       	ld	r13, Z+
    5280:	7f 01       	movw	r14, r30
    5282:	bc 01       	movw	r22, r24
    5284:	80 e0       	ldi	r24, 0x00	; 0
    5286:	90 e0       	ldi	r25, 0x00	; 0
    5288:	0e 94 93 38 	call	0x7126	; 0x7126 <__floatunsisf>
    528c:	a6 01       	movw	r20, r12
    528e:	95 01       	movw	r18, r10
    5290:	0e 94 91 37 	call	0x6f22	; 0x6f22 <__subsf3>
    5294:	9b 01       	movw	r18, r22
    5296:	ac 01       	movw	r20, r24
    5298:	fe 01       	movw	r30, r28
    529a:	ee 0f       	add	r30, r30
    529c:	ff 1f       	adc	r31, r31
    529e:	ee 0f       	add	r30, r30
    52a0:	ff 1f       	adc	r31, r31
    52a2:	e5 5c       	subi	r30, 0xC5	; 197
    52a4:	f9 4f       	sbci	r31, 0xF9	; 249
    52a6:	20 83       	st	Z, r18
    52a8:	31 83       	std	Z+1, r19	; 0x01
    52aa:	42 83       	std	Z+2, r20	; 0x02
    52ac:	53 83       	std	Z+3, r21	; 0x03
		if (abs(Sensors_Latest[i]) <= DEAD_BAND_GYRO) Sensors_Latest[i]=0;
    52ae:	60 81       	ld	r22, Z
    52b0:	71 81       	ldd	r23, Z+1	; 0x01
    52b2:	82 81       	ldd	r24, Z+2	; 0x02
    52b4:	93 81       	ldd	r25, Z+3	; 0x03
    52b6:	0e 94 62 38 	call	0x70c4	; 0x70c4 <__fixsfsi>
    52ba:	27 2f       	mov	r18, r23
    52bc:	86 2f       	mov	r24, r22
    52be:	92 2f       	mov	r25, r18
    52c0:	97 ff       	sbrs	r25, 7
    52c2:	03 c0       	rjmp	.+6      	; 0x52ca <Sensors_ReadAll+0x9e>
    52c4:	90 95       	com	r25
    52c6:	81 95       	neg	r24
    52c8:	9f 4f       	sbci	r25, 0xFF	; 255
    52ca:	85 30       	cpi	r24, 0x05	; 5
    52cc:	91 05       	cpc	r25, r1
    52ce:	5c f4       	brge	.+22     	; 0x52e6 <Sensors_ReadAll+0xba>
    52d0:	fe 01       	movw	r30, r28
    52d2:	ee 0f       	add	r30, r30
    52d4:	ff 1f       	adc	r31, r31
    52d6:	ee 0f       	add	r30, r30
    52d8:	ff 1f       	adc	r31, r31
    52da:	e5 5c       	subi	r30, 0xC5	; 197
    52dc:	f9 4f       	sbci	r31, 0xF9	; 249
    52de:	60 82       	st	Z, r6
    52e0:	71 82       	std	Z+1, r7	; 0x01
    52e2:	82 82       	std	Z+2, r8	; 0x02
    52e4:	93 82       	std	Z+3, r9	; 0x03
		//TX1= TCNT1;
		//TX= TCNT1_X;
   //}   
	//
	
	for (int i=0;i<3;++i)  // gyro
    52e6:	21 96       	adiw	r28, 0x01	; 1
    52e8:	c3 30       	cpi	r28, 0x03	; 3
    52ea:	d1 05       	cpc	r29, r1
    52ec:	09 f0       	breq	.+2      	; 0x52f0 <Sensors_ReadAll+0xc4>
    52ee:	be cf       	rjmp	.-132    	; 0x526c <Sensors_ReadAll+0x40>
    52f0:	01 e1       	ldi	r16, 0x11	; 17
    52f2:	11 e0       	ldi	r17, 0x01	; 1
    52f4:	e4 e9       	ldi	r30, 0x94	; 148
    52f6:	ee 2e       	mov	r14, r30
    52f8:	e7 e0       	ldi	r30, 0x07	; 7
    52fa:	fe 2e       	mov	r15, r30
    52fc:	c3 e0       	ldi	r28, 0x03	; 3
    52fe:	d0 e0       	ldi	r29, 0x00	; 0
		if (abs(Sensors_Latest[i]) <= DEAD_BAND_GYRO) Sensors_Latest[i]=0;
	}
	
	for (int i=3;i<6;++i)  //ACC
	{
		Sensors_Latest[i] = ADCPort_Get(SensorsIndex[i])-Config.Sensor_zero[i]; 
    5300:	f8 01       	movw	r30, r16
    5302:	81 91       	ld	r24, Z+
    5304:	8f 01       	movw	r16, r30
    5306:	0e 94 fc 29 	call	0x53f8	; 0x53f8 <ADCPort_Get>
    530a:	f7 01       	movw	r30, r14
    530c:	a1 90       	ld	r10, Z+
    530e:	b1 90       	ld	r11, Z+
    5310:	c1 90       	ld	r12, Z+
    5312:	d1 90       	ld	r13, Z+
    5314:	7f 01       	movw	r14, r30
    5316:	bc 01       	movw	r22, r24
    5318:	80 e0       	ldi	r24, 0x00	; 0
    531a:	90 e0       	ldi	r25, 0x00	; 0
    531c:	0e 94 93 38 	call	0x7126	; 0x7126 <__floatunsisf>
    5320:	a6 01       	movw	r20, r12
    5322:	95 01       	movw	r18, r10
    5324:	0e 94 91 37 	call	0x6f22	; 0x6f22 <__subsf3>
    5328:	9b 01       	movw	r18, r22
    532a:	ac 01       	movw	r20, r24
    532c:	fe 01       	movw	r30, r28
    532e:	ee 0f       	add	r30, r30
    5330:	ff 1f       	adc	r31, r31
    5332:	ee 0f       	add	r30, r30
    5334:	ff 1f       	adc	r31, r31
    5336:	e5 5c       	subi	r30, 0xC5	; 197
    5338:	f9 4f       	sbci	r31, 0xF9	; 249
    533a:	20 83       	st	Z, r18
    533c:	31 83       	std	Z+1, r19	; 0x01
    533e:	42 83       	std	Z+2, r20	; 0x02
    5340:	53 83       	std	Z+3, r21	; 0x03
	{
		Sensors_Latest[i] = ADCPort_Get(SensorsIndex[i])-Config.Sensor_zero[i]; 
		if (abs(Sensors_Latest[i]) <= DEAD_BAND_GYRO) Sensors_Latest[i]=0;
	}
	
	for (int i=3;i<6;++i)  //ACC
    5342:	21 96       	adiw	r28, 0x01	; 1
    5344:	c6 30       	cpi	r28, 0x06	; 6
    5346:	d1 05       	cpc	r29, r1
    5348:	d9 f6       	brne	.-74     	; 0x5300 <Sensors_ReadAll+0xd4>
		Sensors_Latest[i] = ADCPort_Get(SensorsIndex[i])-Config.Sensor_zero[i]; 
		//if (abs(Sensors_Latest[i]) <= DEAD_BAND_GYRO) Sensors_Latest[i]=0;
	}
	
	
	Sensors_Latest[V_BAT_Index] = Sensor_GetBattery(); 
    534a:	0e 94 03 29 	call	0x5206	; 0x5206 <Sensor_GetBattery>
    534e:	9c 01       	movw	r18, r24
    5350:	b9 01       	movw	r22, r18
    5352:	88 27       	eor	r24, r24
    5354:	77 fd       	sbrc	r23, 7
    5356:	80 95       	com	r24
    5358:	98 2f       	mov	r25, r24
    535a:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    535e:	eb e3       	ldi	r30, 0x3B	; 59
    5360:	f6 e0       	ldi	r31, 0x06	; 6
    5362:	60 8f       	std	Z+24, r22	; 0x18
    5364:	71 8f       	std	Z+25, r23	; 0x19
    5366:	82 8f       	std	Z+26, r24	; 0x1a
    5368:	93 8f       	std	Z+27, r25	; 0x1b
	//else
	//{
		//Sensors_dt = TX1 - TX2;
	//}
	//TX2=TX1;
}
    536a:	df 91       	pop	r29
    536c:	cf 91       	pop	r28
    536e:	1f 91       	pop	r17
    5370:	0f 91       	pop	r16
    5372:	ff 90       	pop	r15
    5374:	ef 90       	pop	r14
    5376:	df 90       	pop	r13
    5378:	cf 90       	pop	r12
    537a:	bf 90       	pop	r11
    537c:	af 90       	pop	r10
    537e:	9f 90       	pop	r9
    5380:	8f 90       	pop	r8
    5382:	7f 90       	pop	r7
    5384:	6f 90       	pop	r6
    5386:	08 95       	ret

00005388 <__vector_24>:
 * 
 *  8.913kHz on mega128 16MHz 1kHz/channel ??
 ***** I used 20 MHz 13 - 260 us conv average = (260-13)/2 + 13 = 136.5 us = 7.326 KHz
*/
ISR(ADC_vect, ISR_NOBLOCK)
{
    5388:	78 94       	sei
    538a:	1f 92       	push	r1
    538c:	0f 92       	push	r0
    538e:	0f b6       	in	r0, 0x3f	; 63
    5390:	0f 92       	push	r0
    5392:	11 24       	eor	r1, r1
    5394:	2f 93       	push	r18
    5396:	8f 93       	push	r24
    5398:	9f 93       	push	r25
    539a:	ef 93       	push	r30
    539c:	ff 93       	push	r31
	static uint8_t _index;
	ADCValues[_index] = ADC;
    539e:	20 91 37 05 	lds	r18, 0x0537
    53a2:	e2 2f       	mov	r30, r18
    53a4:	f0 e0       	ldi	r31, 0x00	; 0
    53a6:	80 91 78 00 	lds	r24, 0x0078
    53aa:	90 91 79 00 	lds	r25, 0x0079
    53ae:	ee 0f       	add	r30, r30
    53b0:	ff 1f       	adc	r31, r31
    53b2:	ea 5c       	subi	r30, 0xCA	; 202
    53b4:	f7 4f       	sbci	r31, 0xF7	; 247
    53b6:	91 83       	std	Z+1, r25	; 0x01
    53b8:	80 83       	st	Z, r24
	_index = (_index + 1) % 8U;
    53ba:	82 2f       	mov	r24, r18
    53bc:	8f 5f       	subi	r24, 0xFF	; 255
    53be:	87 70       	andi	r24, 0x07	; 7
    53c0:	80 93 37 05 	sts	0x0537, r24
	ADMUX = _index;
    53c4:	80 93 7c 00 	sts	0x007C, r24
	ADCSRA |= _BV(ADSC);
    53c8:	ea e7       	ldi	r30, 0x7A	; 122
    53ca:	f0 e0       	ldi	r31, 0x00	; 0
    53cc:	80 81       	ld	r24, Z
    53ce:	80 64       	ori	r24, 0x40	; 64
    53d0:	80 83       	st	Z, r24
	
	
}
    53d2:	ff 91       	pop	r31
    53d4:	ef 91       	pop	r30
    53d6:	9f 91       	pop	r25
    53d8:	8f 91       	pop	r24
    53da:	2f 91       	pop	r18
    53dc:	0f 90       	pop	r0
    53de:	0f be       	out	0x3f, r0	; 63
    53e0:	0f 90       	pop	r0
    53e2:	1f 90       	pop	r1
    53e4:	18 95       	reti

000053e6 <ADCPort_Init>:

void ADCPort_Init ()
{
	DIDR0 = 0xFF;	// disable all digital inputs on Port A
    53e6:	8f ef       	ldi	r24, 0xFF	; 255
    53e8:	80 93 7e 00 	sts	0x007E, r24
	ADMUX = 0;
    53ec:	10 92 7c 00 	sts	0x007C, r1
	ADCSRA = 0b11011111;	// ADEN, ADSC, ADIE, 
    53f0:	8f ed       	ldi	r24, 0xDF	; 223
    53f2:	80 93 7a 00 	sts	0x007A, r24
		
}
    53f6:	08 95       	ret

000053f8 <ADCPort_Get>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    53f8:	f8 94       	cli
inline uint16_t ADCPort_Get(uint8_t channel)
{
	uint16_t _t;
	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		_t = ADCValues[channel];
    53fa:	e8 2f       	mov	r30, r24
    53fc:	f0 e0       	ldi	r31, 0x00	; 0
    53fe:	ee 0f       	add	r30, r30
    5400:	ff 1f       	adc	r31, r31
    5402:	ea 5c       	subi	r30, 0xCA	; 202
    5404:	f7 4f       	sbci	r31, 0xF7	; 247
    5406:	20 81       	ld	r18, Z
    5408:	31 81       	ldd	r19, Z+1	; 0x01
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    540a:	78 94       	sei
	}		
	return _t;
    540c:	c9 01       	movw	r24, r18
    540e:	08 95       	ret

00005410 <_hHomeRestart>:
}


void _hHomeRestart (void)
{
	NOKEYRETURN
    5410:	80 91 ba 05 	lds	r24, 0x05BA
    5414:	88 23       	and	r24, r24
    5416:	11 f0       	breq	.+4      	; 0x541c <_hHomeRestart+0xc>
	
	if (KEY4)
    5418:	84 fd       	sbrc	r24, 4
    541a:	ff cf       	rjmp	.-2      	; 0x541a <_hHomeRestart+0xa>
    541c:	08 95       	ret

0000541e <tsmMain>:
	Menu_LoadPage(PAGE_HOME);
}

PGM_P tsmMain(uint8_t index)
{
	return (PGM_P)pgm_read_word(&lstMenu[index]);
    541e:	90 e0       	ldi	r25, 0x00	; 0
    5420:	88 0f       	add	r24, r24
    5422:	99 1f       	adc	r25, r25
    5424:	8d 5f       	subi	r24, 0xFD	; 253
    5426:	93 4f       	sbci	r25, 0xF3	; 243
    5428:	fc 01       	movw	r30, r24
    542a:	25 91       	lpm	r18, Z+
    542c:	34 91       	lpm	r19, Z+
}
    542e:	c9 01       	movw	r24, r18
    5430:	08 95       	ret

00005432 <writeSoftkeys>:
		//LCD_WriteString_P(e.text);
	//}
//}

static void writeSoftkeys(const char* sk)
{
    5432:	cf 93       	push	r28
    5434:	df 93       	push	r29
    5436:	ec 01       	movw	r28, r24
	if (!sk)
    5438:	00 97       	sbiw	r24, 0x00	; 0
    543a:	31 f4       	brne	.+12     	; 0x5448 <writeSoftkeys+0x16>
		sk = currentPage.softkeys;
    543c:	c0 91 42 05 	lds	r28, 0x0542
    5440:	d0 91 43 05 	lds	r29, 0x0543
	if (sk)
    5444:	20 97       	sbiw	r28, 0x00	; 0
    5446:	39 f0       	breq	.+14     	; 0x5456 <writeSoftkeys+0x24>
	{
		LCD_SetPos(7, 0);
    5448:	87 e0       	ldi	r24, 0x07	; 7
    544a:	60 e0       	ldi	r22, 0x00	; 0
    544c:	0e 94 1f 0c 	call	0x183e	; 0x183e <LCD_SetPos>
		LCD_WriteString_P(sk);
    5450:	ce 01       	movw	r24, r28
    5452:	0e 94 1c 0d 	call	0x1a38	; 0x1a38 <LCD_WriteString_P>
	}
}
    5456:	df 91       	pop	r29
    5458:	cf 91       	pop	r28
    545a:	08 95       	ret

0000545c <_hDebug>:
static double OldAngle;
	static double YAWAngle2;
	static double maxdiff=0;
		
void _hDebug()
{
    545c:	ef 92       	push	r14
    545e:	0f 93       	push	r16

	if (IS_INIT)
    5460:	80 91 ba 05 	lds	r24, 0x05BA
    5464:	80 fd       	sbrc	r24, 0
    5466:	94 c0       	rjmp	.+296    	; 0x5590 <_hDebug+0x134>
			//send_byte(0x01);
			//send_byte(0x01);send_byte(0x00);send_byte(0x00);send_byte(0x00);
			//send_byte(98);
	
		}
		if (KEY3)
    5468:	85 ff       	sbrs	r24, 5
    546a:	23 c0       	rjmp	.+70     	; 0x54b2 <_hDebug+0x56>
		{
			//gyroZangle=0;
			//gyroYangle=0;
			//gyroXangle=0;
			AnglePitch=0;
    546c:	80 e0       	ldi	r24, 0x00	; 0
    546e:	90 e0       	ldi	r25, 0x00	; 0
    5470:	dc 01       	movw	r26, r24
    5472:	80 93 16 06 	sts	0x0616, r24
    5476:	90 93 17 06 	sts	0x0617, r25
    547a:	a0 93 18 06 	sts	0x0618, r26
    547e:	b0 93 19 06 	sts	0x0619, r27
			AngleRoll=0;
    5482:	80 93 de 06 	sts	0x06DE, r24
    5486:	90 93 df 06 	sts	0x06DF, r25
    548a:	a0 93 e0 06 	sts	0x06E0, r26
    548e:	b0 93 e1 06 	sts	0x06E1, r27
			AngleZ =0;
    5492:	80 93 6c 06 	sts	0x066C, r24
    5496:	90 93 6d 06 	sts	0x066D, r25
    549a:	a0 93 6e 06 	sts	0x066E, r26
    549e:	b0 93 6f 06 	sts	0x066F, r27
			maxdiff=0;
    54a2:	80 93 3e 05 	sts	0x053E, r24
    54a6:	90 93 3f 05 	sts	0x053F, r25
    54aa:	a0 93 40 05 	sts	0x0540, r26
    54ae:	b0 93 41 05 	sts	0x0541, r27
		}	
		static double lastGyro=0;
		LCD_SetPos(0, 18);
    54b2:	80 e0       	ldi	r24, 0x00	; 0
    54b4:	62 e1       	ldi	r22, 0x12	; 18
    54b6:	0e 94 1f 0c 	call	0x183e	; 0x183e <LCD_SetPos>
		LCD_WriteString_P(PSTR("Meas"));
    54ba:	89 e2       	ldi	r24, 0x29	; 41
    54bc:	9c e0       	ldi	r25, 0x0C	; 12
    54be:	0e 94 1c 0d 	call	0x1a38	; 0x1a38 <LCD_WriteString_P>
		LCD_WriteValue_double_ex(1,48, AnglePitch,9,false);
    54c2:	20 91 16 06 	lds	r18, 0x0616
    54c6:	30 91 17 06 	lds	r19, 0x0617
    54ca:	40 91 18 06 	lds	r20, 0x0618
    54ce:	50 91 19 06 	lds	r21, 0x0619
    54d2:	81 e0       	ldi	r24, 0x01	; 1
    54d4:	60 e3       	ldi	r22, 0x30	; 48
    54d6:	09 e0       	ldi	r16, 0x09	; 9
    54d8:	ee 24       	eor	r14, r14
    54da:	0e 94 c9 0d 	call	0x1b92	; 0x1b92 <LCD_WriteValue_double_ex>
		LCD_WriteValue_double_ex(2,48, AngleRoll,9,false);
    54de:	20 91 de 06 	lds	r18, 0x06DE
    54e2:	30 91 df 06 	lds	r19, 0x06DF
    54e6:	40 91 e0 06 	lds	r20, 0x06E0
    54ea:	50 91 e1 06 	lds	r21, 0x06E1
    54ee:	82 e0       	ldi	r24, 0x02	; 2
    54f0:	60 e3       	ldi	r22, 0x30	; 48
    54f2:	0e 94 c9 0d 	call	0x1b92	; 0x1b92 <LCD_WriteValue_double_ex>
		LCD_WriteValue_double_ex(3,48, AngleZ,9,false);
    54f6:	20 91 6c 06 	lds	r18, 0x066C
    54fa:	30 91 6d 06 	lds	r19, 0x066D
    54fe:	40 91 6e 06 	lds	r20, 0x066E
    5502:	50 91 6f 06 	lds	r21, 0x066F
    5506:	83 e0       	ldi	r24, 0x03	; 3
    5508:	60 e3       	ldi	r22, 0x30	; 48
    550a:	0e 94 c9 0d 	call	0x1b92	; 0x1b92 <LCD_WriteValue_double_ex>
		LCD_WriteValue_double_ex(4,48, NavX,9,false);
    550e:	20 91 48 05 	lds	r18, 0x0548
    5512:	30 91 49 05 	lds	r19, 0x0549
    5516:	40 91 4a 05 	lds	r20, 0x054A
    551a:	50 91 4b 05 	lds	r21, 0x054B
    551e:	84 e0       	ldi	r24, 0x04	; 4
    5520:	60 e3       	ldi	r22, 0x30	; 48
    5522:	0e 94 c9 0d 	call	0x1b92	; 0x1b92 <LCD_WriteValue_double_ex>
		//lastGyro = Sensors_Latest[GYRO_ROLL_Index];
		//if (abs(maxdiff) < abs(lastGyro)) maxdiff = lastGyro;
		maxdiff = maxdiff + CompAccZ;
    5526:	60 91 3e 05 	lds	r22, 0x053E
    552a:	70 91 3f 05 	lds	r23, 0x053F
    552e:	80 91 40 05 	lds	r24, 0x0540
    5532:	90 91 41 05 	lds	r25, 0x0541
    5536:	20 91 37 06 	lds	r18, 0x0637
    553a:	30 91 38 06 	lds	r19, 0x0638
    553e:	40 91 39 06 	lds	r20, 0x0639
    5542:	50 91 3a 06 	lds	r21, 0x063A
    5546:	0e 94 92 37 	call	0x6f24	; 0x6f24 <__addsf3>
    554a:	60 93 3e 05 	sts	0x053E, r22
    554e:	70 93 3f 05 	sts	0x053F, r23
    5552:	80 93 40 05 	sts	0x0540, r24
    5556:	90 93 41 05 	sts	0x0541, r25
		LCD_WriteValue_double_ex(5,48,AnglePitch,9,true);
    555a:	20 91 16 06 	lds	r18, 0x0616
    555e:	30 91 17 06 	lds	r19, 0x0617
    5562:	40 91 18 06 	lds	r20, 0x0618
    5566:	50 91 19 06 	lds	r21, 0x0619
    556a:	85 e0       	ldi	r24, 0x05	; 5
    556c:	60 e3       	ldi	r22, 0x30	; 48
    556e:	ee 24       	eor	r14, r14
    5570:	e3 94       	inc	r14
    5572:	0e 94 c9 0d 	call	0x1b92	; 0x1b92 <LCD_WriteValue_double_ex>
		LCD_WriteValue_double_ex(6,48,Sensors_Latest[ACC_PITCH_Index],9,false);
    5576:	20 91 47 06 	lds	r18, 0x0647
    557a:	30 91 48 06 	lds	r19, 0x0648
    557e:	40 91 49 06 	lds	r20, 0x0649
    5582:	50 91 4a 06 	lds	r21, 0x064A
    5586:	86 e0       	ldi	r24, 0x06	; 6
    5588:	60 e3       	ldi	r22, 0x30	; 48
    558a:	ee 24       	eor	r14, r14
    558c:	0e 94 c9 0d 	call	0x1b92	; 0x1b92 <LCD_WriteValue_double_ex>
		
		//LCD_WriteValue(4,48, MotorOut[3],9,false);
	}
}
    5590:	0f 91       	pop	r16
    5592:	ef 90       	pop	r14
    5594:	08 95       	ret

00005596 <_hSensorCalibration>:

	_helper_DisplayRXStatus(6);
}

void _hSensorCalibration()
{
    5596:	ef 92       	push	r14
    5598:	0f 93       	push	r16
    559a:	1f 93       	push	r17
    559c:	cf 93       	push	r28
    559e:	df 93       	push	r29
	NOKEYRETURN;
    55a0:	80 91 ba 05 	lds	r24, 0x05BA
    55a4:	88 23       	and	r24, r24
    55a6:	79 f1       	breq	.+94     	; 0x5606 <_hSensorCalibration+0x70>
	uint8_t i;
		
	if (KEY4)
    55a8:	84 ff       	sbrs	r24, 4
    55aa:	19 c0       	rjmp	.+50     	; 0x55de <_hSensorCalibration+0x48>
    55ac:	15 e0       	ldi	r17, 0x05	; 5
	{
		// Delay to allow not touching the board.		
		for (i=0; i<5;++i)
		{
			LED_FlashOrangeLED (200,2);
    55ae:	88 ec       	ldi	r24, 0xC8	; 200
    55b0:	90 e0       	ldi	r25, 0x00	; 0
    55b2:	62 e0       	ldi	r22, 0x02	; 2
    55b4:	0e 94 aa 0e 	call	0x1d54	; 0x1d54 <LED_FlashOrangeLED>
			Beeper_Beep(BEEP_SHORT,1);
    55b8:	86 e4       	ldi	r24, 0x46	; 70
    55ba:	90 e0       	ldi	r25, 0x00	; 0
    55bc:	61 e0       	ldi	r22, 0x01	; 1
    55be:	0e 94 a8 0b 	call	0x1750	; 0x1750 <Beeper_Beep>
    55c2:	11 50       	subi	r17, 0x01	; 1
	uint8_t i;
		
	if (KEY4)
	{
		// Delay to allow not touching the board.		
		for (i=0; i<5;++i)
    55c4:	a1 f7       	brne	.-24     	; 0x55ae <_hSensorCalibration+0x18>
		{
			LED_FlashOrangeLED (200,2);
			Beeper_Beep(BEEP_SHORT,1);
		}
	
		Sensors_Calibrate ();
    55c6:	0e 94 5b 28 	call	0x50b6	; 0x50b6 <Sensors_Calibrate>
		
		Save_Config_to_EEPROM();
    55ca:	0e 94 df 0f 	call	0x1fbe	; 0x1fbe <Save_Config_to_EEPROM>
		currentPage.softkeys = _skBACK;
    55ce:	8a e0       	ldi	r24, 0x0A	; 10
    55d0:	9d e0       	ldi	r25, 0x0D	; 13
    55d2:	90 93 43 05 	sts	0x0543, r25
    55d6:	80 93 42 05 	sts	0x0542, r24
		writeSoftkeys(currentPage.softkeys);
    55da:	0e 94 19 2a 	call	0x5432	; 0x5432 <writeSoftkeys>
    55de:	c8 e8       	ldi	r28, 0x88	; 136
    55e0:	d7 e0       	ldi	r29, 0x07	; 7
void _hSensorCalibration()
{
	NOKEYRETURN;
	uint8_t i;
		
	if (KEY4)
    55e2:	10 e0       	ldi	r17, 0x00	; 0
	}
	
	
	for (i=0; i<6;++i)
	{ // order is aligned with ACC_PITCH_Index & GYRO_ROLL_Index
		LCD_SetPos(i, 48);
    55e4:	81 2f       	mov	r24, r17
    55e6:	60 e3       	ldi	r22, 0x30	; 48
    55e8:	0e 94 1f 0c 	call	0x183e	; 0x183e <LCD_SetPos>
		LCD_WriteValue_double_ex(i,48,Config.Sensor_zero[i],9,false);
    55ec:	29 91       	ld	r18, Y+
    55ee:	39 91       	ld	r19, Y+
    55f0:	49 91       	ld	r20, Y+
    55f2:	59 91       	ld	r21, Y+
    55f4:	81 2f       	mov	r24, r17
    55f6:	60 e3       	ldi	r22, 0x30	; 48
    55f8:	09 e0       	ldi	r16, 0x09	; 9
    55fa:	ee 24       	eor	r14, r14
    55fc:	0e 94 c9 0d 	call	0x1b92	; 0x1b92 <LCD_WriteValue_double_ex>
		currentPage.softkeys = _skBACK;
		writeSoftkeys(currentPage.softkeys);
	}
	
	
	for (i=0; i<6;++i)
    5600:	1f 5f       	subi	r17, 0xFF	; 255
    5602:	16 30       	cpi	r17, 0x06	; 6
    5604:	79 f7       	brne	.-34     	; 0x55e4 <_hSensorCalibration+0x4e>
	{ // order is aligned with ACC_PITCH_Index & GYRO_ROLL_Index
		LCD_SetPos(i, 48);
		LCD_WriteValue_double_ex(i,48,Config.Sensor_zero[i],9,false);
	}	
	
}
    5606:	df 91       	pop	r29
    5608:	cf 91       	pop	r28
    560a:	1f 91       	pop	r17
    560c:	0f 91       	pop	r16
    560e:	ef 90       	pop	r14
    5610:	08 95       	ret

00005612 <_hSensorTest>:
	}
}


void _hSensorTest()
{
    5612:	0f 93       	push	r16
    5614:	1f 93       	push	r17
    5616:	cf 93       	push	r28
    5618:	df 93       	push	r29
	#define AccLowLimit			450
	#define AccHighLimit		850
	#define GyroLowLimit		450 //500		
	#define GyroHighLimit		850 //630
	
	for (int i=0; i<6;++i)
    561a:	05 e1       	ldi	r16, 0x15	; 21
    561c:	11 e0       	ldi	r17, 0x01	; 1
    561e:	c0 e0       	ldi	r28, 0x00	; 0
    5620:	d0 e0       	ldi	r29, 0x00	; 0
	{
		LCD_SetPos(i, 48);
    5622:	8c 2f       	mov	r24, r28
    5624:	60 e3       	ldi	r22, 0x30	; 48
    5626:	0e 94 1f 0c 	call	0x183e	; 0x183e <LCD_SetPos>
		LCD_WriteString(Sensors_Test(SensorsIndex[i],GyroLowLimit,GyroHighLimit));
    562a:	f8 01       	movw	r30, r16
    562c:	81 91       	ld	r24, Z+
    562e:	8f 01       	movw	r16, r30
    5630:	62 ec       	ldi	r22, 0xC2	; 194
    5632:	71 e0       	ldi	r23, 0x01	; 1
    5634:	42 e5       	ldi	r20, 0x52	; 82
    5636:	53 e0       	ldi	r21, 0x03	; 3
    5638:	0e 94 23 28 	call	0x5046	; 0x5046 <Sensors_Test>
    563c:	0e 94 08 0d 	call	0x1a10	; 0x1a10 <LCD_WriteString>
	#define AccLowLimit			450
	#define AccHighLimit		850
	#define GyroLowLimit		450 //500		
	#define GyroHighLimit		850 //630
	
	for (int i=0; i<6;++i)
    5640:	21 96       	adiw	r28, 0x01	; 1
    5642:	c6 30       	cpi	r28, 0x06	; 6
    5644:	d1 05       	cpc	r29, r1
    5646:	69 f7       	brne	.-38     	; 0x5622 <_hSensorTest+0x10>
	//LCD_WriteString(Sensors_Test(ACC_ROLL_PNUM,AccLowLimit,AccHighLimit));
	//LCD_SetPos(5, 48);
	//LCD_WriteString(Sensors_Test(ACC_Z_PNUM,AccLowLimit,AccHighLimit));
	//LCD_SetPos(6, 48);
	//LCD_WriteValue_double(6,48,Sensor_GetBattery(),false);
}
    5648:	df 91       	pop	r29
    564a:	cf 91       	pop	r28
    564c:	1f 91       	pop	r17
    564e:	0f 91       	pop	r16
    5650:	08 95       	ret

00005652 <_hHomeArmedESC>:


void _hHomeArmedESC (void)
{
	
	if (IS_INIT)	
    5652:	80 91 ba 05 	lds	r24, 0x05BA
    5656:	80 ff       	sbrs	r24, 0
    5658:	10 c0       	rjmp	.+32     	; 0x567a <_hHomeArmedESC+0x28>
	{
		LCD_SelectFont (&font12x16);
    565a:	87 e7       	ldi	r24, 0x77	; 119
    565c:	91 e0       	ldi	r25, 0x01	; 1
    565e:	0e 94 73 0e 	call	0x1ce6	; 0x1ce6 <LCD_SelectFont>
		LCD_SetPos(0,0);
    5662:	80 e0       	ldi	r24, 0x00	; 0
    5664:	60 e0       	ldi	r22, 0x00	; 0
    5666:	0e 94 1f 0c 	call	0x183e	; 0x183e <LCD_SetPos>
		LCD_WriteString_P(strARMED);
    566a:	8e e2       	ldi	r24, 0x2E	; 46
    566c:	9d e0       	ldi	r25, 0x0D	; 13
    566e:	0e 94 1c 0d 	call	0x1a38	; 0x1a38 <LCD_WriteString_P>
		LCD_SelectFont (NULL);
    5672:	80 e0       	ldi	r24, 0x00	; 0
    5674:	90 e0       	ldi	r25, 0x00	; 0
    5676:	0e 94 73 0e 	call	0x1ce6	; 0x1ce6 <LCD_SelectFont>
	}
	
	if (KEY4)
    567a:	80 91 ba 05 	lds	r24, 0x05BA
    567e:	84 ff       	sbrs	r24, 4
    5680:	04 c0       	rjmp	.+8      	; 0x568a <_hHomeArmedESC+0x38>
	{
		//reset ESC Calibration mode.
		Config.IsESCCalibration=ESCCalibration_OFF;
    5682:	10 92 ef 06 	sts	0x06EF, r1
		Save_Config_to_EEPROM();
    5686:	0e 94 df 0f 	call	0x1fbe	; 0x1fbe <Save_Config_to_EEPROM>
	}
	
	LCD_SetPos(3,18);
    568a:	83 e0       	ldi	r24, 0x03	; 3
    568c:	62 e1       	ldi	r22, 0x12	; 18
    568e:	0e 94 1f 0c 	call	0x183e	; 0x183e <LCD_SetPos>
	itoa(MotorOut[0],sXDeg,10);
    5692:	80 91 96 05 	lds	r24, 0x0596
    5696:	90 91 97 05 	lds	r25, 0x0597
    569a:	6a ee       	ldi	r22, 0xEA	; 234
    569c:	75 e0       	ldi	r23, 0x05	; 5
    569e:	4a e0       	ldi	r20, 0x0A	; 10
    56a0:	50 e0       	ldi	r21, 0x00	; 0
    56a2:	0e 94 ae 3a 	call	0x755c	; 0x755c <itoa>
	LCD_WritePadded(sXDeg,5);
    56a6:	8a ee       	ldi	r24, 0xEA	; 234
    56a8:	95 e0       	ldi	r25, 0x05	; 5
    56aa:	65 e0       	ldi	r22, 0x05	; 5
    56ac:	0e 94 6e 0d 	call	0x1adc	; 0x1adc <LCD_WritePadded>
	
	LCD_SetPos(3,78);
    56b0:	83 e0       	ldi	r24, 0x03	; 3
    56b2:	6e e4       	ldi	r22, 0x4E	; 78
    56b4:	0e 94 1f 0c 	call	0x183e	; 0x183e <LCD_SetPos>
	itoa(MotorOut[3],sXDeg,10);
    56b8:	80 91 9c 05 	lds	r24, 0x059C
    56bc:	90 91 9d 05 	lds	r25, 0x059D
    56c0:	6a ee       	ldi	r22, 0xEA	; 234
    56c2:	75 e0       	ldi	r23, 0x05	; 5
    56c4:	4a e0       	ldi	r20, 0x0A	; 10
    56c6:	50 e0       	ldi	r21, 0x00	; 0
    56c8:	0e 94 ae 3a 	call	0x755c	; 0x755c <itoa>
	LCD_WritePadded(sXDeg,5);
    56cc:	8a ee       	ldi	r24, 0xEA	; 234
    56ce:	95 e0       	ldi	r25, 0x05	; 5
    56d0:	65 e0       	ldi	r22, 0x05	; 5
    56d2:	0e 94 6e 0d 	call	0x1adc	; 0x1adc <LCD_WritePadded>
	
	LCD_SetPos(4,18);
    56d6:	84 e0       	ldi	r24, 0x04	; 4
    56d8:	62 e1       	ldi	r22, 0x12	; 18
    56da:	0e 94 1f 0c 	call	0x183e	; 0x183e <LCD_SetPos>
	itoa(MotorOut[1],sXDeg,10);
    56de:	80 91 98 05 	lds	r24, 0x0598
    56e2:	90 91 99 05 	lds	r25, 0x0599
    56e6:	6a ee       	ldi	r22, 0xEA	; 234
    56e8:	75 e0       	ldi	r23, 0x05	; 5
    56ea:	4a e0       	ldi	r20, 0x0A	; 10
    56ec:	50 e0       	ldi	r21, 0x00	; 0
    56ee:	0e 94 ae 3a 	call	0x755c	; 0x755c <itoa>
	LCD_WritePadded(sXDeg,5);
    56f2:	8a ee       	ldi	r24, 0xEA	; 234
    56f4:	95 e0       	ldi	r25, 0x05	; 5
    56f6:	65 e0       	ldi	r22, 0x05	; 5
    56f8:	0e 94 6e 0d 	call	0x1adc	; 0x1adc <LCD_WritePadded>
	
	LCD_SetPos(4,78);
    56fc:	84 e0       	ldi	r24, 0x04	; 4
    56fe:	6e e4       	ldi	r22, 0x4E	; 78
    5700:	0e 94 1f 0c 	call	0x183e	; 0x183e <LCD_SetPos>
	itoa(MotorOut[2],sXDeg,10);
    5704:	80 91 9a 05 	lds	r24, 0x059A
    5708:	90 91 9b 05 	lds	r25, 0x059B
    570c:	6a ee       	ldi	r22, 0xEA	; 234
    570e:	75 e0       	ldi	r23, 0x05	; 5
    5710:	4a e0       	ldi	r20, 0x0A	; 10
    5712:	50 e0       	ldi	r21, 0x00	; 0
    5714:	0e 94 ae 3a 	call	0x755c	; 0x755c <itoa>
	LCD_WritePadded(sXDeg,5);
    5718:	8a ee       	ldi	r24, 0xEA	; 234
    571a:	95 e0       	ldi	r25, 0x05	; 5
    571c:	65 e0       	ldi	r22, 0x05	; 5
    571e:	0e 94 6e 0d 	call	0x1adc	; 0x1adc <LCD_WritePadded>
	
}
    5722:	08 95       	ret

00005724 <_helper_DisplayPitchRollYaw>:
	};
//////////////////////////////////////////////////////////////////////////

void _helper_DisplayPitchRollYaw (const uint8_t subindex)
{
	switch (subindex)
    5724:	81 30       	cpi	r24, 0x01	; 1
    5726:	99 f0       	breq	.+38     	; 0x574e <_helper_DisplayPitchRollYaw+0x2a>
    5728:	81 30       	cpi	r24, 0x01	; 1
    572a:	18 f0       	brcs	.+6      	; 0x5732 <_helper_DisplayPitchRollYaw+0xe>
    572c:	82 30       	cpi	r24, 0x02	; 2
    572e:	e1 f4       	brne	.+56     	; 0x5768 <_helper_DisplayPitchRollYaw+0x44>
    5730:	15 c0       	rjmp	.+42     	; 0x575c <_helper_DisplayPitchRollYaw+0x38>
	{
		case 0:	
			if (Config.PitchRollLinked==0)
    5732:	80 91 af 07 	lds	r24, 0x07AF
    5736:	88 23       	and	r24, r24
    5738:	29 f4       	brne	.+10     	; 0x5744 <_helper_DisplayPitchRollYaw+0x20>
			{				   
				strcpy_P(sXDeg,PSTR("Pitch        "));
    573a:	8a ee       	ldi	r24, 0xEA	; 234
    573c:	95 e0       	ldi	r25, 0x05	; 5
    573e:	69 e1       	ldi	r22, 0x19	; 25
    5740:	7e e0       	ldi	r23, 0x0E	; 14
    5742:	09 c0       	rjmp	.+18     	; 0x5756 <_helper_DisplayPitchRollYaw+0x32>
			}
			else
			{
				strcpy_P(sXDeg,PSTR("Pitch & Roll "));
    5744:	8a ee       	ldi	r24, 0xEA	; 234
    5746:	95 e0       	ldi	r25, 0x05	; 5
    5748:	6b e0       	ldi	r22, 0x0B	; 11
    574a:	7e e0       	ldi	r23, 0x0E	; 14
    574c:	04 c0       	rjmp	.+8      	; 0x5756 <_helper_DisplayPitchRollYaw+0x32>
			}
			break;
		case 1:	
				strcpy_P(sXDeg,PSTR("Roll         "));
    574e:	8a ee       	ldi	r24, 0xEA	; 234
    5750:	95 e0       	ldi	r25, 0x05	; 5
    5752:	6d ef       	ldi	r22, 0xFD	; 253
    5754:	7d e0       	ldi	r23, 0x0D	; 13
    5756:	0e 94 8a 3a 	call	0x7514	; 0x7514 <strcpy_P>
			break;
    575a:	08 95       	ret
		case 2:	
				strcpy_P(sXDeg,PSTR("YAW          "));
    575c:	8a ee       	ldi	r24, 0xEA	; 234
    575e:	95 e0       	ldi	r25, 0x05	; 5
    5760:	6f ee       	ldi	r22, 0xEF	; 239
    5762:	7d e0       	ldi	r23, 0x0D	; 13
    5764:	0e 94 8a 3a 	call	0x7514	; 0x7514 <strcpy_P>
    5768:	08 95       	ret

0000576a <_helper_SwitchPitchRollYaw>:
			break;
	}
}

void _helper_SwitchPitchRollYaw (uint8_t *subindex)
{
    576a:	fc 01       	movw	r30, r24
	switch (subindex[0])
    576c:	80 81       	ld	r24, Z
    576e:	81 30       	cpi	r24, 0x01	; 1
    5770:	59 f0       	breq	.+22     	; 0x5788 <_helper_SwitchPitchRollYaw+0x1e>
    5772:	81 30       	cpi	r24, 0x01	; 1
    5774:	18 f0       	brcs	.+6      	; 0x577c <_helper_SwitchPitchRollYaw+0x12>
    5776:	82 30       	cpi	r24, 0x02	; 2
    5778:	59 f4       	brne	.+22     	; 0x5790 <_helper_SwitchPitchRollYaw+0x26>
    577a:	09 c0       	rjmp	.+18     	; 0x578e <_helper_SwitchPitchRollYaw+0x24>
	{
		case 0:	if (Config.PitchRollLinked==0) subindex[0]=1; else subindex[0]=2;
    577c:	80 91 af 07 	lds	r24, 0x07AF
    5780:	88 23       	and	r24, r24
    5782:	11 f4       	brne	.+4      	; 0x5788 <_helper_SwitchPitchRollYaw+0x1e>
    5784:	81 e0       	ldi	r24, 0x01	; 1
    5786:	01 c0       	rjmp	.+2      	; 0x578a <_helper_SwitchPitchRollYaw+0x20>
		break;
		case 1:	subindex[0] +=1;
    5788:	82 e0       	ldi	r24, 0x02	; 2
    578a:	80 83       	st	Z, r24
		break;
    578c:	08 95       	ret
		case 2: subindex[0]=0;
    578e:	10 82       	st	Z, r1
    5790:	08 95       	ret

00005792 <_helper_DisplayBiStateText>:

	return;	
}	

void _helper_DisplayBiStateText(const uint8_t Row, const uint8_t Col, PGM_P strTrue, PGM_P strFalse, const bool Condition, const BOOL LCDReverse )
{
    5792:	af 92       	push	r10
    5794:	bf 92       	push	r11
    5796:	cf 92       	push	r12
    5798:	df 92       	push	r13
    579a:	ef 92       	push	r14
    579c:	0f 93       	push	r16
    579e:	1f 93       	push	r17
    57a0:	df 93       	push	r29
    57a2:	cf 93       	push	r28
    57a4:	0f 92       	push	r0
    57a6:	cd b7       	in	r28, 0x3d	; 61
    57a8:	de b7       	in	r29, 0x3e	; 62
    57aa:	18 2f       	mov	r17, r24
    57ac:	6a 01       	movw	r12, r20
    57ae:	59 01       	movw	r10, r18
    57b0:	8e 2d       	mov	r24, r14
		lcdReverse(LCDReverse);
    57b2:	69 83       	std	Y+1, r22	; 0x01
    57b4:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <lcdReverse>
		LCD_SetPos(Row, Col);
    57b8:	81 2f       	mov	r24, r17
    57ba:	69 81       	ldd	r22, Y+1	; 0x01
    57bc:	0e 94 1f 0c 	call	0x183e	; 0x183e <LCD_SetPos>
		if (Condition==true) 
    57c0:	00 23       	and	r16, r16
    57c2:	11 f0       	breq	.+4      	; 0x57c8 <_helper_DisplayBiStateText+0x36>
		{
			LCD_WriteString_P(strTrue);
    57c4:	c6 01       	movw	r24, r12
    57c6:	01 c0       	rjmp	.+2      	; 0x57ca <_helper_DisplayBiStateText+0x38>
		}
		else
		{
			LCD_WriteString_P(strFalse);
    57c8:	c5 01       	movw	r24, r10
    57ca:	0e 94 1c 0d 	call	0x1a38	; 0x1a38 <LCD_WriteString_P>
		}	
		lcdReverse(false);
    57ce:	80 e0       	ldi	r24, 0x00	; 0
    57d0:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <lcdReverse>
}
    57d4:	0f 90       	pop	r0
    57d6:	cf 91       	pop	r28
    57d8:	df 91       	pop	r29
    57da:	1f 91       	pop	r17
    57dc:	0f 91       	pop	r16
    57de:	ef 90       	pop	r14
    57e0:	df 90       	pop	r13
    57e2:	cf 90       	pop	r12
    57e4:	bf 90       	pop	r11
    57e6:	af 90       	pop	r10
    57e8:	08 95       	ret

000057ea <_helper_SaveinEEPROM_ifChanged>:


void _helper_SaveinEEPROM_ifChanged()
{
	if (bValueChanged==true)
    57ea:	80 91 38 05 	lds	r24, 0x0538
    57ee:	81 30       	cpi	r24, 0x01	; 1
    57f0:	21 f4       	brne	.+8      	; 0x57fa <_helper_SaveinEEPROM_ifChanged+0x10>
		{
			Save_Config_to_EEPROM();
    57f2:	0e 94 df 0f 	call	0x1fbe	; 0x1fbe <Save_Config_to_EEPROM>
			bValueChanged = false;
    57f6:	10 92 38 05 	sts	0x0538, r1
    57fa:	08 95       	ret

000057fc <_helper_DisplayRXStatus>:
			return ;
	}
}

void _helper_DisplayRXStatus(const uint8_t Row)
{
    57fc:	ef 92       	push	r14
    57fe:	0f 93       	push	r16
    5800:	1f 93       	push	r17
    5802:	18 2f       	mov	r17, r24
	// Write RX Status
	// FIX: highlighted is the selected one.
	_helper_DisplayBiStateText(Row,18,str1,strX,IS_TX1_GOOD,(ActiveRXIndex!=1));
    5804:	20 91 fb 07 	lds	r18, 0x07FB
    5808:	80 91 ca 05 	lds	r24, 0x05CA
    580c:	30 e0       	ldi	r19, 0x00	; 0
    580e:	2f 70       	andi	r18, 0x0F	; 15
    5810:	30 70       	andi	r19, 0x00	; 0
    5812:	01 e0       	ldi	r16, 0x01	; 1
    5814:	21 15       	cp	r18, r1
    5816:	31 05       	cpc	r19, r1
    5818:	09 f0       	breq	.+2      	; 0x581c <_helper_DisplayRXStatus+0x20>
    581a:	00 e0       	ldi	r16, 0x00	; 0
    581c:	91 e0       	ldi	r25, 0x01	; 1
    581e:	81 30       	cpi	r24, 0x01	; 1
    5820:	09 f4       	brne	.+2      	; 0x5824 <_helper_DisplayRXStatus+0x28>
    5822:	90 e0       	ldi	r25, 0x00	; 0
    5824:	81 2f       	mov	r24, r17
    5826:	62 e1       	ldi	r22, 0x12	; 18
    5828:	4c e4       	ldi	r20, 0x4C	; 76
    582a:	5d e0       	ldi	r21, 0x0D	; 13
    582c:	2e e4       	ldi	r18, 0x4E	; 78
    582e:	3d e0       	ldi	r19, 0x0D	; 13
    5830:	e9 2e       	mov	r14, r25
    5832:	0e 94 c9 2b 	call	0x5792	; 0x5792 <_helper_DisplayBiStateText>
	
	_helper_DisplayBiStateText(Row,30,str2,strX,IS_TX2_GOOD,(ActiveRXIndex!=0));
    5836:	80 91 fb 07 	lds	r24, 0x07FB
    583a:	20 91 ca 05 	lds	r18, 0x05CA
    583e:	80 7f       	andi	r24, 0xF0	; 240
    5840:	01 e0       	ldi	r16, 0x01	; 1
    5842:	09 f0       	breq	.+2      	; 0x5846 <_helper_DisplayRXStatus+0x4a>
    5844:	00 e0       	ldi	r16, 0x00	; 0
    5846:	91 e0       	ldi	r25, 0x01	; 1
    5848:	22 23       	and	r18, r18
    584a:	09 f4       	brne	.+2      	; 0x584e <_helper_DisplayRXStatus+0x52>
    584c:	90 e0       	ldi	r25, 0x00	; 0
    584e:	81 2f       	mov	r24, r17
    5850:	6e e1       	ldi	r22, 0x1E	; 30
    5852:	40 e5       	ldi	r20, 0x50	; 80
    5854:	5d e0       	ldi	r21, 0x0D	; 13
    5856:	2e e4       	ldi	r18, 0x4E	; 78
    5858:	3d e0       	ldi	r19, 0x0D	; 13
    585a:	e9 2e       	mov	r14, r25
    585c:	0e 94 c9 2b 	call	0x5792	; 0x5792 <_helper_DisplayBiStateText>
	
	lcdReverse(false);
    5860:	80 e0       	ldi	r24, 0x00	; 0
    5862:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <lcdReverse>
	
}
    5866:	1f 91       	pop	r17
    5868:	0f 91       	pop	r16
    586a:	ef 90       	pop	r14
    586c:	08 95       	ret

0000586e <_hStickCentering>:



BOOL bError; 
void _hStickCentering()
{
    586e:	0f 93       	push	r16
    5870:	1f 93       	push	r17
    5872:	cf 93       	push	r28
    5874:	df 93       	push	r29
	uint8_t i ;
	UIEnableStickCommands=false; // you cannot use sticks here. for arming or as buttons.
    5876:	10 92 e5 05 	sts	0x05E5, r1
	
	if (IS_INIT)
    587a:	80 91 ba 05 	lds	r24, 0x05BA
    587e:	80 ff       	sbrs	r24, 0
    5880:	0c c0       	rjmp	.+24     	; 0x589a <_hStickCentering+0x2c>
	{
		RX_StickCenterCalibrationInit(ActiveRXIndex);
    5882:	80 91 ca 05 	lds	r24, 0x05CA
    5886:	0e 94 26 27 	call	0x4e4c	; 0x4e4c <RX_StickCenterCalibrationInit>
		LCD_WriteString_Pex(0,0,strSPC1,18,false); // clear the header
    588a:	80 e0       	ldi	r24, 0x00	; 0
    588c:	60 e0       	ldi	r22, 0x00	; 0
    588e:	40 e2       	ldi	r20, 0x20	; 32
    5890:	5d e0       	ldi	r21, 0x0D	; 13
    5892:	22 e1       	ldi	r18, 0x12	; 18
    5894:	00 e0       	ldi	r16, 0x00	; 0
    5896:	0e 94 a4 0d 	call	0x1b48	; 0x1b48 <LCD_WriteString_Pex>
	}
	
	if (KEY4)
    589a:	80 91 ba 05 	lds	r24, 0x05BA
    589e:	84 ff       	sbrs	r24, 4
    58a0:	bf c0       	rjmp	.+382    	; 0x5a20 <_hStickCentering+0x1b2>
	{
		if (!bError)
    58a2:	80 91 46 08 	lds	r24, 0x0846
    58a6:	88 23       	and	r24, r24
    58a8:	09 f0       	breq	.+2      	; 0x58ac <_hStickCentering+0x3e>
    58aa:	b5 c0       	rjmp	.+362    	; 0x5a16 <_hStickCentering+0x1a8>
    58ac:	20 e0       	ldi	r18, 0x00	; 0
    58ae:	30 e0       	ldi	r19, 0x00	; 0
			// Save config
			for (i = 0; i < RXChannels; i++)
			{
				Config.RX_Mid[ActiveRXIndex][i] = (RX_MAX_raw[ActiveRXIndex][i]+RX_MIN_raw[ActiveRXIndex][i])/2;
				Config.RX_Min[ActiveRXIndex][i] = RX_MIN_raw[ActiveRXIndex][i];
				Config.RX_DiV_Value[ActiveRXIndex][i] = ((RX_MAX_raw[ActiveRXIndex][i] - RX_MIN_raw[ActiveRXIndex][i]) / 1000);
    58b0:	08 ee       	ldi	r16, 0xE8	; 232
    58b2:	13 e0       	ldi	r17, 0x03	; 3
		if (!bError)
		{
			// Save config
			for (i = 0; i < RXChannels; i++)
			{
				Config.RX_Mid[ActiveRXIndex][i] = (RX_MAX_raw[ActiveRXIndex][i]+RX_MIN_raw[ActiveRXIndex][i])/2;
    58b4:	80 91 ca 05 	lds	r24, 0x05CA
    58b8:	40 91 ca 05 	lds	r20, 0x05CA
    58bc:	60 91 ca 05 	lds	r22, 0x05CA
    58c0:	90 e0       	ldi	r25, 0x00	; 0
    58c2:	fc 01       	movw	r30, r24
    58c4:	ee 0f       	add	r30, r30
    58c6:	ff 1f       	adc	r31, r31
    58c8:	ee 0f       	add	r30, r30
    58ca:	ff 1f       	adc	r31, r31
    58cc:	e8 0f       	add	r30, r24
    58ce:	f9 1f       	adc	r31, r25
    58d0:	e2 0f       	add	r30, r18
    58d2:	f3 1f       	adc	r31, r19
    58d4:	ee 0f       	add	r30, r30
    58d6:	ff 1f       	adc	r31, r31
    58d8:	e4 5a       	subi	r30, 0xA4	; 164
    58da:	f8 4f       	sbci	r31, 0xF8	; 248
    58dc:	70 e0       	ldi	r23, 0x00	; 0
    58de:	cb 01       	movw	r24, r22
    58e0:	88 0f       	add	r24, r24
    58e2:	99 1f       	adc	r25, r25
    58e4:	88 0f       	add	r24, r24
    58e6:	99 1f       	adc	r25, r25
    58e8:	86 0f       	add	r24, r22
    58ea:	97 1f       	adc	r25, r23
    58ec:	82 0f       	add	r24, r18
    58ee:	93 1f       	adc	r25, r19
    58f0:	88 0f       	add	r24, r24
    58f2:	99 1f       	adc	r25, r25
    58f4:	8e 53       	subi	r24, 0x3E	; 62
    58f6:	99 4f       	sbci	r25, 0xF9	; 249
    58f8:	50 e0       	ldi	r21, 0x00	; 0
    58fa:	da 01       	movw	r26, r20
    58fc:	aa 0f       	add	r26, r26
    58fe:	bb 1f       	adc	r27, r27
    5900:	aa 0f       	add	r26, r26
    5902:	bb 1f       	adc	r27, r27
    5904:	a4 0f       	add	r26, r20
    5906:	b5 1f       	adc	r27, r21
    5908:	a2 0f       	add	r26, r18
    590a:	b3 1f       	adc	r27, r19
    590c:	aa 0f       	add	r26, r26
    590e:	bb 1f       	adc	r27, r27
    5910:	af 5d       	subi	r26, 0xDF	; 223
    5912:	b9 4f       	sbci	r27, 0xF9	; 249
    5914:	ec 01       	movw	r28, r24
    5916:	88 81       	ld	r24, Y
    5918:	99 81       	ldd	r25, Y+1	; 0x01
    591a:	4d 91       	ld	r20, X+
    591c:	5c 91       	ld	r21, X
    591e:	84 0f       	add	r24, r20
    5920:	95 1f       	adc	r25, r21
    5922:	96 95       	lsr	r25
    5924:	87 95       	ror	r24
    5926:	91 83       	std	Z+1, r25	; 0x01
    5928:	80 83       	st	Z, r24
				Config.RX_Min[ActiveRXIndex][i] = RX_MIN_raw[ActiveRXIndex][i];
    592a:	40 91 ca 05 	lds	r20, 0x05CA
    592e:	80 91 ca 05 	lds	r24, 0x05CA
    5932:	50 e0       	ldi	r21, 0x00	; 0
    5934:	fa 01       	movw	r30, r20
    5936:	ee 0f       	add	r30, r30
    5938:	ff 1f       	adc	r31, r31
    593a:	ee 0f       	add	r30, r30
    593c:	ff 1f       	adc	r31, r31
    593e:	e4 0f       	add	r30, r20
    5940:	f5 1f       	adc	r31, r21
    5942:	e2 0f       	add	r30, r18
    5944:	f3 1f       	adc	r31, r19
    5946:	ee 0f       	add	r30, r30
    5948:	ff 1f       	adc	r31, r31
    594a:	e0 59       	subi	r30, 0x90	; 144
    594c:	f8 4f       	sbci	r31, 0xF8	; 248
    594e:	90 e0       	ldi	r25, 0x00	; 0
    5950:	dc 01       	movw	r26, r24
    5952:	aa 0f       	add	r26, r26
    5954:	bb 1f       	adc	r27, r27
    5956:	aa 0f       	add	r26, r26
    5958:	bb 1f       	adc	r27, r27
    595a:	a8 0f       	add	r26, r24
    595c:	b9 1f       	adc	r27, r25
    595e:	a2 0f       	add	r26, r18
    5960:	b3 1f       	adc	r27, r19
    5962:	aa 0f       	add	r26, r26
    5964:	bb 1f       	adc	r27, r27
    5966:	ae 53       	subi	r26, 0x3E	; 62
    5968:	b9 4f       	sbci	r27, 0xF9	; 249
    596a:	8d 91       	ld	r24, X+
    596c:	9c 91       	ld	r25, X
    596e:	91 83       	std	Z+1, r25	; 0x01
    5970:	80 83       	st	Z, r24
				Config.RX_DiV_Value[ActiveRXIndex][i] = ((RX_MAX_raw[ActiveRXIndex][i] - RX_MIN_raw[ActiveRXIndex][i]) / 1000);
    5972:	80 91 ca 05 	lds	r24, 0x05CA
    5976:	60 91 ca 05 	lds	r22, 0x05CA
    597a:	40 91 ca 05 	lds	r20, 0x05CA
    597e:	90 e0       	ldi	r25, 0x00	; 0
    5980:	fc 01       	movw	r30, r24
    5982:	ee 0f       	add	r30, r30
    5984:	ff 1f       	adc	r31, r31
    5986:	ee 0f       	add	r30, r30
    5988:	ff 1f       	adc	r31, r31
    598a:	e8 0f       	add	r30, r24
    598c:	f9 1f       	adc	r31, r25
    598e:	e2 0f       	add	r30, r18
    5990:	f3 1f       	adc	r31, r19
    5992:	ec 55       	subi	r30, 0x5C	; 92
    5994:	f8 4f       	sbci	r31, 0xF8	; 248
    5996:	70 e0       	ldi	r23, 0x00	; 0
    5998:	cb 01       	movw	r24, r22
    599a:	88 0f       	add	r24, r24
    599c:	99 1f       	adc	r25, r25
    599e:	88 0f       	add	r24, r24
    59a0:	99 1f       	adc	r25, r25
    59a2:	86 0f       	add	r24, r22
    59a4:	97 1f       	adc	r25, r23
    59a6:	82 0f       	add	r24, r18
    59a8:	93 1f       	adc	r25, r19
    59aa:	88 0f       	add	r24, r24
    59ac:	99 1f       	adc	r25, r25
    59ae:	8f 5d       	subi	r24, 0xDF	; 223
    59b0:	99 4f       	sbci	r25, 0xF9	; 249
    59b2:	50 e0       	ldi	r21, 0x00	; 0
    59b4:	da 01       	movw	r26, r20
    59b6:	aa 0f       	add	r26, r26
    59b8:	bb 1f       	adc	r27, r27
    59ba:	aa 0f       	add	r26, r26
    59bc:	bb 1f       	adc	r27, r27
    59be:	a4 0f       	add	r26, r20
    59c0:	b5 1f       	adc	r27, r21
    59c2:	a2 0f       	add	r26, r18
    59c4:	b3 1f       	adc	r27, r19
    59c6:	aa 0f       	add	r26, r26
    59c8:	bb 1f       	adc	r27, r27
    59ca:	ae 53       	subi	r26, 0x3E	; 62
    59cc:	b9 4f       	sbci	r27, 0xF9	; 249
    59ce:	ec 01       	movw	r28, r24
    59d0:	88 81       	ld	r24, Y
    59d2:	99 81       	ldd	r25, Y+1	; 0x01
    59d4:	4d 91       	ld	r20, X+
    59d6:	5c 91       	ld	r21, X
    59d8:	11 97       	sbiw	r26, 0x01	; 1
    59da:	84 1b       	sub	r24, r20
    59dc:	95 0b       	sbc	r25, r21
    59de:	b8 01       	movw	r22, r16
    59e0:	0e 94 2f 3a 	call	0x745e	; 0x745e <__udivmodhi4>
    59e4:	60 83       	st	Z, r22
    59e6:	2f 5f       	subi	r18, 0xFF	; 255
    59e8:	3f 4f       	sbci	r19, 0xFF	; 255
	if (KEY4)
	{
		if (!bError)
		{
			// Save config
			for (i = 0; i < RXChannels; i++)
    59ea:	25 30       	cpi	r18, 0x05	; 5
    59ec:	31 05       	cpc	r19, r1
    59ee:	09 f0       	breq	.+2      	; 0x59f2 <_hStickCentering+0x184>
    59f0:	61 cf       	rjmp	.-318    	; 0x58b4 <_hStickCentering+0x46>
				Config.RX_Min[ActiveRXIndex][i] = RX_MIN_raw[ActiveRXIndex][i];
				Config.RX_DiV_Value[ActiveRXIndex][i] = ((RX_MAX_raw[ActiveRXIndex][i] - RX_MIN_raw[ActiveRXIndex][i]) / 1000);
				
			}		
			
			Config.IsCalibrated= (Config.IsCalibrated | (1 << ActiveRXIndex));	// either 0b00000001 or 0b00000010
    59f2:	20 91 ca 05 	lds	r18, 0x05CA
    59f6:	81 e0       	ldi	r24, 0x01	; 1
    59f8:	90 e0       	ldi	r25, 0x00	; 0
    59fa:	02 c0       	rjmp	.+4      	; 0x5a00 <_hStickCentering+0x192>
    59fc:	88 0f       	add	r24, r24
    59fe:	99 1f       	adc	r25, r25
    5a00:	2a 95       	dec	r18
    5a02:	e2 f7       	brpl	.-8      	; 0x59fc <_hStickCentering+0x18e>
    5a04:	20 91 ea 06 	lds	r18, 0x06EA
    5a08:	28 2b       	or	r18, r24
    5a0a:	e7 ee       	ldi	r30, 0xE7	; 231
    5a0c:	f6 e0       	ldi	r31, 0x06	; 6
    5a0e:	23 83       	std	Z+3, r18	; 0x03
			Save_Config_to_EEPROM();
    5a10:	0e 94 df 0f 	call	0x1fbe	; 0x1fbe <Save_Config_to_EEPROM>
    5a14:	05 c0       	rjmp	.+10     	; 0x5a20 <_hStickCentering+0x1b2>
		}
		else
		{
			Beeper_Beep(BEEP_ERROR,3);	
    5a16:	88 ec       	ldi	r24, 0xC8	; 200
    5a18:	90 e0       	ldi	r25, 0x00	; 0
    5a1a:	63 e0       	ldi	r22, 0x03	; 3
    5a1c:	0e 94 a8 0b 	call	0x1750	; 0x1750 <Beeper_Beep>
		}
		
	}
	
	if (KEY2)
    5a20:	80 91 ba 05 	lds	r24, 0x05BA
    5a24:	86 ff       	sbrs	r24, 6
    5a26:	04 c0       	rjmp	.+8      	; 0x5a30 <_hStickCentering+0x1c2>
	{
		RX_StickCenterCalibrationInit(ActiveRXIndex);				
    5a28:	80 91 ca 05 	lds	r24, 0x05CA
    5a2c:	0e 94 26 27 	call	0x4e4c	; 0x4e4c <RX_StickCenterCalibrationInit>
	}
	
	bError = false;
    5a30:	10 92 46 08 	sts	0x0846, r1
	RX_StickCenterCalibration(ActiveRXIndex);
    5a34:	80 91 ca 05 	lds	r24, 0x05CA
    5a38:	0e 94 cd 27 	call	0x4f9a	; 0x4f9a <RX_StickCenterCalibration>
    5a3c:	c0 e0       	ldi	r28, 0x00	; 0
    5a3e:	d0 e0       	ldi	r29, 0x00	; 0
		else
		{
			if ((RX_MAX_raw[ActiveRXIndex][i]< RX_MIN_raw[ActiveRXIndex][i]) || (RX_MIN_raw[ActiveRXIndex][i]==0))  // RX_MIN_raw[i]=0 if the Remote is OFF when entering the test
			{
				LCD_WriteString_P(strErr);	
				bError = TRUE;
    5a40:	11 e0       	ldi	r17, 0x01	; 1
}



BOOL bError; 
void _hStickCentering()
    5a42:	ce 01       	movw	r24, r28
	
	bError = false;
	RX_StickCenterCalibration(ActiveRXIndex);
	for (uint8_t i = 0; i < RXChannels; i++)
	{
		LCD_SetPos(i+1, 30);
    5a44:	8f 5f       	subi	r24, 0xFF	; 255
    5a46:	6e e1       	ldi	r22, 0x1E	; 30
    5a48:	0e 94 1f 0c 	call	0x183e	; 0x183e <LCD_SetPos>
		utoa(RX_MAX_raw[ActiveRXIndex][i], sXDeg, 10);
    5a4c:	80 91 ca 05 	lds	r24, 0x05CA
    5a50:	90 e0       	ldi	r25, 0x00	; 0
    5a52:	fc 01       	movw	r30, r24
    5a54:	ee 0f       	add	r30, r30
    5a56:	ff 1f       	adc	r31, r31
    5a58:	ee 0f       	add	r30, r30
    5a5a:	ff 1f       	adc	r31, r31
    5a5c:	e8 0f       	add	r30, r24
    5a5e:	f9 1f       	adc	r31, r25
    5a60:	ec 0f       	add	r30, r28
    5a62:	fd 1f       	adc	r31, r29
    5a64:	ee 0f       	add	r30, r30
    5a66:	ff 1f       	adc	r31, r31
    5a68:	ef 5d       	subi	r30, 0xDF	; 223
    5a6a:	f9 4f       	sbci	r31, 0xF9	; 249
    5a6c:	80 81       	ld	r24, Z
    5a6e:	91 81       	ldd	r25, Z+1	; 0x01
    5a70:	6a ee       	ldi	r22, 0xEA	; 234
    5a72:	75 e0       	ldi	r23, 0x05	; 5
    5a74:	4a e0       	ldi	r20, 0x0A	; 10
    5a76:	50 e0       	ldi	r21, 0x00	; 0
    5a78:	0e 94 cf 3a 	call	0x759e	; 0x759e <utoa>
		LCD_WriteString(sXDeg);
    5a7c:	8a ee       	ldi	r24, 0xEA	; 234
    5a7e:	95 e0       	ldi	r25, 0x05	; 5
    5a80:	0e 94 08 0d 	call	0x1a10	; 0x1a10 <LCD_WriteString>
		LCD_WriteString_P(strSPC1);
    5a84:	80 e2       	ldi	r24, 0x20	; 32
    5a86:	9d e0       	ldi	r25, 0x0D	; 13
    5a88:	0e 94 1c 0d 	call	0x1a38	; 0x1a38 <LCD_WriteString_P>
		utoa(RX_MIN_raw[ActiveRXIndex][i], sXDeg, 10);
    5a8c:	80 91 ca 05 	lds	r24, 0x05CA
    5a90:	90 e0       	ldi	r25, 0x00	; 0
    5a92:	fc 01       	movw	r30, r24
    5a94:	ee 0f       	add	r30, r30
    5a96:	ff 1f       	adc	r31, r31
    5a98:	ee 0f       	add	r30, r30
    5a9a:	ff 1f       	adc	r31, r31
    5a9c:	e8 0f       	add	r30, r24
    5a9e:	f9 1f       	adc	r31, r25
    5aa0:	ec 0f       	add	r30, r28
    5aa2:	fd 1f       	adc	r31, r29
    5aa4:	ee 0f       	add	r30, r30
    5aa6:	ff 1f       	adc	r31, r31
    5aa8:	ee 53       	subi	r30, 0x3E	; 62
    5aaa:	f9 4f       	sbci	r31, 0xF9	; 249
    5aac:	80 81       	ld	r24, Z
    5aae:	91 81       	ldd	r25, Z+1	; 0x01
    5ab0:	6a ee       	ldi	r22, 0xEA	; 234
    5ab2:	75 e0       	ldi	r23, 0x05	; 5
    5ab4:	4a e0       	ldi	r20, 0x0A	; 10
    5ab6:	50 e0       	ldi	r21, 0x00	; 0
    5ab8:	0e 94 cf 3a 	call	0x759e	; 0x759e <utoa>
		LCD_WriteString(sXDeg);
    5abc:	8a ee       	ldi	r24, 0xEA	; 234
    5abe:	95 e0       	ldi	r25, 0x05	; 5
    5ac0:	0e 94 08 0d 	call	0x1a10	; 0x1a10 <LCD_WriteString>
		if ((ActiveRXIndex==0) && (i == RXChannel_AUX))
    5ac4:	80 91 ca 05 	lds	r24, 0x05CA
    5ac8:	88 23       	and	r24, r24
    5aca:	29 f4       	brne	.+10     	; 0x5ad6 <_hStickCentering+0x268>
    5acc:	c4 30       	cpi	r28, 0x04	; 4
    5ace:	19 f4       	brne	.+6      	; 0x5ad6 <_hStickCentering+0x268>
		{
			LCD_WriteString_P(PSTR("NA"));
    5ad0:	8b e2       	ldi	r24, 0x2B	; 43
    5ad2:	9d e0       	ldi	r25, 0x0D	; 13
    5ad4:	45 c0       	rjmp	.+138    	; 0x5b60 <_hStickCentering+0x2f2>
		}
		else
		{
			if ((RX_MAX_raw[ActiveRXIndex][i]< RX_MIN_raw[ActiveRXIndex][i]) || (RX_MIN_raw[ActiveRXIndex][i]==0))  // RX_MIN_raw[i]=0 if the Remote is OFF when entering the test
    5ad6:	20 91 ca 05 	lds	r18, 0x05CA
    5ada:	80 91 ca 05 	lds	r24, 0x05CA
    5ade:	30 e0       	ldi	r19, 0x00	; 0
    5ae0:	d9 01       	movw	r26, r18
    5ae2:	aa 0f       	add	r26, r26
    5ae4:	bb 1f       	adc	r27, r27
    5ae6:	aa 0f       	add	r26, r26
    5ae8:	bb 1f       	adc	r27, r27
    5aea:	a2 0f       	add	r26, r18
    5aec:	b3 1f       	adc	r27, r19
    5aee:	ac 0f       	add	r26, r28
    5af0:	bd 1f       	adc	r27, r29
    5af2:	aa 0f       	add	r26, r26
    5af4:	bb 1f       	adc	r27, r27
    5af6:	af 5d       	subi	r26, 0xDF	; 223
    5af8:	b9 4f       	sbci	r27, 0xF9	; 249
    5afa:	90 e0       	ldi	r25, 0x00	; 0
    5afc:	fc 01       	movw	r30, r24
    5afe:	ee 0f       	add	r30, r30
    5b00:	ff 1f       	adc	r31, r31
    5b02:	ee 0f       	add	r30, r30
    5b04:	ff 1f       	adc	r31, r31
    5b06:	e8 0f       	add	r30, r24
    5b08:	f9 1f       	adc	r31, r25
    5b0a:	ec 0f       	add	r30, r28
    5b0c:	fd 1f       	adc	r31, r29
    5b0e:	ee 0f       	add	r30, r30
    5b10:	ff 1f       	adc	r31, r31
    5b12:	ee 53       	subi	r30, 0x3E	; 62
    5b14:	f9 4f       	sbci	r31, 0xF9	; 249
    5b16:	2d 91       	ld	r18, X+
    5b18:	3c 91       	ld	r19, X
    5b1a:	11 97       	sbiw	r26, 0x01	; 1
    5b1c:	80 81       	ld	r24, Z
    5b1e:	91 81       	ldd	r25, Z+1	; 0x01
    5b20:	28 17       	cp	r18, r24
    5b22:	39 07       	cpc	r19, r25
    5b24:	a0 f0       	brcs	.+40     	; 0x5b4e <_hStickCentering+0x2e0>
    5b26:	80 91 ca 05 	lds	r24, 0x05CA
    5b2a:	90 e0       	ldi	r25, 0x00	; 0
    5b2c:	fc 01       	movw	r30, r24
    5b2e:	ee 0f       	add	r30, r30
    5b30:	ff 1f       	adc	r31, r31
    5b32:	ee 0f       	add	r30, r30
    5b34:	ff 1f       	adc	r31, r31
    5b36:	e8 0f       	add	r30, r24
    5b38:	f9 1f       	adc	r31, r25
    5b3a:	ec 0f       	add	r30, r28
    5b3c:	fd 1f       	adc	r31, r29
    5b3e:	ee 0f       	add	r30, r30
    5b40:	ff 1f       	adc	r31, r31
    5b42:	ee 53       	subi	r30, 0x3E	; 62
    5b44:	f9 4f       	sbci	r31, 0xF9	; 249
    5b46:	80 81       	ld	r24, Z
    5b48:	91 81       	ldd	r25, Z+1	; 0x01
    5b4a:	00 97       	sbiw	r24, 0x00	; 0
    5b4c:	39 f4       	brne	.+14     	; 0x5b5c <_hStickCentering+0x2ee>
			{
				LCD_WriteString_P(strErr);	
    5b4e:	82 e2       	ldi	r24, 0x22	; 34
    5b50:	9d e0       	ldi	r25, 0x0D	; 13
    5b52:	0e 94 1c 0d 	call	0x1a38	; 0x1a38 <LCD_WriteString_P>
				bError = TRUE;
    5b56:	10 93 46 08 	sts	0x0846, r17
    5b5a:	04 c0       	rjmp	.+8      	; 0x5b64 <_hStickCentering+0x2f6>
			}
			else
			{
				LCD_WriteString_P(strSPC4);	
    5b5c:	86 e2       	ldi	r24, 0x26	; 38
    5b5e:	9d e0       	ldi	r25, 0x0D	; 13
    5b60:	0e 94 1c 0d 	call	0x1a38	; 0x1a38 <LCD_WriteString_P>
    5b64:	21 96       	adiw	r28, 0x01	; 1
		RX_StickCenterCalibrationInit(ActiveRXIndex);				
	}
	
	bError = false;
	RX_StickCenterCalibration(ActiveRXIndex);
	for (uint8_t i = 0; i < RXChannels; i++)
    5b66:	c5 30       	cpi	r28, 0x05	; 5
    5b68:	d1 05       	cpc	r29, r1
    5b6a:	09 f0       	breq	.+2      	; 0x5b6e <_hStickCentering+0x300>
    5b6c:	6a cf       	rjmp	.-300    	; 0x5a42 <_hStickCentering+0x1d4>
			}
		}	
	}
	

	_helper_DisplayRXStatus(6);
    5b6e:	86 e0       	ldi	r24, 0x06	; 6
    5b70:	0e 94 fe 2b 	call	0x57fc	; 0x57fc <_helper_DisplayRXStatus>
}
    5b74:	df 91       	pop	r29
    5b76:	cf 91       	pop	r28
    5b78:	1f 91       	pop	r17
    5b7a:	0f 91       	pop	r16
    5b7c:	08 95       	ret

00005b7e <_hReceiverTest>:
	//LCD_SetPos(6, 48);
	//LCD_WriteValue_double(6,48,Sensor_GetBattery(),false);
}

void _hReceiverTest()
{
    5b7e:	0f 93       	push	r16
    5b80:	1f 93       	push	r17
    5b82:	cf 93       	push	r28
    5b84:	df 93       	push	r29
	UIEnableStickCommands=false; // you cannot use sticks here. for arming or as buttons.
    5b86:	10 92 e5 05 	sts	0x05E5, r1
	
	RX_CopyLatestReceiverValues();
    5b8a:	0e 94 cc 26 	call	0x4d98	; 0x4d98 <RX_CopyLatestReceiverValues>
    5b8e:	c0 e0       	ldi	r28, 0x00	; 0
    5b90:	d0 e0       	ldi	r29, 0x00	; 0
    5b92:	ce 01       	movw	r24, r28
    5b94:	8f 5f       	subi	r24, 0xFF	; 255
    5b96:	18 2f       	mov	r17, r24
		
		
	for (uint8_t i = 0; i < RXChannels; i++)
	{
		LCD_SetPos(i+1, 24);
    5b98:	68 e1       	ldi	r22, 0x18	; 24
    5b9a:	0e 94 1f 0c 	call	0x183e	; 0x183e <LCD_SetPos>
			
		//itoa(RX_Latest[ActiveRXIndex][i], sXDeg, 10);
		LCD_WriteValue(i+1,36,RX_Latest[0][i],5,(!IS_TX1_GOOD));
    5b9e:	fe 01       	movw	r30, r28
    5ba0:	ee 0f       	add	r30, r30
    5ba2:	ff 1f       	adc	r31, r31
    5ba4:	ee 5f       	subi	r30, 0xFE	; 254
    5ba6:	f9 4f       	sbci	r31, 0xF9	; 249
    5ba8:	40 81       	ld	r20, Z
    5baa:	51 81       	ldd	r21, Z+1	; 0x01
    5bac:	80 91 fb 07 	lds	r24, 0x07FB
    5bb0:	90 e0       	ldi	r25, 0x00	; 0
    5bb2:	8f 70       	andi	r24, 0x0F	; 15
    5bb4:	90 70       	andi	r25, 0x00	; 0
    5bb6:	01 e0       	ldi	r16, 0x01	; 1
    5bb8:	00 97       	sbiw	r24, 0x00	; 0
    5bba:	09 f4       	brne	.+2      	; 0x5bbe <_hReceiverTest+0x40>
    5bbc:	00 e0       	ldi	r16, 0x00	; 0
    5bbe:	81 2f       	mov	r24, r17
    5bc0:	64 e2       	ldi	r22, 0x24	; 36
    5bc2:	25 e0       	ldi	r18, 0x05	; 5
    5bc4:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <LCD_WriteValue>
		LCD_WriteValue(i+1,84,RX_Latest[1][i],5,(!IS_TX2_GOOD));
    5bc8:	fe 01       	movw	r30, r28
    5bca:	ee 0f       	add	r30, r30
    5bcc:	ff 1f       	adc	r31, r31
    5bce:	e4 5f       	subi	r30, 0xF4	; 244
    5bd0:	f9 4f       	sbci	r31, 0xF9	; 249
    5bd2:	40 81       	ld	r20, Z
    5bd4:	51 81       	ldd	r21, Z+1	; 0x01
    5bd6:	80 91 fb 07 	lds	r24, 0x07FB
    5bda:	80 7f       	andi	r24, 0xF0	; 240
    5bdc:	01 e0       	ldi	r16, 0x01	; 1
    5bde:	09 f4       	brne	.+2      	; 0x5be2 <_hReceiverTest+0x64>
    5be0:	00 e0       	ldi	r16, 0x00	; 0
    5be2:	81 2f       	mov	r24, r17
    5be4:	64 e5       	ldi	r22, 0x54	; 84
    5be6:	25 e0       	ldi	r18, 0x05	; 5
    5be8:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <LCD_WriteValue>
    5bec:	21 96       	adiw	r28, 0x01	; 1
	UIEnableStickCommands=false; // you cannot use sticks here. for arming or as buttons.
	
	RX_CopyLatestReceiverValues();
		
		
	for (uint8_t i = 0; i < RXChannels; i++)
    5bee:	c5 30       	cpi	r28, 0x05	; 5
    5bf0:	d1 05       	cpc	r29, r1
    5bf2:	79 f6       	brne	.-98     	; 0x5b92 <_hReceiverTest+0x14>
		LCD_WriteValue(i+1,84,RX_Latest[1][i],5,(!IS_TX2_GOOD));
		
	}			
	
	
	_helper_DisplayRXStatus(6);
    5bf4:	86 e0       	ldi	r24, 0x06	; 6
    5bf6:	0e 94 fe 2b 	call	0x57fc	; 0x57fc <_helper_DisplayRXStatus>
	
}
    5bfa:	df 91       	pop	r29
    5bfc:	cf 91       	pop	r28
    5bfe:	1f 91       	pop	r17
    5c00:	0f 91       	pop	r16
    5c02:	08 95       	ret

00005c04 <_helper_Words>:
	
}


void _helper_Words (const int8_t row, const int8_t col,  const BOOL LCDReverse, const bool Condition, PGM_P TrueString, PGM_P FalseString, int8_t Len)
{
    5c04:	cf 92       	push	r12
    5c06:	ef 92       	push	r14
    5c08:	ff 92       	push	r15
    5c0a:	0f 93       	push	r16
    5c0c:	1f 93       	push	r17
    5c0e:	94 2f       	mov	r25, r20
    5c10:	32 2f       	mov	r19, r18
    5c12:	2c 2d       	mov	r18, r12
	if (Condition== TRUE)
    5c14:	33 23       	and	r19, r19
    5c16:	11 f0       	breq	.+4      	; 0x5c1c <_helper_Words+0x18>
	{
		LCD_WriteString_Pex(row,col,TrueString,Len,LCDReverse);
    5c18:	a8 01       	movw	r20, r16
    5c1a:	01 c0       	rjmp	.+2      	; 0x5c1e <_helper_Words+0x1a>
	}
	else
	{
		LCD_WriteString_Pex(row,col,FalseString,Len,LCDReverse);
    5c1c:	a7 01       	movw	r20, r14
    5c1e:	09 2f       	mov	r16, r25
    5c20:	0e 94 a4 0d 	call	0x1b48	; 0x1b48 <LCD_WriteString_Pex>
	}
}
    5c24:	1f 91       	pop	r17
    5c26:	0f 91       	pop	r16
    5c28:	ff 90       	pop	r15
    5c2a:	ef 90       	pop	r14
    5c2c:	cf 90       	pop	r12
    5c2e:	08 95       	ret

00005c30 <Menu_LoadPage>:

/*
//	Put screen into CurrentPage ==> MemoryScreen
*/
void Menu_LoadPage(const uint8_t pageIndex)
{
    5c30:	1f 93       	push	r17
    5c32:	18 2f       	mov	r17, r24
	memcpy_P(&currentPage, &pages[pageIndex], sizeof(currentPage));
    5c34:	66 e0       	ldi	r22, 0x06	; 6
    5c36:	86 9f       	mul	r24, r22
    5c38:	b0 01       	movw	r22, r0
    5c3a:	11 24       	eor	r1, r1
    5c3c:	67 57       	subi	r22, 0x77	; 119
    5c3e:	72 4f       	sbci	r23, 0xF2	; 242
    5c40:	82 e4       	ldi	r24, 0x42	; 66
    5c42:	95 e0       	ldi	r25, 0x05	; 5
    5c44:	46 e0       	ldi	r20, 0x06	; 6
    5c46:	50 e0       	ldi	r21, 0x00	; 0
    5c48:	0e 94 81 3a 	call	0x7502	; 0x7502 <memcpy_P>
	page = pageIndex;
    5c4c:	10 93 3b 05 	sts	0x053B, r17
}
    5c50:	1f 91       	pop	r17
    5c52:	08 95       	ret

00005c54 <_hFactoryReset>:
		//LCD_WriteValue(4,48, MotorOut[3],9,false);
	}
}
void _hFactoryReset()
{
	if (IS_INIT)
    5c54:	80 91 ba 05 	lds	r24, 0x05BA
    5c58:	80 ff       	sbrs	r24, 0
    5c5a:	05 c0       	rjmp	.+10     	; 0x5c66 <_hFactoryReset+0x12>
	{
		;
		LCD_WriteString_P(strAreYouSure);
    5c5c:	8b e1       	ldi	r24, 0x1B	; 27
    5c5e:	9c e0       	ldi	r25, 0x0C	; 12
    5c60:	0e 94 1c 0d 	call	0x1a38	; 0x1a38 <LCD_WriteString_P>
    5c64:	08 95       	ret
	}
	else if (KEY4)	// Yes
    5c66:	84 ff       	sbrs	r24, 4
    5c68:	05 c0       	rjmp	.+10     	; 0x5c74 <_hFactoryReset+0x20>
	{
		Save_Default_Config_to_EEPROM();
    5c6a:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <Save_Default_Config_to_EEPROM>
		//RST_CTRL
		Menu_LoadPage(PAGE_RESTART);
    5c6e:	84 e0       	ldi	r24, 0x04	; 4
    5c70:	0e 94 18 2e 	call	0x5c30	; 0x5c30 <Menu_LoadPage>
    5c74:	08 95       	ret

00005c76 <_hESCCalibration>:
	
}

void _hESCCalibration()
{
	NOKEYRETURN
    5c76:	80 91 ba 05 	lds	r24, 0x05BA
    5c7a:	88 23       	and	r24, r24
    5c7c:	c1 f0       	breq	.+48     	; 0x5cae <_hESCCalibration+0x38>
	
	if (KEY4)
    5c7e:	84 ff       	sbrs	r24, 4
    5c80:	16 c0       	rjmp	.+44     	; 0x5cae <_hESCCalibration+0x38>
	{
		if ((Config.IsCalibrated & CALIBRATED_SENSOR) && ((Config.IsCalibrated & CALIBRATED_Stick_SECONDARY)==CALIBRATED_Stick_SECONDARY))
    5c82:	80 91 ea 06 	lds	r24, 0x06EA
		LCD_WriteValue_double_ex(i,48,Config.Sensor_zero[i],9,false);
	}	
	
}

void _hESCCalibration()
    5c86:	86 70       	andi	r24, 0x06	; 6
{
	NOKEYRETURN
	
	if (KEY4)
	{
		if ((Config.IsCalibrated & CALIBRATED_SENSOR) && ((Config.IsCalibrated & CALIBRATED_Stick_SECONDARY)==CALIBRATED_Stick_SECONDARY))
    5c88:	86 30       	cpi	r24, 0x06	; 6
    5c8a:	61 f4       	brne	.+24     	; 0x5ca4 <_hESCCalibration+0x2e>
		{
			SystemActions = SYS_ACT_DISARM;
    5c8c:	82 e0       	ldi	r24, 0x02	; 2
    5c8e:	80 93 4d 05 	sts	0x054D, r24
			Config.IsESCCalibration=ESCCalibration_ON;
    5c92:	81 e0       	ldi	r24, 0x01	; 1
    5c94:	80 93 ef 06 	sts	0x06EF, r24
			Save_Config_to_EEPROM();
    5c98:	0e 94 df 0f 	call	0x1fbe	; 0x1fbe <Save_Config_to_EEPROM>
			Menu_LoadPage(PAGE_RESTART);
    5c9c:	84 e0       	ldi	r24, 0x04	; 4
    5c9e:	0e 94 18 2e 	call	0x5c30	; 0x5c30 <Menu_LoadPage>
			return;
    5ca2:	08 95       	ret
		}
		else
		{ //...flash as error
			LED_FlashOrangeLED(LED_SHORT_TOGGLE,2);
    5ca4:	8e e1       	ldi	r24, 0x1E	; 30
    5ca6:	90 e0       	ldi	r25, 0x00	; 0
    5ca8:	62 e0       	ldi	r22, 0x02	; 2
    5caa:	0e 94 aa 0e 	call	0x1d54	; 0x1d54 <LED_FlashOrangeLED>
    5cae:	08 95       	ret

00005cb0 <_hHomeArmed>:
}

void _hHomeArmed()
{
	
	if (IS_INIT)	
    5cb0:	80 91 ba 05 	lds	r24, 0x05BA
    5cb4:	80 ff       	sbrs	r24, 0
    5cb6:	10 c0       	rjmp	.+32     	; 0x5cd8 <_hHomeArmed+0x28>
	{
		LCD_SelectFont (&font12x16);
    5cb8:	87 e7       	ldi	r24, 0x77	; 119
    5cba:	91 e0       	ldi	r25, 0x01	; 1
    5cbc:	0e 94 73 0e 	call	0x1ce6	; 0x1ce6 <LCD_SelectFont>
		LCD_SetPos(0,0);
    5cc0:	80 e0       	ldi	r24, 0x00	; 0
    5cc2:	60 e0       	ldi	r22, 0x00	; 0
    5cc4:	0e 94 1f 0c 	call	0x183e	; 0x183e <LCD_SetPos>
		LCD_WriteString_P(strARMED);
    5cc8:	8e e2       	ldi	r24, 0x2E	; 46
    5cca:	9d e0       	ldi	r25, 0x0D	; 13
    5ccc:	0e 94 1c 0d 	call	0x1a38	; 0x1a38 <LCD_WriteString_P>
		LCD_SelectFont (NULL);
    5cd0:	80 e0       	ldi	r24, 0x00	; 0
    5cd2:	90 e0       	ldi	r25, 0x00	; 0
    5cd4:	0e 94 73 0e 	call	0x1ce6	; 0x1ce6 <LCD_SelectFont>
	}
	
	
	if (KEY4)	// MENU
    5cd8:	80 91 ba 05 	lds	r24, 0x05BA
    5cdc:	84 ff       	sbrs	r24, 4
    5cde:	03 c0       	rjmp	.+6      	; 0x5ce6 <_hHomeArmed+0x36>
	{
		Menu_LoadPage(PAGE_MENU);
    5ce0:	81 e0       	ldi	r24, 0x01	; 1
    5ce2:	0e 94 18 2e 	call	0x5c30	; 0x5c30 <Menu_LoadPage>
    5ce6:	08 95       	ret

00005ce8 <_hHomePage>:
}



void _hHomePage()
{
    5ce8:	cf 92       	push	r12
    5cea:	ef 92       	push	r14
    5cec:	ff 92       	push	r15
    5cee:	0f 93       	push	r16
    5cf0:	1f 93       	push	r17
	
	if (IS_INIT)
    5cf2:	80 91 ba 05 	lds	r24, 0x05BA
    5cf6:	80 ff       	sbrs	r24, 0
    5cf8:	31 c0       	rjmp	.+98     	; 0x5d5c <_hHomePage+0x74>
	{
		// Version
		LCD_SetPos(0,0);
    5cfa:	80 e0       	ldi	r24, 0x00	; 0
    5cfc:	60 e0       	ldi	r22, 0x00	; 0
    5cfe:	0e 94 1f 0c 	call	0x183e	; 0x183e <LCD_SetPos>
		LCD_WriteString_P(strVersionInfo);
    5d02:	84 e3       	ldi	r24, 0x34	; 52
    5d04:	9d e0       	ldi	r25, 0x0D	; 13
    5d06:	0e 94 1c 0d 	call	0x1a38	; 0x1a38 <LCD_WriteString_P>
		// Sensors
		_helper_DisplayBiStateText(5, 60, strOK, strErr, (Config.IsCalibrated & CALIBRATED_SENSOR),false);
    5d0a:	80 91 ea 06 	lds	r24, 0x06EA
    5d0e:	01 e0       	ldi	r16, 0x01	; 1
    5d10:	82 ff       	sbrs	r24, 2
    5d12:	00 e0       	ldi	r16, 0x00	; 0
    5d14:	85 e0       	ldi	r24, 0x05	; 5
    5d16:	6c e3       	ldi	r22, 0x3C	; 60
    5d18:	48 e4       	ldi	r20, 0x48	; 72
    5d1a:	5d e0       	ldi	r21, 0x0D	; 13
    5d1c:	22 e2       	ldi	r18, 0x22	; 34
    5d1e:	3d e0       	ldi	r19, 0x0D	; 13
    5d20:	ee 24       	eor	r14, r14
    5d22:	0e 94 c9 2b 	call	0x5792	; 0x5792 <_helper_DisplayBiStateText>
		
		//Stick Centering & Calibration
		_helper_DisplayBiStateText(5, 102, str1, strX, (Config.IsCalibrated & CALIBRATED_Stick_PRIMARY),false);
    5d26:	00 91 ea 06 	lds	r16, 0x06EA
    5d2a:	10 e0       	ldi	r17, 0x00	; 0
    5d2c:	01 70       	andi	r16, 0x01	; 1
    5d2e:	10 70       	andi	r17, 0x00	; 0
    5d30:	85 e0       	ldi	r24, 0x05	; 5
    5d32:	66 e6       	ldi	r22, 0x66	; 102
    5d34:	4c e4       	ldi	r20, 0x4C	; 76
    5d36:	5d e0       	ldi	r21, 0x0D	; 13
    5d38:	2e e4       	ldi	r18, 0x4E	; 78
    5d3a:	3d e0       	ldi	r19, 0x0D	; 13
    5d3c:	0e 94 c9 2b 	call	0x5792	; 0x5792 <_helper_DisplayBiStateText>
		
		_helper_DisplayBiStateText(5, 114, str2, strX, (Config.IsCalibrated & CALIBRATED_Stick_SECONDARY),false);
    5d40:	80 91 ea 06 	lds	r24, 0x06EA
    5d44:	01 e0       	ldi	r16, 0x01	; 1
    5d46:	81 ff       	sbrs	r24, 1
    5d48:	00 e0       	ldi	r16, 0x00	; 0
    5d4a:	85 e0       	ldi	r24, 0x05	; 5
    5d4c:	62 e7       	ldi	r22, 0x72	; 114
    5d4e:	40 e5       	ldi	r20, 0x50	; 80
    5d50:	5d e0       	ldi	r21, 0x0D	; 13
    5d52:	2e e4       	ldi	r18, 0x4E	; 78
    5d54:	3d e0       	ldi	r19, 0x0D	; 13
    5d56:	ee 24       	eor	r14, r14
    5d58:	0e 94 c9 2b 	call	0x5792	; 0x5792 <_helper_DisplayBiStateText>
		
		
	}
	
	if (KEY4)	// MENU
    5d5c:	80 91 ba 05 	lds	r24, 0x05BA
    5d60:	84 ff       	sbrs	r24, 4
    5d62:	04 c0       	rjmp	.+8      	; 0x5d6c <_hHomePage+0x84>
	{
		Menu_LoadPage(PAGE_MENU);
    5d64:	81 e0       	ldi	r24, 0x01	; 1
    5d66:	0e 94 18 2e 	call	0x5c30	; 0x5c30 <Menu_LoadPage>
		return;
    5d6a:	94 c0       	rjmp	.+296    	; 0x5e94 <_hHomePage+0x1ac>
	}
	
	// Write Voltage
	//LCD_SetPos(2, 30);
	double volt = (double)(Sensor_GetBattery()/10.0f);
    5d6c:	0e 94 03 29 	call	0x5206	; 0x5206 <Sensor_GetBattery>
    5d70:	9c 01       	movw	r18, r24
    5d72:	b9 01       	movw	r22, r18
    5d74:	88 27       	eor	r24, r24
    5d76:	77 fd       	sbrc	r23, 7
    5d78:	80 95       	com	r24
    5d7a:	98 2f       	mov	r25, r24
    5d7c:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    5d80:	20 e0       	ldi	r18, 0x00	; 0
    5d82:	30 e0       	ldi	r19, 0x00	; 0
    5d84:	40 e2       	ldi	r20, 0x20	; 32
    5d86:	51 e4       	ldi	r21, 0x41	; 65
    5d88:	0e 94 fa 37 	call	0x6ff4	; 0x6ff4 <__divsf3>
    5d8c:	9b 01       	movw	r18, r22
    5d8e:	ac 01       	movw	r20, r24
	LCD_WriteValue_double_ex(2,36,volt,8,IS_SYS_ERR_VOLTAGE); // FIX: 8 to display 2 digits volt besides floating point
    5d90:	90 91 d7 06 	lds	r25, 0x06D7
    5d94:	92 70       	andi	r25, 0x02	; 2
    5d96:	82 e0       	ldi	r24, 0x02	; 2
    5d98:	64 e2       	ldi	r22, 0x24	; 36
    5d9a:	08 e0       	ldi	r16, 0x08	; 8
    5d9c:	e9 2e       	mov	r14, r25
    5d9e:	0e 94 c9 0d 	call	0x1b92	; 0x1b92 <LCD_WriteValue_double_ex>
	//LCD_WriteValue(2,36,Sensor_GetBattery(),4,IS_SYS_ERR_VOLTAGE);
	LCD_SetPos (3,6);
    5da2:	83 e0       	ldi	r24, 0x03	; 3
    5da4:	66 e0       	ldi	r22, 0x06	; 6
    5da6:	0e 94 1f 0c 	call	0x183e	; 0x183e <LCD_SetPos>
	if (nFlyingModes == FLYINGMODE_ACRO)
    5daa:	80 91 1a 06 	lds	r24, 0x061A
    5dae:	81 30       	cpi	r24, 0x01	; 1
    5db0:	19 f4       	brne	.+6      	; 0x5db8 <_hHomePage+0xd0>
	{
		LCD_WriteString_P(PSTR("ACRO  "));
    5db2:	82 e8       	ldi	r24, 0x82	; 130
    5db4:	9d e0       	ldi	r25, 0x0D	; 13
    5db6:	09 c0       	rjmp	.+18     	; 0x5dca <_hHomePage+0xe2>
	}
	else if (nFlyingModes == FLYINGMODE_LEVEL)
    5db8:	82 30       	cpi	r24, 0x02	; 2
    5dba:	19 f4       	brne	.+6      	; 0x5dc2 <_hHomePage+0xda>
	{
		LCD_WriteString_P(PSTR("STABLE"));
    5dbc:	8b e7       	ldi	r24, 0x7B	; 123
    5dbe:	9d e0       	ldi	r25, 0x0D	; 13
    5dc0:	04 c0       	rjmp	.+8      	; 0x5dca <_hHomePage+0xe2>
	}
	else if (nFlyingModes == FLYINGMODE_ALTHOLD)
    5dc2:	84 30       	cpi	r24, 0x04	; 4
    5dc4:	21 f4       	brne	.+8      	; 0x5dce <_hHomePage+0xe6>
	{
		LCD_WriteString_P(PSTR("ALTHLD"));
    5dc6:	84 e7       	ldi	r24, 0x74	; 116
    5dc8:	9d e0       	ldi	r25, 0x0D	; 13
    5dca:	0e 94 1c 0d 	call	0x1a38	; 0x1a38 <LCD_WriteString_P>
	}
	
	_helper_Words (3,48,  0,(Config.FrameType== FRAMETYPE_QUADCOPTER),PSTR("Quad"),PSTR("TRI "),5);
    5dce:	21 e0       	ldi	r18, 0x01	; 1
    5dd0:	80 91 f0 06 	lds	r24, 0x06F0
    5dd4:	81 30       	cpi	r24, 0x01	; 1
    5dd6:	09 f0       	breq	.+2      	; 0x5dda <_hHomePage+0xf2>
    5dd8:	20 e0       	ldi	r18, 0x00	; 0
    5dda:	83 e0       	ldi	r24, 0x03	; 3
    5ddc:	60 e3       	ldi	r22, 0x30	; 48
    5dde:	40 e0       	ldi	r20, 0x00	; 0
    5de0:	0f e6       	ldi	r16, 0x6F	; 111
    5de2:	1d e0       	ldi	r17, 0x0D	; 13
    5de4:	ba e6       	ldi	r27, 0x6A	; 106
    5de6:	eb 2e       	mov	r14, r27
    5de8:	bd e0       	ldi	r27, 0x0D	; 13
    5dea:	fb 2e       	mov	r15, r27
    5dec:	a5 e0       	ldi	r26, 0x05	; 5
    5dee:	ca 2e       	mov	r12, r26
    5df0:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <_helper_Words>
	_helper_Words (3,84,0,(Config.RX_mode == RX_mode_BuddyMode),PSTR("Buddy"),PSTR("UART "),5);
    5df4:	21 e0       	ldi	r18, 0x01	; 1
    5df6:	80 91 eb 06 	lds	r24, 0x06EB
    5dfa:	81 11       	cpse	r24, r1
    5dfc:	20 e0       	ldi	r18, 0x00	; 0
    5dfe:	83 e0       	ldi	r24, 0x03	; 3
    5e00:	64 e5       	ldi	r22, 0x54	; 84
    5e02:	40 e0       	ldi	r20, 0x00	; 0
    5e04:	04 e6       	ldi	r16, 0x64	; 100
    5e06:	1d e0       	ldi	r17, 0x0D	; 13
    5e08:	fe e5       	ldi	r31, 0x5E	; 94
    5e0a:	ef 2e       	mov	r14, r31
    5e0c:	fd e0       	ldi	r31, 0x0D	; 13
    5e0e:	ff 2e       	mov	r15, r31
    5e10:	e5 e0       	ldi	r30, 0x05	; 5
    5e12:	ce 2e       	mov	r12, r30
    5e14:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <_helper_Words>
	
	_helper_DisplayRXStatus(5);
    5e18:	85 e0       	ldi	r24, 0x05	; 5
    5e1a:	0e 94 fe 2b 	call	0x57fc	; 0x57fc <_helper_DisplayRXStatus>
	
		
	///////// Flying Mode
	LCD_SetPos (6,24);
    5e1e:	86 e0       	ldi	r24, 0x06	; 6
    5e20:	68 e1       	ldi	r22, 0x18	; 24
    5e22:	0e 94 1f 0c 	call	0x183e	; 0x183e <LCD_SetPos>
	LCD_SelectFont (&font12x16);
    5e26:	87 e7       	ldi	r24, 0x77	; 119
    5e28:	91 e0       	ldi	r25, 0x01	; 1
    5e2a:	0e 94 73 0e 	call	0x1ce6	; 0x1ce6 <LCD_SelectFont>
	
	if (Config.QuadFlyingMode==QuadFlyingMode_X)
    5e2e:	80 91 f2 06 	lds	r24, 0x06F2
    5e32:	81 30       	cpi	r24, 0x01	; 1
    5e34:	51 f4       	brne	.+20     	; 0x5e4a <_hHomePage+0x162>
	{
		if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    5e36:	80 91 f0 06 	lds	r24, 0x06F0
    5e3a:	81 30       	cpi	r24, 0x01	; 1
    5e3c:	19 f4       	brne	.+6      	; 0x5e44 <_hHomePage+0x15c>
		{
			LCD_WriteString_P(PSTR ("X"));
    5e3e:	8c e5       	ldi	r24, 0x5C	; 92
    5e40:	9d e0       	ldi	r25, 0x0D	; 13
    5e42:	0c c0       	rjmp	.+24     	; 0x5e5c <_hHomePage+0x174>
		}
		else
		{
			LCD_WriteString_P(PSTR ("A"));
    5e44:	8a e5       	ldi	r24, 0x5A	; 90
    5e46:	9d e0       	ldi	r25, 0x0D	; 13
    5e48:	09 c0       	rjmp	.+18     	; 0x5e5c <_hHomePage+0x174>
		}			
	}
	else
	{
		if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    5e4a:	80 91 f0 06 	lds	r24, 0x06F0
    5e4e:	81 30       	cpi	r24, 0x01	; 1
    5e50:	19 f4       	brne	.+6      	; 0x5e58 <_hHomePage+0x170>
		{
			LCD_WriteString_P(PSTR ("+"));
    5e52:	88 e5       	ldi	r24, 0x58	; 88
    5e54:	9d e0       	ldi	r25, 0x0D	; 13
    5e56:	02 c0       	rjmp	.+4      	; 0x5e5c <_hHomePage+0x174>
		}
		else
		{
			LCD_WriteString_P(PSTR ("Y"));
    5e58:	86 e5       	ldi	r24, 0x56	; 86
    5e5a:	9d e0       	ldi	r25, 0x0D	; 13
    5e5c:	0e 94 1c 0d 	call	0x1a38	; 0x1a38 <LCD_WriteString_P>
		}			
	}
	
	LCD_SetPos (6,80);
    5e60:	86 e0       	ldi	r24, 0x06	; 6
    5e62:	60 e5       	ldi	r22, 0x50	; 80
    5e64:	0e 94 1f 0c 	call	0x183e	; 0x183e <LCD_SetPos>
	LCD_SelectFont (&font12x16);
    5e68:	87 e7       	ldi	r24, 0x77	; 119
    5e6a:	91 e0       	ldi	r25, 0x01	; 1
    5e6c:	0e 94 73 0e 	call	0x1ce6	; 0x1ce6 <LCD_SelectFont>
	if (Config.BoardOrientationMode==QuadFlyingMode_X)
    5e70:	80 91 f1 06 	lds	r24, 0x06F1
    5e74:	81 30       	cpi	r24, 0x01	; 1
    5e76:	19 f4       	brne	.+6      	; 0x5e7e <_hHomePage+0x196>
	{
		LCD_WriteString_P(PSTR ("X"));
    5e78:	84 e5       	ldi	r24, 0x54	; 84
    5e7a:	9d e0       	ldi	r25, 0x0D	; 13
    5e7c:	02 c0       	rjmp	.+4      	; 0x5e82 <_hHomePage+0x19a>
	}
	else
	{
		LCD_WriteString_P(PSTR ("+"));
    5e7e:	82 e5       	ldi	r24, 0x52	; 82
    5e80:	9d e0       	ldi	r25, 0x0D	; 13
    5e82:	0e 94 1c 0d 	call	0x1a38	; 0x1a38 <LCD_WriteString_P>
	}
	LCD_SelectFont (NULL);
    5e86:	80 e0       	ldi	r24, 0x00	; 0
    5e88:	90 e0       	ldi	r25, 0x00	; 0
    5e8a:	0e 94 73 0e 	call	0x1ce6	; 0x1ce6 <LCD_SelectFont>
	///////
	UIEnableStickCommands=true;
    5e8e:	81 e0       	ldi	r24, 0x01	; 1
    5e90:	80 93 e5 05 	sts	0x05E5, r24
	
}
    5e94:	1f 91       	pop	r17
    5e96:	0f 91       	pop	r16
    5e98:	ff 90       	pop	r15
    5e9a:	ef 90       	pop	r14
    5e9c:	cf 90       	pop	r12
    5e9e:	08 95       	ret

00005ea0 <defaultHandler>:


void defaultHandler()
{
	
	if (editMode==true)
    5ea0:	80 91 f8 07 	lds	r24, 0x07F8
    5ea4:	81 30       	cpi	r24, 0x01	; 1
    5ea6:	19 f4       	brne	.+6      	; 0x5eae <defaultHandler+0xe>
	{		// edit mode?
		editModeHandler();
    5ea8:	0e 94 76 2f 	call	0x5eec	; 0x5eec <editModeHandler>
    5eac:	08 95       	ret
	}
	else
	{
		if (IS_INIT | IS_KEYREFRESH) 
    5eae:	80 91 ba 05 	lds	r24, 0x05BA
    5eb2:	90 e0       	ldi	r25, 0x00	; 0
    5eb4:	83 70       	andi	r24, 0x03	; 3
    5eb6:	90 70       	andi	r25, 0x00	; 0
    5eb8:	00 97       	sbiw	r24, 0x00	; 0
    5eba:	81 f0       	breq	.+32     	; 0x5edc <defaultHandler+0x3c>
		{
			LCD_Clear();
    5ebc:	0e 94 57 0c 	call	0x18ae	; 0x18ae <LCD_Clear>
			// 1- display screen content
			if (currentPage.screen)
    5ec0:	80 91 46 05 	lds	r24, 0x0546
    5ec4:	90 91 47 05 	lds	r25, 0x0547
    5ec8:	00 97       	sbiw	r24, 0x00	; 0
    5eca:	11 f0       	breq	.+4      	; 0x5ed0 <defaultHandler+0x30>
				LCD_WriteString_P(currentPage.screen);
    5ecc:	0e 94 1c 0d 	call	0x1a38	; 0x1a38 <LCD_WriteString_P>
			// 2- Display control buttons... always be last to overwrite any graphics on it.
			writeSoftkeys(currentPage.softkeys);
    5ed0:	80 91 42 05 	lds	r24, 0x0542
    5ed4:	90 91 43 05 	lds	r25, 0x0543
    5ed8:	0e 94 19 2a 	call	0x5432	; 0x5432 <writeSoftkeys>
			//LCD_SetPos(0, 0);
		}
		
		if (currentPage.handler)
    5edc:	e0 91 44 05 	lds	r30, 0x0544
    5ee0:	f0 91 45 05 	lds	r31, 0x0545
    5ee4:	30 97       	sbiw	r30, 0x00	; 0
    5ee6:	09 f0       	breq	.+2      	; 0x5eea <defaultHandler+0x4a>
		{
			currentPage.handler();
    5ee8:	09 95       	icall
    5eea:	08 95       	ret

00005eec <editModeHandler>:
		subpage = (subpage + 1) % num;
}


void editModeHandler()
{
    5eec:	0f 93       	push	r16
	if (KEY4)	// DONE;
    5eee:	80 91 ba 05 	lds	r24, 0x05BA
    5ef2:	84 ff       	sbrs	r24, 4
    5ef4:	23 c0       	rjmp	.+70     	; 0x5f3c <editModeHandler+0x50>
	{
		editMode = false;
    5ef6:	10 92 f8 07 	sts	0x07F8, r1
		_mykey = KEY_REFRESH;
    5efa:	82 e0       	ldi	r24, 0x02	; 2
    5efc:	80 93 ba 05 	sts	0x05BA, r24
		
		if (editValueType == TYPE_UINT8)
    5f00:	80 91 f7 07 	lds	r24, 0x07F7
    5f04:	82 30       	cpi	r24, 0x02	; 2
    5f06:	11 f0       	breq	.+4      	; 0x5f0c <editModeHandler+0x20>
			*((uint8_t*)editValuePtr) = (uint8_t) editValue;
		else if (editValueType == TYPE_INT8)
    5f08:	81 30       	cpi	r24, 0x01	; 1
    5f0a:	41 f4       	brne	.+16     	; 0x5f1c <editModeHandler+0x30>
			*((int8_t*)editValuePtr) = (int8_t) editValue;
    5f0c:	e0 91 f5 07 	lds	r30, 0x07F5
    5f10:	f0 91 f6 07 	lds	r31, 0x07F6
    5f14:	80 91 fc 07 	lds	r24, 0x07FC
    5f18:	80 83       	st	Z, r24
    5f1a:	58 c0       	rjmp	.+176    	; 0x5fcc <editModeHandler+0xe0>
		else if (editValueType == TYPE_INT16)
    5f1c:	83 30       	cpi	r24, 0x03	; 3
    5f1e:	19 f0       	breq	.+6      	; 0x5f26 <editModeHandler+0x3a>
			*(int16_t*)editValuePtr = (int16_t) editValue;
		else if (editValueType == TYPE_UINT16)
    5f20:	84 30       	cpi	r24, 0x04	; 4
    5f22:	09 f0       	breq	.+2      	; 0x5f26 <editModeHandler+0x3a>
    5f24:	53 c0       	rjmp	.+166    	; 0x5fcc <editModeHandler+0xe0>
			*(uint16_t*)editValuePtr =(uint16_t) editValue;
    5f26:	e0 91 f5 07 	lds	r30, 0x07F5
    5f2a:	f0 91 f6 07 	lds	r31, 0x07F6
    5f2e:	80 91 fc 07 	lds	r24, 0x07FC
    5f32:	90 91 fd 07 	lds	r25, 0x07FD
    5f36:	91 83       	std	Z+1, r25	; 0x01
    5f38:	80 83       	st	Z, r24
    5f3a:	48 c0       	rjmp	.+144    	; 0x5fcc <editModeHandler+0xe0>
		
		LCD_SelectFont(NULL);
		defaultHandler();
		return;
	}
	if (ANYKEY)
    5f3c:	88 23       	and	r24, r24
    5f3e:	09 f4       	brne	.+2      	; 0x5f42 <editModeHandler+0x56>
    5f40:	56 c0       	rjmp	.+172    	; 0x5fee <editModeHandler+0x102>
	{
		if (KEY2)	// DOWN?
    5f42:	86 ff       	sbrs	r24, 6
    5f44:	1b c0       	rjmp	.+54     	; 0x5f7c <editModeHandler+0x90>
		{
			
				if (_keyrepeat == KEYBOARD_REPEAT)
    5f46:	20 91 cb 05 	lds	r18, 0x05CB
    5f4a:	80 91 fc 07 	lds	r24, 0x07FC
    5f4e:	90 91 fd 07 	lds	r25, 0x07FD
    5f52:	21 30       	cpi	r18, 0x01	; 1
    5f54:	11 f4       	brne	.+4      	; 0x5f5a <editModeHandler+0x6e>
				{
					editValue-=10;
    5f56:	0a 97       	sbiw	r24, 0x0a	; 10
    5f58:	01 c0       	rjmp	.+2      	; 0x5f5c <editModeHandler+0x70>
				}
				else
				{
					editValue--;	
    5f5a:	01 97       	sbiw	r24, 0x01	; 1
    5f5c:	90 93 fd 07 	sts	0x07FD, r25
    5f60:	80 93 fc 07 	sts	0x07FC, r24
				}
				
				if (editValue < editLoLimit)				
    5f64:	80 91 f9 07 	lds	r24, 0x07F9
    5f68:	90 91 fa 07 	lds	r25, 0x07FA
    5f6c:	20 91 fc 07 	lds	r18, 0x07FC
    5f70:	30 91 fd 07 	lds	r19, 0x07FD
    5f74:	28 17       	cp	r18, r24
    5f76:	39 07       	cpc	r19, r25
    5f78:	84 f5       	brge	.+96     	; 0x5fda <editModeHandler+0xee>
    5f7a:	1c c0       	rjmp	.+56     	; 0x5fb4 <editModeHandler+0xc8>
				{
					editValue = editLoLimit;
				}
		}
		else if (KEY3)	// UP?
    5f7c:	85 ff       	sbrs	r24, 5
    5f7e:	1f c0       	rjmp	.+62     	; 0x5fbe <editModeHandler+0xd2>
		{
				if (_keyrepeat == KEYBOARD_REPEAT)
    5f80:	20 91 cb 05 	lds	r18, 0x05CB
    5f84:	80 91 fc 07 	lds	r24, 0x07FC
    5f88:	90 91 fd 07 	lds	r25, 0x07FD
    5f8c:	21 30       	cpi	r18, 0x01	; 1
    5f8e:	11 f4       	brne	.+4      	; 0x5f94 <editModeHandler+0xa8>
				{
					editValue+=10;
    5f90:	0a 96       	adiw	r24, 0x0a	; 10
    5f92:	01 c0       	rjmp	.+2      	; 0x5f96 <editModeHandler+0xaa>
				}
				else
				{
					editValue++;	
    5f94:	01 96       	adiw	r24, 0x01	; 1
    5f96:	90 93 fd 07 	sts	0x07FD, r25
    5f9a:	80 93 fc 07 	sts	0x07FC, r24
				}
				
				if (editValue > editHiLimit)
    5f9e:	80 91 f3 07 	lds	r24, 0x07F3
    5fa2:	90 91 f4 07 	lds	r25, 0x07F4
    5fa6:	20 91 fc 07 	lds	r18, 0x07FC
    5faa:	30 91 fd 07 	lds	r19, 0x07FD
    5fae:	82 17       	cp	r24, r18
    5fb0:	93 07       	cpc	r25, r19
    5fb2:	9c f4       	brge	.+38     	; 0x5fda <editModeHandler+0xee>
				{
					editValue=editHiLimit;
    5fb4:	90 93 fd 07 	sts	0x07FD, r25
    5fb8:	80 93 fc 07 	sts	0x07FC, r24
    5fbc:	0e c0       	rjmp	.+28     	; 0x5fda <editModeHandler+0xee>
				}					
		}
		else if (KEY1)	// CLR?
    5fbe:	87 ff       	sbrs	r24, 7
    5fc0:	0c c0       	rjmp	.+24     	; 0x5fda <editModeHandler+0xee>
		{
			editMode = false;
    5fc2:	10 92 f8 07 	sts	0x07F8, r1
			_mykey = KEY_REFRESH;
    5fc6:	82 e0       	ldi	r24, 0x02	; 2
    5fc8:	80 93 ba 05 	sts	0x05BA, r24
	
			LCD_SelectFont(NULL);
    5fcc:	80 e0       	ldi	r24, 0x00	; 0
    5fce:	90 e0       	ldi	r25, 0x00	; 0
    5fd0:	0e 94 73 0e 	call	0x1ce6	; 0x1ce6 <LCD_SelectFont>
			defaultHandler();
    5fd4:	0e 94 50 2f 	call	0x5ea0	; 0x5ea0 <defaultHandler>
			return;	
    5fd8:	0a c0       	rjmp	.+20     	; 0x5fee <editModeHandler+0x102>
		}
			
		LCD_WriteValue(2, 34, editValue, 5, -1);
    5fda:	40 91 fc 07 	lds	r20, 0x07FC
    5fde:	50 91 fd 07 	lds	r21, 0x07FD
    5fe2:	82 e0       	ldi	r24, 0x02	; 2
    5fe4:	62 e2       	ldi	r22, 0x22	; 34
    5fe6:	25 e0       	ldi	r18, 0x05	; 5
    5fe8:	0f ef       	ldi	r16, 0xFF	; 255
    5fea:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <LCD_WriteValue>
	}
}
    5fee:	0f 91       	pop	r16
    5ff0:	08 95       	ret

00005ff2 <startEditMode>:

static void startEditMode(void* valuePtr, int16_t loLimit, int16_t hiLimit, uint8_t valueType)
{
    5ff2:	0f 93       	push	r16
    5ff4:	fc 01       	movw	r30, r24
	editMode = true;
    5ff6:	81 e0       	ldi	r24, 0x01	; 1
    5ff8:	80 93 f8 07 	sts	0x07F8, r24
	_mykey = KEY_INIT;
    5ffc:	80 93 ba 05 	sts	0x05BA, r24
	editValuePtr = valuePtr;
    6000:	f0 93 f6 07 	sts	0x07F6, r31
    6004:	e0 93 f5 07 	sts	0x07F5, r30
	editValueType = valueType;
    6008:	20 93 f7 07 	sts	0x07F7, r18
	
	if (valueType == TYPE_UINT8)
    600c:	22 30       	cpi	r18, 0x02	; 2
    600e:	31 f4       	brne	.+12     	; 0x601c <startEditMode+0x2a>
		editValue = *(uint8_t*)valuePtr;
    6010:	80 81       	ld	r24, Z
    6012:	80 93 fc 07 	sts	0x07FC, r24
    6016:	10 92 fd 07 	sts	0x07FD, r1
    601a:	11 c0       	rjmp	.+34     	; 0x603e <startEditMode+0x4c>
	else if (valueType == TYPE_INT8)
    601c:	21 30       	cpi	r18, 0x01	; 1
    601e:	29 f4       	brne	.+10     	; 0x602a <startEditMode+0x38>
		editValue = *(int8_t*)valuePtr;
    6020:	80 81       	ld	r24, Z
    6022:	99 27       	eor	r25, r25
    6024:	87 fd       	sbrc	r24, 7
    6026:	90 95       	com	r25
    6028:	06 c0       	rjmp	.+12     	; 0x6036 <startEditMode+0x44>
	else if (valueType == TYPE_INT16)
    602a:	23 30       	cpi	r18, 0x03	; 3
    602c:	11 f0       	breq	.+4      	; 0x6032 <startEditMode+0x40>
 		editValue = *(int16_t*)valuePtr;
	else if (valueType == TYPE_UINT16)
    602e:	24 30       	cpi	r18, 0x04	; 4
    6030:	31 f4       	brne	.+12     	; 0x603e <startEditMode+0x4c>
 		editValue = *(uint16_t*)valuePtr;
    6032:	80 81       	ld	r24, Z
    6034:	91 81       	ldd	r25, Z+1	; 0x01
    6036:	90 93 fd 07 	sts	0x07FD, r25
    603a:	80 93 fc 07 	sts	0x07FC, r24
	
	editLoLimit = loLimit;
    603e:	70 93 fa 07 	sts	0x07FA, r23
    6042:	60 93 f9 07 	sts	0x07F9, r22
	editHiLimit = hiLimit;
    6046:	50 93 f4 07 	sts	0x07F4, r21
    604a:	40 93 f3 07 	sts	0x07F3, r20
	
	LCD_FillRectangle(30, 11, 98, 34, 0);
    604e:	8e e1       	ldi	r24, 0x1E	; 30
    6050:	6b e0       	ldi	r22, 0x0B	; 11
    6052:	42 e6       	ldi	r20, 0x62	; 98
    6054:	22 e2       	ldi	r18, 0x22	; 34
    6056:	00 e0       	ldi	r16, 0x00	; 0
    6058:	0e 94 56 0c 	call	0x18ac	; 0x18ac <LCD_FillRectangle>
	LCD_Rectangle(30, 11, 98, 34, 1);
    605c:	8e e1       	ldi	r24, 0x1E	; 30
    605e:	6b e0       	ldi	r22, 0x0B	; 11
    6060:	42 e6       	ldi	r20, 0x62	; 98
    6062:	22 e2       	ldi	r18, 0x22	; 34
    6064:	01 e0       	ldi	r16, 0x01	; 1
    6066:	0e 94 55 0c 	call	0x18aa	; 0x18aa <LCD_Rectangle>
	LCD_Rectangle(31, 12, 97, 33, 1);
    606a:	8f e1       	ldi	r24, 0x1F	; 31
    606c:	6c e0       	ldi	r22, 0x0C	; 12
    606e:	41 e6       	ldi	r20, 0x61	; 97
    6070:	21 e2       	ldi	r18, 0x21	; 33
    6072:	0e 94 55 0c 	call	0x18aa	; 0x18aa <LCD_Rectangle>
	writeSoftkeys(_skEDIT);
    6076:	85 e5       	ldi	r24, 0x55	; 85
    6078:	9c e0       	ldi	r25, 0x0C	; 12
    607a:	0e 94 19 2a 	call	0x5432	; 0x5432 <writeSoftkeys>
	LCD_SelectFont(&font12x16);
    607e:	87 e7       	ldi	r24, 0x77	; 119
    6080:	91 e0       	ldi	r25, 0x01	; 1
    6082:	0e 94 73 0e 	call	0x1ce6	; 0x1ce6 <LCD_SelectFont>
	editModeHandler();
    6086:	0e 94 76 2f 	call	0x5eec	; 0x5eec <editModeHandler>
}
    608a:	0f 91       	pop	r16
    608c:	08 95       	ret

0000608e <PageKey>:
}


void PageKey(const uint8_t num)
{
	if (KEY2)	// PREV
    608e:	90 91 ba 05 	lds	r25, 0x05BA
    6092:	96 ff       	sbrs	r25, 6
    6094:	08 c0       	rjmp	.+16     	; 0x60a6 <PageKey+0x18>
		subpage = subpage == 0 ? num - 1 : subpage - 1;
    6096:	60 91 3c 05 	lds	r22, 0x053C
    609a:	61 11       	cpse	r22, r1
    609c:	86 2f       	mov	r24, r22
    609e:	81 50       	subi	r24, 0x01	; 1
    60a0:	80 93 3c 05 	sts	0x053C, r24
    60a4:	08 95       	ret
	else if (KEY3) // NEXT
    60a6:	95 ff       	sbrs	r25, 5
    60a8:	0c c0       	rjmp	.+24     	; 0x60c2 <PageKey+0x34>
		subpage = (subpage + 1) % num;
    60aa:	20 91 3c 05 	lds	r18, 0x053C
    60ae:	30 e0       	ldi	r19, 0x00	; 0
    60b0:	2f 5f       	subi	r18, 0xFF	; 255
    60b2:	3f 4f       	sbci	r19, 0xFF	; 255
    60b4:	68 2f       	mov	r22, r24
    60b6:	c9 01       	movw	r24, r18
    60b8:	70 e0       	ldi	r23, 0x00	; 0
    60ba:	0e 94 43 3a 	call	0x7486	; 0x7486 <__divmodhi4>
    60be:	80 93 3c 05 	sts	0x053C, r24
    60c2:	08 95       	ret

000060c4 <_hAltitudeHold>:




void _hAltitudeHold()
{
    60c4:	0f 93       	push	r16
	
	NOKEYRETURN;
    60c6:	80 91 ba 05 	lds	r24, 0x05BA
    60ca:	88 23       	and	r24, r24
    60cc:	09 f4       	brne	.+2      	; 0x60d0 <_hAltitudeHold+0xc>
    60ce:	a2 c0       	rjmp	.+324    	; 0x6214 <_hAltitudeHold+0x150>
	PageKey(6);
    60d0:	86 e0       	ldi	r24, 0x06	; 6
    60d2:	0e 94 47 30 	call	0x608e	; 0x608e <PageKey>
	
	
	if (KEY4)
    60d6:	20 91 ba 05 	lds	r18, 0x05BA
    60da:	24 ff       	sbrs	r18, 4
    60dc:	36 c0       	rjmp	.+108    	; 0x614a <_hAltitudeHold+0x86>
	{
		bValueChanged = true;
    60de:	81 e0       	ldi	r24, 0x01	; 1
    60e0:	80 93 38 05 	sts	0x0538, r24
		currentPage.softkeys = _skMENUSAVE;
    60e4:	8e e2       	ldi	r24, 0x2E	; 46
    60e6:	9c e0       	ldi	r25, 0x0C	; 12
    60e8:	90 93 43 05 	sts	0x0543, r25
    60ec:	80 93 42 05 	sts	0x0542, r24
		switch (subpage)
    60f0:	80 91 3c 05 	lds	r24, 0x053C
    60f4:	82 30       	cpi	r24, 0x02	; 2
    60f6:	a1 f0       	breq	.+40     	; 0x6120 <_hAltitudeHold+0x5c>
    60f8:	83 30       	cpi	r24, 0x03	; 3
    60fa:	28 f4       	brcc	.+10     	; 0x6106 <_hAltitudeHold+0x42>
    60fc:	88 23       	and	r24, r24
    60fe:	51 f0       	breq	.+20     	; 0x6114 <_hAltitudeHold+0x50>
    6100:	81 30       	cpi	r24, 0x01	; 1
    6102:	19 f5       	brne	.+70     	; 0x614a <_hAltitudeHold+0x86>
    6104:	0a c0       	rjmp	.+20     	; 0x611a <_hAltitudeHold+0x56>
    6106:	84 30       	cpi	r24, 0x04	; 4
    6108:	89 f0       	breq	.+34     	; 0x612c <_hAltitudeHold+0x68>
    610a:	84 30       	cpi	r24, 0x04	; 4
    610c:	60 f0       	brcs	.+24     	; 0x6126 <_hAltitudeHold+0x62>
    610e:	85 30       	cpi	r24, 0x05	; 5
    6110:	e1 f4       	brne	.+56     	; 0x614a <_hAltitudeHold+0x86>
    6112:	11 c0       	rjmp	.+34     	; 0x6136 <_hAltitudeHold+0x72>
		{
			case 0: startEditMode(&(Config.SonarParams[0]._P),-500,500,TYPE_INT16); return ;
    6114:	8b e4       	ldi	r24, 0x4B	; 75
    6116:	97 e0       	ldi	r25, 0x07	; 7
    6118:	0b c0       	rjmp	.+22     	; 0x6130 <_hAltitudeHold+0x6c>
			case 1: startEditMode(&(Config.SonarParams[0]._PLimit),0,500,TYPE_INT16); return ;
    611a:	8d e4       	ldi	r24, 0x4D	; 77
    611c:	97 e0       	ldi	r25, 0x07	; 7
    611e:	0d c0       	rjmp	.+26     	; 0x613a <_hAltitudeHold+0x76>
			case 2: startEditMode(&(Config.SonarParams[0]._I),-500,500,TYPE_INT16);  return ;
    6120:	8f e4       	ldi	r24, 0x4F	; 79
    6122:	97 e0       	ldi	r25, 0x07	; 7
    6124:	05 c0       	rjmp	.+10     	; 0x6130 <_hAltitudeHold+0x6c>
			case 3: startEditMode(&(Config.SonarParams[0]._ILimit),0,500,TYPE_INT16); return ;
    6126:	81 e5       	ldi	r24, 0x51	; 81
    6128:	97 e0       	ldi	r25, 0x07	; 7
    612a:	07 c0       	rjmp	.+14     	; 0x613a <_hAltitudeHold+0x76>
			case 4: startEditMode(&(Config.SonarParams[0]._D),-500,500,TYPE_INT16);  return ; // negative D
    612c:	83 e5       	ldi	r24, 0x53	; 83
    612e:	97 e0       	ldi	r25, 0x07	; 7
    6130:	6c e0       	ldi	r22, 0x0C	; 12
    6132:	7e ef       	ldi	r23, 0xFE	; 254
    6134:	04 c0       	rjmp	.+8      	; 0x613e <_hAltitudeHold+0x7a>
			case 5: startEditMode(&(Config.SonarParams[0]._DLimit),0,500,TYPE_INT16); return ;
    6136:	85 e5       	ldi	r24, 0x55	; 85
    6138:	97 e0       	ldi	r25, 0x07	; 7
    613a:	60 e0       	ldi	r22, 0x00	; 0
    613c:	70 e0       	ldi	r23, 0x00	; 0
    613e:	44 ef       	ldi	r20, 0xF4	; 244
    6140:	51 e0       	ldi	r21, 0x01	; 1
    6142:	23 e0       	ldi	r18, 0x03	; 3
    6144:	0e 94 f9 2f 	call	0x5ff2	; 0x5ff2 <startEditMode>
    6148:	65 c0       	rjmp	.+202    	; 0x6214 <_hAltitudeHold+0x150>
		}
	}
	
	if (KEY1)
    614a:	27 ff       	sbrs	r18, 7
    614c:	02 c0       	rjmp	.+4      	; 0x6152 <_hAltitudeHold+0x8e>
	{
		_helper_SaveinEEPROM_ifChanged();
    614e:	0e 94 f5 2b 	call	0x57ea	; 0x57ea <_helper_SaveinEEPROM_ifChanged>
	}
	
	LCD_WriteValue(1,30,Config.SonarParams[0]._P,3,0==subpage);
    6152:	40 91 4b 07 	lds	r20, 0x074B
    6156:	50 91 4c 07 	lds	r21, 0x074C
    615a:	01 e0       	ldi	r16, 0x01	; 1
    615c:	80 91 3c 05 	lds	r24, 0x053C
    6160:	81 11       	cpse	r24, r1
    6162:	00 e0       	ldi	r16, 0x00	; 0
    6164:	81 e0       	ldi	r24, 0x01	; 1
    6166:	6e e1       	ldi	r22, 0x1E	; 30
    6168:	23 e0       	ldi	r18, 0x03	; 3
    616a:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <LCD_WriteValue>
	LCD_WriteValue(1,84,Config.SonarParams[0]._PLimit,3,1==subpage);
    616e:	40 91 4d 07 	lds	r20, 0x074D
    6172:	50 91 4e 07 	lds	r21, 0x074E
    6176:	01 e0       	ldi	r16, 0x01	; 1
    6178:	80 91 3c 05 	lds	r24, 0x053C
    617c:	81 30       	cpi	r24, 0x01	; 1
    617e:	09 f0       	breq	.+2      	; 0x6182 <_hAltitudeHold+0xbe>
    6180:	00 e0       	ldi	r16, 0x00	; 0
    6182:	81 e0       	ldi	r24, 0x01	; 1
    6184:	64 e5       	ldi	r22, 0x54	; 84
    6186:	23 e0       	ldi	r18, 0x03	; 3
    6188:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <LCD_WriteValue>
	LCD_WriteValue(2,30,Config.SonarParams[0]._I,3,2==subpage);
    618c:	40 91 4f 07 	lds	r20, 0x074F
    6190:	50 91 50 07 	lds	r21, 0x0750
    6194:	01 e0       	ldi	r16, 0x01	; 1
    6196:	80 91 3c 05 	lds	r24, 0x053C
    619a:	82 30       	cpi	r24, 0x02	; 2
    619c:	09 f0       	breq	.+2      	; 0x61a0 <_hAltitudeHold+0xdc>
    619e:	00 e0       	ldi	r16, 0x00	; 0
    61a0:	82 e0       	ldi	r24, 0x02	; 2
    61a2:	6e e1       	ldi	r22, 0x1E	; 30
    61a4:	23 e0       	ldi	r18, 0x03	; 3
    61a6:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <LCD_WriteValue>
	LCD_WriteValue(2,84,Config.SonarParams[0]._ILimit,3,3==subpage);
    61aa:	40 91 51 07 	lds	r20, 0x0751
    61ae:	50 91 52 07 	lds	r21, 0x0752
    61b2:	01 e0       	ldi	r16, 0x01	; 1
    61b4:	80 91 3c 05 	lds	r24, 0x053C
    61b8:	83 30       	cpi	r24, 0x03	; 3
    61ba:	09 f0       	breq	.+2      	; 0x61be <_hAltitudeHold+0xfa>
    61bc:	00 e0       	ldi	r16, 0x00	; 0
    61be:	82 e0       	ldi	r24, 0x02	; 2
    61c0:	64 e5       	ldi	r22, 0x54	; 84
    61c2:	23 e0       	ldi	r18, 0x03	; 3
    61c4:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <LCD_WriteValue>
	LCD_WriteValue(3,30,Config.SonarParams[0]._D,3,4==subpage);
    61c8:	40 91 53 07 	lds	r20, 0x0753
    61cc:	50 91 54 07 	lds	r21, 0x0754
    61d0:	01 e0       	ldi	r16, 0x01	; 1
    61d2:	80 91 3c 05 	lds	r24, 0x053C
    61d6:	84 30       	cpi	r24, 0x04	; 4
    61d8:	09 f0       	breq	.+2      	; 0x61dc <_hAltitudeHold+0x118>
    61da:	00 e0       	ldi	r16, 0x00	; 0
    61dc:	83 e0       	ldi	r24, 0x03	; 3
    61de:	6e e1       	ldi	r22, 0x1E	; 30
    61e0:	23 e0       	ldi	r18, 0x03	; 3
    61e2:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <LCD_WriteValue>
	LCD_WriteValue(3,84,Config.SonarParams[0]._DLimit,3,5==subpage);
    61e6:	40 91 55 07 	lds	r20, 0x0755
    61ea:	50 91 56 07 	lds	r21, 0x0756
    61ee:	01 e0       	ldi	r16, 0x01	; 1
    61f0:	80 91 3c 05 	lds	r24, 0x053C
    61f4:	85 30       	cpi	r24, 0x05	; 5
    61f6:	09 f0       	breq	.+2      	; 0x61fa <_hAltitudeHold+0x136>
    61f8:	00 e0       	ldi	r16, 0x00	; 0
    61fa:	83 e0       	ldi	r24, 0x03	; 3
    61fc:	64 e5       	ldi	r22, 0x54	; 84
    61fe:	23 e0       	ldi	r18, 0x03	; 3
    6200:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <LCD_WriteValue>
	LCD_WriteString_Pex(5,0,PSTR("                "),16,false);    
    6204:	85 e0       	ldi	r24, 0x05	; 5
    6206:	60 e0       	ldi	r22, 0x00	; 0
    6208:	44 e4       	ldi	r20, 0x44	; 68
    620a:	5c e0       	ldi	r21, 0x0C	; 12
    620c:	20 e1       	ldi	r18, 0x10	; 16
    620e:	00 e0       	ldi	r16, 0x00	; 0
    6210:	0e 94 a4 0d 	call	0x1b48	; 0x1b48 <LCD_WriteString_Pex>
				
}
    6214:	0f 91       	pop	r16
    6216:	08 95       	ret

00006218 <_hSelfLeveling>:
}



void _hSelfLeveling()
{
    6218:	0f 93       	push	r16
	NOKEYRETURN;
    621a:	80 91 ba 05 	lds	r24, 0x05BA
    621e:	88 23       	and	r24, r24
    6220:	09 f4       	brne	.+2      	; 0x6224 <_hSelfLeveling+0xc>
    6222:	ff c1       	rjmp	.+1022   	; 0x6622 <_hSelfLeveling+0x40a>
	PageKey(10);
    6224:	8a e0       	ldi	r24, 0x0A	; 10
    6226:	0e 94 47 30 	call	0x608e	; 0x608e <PageKey>
	
	if ((subindex==2) && (subpage>7)) subpage=0;
    622a:	80 91 3d 05 	lds	r24, 0x053D
    622e:	82 30       	cpi	r24, 0x02	; 2
    6230:	31 f4       	brne	.+12     	; 0x623e <_hSelfLeveling+0x26>
    6232:	80 91 3c 05 	lds	r24, 0x053C
    6236:	88 30       	cpi	r24, 0x08	; 8
    6238:	10 f0       	brcs	.+4      	; 0x623e <_hSelfLeveling+0x26>
    623a:	10 92 3c 05 	sts	0x053C, r1
		
	
	
	if (KEY4)
    623e:	80 91 ba 05 	lds	r24, 0x05BA
    6242:	84 ff       	sbrs	r24, 4
    6244:	d6 c0       	rjmp	.+428    	; 0x63f2 <_hSelfLeveling+0x1da>
	{
		if (subpage!=0) bValueChanged = true;
    6246:	20 91 3c 05 	lds	r18, 0x053C
    624a:	22 23       	and	r18, r18
    624c:	19 f0       	breq	.+6      	; 0x6254 <_hSelfLeveling+0x3c>
    624e:	81 e0       	ldi	r24, 0x01	; 1
    6250:	80 93 38 05 	sts	0x0538, r24
		currentPage.softkeys = _skMENUSAVE;
    6254:	8e e2       	ldi	r24, 0x2E	; 46
    6256:	9c e0       	ldi	r25, 0x0C	; 12
    6258:	90 93 43 05 	sts	0x0543, r25
    625c:	80 93 42 05 	sts	0x0542, r24
		
		switch (subpage)
    6260:	24 30       	cpi	r18, 0x04	; 4
    6262:	09 f4       	brne	.+2      	; 0x6266 <_hSelfLeveling+0x4e>
    6264:	6e c0       	rjmp	.+220    	; 0x6342 <_hSelfLeveling+0x12a>
    6266:	25 30       	cpi	r18, 0x05	; 5
    6268:	58 f4       	brcc	.+22     	; 0x6280 <_hSelfLeveling+0x68>
    626a:	21 30       	cpi	r18, 0x01	; 1
    626c:	99 f1       	breq	.+102    	; 0x62d4 <_hSelfLeveling+0xbc>
    626e:	21 30       	cpi	r18, 0x01	; 1
    6270:	d0 f0       	brcs	.+52     	; 0x62a6 <_hSelfLeveling+0x8e>
    6272:	22 30       	cpi	r18, 0x02	; 2
    6274:	09 f4       	brne	.+2      	; 0x6278 <_hSelfLeveling+0x60>
    6276:	3f c0       	rjmp	.+126    	; 0x62f6 <_hSelfLeveling+0xde>
    6278:	23 30       	cpi	r18, 0x03	; 3
    627a:	09 f0       	breq	.+2      	; 0x627e <_hSelfLeveling+0x66>
    627c:	ba c0       	rjmp	.+372    	; 0x63f2 <_hSelfLeveling+0x1da>
    627e:	50 c0       	rjmp	.+160    	; 0x6320 <_hSelfLeveling+0x108>
    6280:	27 30       	cpi	r18, 0x07	; 7
    6282:	09 f4       	brne	.+2      	; 0x6286 <_hSelfLeveling+0x6e>
    6284:	93 c0       	rjmp	.+294    	; 0x63ac <_hSelfLeveling+0x194>
    6286:	28 30       	cpi	r18, 0x08	; 8
    6288:	38 f4       	brcc	.+14     	; 0x6298 <_hSelfLeveling+0x80>
    628a:	25 30       	cpi	r18, 0x05	; 5
    628c:	09 f4       	brne	.+2      	; 0x6290 <_hSelfLeveling+0x78>
    628e:	6a c0       	rjmp	.+212    	; 0x6364 <_hSelfLeveling+0x14c>
    6290:	26 30       	cpi	r18, 0x06	; 6
    6292:	09 f0       	breq	.+2      	; 0x6296 <_hSelfLeveling+0x7e>
    6294:	ae c0       	rjmp	.+348    	; 0x63f2 <_hSelfLeveling+0x1da>
    6296:	79 c0       	rjmp	.+242    	; 0x638a <_hSelfLeveling+0x172>
    6298:	28 30       	cpi	r18, 0x08	; 8
    629a:	09 f4       	brne	.+2      	; 0x629e <_hSelfLeveling+0x86>
    629c:	9d c0       	rjmp	.+314    	; 0x63d8 <_hSelfLeveling+0x1c0>
    629e:	29 30       	cpi	r18, 0x09	; 9
    62a0:	09 f0       	breq	.+2      	; 0x62a4 <_hSelfLeveling+0x8c>
    62a2:	a7 c0       	rjmp	.+334    	; 0x63f2 <_hSelfLeveling+0x1da>
    62a4:	9c c0       	rjmp	.+312    	; 0x63de <_hSelfLeveling+0x1c6>
		{
			case 0: _helper_SwitchPitchRollYaw(&subindex); 
    62a6:	8d e3       	ldi	r24, 0x3D	; 61
    62a8:	95 e0       	ldi	r25, 0x05	; 5
    62aa:	0e 94 b5 2b 	call	0x576a	; 0x576a <_helper_SwitchPitchRollYaw>
					if (subindex==2) 
    62ae:	80 91 3d 05 	lds	r24, 0x053D
    62b2:	82 30       	cpi	r24, 0x02	; 2
    62b4:	31 f4       	brne	.+12     	; 0x62c2 <_hSelfLeveling+0xaa>
					{
						LCD_WriteString_Pex(5,0,PSTR("                "),16,false);    
    62b6:	85 e0       	ldi	r24, 0x05	; 5
    62b8:	60 e0       	ldi	r22, 0x00	; 0
    62ba:	47 e8       	ldi	r20, 0x87	; 135
    62bc:	5c e0       	ldi	r21, 0x0C	; 12
    62be:	20 e1       	ldi	r18, 0x10	; 16
    62c0:	05 c0       	rjmp	.+10     	; 0x62cc <_hSelfLeveling+0xb4>
					}
					else
					{
						LCD_WriteString_Pex(5,0,PSTR("Trim P:    R:"),13,false);
    62c2:	85 e0       	ldi	r24, 0x05	; 5
    62c4:	60 e0       	ldi	r22, 0x00	; 0
    62c6:	49 e7       	ldi	r20, 0x79	; 121
    62c8:	5c e0       	ldi	r21, 0x0C	; 12
    62ca:	2d e0       	ldi	r18, 0x0D	; 13
    62cc:	00 e0       	ldi	r16, 0x00	; 0
    62ce:	0e 94 a4 0d 	call	0x1b48	; 0x1b48 <LCD_WriteString_Pex>
    62d2:	8f c0       	rjmp	.+286    	; 0x63f2 <_hSelfLeveling+0x1da>
					}				
					break;		
			case 1: startEditMode(&(Config.AccParams[subindex]._P),-500,500,TYPE_INT16); return ;
    62d4:	80 91 3d 05 	lds	r24, 0x053D
    62d8:	90 e0       	ldi	r25, 0x00	; 0
    62da:	9c 01       	movw	r18, r24
    62dc:	22 0f       	add	r18, r18
    62de:	33 1f       	adc	r19, r19
    62e0:	c9 01       	movw	r24, r18
    62e2:	e3 e0       	ldi	r30, 0x03	; 3
    62e4:	88 0f       	add	r24, r24
    62e6:	99 1f       	adc	r25, r25
    62e8:	ea 95       	dec	r30
    62ea:	e1 f7       	brne	.-8      	; 0x62e4 <_hSelfLeveling+0xcc>
    62ec:	82 1b       	sub	r24, r18
    62ee:	93 0b       	sbc	r25, r19
    62f0:	8f 5d       	subi	r24, 0xDF	; 223
    62f2:	98 4f       	sbci	r25, 0xF8	; 248
    62f4:	47 c0       	rjmp	.+142    	; 0x6384 <_hSelfLeveling+0x16c>
			case 2: startEditMode(&(Config.AccParams[subindex]._PLimit),0,500,TYPE_INT16); return ;
    62f6:	80 91 3d 05 	lds	r24, 0x053D
    62fa:	90 e0       	ldi	r25, 0x00	; 0
    62fc:	9c 01       	movw	r18, r24
    62fe:	22 0f       	add	r18, r18
    6300:	33 1f       	adc	r19, r19
    6302:	c9 01       	movw	r24, r18
    6304:	63 e0       	ldi	r22, 0x03	; 3
    6306:	88 0f       	add	r24, r24
    6308:	99 1f       	adc	r25, r25
    630a:	6a 95       	dec	r22
    630c:	e1 f7       	brne	.-8      	; 0x6306 <_hSelfLeveling+0xee>
    630e:	82 1b       	sub	r24, r18
    6310:	93 0b       	sbc	r25, r19
    6312:	8d 5d       	subi	r24, 0xDD	; 221
    6314:	98 4f       	sbci	r25, 0xF8	; 248
    6316:	60 e0       	ldi	r22, 0x00	; 0
    6318:	70 e0       	ldi	r23, 0x00	; 0
    631a:	44 ef       	ldi	r20, 0xF4	; 244
    631c:	51 e0       	ldi	r21, 0x01	; 1
    631e:	5a c0       	rjmp	.+180    	; 0x63d4 <_hSelfLeveling+0x1bc>
			case 3: startEditMode(&(Config.AccParams[subindex]._I),-500,500,TYPE_INT16);  return ;
    6320:	80 91 3d 05 	lds	r24, 0x053D
    6324:	90 e0       	ldi	r25, 0x00	; 0
    6326:	9c 01       	movw	r18, r24
    6328:	22 0f       	add	r18, r18
    632a:	33 1f       	adc	r19, r19
    632c:	c9 01       	movw	r24, r18
    632e:	43 e0       	ldi	r20, 0x03	; 3
    6330:	88 0f       	add	r24, r24
    6332:	99 1f       	adc	r25, r25
    6334:	4a 95       	dec	r20
    6336:	e1 f7       	brne	.-8      	; 0x6330 <_hSelfLeveling+0x118>
    6338:	82 1b       	sub	r24, r18
    633a:	93 0b       	sbc	r25, r19
    633c:	8b 5d       	subi	r24, 0xDB	; 219
    633e:	98 4f       	sbci	r25, 0xF8	; 248
    6340:	21 c0       	rjmp	.+66     	; 0x6384 <_hSelfLeveling+0x16c>
			case 4: startEditMode(&(Config.AccParams[subindex]._ILimit),0,500,TYPE_INT16); return ;
    6342:	80 91 3d 05 	lds	r24, 0x053D
    6346:	90 e0       	ldi	r25, 0x00	; 0
    6348:	9c 01       	movw	r18, r24
    634a:	22 0f       	add	r18, r18
    634c:	33 1f       	adc	r19, r19
    634e:	c9 01       	movw	r24, r18
    6350:	b3 e0       	ldi	r27, 0x03	; 3
    6352:	88 0f       	add	r24, r24
    6354:	99 1f       	adc	r25, r25
    6356:	ba 95       	dec	r27
    6358:	e1 f7       	brne	.-8      	; 0x6352 <_hSelfLeveling+0x13a>
    635a:	82 1b       	sub	r24, r18
    635c:	93 0b       	sbc	r25, r19
    635e:	89 5d       	subi	r24, 0xD9	; 217
    6360:	98 4f       	sbci	r25, 0xF8	; 248
    6362:	d9 cf       	rjmp	.-78     	; 0x6316 <_hSelfLeveling+0xfe>
			case 5: startEditMode(&(Config.AccParams[subindex]._D),-500,500,TYPE_INT16);  return ; // negative D
    6364:	80 91 3d 05 	lds	r24, 0x053D
    6368:	90 e0       	ldi	r25, 0x00	; 0
    636a:	9c 01       	movw	r18, r24
    636c:	22 0f       	add	r18, r18
    636e:	33 1f       	adc	r19, r19
    6370:	c9 01       	movw	r24, r18
    6372:	f3 e0       	ldi	r31, 0x03	; 3
    6374:	88 0f       	add	r24, r24
    6376:	99 1f       	adc	r25, r25
    6378:	fa 95       	dec	r31
    637a:	e1 f7       	brne	.-8      	; 0x6374 <_hSelfLeveling+0x15c>
    637c:	82 1b       	sub	r24, r18
    637e:	93 0b       	sbc	r25, r19
    6380:	87 5d       	subi	r24, 0xD7	; 215
    6382:	98 4f       	sbci	r25, 0xF8	; 248
    6384:	6c e0       	ldi	r22, 0x0C	; 12
    6386:	7e ef       	ldi	r23, 0xFE	; 254
    6388:	c8 cf       	rjmp	.-112    	; 0x631a <_hSelfLeveling+0x102>
			case 6: startEditMode(&(Config.AccParams[subindex]._DLimit),0,500,TYPE_INT16); return ;
    638a:	80 91 3d 05 	lds	r24, 0x053D
    638e:	90 e0       	ldi	r25, 0x00	; 0
    6390:	9c 01       	movw	r18, r24
    6392:	22 0f       	add	r18, r18
    6394:	33 1f       	adc	r19, r19
    6396:	c9 01       	movw	r24, r18
    6398:	73 e0       	ldi	r23, 0x03	; 3
    639a:	88 0f       	add	r24, r24
    639c:	99 1f       	adc	r25, r25
    639e:	7a 95       	dec	r23
    63a0:	e1 f7       	brne	.-8      	; 0x639a <_hSelfLeveling+0x182>
    63a2:	82 1b       	sub	r24, r18
    63a4:	93 0b       	sbc	r25, r19
    63a6:	85 5d       	subi	r24, 0xD5	; 213
    63a8:	98 4f       	sbci	r25, 0xF8	; 248
    63aa:	b5 cf       	rjmp	.-150    	; 0x6316 <_hSelfLeveling+0xfe>
			case 7: startEditMode(&(Config.AccParams[subindex].ComplementaryFilterAlpha),0,999,TYPE_INT16); return ;
    63ac:	80 91 3d 05 	lds	r24, 0x053D
    63b0:	90 e0       	ldi	r25, 0x00	; 0
    63b2:	9c 01       	movw	r18, r24
    63b4:	22 0f       	add	r18, r18
    63b6:	33 1f       	adc	r19, r19
    63b8:	c9 01       	movw	r24, r18
    63ba:	53 e0       	ldi	r21, 0x03	; 3
    63bc:	88 0f       	add	r24, r24
    63be:	99 1f       	adc	r25, r25
    63c0:	5a 95       	dec	r21
    63c2:	e1 f7       	brne	.-8      	; 0x63bc <_hSelfLeveling+0x1a4>
    63c4:	82 1b       	sub	r24, r18
    63c6:	93 0b       	sbc	r25, r19
    63c8:	83 5d       	subi	r24, 0xD3	; 211
    63ca:	98 4f       	sbci	r25, 0xF8	; 248
    63cc:	60 e0       	ldi	r22, 0x00	; 0
    63ce:	70 e0       	ldi	r23, 0x00	; 0
    63d0:	47 ee       	ldi	r20, 0xE7	; 231
    63d2:	53 e0       	ldi	r21, 0x03	; 3
    63d4:	23 e0       	ldi	r18, 0x03	; 3
    63d6:	0a c0       	rjmp	.+20     	; 0x63ec <_hSelfLeveling+0x1d4>
			case 8: startEditMode(&(Config.Acc_Pitch_Trim),-25,25,TYPE_INT8);  return ; 
    63d8:	8a e5       	ldi	r24, 0x5A	; 90
    63da:	97 e0       	ldi	r25, 0x07	; 7
    63dc:	02 c0       	rjmp	.+4      	; 0x63e2 <_hSelfLeveling+0x1ca>
			case 9: startEditMode(&(Config.Acc_Roll_Trim),-25,25,TYPE_INT8); return ;
    63de:	8b e5       	ldi	r24, 0x5B	; 91
    63e0:	97 e0       	ldi	r25, 0x07	; 7
    63e2:	67 ee       	ldi	r22, 0xE7	; 231
    63e4:	7f ef       	ldi	r23, 0xFF	; 255
    63e6:	49 e1       	ldi	r20, 0x19	; 25
    63e8:	50 e0       	ldi	r21, 0x00	; 0
    63ea:	21 e0       	ldi	r18, 0x01	; 1
    63ec:	0e 94 f9 2f 	call	0x5ff2	; 0x5ff2 <startEditMode>
    63f0:	18 c1       	rjmp	.+560    	; 0x6622 <_hSelfLeveling+0x40a>
		}
	}
	
	if (KEY1)
    63f2:	80 91 ba 05 	lds	r24, 0x05BA
    63f6:	87 ff       	sbrs	r24, 7
    63f8:	0f c0       	rjmp	.+30     	; 0x6418 <_hSelfLeveling+0x200>
	{
		if (Config.PitchRollLinked==1)
    63fa:	80 91 af 07 	lds	r24, 0x07AF
    63fe:	81 30       	cpi	r24, 0x01	; 1
    6400:	49 f4       	brne	.+18     	; 0x6414 <_hSelfLeveling+0x1fc>
		{ 
			memcpy(&(Config.AccParams[ROLL_INDEX]),&(Config.AccParams[PITCH_INDEX]), sizeof(pid_param_t));
    6402:	ef e2       	ldi	r30, 0x2F	; 47
    6404:	f7 e0       	ldi	r31, 0x07	; 7
    6406:	df 01       	movw	r26, r30
    6408:	1e 97       	sbiw	r26, 0x0e	; 14
    640a:	8e e0       	ldi	r24, 0x0E	; 14
    640c:	0d 90       	ld	r0, X+
    640e:	01 92       	st	Z+, r0
    6410:	81 50       	subi	r24, 0x01	; 1
    6412:	e1 f7       	brne	.-8      	; 0x640c <_hSelfLeveling+0x1f4>
		}
		
		_helper_SaveinEEPROM_ifChanged();
    6414:	0e 94 f5 2b 	call	0x57ea	; 0x57ea <_helper_SaveinEEPROM_ifChanged>
	}
	
	lcdReverse(subpage == 0);
    6418:	81 e0       	ldi	r24, 0x01	; 1
    641a:	90 91 3c 05 	lds	r25, 0x053C
    641e:	91 11       	cpse	r25, r1
    6420:	80 e0       	ldi	r24, 0x00	; 0
    6422:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <lcdReverse>
	_helper_DisplayPitchRollYaw(subindex);
    6426:	80 91 3d 05 	lds	r24, 0x053D
    642a:	0e 94 92 2b 	call	0x5724	; 0x5724 <_helper_DisplayPitchRollYaw>
	if (subindex<2)
    642e:	80 91 3d 05 	lds	r24, 0x053D
    6432:	82 30       	cpi	r24, 0x02	; 2
    6434:	08 f5       	brcc	.+66     	; 0x6478 <_hSelfLeveling+0x260>
	{
		LCD_WriteValue(5,42,Config.Acc_Pitch_Trim,3,8==subpage);
    6436:	40 91 5a 07 	lds	r20, 0x075A
    643a:	55 27       	eor	r21, r21
    643c:	47 fd       	sbrc	r20, 7
    643e:	50 95       	com	r21
    6440:	01 e0       	ldi	r16, 0x01	; 1
    6442:	80 91 3c 05 	lds	r24, 0x053C
    6446:	88 30       	cpi	r24, 0x08	; 8
    6448:	09 f0       	breq	.+2      	; 0x644c <_hSelfLeveling+0x234>
    644a:	00 e0       	ldi	r16, 0x00	; 0
    644c:	85 e0       	ldi	r24, 0x05	; 5
    644e:	6a e2       	ldi	r22, 0x2A	; 42
    6450:	23 e0       	ldi	r18, 0x03	; 3
    6452:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <LCD_WriteValue>
		LCD_WriteValue(5,78,Config.Acc_Roll_Trim,3,9==subpage);
    6456:	40 91 5b 07 	lds	r20, 0x075B
    645a:	55 27       	eor	r21, r21
    645c:	47 fd       	sbrc	r20, 7
    645e:	50 95       	com	r21
    6460:	01 e0       	ldi	r16, 0x01	; 1
    6462:	80 91 3c 05 	lds	r24, 0x053C
    6466:	89 30       	cpi	r24, 0x09	; 9
    6468:	09 f0       	breq	.+2      	; 0x646c <_hSelfLeveling+0x254>
    646a:	00 e0       	ldi	r16, 0x00	; 0
    646c:	85 e0       	ldi	r24, 0x05	; 5
    646e:	6e e4       	ldi	r22, 0x4E	; 78
    6470:	23 e0       	ldi	r18, 0x03	; 3
    6472:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <LCD_WriteValue>
    6476:	06 c0       	rjmp	.+12     	; 0x6484 <_hSelfLeveling+0x26c>
	}
	else
	{
		strcpy_P(sXDeg,PSTR("ACC-Z damping"));
    6478:	8a ee       	ldi	r24, 0xEA	; 234
    647a:	95 e0       	ldi	r25, 0x05	; 5
    647c:	6b e6       	ldi	r22, 0x6B	; 107
    647e:	7c e0       	ldi	r23, 0x0C	; 12
    6480:	0e 94 8a 3a 	call	0x7514	; 0x7514 <strcpy_P>
	}
	
	LCD_WriteStringex (0,0,sXDeg,0==subpage);
    6484:	21 e0       	ldi	r18, 0x01	; 1
    6486:	80 91 3c 05 	lds	r24, 0x053C
    648a:	81 11       	cpse	r24, r1
    648c:	20 e0       	ldi	r18, 0x00	; 0
    648e:	80 e0       	ldi	r24, 0x00	; 0
    6490:	60 e0       	ldi	r22, 0x00	; 0
    6492:	4a ee       	ldi	r20, 0xEA	; 234
    6494:	55 e0       	ldi	r21, 0x05	; 5
    6496:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <LCD_WriteStringex>
	LCD_WriteValue(1,30,Config.AccParams[subindex]._P,3,1==subpage);
    649a:	80 91 3d 05 	lds	r24, 0x053D
    649e:	90 e0       	ldi	r25, 0x00	; 0
    64a0:	88 0f       	add	r24, r24
    64a2:	99 1f       	adc	r25, r25
    64a4:	fc 01       	movw	r30, r24
    64a6:	33 e0       	ldi	r19, 0x03	; 3
    64a8:	ee 0f       	add	r30, r30
    64aa:	ff 1f       	adc	r31, r31
    64ac:	3a 95       	dec	r19
    64ae:	e1 f7       	brne	.-8      	; 0x64a8 <_hSelfLeveling+0x290>
    64b0:	e8 1b       	sub	r30, r24
    64b2:	f9 0b       	sbc	r31, r25
    64b4:	e9 51       	subi	r30, 0x19	; 25
    64b6:	f9 4f       	sbci	r31, 0xF9	; 249
    64b8:	42 ad       	ldd	r20, Z+58	; 0x3a
    64ba:	53 ad       	ldd	r21, Z+59	; 0x3b
    64bc:	01 e0       	ldi	r16, 0x01	; 1
    64be:	80 91 3c 05 	lds	r24, 0x053C
    64c2:	81 30       	cpi	r24, 0x01	; 1
    64c4:	09 f0       	breq	.+2      	; 0x64c8 <_hSelfLeveling+0x2b0>
    64c6:	00 e0       	ldi	r16, 0x00	; 0
    64c8:	81 e0       	ldi	r24, 0x01	; 1
    64ca:	6e e1       	ldi	r22, 0x1E	; 30
    64cc:	23 e0       	ldi	r18, 0x03	; 3
    64ce:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <LCD_WriteValue>
	LCD_WriteValue(1,84,Config.AccParams[subindex]._PLimit,3,2==subpage);
    64d2:	80 91 3d 05 	lds	r24, 0x053D
    64d6:	90 e0       	ldi	r25, 0x00	; 0
    64d8:	88 0f       	add	r24, r24
    64da:	99 1f       	adc	r25, r25
    64dc:	fc 01       	movw	r30, r24
    64de:	03 e0       	ldi	r16, 0x03	; 3
    64e0:	ee 0f       	add	r30, r30
    64e2:	ff 1f       	adc	r31, r31
    64e4:	0a 95       	dec	r16
    64e6:	e1 f7       	brne	.-8      	; 0x64e0 <_hSelfLeveling+0x2c8>
    64e8:	e8 1b       	sub	r30, r24
    64ea:	f9 0b       	sbc	r31, r25
    64ec:	e9 51       	subi	r30, 0x19	; 25
    64ee:	f9 4f       	sbci	r31, 0xF9	; 249
    64f0:	44 ad       	ldd	r20, Z+60	; 0x3c
    64f2:	55 ad       	ldd	r21, Z+61	; 0x3d
    64f4:	01 e0       	ldi	r16, 0x01	; 1
    64f6:	80 91 3c 05 	lds	r24, 0x053C
    64fa:	82 30       	cpi	r24, 0x02	; 2
    64fc:	09 f0       	breq	.+2      	; 0x6500 <_hSelfLeveling+0x2e8>
    64fe:	00 e0       	ldi	r16, 0x00	; 0
    6500:	81 e0       	ldi	r24, 0x01	; 1
    6502:	64 e5       	ldi	r22, 0x54	; 84
    6504:	23 e0       	ldi	r18, 0x03	; 3
    6506:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <LCD_WriteValue>
	LCD_WriteValue(2,30,Config.AccParams[subindex]._I,3,3==subpage);
    650a:	80 91 3d 05 	lds	r24, 0x053D
    650e:	90 e0       	ldi	r25, 0x00	; 0
    6510:	88 0f       	add	r24, r24
    6512:	99 1f       	adc	r25, r25
    6514:	fc 01       	movw	r30, r24
    6516:	a3 e0       	ldi	r26, 0x03	; 3
    6518:	ee 0f       	add	r30, r30
    651a:	ff 1f       	adc	r31, r31
    651c:	aa 95       	dec	r26
    651e:	e1 f7       	brne	.-8      	; 0x6518 <_hSelfLeveling+0x300>
    6520:	e8 1b       	sub	r30, r24
    6522:	f9 0b       	sbc	r31, r25
    6524:	eb 5d       	subi	r30, 0xDB	; 219
    6526:	f8 4f       	sbci	r31, 0xF8	; 248
    6528:	40 81       	ld	r20, Z
    652a:	51 81       	ldd	r21, Z+1	; 0x01
    652c:	01 e0       	ldi	r16, 0x01	; 1
    652e:	80 91 3c 05 	lds	r24, 0x053C
    6532:	83 30       	cpi	r24, 0x03	; 3
    6534:	09 f0       	breq	.+2      	; 0x6538 <_hSelfLeveling+0x320>
    6536:	00 e0       	ldi	r16, 0x00	; 0
    6538:	82 e0       	ldi	r24, 0x02	; 2
    653a:	6e e1       	ldi	r22, 0x1E	; 30
    653c:	23 e0       	ldi	r18, 0x03	; 3
    653e:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <LCD_WriteValue>
	LCD_WriteValue(2,84,Config.AccParams[subindex]._ILimit,3,4==subpage);
    6542:	80 91 3d 05 	lds	r24, 0x053D
    6546:	90 e0       	ldi	r25, 0x00	; 0
    6548:	88 0f       	add	r24, r24
    654a:	99 1f       	adc	r25, r25
    654c:	fc 01       	movw	r30, r24
    654e:	73 e0       	ldi	r23, 0x03	; 3
    6550:	ee 0f       	add	r30, r30
    6552:	ff 1f       	adc	r31, r31
    6554:	7a 95       	dec	r23
    6556:	e1 f7       	brne	.-8      	; 0x6550 <_hSelfLeveling+0x338>
    6558:	e8 1b       	sub	r30, r24
    655a:	f9 0b       	sbc	r31, r25
    655c:	e9 5d       	subi	r30, 0xD9	; 217
    655e:	f8 4f       	sbci	r31, 0xF8	; 248
    6560:	40 81       	ld	r20, Z
    6562:	51 81       	ldd	r21, Z+1	; 0x01
    6564:	01 e0       	ldi	r16, 0x01	; 1
    6566:	80 91 3c 05 	lds	r24, 0x053C
    656a:	84 30       	cpi	r24, 0x04	; 4
    656c:	09 f0       	breq	.+2      	; 0x6570 <_hSelfLeveling+0x358>
    656e:	00 e0       	ldi	r16, 0x00	; 0
    6570:	82 e0       	ldi	r24, 0x02	; 2
    6572:	64 e5       	ldi	r22, 0x54	; 84
    6574:	23 e0       	ldi	r18, 0x03	; 3
    6576:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <LCD_WriteValue>
	LCD_WriteValue(3,30,Config.AccParams[subindex]._D,3,5==subpage);
    657a:	80 91 3d 05 	lds	r24, 0x053D
    657e:	90 e0       	ldi	r25, 0x00	; 0
    6580:	88 0f       	add	r24, r24
    6582:	99 1f       	adc	r25, r25
    6584:	fc 01       	movw	r30, r24
    6586:	53 e0       	ldi	r21, 0x03	; 3
    6588:	ee 0f       	add	r30, r30
    658a:	ff 1f       	adc	r31, r31
    658c:	5a 95       	dec	r21
    658e:	e1 f7       	brne	.-8      	; 0x6588 <_hSelfLeveling+0x370>
    6590:	e8 1b       	sub	r30, r24
    6592:	f9 0b       	sbc	r31, r25
    6594:	e7 5d       	subi	r30, 0xD7	; 215
    6596:	f8 4f       	sbci	r31, 0xF8	; 248
    6598:	40 81       	ld	r20, Z
    659a:	51 81       	ldd	r21, Z+1	; 0x01
    659c:	01 e0       	ldi	r16, 0x01	; 1
    659e:	80 91 3c 05 	lds	r24, 0x053C
    65a2:	85 30       	cpi	r24, 0x05	; 5
    65a4:	09 f0       	breq	.+2      	; 0x65a8 <_hSelfLeveling+0x390>
    65a6:	00 e0       	ldi	r16, 0x00	; 0
    65a8:	83 e0       	ldi	r24, 0x03	; 3
    65aa:	6e e1       	ldi	r22, 0x1E	; 30
    65ac:	23 e0       	ldi	r18, 0x03	; 3
    65ae:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <LCD_WriteValue>
	LCD_WriteValue(3,84,Config.AccParams[subindex]._DLimit,3,6==subpage);
    65b2:	80 91 3d 05 	lds	r24, 0x053D
    65b6:	90 e0       	ldi	r25, 0x00	; 0
    65b8:	88 0f       	add	r24, r24
    65ba:	99 1f       	adc	r25, r25
    65bc:	fc 01       	movw	r30, r24
    65be:	33 e0       	ldi	r19, 0x03	; 3
    65c0:	ee 0f       	add	r30, r30
    65c2:	ff 1f       	adc	r31, r31
    65c4:	3a 95       	dec	r19
    65c6:	e1 f7       	brne	.-8      	; 0x65c0 <_hSelfLeveling+0x3a8>
    65c8:	e8 1b       	sub	r30, r24
    65ca:	f9 0b       	sbc	r31, r25
    65cc:	e5 5d       	subi	r30, 0xD5	; 213
    65ce:	f8 4f       	sbci	r31, 0xF8	; 248
    65d0:	40 81       	ld	r20, Z
    65d2:	51 81       	ldd	r21, Z+1	; 0x01
    65d4:	01 e0       	ldi	r16, 0x01	; 1
    65d6:	80 91 3c 05 	lds	r24, 0x053C
    65da:	86 30       	cpi	r24, 0x06	; 6
    65dc:	09 f0       	breq	.+2      	; 0x65e0 <_hSelfLeveling+0x3c8>
    65de:	00 e0       	ldi	r16, 0x00	; 0
    65e0:	83 e0       	ldi	r24, 0x03	; 3
    65e2:	64 e5       	ldi	r22, 0x54	; 84
    65e4:	23 e0       	ldi	r18, 0x03	; 3
    65e6:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <LCD_WriteValue>
	LCD_WriteValue(4,84,Config.AccParams[subindex].ComplementaryFilterAlpha,3,7==subpage);
    65ea:	80 91 3d 05 	lds	r24, 0x053D
    65ee:	90 e0       	ldi	r25, 0x00	; 0
    65f0:	88 0f       	add	r24, r24
    65f2:	99 1f       	adc	r25, r25
    65f4:	fc 01       	movw	r30, r24
    65f6:	03 e0       	ldi	r16, 0x03	; 3
    65f8:	ee 0f       	add	r30, r30
    65fa:	ff 1f       	adc	r31, r31
    65fc:	0a 95       	dec	r16
    65fe:	e1 f7       	brne	.-8      	; 0x65f8 <_hSelfLeveling+0x3e0>
    6600:	e8 1b       	sub	r30, r24
    6602:	f9 0b       	sbc	r31, r25
    6604:	e3 5d       	subi	r30, 0xD3	; 211
    6606:	f8 4f       	sbci	r31, 0xF8	; 248
    6608:	40 81       	ld	r20, Z
    660a:	51 81       	ldd	r21, Z+1	; 0x01
    660c:	01 e0       	ldi	r16, 0x01	; 1
    660e:	80 91 3c 05 	lds	r24, 0x053C
    6612:	87 30       	cpi	r24, 0x07	; 7
    6614:	09 f0       	breq	.+2      	; 0x6618 <_hSelfLeveling+0x400>
    6616:	00 e0       	ldi	r16, 0x00	; 0
    6618:	84 e0       	ldi	r24, 0x04	; 4
    661a:	64 e5       	ldi	r22, 0x54	; 84
    661c:	23 e0       	ldi	r18, 0x03	; 3
    661e:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <LCD_WriteValue>
	
}
    6622:	0f 91       	pop	r16
    6624:	08 95       	ret

00006626 <_hStabilization>:

/*
* check : http://code.google.com/p/ardupirates/wiki/PID_Setting_SuperStable_Code
*/ 
void _hStabilization()
{
    6626:	ef 92       	push	r14
    6628:	0f 93       	push	r16
	NOKEYRETURN;
    662a:	80 91 ba 05 	lds	r24, 0x05BA
    662e:	88 23       	and	r24, r24
    6630:	09 f4       	brne	.+2      	; 0x6634 <_hStabilization+0xe>
    6632:	db c1       	rjmp	.+950    	; 0x69ea <_hStabilization+0x3c4>
	PageKey(9);
    6634:	89 e0       	ldi	r24, 0x09	; 9
    6636:	0e 94 47 30 	call	0x608e	; 0x608e <PageKey>
	
	if (KEY4)
    663a:	80 91 ba 05 	lds	r24, 0x05BA
    663e:	84 ff       	sbrs	r24, 4
    6640:	bb c0       	rjmp	.+374    	; 0x67b8 <_hStabilization+0x192>
	{
		if (subpage!=0) bValueChanged = true;
    6642:	20 91 3c 05 	lds	r18, 0x053C
    6646:	22 23       	and	r18, r18
    6648:	19 f0       	breq	.+6      	; 0x6650 <_hStabilization+0x2a>
    664a:	81 e0       	ldi	r24, 0x01	; 1
    664c:	80 93 38 05 	sts	0x0538, r24
		currentPage.softkeys = _skMENUSAVE;
    6650:	8e e2       	ldi	r24, 0x2E	; 46
    6652:	9c e0       	ldi	r25, 0x0C	; 12
    6654:	90 93 43 05 	sts	0x0543, r25
    6658:	80 93 42 05 	sts	0x0542, r24
		
		switch (subpage)
    665c:	24 30       	cpi	r18, 0x04	; 4
    665e:	09 f4       	brne	.+2      	; 0x6662 <_hStabilization+0x3c>
    6660:	53 c0       	rjmp	.+166    	; 0x6708 <_hStabilization+0xe2>
    6662:	25 30       	cpi	r18, 0x05	; 5
    6664:	50 f4       	brcc	.+20     	; 0x667a <_hStabilization+0x54>
    6666:	21 30       	cpi	r18, 0x01	; 1
    6668:	d1 f0       	breq	.+52     	; 0x669e <_hStabilization+0x78>
    666a:	21 30       	cpi	r18, 0x01	; 1
    666c:	98 f0       	brcs	.+38     	; 0x6694 <_hStabilization+0x6e>
    666e:	22 30       	cpi	r18, 0x02	; 2
    6670:	39 f1       	breq	.+78     	; 0x66c0 <_hStabilization+0x9a>
    6672:	23 30       	cpi	r18, 0x03	; 3
    6674:	09 f0       	breq	.+2      	; 0x6678 <_hStabilization+0x52>
    6676:	a0 c0       	rjmp	.+320    	; 0x67b8 <_hStabilization+0x192>
    6678:	34 c0       	rjmp	.+104    	; 0x66e2 <_hStabilization+0xbc>
    667a:	26 30       	cpi	r18, 0x06	; 6
    667c:	09 f4       	brne	.+2      	; 0x6680 <_hStabilization+0x5a>
    667e:	66 c0       	rjmp	.+204    	; 0x674c <_hStabilization+0x126>
    6680:	26 30       	cpi	r18, 0x06	; 6
    6682:	08 f4       	brcc	.+2      	; 0x6686 <_hStabilization+0x60>
    6684:	52 c0       	rjmp	.+164    	; 0x672a <_hStabilization+0x104>
    6686:	27 30       	cpi	r18, 0x07	; 7
    6688:	09 f4       	brne	.+2      	; 0x668c <_hStabilization+0x66>
    668a:	75 c0       	rjmp	.+234    	; 0x6776 <_hStabilization+0x150>
    668c:	28 30       	cpi	r18, 0x08	; 8
    668e:	09 f0       	breq	.+2      	; 0x6692 <_hStabilization+0x6c>
    6690:	93 c0       	rjmp	.+294    	; 0x67b8 <_hStabilization+0x192>
    6692:	89 c0       	rjmp	.+274    	; 0x67a6 <_hStabilization+0x180>
		{
			case 0: _helper_SwitchPitchRollYaw(&subindex); break;
    6694:	8d e3       	ldi	r24, 0x3D	; 61
    6696:	95 e0       	ldi	r25, 0x05	; 5
    6698:	0e 94 b5 2b 	call	0x576a	; 0x576a <_helper_SwitchPitchRollYaw>
    669c:	8d c0       	rjmp	.+282    	; 0x67b8 <_hStabilization+0x192>
			case 1: startEditMode(&(Config.GyroParams[subindex]._P),-500,500,TYPE_INT16); return ;
    669e:	80 91 3d 05 	lds	r24, 0x053D
    66a2:	90 e0       	ldi	r25, 0x00	; 0
    66a4:	9c 01       	movw	r18, r24
    66a6:	22 0f       	add	r18, r18
    66a8:	33 1f       	adc	r19, r19
    66aa:	c9 01       	movw	r24, r18
    66ac:	63 e0       	ldi	r22, 0x03	; 3
    66ae:	88 0f       	add	r24, r24
    66b0:	99 1f       	adc	r25, r25
    66b2:	6a 95       	dec	r22
    66b4:	e1 f7       	brne	.-8      	; 0x66ae <_hStabilization+0x88>
    66b6:	82 1b       	sub	r24, r18
    66b8:	93 0b       	sbc	r25, r19
    66ba:	89 50       	subi	r24, 0x09	; 9
    66bc:	99 4f       	sbci	r25, 0xF9	; 249
    66be:	21 c0       	rjmp	.+66     	; 0x6702 <_hStabilization+0xdc>
			case 2: startEditMode(&(Config.GyroParams[subindex]._PLimit),0,500,TYPE_INT16); return ;
    66c0:	80 91 3d 05 	lds	r24, 0x053D
    66c4:	90 e0       	ldi	r25, 0x00	; 0
    66c6:	9c 01       	movw	r18, r24
    66c8:	22 0f       	add	r18, r18
    66ca:	33 1f       	adc	r19, r19
    66cc:	c9 01       	movw	r24, r18
    66ce:	43 e0       	ldi	r20, 0x03	; 3
    66d0:	88 0f       	add	r24, r24
    66d2:	99 1f       	adc	r25, r25
    66d4:	4a 95       	dec	r20
    66d6:	e1 f7       	brne	.-8      	; 0x66d0 <_hStabilization+0xaa>
    66d8:	82 1b       	sub	r24, r18
    66da:	93 0b       	sbc	r25, r19
    66dc:	87 50       	subi	r24, 0x07	; 7
    66de:	99 4f       	sbci	r25, 0xF9	; 249
    66e0:	45 c0       	rjmp	.+138    	; 0x676c <_hStabilization+0x146>
			case 3: startEditMode(&(Config.GyroParams[subindex]._I),-500,500,TYPE_INT16);  return ;
    66e2:	80 91 3d 05 	lds	r24, 0x053D
    66e6:	90 e0       	ldi	r25, 0x00	; 0
    66e8:	9c 01       	movw	r18, r24
    66ea:	22 0f       	add	r18, r18
    66ec:	33 1f       	adc	r19, r19
    66ee:	c9 01       	movw	r24, r18
    66f0:	03 e0       	ldi	r16, 0x03	; 3
    66f2:	88 0f       	add	r24, r24
    66f4:	99 1f       	adc	r25, r25
    66f6:	0a 95       	dec	r16
    66f8:	e1 f7       	brne	.-8      	; 0x66f2 <_hStabilization+0xcc>
    66fa:	82 1b       	sub	r24, r18
    66fc:	93 0b       	sbc	r25, r19
    66fe:	85 50       	subi	r24, 0x05	; 5
    6700:	99 4f       	sbci	r25, 0xF9	; 249
    6702:	6c e0       	ldi	r22, 0x0C	; 12
    6704:	7e ef       	ldi	r23, 0xFE	; 254
    6706:	34 c0       	rjmp	.+104    	; 0x6770 <_hStabilization+0x14a>
			case 4: startEditMode(&(Config.GyroParams[subindex]._ILimit),0,500,TYPE_INT16); return ;
    6708:	80 91 3d 05 	lds	r24, 0x053D
    670c:	90 e0       	ldi	r25, 0x00	; 0
    670e:	9c 01       	movw	r18, r24
    6710:	22 0f       	add	r18, r18
    6712:	33 1f       	adc	r19, r19
    6714:	c9 01       	movw	r24, r18
    6716:	a3 e0       	ldi	r26, 0x03	; 3
    6718:	88 0f       	add	r24, r24
    671a:	99 1f       	adc	r25, r25
    671c:	aa 95       	dec	r26
    671e:	e1 f7       	brne	.-8      	; 0x6718 <_hStabilization+0xf2>
    6720:	82 1b       	sub	r24, r18
    6722:	93 0b       	sbc	r25, r19
    6724:	83 50       	subi	r24, 0x03	; 3
    6726:	99 4f       	sbci	r25, 0xF9	; 249
    6728:	21 c0       	rjmp	.+66     	; 0x676c <_hStabilization+0x146>
			case 5: startEditMode(&(Config.GyroParams[subindex]._D),-500,500,TYPE_INT16);  return ; 
    672a:	80 91 3d 05 	lds	r24, 0x053D
    672e:	90 e0       	ldi	r25, 0x00	; 0
    6730:	9c 01       	movw	r18, r24
    6732:	22 0f       	add	r18, r18
    6734:	33 1f       	adc	r19, r19
    6736:	c9 01       	movw	r24, r18
    6738:	e3 e0       	ldi	r30, 0x03	; 3
    673a:	88 0f       	add	r24, r24
    673c:	99 1f       	adc	r25, r25
    673e:	ea 95       	dec	r30
    6740:	e1 f7       	brne	.-8      	; 0x673a <_hStabilization+0x114>
    6742:	82 1b       	sub	r24, r18
    6744:	93 0b       	sbc	r25, r19
    6746:	81 50       	subi	r24, 0x01	; 1
    6748:	99 4f       	sbci	r25, 0xF9	; 249
    674a:	db cf       	rjmp	.-74     	; 0x6702 <_hStabilization+0xdc>
			case 6: startEditMode(&(Config.GyroParams[subindex]._DLimit),0,500,TYPE_INT16); return ;
    674c:	80 91 3d 05 	lds	r24, 0x053D
    6750:	90 e0       	ldi	r25, 0x00	; 0
    6752:	9c 01       	movw	r18, r24
    6754:	22 0f       	add	r18, r18
    6756:	33 1f       	adc	r19, r19
    6758:	c9 01       	movw	r24, r18
    675a:	63 e0       	ldi	r22, 0x03	; 3
    675c:	88 0f       	add	r24, r24
    675e:	99 1f       	adc	r25, r25
    6760:	6a 95       	dec	r22
    6762:	e1 f7       	brne	.-8      	; 0x675c <_hStabilization+0x136>
    6764:	82 1b       	sub	r24, r18
    6766:	93 0b       	sbc	r25, r19
    6768:	8f 5f       	subi	r24, 0xFF	; 255
    676a:	98 4f       	sbci	r25, 0xF8	; 248
    676c:	60 e0       	ldi	r22, 0x00	; 0
    676e:	70 e0       	ldi	r23, 0x00	; 0
    6770:	44 ef       	ldi	r20, 0xF4	; 244
    6772:	51 e0       	ldi	r21, 0x01	; 1
    6774:	14 c0       	rjmp	.+40     	; 0x679e <_hStabilization+0x178>
			case 7: startEditMode(&(Config.GyroParams[subindex].ComplementaryFilterAlpha),0,999,TYPE_INT16); return ;
    6776:	80 91 3d 05 	lds	r24, 0x053D
    677a:	90 e0       	ldi	r25, 0x00	; 0
    677c:	9c 01       	movw	r18, r24
    677e:	22 0f       	add	r18, r18
    6780:	33 1f       	adc	r19, r19
    6782:	c9 01       	movw	r24, r18
    6784:	43 e0       	ldi	r20, 0x03	; 3
    6786:	88 0f       	add	r24, r24
    6788:	99 1f       	adc	r25, r25
    678a:	4a 95       	dec	r20
    678c:	e1 f7       	brne	.-8      	; 0x6786 <_hStabilization+0x160>
    678e:	82 1b       	sub	r24, r18
    6790:	93 0b       	sbc	r25, r19
    6792:	8d 5f       	subi	r24, 0xFD	; 253
    6794:	98 4f       	sbci	r25, 0xF8	; 248
    6796:	60 e0       	ldi	r22, 0x00	; 0
    6798:	70 e0       	ldi	r23, 0x00	; 0
    679a:	47 ee       	ldi	r20, 0xE7	; 231
    679c:	53 e0       	ldi	r21, 0x03	; 3
    679e:	23 e0       	ldi	r18, 0x03	; 3
    67a0:	0e 94 f9 2f 	call	0x5ff2	; 0x5ff2 <startEditMode>
    67a4:	22 c1       	rjmp	.+580    	; 0x69ea <_hStabilization+0x3c4>
			case 8: if (Config.ReverseYAW==GYRO_NORMAL) Config.ReverseYAW =GYRO_REVERSE; else Config.ReverseYAW = GYRO_NORMAL; break; // update the UI
    67a6:	80 91 ae 07 	lds	r24, 0x07AE
    67aa:	81 30       	cpi	r24, 0x01	; 1
    67ac:	11 f4       	brne	.+4      	; 0x67b2 <_hStabilization+0x18c>
    67ae:	8f ef       	ldi	r24, 0xFF	; 255
    67b0:	01 c0       	rjmp	.+2      	; 0x67b4 <_hStabilization+0x18e>
    67b2:	81 e0       	ldi	r24, 0x01	; 1
    67b4:	80 93 ae 07 	sts	0x07AE, r24
		}
		
		
	}
	
	if (KEY1)
    67b8:	80 91 ba 05 	lds	r24, 0x05BA
    67bc:	87 ff       	sbrs	r24, 7
    67be:	0f c0       	rjmp	.+30     	; 0x67de <_hStabilization+0x1b8>
	{
		if (Config.PitchRollLinked==1)
    67c0:	80 91 af 07 	lds	r24, 0x07AF
    67c4:	81 30       	cpi	r24, 0x01	; 1
    67c6:	49 f4       	brne	.+18     	; 0x67da <_hStabilization+0x1b4>
		{
			memcpy(&(Config.GyroParams[ROLL_INDEX]),&(Config.GyroParams[PITCH_INDEX]), sizeof(pid_param_t));
    67c8:	e5 e0       	ldi	r30, 0x05	; 5
    67ca:	f7 e0       	ldi	r31, 0x07	; 7
    67cc:	df 01       	movw	r26, r30
    67ce:	1e 97       	sbiw	r26, 0x0e	; 14
    67d0:	8e e0       	ldi	r24, 0x0E	; 14
    67d2:	0d 90       	ld	r0, X+
    67d4:	01 92       	st	Z+, r0
    67d6:	81 50       	subi	r24, 0x01	; 1
    67d8:	e1 f7       	brne	.-8      	; 0x67d2 <_hStabilization+0x1ac>
		}
		
		_helper_SaveinEEPROM_ifChanged();
    67da:	0e 94 f5 2b 	call	0x57ea	; 0x57ea <_helper_SaveinEEPROM_ifChanged>
	}
	
	lcdReverse(subpage == 0);
    67de:	81 e0       	ldi	r24, 0x01	; 1
    67e0:	90 91 3c 05 	lds	r25, 0x053C
    67e4:	91 11       	cpse	r25, r1
    67e6:	80 e0       	ldi	r24, 0x00	; 0
    67e8:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <lcdReverse>
	_helper_DisplayPitchRollYaw(subindex);
    67ec:	80 91 3d 05 	lds	r24, 0x053D
    67f0:	0e 94 92 2b 	call	0x5724	; 0x5724 <_helper_DisplayPitchRollYaw>
	LCD_WriteString_Pex(5,0,PSTR("                "),16,false);    
    67f4:	85 e0       	ldi	r24, 0x05	; 5
    67f6:	60 e0       	ldi	r22, 0x00	; 0
    67f8:	49 ea       	ldi	r20, 0xA9	; 169
    67fa:	5c e0       	ldi	r21, 0x0C	; 12
    67fc:	20 e1       	ldi	r18, 0x10	; 16
    67fe:	00 e0       	ldi	r16, 0x00	; 0
    6800:	0e 94 a4 0d 	call	0x1b48	; 0x1b48 <LCD_WriteString_Pex>
	
	if ((subindex==2) && (Config.FrameType == FRAMETYPE_TRICOPTER))
    6804:	80 91 3d 05 	lds	r24, 0x053D
    6808:	82 30       	cpi	r24, 0x02	; 2
    680a:	01 f5       	brne	.+64     	; 0x684c <_hStabilization+0x226>
    680c:	80 91 f0 06 	lds	r24, 0x06F0
    6810:	82 30       	cpi	r24, 0x02	; 2
    6812:	e1 f4       	brne	.+56     	; 0x684c <_hStabilization+0x226>
	{
		LCD_WriteString_Pex(5,0,PSTR("Reverse GYRO"),12,false);    
    6814:	85 e0       	ldi	r24, 0x05	; 5
    6816:	60 e0       	ldi	r22, 0x00	; 0
    6818:	4c e9       	ldi	r20, 0x9C	; 156
    681a:	5c e0       	ldi	r21, 0x0C	; 12
    681c:	2c e0       	ldi	r18, 0x0C	; 12
    681e:	0e 94 a4 0d 	call	0x1b48	; 0x1b48 <LCD_WriteString_Pex>
		_helper_DisplayBiStateText(5,84 ,PSTR("N"), PSTR("R"), Config.ReverseYAW==GYRO_NORMAL, 8==subpage);
    6822:	01 e0       	ldi	r16, 0x01	; 1
    6824:	80 91 ae 07 	lds	r24, 0x07AE
    6828:	81 30       	cpi	r24, 0x01	; 1
    682a:	09 f0       	breq	.+2      	; 0x682e <_hStabilization+0x208>
    682c:	00 e0       	ldi	r16, 0x00	; 0
    682e:	91 e0       	ldi	r25, 0x01	; 1
    6830:	80 91 3c 05 	lds	r24, 0x053C
    6834:	88 30       	cpi	r24, 0x08	; 8
    6836:	09 f0       	breq	.+2      	; 0x683a <_hStabilization+0x214>
    6838:	90 e0       	ldi	r25, 0x00	; 0
    683a:	85 e0       	ldi	r24, 0x05	; 5
    683c:	64 e5       	ldi	r22, 0x54	; 84
    683e:	4a e9       	ldi	r20, 0x9A	; 154
    6840:	5c e0       	ldi	r21, 0x0C	; 12
    6842:	28 e9       	ldi	r18, 0x98	; 152
    6844:	3c e0       	ldi	r19, 0x0C	; 12
    6846:	e9 2e       	mov	r14, r25
    6848:	0e 94 c9 2b 	call	0x5792	; 0x5792 <_helper_DisplayBiStateText>
	}		

	
	LCD_WriteStringex (0,0,sXDeg,0==subpage);
    684c:	21 e0       	ldi	r18, 0x01	; 1
    684e:	80 91 3c 05 	lds	r24, 0x053C
    6852:	81 11       	cpse	r24, r1
    6854:	20 e0       	ldi	r18, 0x00	; 0
    6856:	80 e0       	ldi	r24, 0x00	; 0
    6858:	60 e0       	ldi	r22, 0x00	; 0
    685a:	4a ee       	ldi	r20, 0xEA	; 234
    685c:	55 e0       	ldi	r21, 0x05	; 5
    685e:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <LCD_WriteStringex>
	LCD_WriteValue(1,30,Config.GyroParams[subindex]._P,3,1==subpage);
    6862:	80 91 3d 05 	lds	r24, 0x053D
    6866:	90 e0       	ldi	r25, 0x00	; 0
    6868:	88 0f       	add	r24, r24
    686a:	99 1f       	adc	r25, r25
    686c:	fc 01       	movw	r30, r24
    686e:	03 e0       	ldi	r16, 0x03	; 3
    6870:	ee 0f       	add	r30, r30
    6872:	ff 1f       	adc	r31, r31
    6874:	0a 95       	dec	r16
    6876:	e1 f7       	brne	.-8      	; 0x6870 <_hStabilization+0x24a>
    6878:	e8 1b       	sub	r30, r24
    687a:	f9 0b       	sbc	r31, r25
    687c:	e9 51       	subi	r30, 0x19	; 25
    687e:	f9 4f       	sbci	r31, 0xF9	; 249
    6880:	40 89       	ldd	r20, Z+16	; 0x10
    6882:	51 89       	ldd	r21, Z+17	; 0x11
    6884:	01 e0       	ldi	r16, 0x01	; 1
    6886:	80 91 3c 05 	lds	r24, 0x053C
    688a:	81 30       	cpi	r24, 0x01	; 1
    688c:	09 f0       	breq	.+2      	; 0x6890 <_hStabilization+0x26a>
    688e:	00 e0       	ldi	r16, 0x00	; 0
    6890:	81 e0       	ldi	r24, 0x01	; 1
    6892:	6e e1       	ldi	r22, 0x1E	; 30
    6894:	23 e0       	ldi	r18, 0x03	; 3
    6896:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <LCD_WriteValue>
	LCD_WriteValue(1,84,Config.GyroParams[subindex]._PLimit,3,2==subpage);
    689a:	80 91 3d 05 	lds	r24, 0x053D
    689e:	90 e0       	ldi	r25, 0x00	; 0
    68a0:	88 0f       	add	r24, r24
    68a2:	99 1f       	adc	r25, r25
    68a4:	fc 01       	movw	r30, r24
    68a6:	a3 e0       	ldi	r26, 0x03	; 3
    68a8:	ee 0f       	add	r30, r30
    68aa:	ff 1f       	adc	r31, r31
    68ac:	aa 95       	dec	r26
    68ae:	e1 f7       	brne	.-8      	; 0x68a8 <_hStabilization+0x282>
    68b0:	e8 1b       	sub	r30, r24
    68b2:	f9 0b       	sbc	r31, r25
    68b4:	e9 51       	subi	r30, 0x19	; 25
    68b6:	f9 4f       	sbci	r31, 0xF9	; 249
    68b8:	42 89       	ldd	r20, Z+18	; 0x12
    68ba:	53 89       	ldd	r21, Z+19	; 0x13
    68bc:	01 e0       	ldi	r16, 0x01	; 1
    68be:	80 91 3c 05 	lds	r24, 0x053C
    68c2:	82 30       	cpi	r24, 0x02	; 2
    68c4:	09 f0       	breq	.+2      	; 0x68c8 <_hStabilization+0x2a2>
    68c6:	00 e0       	ldi	r16, 0x00	; 0
    68c8:	81 e0       	ldi	r24, 0x01	; 1
    68ca:	64 e5       	ldi	r22, 0x54	; 84
    68cc:	23 e0       	ldi	r18, 0x03	; 3
    68ce:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <LCD_WriteValue>
	LCD_WriteValue(2,30,Config.GyroParams[subindex]._I,3,3==subpage);
    68d2:	80 91 3d 05 	lds	r24, 0x053D
    68d6:	90 e0       	ldi	r25, 0x00	; 0
    68d8:	88 0f       	add	r24, r24
    68da:	99 1f       	adc	r25, r25
    68dc:	fc 01       	movw	r30, r24
    68de:	73 e0       	ldi	r23, 0x03	; 3
    68e0:	ee 0f       	add	r30, r30
    68e2:	ff 1f       	adc	r31, r31
    68e4:	7a 95       	dec	r23
    68e6:	e1 f7       	brne	.-8      	; 0x68e0 <_hStabilization+0x2ba>
    68e8:	e8 1b       	sub	r30, r24
    68ea:	f9 0b       	sbc	r31, r25
    68ec:	e9 51       	subi	r30, 0x19	; 25
    68ee:	f9 4f       	sbci	r31, 0xF9	; 249
    68f0:	44 89       	ldd	r20, Z+20	; 0x14
    68f2:	55 89       	ldd	r21, Z+21	; 0x15
    68f4:	01 e0       	ldi	r16, 0x01	; 1
    68f6:	80 91 3c 05 	lds	r24, 0x053C
    68fa:	83 30       	cpi	r24, 0x03	; 3
    68fc:	09 f0       	breq	.+2      	; 0x6900 <_hStabilization+0x2da>
    68fe:	00 e0       	ldi	r16, 0x00	; 0
    6900:	82 e0       	ldi	r24, 0x02	; 2
    6902:	6e e1       	ldi	r22, 0x1E	; 30
    6904:	23 e0       	ldi	r18, 0x03	; 3
    6906:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <LCD_WriteValue>
	LCD_WriteValue(2,84,Config.GyroParams[subindex]._ILimit,3,4==subpage);
    690a:	80 91 3d 05 	lds	r24, 0x053D
    690e:	90 e0       	ldi	r25, 0x00	; 0
    6910:	88 0f       	add	r24, r24
    6912:	99 1f       	adc	r25, r25
    6914:	fc 01       	movw	r30, r24
    6916:	53 e0       	ldi	r21, 0x03	; 3
    6918:	ee 0f       	add	r30, r30
    691a:	ff 1f       	adc	r31, r31
    691c:	5a 95       	dec	r21
    691e:	e1 f7       	brne	.-8      	; 0x6918 <_hStabilization+0x2f2>
    6920:	e8 1b       	sub	r30, r24
    6922:	f9 0b       	sbc	r31, r25
    6924:	e9 51       	subi	r30, 0x19	; 25
    6926:	f9 4f       	sbci	r31, 0xF9	; 249
    6928:	46 89       	ldd	r20, Z+22	; 0x16
    692a:	57 89       	ldd	r21, Z+23	; 0x17
    692c:	01 e0       	ldi	r16, 0x01	; 1
    692e:	80 91 3c 05 	lds	r24, 0x053C
    6932:	84 30       	cpi	r24, 0x04	; 4
    6934:	09 f0       	breq	.+2      	; 0x6938 <_hStabilization+0x312>
    6936:	00 e0       	ldi	r16, 0x00	; 0
    6938:	82 e0       	ldi	r24, 0x02	; 2
    693a:	64 e5       	ldi	r22, 0x54	; 84
    693c:	23 e0       	ldi	r18, 0x03	; 3
    693e:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <LCD_WriteValue>
	LCD_WriteValue(3,30,Config.GyroParams[subindex]._D,3,5==subpage);
    6942:	80 91 3d 05 	lds	r24, 0x053D
    6946:	90 e0       	ldi	r25, 0x00	; 0
    6948:	88 0f       	add	r24, r24
    694a:	99 1f       	adc	r25, r25
    694c:	fc 01       	movw	r30, r24
    694e:	33 e0       	ldi	r19, 0x03	; 3
    6950:	ee 0f       	add	r30, r30
    6952:	ff 1f       	adc	r31, r31
    6954:	3a 95       	dec	r19
    6956:	e1 f7       	brne	.-8      	; 0x6950 <_hStabilization+0x32a>
    6958:	e8 1b       	sub	r30, r24
    695a:	f9 0b       	sbc	r31, r25
    695c:	e9 51       	subi	r30, 0x19	; 25
    695e:	f9 4f       	sbci	r31, 0xF9	; 249
    6960:	40 8d       	ldd	r20, Z+24	; 0x18
    6962:	51 8d       	ldd	r21, Z+25	; 0x19
    6964:	01 e0       	ldi	r16, 0x01	; 1
    6966:	80 91 3c 05 	lds	r24, 0x053C
    696a:	85 30       	cpi	r24, 0x05	; 5
    696c:	09 f0       	breq	.+2      	; 0x6970 <_hStabilization+0x34a>
    696e:	00 e0       	ldi	r16, 0x00	; 0
    6970:	83 e0       	ldi	r24, 0x03	; 3
    6972:	6e e1       	ldi	r22, 0x1E	; 30
    6974:	23 e0       	ldi	r18, 0x03	; 3
    6976:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <LCD_WriteValue>
	LCD_WriteValue(3,84,Config.GyroParams[subindex]._DLimit,3,6==subpage);
    697a:	80 91 3d 05 	lds	r24, 0x053D
    697e:	90 e0       	ldi	r25, 0x00	; 0
    6980:	88 0f       	add	r24, r24
    6982:	99 1f       	adc	r25, r25
    6984:	fc 01       	movw	r30, r24
    6986:	03 e0       	ldi	r16, 0x03	; 3
    6988:	ee 0f       	add	r30, r30
    698a:	ff 1f       	adc	r31, r31
    698c:	0a 95       	dec	r16
    698e:	e1 f7       	brne	.-8      	; 0x6988 <_hStabilization+0x362>
    6990:	e8 1b       	sub	r30, r24
    6992:	f9 0b       	sbc	r31, r25
    6994:	e9 51       	subi	r30, 0x19	; 25
    6996:	f9 4f       	sbci	r31, 0xF9	; 249
    6998:	42 8d       	ldd	r20, Z+26	; 0x1a
    699a:	53 8d       	ldd	r21, Z+27	; 0x1b
    699c:	01 e0       	ldi	r16, 0x01	; 1
    699e:	80 91 3c 05 	lds	r24, 0x053C
    69a2:	86 30       	cpi	r24, 0x06	; 6
    69a4:	09 f0       	breq	.+2      	; 0x69a8 <_hStabilization+0x382>
    69a6:	00 e0       	ldi	r16, 0x00	; 0
    69a8:	83 e0       	ldi	r24, 0x03	; 3
    69aa:	64 e5       	ldi	r22, 0x54	; 84
    69ac:	23 e0       	ldi	r18, 0x03	; 3
    69ae:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <LCD_WriteValue>
	LCD_WriteValue(4,84,Config.GyroParams[subindex].ComplementaryFilterAlpha,3,7==subpage);
    69b2:	80 91 3d 05 	lds	r24, 0x053D
    69b6:	90 e0       	ldi	r25, 0x00	; 0
    69b8:	88 0f       	add	r24, r24
    69ba:	99 1f       	adc	r25, r25
    69bc:	fc 01       	movw	r30, r24
    69be:	a3 e0       	ldi	r26, 0x03	; 3
    69c0:	ee 0f       	add	r30, r30
    69c2:	ff 1f       	adc	r31, r31
    69c4:	aa 95       	dec	r26
    69c6:	e1 f7       	brne	.-8      	; 0x69c0 <_hStabilization+0x39a>
    69c8:	e8 1b       	sub	r30, r24
    69ca:	f9 0b       	sbc	r31, r25
    69cc:	e9 51       	subi	r30, 0x19	; 25
    69ce:	f9 4f       	sbci	r31, 0xF9	; 249
    69d0:	44 8d       	ldd	r20, Z+28	; 0x1c
    69d2:	55 8d       	ldd	r21, Z+29	; 0x1d
    69d4:	01 e0       	ldi	r16, 0x01	; 1
    69d6:	80 91 3c 05 	lds	r24, 0x053C
    69da:	87 30       	cpi	r24, 0x07	; 7
    69dc:	09 f0       	breq	.+2      	; 0x69e0 <_hStabilization+0x3ba>
    69de:	00 e0       	ldi	r16, 0x00	; 0
    69e0:	84 e0       	ldi	r24, 0x04	; 4
    69e2:	64 e5       	ldi	r22, 0x54	; 84
    69e4:	23 e0       	ldi	r18, 0x03	; 3
    69e6:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <LCD_WriteValue>
	
	
}
    69ea:	0f 91       	pop	r16
    69ec:	ef 90       	pop	r14
    69ee:	08 95       	ret

000069f0 <_hMiscSettings>:
	_helper_DisplayBiStateText(4,84, strYes, strNo, (IS_MISC_SENSOR_SONAR_ENABLED ==true),(subpage==4));
}


void _hMiscSettings()
{
    69f0:	cf 92       	push	r12
    69f2:	ef 92       	push	r14
    69f4:	ff 92       	push	r15
    69f6:	0f 93       	push	r16
    69f8:	1f 93       	push	r17
	NOKEYRETURN;
    69fa:	80 91 ba 05 	lds	r24, 0x05BA
    69fe:	88 23       	and	r24, r24
    6a00:	09 f4       	brne	.+2      	; 0x6a04 <_hMiscSettings+0x14>
    6a02:	a8 c0       	rjmp	.+336    	; 0x6b54 <_hMiscSettings+0x164>
	PageKey(5);
    6a04:	85 e0       	ldi	r24, 0x05	; 5
    6a06:	0e 94 47 30 	call	0x608e	; 0x608e <PageKey>
	
		
	if (KEY4)
    6a0a:	20 91 ba 05 	lds	r18, 0x05BA
    6a0e:	24 ff       	sbrs	r18, 4
    6a10:	3f c0       	rjmp	.+126    	; 0x6a90 <_hMiscSettings+0xa0>
	{
		bValueChanged = true;
    6a12:	81 e0       	ldi	r24, 0x01	; 1
    6a14:	80 93 38 05 	sts	0x0538, r24
		currentPage.softkeys = _skMENUSAVE;
    6a18:	8e e2       	ldi	r24, 0x2E	; 46
    6a1a:	9c e0       	ldi	r25, 0x0C	; 12
    6a1c:	90 93 43 05 	sts	0x0543, r25
    6a20:	80 93 42 05 	sts	0x0542, r24
		
		switch (subpage)
    6a24:	80 91 3c 05 	lds	r24, 0x053C
    6a28:	82 30       	cpi	r24, 0x02	; 2
    6a2a:	d1 f0       	breq	.+52     	; 0x6a60 <_hMiscSettings+0x70>
    6a2c:	83 30       	cpi	r24, 0x03	; 3
    6a2e:	28 f4       	brcc	.+10     	; 0x6a3a <_hMiscSettings+0x4a>
    6a30:	88 23       	and	r24, r24
    6a32:	41 f0       	breq	.+16     	; 0x6a44 <_hMiscSettings+0x54>
    6a34:	81 30       	cpi	r24, 0x01	; 1
    6a36:	61 f5       	brne	.+88     	; 0x6a90 <_hMiscSettings+0xa0>
    6a38:	0c c0       	rjmp	.+24     	; 0x6a52 <_hMiscSettings+0x62>
    6a3a:	83 30       	cpi	r24, 0x03	; 3
    6a3c:	c1 f0       	breq	.+48     	; 0x6a6e <_hMiscSettings+0x7e>
    6a3e:	84 30       	cpi	r24, 0x04	; 4
    6a40:	39 f5       	brne	.+78     	; 0x6a90 <_hMiscSettings+0xa0>
    6a42:	1f c0       	rjmp	.+62     	; 0x6a82 <_hMiscSettings+0x92>
		{
			case 0: startEditMode(&(Config.AutoDisarm),0,10,TYPE_UINT8); return ;
    6a44:	8e ee       	ldi	r24, 0xEE	; 238
    6a46:	96 e0       	ldi	r25, 0x06	; 6
    6a48:	60 e0       	ldi	r22, 0x00	; 0
    6a4a:	70 e0       	ldi	r23, 0x00	; 0
    6a4c:	4a e0       	ldi	r20, 0x0A	; 10
    6a4e:	50 e0       	ldi	r21, 0x00	; 0
    6a50:	14 c0       	rjmp	.+40     	; 0x6a7a <_hMiscSettings+0x8a>
			case 1: startEditMode(&(Config.VoltageAlarm),0,120,TYPE_UINT8);  return ;
    6a52:	89 e5       	ldi	r24, 0x59	; 89
    6a54:	97 e0       	ldi	r25, 0x07	; 7
    6a56:	60 e0       	ldi	r22, 0x00	; 0
    6a58:	70 e0       	ldi	r23, 0x00	; 0
    6a5a:	48 e7       	ldi	r20, 0x78	; 120
    6a5c:	50 e0       	ldi	r21, 0x00	; 0
    6a5e:	0d c0       	rjmp	.+26     	; 0x6a7a <_hMiscSettings+0x8a>
			case 2: startEditMode(&(Config.ThrottleMin),0,255,TYPE_UINT8);  return ;
    6a60:	84 ef       	ldi	r24, 0xF4	; 244
    6a62:	96 e0       	ldi	r25, 0x06	; 6
    6a64:	60 e0       	ldi	r22, 0x00	; 0
    6a66:	70 e0       	ldi	r23, 0x00	; 0
    6a68:	4f ef       	ldi	r20, 0xFF	; 255
    6a6a:	50 e0       	ldi	r21, 0x00	; 0
    6a6c:	06 c0       	rjmp	.+12     	; 0x6a7a <_hMiscSettings+0x8a>
			case 3: startEditMode(&(Config.StickScaling),1,20,TYPE_UINT8);  return ;
    6a6e:	85 ef       	ldi	r24, 0xF5	; 245
    6a70:	96 e0       	ldi	r25, 0x06	; 6
    6a72:	61 e0       	ldi	r22, 0x01	; 1
    6a74:	70 e0       	ldi	r23, 0x00	; 0
    6a76:	44 e1       	ldi	r20, 0x14	; 20
    6a78:	50 e0       	ldi	r21, 0x00	; 0
    6a7a:	22 e0       	ldi	r18, 0x02	; 2
    6a7c:	0e 94 f9 2f 	call	0x5ff2	; 0x5ff2 <startEditMode>
    6a80:	69 c0       	rjmp	.+210    	; 0x6b54 <_hMiscSettings+0x164>
			case 4:	Config.PitchRollLinked=  ((~Config.PitchRollLinked) & 0x01); break; 
    6a82:	90 91 af 07 	lds	r25, 0x07AF
    6a86:	81 e0       	ldi	r24, 0x01	; 1
    6a88:	90 fd       	sbrc	r25, 0
    6a8a:	80 e0       	ldi	r24, 0x00	; 0
    6a8c:	80 93 af 07 	sts	0x07AF, r24
		}
		
	}
	
	if (KEY1)
    6a90:	27 ff       	sbrs	r18, 7
    6a92:	02 c0       	rjmp	.+4      	; 0x6a98 <_hMiscSettings+0xa8>
	{
		_helper_SaveinEEPROM_ifChanged();
    6a94:	0e 94 f5 2b 	call	0x57ea	; 0x57ea <_helper_SaveinEEPROM_ifChanged>
	}
	
	LCD_WriteValue(0,84,Config.AutoDisarm,3,0==subpage);
    6a98:	40 91 ee 06 	lds	r20, 0x06EE
    6a9c:	01 e0       	ldi	r16, 0x01	; 1
    6a9e:	80 91 3c 05 	lds	r24, 0x053C
    6aa2:	81 11       	cpse	r24, r1
    6aa4:	00 e0       	ldi	r16, 0x00	; 0
    6aa6:	80 e0       	ldi	r24, 0x00	; 0
    6aa8:	64 e5       	ldi	r22, 0x54	; 84
    6aaa:	50 e0       	ldi	r21, 0x00	; 0
    6aac:	23 e0       	ldi	r18, 0x03	; 3
    6aae:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <LCD_WriteValue>
	double volt = (double)(Config.VoltageAlarm/10.0f);
    6ab2:	60 91 59 07 	lds	r22, 0x0759
    6ab6:	70 e0       	ldi	r23, 0x00	; 0
    6ab8:	88 27       	eor	r24, r24
    6aba:	77 fd       	sbrc	r23, 7
    6abc:	80 95       	com	r24
    6abe:	98 2f       	mov	r25, r24
    6ac0:	0e 94 95 38 	call	0x712a	; 0x712a <__floatsisf>
    6ac4:	20 e0       	ldi	r18, 0x00	; 0
    6ac6:	30 e0       	ldi	r19, 0x00	; 0
    6ac8:	40 e2       	ldi	r20, 0x20	; 32
    6aca:	51 e4       	ldi	r21, 0x41	; 65
    6acc:	0e 94 fa 37 	call	0x6ff4	; 0x6ff4 <__divsf3>
    6ad0:	9b 01       	movw	r18, r22
    6ad2:	ac 01       	movw	r20, r24
	LCD_WriteValue_double_ex(1,84,volt,8,1==subpage); 
    6ad4:	91 e0       	ldi	r25, 0x01	; 1
    6ad6:	80 91 3c 05 	lds	r24, 0x053C
    6ada:	81 30       	cpi	r24, 0x01	; 1
    6adc:	09 f0       	breq	.+2      	; 0x6ae0 <_hMiscSettings+0xf0>
    6ade:	90 e0       	ldi	r25, 0x00	; 0
    6ae0:	81 e0       	ldi	r24, 0x01	; 1
    6ae2:	64 e5       	ldi	r22, 0x54	; 84
    6ae4:	08 e0       	ldi	r16, 0x08	; 8
    6ae6:	e9 2e       	mov	r14, r25
    6ae8:	0e 94 c9 0d 	call	0x1b92	; 0x1b92 <LCD_WriteValue_double_ex>
	//LCD_WriteValue(1,84,Config.VoltageAlarm,3,1==subpage);
	LCD_WriteValue(2,84,Config.ThrottleMin,3,2==subpage);
    6aec:	40 91 f4 06 	lds	r20, 0x06F4
    6af0:	01 e0       	ldi	r16, 0x01	; 1
    6af2:	80 91 3c 05 	lds	r24, 0x053C
    6af6:	82 30       	cpi	r24, 0x02	; 2
    6af8:	09 f0       	breq	.+2      	; 0x6afc <_hMiscSettings+0x10c>
    6afa:	00 e0       	ldi	r16, 0x00	; 0
    6afc:	82 e0       	ldi	r24, 0x02	; 2
    6afe:	64 e5       	ldi	r22, 0x54	; 84
    6b00:	50 e0       	ldi	r21, 0x00	; 0
    6b02:	23 e0       	ldi	r18, 0x03	; 3
    6b04:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <LCD_WriteValue>
	LCD_WriteValue(3,84,Config.StickScaling,3,3==subpage);
    6b08:	40 91 f5 06 	lds	r20, 0x06F5
    6b0c:	01 e0       	ldi	r16, 0x01	; 1
    6b0e:	80 91 3c 05 	lds	r24, 0x053C
    6b12:	83 30       	cpi	r24, 0x03	; 3
    6b14:	09 f0       	breq	.+2      	; 0x6b18 <_hMiscSettings+0x128>
    6b16:	00 e0       	ldi	r16, 0x00	; 0
    6b18:	83 e0       	ldi	r24, 0x03	; 3
    6b1a:	64 e5       	ldi	r22, 0x54	; 84
    6b1c:	50 e0       	ldi	r21, 0x00	; 0
    6b1e:	23 e0       	ldi	r18, 0x03	; 3
    6b20:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <LCD_WriteValue>
	_helper_Words (4,84,(4==subpage),(Config.PitchRollLinked),PSTR("yes"),PSTR("no "),5);
    6b24:	41 e0       	ldi	r20, 0x01	; 1
    6b26:	80 91 3c 05 	lds	r24, 0x053C
    6b2a:	84 30       	cpi	r24, 0x04	; 4
    6b2c:	09 f0       	breq	.+2      	; 0x6b30 <_hMiscSettings+0x140>
    6b2e:	40 e0       	ldi	r20, 0x00	; 0
    6b30:	21 e0       	ldi	r18, 0x01	; 1
    6b32:	80 91 af 07 	lds	r24, 0x07AF
    6b36:	88 23       	and	r24, r24
    6b38:	09 f4       	brne	.+2      	; 0x6b3c <_hMiscSettings+0x14c>
    6b3a:	20 e0       	ldi	r18, 0x00	; 0
    6b3c:	84 e0       	ldi	r24, 0x04	; 4
    6b3e:	64 e5       	ldi	r22, 0x54	; 84
    6b40:	0e eb       	ldi	r16, 0xBE	; 190
    6b42:	1c e0       	ldi	r17, 0x0C	; 12
    6b44:	fa eb       	ldi	r31, 0xBA	; 186
    6b46:	ef 2e       	mov	r14, r31
    6b48:	fc e0       	ldi	r31, 0x0C	; 12
    6b4a:	ff 2e       	mov	r15, r31
    6b4c:	e5 e0       	ldi	r30, 0x05	; 5
    6b4e:	ce 2e       	mov	r12, r30
    6b50:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <_helper_Words>
	
		
}
    6b54:	1f 91       	pop	r17
    6b56:	0f 91       	pop	r16
    6b58:	ff 90       	pop	r15
    6b5a:	ef 90       	pop	r14
    6b5c:	cf 90       	pop	r12
    6b5e:	08 95       	ret

00006b60 <_hModeSettings>:
	
}

bool bNeedRestart=false;
void _hModeSettings ()
{
    6b60:	cf 92       	push	r12
    6b62:	ef 92       	push	r14
    6b64:	ff 92       	push	r15
    6b66:	0f 93       	push	r16
    6b68:	1f 93       	push	r17
	NOKEYRETURN;
    6b6a:	80 91 ba 05 	lds	r24, 0x05BA
    6b6e:	88 23       	and	r24, r24
    6b70:	09 f4       	brne	.+2      	; 0x6b74 <_hModeSettings+0x14>
    6b72:	db c0       	rjmp	.+438    	; 0x6d2a <_hModeSettings+0x1ca>
	PageKey(5);
    6b74:	85 e0       	ldi	r24, 0x05	; 5
    6b76:	0e 94 47 30 	call	0x608e	; 0x608e <PageKey>
	
	if ((KEY1) && (bValueChanged==true))
    6b7a:	80 91 ba 05 	lds	r24, 0x05BA
    6b7e:	87 ff       	sbrs	r24, 7
    6b80:	0f c0       	rjmp	.+30     	; 0x6ba0 <_hModeSettings+0x40>
    6b82:	90 91 38 05 	lds	r25, 0x0538
    6b86:	91 30       	cpi	r25, 0x01	; 1
    6b88:	59 f4       	brne	.+22     	; 0x6ba0 <_hModeSettings+0x40>
	{
		_helper_SaveinEEPROM_ifChanged();
    6b8a:	0e 94 f5 2b 	call	0x57ea	; 0x57ea <_helper_SaveinEEPROM_ifChanged>
		if (bNeedRestart==true) Menu_LoadPage(PAGE_RESTART);
    6b8e:	80 91 39 05 	lds	r24, 0x0539
    6b92:	88 23       	and	r24, r24
    6b94:	09 f4       	brne	.+2      	; 0x6b98 <_hModeSettings+0x38>
    6b96:	c9 c0       	rjmp	.+402    	; 0x6d2a <_hModeSettings+0x1ca>
    6b98:	84 e0       	ldi	r24, 0x04	; 4
    6b9a:	0e 94 18 2e 	call	0x5c30	; 0x5c30 <Menu_LoadPage>
    6b9e:	c5 c0       	rjmp	.+394    	; 0x6d2a <_hModeSettings+0x1ca>
		return;
	}
	
	if (KEY4)
    6ba0:	84 ff       	sbrs	r24, 4
    6ba2:	3d c0       	rjmp	.+122    	; 0x6c1e <_hModeSettings+0xbe>
	{
		bValueChanged = true;
    6ba4:	91 e0       	ldi	r25, 0x01	; 1
    6ba6:	90 93 38 05 	sts	0x0538, r25
		//currentPage.softkeys = _skMENUSAVE;
		switch (subpage)
    6baa:	80 91 3c 05 	lds	r24, 0x053C
    6bae:	82 30       	cpi	r24, 0x02	; 2
    6bb0:	f9 f0       	breq	.+62     	; 0x6bf0 <_hModeSettings+0x90>
    6bb2:	83 30       	cpi	r24, 0x03	; 3
    6bb4:	28 f4       	brcc	.+10     	; 0x6bc0 <_hModeSettings+0x60>
    6bb6:	88 23       	and	r24, r24
    6bb8:	41 f0       	breq	.+16     	; 0x6bca <_hModeSettings+0x6a>
    6bba:	81 30       	cpi	r24, 0x01	; 1
    6bbc:	81 f5       	brne	.+96     	; 0x6c1e <_hModeSettings+0xbe>
    6bbe:	10 c0       	rjmp	.+32     	; 0x6be0 <_hModeSettings+0x80>
    6bc0:	83 30       	cpi	r24, 0x03	; 3
    6bc2:	f1 f0       	breq	.+60     	; 0x6c00 <_hModeSettings+0xa0>
    6bc4:	84 30       	cpi	r24, 0x04	; 4
    6bc6:	59 f5       	brne	.+86     	; 0x6c1e <_hModeSettings+0xbe>
    6bc8:	23 c0       	rjmp	.+70     	; 0x6c10 <_hModeSettings+0xb0>
		{
			case 0: if (Config.FrameType==FRAMETYPE_QUADCOPTER) Config.FrameType=FRAMETYPE_TRICOPTER; else Config.FrameType=FRAMETYPE_QUADCOPTER; break;
    6bca:	80 91 f0 06 	lds	r24, 0x06F0
    6bce:	81 30       	cpi	r24, 0x01	; 1
    6bd0:	21 f4       	brne	.+8      	; 0x6bda <_hModeSettings+0x7a>
    6bd2:	82 e0       	ldi	r24, 0x02	; 2
    6bd4:	80 93 f0 06 	sts	0x06F0, r24
    6bd8:	22 c0       	rjmp	.+68     	; 0x6c1e <_hModeSettings+0xbe>
    6bda:	90 93 f0 06 	sts	0x06F0, r25
    6bde:	1f c0       	rjmp	.+62     	; 0x6c1e <_hModeSettings+0xbe>
			case 1: Config.RX_mode=~Config.RX_mode; bNeedRestart = true; break;
    6be0:	90 91 eb 06 	lds	r25, 0x06EB
    6be4:	90 95       	com	r25
    6be6:	90 93 eb 06 	sts	0x06EB, r25
    6bea:	80 93 39 05 	sts	0x0539, r24
    6bee:	17 c0       	rjmp	.+46     	; 0x6c1e <_hModeSettings+0xbe>
			case 2: Config.BoardOrientationMode=((~Config.BoardOrientationMode) & 0x01); /* value either 0 or 1*/break;
    6bf0:	90 91 f1 06 	lds	r25, 0x06F1
    6bf4:	81 e0       	ldi	r24, 0x01	; 1
    6bf6:	90 fd       	sbrc	r25, 0
    6bf8:	80 e0       	ldi	r24, 0x00	; 0
    6bfa:	80 93 f1 06 	sts	0x06F1, r24
    6bfe:	0f c0       	rjmp	.+30     	; 0x6c1e <_hModeSettings+0xbe>
			case 3: Config.QuadFlyingMode = ((~Config.QuadFlyingMode) & 0x01); /* value either 0 or 1*/break;
    6c00:	90 91 f2 06 	lds	r25, 0x06F2
    6c04:	81 e0       	ldi	r24, 0x01	; 1
    6c06:	90 fd       	sbrc	r25, 0
    6c08:	80 e0       	ldi	r24, 0x00	; 0
    6c0a:	80 93 f2 06 	sts	0x06F2, r24
    6c0e:	07 c0       	rjmp	.+14     	; 0x6c1e <_hModeSettings+0xbe>
			case 4: Config.MiscSensors =  ((~Config.MiscSensors) & 0x01); break; // this condition should be rewritten if another sensor is added.
    6c10:	90 91 f6 06 	lds	r25, 0x06F6
    6c14:	81 e0       	ldi	r24, 0x01	; 1
    6c16:	90 fd       	sbrc	r25, 0
    6c18:	80 e0       	ldi	r24, 0x00	; 0
    6c1a:	80 93 f6 06 	sts	0x06F6, r24
		}
	}
	
	_helper_Words  (0,84,(subpage==0),(Config.FrameType== FRAMETYPE_QUADCOPTER),PSTR("Quad"),PSTR("TRI "),5);
    6c1e:	41 e0       	ldi	r20, 0x01	; 1
    6c20:	80 91 3c 05 	lds	r24, 0x053C
    6c24:	81 11       	cpse	r24, r1
    6c26:	40 e0       	ldi	r20, 0x00	; 0
    6c28:	21 e0       	ldi	r18, 0x01	; 1
    6c2a:	80 91 f0 06 	lds	r24, 0x06F0
    6c2e:	81 30       	cpi	r24, 0x01	; 1
    6c30:	09 f0       	breq	.+2      	; 0x6c34 <_hModeSettings+0xd4>
    6c32:	20 e0       	ldi	r18, 0x00	; 0
    6c34:	80 e0       	ldi	r24, 0x00	; 0
    6c36:	64 e5       	ldi	r22, 0x54	; 84
    6c38:	05 e0       	ldi	r16, 0x05	; 5
    6c3a:	1d e0       	ldi	r17, 0x0D	; 13
    6c3c:	a0 e0       	ldi	r26, 0x00	; 0
    6c3e:	ea 2e       	mov	r14, r26
    6c40:	ad e0       	ldi	r26, 0x0D	; 13
    6c42:	fa 2e       	mov	r15, r26
    6c44:	f5 e0       	ldi	r31, 0x05	; 5
    6c46:	cf 2e       	mov	r12, r31
    6c48:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <_helper_Words>
	_helper_Words  (1,84,(subpage==1),(Config.RX_mode== RX_mode_BuddyMode),PSTR("Buddy"),PSTR("UART "),5);
    6c4c:	41 e0       	ldi	r20, 0x01	; 1
    6c4e:	80 91 3c 05 	lds	r24, 0x053C
    6c52:	81 30       	cpi	r24, 0x01	; 1
    6c54:	09 f0       	breq	.+2      	; 0x6c58 <_hModeSettings+0xf8>
    6c56:	40 e0       	ldi	r20, 0x00	; 0
    6c58:	21 e0       	ldi	r18, 0x01	; 1
    6c5a:	80 91 eb 06 	lds	r24, 0x06EB
    6c5e:	81 11       	cpse	r24, r1
    6c60:	20 e0       	ldi	r18, 0x00	; 0
    6c62:	81 e0       	ldi	r24, 0x01	; 1
    6c64:	64 e5       	ldi	r22, 0x54	; 84
    6c66:	0a ef       	ldi	r16, 0xFA	; 250
    6c68:	1c e0       	ldi	r17, 0x0C	; 12
    6c6a:	e4 ef       	ldi	r30, 0xF4	; 244
    6c6c:	ee 2e       	mov	r14, r30
    6c6e:	ec e0       	ldi	r30, 0x0C	; 12
    6c70:	fe 2e       	mov	r15, r30
    6c72:	75 e0       	ldi	r23, 0x05	; 5
    6c74:	c7 2e       	mov	r12, r23
    6c76:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <_helper_Words>
	_helper_Words (2,84,(subpage==2),(Config.BoardOrientationMode == QuadFlyingMode_PLUS),PSTR("+ Quad"),PSTR("X Quad"),6);
    6c7a:	41 e0       	ldi	r20, 0x01	; 1
    6c7c:	80 91 3c 05 	lds	r24, 0x053C
    6c80:	82 30       	cpi	r24, 0x02	; 2
    6c82:	09 f0       	breq	.+2      	; 0x6c86 <_hModeSettings+0x126>
    6c84:	40 e0       	ldi	r20, 0x00	; 0
    6c86:	21 e0       	ldi	r18, 0x01	; 1
    6c88:	80 91 f1 06 	lds	r24, 0x06F1
    6c8c:	81 11       	cpse	r24, r1
    6c8e:	20 e0       	ldi	r18, 0x00	; 0
    6c90:	82 e0       	ldi	r24, 0x02	; 2
    6c92:	64 e5       	ldi	r22, 0x54	; 84
    6c94:	0d ee       	ldi	r16, 0xED	; 237
    6c96:	1c e0       	ldi	r17, 0x0C	; 12
    6c98:	56 ee       	ldi	r21, 0xE6	; 230
    6c9a:	e5 2e       	mov	r14, r21
    6c9c:	5c e0       	ldi	r21, 0x0C	; 12
    6c9e:	f5 2e       	mov	r15, r21
    6ca0:	36 e0       	ldi	r19, 0x06	; 6
    6ca2:	c3 2e       	mov	r12, r19
    6ca4:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <_helper_Words>
	if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    6ca8:	90 91 f0 06 	lds	r25, 0x06F0
    6cac:	80 91 3c 05 	lds	r24, 0x053C
    6cb0:	91 30       	cpi	r25, 0x01	; 1
    6cb2:	91 f4       	brne	.+36     	; 0x6cd8 <_hModeSettings+0x178>
	{
		_helper_Words (3,84,(subpage==3),(Config.QuadFlyingMode == QuadFlyingMode_PLUS),PSTR("+ Quad"),PSTR("X Quad"),6);
    6cb4:	41 e0       	ldi	r20, 0x01	; 1
    6cb6:	83 30       	cpi	r24, 0x03	; 3
    6cb8:	09 f0       	breq	.+2      	; 0x6cbc <_hModeSettings+0x15c>
    6cba:	40 e0       	ldi	r20, 0x00	; 0
    6cbc:	21 e0       	ldi	r18, 0x01	; 1
    6cbe:	80 91 f2 06 	lds	r24, 0x06F2
    6cc2:	81 11       	cpse	r24, r1
    6cc4:	20 e0       	ldi	r18, 0x00	; 0
    6cc6:	83 e0       	ldi	r24, 0x03	; 3
    6cc8:	64 e5       	ldi	r22, 0x54	; 84
    6cca:	0f ed       	ldi	r16, 0xDF	; 223
    6ccc:	1c e0       	ldi	r17, 0x0C	; 12
    6cce:	98 ed       	ldi	r25, 0xD8	; 216
    6cd0:	e9 2e       	mov	r14, r25
    6cd2:	9c e0       	ldi	r25, 0x0C	; 12
    6cd4:	f9 2e       	mov	r15, r25
    6cd6:	11 c0       	rjmp	.+34     	; 0x6cfa <_hModeSettings+0x19a>
	}
	else
	{
		_helper_Words (3,84,(subpage==3),(Config.QuadFlyingMode == QuadFlyingMode_PLUS),PSTR("Y Tri "),PSTR("A Tri "),6);
    6cd8:	41 e0       	ldi	r20, 0x01	; 1
    6cda:	83 30       	cpi	r24, 0x03	; 3
    6cdc:	09 f0       	breq	.+2      	; 0x6ce0 <_hModeSettings+0x180>
    6cde:	40 e0       	ldi	r20, 0x00	; 0
    6ce0:	21 e0       	ldi	r18, 0x01	; 1
    6ce2:	80 91 f2 06 	lds	r24, 0x06F2
    6ce6:	81 11       	cpse	r24, r1
    6ce8:	20 e0       	ldi	r18, 0x00	; 0
    6cea:	83 e0       	ldi	r24, 0x03	; 3
    6cec:	64 e5       	ldi	r22, 0x54	; 84
    6cee:	01 ed       	ldi	r16, 0xD1	; 209
    6cf0:	1c e0       	ldi	r17, 0x0C	; 12
    6cf2:	ba ec       	ldi	r27, 0xCA	; 202
    6cf4:	eb 2e       	mov	r14, r27
    6cf6:	bc e0       	ldi	r27, 0x0C	; 12
    6cf8:	fb 2e       	mov	r15, r27
    6cfa:	a6 e0       	ldi	r26, 0x06	; 6
    6cfc:	ca 2e       	mov	r12, r26
    6cfe:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <_helper_Words>
	}	
	_helper_DisplayBiStateText(4,84, strYes, strNo, (IS_MISC_SENSOR_SONAR_ENABLED ==true),(subpage==4));
    6d02:	00 91 f6 06 	lds	r16, 0x06F6
    6d06:	10 e0       	ldi	r17, 0x00	; 0
    6d08:	01 70       	andi	r16, 0x01	; 1
    6d0a:	10 70       	andi	r17, 0x00	; 0
    6d0c:	91 e0       	ldi	r25, 0x01	; 1
    6d0e:	80 91 3c 05 	lds	r24, 0x053C
    6d12:	84 30       	cpi	r24, 0x04	; 4
    6d14:	09 f0       	breq	.+2      	; 0x6d18 <_hModeSettings+0x1b8>
    6d16:	90 e0       	ldi	r25, 0x00	; 0
    6d18:	84 e0       	ldi	r24, 0x04	; 4
    6d1a:	64 e5       	ldi	r22, 0x54	; 84
    6d1c:	42 ec       	ldi	r20, 0xC2	; 194
    6d1e:	5c e0       	ldi	r21, 0x0C	; 12
    6d20:	26 ec       	ldi	r18, 0xC6	; 198
    6d22:	3c e0       	ldi	r19, 0x0C	; 12
    6d24:	e9 2e       	mov	r14, r25
    6d26:	0e 94 c9 2b 	call	0x5792	; 0x5792 <_helper_DisplayBiStateText>
}
    6d2a:	1f 91       	pop	r17
    6d2c:	0f 91       	pop	r16
    6d2e:	ff 90       	pop	r15
    6d30:	ef 90       	pop	r14
    6d32:	cf 90       	pop	r12
    6d34:	08 95       	ret

00006d36 <doMenu>:

/*
//	Draw the menu
*/
uint8_t doMenu(menu_t *menu)
{
    6d36:	ef 92       	push	r14
    6d38:	ff 92       	push	r15
    6d3a:	0f 93       	push	r16
    6d3c:	1f 93       	push	r17
    6d3e:	cf 93       	push	r28
    6d40:	df 93       	push	r29
    6d42:	ec 01       	movw	r28, r24
	UIEnableStickCommands=true;
    6d44:	81 e0       	ldi	r24, 0x01	; 1
    6d46:	80 93 e5 05 	sts	0x05E5, r24
	
	if (!_mykey) return 0;
    6d4a:	80 91 ba 05 	lds	r24, 0x05BA
    6d4e:	88 23       	and	r24, r24
    6d50:	09 f4       	brne	.+2      	; 0x6d54 <doMenu+0x1e>
    6d52:	70 c0       	rjmp	.+224    	; 0x6e34 <doMenu+0xfe>
	
	// key handling
	if (KEY2)		// UP
    6d54:	86 ff       	sbrs	r24, 6
    6d56:	06 c0       	rjmp	.+12     	; 0x6d64 <doMenu+0x2e>
	{
		if (menu->marked > 0) 
    6d58:	8c 81       	ldd	r24, Y+4	; 0x04
    6d5a:	88 23       	and	r24, r24
    6d5c:	99 f0       	breq	.+38     	; 0x6d84 <doMenu+0x4e>
			menu->marked--;
    6d5e:	81 50       	subi	r24, 0x01	; 1
    6d60:	8c 83       	std	Y+4, r24	; 0x04
    6d62:	10 c0       	rjmp	.+32     	; 0x6d84 <doMenu+0x4e>
	}
	else if (KEY3)		// DOWN
    6d64:	85 ff       	sbrs	r24, 5
    6d66:	0c c0       	rjmp	.+24     	; 0x6d80 <doMenu+0x4a>
	{
		if (menu->marked < menu->len - 1) 
    6d68:	4c 81       	ldd	r20, Y+4	; 0x04
    6d6a:	24 2f       	mov	r18, r20
    6d6c:	30 e0       	ldi	r19, 0x00	; 0
    6d6e:	88 81       	ld	r24, Y
    6d70:	90 e0       	ldi	r25, 0x00	; 0
    6d72:	01 97       	sbiw	r24, 0x01	; 1
    6d74:	28 17       	cp	r18, r24
    6d76:	39 07       	cpc	r19, r25
    6d78:	2c f4       	brge	.+10     	; 0x6d84 <doMenu+0x4e>
			menu->marked++;
    6d7a:	4f 5f       	subi	r20, 0xFF	; 255
    6d7c:	4c 83       	std	Y+4, r20	; 0x04
    6d7e:	02 c0       	rjmp	.+4      	; 0x6d84 <doMenu+0x4e>
	}
	else if (KEY4)		// ENTER
    6d80:	84 fd       	sbrc	r24, 4
    6d82:	56 c0       	rjmp	.+172    	; 0x6e30 <doMenu+0xfa>
		return 1;

	if (menu->marked < menu->top)
    6d84:	2c 81       	ldd	r18, Y+4	; 0x04
    6d86:	3b 81       	ldd	r19, Y+3	; 0x03
    6d88:	23 17       	cp	r18, r19
    6d8a:	40 f0       	brcs	.+16     	; 0x6d9c <doMenu+0x66>
		menu->top = menu->marked;
	else if (menu->marked - menu->top >= 5)
    6d8c:	82 2f       	mov	r24, r18
    6d8e:	90 e0       	ldi	r25, 0x00	; 0
    6d90:	83 1b       	sub	r24, r19
    6d92:	91 09       	sbc	r25, r1
    6d94:	85 30       	cpi	r24, 0x05	; 5
    6d96:	91 05       	cpc	r25, r1
    6d98:	14 f0       	brlt	.+4      	; 0x6d9e <doMenu+0x68>
		menu->top = menu->marked - 4;
    6d9a:	24 50       	subi	r18, 0x04	; 4
    6d9c:	2b 83       	std	Y+3, r18	; 0x03
	
	// text output
	LCD_SetPos(0, 58);
    6d9e:	80 e0       	ldi	r24, 0x00	; 0
    6da0:	6a e3       	ldi	r22, 0x3A	; 58
    6da2:	0e 94 1f 0c 	call	0x183e	; 0x183e <LCD_SetPos>
	if (menu->top > 0)
    6da6:	8b 81       	ldd	r24, Y+3	; 0x03
    6da8:	88 23       	and	r24, r24
    6daa:	29 f0       	breq	.+10     	; 0x6db6 <doMenu+0x80>
		lcdWriteGlyph_P(&glyArrowUp, 0);
    6dac:	83 ec       	ldi	r24, 0xC3	; 195
    6dae:	99 e0       	ldi	r25, 0x09	; 9
    6db0:	60 e0       	ldi	r22, 0x00	; 0
    6db2:	0e 94 df 0c 	call	0x19be	; 0x19be <lcdWriteGlyph_P>

/*
//	Draw the menu
*/
uint8_t doMenu(menu_t *menu)
{
    6db6:	00 e0       	ldi	r16, 0x00	; 0
    6db8:	10 e0       	ldi	r17, 0x00	; 0
    6dba:	21 c0       	rjmp	.+66     	; 0x6dfe <doMenu+0xc8>
	if (menu->top > 0)
		lcdWriteGlyph_P(&glyArrowUp, 0);
		
	for (uint8_t i = 0; i < 5 && i < menu->len; i++)
	{
		LCD_SetPos(i + 1, 0);
    6dbc:	8e 2d       	mov	r24, r14
    6dbe:	8f 5f       	subi	r24, 0xFF	; 255
    6dc0:	60 e0       	ldi	r22, 0x00	; 0
    6dc2:	0e 94 1f 0c 	call	0x183e	; 0x183e <LCD_SetPos>
		PGM_P item = menu->textSelector(menu->top + i);
    6dc6:	8b 81       	ldd	r24, Y+3	; 0x03
    6dc8:	e9 81       	ldd	r30, Y+1	; 0x01
    6dca:	fa 81       	ldd	r31, Y+2	; 0x02
    6dcc:	8e 0d       	add	r24, r14
    6dce:	09 95       	icall
    6dd0:	7c 01       	movw	r14, r24
		lcdReverse(menu->top + i == menu->marked);
    6dd2:	8b 81       	ldd	r24, Y+3	; 0x03
    6dd4:	a8 01       	movw	r20, r16
    6dd6:	48 0f       	add	r20, r24
    6dd8:	51 1d       	adc	r21, r1
    6dda:	2c 81       	ldd	r18, Y+4	; 0x04
    6ddc:	30 e0       	ldi	r19, 0x00	; 0
    6dde:	81 e0       	ldi	r24, 0x01	; 1
    6de0:	42 17       	cp	r20, r18
    6de2:	53 07       	cpc	r21, r19
    6de4:	09 f0       	breq	.+2      	; 0x6de8 <doMenu+0xb2>
    6de6:	80 e0       	ldi	r24, 0x00	; 0
    6de8:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <lcdReverse>
		LCD_WritePadded_P(item, 21);
    6dec:	c7 01       	movw	r24, r14
    6dee:	65 e1       	ldi	r22, 0x15	; 21
    6df0:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <LCD_WritePadded_P>
    6df4:	0f 5f       	subi	r16, 0xFF	; 255
    6df6:	1f 4f       	sbci	r17, 0xFF	; 255
	// text output
	LCD_SetPos(0, 58);
	if (menu->top > 0)
		lcdWriteGlyph_P(&glyArrowUp, 0);
		
	for (uint8_t i = 0; i < 5 && i < menu->len; i++)
    6df8:	05 30       	cpi	r16, 0x05	; 5
    6dfa:	11 05       	cpc	r17, r1
    6dfc:	21 f0       	breq	.+8      	; 0x6e06 <doMenu+0xd0>
    6dfe:	e0 2e       	mov	r14, r16
    6e00:	88 81       	ld	r24, Y
    6e02:	08 17       	cp	r16, r24
    6e04:	d8 f2       	brcs	.-74     	; 0x6dbc <doMenu+0x86>
		PGM_P item = menu->textSelector(menu->top + i);
		lcdReverse(menu->top + i == menu->marked);
		LCD_WritePadded_P(item, 21);
	}

	lcdReverse(0);
    6e06:	80 e0       	ldi	r24, 0x00	; 0
    6e08:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <lcdReverse>


	LCD_SetPos(6, 58);
    6e0c:	86 e0       	ldi	r24, 0x06	; 6
    6e0e:	6a e3       	ldi	r22, 0x3A	; 58
    6e10:	0e 94 1f 0c 	call	0x183e	; 0x183e <LCD_SetPos>
	if (menu->top < menu->len - 5)
    6e14:	2b 81       	ldd	r18, Y+3	; 0x03
    6e16:	30 e0       	ldi	r19, 0x00	; 0
    6e18:	88 81       	ld	r24, Y
    6e1a:	90 e0       	ldi	r25, 0x00	; 0
    6e1c:	05 97       	sbiw	r24, 0x05	; 5
    6e1e:	28 17       	cp	r18, r24
    6e20:	39 07       	cpc	r19, r25
    6e22:	44 f4       	brge	.+16     	; 0x6e34 <doMenu+0xfe>
		lcdWriteGlyph_P(&glyArrowDown, 0);
    6e24:	8d ec       	ldi	r24, 0xCD	; 205
    6e26:	99 e0       	ldi	r25, 0x09	; 9
    6e28:	60 e0       	ldi	r22, 0x00	; 0
    6e2a:	0e 94 df 0c 	call	0x19be	; 0x19be <lcdWriteGlyph_P>
    6e2e:	02 c0       	rjmp	.+4      	; 0x6e34 <doMenu+0xfe>
	{
		if (menu->marked < menu->len - 1) 
			menu->marked++;
	}
	else if (KEY4)		// ENTER
		return 1;
    6e30:	81 e0       	ldi	r24, 0x01	; 1
    6e32:	01 c0       	rjmp	.+2      	; 0x6e36 <doMenu+0x100>

	LCD_SetPos(6, 58);
	if (menu->top < menu->len - 5)
		lcdWriteGlyph_P(&glyArrowDown, 0);
	
	return 0;
    6e34:	80 e0       	ldi	r24, 0x00	; 0
}
    6e36:	df 91       	pop	r29
    6e38:	cf 91       	pop	r28
    6e3a:	1f 91       	pop	r17
    6e3c:	0f 91       	pop	r16
    6e3e:	ff 90       	pop	r15
    6e40:	ef 90       	pop	r14
    6e42:	08 95       	ret

00006e44 <_hMenu>:


void _hMenu()
{
	if (doMenu(&mnuMain))
    6e44:	8c e1       	ldi	r24, 0x1C	; 28
    6e46:	91 e0       	ldi	r25, 0x01	; 1
    6e48:	0e 94 9b 36 	call	0x6d36	; 0x6d36 <doMenu>
    6e4c:	88 23       	and	r24, r24
    6e4e:	91 f0       	breq	.+36     	; 0x6e74 <_hMenu+0x30>
	{	// if menu item selected then open it if...
		if (menuEnabled[mnuMain.marked + MENU_START_INDEX]==1)
    6e50:	80 91 20 01 	lds	r24, 0x0120
    6e54:	e8 2f       	mov	r30, r24
    6e56:	f0 e0       	ldi	r31, 0x00	; 0
    6e58:	ee 51       	subi	r30, 0x1E	; 30
    6e5a:	f8 4f       	sbci	r31, 0xF8	; 248
    6e5c:	95 81       	ldd	r25, Z+5	; 0x05
    6e5e:	91 30       	cpi	r25, 0x01	; 1
    6e60:	21 f4       	brne	.+8      	; 0x6e6a <_hMenu+0x26>
		{ //... the menu item is enabled 
			Menu_LoadPage(mnuMain.marked + MENU_START_INDEX);
    6e62:	8b 5f       	subi	r24, 0xFB	; 251
    6e64:	0e 94 18 2e 	call	0x5c30	; 0x5c30 <Menu_LoadPage>
    6e68:	08 95       	ret
		}
		else
		{ //... else flash light and ignore command
			LED_FlashOrangeLED(LED_SHORT_TOGGLE,2);
    6e6a:	8e e1       	ldi	r24, 0x1E	; 30
    6e6c:	90 e0       	ldi	r25, 0x00	; 0
    6e6e:	62 e0       	ldi	r22, 0x02	; 2
    6e70:	0e 94 aa 0e 	call	0x1d54	; 0x1d54 <LED_FlashOrangeLED>
    6e74:	08 95       	ret

00006e76 <Menu_MenuShow>:

void Menu_MenuShow()
{
	
	
	_mykey = Keyboard_Read();
    6e76:	0e 94 cf 0b 	call	0x179e	; 0x179e <Keyboard_Read>
	_mykey = _mykey | _TXKeys;
    6e7a:	90 91 d6 06 	lds	r25, 0x06D6
    6e7e:	98 2b       	or	r25, r24
    6e80:	90 93 ba 05 	sts	0x05BA, r25

	
	LCD_Disable();
    6e84:	0e 94 54 0e 	call	0x1ca8	; 0x1ca8 <LCD_Disable>
	if (oldPage != page)
    6e88:	90 91 3b 05 	lds	r25, 0x053B
    6e8c:	80 91 3a 05 	lds	r24, 0x053A
    6e90:	89 17       	cp	r24, r25
    6e92:	59 f0       	breq	.+22     	; 0x6eaa <Menu_MenuShow+0x34>
	{	// if this is a new page then KEY_INIT = true
		_mykey |= KEY_INIT;
    6e94:	80 91 ba 05 	lds	r24, 0x05BA
    6e98:	81 60       	ori	r24, 0x01	; 1
    6e9a:	80 93 ba 05 	sts	0x05BA, r24
		subpage = 0;
    6e9e:	10 92 3c 05 	sts	0x053C, r1
		subindex = 0;
    6ea2:	10 92 3d 05 	sts	0x053D, r1
		oldPage = page;
    6ea6:	90 93 3a 05 	sts	0x053A, r25
	}
	defaultHandler();
    6eaa:	0e 94 50 2f 	call	0x5ea0	; 0x5ea0 <defaultHandler>
	LCD_Enable();
    6eae:	0e 94 4b 0e 	call	0x1c96	; 0x1c96 <LCD_Enable>

	
	
	if (KEY1 && !editMode)	// BACK
    6eb2:	80 91 ba 05 	lds	r24, 0x05BA
    6eb6:	87 ff       	sbrs	r24, 7
    6eb8:	15 c0       	rjmp	.+42     	; 0x6ee4 <Menu_MenuShow+0x6e>
    6eba:	80 91 f8 07 	lds	r24, 0x07F8
    6ebe:	88 23       	and	r24, r24
    6ec0:	89 f4       	brne	.+34     	; 0x6ee4 <Menu_MenuShow+0x6e>
	{
		if (page > PAGE_MENU) // if any page then go to main menu
    6ec2:	80 91 3b 05 	lds	r24, 0x053B
    6ec6:	82 30       	cpi	r24, 0x02	; 2
    6ec8:	10 f0       	brcs	.+4      	; 0x6ece <Menu_MenuShow+0x58>
			Menu_LoadPage(PAGE_MENU);
    6eca:	81 e0       	ldi	r24, 0x01	; 1
    6ecc:	09 c0       	rjmp	.+18     	; 0x6ee0 <Menu_MenuShow+0x6a>
		else if (page == PAGE_MENU)  // if menu page then goto HomePage
    6ece:	81 30       	cpi	r24, 0x01	; 1
    6ed0:	49 f4       	brne	.+18     	; 0x6ee4 <Menu_MenuShow+0x6e>
			{
				if (IsArmed == true)
    6ed2:	80 91 c8 07 	lds	r24, 0x07C8
    6ed6:	81 30       	cpi	r24, 0x01	; 1
    6ed8:	11 f4       	brne	.+4      	; 0x6ede <Menu_MenuShow+0x68>
				{
					Menu_LoadPage(PAGE_HOME_ARMED);
    6eda:	82 e0       	ldi	r24, 0x02	; 2
    6edc:	01 c0       	rjmp	.+2      	; 0x6ee0 <Menu_MenuShow+0x6a>
				}
				else
				{
					Menu_LoadPage(PAGE_HOME);
    6ede:	80 e0       	ldi	r24, 0x00	; 0
    6ee0:	0e 94 18 2e 	call	0x5c30	; 0x5c30 <Menu_LoadPage>
				}
			}							
	}
	
	
	if (KEYPRESS)
    6ee4:	80 91 ba 05 	lds	r24, 0x05BA
    6ee8:	80 7f       	andi	r24, 0xF0	; 240
    6eea:	29 f0       	breq	.+10     	; 0x6ef6 <Menu_MenuShow+0x80>
		Beeper_Beep(BEEP_KEY,1);
    6eec:	86 e4       	ldi	r24, 0x46	; 70
    6eee:	90 e0       	ldi	r25, 0x00	; 0
    6ef0:	61 e0       	ldi	r22, 0x01	; 1
    6ef2:	0e 94 a8 0b 	call	0x1750	; 0x1750 <Beeper_Beep>
		
	_TXKeys = 0; // No Key Pressed
    6ef6:	10 92 d6 06 	sts	0x06D6, r1
}
    6efa:	08 95       	ret

00006efc <Menu_MenuInit>:

void Menu_MenuInit()
{
	oldPage=0xff;
    6efc:	8f ef       	ldi	r24, 0xFF	; 255
    6efe:	80 93 3a 05 	sts	0x053A, r24
	Menu_LoadPage(PAGE_HOME);
    6f02:	80 e0       	ldi	r24, 0x00	; 0
    6f04:	0e 94 18 2e 	call	0x5c30	; 0x5c30 <Menu_LoadPage>
}
    6f08:	08 95       	ret

00006f0a <tsmLoadModelLayout>:
}

PGM_P tsmLoadModelLayout(uint8_t index)
{
	//return (PGM_P)pgm_read_word(&mixerTable[index].Name);
}
    6f0a:	08 95       	ret

00006f0c <Menu_EnableAllItems>:


void Menu_EnableAllItems ()
{
    6f0c:	e2 ee       	ldi	r30, 0xE2	; 226
    6f0e:	f7 e0       	ldi	r31, 0x07	; 7
	
	for (int i=0;i <MENU_ITEMS_COUNT;++i)
	{
		
		menuEnabled[i]=1;
    6f10:	81 e0       	ldi	r24, 0x01	; 1
    6f12:	81 93       	st	Z+, r24


void Menu_EnableAllItems ()
{
	
	for (int i=0;i <MENU_ITEMS_COUNT;++i)
    6f14:	97 e0       	ldi	r25, 0x07	; 7
    6f16:	e3 3f       	cpi	r30, 0xF3	; 243
    6f18:	f9 07       	cpc	r31, r25
    6f1a:	d9 f7       	brne	.-10     	; 0x6f12 <Menu_EnableAllItems+0x6>
	{
		
		menuEnabled[i]=1;
	}
	menuEnabled[PAGE_DEBUG]=1;
    6f1c:	80 93 f1 07 	sts	0x07F1, r24
	
    6f20:	08 95       	ret

00006f22 <__subsf3>:
    6f22:	50 58       	subi	r21, 0x80	; 128

00006f24 <__addsf3>:
    6f24:	bb 27       	eor	r27, r27
    6f26:	aa 27       	eor	r26, r26
    6f28:	0e d0       	rcall	.+28     	; 0x6f46 <__addsf3x>
    6f2a:	75 c1       	rjmp	.+746    	; 0x7216 <__fp_round>
    6f2c:	66 d1       	rcall	.+716    	; 0x71fa <__fp_pscA>
    6f2e:	30 f0       	brcs	.+12     	; 0x6f3c <__addsf3+0x18>
    6f30:	6b d1       	rcall	.+726    	; 0x7208 <__fp_pscB>
    6f32:	20 f0       	brcs	.+8      	; 0x6f3c <__addsf3+0x18>
    6f34:	31 f4       	brne	.+12     	; 0x6f42 <__addsf3+0x1e>
    6f36:	9f 3f       	cpi	r25, 0xFF	; 255
    6f38:	11 f4       	brne	.+4      	; 0x6f3e <__addsf3+0x1a>
    6f3a:	1e f4       	brtc	.+6      	; 0x6f42 <__addsf3+0x1e>
    6f3c:	5b c1       	rjmp	.+694    	; 0x71f4 <__fp_nan>
    6f3e:	0e f4       	brtc	.+2      	; 0x6f42 <__addsf3+0x1e>
    6f40:	e0 95       	com	r30
    6f42:	e7 fb       	bst	r30, 7
    6f44:	51 c1       	rjmp	.+674    	; 0x71e8 <__fp_inf>

00006f46 <__addsf3x>:
    6f46:	e9 2f       	mov	r30, r25
    6f48:	77 d1       	rcall	.+750    	; 0x7238 <__fp_split3>
    6f4a:	80 f3       	brcs	.-32     	; 0x6f2c <__addsf3+0x8>
    6f4c:	ba 17       	cp	r27, r26
    6f4e:	62 07       	cpc	r22, r18
    6f50:	73 07       	cpc	r23, r19
    6f52:	84 07       	cpc	r24, r20
    6f54:	95 07       	cpc	r25, r21
    6f56:	18 f0       	brcs	.+6      	; 0x6f5e <__addsf3x+0x18>
    6f58:	71 f4       	brne	.+28     	; 0x6f76 <__addsf3x+0x30>
    6f5a:	9e f5       	brtc	.+102    	; 0x6fc2 <__addsf3x+0x7c>
    6f5c:	8f c1       	rjmp	.+798    	; 0x727c <__fp_zero>
    6f5e:	0e f4       	brtc	.+2      	; 0x6f62 <__addsf3x+0x1c>
    6f60:	e0 95       	com	r30
    6f62:	0b 2e       	mov	r0, r27
    6f64:	ba 2f       	mov	r27, r26
    6f66:	a0 2d       	mov	r26, r0
    6f68:	0b 01       	movw	r0, r22
    6f6a:	b9 01       	movw	r22, r18
    6f6c:	90 01       	movw	r18, r0
    6f6e:	0c 01       	movw	r0, r24
    6f70:	ca 01       	movw	r24, r20
    6f72:	a0 01       	movw	r20, r0
    6f74:	11 24       	eor	r1, r1
    6f76:	ff 27       	eor	r31, r31
    6f78:	59 1b       	sub	r21, r25
    6f7a:	99 f0       	breq	.+38     	; 0x6fa2 <__addsf3x+0x5c>
    6f7c:	59 3f       	cpi	r21, 0xF9	; 249
    6f7e:	50 f4       	brcc	.+20     	; 0x6f94 <__addsf3x+0x4e>
    6f80:	50 3e       	cpi	r21, 0xE0	; 224
    6f82:	68 f1       	brcs	.+90     	; 0x6fde <__addsf3x+0x98>
    6f84:	1a 16       	cp	r1, r26
    6f86:	f0 40       	sbci	r31, 0x00	; 0
    6f88:	a2 2f       	mov	r26, r18
    6f8a:	23 2f       	mov	r18, r19
    6f8c:	34 2f       	mov	r19, r20
    6f8e:	44 27       	eor	r20, r20
    6f90:	58 5f       	subi	r21, 0xF8	; 248
    6f92:	f3 cf       	rjmp	.-26     	; 0x6f7a <__addsf3x+0x34>
    6f94:	46 95       	lsr	r20
    6f96:	37 95       	ror	r19
    6f98:	27 95       	ror	r18
    6f9a:	a7 95       	ror	r26
    6f9c:	f0 40       	sbci	r31, 0x00	; 0
    6f9e:	53 95       	inc	r21
    6fa0:	c9 f7       	brne	.-14     	; 0x6f94 <__addsf3x+0x4e>
    6fa2:	7e f4       	brtc	.+30     	; 0x6fc2 <__addsf3x+0x7c>
    6fa4:	1f 16       	cp	r1, r31
    6fa6:	ba 0b       	sbc	r27, r26
    6fa8:	62 0b       	sbc	r22, r18
    6faa:	73 0b       	sbc	r23, r19
    6fac:	84 0b       	sbc	r24, r20
    6fae:	ba f0       	brmi	.+46     	; 0x6fde <__addsf3x+0x98>
    6fb0:	91 50       	subi	r25, 0x01	; 1
    6fb2:	a1 f0       	breq	.+40     	; 0x6fdc <__addsf3x+0x96>
    6fb4:	ff 0f       	add	r31, r31
    6fb6:	bb 1f       	adc	r27, r27
    6fb8:	66 1f       	adc	r22, r22
    6fba:	77 1f       	adc	r23, r23
    6fbc:	88 1f       	adc	r24, r24
    6fbe:	c2 f7       	brpl	.-16     	; 0x6fb0 <__addsf3x+0x6a>
    6fc0:	0e c0       	rjmp	.+28     	; 0x6fde <__addsf3x+0x98>
    6fc2:	ba 0f       	add	r27, r26
    6fc4:	62 1f       	adc	r22, r18
    6fc6:	73 1f       	adc	r23, r19
    6fc8:	84 1f       	adc	r24, r20
    6fca:	48 f4       	brcc	.+18     	; 0x6fde <__addsf3x+0x98>
    6fcc:	87 95       	ror	r24
    6fce:	77 95       	ror	r23
    6fd0:	67 95       	ror	r22
    6fd2:	b7 95       	ror	r27
    6fd4:	f7 95       	ror	r31
    6fd6:	9e 3f       	cpi	r25, 0xFE	; 254
    6fd8:	08 f0       	brcs	.+2      	; 0x6fdc <__addsf3x+0x96>
    6fda:	b3 cf       	rjmp	.-154    	; 0x6f42 <__addsf3+0x1e>
    6fdc:	93 95       	inc	r25
    6fde:	88 0f       	add	r24, r24
    6fe0:	08 f0       	brcs	.+2      	; 0x6fe4 <__addsf3x+0x9e>
    6fe2:	99 27       	eor	r25, r25
    6fe4:	ee 0f       	add	r30, r30
    6fe6:	97 95       	ror	r25
    6fe8:	87 95       	ror	r24
    6fea:	08 95       	ret

00006fec <__cmpsf2>:
    6fec:	d9 d0       	rcall	.+434    	; 0x71a0 <__fp_cmp>
    6fee:	08 f4       	brcc	.+2      	; 0x6ff2 <__cmpsf2+0x6>
    6ff0:	81 e0       	ldi	r24, 0x01	; 1
    6ff2:	08 95       	ret

00006ff4 <__divsf3>:
    6ff4:	0c d0       	rcall	.+24     	; 0x700e <__divsf3x>
    6ff6:	0f c1       	rjmp	.+542    	; 0x7216 <__fp_round>
    6ff8:	07 d1       	rcall	.+526    	; 0x7208 <__fp_pscB>
    6ffa:	40 f0       	brcs	.+16     	; 0x700c <__divsf3+0x18>
    6ffc:	fe d0       	rcall	.+508    	; 0x71fa <__fp_pscA>
    6ffe:	30 f0       	brcs	.+12     	; 0x700c <__divsf3+0x18>
    7000:	21 f4       	brne	.+8      	; 0x700a <__divsf3+0x16>
    7002:	5f 3f       	cpi	r21, 0xFF	; 255
    7004:	19 f0       	breq	.+6      	; 0x700c <__divsf3+0x18>
    7006:	f0 c0       	rjmp	.+480    	; 0x71e8 <__fp_inf>
    7008:	51 11       	cpse	r21, r1
    700a:	39 c1       	rjmp	.+626    	; 0x727e <__fp_szero>
    700c:	f3 c0       	rjmp	.+486    	; 0x71f4 <__fp_nan>

0000700e <__divsf3x>:
    700e:	14 d1       	rcall	.+552    	; 0x7238 <__fp_split3>
    7010:	98 f3       	brcs	.-26     	; 0x6ff8 <__divsf3+0x4>

00007012 <__divsf3_pse>:
    7012:	99 23       	and	r25, r25
    7014:	c9 f3       	breq	.-14     	; 0x7008 <__divsf3+0x14>
    7016:	55 23       	and	r21, r21
    7018:	b1 f3       	breq	.-20     	; 0x7006 <__divsf3+0x12>
    701a:	95 1b       	sub	r25, r21
    701c:	55 0b       	sbc	r21, r21
    701e:	bb 27       	eor	r27, r27
    7020:	aa 27       	eor	r26, r26
    7022:	62 17       	cp	r22, r18
    7024:	73 07       	cpc	r23, r19
    7026:	84 07       	cpc	r24, r20
    7028:	38 f0       	brcs	.+14     	; 0x7038 <__divsf3_pse+0x26>
    702a:	9f 5f       	subi	r25, 0xFF	; 255
    702c:	5f 4f       	sbci	r21, 0xFF	; 255
    702e:	22 0f       	add	r18, r18
    7030:	33 1f       	adc	r19, r19
    7032:	44 1f       	adc	r20, r20
    7034:	aa 1f       	adc	r26, r26
    7036:	a9 f3       	breq	.-22     	; 0x7022 <__divsf3_pse+0x10>
    7038:	33 d0       	rcall	.+102    	; 0x70a0 <__divsf3_pse+0x8e>
    703a:	0e 2e       	mov	r0, r30
    703c:	3a f0       	brmi	.+14     	; 0x704c <__divsf3_pse+0x3a>
    703e:	e0 e8       	ldi	r30, 0x80	; 128
    7040:	30 d0       	rcall	.+96     	; 0x70a2 <__divsf3_pse+0x90>
    7042:	91 50       	subi	r25, 0x01	; 1
    7044:	50 40       	sbci	r21, 0x00	; 0
    7046:	e6 95       	lsr	r30
    7048:	00 1c       	adc	r0, r0
    704a:	ca f7       	brpl	.-14     	; 0x703e <__divsf3_pse+0x2c>
    704c:	29 d0       	rcall	.+82     	; 0x70a0 <__divsf3_pse+0x8e>
    704e:	fe 2f       	mov	r31, r30
    7050:	27 d0       	rcall	.+78     	; 0x70a0 <__divsf3_pse+0x8e>
    7052:	66 0f       	add	r22, r22
    7054:	77 1f       	adc	r23, r23
    7056:	88 1f       	adc	r24, r24
    7058:	bb 1f       	adc	r27, r27
    705a:	26 17       	cp	r18, r22
    705c:	37 07       	cpc	r19, r23
    705e:	48 07       	cpc	r20, r24
    7060:	ab 07       	cpc	r26, r27
    7062:	b0 e8       	ldi	r27, 0x80	; 128
    7064:	09 f0       	breq	.+2      	; 0x7068 <__divsf3_pse+0x56>
    7066:	bb 0b       	sbc	r27, r27
    7068:	80 2d       	mov	r24, r0
    706a:	bf 01       	movw	r22, r30
    706c:	ff 27       	eor	r31, r31
    706e:	93 58       	subi	r25, 0x83	; 131
    7070:	5f 4f       	sbci	r21, 0xFF	; 255
    7072:	2a f0       	brmi	.+10     	; 0x707e <__divsf3_pse+0x6c>
    7074:	9e 3f       	cpi	r25, 0xFE	; 254
    7076:	51 05       	cpc	r21, r1
    7078:	68 f0       	brcs	.+26     	; 0x7094 <__divsf3_pse+0x82>
    707a:	b6 c0       	rjmp	.+364    	; 0x71e8 <__fp_inf>
    707c:	00 c1       	rjmp	.+512    	; 0x727e <__fp_szero>
    707e:	5f 3f       	cpi	r21, 0xFF	; 255
    7080:	ec f3       	brlt	.-6      	; 0x707c <__divsf3_pse+0x6a>
    7082:	98 3e       	cpi	r25, 0xE8	; 232
    7084:	dc f3       	brlt	.-10     	; 0x707c <__divsf3_pse+0x6a>
    7086:	86 95       	lsr	r24
    7088:	77 95       	ror	r23
    708a:	67 95       	ror	r22
    708c:	b7 95       	ror	r27
    708e:	f7 95       	ror	r31
    7090:	9f 5f       	subi	r25, 0xFF	; 255
    7092:	c9 f7       	brne	.-14     	; 0x7086 <__divsf3_pse+0x74>
    7094:	88 0f       	add	r24, r24
    7096:	91 1d       	adc	r25, r1
    7098:	96 95       	lsr	r25
    709a:	87 95       	ror	r24
    709c:	97 f9       	bld	r25, 7
    709e:	08 95       	ret
    70a0:	e1 e0       	ldi	r30, 0x01	; 1
    70a2:	66 0f       	add	r22, r22
    70a4:	77 1f       	adc	r23, r23
    70a6:	88 1f       	adc	r24, r24
    70a8:	bb 1f       	adc	r27, r27
    70aa:	62 17       	cp	r22, r18
    70ac:	73 07       	cpc	r23, r19
    70ae:	84 07       	cpc	r24, r20
    70b0:	ba 07       	cpc	r27, r26
    70b2:	20 f0       	brcs	.+8      	; 0x70bc <__divsf3_pse+0xaa>
    70b4:	62 1b       	sub	r22, r18
    70b6:	73 0b       	sbc	r23, r19
    70b8:	84 0b       	sbc	r24, r20
    70ba:	ba 0b       	sbc	r27, r26
    70bc:	ee 1f       	adc	r30, r30
    70be:	88 f7       	brcc	.-30     	; 0x70a2 <__divsf3_pse+0x90>
    70c0:	e0 95       	com	r30
    70c2:	08 95       	ret

000070c4 <__fixsfsi>:
    70c4:	04 d0       	rcall	.+8      	; 0x70ce <__fixunssfsi>
    70c6:	68 94       	set
    70c8:	b1 11       	cpse	r27, r1
    70ca:	d9 c0       	rjmp	.+434    	; 0x727e <__fp_szero>
    70cc:	08 95       	ret

000070ce <__fixunssfsi>:
    70ce:	bc d0       	rcall	.+376    	; 0x7248 <__fp_splitA>
    70d0:	88 f0       	brcs	.+34     	; 0x70f4 <__fixunssfsi+0x26>
    70d2:	9f 57       	subi	r25, 0x7F	; 127
    70d4:	90 f0       	brcs	.+36     	; 0x70fa <__fixunssfsi+0x2c>
    70d6:	b9 2f       	mov	r27, r25
    70d8:	99 27       	eor	r25, r25
    70da:	b7 51       	subi	r27, 0x17	; 23
    70dc:	a0 f0       	brcs	.+40     	; 0x7106 <__fixunssfsi+0x38>
    70de:	d1 f0       	breq	.+52     	; 0x7114 <__fixunssfsi+0x46>
    70e0:	66 0f       	add	r22, r22
    70e2:	77 1f       	adc	r23, r23
    70e4:	88 1f       	adc	r24, r24
    70e6:	99 1f       	adc	r25, r25
    70e8:	1a f0       	brmi	.+6      	; 0x70f0 <__fixunssfsi+0x22>
    70ea:	ba 95       	dec	r27
    70ec:	c9 f7       	brne	.-14     	; 0x70e0 <__fixunssfsi+0x12>
    70ee:	12 c0       	rjmp	.+36     	; 0x7114 <__fixunssfsi+0x46>
    70f0:	b1 30       	cpi	r27, 0x01	; 1
    70f2:	81 f0       	breq	.+32     	; 0x7114 <__fixunssfsi+0x46>
    70f4:	c3 d0       	rcall	.+390    	; 0x727c <__fp_zero>
    70f6:	b1 e0       	ldi	r27, 0x01	; 1
    70f8:	08 95       	ret
    70fa:	c0 c0       	rjmp	.+384    	; 0x727c <__fp_zero>
    70fc:	67 2f       	mov	r22, r23
    70fe:	78 2f       	mov	r23, r24
    7100:	88 27       	eor	r24, r24
    7102:	b8 5f       	subi	r27, 0xF8	; 248
    7104:	39 f0       	breq	.+14     	; 0x7114 <__fixunssfsi+0x46>
    7106:	b9 3f       	cpi	r27, 0xF9	; 249
    7108:	cc f3       	brlt	.-14     	; 0x70fc <__fixunssfsi+0x2e>
    710a:	86 95       	lsr	r24
    710c:	77 95       	ror	r23
    710e:	67 95       	ror	r22
    7110:	b3 95       	inc	r27
    7112:	d9 f7       	brne	.-10     	; 0x710a <__fixunssfsi+0x3c>
    7114:	3e f4       	brtc	.+14     	; 0x7124 <__fixunssfsi+0x56>
    7116:	90 95       	com	r25
    7118:	80 95       	com	r24
    711a:	70 95       	com	r23
    711c:	61 95       	neg	r22
    711e:	7f 4f       	sbci	r23, 0xFF	; 255
    7120:	8f 4f       	sbci	r24, 0xFF	; 255
    7122:	9f 4f       	sbci	r25, 0xFF	; 255
    7124:	08 95       	ret

00007126 <__floatunsisf>:
    7126:	e8 94       	clt
    7128:	09 c0       	rjmp	.+18     	; 0x713c <__floatsisf+0x12>

0000712a <__floatsisf>:
    712a:	97 fb       	bst	r25, 7
    712c:	3e f4       	brtc	.+14     	; 0x713c <__floatsisf+0x12>
    712e:	90 95       	com	r25
    7130:	80 95       	com	r24
    7132:	70 95       	com	r23
    7134:	61 95       	neg	r22
    7136:	7f 4f       	sbci	r23, 0xFF	; 255
    7138:	8f 4f       	sbci	r24, 0xFF	; 255
    713a:	9f 4f       	sbci	r25, 0xFF	; 255
    713c:	99 23       	and	r25, r25
    713e:	a9 f0       	breq	.+42     	; 0x716a <__floatsisf+0x40>
    7140:	f9 2f       	mov	r31, r25
    7142:	96 e9       	ldi	r25, 0x96	; 150
    7144:	bb 27       	eor	r27, r27
    7146:	93 95       	inc	r25
    7148:	f6 95       	lsr	r31
    714a:	87 95       	ror	r24
    714c:	77 95       	ror	r23
    714e:	67 95       	ror	r22
    7150:	b7 95       	ror	r27
    7152:	f1 11       	cpse	r31, r1
    7154:	f8 cf       	rjmp	.-16     	; 0x7146 <__floatsisf+0x1c>
    7156:	fa f4       	brpl	.+62     	; 0x7196 <__floatsisf+0x6c>
    7158:	bb 0f       	add	r27, r27
    715a:	11 f4       	brne	.+4      	; 0x7160 <__floatsisf+0x36>
    715c:	60 ff       	sbrs	r22, 0
    715e:	1b c0       	rjmp	.+54     	; 0x7196 <__floatsisf+0x6c>
    7160:	6f 5f       	subi	r22, 0xFF	; 255
    7162:	7f 4f       	sbci	r23, 0xFF	; 255
    7164:	8f 4f       	sbci	r24, 0xFF	; 255
    7166:	9f 4f       	sbci	r25, 0xFF	; 255
    7168:	16 c0       	rjmp	.+44     	; 0x7196 <__floatsisf+0x6c>
    716a:	88 23       	and	r24, r24
    716c:	11 f0       	breq	.+4      	; 0x7172 <__floatsisf+0x48>
    716e:	96 e9       	ldi	r25, 0x96	; 150
    7170:	11 c0       	rjmp	.+34     	; 0x7194 <__floatsisf+0x6a>
    7172:	77 23       	and	r23, r23
    7174:	21 f0       	breq	.+8      	; 0x717e <__floatsisf+0x54>
    7176:	9e e8       	ldi	r25, 0x8E	; 142
    7178:	87 2f       	mov	r24, r23
    717a:	76 2f       	mov	r23, r22
    717c:	05 c0       	rjmp	.+10     	; 0x7188 <__floatsisf+0x5e>
    717e:	66 23       	and	r22, r22
    7180:	71 f0       	breq	.+28     	; 0x719e <__floatsisf+0x74>
    7182:	96 e8       	ldi	r25, 0x86	; 134
    7184:	86 2f       	mov	r24, r22
    7186:	70 e0       	ldi	r23, 0x00	; 0
    7188:	60 e0       	ldi	r22, 0x00	; 0
    718a:	2a f0       	brmi	.+10     	; 0x7196 <__floatsisf+0x6c>
    718c:	9a 95       	dec	r25
    718e:	66 0f       	add	r22, r22
    7190:	77 1f       	adc	r23, r23
    7192:	88 1f       	adc	r24, r24
    7194:	da f7       	brpl	.-10     	; 0x718c <__floatsisf+0x62>
    7196:	88 0f       	add	r24, r24
    7198:	96 95       	lsr	r25
    719a:	87 95       	ror	r24
    719c:	97 f9       	bld	r25, 7
    719e:	08 95       	ret

000071a0 <__fp_cmp>:
    71a0:	99 0f       	add	r25, r25
    71a2:	00 08       	sbc	r0, r0
    71a4:	55 0f       	add	r21, r21
    71a6:	aa 0b       	sbc	r26, r26
    71a8:	e0 e8       	ldi	r30, 0x80	; 128
    71aa:	fe ef       	ldi	r31, 0xFE	; 254
    71ac:	16 16       	cp	r1, r22
    71ae:	17 06       	cpc	r1, r23
    71b0:	e8 07       	cpc	r30, r24
    71b2:	f9 07       	cpc	r31, r25
    71b4:	c0 f0       	brcs	.+48     	; 0x71e6 <__fp_cmp+0x46>
    71b6:	12 16       	cp	r1, r18
    71b8:	13 06       	cpc	r1, r19
    71ba:	e4 07       	cpc	r30, r20
    71bc:	f5 07       	cpc	r31, r21
    71be:	98 f0       	brcs	.+38     	; 0x71e6 <__fp_cmp+0x46>
    71c0:	62 1b       	sub	r22, r18
    71c2:	73 0b       	sbc	r23, r19
    71c4:	84 0b       	sbc	r24, r20
    71c6:	95 0b       	sbc	r25, r21
    71c8:	39 f4       	brne	.+14     	; 0x71d8 <__fp_cmp+0x38>
    71ca:	0a 26       	eor	r0, r26
    71cc:	61 f0       	breq	.+24     	; 0x71e6 <__fp_cmp+0x46>
    71ce:	23 2b       	or	r18, r19
    71d0:	24 2b       	or	r18, r20
    71d2:	25 2b       	or	r18, r21
    71d4:	21 f4       	brne	.+8      	; 0x71de <__fp_cmp+0x3e>
    71d6:	08 95       	ret
    71d8:	0a 26       	eor	r0, r26
    71da:	09 f4       	brne	.+2      	; 0x71de <__fp_cmp+0x3e>
    71dc:	a1 40       	sbci	r26, 0x01	; 1
    71de:	a6 95       	lsr	r26
    71e0:	8f ef       	ldi	r24, 0xFF	; 255
    71e2:	81 1d       	adc	r24, r1
    71e4:	81 1d       	adc	r24, r1
    71e6:	08 95       	ret

000071e8 <__fp_inf>:
    71e8:	97 f9       	bld	r25, 7
    71ea:	9f 67       	ori	r25, 0x7F	; 127
    71ec:	80 e8       	ldi	r24, 0x80	; 128
    71ee:	70 e0       	ldi	r23, 0x00	; 0
    71f0:	60 e0       	ldi	r22, 0x00	; 0
    71f2:	08 95       	ret

000071f4 <__fp_nan>:
    71f4:	9f ef       	ldi	r25, 0xFF	; 255
    71f6:	80 ec       	ldi	r24, 0xC0	; 192
    71f8:	08 95       	ret

000071fa <__fp_pscA>:
    71fa:	00 24       	eor	r0, r0
    71fc:	0a 94       	dec	r0
    71fe:	16 16       	cp	r1, r22
    7200:	17 06       	cpc	r1, r23
    7202:	18 06       	cpc	r1, r24
    7204:	09 06       	cpc	r0, r25
    7206:	08 95       	ret

00007208 <__fp_pscB>:
    7208:	00 24       	eor	r0, r0
    720a:	0a 94       	dec	r0
    720c:	12 16       	cp	r1, r18
    720e:	13 06       	cpc	r1, r19
    7210:	14 06       	cpc	r1, r20
    7212:	05 06       	cpc	r0, r21
    7214:	08 95       	ret

00007216 <__fp_round>:
    7216:	09 2e       	mov	r0, r25
    7218:	03 94       	inc	r0
    721a:	00 0c       	add	r0, r0
    721c:	11 f4       	brne	.+4      	; 0x7222 <__fp_round+0xc>
    721e:	88 23       	and	r24, r24
    7220:	52 f0       	brmi	.+20     	; 0x7236 <__fp_round+0x20>
    7222:	bb 0f       	add	r27, r27
    7224:	40 f4       	brcc	.+16     	; 0x7236 <__fp_round+0x20>
    7226:	bf 2b       	or	r27, r31
    7228:	11 f4       	brne	.+4      	; 0x722e <__fp_round+0x18>
    722a:	60 ff       	sbrs	r22, 0
    722c:	04 c0       	rjmp	.+8      	; 0x7236 <__fp_round+0x20>
    722e:	6f 5f       	subi	r22, 0xFF	; 255
    7230:	7f 4f       	sbci	r23, 0xFF	; 255
    7232:	8f 4f       	sbci	r24, 0xFF	; 255
    7234:	9f 4f       	sbci	r25, 0xFF	; 255
    7236:	08 95       	ret

00007238 <__fp_split3>:
    7238:	57 fd       	sbrc	r21, 7
    723a:	90 58       	subi	r25, 0x80	; 128
    723c:	44 0f       	add	r20, r20
    723e:	55 1f       	adc	r21, r21
    7240:	59 f0       	breq	.+22     	; 0x7258 <__fp_splitA+0x10>
    7242:	5f 3f       	cpi	r21, 0xFF	; 255
    7244:	71 f0       	breq	.+28     	; 0x7262 <__fp_splitA+0x1a>
    7246:	47 95       	ror	r20

00007248 <__fp_splitA>:
    7248:	88 0f       	add	r24, r24
    724a:	97 fb       	bst	r25, 7
    724c:	99 1f       	adc	r25, r25
    724e:	61 f0       	breq	.+24     	; 0x7268 <__fp_splitA+0x20>
    7250:	9f 3f       	cpi	r25, 0xFF	; 255
    7252:	79 f0       	breq	.+30     	; 0x7272 <__fp_splitA+0x2a>
    7254:	87 95       	ror	r24
    7256:	08 95       	ret
    7258:	12 16       	cp	r1, r18
    725a:	13 06       	cpc	r1, r19
    725c:	14 06       	cpc	r1, r20
    725e:	55 1f       	adc	r21, r21
    7260:	f2 cf       	rjmp	.-28     	; 0x7246 <__fp_split3+0xe>
    7262:	46 95       	lsr	r20
    7264:	f1 df       	rcall	.-30     	; 0x7248 <__fp_splitA>
    7266:	08 c0       	rjmp	.+16     	; 0x7278 <__fp_splitA+0x30>
    7268:	16 16       	cp	r1, r22
    726a:	17 06       	cpc	r1, r23
    726c:	18 06       	cpc	r1, r24
    726e:	99 1f       	adc	r25, r25
    7270:	f1 cf       	rjmp	.-30     	; 0x7254 <__fp_splitA+0xc>
    7272:	86 95       	lsr	r24
    7274:	71 05       	cpc	r23, r1
    7276:	61 05       	cpc	r22, r1
    7278:	08 94       	sec
    727a:	08 95       	ret

0000727c <__fp_zero>:
    727c:	e8 94       	clt

0000727e <__fp_szero>:
    727e:	bb 27       	eor	r27, r27
    7280:	66 27       	eor	r22, r22
    7282:	77 27       	eor	r23, r23
    7284:	cb 01       	movw	r24, r22
    7286:	97 f9       	bld	r25, 7
    7288:	08 95       	ret

0000728a <__gesf2>:
    728a:	8a df       	rcall	.-236    	; 0x71a0 <__fp_cmp>
    728c:	08 f4       	brcc	.+2      	; 0x7290 <__gesf2+0x6>
    728e:	8f ef       	ldi	r24, 0xFF	; 255
    7290:	08 95       	ret

00007292 <__mulsf3>:
    7292:	0b d0       	rcall	.+22     	; 0x72aa <__mulsf3x>
    7294:	c0 cf       	rjmp	.-128    	; 0x7216 <__fp_round>
    7296:	b1 df       	rcall	.-158    	; 0x71fa <__fp_pscA>
    7298:	28 f0       	brcs	.+10     	; 0x72a4 <__mulsf3+0x12>
    729a:	b6 df       	rcall	.-148    	; 0x7208 <__fp_pscB>
    729c:	18 f0       	brcs	.+6      	; 0x72a4 <__mulsf3+0x12>
    729e:	95 23       	and	r25, r21
    72a0:	09 f0       	breq	.+2      	; 0x72a4 <__mulsf3+0x12>
    72a2:	a2 cf       	rjmp	.-188    	; 0x71e8 <__fp_inf>
    72a4:	a7 cf       	rjmp	.-178    	; 0x71f4 <__fp_nan>
    72a6:	11 24       	eor	r1, r1
    72a8:	ea cf       	rjmp	.-44     	; 0x727e <__fp_szero>

000072aa <__mulsf3x>:
    72aa:	c6 df       	rcall	.-116    	; 0x7238 <__fp_split3>
    72ac:	a0 f3       	brcs	.-24     	; 0x7296 <__mulsf3+0x4>

000072ae <__mulsf3_pse>:
    72ae:	95 9f       	mul	r25, r21
    72b0:	d1 f3       	breq	.-12     	; 0x72a6 <__mulsf3+0x14>
    72b2:	95 0f       	add	r25, r21
    72b4:	50 e0       	ldi	r21, 0x00	; 0
    72b6:	55 1f       	adc	r21, r21
    72b8:	62 9f       	mul	r22, r18
    72ba:	f0 01       	movw	r30, r0
    72bc:	72 9f       	mul	r23, r18
    72be:	bb 27       	eor	r27, r27
    72c0:	f0 0d       	add	r31, r0
    72c2:	b1 1d       	adc	r27, r1
    72c4:	63 9f       	mul	r22, r19
    72c6:	aa 27       	eor	r26, r26
    72c8:	f0 0d       	add	r31, r0
    72ca:	b1 1d       	adc	r27, r1
    72cc:	aa 1f       	adc	r26, r26
    72ce:	64 9f       	mul	r22, r20
    72d0:	66 27       	eor	r22, r22
    72d2:	b0 0d       	add	r27, r0
    72d4:	a1 1d       	adc	r26, r1
    72d6:	66 1f       	adc	r22, r22
    72d8:	82 9f       	mul	r24, r18
    72da:	22 27       	eor	r18, r18
    72dc:	b0 0d       	add	r27, r0
    72de:	a1 1d       	adc	r26, r1
    72e0:	62 1f       	adc	r22, r18
    72e2:	73 9f       	mul	r23, r19
    72e4:	b0 0d       	add	r27, r0
    72e6:	a1 1d       	adc	r26, r1
    72e8:	62 1f       	adc	r22, r18
    72ea:	83 9f       	mul	r24, r19
    72ec:	a0 0d       	add	r26, r0
    72ee:	61 1d       	adc	r22, r1
    72f0:	22 1f       	adc	r18, r18
    72f2:	74 9f       	mul	r23, r20
    72f4:	33 27       	eor	r19, r19
    72f6:	a0 0d       	add	r26, r0
    72f8:	61 1d       	adc	r22, r1
    72fa:	23 1f       	adc	r18, r19
    72fc:	84 9f       	mul	r24, r20
    72fe:	60 0d       	add	r22, r0
    7300:	21 1d       	adc	r18, r1
    7302:	82 2f       	mov	r24, r18
    7304:	76 2f       	mov	r23, r22
    7306:	6a 2f       	mov	r22, r26
    7308:	11 24       	eor	r1, r1
    730a:	9f 57       	subi	r25, 0x7F	; 127
    730c:	50 40       	sbci	r21, 0x00	; 0
    730e:	8a f0       	brmi	.+34     	; 0x7332 <__mulsf3_pse+0x84>
    7310:	e1 f0       	breq	.+56     	; 0x734a <__mulsf3_pse+0x9c>
    7312:	88 23       	and	r24, r24
    7314:	4a f0       	brmi	.+18     	; 0x7328 <__mulsf3_pse+0x7a>
    7316:	ee 0f       	add	r30, r30
    7318:	ff 1f       	adc	r31, r31
    731a:	bb 1f       	adc	r27, r27
    731c:	66 1f       	adc	r22, r22
    731e:	77 1f       	adc	r23, r23
    7320:	88 1f       	adc	r24, r24
    7322:	91 50       	subi	r25, 0x01	; 1
    7324:	50 40       	sbci	r21, 0x00	; 0
    7326:	a9 f7       	brne	.-22     	; 0x7312 <__mulsf3_pse+0x64>
    7328:	9e 3f       	cpi	r25, 0xFE	; 254
    732a:	51 05       	cpc	r21, r1
    732c:	70 f0       	brcs	.+28     	; 0x734a <__mulsf3_pse+0x9c>
    732e:	5c cf       	rjmp	.-328    	; 0x71e8 <__fp_inf>
    7330:	a6 cf       	rjmp	.-180    	; 0x727e <__fp_szero>
    7332:	5f 3f       	cpi	r21, 0xFF	; 255
    7334:	ec f3       	brlt	.-6      	; 0x7330 <__mulsf3_pse+0x82>
    7336:	98 3e       	cpi	r25, 0xE8	; 232
    7338:	dc f3       	brlt	.-10     	; 0x7330 <__mulsf3_pse+0x82>
    733a:	86 95       	lsr	r24
    733c:	77 95       	ror	r23
    733e:	67 95       	ror	r22
    7340:	b7 95       	ror	r27
    7342:	f7 95       	ror	r31
    7344:	e7 95       	ror	r30
    7346:	9f 5f       	subi	r25, 0xFF	; 255
    7348:	c1 f7       	brne	.-16     	; 0x733a <__mulsf3_pse+0x8c>
    734a:	fe 2b       	or	r31, r30
    734c:	88 0f       	add	r24, r24
    734e:	91 1d       	adc	r25, r1
    7350:	96 95       	lsr	r25
    7352:	87 95       	ror	r24
    7354:	97 f9       	bld	r25, 7
    7356:	08 95       	ret

00007358 <sin>:
    7358:	9f 93       	push	r25
    735a:	05 d0       	rcall	.+10     	; 0x7366 <__fp_rempio2>
    735c:	0f 90       	pop	r0
    735e:	07 fc       	sbrc	r0, 7
    7360:	ee 5f       	subi	r30, 0xFE	; 254
    7362:	28 c0       	rjmp	.+80     	; 0x73b4 <__fp_sinus>
    7364:	47 cf       	rjmp	.-370    	; 0x71f4 <__fp_nan>

00007366 <__fp_rempio2>:
    7366:	70 df       	rcall	.-288    	; 0x7248 <__fp_splitA>
    7368:	e8 f3       	brcs	.-6      	; 0x7364 <sin+0xc>
    736a:	e8 94       	clt
    736c:	e0 e0       	ldi	r30, 0x00	; 0
    736e:	bb 27       	eor	r27, r27
    7370:	9f 57       	subi	r25, 0x7F	; 127
    7372:	f0 f0       	brcs	.+60     	; 0x73b0 <__fp_rempio2+0x4a>
    7374:	2a ed       	ldi	r18, 0xDA	; 218
    7376:	3f e0       	ldi	r19, 0x0F	; 15
    7378:	49 ec       	ldi	r20, 0xC9	; 201
    737a:	06 c0       	rjmp	.+12     	; 0x7388 <__fp_rempio2+0x22>
    737c:	ee 0f       	add	r30, r30
    737e:	bb 0f       	add	r27, r27
    7380:	66 1f       	adc	r22, r22
    7382:	77 1f       	adc	r23, r23
    7384:	88 1f       	adc	r24, r24
    7386:	28 f0       	brcs	.+10     	; 0x7392 <__fp_rempio2+0x2c>
    7388:	b2 3a       	cpi	r27, 0xA2	; 162
    738a:	62 07       	cpc	r22, r18
    738c:	73 07       	cpc	r23, r19
    738e:	84 07       	cpc	r24, r20
    7390:	28 f0       	brcs	.+10     	; 0x739c <__fp_rempio2+0x36>
    7392:	b2 5a       	subi	r27, 0xA2	; 162
    7394:	62 0b       	sbc	r22, r18
    7396:	73 0b       	sbc	r23, r19
    7398:	84 0b       	sbc	r24, r20
    739a:	e3 95       	inc	r30
    739c:	9a 95       	dec	r25
    739e:	72 f7       	brpl	.-36     	; 0x737c <__fp_rempio2+0x16>
    73a0:	80 38       	cpi	r24, 0x80	; 128
    73a2:	30 f4       	brcc	.+12     	; 0x73b0 <__fp_rempio2+0x4a>
    73a4:	9a 95       	dec	r25
    73a6:	bb 0f       	add	r27, r27
    73a8:	66 1f       	adc	r22, r22
    73aa:	77 1f       	adc	r23, r23
    73ac:	88 1f       	adc	r24, r24
    73ae:	d2 f7       	brpl	.-12     	; 0x73a4 <__fp_rempio2+0x3e>
    73b0:	90 48       	sbci	r25, 0x80	; 128
    73b2:	13 c0       	rjmp	.+38     	; 0x73da <__fp_mpack_finite>

000073b4 <__fp_sinus>:
    73b4:	ef 93       	push	r30
    73b6:	e0 ff       	sbrs	r30, 0
    73b8:	06 c0       	rjmp	.+12     	; 0x73c6 <__fp_sinus+0x12>
    73ba:	a2 ea       	ldi	r26, 0xA2	; 162
    73bc:	2a ed       	ldi	r18, 0xDA	; 218
    73be:	3f e0       	ldi	r19, 0x0F	; 15
    73c0:	49 ec       	ldi	r20, 0xC9	; 201
    73c2:	5f eb       	ldi	r21, 0xBF	; 191
    73c4:	c0 dd       	rcall	.-1152   	; 0x6f46 <__addsf3x>
    73c6:	27 df       	rcall	.-434    	; 0x7216 <__fp_round>
    73c8:	0f 90       	pop	r0
    73ca:	03 94       	inc	r0
    73cc:	01 fc       	sbrc	r0, 1
    73ce:	90 58       	subi	r25, 0x80	; 128
    73d0:	ec e7       	ldi	r30, 0x7C	; 124
    73d2:	f0 e0       	ldi	r31, 0x00	; 0
    73d4:	0e c0       	rjmp	.+28     	; 0x73f2 <__fp_powsodd>

000073d6 <__fp_mpack>:
    73d6:	9f 3f       	cpi	r25, 0xFF	; 255
    73d8:	31 f0       	breq	.+12     	; 0x73e6 <__fp_mpack_finite+0xc>

000073da <__fp_mpack_finite>:
    73da:	91 50       	subi	r25, 0x01	; 1
    73dc:	20 f4       	brcc	.+8      	; 0x73e6 <__fp_mpack_finite+0xc>
    73de:	87 95       	ror	r24
    73e0:	77 95       	ror	r23
    73e2:	67 95       	ror	r22
    73e4:	b7 95       	ror	r27
    73e6:	88 0f       	add	r24, r24
    73e8:	91 1d       	adc	r25, r1
    73ea:	96 95       	lsr	r25
    73ec:	87 95       	ror	r24
    73ee:	97 f9       	bld	r25, 7
    73f0:	08 95       	ret

000073f2 <__fp_powsodd>:
    73f2:	9f 93       	push	r25
    73f4:	8f 93       	push	r24
    73f6:	7f 93       	push	r23
    73f8:	6f 93       	push	r22
    73fa:	ff 93       	push	r31
    73fc:	ef 93       	push	r30
    73fe:	9b 01       	movw	r18, r22
    7400:	ac 01       	movw	r20, r24
    7402:	47 df       	rcall	.-370    	; 0x7292 <__mulsf3>
    7404:	ef 91       	pop	r30
    7406:	ff 91       	pop	r31
    7408:	05 d0       	rcall	.+10     	; 0x7414 <__fp_powser>
    740a:	2f 91       	pop	r18
    740c:	3f 91       	pop	r19
    740e:	4f 91       	pop	r20
    7410:	5f 91       	pop	r21
    7412:	3f cf       	rjmp	.-386    	; 0x7292 <__mulsf3>

00007414 <__fp_powser>:
    7414:	df 93       	push	r29
    7416:	cf 93       	push	r28
    7418:	1f 93       	push	r17
    741a:	0f 93       	push	r16
    741c:	ff 92       	push	r15
    741e:	ef 92       	push	r14
    7420:	df 92       	push	r13
    7422:	7b 01       	movw	r14, r22
    7424:	8c 01       	movw	r16, r24
    7426:	68 94       	set
    7428:	05 c0       	rjmp	.+10     	; 0x7434 <__fp_powser+0x20>
    742a:	da 2e       	mov	r13, r26
    742c:	ef 01       	movw	r28, r30
    742e:	3d df       	rcall	.-390    	; 0x72aa <__mulsf3x>
    7430:	fe 01       	movw	r30, r28
    7432:	e8 94       	clt
    7434:	a5 91       	lpm	r26, Z+
    7436:	25 91       	lpm	r18, Z+
    7438:	35 91       	lpm	r19, Z+
    743a:	45 91       	lpm	r20, Z+
    743c:	55 91       	lpm	r21, Z+
    743e:	ae f3       	brts	.-22     	; 0x742a <__fp_powser+0x16>
    7440:	ef 01       	movw	r28, r30
    7442:	81 dd       	rcall	.-1278   	; 0x6f46 <__addsf3x>
    7444:	fe 01       	movw	r30, r28
    7446:	97 01       	movw	r18, r14
    7448:	a8 01       	movw	r20, r16
    744a:	da 94       	dec	r13
    744c:	79 f7       	brne	.-34     	; 0x742c <__fp_powser+0x18>
    744e:	df 90       	pop	r13
    7450:	ef 90       	pop	r14
    7452:	ff 90       	pop	r15
    7454:	0f 91       	pop	r16
    7456:	1f 91       	pop	r17
    7458:	cf 91       	pop	r28
    745a:	df 91       	pop	r29
    745c:	08 95       	ret

0000745e <__udivmodhi4>:
    745e:	aa 1b       	sub	r26, r26
    7460:	bb 1b       	sub	r27, r27
    7462:	51 e1       	ldi	r21, 0x11	; 17
    7464:	07 c0       	rjmp	.+14     	; 0x7474 <__udivmodhi4_ep>

00007466 <__udivmodhi4_loop>:
    7466:	aa 1f       	adc	r26, r26
    7468:	bb 1f       	adc	r27, r27
    746a:	a6 17       	cp	r26, r22
    746c:	b7 07       	cpc	r27, r23
    746e:	10 f0       	brcs	.+4      	; 0x7474 <__udivmodhi4_ep>
    7470:	a6 1b       	sub	r26, r22
    7472:	b7 0b       	sbc	r27, r23

00007474 <__udivmodhi4_ep>:
    7474:	88 1f       	adc	r24, r24
    7476:	99 1f       	adc	r25, r25
    7478:	5a 95       	dec	r21
    747a:	a9 f7       	brne	.-22     	; 0x7466 <__udivmodhi4_loop>
    747c:	80 95       	com	r24
    747e:	90 95       	com	r25
    7480:	bc 01       	movw	r22, r24
    7482:	cd 01       	movw	r24, r26
    7484:	08 95       	ret

00007486 <__divmodhi4>:
    7486:	97 fb       	bst	r25, 7
    7488:	09 2e       	mov	r0, r25
    748a:	07 26       	eor	r0, r23
    748c:	0a d0       	rcall	.+20     	; 0x74a2 <__divmodhi4_neg1>
    748e:	77 fd       	sbrc	r23, 7
    7490:	04 d0       	rcall	.+8      	; 0x749a <__divmodhi4_neg2>
    7492:	e5 df       	rcall	.-54     	; 0x745e <__udivmodhi4>
    7494:	06 d0       	rcall	.+12     	; 0x74a2 <__divmodhi4_neg1>
    7496:	00 20       	and	r0, r0
    7498:	1a f4       	brpl	.+6      	; 0x74a0 <__divmodhi4_exit>

0000749a <__divmodhi4_neg2>:
    749a:	70 95       	com	r23
    749c:	61 95       	neg	r22
    749e:	7f 4f       	sbci	r23, 0xFF	; 255

000074a0 <__divmodhi4_exit>:
    74a0:	08 95       	ret

000074a2 <__divmodhi4_neg1>:
    74a2:	f6 f7       	brtc	.-4      	; 0x74a0 <__divmodhi4_exit>
    74a4:	90 95       	com	r25
    74a6:	81 95       	neg	r24
    74a8:	9f 4f       	sbci	r25, 0xFF	; 255
    74aa:	08 95       	ret

000074ac <abs>:
    74ac:	28 2f       	mov	r18, r24
    74ae:	39 2f       	mov	r19, r25
    74b0:	37 ff       	sbrs	r19, 7
    74b2:	03 c0       	rjmp	.+6      	; 0x74ba <abs+0xe>
    74b4:	30 95       	com	r19
    74b6:	21 95       	neg	r18
    74b8:	3f 4f       	sbci	r19, 0xFF	; 255
    74ba:	c9 01       	movw	r24, r18
    74bc:	08 95       	ret

000074be <dtostrf>:
    74be:	ef 92       	push	r14
    74c0:	ff 92       	push	r15
    74c2:	0f 93       	push	r16
    74c4:	1f 93       	push	r17
    74c6:	32 2f       	mov	r19, r18
    74c8:	f0 2e       	mov	r15, r16
    74ca:	47 ff       	sbrs	r20, 7
    74cc:	02 c0       	rjmp	.+4      	; 0x74d2 <dtostrf+0x14>
    74ce:	a4 e1       	ldi	r26, 0x14	; 20
    74d0:	01 c0       	rjmp	.+2      	; 0x74d4 <dtostrf+0x16>
    74d2:	a4 e0       	ldi	r26, 0x04	; 4
    74d4:	e4 2f       	mov	r30, r20
    74d6:	ff 27       	eor	r31, r31
    74d8:	e7 fd       	sbrc	r30, 7
    74da:	f0 95       	com	r31
    74dc:	f7 ff       	sbrs	r31, 7
    74de:	03 c0       	rjmp	.+6      	; 0x74e6 <dtostrf+0x28>
    74e0:	f0 95       	com	r31
    74e2:	e1 95       	neg	r30
    74e4:	ff 4f       	sbci	r31, 0xFF	; 255
    74e6:	4f 2d       	mov	r20, r15
    74e8:	51 2f       	mov	r21, r17
    74ea:	2e 2f       	mov	r18, r30
    74ec:	03 2f       	mov	r16, r19
    74ee:	ea 2e       	mov	r14, r26
    74f0:	0e 94 0b 3b 	call	0x7616	; 0x7616 <dtoa_prf>
    74f4:	8f 2d       	mov	r24, r15
    74f6:	91 2f       	mov	r25, r17
    74f8:	1f 91       	pop	r17
    74fa:	0f 91       	pop	r16
    74fc:	ff 90       	pop	r15
    74fe:	ef 90       	pop	r14
    7500:	08 95       	ret

00007502 <memcpy_P>:
    7502:	fb 01       	movw	r30, r22
    7504:	dc 01       	movw	r26, r24
    7506:	02 c0       	rjmp	.+4      	; 0x750c <memcpy_P+0xa>
    7508:	05 90       	lpm	r0, Z+
    750a:	0d 92       	st	X+, r0
    750c:	41 50       	subi	r20, 0x01	; 1
    750e:	50 40       	sbci	r21, 0x00	; 0
    7510:	d8 f7       	brcc	.-10     	; 0x7508 <memcpy_P+0x6>
    7512:	08 95       	ret

00007514 <strcpy_P>:
    7514:	fb 01       	movw	r30, r22
    7516:	dc 01       	movw	r26, r24
    7518:	05 90       	lpm	r0, Z+
    751a:	0d 92       	st	X+, r0
    751c:	00 20       	and	r0, r0
    751e:	e1 f7       	brne	.-8      	; 0x7518 <strcpy_P+0x4>
    7520:	08 95       	ret

00007522 <strlen_P>:
    7522:	fc 01       	movw	r30, r24
    7524:	05 90       	lpm	r0, Z+
    7526:	00 20       	and	r0, r0
    7528:	e9 f7       	brne	.-6      	; 0x7524 <strlen_P+0x2>
    752a:	80 95       	com	r24
    752c:	90 95       	com	r25
    752e:	8e 0f       	add	r24, r30
    7530:	9f 1f       	adc	r25, r31
    7532:	08 95       	ret

00007534 <memcpy>:
    7534:	fb 01       	movw	r30, r22
    7536:	dc 01       	movw	r26, r24
    7538:	02 c0       	rjmp	.+4      	; 0x753e <memcpy+0xa>
    753a:	01 90       	ld	r0, Z+
    753c:	0d 92       	st	X+, r0
    753e:	41 50       	subi	r20, 0x01	; 1
    7540:	50 40       	sbci	r21, 0x00	; 0
    7542:	d8 f7       	brcc	.-10     	; 0x753a <memcpy+0x6>
    7544:	08 95       	ret

00007546 <strcat>:
    7546:	fb 01       	movw	r30, r22
    7548:	dc 01       	movw	r26, r24
    754a:	0d 90       	ld	r0, X+
    754c:	00 20       	and	r0, r0
    754e:	e9 f7       	brne	.-6      	; 0x754a <strcat+0x4>
    7550:	11 97       	sbiw	r26, 0x01	; 1
    7552:	01 90       	ld	r0, Z+
    7554:	0d 92       	st	X+, r0
    7556:	00 20       	and	r0, r0
    7558:	e1 f7       	brne	.-8      	; 0x7552 <strcat+0xc>
    755a:	08 95       	ret

0000755c <itoa>:
    755c:	fb 01       	movw	r30, r22
    755e:	9f 01       	movw	r18, r30
    7560:	e8 94       	clt
    7562:	42 30       	cpi	r20, 0x02	; 2
    7564:	c4 f0       	brlt	.+48     	; 0x7596 <itoa+0x3a>
    7566:	45 32       	cpi	r20, 0x25	; 37
    7568:	b4 f4       	brge	.+44     	; 0x7596 <itoa+0x3a>
    756a:	4a 30       	cpi	r20, 0x0A	; 10
    756c:	29 f4       	brne	.+10     	; 0x7578 <itoa+0x1c>
    756e:	97 fb       	bst	r25, 7
    7570:	1e f4       	brtc	.+6      	; 0x7578 <itoa+0x1c>
    7572:	90 95       	com	r25
    7574:	81 95       	neg	r24
    7576:	9f 4f       	sbci	r25, 0xFF	; 255
    7578:	64 2f       	mov	r22, r20
    757a:	77 27       	eor	r23, r23
    757c:	0e 94 2f 3a 	call	0x745e	; 0x745e <__udivmodhi4>
    7580:	80 5d       	subi	r24, 0xD0	; 208
    7582:	8a 33       	cpi	r24, 0x3A	; 58
    7584:	0c f0       	brlt	.+2      	; 0x7588 <itoa+0x2c>
    7586:	89 5d       	subi	r24, 0xD9	; 217
    7588:	81 93       	st	Z+, r24
    758a:	cb 01       	movw	r24, r22
    758c:	00 97       	sbiw	r24, 0x00	; 0
    758e:	a1 f7       	brne	.-24     	; 0x7578 <itoa+0x1c>
    7590:	16 f4       	brtc	.+4      	; 0x7596 <itoa+0x3a>
    7592:	5d e2       	ldi	r21, 0x2D	; 45
    7594:	51 93       	st	Z+, r21
    7596:	10 82       	st	Z, r1
    7598:	c9 01       	movw	r24, r18
    759a:	0c 94 3a 3d 	jmp	0x7a74	; 0x7a74 <strrev>

0000759e <utoa>:
    759e:	fb 01       	movw	r30, r22
    75a0:	9f 01       	movw	r18, r30
    75a2:	42 30       	cpi	r20, 0x02	; 2
    75a4:	74 f0       	brlt	.+28     	; 0x75c2 <utoa+0x24>
    75a6:	45 32       	cpi	r20, 0x25	; 37
    75a8:	64 f4       	brge	.+24     	; 0x75c2 <utoa+0x24>
    75aa:	64 2f       	mov	r22, r20
    75ac:	77 27       	eor	r23, r23
    75ae:	0e 94 2f 3a 	call	0x745e	; 0x745e <__udivmodhi4>
    75b2:	80 5d       	subi	r24, 0xD0	; 208
    75b4:	8a 33       	cpi	r24, 0x3A	; 58
    75b6:	0c f0       	brlt	.+2      	; 0x75ba <utoa+0x1c>
    75b8:	89 5d       	subi	r24, 0xD9	; 217
    75ba:	81 93       	st	Z+, r24
    75bc:	cb 01       	movw	r24, r22
    75be:	00 97       	sbiw	r24, 0x00	; 0
    75c0:	a1 f7       	brne	.-24     	; 0x75aa <utoa+0xc>
    75c2:	10 82       	st	Z, r1
    75c4:	c9 01       	movw	r24, r18
    75c6:	0c 94 3a 3d 	jmp	0x7a74	; 0x7a74 <strrev>

000075ca <__eerd_block_m324pa>:
    75ca:	dc 01       	movw	r26, r24
    75cc:	cb 01       	movw	r24, r22

000075ce <__eerd_blraw_m324pa>:
    75ce:	fc 01       	movw	r30, r24
    75d0:	f9 99       	sbic	0x1f, 1	; 31
    75d2:	fe cf       	rjmp	.-4      	; 0x75d0 <__eerd_blraw_m324pa+0x2>
    75d4:	06 c0       	rjmp	.+12     	; 0x75e2 <__eerd_blraw_m324pa+0x14>
    75d6:	f2 bd       	out	0x22, r31	; 34
    75d8:	e1 bd       	out	0x21, r30	; 33
    75da:	f8 9a       	sbi	0x1f, 0	; 31
    75dc:	31 96       	adiw	r30, 0x01	; 1
    75de:	00 b4       	in	r0, 0x20	; 32
    75e0:	0d 92       	st	X+, r0
    75e2:	41 50       	subi	r20, 0x01	; 1
    75e4:	50 40       	sbci	r21, 0x00	; 0
    75e6:	b8 f7       	brcc	.-18     	; 0x75d6 <__eerd_blraw_m324pa+0x8>
    75e8:	08 95       	ret

000075ea <__eerd_byte_m324pa>:
    75ea:	f9 99       	sbic	0x1f, 1	; 31
    75ec:	fe cf       	rjmp	.-4      	; 0x75ea <__eerd_byte_m324pa>
    75ee:	92 bd       	out	0x22, r25	; 34
    75f0:	81 bd       	out	0x21, r24	; 33
    75f2:	f8 9a       	sbi	0x1f, 0	; 31
    75f4:	99 27       	eor	r25, r25
    75f6:	80 b5       	in	r24, 0x20	; 32
    75f8:	08 95       	ret

000075fa <__eewr_byte_m324pa>:
    75fa:	26 2f       	mov	r18, r22

000075fc <__eewr_r18_m324pa>:
    75fc:	f9 99       	sbic	0x1f, 1	; 31
    75fe:	fe cf       	rjmp	.-4      	; 0x75fc <__eewr_r18_m324pa>
    7600:	1f ba       	out	0x1f, r1	; 31
    7602:	92 bd       	out	0x22, r25	; 34
    7604:	81 bd       	out	0x21, r24	; 33
    7606:	20 bd       	out	0x20, r18	; 32
    7608:	0f b6       	in	r0, 0x3f	; 63
    760a:	f8 94       	cli
    760c:	fa 9a       	sbi	0x1f, 2	; 31
    760e:	f9 9a       	sbi	0x1f, 1	; 31
    7610:	0f be       	out	0x3f, r0	; 63
    7612:	01 96       	adiw	r24, 0x01	; 1
    7614:	08 95       	ret

00007616 <dtoa_prf>:
    7616:	a9 e0       	ldi	r26, 0x09	; 9
    7618:	b0 e0       	ldi	r27, 0x00	; 0
    761a:	e1 e1       	ldi	r30, 0x11	; 17
    761c:	fb e3       	ldi	r31, 0x3B	; 59
    761e:	0c 94 52 3d 	jmp	0x7aa4	; 0x7aa4 <__prologue_saves__+0x10>
    7622:	6a 01       	movw	r12, r20
    7624:	f2 2e       	mov	r15, r18
    7626:	10 2f       	mov	r17, r16
    7628:	0c 33       	cpi	r16, 0x3C	; 60
    762a:	18 f4       	brcc	.+6      	; 0x7632 <dtoa_prf+0x1c>
    762c:	b0 2e       	mov	r11, r16
    762e:	b3 94       	inc	r11
    7630:	02 c0       	rjmp	.+4      	; 0x7636 <dtoa_prf+0x20>
    7632:	ec e3       	ldi	r30, 0x3C	; 60
    7634:	be 2e       	mov	r11, r30
    7636:	ae 01       	movw	r20, r28
    7638:	4f 5f       	subi	r20, 0xFF	; 255
    763a:	5f 4f       	sbci	r21, 0xFF	; 255
    763c:	27 e0       	ldi	r18, 0x07	; 7
    763e:	0b 2d       	mov	r16, r11
    7640:	0e 94 62 3c 	call	0x78c4	; 0x78c4 <__ftoa_engine>
    7644:	29 81       	ldd	r18, Y+1	; 0x01
    7646:	30 e0       	ldi	r19, 0x00	; 0
    7648:	a9 01       	movw	r20, r18
    764a:	49 70       	andi	r20, 0x09	; 9
    764c:	50 70       	andi	r21, 0x00	; 0
    764e:	41 30       	cpi	r20, 0x01	; 1
    7650:	51 05       	cpc	r21, r1
    7652:	31 f0       	breq	.+12     	; 0x7660 <dtoa_prf+0x4a>
    7654:	e1 fc       	sbrc	r14, 1
    7656:	06 c0       	rjmp	.+12     	; 0x7664 <dtoa_prf+0x4e>
    7658:	e0 fe       	sbrs	r14, 0
    765a:	06 c0       	rjmp	.+12     	; 0x7668 <dtoa_prf+0x52>
    765c:	e0 e2       	ldi	r30, 0x20	; 32
    765e:	05 c0       	rjmp	.+10     	; 0x766a <dtoa_prf+0x54>
    7660:	ed e2       	ldi	r30, 0x2D	; 45
    7662:	03 c0       	rjmp	.+6      	; 0x766a <dtoa_prf+0x54>
    7664:	eb e2       	ldi	r30, 0x2B	; 43
    7666:	01 c0       	rjmp	.+2      	; 0x766a <dtoa_prf+0x54>
    7668:	e0 e0       	ldi	r30, 0x00	; 0
    766a:	23 ff       	sbrs	r18, 3
    766c:	37 c0       	rjmp	.+110    	; 0x76dc <dtoa_prf+0xc6>
    766e:	ee 23       	and	r30, r30
    7670:	11 f0       	breq	.+4      	; 0x7676 <dtoa_prf+0x60>
    7672:	84 e0       	ldi	r24, 0x04	; 4
    7674:	01 c0       	rjmp	.+2      	; 0x7678 <dtoa_prf+0x62>
    7676:	83 e0       	ldi	r24, 0x03	; 3
    7678:	8f 15       	cp	r24, r15
    767a:	18 f4       	brcc	.+6      	; 0x7682 <dtoa_prf+0x6c>
    767c:	f8 1a       	sub	r15, r24
    767e:	8f 2d       	mov	r24, r15
    7680:	01 c0       	rjmp	.+2      	; 0x7684 <dtoa_prf+0x6e>
    7682:	80 e0       	ldi	r24, 0x00	; 0
    7684:	e4 fc       	sbrc	r14, 4
    7686:	0b c0       	rjmp	.+22     	; 0x769e <dtoa_prf+0x88>
    7688:	98 2f       	mov	r25, r24
    768a:	d6 01       	movw	r26, r12
    768c:	20 e2       	ldi	r18, 0x20	; 32
    768e:	02 c0       	rjmp	.+4      	; 0x7694 <dtoa_prf+0x7e>
    7690:	2d 93       	st	X+, r18
    7692:	91 50       	subi	r25, 0x01	; 1
    7694:	99 23       	and	r25, r25
    7696:	e1 f7       	brne	.-8      	; 0x7690 <dtoa_prf+0x7a>
    7698:	c8 0e       	add	r12, r24
    769a:	d1 1c       	adc	r13, r1
    769c:	80 e0       	ldi	r24, 0x00	; 0
    769e:	ee 23       	and	r30, r30
    76a0:	19 f0       	breq	.+6      	; 0x76a8 <dtoa_prf+0x92>
    76a2:	d6 01       	movw	r26, r12
    76a4:	ed 93       	st	X+, r30
    76a6:	6d 01       	movw	r12, r26
    76a8:	f6 01       	movw	r30, r12
    76aa:	31 96       	adiw	r30, 0x01	; 1
    76ac:	e2 fe       	sbrs	r14, 2
    76ae:	05 c0       	rjmp	.+10     	; 0x76ba <dtoa_prf+0xa4>
    76b0:	9e e4       	ldi	r25, 0x4E	; 78
    76b2:	d6 01       	movw	r26, r12
    76b4:	9c 93       	st	X, r25
    76b6:	21 e4       	ldi	r18, 0x41	; 65
    76b8:	04 c0       	rjmp	.+8      	; 0x76c2 <dtoa_prf+0xac>
    76ba:	9e e6       	ldi	r25, 0x6E	; 110
    76bc:	d6 01       	movw	r26, r12
    76be:	9c 93       	st	X, r25
    76c0:	21 e6       	ldi	r18, 0x61	; 97
    76c2:	11 96       	adiw	r26, 0x01	; 1
    76c4:	2c 93       	st	X, r18
    76c6:	91 83       	std	Z+1, r25	; 0x01
    76c8:	32 96       	adiw	r30, 0x02	; 2
    76ca:	98 2f       	mov	r25, r24
    76cc:	df 01       	movw	r26, r30
    76ce:	20 e2       	ldi	r18, 0x20	; 32
    76d0:	02 c0       	rjmp	.+4      	; 0x76d6 <dtoa_prf+0xc0>
    76d2:	2d 93       	st	X+, r18
    76d4:	91 50       	subi	r25, 0x01	; 1
    76d6:	99 23       	and	r25, r25
    76d8:	e1 f7       	brne	.-8      	; 0x76d2 <dtoa_prf+0xbc>
    76da:	3d c0       	rjmp	.+122    	; 0x7756 <dtoa_prf+0x140>
    76dc:	22 ff       	sbrs	r18, 2
    76de:	41 c0       	rjmp	.+130    	; 0x7762 <dtoa_prf+0x14c>
    76e0:	ee 23       	and	r30, r30
    76e2:	11 f0       	breq	.+4      	; 0x76e8 <dtoa_prf+0xd2>
    76e4:	84 e0       	ldi	r24, 0x04	; 4
    76e6:	01 c0       	rjmp	.+2      	; 0x76ea <dtoa_prf+0xd4>
    76e8:	83 e0       	ldi	r24, 0x03	; 3
    76ea:	8f 15       	cp	r24, r15
    76ec:	18 f4       	brcc	.+6      	; 0x76f4 <dtoa_prf+0xde>
    76ee:	f8 1a       	sub	r15, r24
    76f0:	8f 2d       	mov	r24, r15
    76f2:	01 c0       	rjmp	.+2      	; 0x76f6 <dtoa_prf+0xe0>
    76f4:	80 e0       	ldi	r24, 0x00	; 0
    76f6:	e4 fc       	sbrc	r14, 4
    76f8:	0b c0       	rjmp	.+22     	; 0x7710 <dtoa_prf+0xfa>
    76fa:	98 2f       	mov	r25, r24
    76fc:	d6 01       	movw	r26, r12
    76fe:	20 e2       	ldi	r18, 0x20	; 32
    7700:	02 c0       	rjmp	.+4      	; 0x7706 <dtoa_prf+0xf0>
    7702:	2d 93       	st	X+, r18
    7704:	91 50       	subi	r25, 0x01	; 1
    7706:	99 23       	and	r25, r25
    7708:	e1 f7       	brne	.-8      	; 0x7702 <dtoa_prf+0xec>
    770a:	c8 0e       	add	r12, r24
    770c:	d1 1c       	adc	r13, r1
    770e:	80 e0       	ldi	r24, 0x00	; 0
    7710:	ee 23       	and	r30, r30
    7712:	19 f0       	breq	.+6      	; 0x771a <dtoa_prf+0x104>
    7714:	d6 01       	movw	r26, r12
    7716:	ed 93       	st	X+, r30
    7718:	6d 01       	movw	r12, r26
    771a:	f6 01       	movw	r30, r12
    771c:	31 96       	adiw	r30, 0x01	; 1
    771e:	e2 fe       	sbrs	r14, 2
    7720:	09 c0       	rjmp	.+18     	; 0x7734 <dtoa_prf+0x11e>
    7722:	99 e4       	ldi	r25, 0x49	; 73
    7724:	d6 01       	movw	r26, r12
    7726:	9c 93       	st	X, r25
    7728:	9e e4       	ldi	r25, 0x4E	; 78
    772a:	11 96       	adiw	r26, 0x01	; 1
    772c:	9c 93       	st	X, r25
    772e:	11 97       	sbiw	r26, 0x01	; 1
    7730:	96 e4       	ldi	r25, 0x46	; 70
    7732:	07 c0       	rjmp	.+14     	; 0x7742 <dtoa_prf+0x12c>
    7734:	99 e6       	ldi	r25, 0x69	; 105
    7736:	d6 01       	movw	r26, r12
    7738:	9c 93       	st	X, r25
    773a:	9e e6       	ldi	r25, 0x6E	; 110
    773c:	11 96       	adiw	r26, 0x01	; 1
    773e:	9c 93       	st	X, r25
    7740:	96 e6       	ldi	r25, 0x66	; 102
    7742:	91 83       	std	Z+1, r25	; 0x01
    7744:	32 96       	adiw	r30, 0x02	; 2
    7746:	98 2f       	mov	r25, r24
    7748:	df 01       	movw	r26, r30
    774a:	20 e2       	ldi	r18, 0x20	; 32
    774c:	02 c0       	rjmp	.+4      	; 0x7752 <dtoa_prf+0x13c>
    774e:	2d 93       	st	X+, r18
    7750:	91 50       	subi	r25, 0x01	; 1
    7752:	99 23       	and	r25, r25
    7754:	e1 f7       	brne	.-8      	; 0x774e <dtoa_prf+0x138>
    7756:	e8 0f       	add	r30, r24
    7758:	f1 1d       	adc	r31, r1
    775a:	10 82       	st	Z, r1
    775c:	2e ef       	ldi	r18, 0xFE	; 254
    775e:	3f ef       	ldi	r19, 0xFF	; 255
    7760:	ac c0       	rjmp	.+344    	; 0x78ba <dtoa_prf+0x2a4>
    7762:	41 e0       	ldi	r20, 0x01	; 1
    7764:	50 e0       	ldi	r21, 0x00	; 0
    7766:	ee 23       	and	r30, r30
    7768:	11 f4       	brne	.+4      	; 0x776e <dtoa_prf+0x158>
    776a:	40 e0       	ldi	r20, 0x00	; 0
    776c:	50 e0       	ldi	r21, 0x00	; 0
    776e:	18 16       	cp	r1, r24
    7770:	19 06       	cpc	r1, r25
    7772:	24 f4       	brge	.+8      	; 0x777c <dtoa_prf+0x166>
    7774:	bc 01       	movw	r22, r24
    7776:	6f 5f       	subi	r22, 0xFF	; 255
    7778:	7f 4f       	sbci	r23, 0xFF	; 255
    777a:	02 c0       	rjmp	.+4      	; 0x7780 <dtoa_prf+0x16a>
    777c:	61 e0       	ldi	r22, 0x01	; 1
    777e:	70 e0       	ldi	r23, 0x00	; 0
    7780:	64 0f       	add	r22, r20
    7782:	75 1f       	adc	r23, r21
    7784:	11 23       	and	r17, r17
    7786:	29 f0       	breq	.+10     	; 0x7792 <dtoa_prf+0x17c>
    7788:	41 2f       	mov	r20, r17
    778a:	50 e0       	ldi	r21, 0x00	; 0
    778c:	4f 5f       	subi	r20, 0xFF	; 255
    778e:	5f 4f       	sbci	r21, 0xFF	; 255
    7790:	02 c0       	rjmp	.+4      	; 0x7796 <dtoa_prf+0x180>
    7792:	40 e0       	ldi	r20, 0x00	; 0
    7794:	50 e0       	ldi	r21, 0x00	; 0
    7796:	46 0f       	add	r20, r22
    7798:	57 1f       	adc	r21, r23
    779a:	6f 2d       	mov	r22, r15
    779c:	70 e0       	ldi	r23, 0x00	; 0
    779e:	46 17       	cp	r20, r22
    77a0:	57 07       	cpc	r21, r23
    77a2:	1c f4       	brge	.+6      	; 0x77aa <dtoa_prf+0x194>
    77a4:	0f 2d       	mov	r16, r15
    77a6:	04 1b       	sub	r16, r20
    77a8:	01 c0       	rjmp	.+2      	; 0x77ac <dtoa_prf+0x196>
    77aa:	00 e0       	ldi	r16, 0x00	; 0
    77ac:	ff 24       	eor	r15, r15
    77ae:	a7 01       	movw	r20, r14
    77b0:	40 71       	andi	r20, 0x10	; 16
    77b2:	50 70       	andi	r21, 0x00	; 0
    77b4:	e4 fc       	sbrc	r14, 4
    77b6:	0d c0       	rjmp	.+26     	; 0x77d2 <dtoa_prf+0x1bc>
    77b8:	e3 fc       	sbrc	r14, 3
    77ba:	0b c0       	rjmp	.+22     	; 0x77d2 <dtoa_prf+0x1bc>
    77bc:	60 2f       	mov	r22, r16
    77be:	d6 01       	movw	r26, r12
    77c0:	70 e2       	ldi	r23, 0x20	; 32
    77c2:	02 c0       	rjmp	.+4      	; 0x77c8 <dtoa_prf+0x1b2>
    77c4:	7d 93       	st	X+, r23
    77c6:	61 50       	subi	r22, 0x01	; 1
    77c8:	66 23       	and	r22, r22
    77ca:	e1 f7       	brne	.-8      	; 0x77c4 <dtoa_prf+0x1ae>
    77cc:	c0 0e       	add	r12, r16
    77ce:	d1 1c       	adc	r13, r1
    77d0:	00 e0       	ldi	r16, 0x00	; 0
    77d2:	ee 23       	and	r30, r30
    77d4:	19 f0       	breq	.+6      	; 0x77dc <dtoa_prf+0x1c6>
    77d6:	d6 01       	movw	r26, r12
    77d8:	ed 93       	st	X+, r30
    77da:	6d 01       	movw	r12, r26
    77dc:	41 15       	cp	r20, r1
    77de:	51 05       	cpc	r21, r1
    77e0:	59 f4       	brne	.+22     	; 0x77f8 <dtoa_prf+0x1e2>
    77e2:	40 2f       	mov	r20, r16
    77e4:	f6 01       	movw	r30, r12
    77e6:	50 e3       	ldi	r21, 0x30	; 48
    77e8:	02 c0       	rjmp	.+4      	; 0x77ee <dtoa_prf+0x1d8>
    77ea:	51 93       	st	Z+, r21
    77ec:	41 50       	subi	r20, 0x01	; 1
    77ee:	44 23       	and	r20, r20
    77f0:	e1 f7       	brne	.-8      	; 0x77ea <dtoa_prf+0x1d4>
    77f2:	c0 0e       	add	r12, r16
    77f4:	d1 1c       	adc	r13, r1
    77f6:	00 e0       	ldi	r16, 0x00	; 0
    77f8:	b8 0e       	add	r11, r24
    77fa:	fa 80       	ldd	r15, Y+2	; 0x02
    77fc:	a9 01       	movw	r20, r18
    77fe:	40 71       	andi	r20, 0x10	; 16
    7800:	50 70       	andi	r21, 0x00	; 0
    7802:	24 ff       	sbrs	r18, 4
    7804:	04 c0       	rjmp	.+8      	; 0x780e <dtoa_prf+0x1f8>
    7806:	bf 2d       	mov	r27, r15
    7808:	b1 33       	cpi	r27, 0x31	; 49
    780a:	09 f4       	brne	.+2      	; 0x780e <dtoa_prf+0x1f8>
    780c:	ba 94       	dec	r11
    780e:	1b 14       	cp	r1, r11
    7810:	2c f4       	brge	.+10     	; 0x781c <dtoa_prf+0x206>
    7812:	ab 2d       	mov	r26, r11
    7814:	a9 30       	cpi	r26, 0x09	; 9
    7816:	18 f0       	brcs	.+6      	; 0x781e <dtoa_prf+0x208>
    7818:	a8 e0       	ldi	r26, 0x08	; 8
    781a:	01 c0       	rjmp	.+2      	; 0x781e <dtoa_prf+0x208>
    781c:	a1 e0       	ldi	r26, 0x01	; 1
    781e:	9c 01       	movw	r18, r24
    7820:	97 ff       	sbrs	r25, 7
    7822:	02 c0       	rjmp	.+4      	; 0x7828 <dtoa_prf+0x212>
    7824:	20 e0       	ldi	r18, 0x00	; 0
    7826:	30 e0       	ldi	r19, 0x00	; 0
    7828:	bc 01       	movw	r22, r24
    782a:	6f 5f       	subi	r22, 0xFF	; 255
    782c:	7f 4f       	sbci	r23, 0xFF	; 255
    782e:	62 1b       	sub	r22, r18
    7830:	73 0b       	sbc	r23, r19
    7832:	fe 01       	movw	r30, r28
    7834:	31 96       	adiw	r30, 0x01	; 1
    7836:	e6 0f       	add	r30, r22
    7838:	f7 1f       	adc	r31, r23
    783a:	6e e2       	ldi	r22, 0x2E	; 46
    783c:	e6 2e       	mov	r14, r22
    783e:	bc 01       	movw	r22, r24
    7840:	6a 1b       	sub	r22, r26
    7842:	71 09       	sbc	r23, r1
    7844:	a1 2f       	mov	r26, r17
    7846:	b0 e0       	ldi	r27, 0x00	; 0
    7848:	aa 24       	eor	r10, r10
    784a:	bb 24       	eor	r11, r11
    784c:	aa 1a       	sub	r10, r26
    784e:	bb 0a       	sbc	r11, r27
    7850:	1f ef       	ldi	r17, 0xFF	; 255
    7852:	2f 3f       	cpi	r18, 0xFF	; 255
    7854:	31 07       	cpc	r19, r17
    7856:	19 f4       	brne	.+6      	; 0x785e <dtoa_prf+0x248>
    7858:	d6 01       	movw	r26, r12
    785a:	ed 92       	st	X+, r14
    785c:	6d 01       	movw	r12, r26
    785e:	82 17       	cp	r24, r18
    7860:	93 07       	cpc	r25, r19
    7862:	2c f0       	brlt	.+10     	; 0x786e <dtoa_prf+0x258>
    7864:	62 17       	cp	r22, r18
    7866:	73 07       	cpc	r23, r19
    7868:	14 f4       	brge	.+4      	; 0x786e <dtoa_prf+0x258>
    786a:	10 81       	ld	r17, Z
    786c:	01 c0       	rjmp	.+2      	; 0x7870 <dtoa_prf+0x25a>
    786e:	10 e3       	ldi	r17, 0x30	; 48
    7870:	21 50       	subi	r18, 0x01	; 1
    7872:	30 40       	sbci	r19, 0x00	; 0
    7874:	31 96       	adiw	r30, 0x01	; 1
    7876:	2a 15       	cp	r18, r10
    7878:	3b 05       	cpc	r19, r11
    787a:	24 f0       	brlt	.+8      	; 0x7884 <dtoa_prf+0x26e>
    787c:	d6 01       	movw	r26, r12
    787e:	1d 93       	st	X+, r17
    7880:	6d 01       	movw	r12, r26
    7882:	e6 cf       	rjmp	.-52     	; 0x7850 <dtoa_prf+0x23a>
    7884:	28 17       	cp	r18, r24
    7886:	39 07       	cpc	r19, r25
    7888:	49 f4       	brne	.+18     	; 0x789c <dtoa_prf+0x286>
    788a:	bf 2d       	mov	r27, r15
    788c:	b6 33       	cpi	r27, 0x36	; 54
    788e:	28 f4       	brcc	.+10     	; 0x789a <dtoa_prf+0x284>
    7890:	b5 33       	cpi	r27, 0x35	; 53
    7892:	21 f4       	brne	.+8      	; 0x789c <dtoa_prf+0x286>
    7894:	41 15       	cp	r20, r1
    7896:	51 05       	cpc	r21, r1
    7898:	09 f4       	brne	.+2      	; 0x789c <dtoa_prf+0x286>
    789a:	11 e3       	ldi	r17, 0x31	; 49
    789c:	f6 01       	movw	r30, r12
    789e:	11 93       	st	Z+, r17
    78a0:	80 2f       	mov	r24, r16
    78a2:	df 01       	movw	r26, r30
    78a4:	90 e2       	ldi	r25, 0x20	; 32
    78a6:	02 c0       	rjmp	.+4      	; 0x78ac <dtoa_prf+0x296>
    78a8:	9d 93       	st	X+, r25
    78aa:	81 50       	subi	r24, 0x01	; 1
    78ac:	88 23       	and	r24, r24
    78ae:	e1 f7       	brne	.-8      	; 0x78a8 <dtoa_prf+0x292>
    78b0:	e0 0f       	add	r30, r16
    78b2:	f1 1d       	adc	r31, r1
    78b4:	10 82       	st	Z, r1
    78b6:	20 e0       	ldi	r18, 0x00	; 0
    78b8:	30 e0       	ldi	r19, 0x00	; 0
    78ba:	c9 01       	movw	r24, r18
    78bc:	29 96       	adiw	r28, 0x09	; 9
    78be:	ea e0       	ldi	r30, 0x0A	; 10
    78c0:	0c 94 6e 3d 	jmp	0x7adc	; 0x7adc <__epilogue_restores__+0x10>

000078c4 <__ftoa_engine>:
    78c4:	28 30       	cpi	r18, 0x08	; 8
    78c6:	08 f0       	brcs	.+2      	; 0x78ca <__ftoa_engine+0x6>
    78c8:	27 e0       	ldi	r18, 0x07	; 7
    78ca:	33 27       	eor	r19, r19
    78cc:	da 01       	movw	r26, r20
    78ce:	99 0f       	add	r25, r25
    78d0:	31 1d       	adc	r19, r1
    78d2:	87 fd       	sbrc	r24, 7
    78d4:	91 60       	ori	r25, 0x01	; 1
    78d6:	00 96       	adiw	r24, 0x00	; 0
    78d8:	61 05       	cpc	r22, r1
    78da:	71 05       	cpc	r23, r1
    78dc:	39 f4       	brne	.+14     	; 0x78ec <__ftoa_engine+0x28>
    78de:	32 60       	ori	r19, 0x02	; 2
    78e0:	2e 5f       	subi	r18, 0xFE	; 254
    78e2:	3d 93       	st	X+, r19
    78e4:	30 e3       	ldi	r19, 0x30	; 48
    78e6:	2a 95       	dec	r18
    78e8:	e1 f7       	brne	.-8      	; 0x78e2 <__ftoa_engine+0x1e>
    78ea:	08 95       	ret
    78ec:	9f 3f       	cpi	r25, 0xFF	; 255
    78ee:	30 f0       	brcs	.+12     	; 0x78fc <__ftoa_engine+0x38>
    78f0:	80 38       	cpi	r24, 0x80	; 128
    78f2:	71 05       	cpc	r23, r1
    78f4:	61 05       	cpc	r22, r1
    78f6:	09 f0       	breq	.+2      	; 0x78fa <__ftoa_engine+0x36>
    78f8:	3c 5f       	subi	r19, 0xFC	; 252
    78fa:	3c 5f       	subi	r19, 0xFC	; 252
    78fc:	3d 93       	st	X+, r19
    78fe:	91 30       	cpi	r25, 0x01	; 1
    7900:	08 f0       	brcs	.+2      	; 0x7904 <__ftoa_engine+0x40>
    7902:	80 68       	ori	r24, 0x80	; 128
    7904:	91 1d       	adc	r25, r1
    7906:	df 93       	push	r29
    7908:	cf 93       	push	r28
    790a:	1f 93       	push	r17
    790c:	0f 93       	push	r16
    790e:	ff 92       	push	r15
    7910:	ef 92       	push	r14
    7912:	19 2f       	mov	r17, r25
    7914:	98 7f       	andi	r25, 0xF8	; 248
    7916:	96 95       	lsr	r25
    7918:	e9 2f       	mov	r30, r25
    791a:	96 95       	lsr	r25
    791c:	96 95       	lsr	r25
    791e:	e9 0f       	add	r30, r25
    7920:	ff 27       	eor	r31, r31
    7922:	ed 5e       	subi	r30, 0xED	; 237
    7924:	fd 4e       	sbci	r31, 0xED	; 237
    7926:	99 27       	eor	r25, r25
    7928:	33 27       	eor	r19, r19
    792a:	ee 24       	eor	r14, r14
    792c:	ff 24       	eor	r15, r15
    792e:	a7 01       	movw	r20, r14
    7930:	e7 01       	movw	r28, r14
    7932:	05 90       	lpm	r0, Z+
    7934:	08 94       	sec
    7936:	07 94       	ror	r0
    7938:	28 f4       	brcc	.+10     	; 0x7944 <__ftoa_engine+0x80>
    793a:	36 0f       	add	r19, r22
    793c:	e7 1e       	adc	r14, r23
    793e:	f8 1e       	adc	r15, r24
    7940:	49 1f       	adc	r20, r25
    7942:	51 1d       	adc	r21, r1
    7944:	66 0f       	add	r22, r22
    7946:	77 1f       	adc	r23, r23
    7948:	88 1f       	adc	r24, r24
    794a:	99 1f       	adc	r25, r25
    794c:	06 94       	lsr	r0
    794e:	a1 f7       	brne	.-24     	; 0x7938 <__ftoa_engine+0x74>
    7950:	05 90       	lpm	r0, Z+
    7952:	07 94       	ror	r0
    7954:	28 f4       	brcc	.+10     	; 0x7960 <__ftoa_engine+0x9c>
    7956:	e7 0e       	add	r14, r23
    7958:	f8 1e       	adc	r15, r24
    795a:	49 1f       	adc	r20, r25
    795c:	56 1f       	adc	r21, r22
    795e:	c1 1d       	adc	r28, r1
    7960:	77 0f       	add	r23, r23
    7962:	88 1f       	adc	r24, r24
    7964:	99 1f       	adc	r25, r25
    7966:	66 1f       	adc	r22, r22
    7968:	06 94       	lsr	r0
    796a:	a1 f7       	brne	.-24     	; 0x7954 <__ftoa_engine+0x90>
    796c:	05 90       	lpm	r0, Z+
    796e:	07 94       	ror	r0
    7970:	28 f4       	brcc	.+10     	; 0x797c <__ftoa_engine+0xb8>
    7972:	f8 0e       	add	r15, r24
    7974:	49 1f       	adc	r20, r25
    7976:	56 1f       	adc	r21, r22
    7978:	c7 1f       	adc	r28, r23
    797a:	d1 1d       	adc	r29, r1
    797c:	88 0f       	add	r24, r24
    797e:	99 1f       	adc	r25, r25
    7980:	66 1f       	adc	r22, r22
    7982:	77 1f       	adc	r23, r23
    7984:	06 94       	lsr	r0
    7986:	a1 f7       	brne	.-24     	; 0x7970 <__ftoa_engine+0xac>
    7988:	05 90       	lpm	r0, Z+
    798a:	07 94       	ror	r0
    798c:	20 f4       	brcc	.+8      	; 0x7996 <__ftoa_engine+0xd2>
    798e:	49 0f       	add	r20, r25
    7990:	56 1f       	adc	r21, r22
    7992:	c7 1f       	adc	r28, r23
    7994:	d8 1f       	adc	r29, r24
    7996:	99 0f       	add	r25, r25
    7998:	66 1f       	adc	r22, r22
    799a:	77 1f       	adc	r23, r23
    799c:	88 1f       	adc	r24, r24
    799e:	06 94       	lsr	r0
    79a0:	a9 f7       	brne	.-22     	; 0x798c <__ftoa_engine+0xc8>
    79a2:	84 91       	lpm	r24, Z+
    79a4:	10 95       	com	r17
    79a6:	17 70       	andi	r17, 0x07	; 7
    79a8:	41 f0       	breq	.+16     	; 0x79ba <__ftoa_engine+0xf6>
    79aa:	d6 95       	lsr	r29
    79ac:	c7 95       	ror	r28
    79ae:	57 95       	ror	r21
    79b0:	47 95       	ror	r20
    79b2:	f7 94       	ror	r15
    79b4:	e7 94       	ror	r14
    79b6:	1a 95       	dec	r17
    79b8:	c1 f7       	brne	.-16     	; 0x79aa <__ftoa_engine+0xe6>
    79ba:	e9 eb       	ldi	r30, 0xB9	; 185
    79bc:	f1 e1       	ldi	r31, 0x11	; 17
    79be:	68 94       	set
    79c0:	15 90       	lpm	r1, Z+
    79c2:	15 91       	lpm	r17, Z+
    79c4:	35 91       	lpm	r19, Z+
    79c6:	65 91       	lpm	r22, Z+
    79c8:	95 91       	lpm	r25, Z+
    79ca:	05 90       	lpm	r0, Z+
    79cc:	7f e2       	ldi	r23, 0x2F	; 47
    79ce:	73 95       	inc	r23
    79d0:	e1 18       	sub	r14, r1
    79d2:	f1 0a       	sbc	r15, r17
    79d4:	43 0b       	sbc	r20, r19
    79d6:	56 0b       	sbc	r21, r22
    79d8:	c9 0b       	sbc	r28, r25
    79da:	d0 09       	sbc	r29, r0
    79dc:	c0 f7       	brcc	.-16     	; 0x79ce <__ftoa_engine+0x10a>
    79de:	e1 0c       	add	r14, r1
    79e0:	f1 1e       	adc	r15, r17
    79e2:	43 1f       	adc	r20, r19
    79e4:	56 1f       	adc	r21, r22
    79e6:	c9 1f       	adc	r28, r25
    79e8:	d0 1d       	adc	r29, r0
    79ea:	7e f4       	brtc	.+30     	; 0x7a0a <__ftoa_engine+0x146>
    79ec:	70 33       	cpi	r23, 0x30	; 48
    79ee:	11 f4       	brne	.+4      	; 0x79f4 <__ftoa_engine+0x130>
    79f0:	8a 95       	dec	r24
    79f2:	e6 cf       	rjmp	.-52     	; 0x79c0 <__ftoa_engine+0xfc>
    79f4:	e8 94       	clt
    79f6:	01 50       	subi	r16, 0x01	; 1
    79f8:	30 f0       	brcs	.+12     	; 0x7a06 <__ftoa_engine+0x142>
    79fa:	08 0f       	add	r16, r24
    79fc:	0a f4       	brpl	.+2      	; 0x7a00 <__ftoa_engine+0x13c>
    79fe:	00 27       	eor	r16, r16
    7a00:	02 17       	cp	r16, r18
    7a02:	08 f4       	brcc	.+2      	; 0x7a06 <__ftoa_engine+0x142>
    7a04:	20 2f       	mov	r18, r16
    7a06:	23 95       	inc	r18
    7a08:	02 2f       	mov	r16, r18
    7a0a:	7a 33       	cpi	r23, 0x3A	; 58
    7a0c:	28 f0       	brcs	.+10     	; 0x7a18 <__ftoa_engine+0x154>
    7a0e:	79 e3       	ldi	r23, 0x39	; 57
    7a10:	7d 93       	st	X+, r23
    7a12:	2a 95       	dec	r18
    7a14:	e9 f7       	brne	.-6      	; 0x7a10 <__ftoa_engine+0x14c>
    7a16:	10 c0       	rjmp	.+32     	; 0x7a38 <__ftoa_engine+0x174>
    7a18:	7d 93       	st	X+, r23
    7a1a:	2a 95       	dec	r18
    7a1c:	89 f6       	brne	.-94     	; 0x79c0 <__ftoa_engine+0xfc>
    7a1e:	06 94       	lsr	r0
    7a20:	97 95       	ror	r25
    7a22:	67 95       	ror	r22
    7a24:	37 95       	ror	r19
    7a26:	17 95       	ror	r17
    7a28:	17 94       	ror	r1
    7a2a:	e1 18       	sub	r14, r1
    7a2c:	f1 0a       	sbc	r15, r17
    7a2e:	43 0b       	sbc	r20, r19
    7a30:	56 0b       	sbc	r21, r22
    7a32:	c9 0b       	sbc	r28, r25
    7a34:	d0 09       	sbc	r29, r0
    7a36:	98 f0       	brcs	.+38     	; 0x7a5e <__ftoa_engine+0x19a>
    7a38:	23 95       	inc	r18
    7a3a:	7e 91       	ld	r23, -X
    7a3c:	73 95       	inc	r23
    7a3e:	7a 33       	cpi	r23, 0x3A	; 58
    7a40:	08 f0       	brcs	.+2      	; 0x7a44 <__ftoa_engine+0x180>
    7a42:	70 e3       	ldi	r23, 0x30	; 48
    7a44:	7c 93       	st	X, r23
    7a46:	20 13       	cpse	r18, r16
    7a48:	b8 f7       	brcc	.-18     	; 0x7a38 <__ftoa_engine+0x174>
    7a4a:	7e 91       	ld	r23, -X
    7a4c:	70 61       	ori	r23, 0x10	; 16
    7a4e:	7d 93       	st	X+, r23
    7a50:	30 f0       	brcs	.+12     	; 0x7a5e <__ftoa_engine+0x19a>
    7a52:	83 95       	inc	r24
    7a54:	71 e3       	ldi	r23, 0x31	; 49
    7a56:	7d 93       	st	X+, r23
    7a58:	70 e3       	ldi	r23, 0x30	; 48
    7a5a:	2a 95       	dec	r18
    7a5c:	e1 f7       	brne	.-8      	; 0x7a56 <__ftoa_engine+0x192>
    7a5e:	11 24       	eor	r1, r1
    7a60:	ef 90       	pop	r14
    7a62:	ff 90       	pop	r15
    7a64:	0f 91       	pop	r16
    7a66:	1f 91       	pop	r17
    7a68:	cf 91       	pop	r28
    7a6a:	df 91       	pop	r29
    7a6c:	99 27       	eor	r25, r25
    7a6e:	87 fd       	sbrc	r24, 7
    7a70:	90 95       	com	r25
    7a72:	08 95       	ret

00007a74 <strrev>:
    7a74:	dc 01       	movw	r26, r24
    7a76:	fc 01       	movw	r30, r24
    7a78:	67 2f       	mov	r22, r23
    7a7a:	71 91       	ld	r23, Z+
    7a7c:	77 23       	and	r23, r23
    7a7e:	e1 f7       	brne	.-8      	; 0x7a78 <strrev+0x4>
    7a80:	32 97       	sbiw	r30, 0x02	; 2
    7a82:	04 c0       	rjmp	.+8      	; 0x7a8c <strrev+0x18>
    7a84:	7c 91       	ld	r23, X
    7a86:	6d 93       	st	X+, r22
    7a88:	70 83       	st	Z, r23
    7a8a:	62 91       	ld	r22, -Z
    7a8c:	ae 17       	cp	r26, r30
    7a8e:	bf 07       	cpc	r27, r31
    7a90:	c8 f3       	brcs	.-14     	; 0x7a84 <strrev+0x10>
    7a92:	08 95       	ret

00007a94 <__prologue_saves__>:
    7a94:	2f 92       	push	r2
    7a96:	3f 92       	push	r3
    7a98:	4f 92       	push	r4
    7a9a:	5f 92       	push	r5
    7a9c:	6f 92       	push	r6
    7a9e:	7f 92       	push	r7
    7aa0:	8f 92       	push	r8
    7aa2:	9f 92       	push	r9
    7aa4:	af 92       	push	r10
    7aa6:	bf 92       	push	r11
    7aa8:	cf 92       	push	r12
    7aaa:	df 92       	push	r13
    7aac:	ef 92       	push	r14
    7aae:	ff 92       	push	r15
    7ab0:	0f 93       	push	r16
    7ab2:	1f 93       	push	r17
    7ab4:	cf 93       	push	r28
    7ab6:	df 93       	push	r29
    7ab8:	cd b7       	in	r28, 0x3d	; 61
    7aba:	de b7       	in	r29, 0x3e	; 62
    7abc:	ca 1b       	sub	r28, r26
    7abe:	db 0b       	sbc	r29, r27
    7ac0:	0f b6       	in	r0, 0x3f	; 63
    7ac2:	f8 94       	cli
    7ac4:	de bf       	out	0x3e, r29	; 62
    7ac6:	0f be       	out	0x3f, r0	; 63
    7ac8:	cd bf       	out	0x3d, r28	; 61
    7aca:	09 94       	ijmp

00007acc <__epilogue_restores__>:
    7acc:	2a 88       	ldd	r2, Y+18	; 0x12
    7ace:	39 88       	ldd	r3, Y+17	; 0x11
    7ad0:	48 88       	ldd	r4, Y+16	; 0x10
    7ad2:	5f 84       	ldd	r5, Y+15	; 0x0f
    7ad4:	6e 84       	ldd	r6, Y+14	; 0x0e
    7ad6:	7d 84       	ldd	r7, Y+13	; 0x0d
    7ad8:	8c 84       	ldd	r8, Y+12	; 0x0c
    7ada:	9b 84       	ldd	r9, Y+11	; 0x0b
    7adc:	aa 84       	ldd	r10, Y+10	; 0x0a
    7ade:	b9 84       	ldd	r11, Y+9	; 0x09
    7ae0:	c8 84       	ldd	r12, Y+8	; 0x08
    7ae2:	df 80       	ldd	r13, Y+7	; 0x07
    7ae4:	ee 80       	ldd	r14, Y+6	; 0x06
    7ae6:	fd 80       	ldd	r15, Y+5	; 0x05
    7ae8:	0c 81       	ldd	r16, Y+4	; 0x04
    7aea:	1b 81       	ldd	r17, Y+3	; 0x03
    7aec:	aa 81       	ldd	r26, Y+2	; 0x02
    7aee:	b9 81       	ldd	r27, Y+1	; 0x01
    7af0:	ce 0f       	add	r28, r30
    7af2:	d1 1d       	adc	r29, r1
    7af4:	0f b6       	in	r0, 0x3f	; 63
    7af6:	f8 94       	cli
    7af8:	de bf       	out	0x3e, r29	; 62
    7afa:	0f be       	out	0x3f, r0	; 63
    7afc:	cd bf       	out	0x3d, r28	; 61
    7afe:	ed 01       	movw	r28, r26
    7b00:	08 95       	ret

00007b02 <_exit>:
    7b02:	f8 94       	cli

00007b04 <__stop_program>:
    7b04:	ff cf       	rjmp	.-2      	; 0x7b04 <__stop_program>
