
HefnyCopter 2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000014  00800100  00007900  00007994  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00007900  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000006fd  00800114  00800114  000079a8  2**0
                  ALLOC
  3 .stab         00003744  00000000  00000000  000079a8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000ddf  00000000  00000000  0000b0ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000338  00000000  00000000  0000becb  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000039c8  00000000  00000000  0000c203  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000d1be  00000000  00000000  0000fbcb  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000024e0  00000000  00000000  0001cd89  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00006447  00000000  00000000  0001f269  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000a74  00000000  00000000  000256b0  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000019ce  00000000  00000000  00026124  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000219b  00000000  00000000  00027af2  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubtypes 00000ab6  00000000  00000000  00029c8d  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000118  00000000  00000000  0002a743  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 6d 0b 	jmp	0x16da	; 0x16da <__ctors_end>
       4:	0c 94 6e 0a 	jmp	0x14dc	; 0x14dc <__vector_1>
       8:	0c 94 30 0a 	jmp	0x1460	; 0x1460 <__vector_2>
       c:	0c 94 dd 0a 	jmp	0x15ba	; 0x15ba <__vector_3>
      10:	0c 94 8a 0b 	jmp	0x1714	; 0x1714 <__bad_interrupt>
      14:	0c 94 31 0b 	jmp	0x1662	; 0x1662 <__vector_5>
      18:	0c 94 97 09 	jmp	0x132e	; 0x132e <__vector_6>
      1c:	0c 94 ac 0a 	jmp	0x1558	; 0x1558 <__vector_7>
      20:	0c 94 8a 0b 	jmp	0x1714	; 0x1714 <__bad_interrupt>
      24:	0c 94 8a 0b 	jmp	0x1714	; 0x1714 <__bad_interrupt>
      28:	0c 94 8a 0b 	jmp	0x1714	; 0x1714 <__bad_interrupt>
      2c:	0c 94 13 10 	jmp	0x2026	; 0x2026 <__vector_11>
      30:	0c 94 8a 0b 	jmp	0x1714	; 0x1714 <__bad_interrupt>
      34:	0c 94 8a 0b 	jmp	0x1714	; 0x1714 <__bad_interrupt>
      38:	0c 94 8a 0b 	jmp	0x1714	; 0x1714 <__bad_interrupt>
      3c:	0c 94 fc 0f 	jmp	0x1ff8	; 0x1ff8 <__vector_15>
      40:	0c 94 8a 0b 	jmp	0x1714	; 0x1714 <__bad_interrupt>
      44:	0c 94 8a 0b 	jmp	0x1714	; 0x1714 <__bad_interrupt>
      48:	0c 94 3e 09 	jmp	0x127c	; 0x127c <__vector_18>
      4c:	0c 94 8a 0b 	jmp	0x1714	; 0x1714 <__bad_interrupt>
      50:	0c 94 8a 0b 	jmp	0x1714	; 0x1714 <__bad_interrupt>
      54:	0c 94 8a 0b 	jmp	0x1714	; 0x1714 <__bad_interrupt>
      58:	0c 94 8a 0b 	jmp	0x1714	; 0x1714 <__bad_interrupt>
      5c:	0c 94 8a 0b 	jmp	0x1714	; 0x1714 <__bad_interrupt>
      60:	0c 94 50 29 	jmp	0x52a0	; 0x52a0 <__vector_24>
      64:	0c 94 8a 0b 	jmp	0x1714	; 0x1714 <__bad_interrupt>
      68:	0c 94 8a 0b 	jmp	0x1714	; 0x1714 <__bad_interrupt>
      6c:	0c 94 8a 0b 	jmp	0x1714	; 0x1714 <__bad_interrupt>
      70:	0c 94 e4 10 	jmp	0x21c8	; 0x21c8 <__vector_28>
      74:	0c 94 8a 0b 	jmp	0x1714	; 0x1714 <__bad_interrupt>
      78:	0c 94 8a 0b 	jmp	0x1714	; 0x1714 <__bad_interrupt>

0000007c <_initSeq>:
      7c:	a2 a0 c8 40 a6 a4 2f 24 81 20 af 00                 ...@../$. ..

00000088 <masks.1991>:
      88:	01 02 04 08 10 20 40 80                             ..... @.

00000090 <defaultConfig>:
      90:	fe 00 ff 00 00 03 00 01 00 00 00 96 04 00 19 00     ................
      a0:	64 00 00 00 00 00 fd ff 14 00 00 00 19 00 64 00     d.............d.
      b0:	00 00 00 00 fd ff 14 00 00 00 32 00 5a 00 32 00     ..........2.Z.2.
      c0:	5a 00 00 00 14 00 c8 00 0a 00 5a 00 14 00 0f 00     Z.........Z.....
      d0:	fe ff 32 00 de 03 0a 00 5a 00 14 00 0f 00 fe ff     ..2.....Z.......
      e0:	32 00 de 03 0f 00 1e 00 00 00 00 00 00 00 00 00     2...............
      f0:	58 02 0f 00 19 00 00 00 00 00 00 00 00 00 00 00     X...............
	...
     144:	00 00 00 01 00                                      .....

00000149 <font12x16>:
     149:	0c 10 75 11                                         ..u.

0000014d <_font12x16map>:
	...
     16d:	7c 00 ff 33 ff 33 7c 00 00 00 00 00 00 00 00 00     |..3.3|.........
     17d:	00 00 00 00 00 00 3c 00 3c 00 00 00 00 00 3c 00     ......<.<.....<.
     18d:	3c 00 00 00 00 00 00 00 00 00 00 02 10 1e 90 1f     <...............
     19d:	f0 03 7e 02 1e 1e 90 1f f0 03 7e 02 1e 00 10 00     ..~.......~.....
     1ad:	00 00 00 00 78 04 fc 0c cc 0c ff 3f ff 3f cc 0c     ....x......?.?..
     1bd:	cc 0f 88 07 00 00 00 00 00 00 00 30 38 38 38 1c     ...........0888.
     1cd:	38 0e 00 07 80 03 c0 01 e0 38 70 38 38 38 1c 00     8........8p888..
     1dd:	00 00 00 00 00 1f b8 3f fc 31 c6 21 e2 37 3e 1e     .......?.1.!.7>.
     1ed:	1c 1c 00 36 00 22 00 00 00 00 00 00 00 00 00 00     ...6."..........
     1fd:	27 00 3f 00 1f 00 00 00 00 00 00 00 00 00 00 00     '.?.............
     20d:	00 00 00 00 00 00 f0 03 fc 0f fe 1f 07 38 01 20     .............8. 
     21d:	01 20 00 00 00 00 00 00 00 00 00 00 00 00 01 20     . ............. 
     22d:	01 20 07 38 fe 1f fc 0f f0 03 00 00 00 00 00 00     . .8............
     23d:	00 00 00 00 98 0c b8 0e e0 03 f8 0f f8 0f e0 03     ................
     24d:	b8 0e 98 0c 00 00 00 00 00 00 00 00 80 01 80 01     ................
     25d:	80 01 f0 0f f0 0f 80 01 80 01 80 01 00 00 00 00     ................
	...
     275:	00 b8 00 f8 00 78 00 00 00 00 00 00 00 00 00 00     .....x..........
     285:	00 00 00 00 80 01 80 01 80 01 80 01 80 01 80 01     ................
     295:	80 01 80 01 00 00 00 00 00 00 00 00 00 00 00 00     ................
     2a5:	00 38 00 38 00 38 00 00 00 00 00 00 00 00 00 00     .8.8.8..........
     2b5:	00 00 00 18 00 1c 00 0e 00 07 80 03 c0 01 e0 00     ................
     2c5:	70 00 38 00 1c 00 0e 00 00 00 f8 07 fe 1f 06 1e     p.8.............
     2d5:	03 33 83 31 c3 30 63 30 33 30 1e 18 fe 1f f8 07     .3.1.0c030......
     2e5:	00 00 00 00 00 00 0c 30 0c 30 0e 30 ff 3f ff 3f     .......0.0.0.?.?
     2f5:	00 30 00 30 00 30 00 00 00 00 1c 30 1e 38 07 3c     .0.0.0.....0.8.<
     305:	03 3e 03 37 83 33 c3 31 e3 30 77 30 3e 30 1c 30     .>.7.3.1.0w0>0.0
     315:	00 00 0c 0c 0e 1c 07 38 c3 30 c3 30 c3 30 c3 30     .......8.0.0.0.0
     325:	c3 30 e7 39 7e 1f 3c 0e 00 00 c0 03 e0 03 70 03     .0.9~.<.......p.
     335:	38 03 1c 03 0e 03 07 03 ff 3f ff 3f 00 03 00 03     8........?.?....
     345:	00 00 3f 0c 7f 1c 63 38 63 30 63 30 63 30 63 30     ..?...c8c0c0c0c0
     355:	63 30 e3 38 c3 1f 83 0f 00 00 c0 0f f0 1f f8 39     c0.8...........9
     365:	dc 30 ce 30 c7 30 c3 30 c3 30 c3 39 80 1f 00 0f     .0.0.0.0.0.9....
     375:	00 00 03 00 03 00 03 00 03 30 03 3c 03 0f c3 03     .........0.<....
     385:	f3 00 3f 00 0f 00 03 00 00 00 00 0f bc 1f fe 39     ..?............9
     395:	e7 30 c3 30 c3 30 c3 30 e7 30 fe 39 bc 1f 00 0f     .0.0.0.0.0.9....
     3a5:	00 00 3c 00 7e 00 e7 30 c3 30 c3 30 c3 38 c3 1c     ..<.~..0.0.0.8..
     3b5:	c3 0e e7 07 fe 03 fc 00 00 00 00 00 00 00 00 00     ................
     3c5:	70 1c 70 1c 70 1c 00 00 00 00 00 00 00 00 00 00     p.p.p...........
	...
     3dd:	70 9c 70 fc 70 7c 00 00 00 00 00 00 00 00 00 00     p.p.p|..........
     3ed:	00 00 00 00 c0 00 e0 01 f0 03 38 07 1c 0e 0e 1c     ..........8.....
     3fd:	07 38 03 30 00 00 00 00 00 00 00 00 60 06 60 06     .8.0........`.`.
     40d:	60 06 60 06 60 06 60 06 60 06 60 06 60 06 00 00     `.`.`.`.`.`.`...
     41d:	00 00 00 00 03 30 07 38 0e 1c 1c 0e 38 07 f0 03     .....0.8....8...
     42d:	e0 01 c0 00 00 00 00 00 00 00 1c 00 1e 00 07 00     ................
     43d:	03 00 83 37 c3 37 e3 00 77 00 3e 00 1c 00 00 00     ...7.7..w.>.....
     44d:	00 00 f8 0f fe 1f 07 18 f3 33 fb 37 1b 36 fb 37     .........3.7.6.7
     45d:	fb 37 07 36 fe 03 f8 01 00 00 00 38 00 3f e0 07     .7.6.......8.?..
     46d:	fc 06 1f 06 1f 06 fc 06 e0 07 00 3f 00 38 00 00     ...........?.8..
     47d:	00 00 ff 3f ff 3f c3 30 c3 30 c3 30 c3 30 e7 30     ...?.?.0.0.0.0.0
     48d:	fe 39 bc 1f 00 0f 00 00 00 00 f0 03 fc 0f 0e 1c     .9..............
     49d:	07 38 03 30 03 30 03 30 07 38 0e 1c 0c 0c 00 00     .8.0.0.0.8......
     4ad:	00 00 ff 3f ff 3f 03 30 03 30 03 30 03 30 07 38     ...?.?.0.0.0.0.8
     4bd:	0e 1c fc 0f f0 03 00 00 00 00 ff 3f ff 3f c3 30     ...........?.?.0
     4cd:	c3 30 c3 30 c3 30 c3 30 c3 30 03 30 03 30 00 00     .0.0.0.0.0.0.0..
     4dd:	00 00 ff 3f ff 3f c3 00 c3 00 c3 00 c3 00 c3 00     ...?.?..........
     4ed:	c3 00 03 00 03 00 00 00 00 00 f0 03 fc 0f 0e 1c     ................
     4fd:	07 38 03 30 c3 30 c3 30 c3 30 c7 3f c6 3f 00 00     .8.0.0.0.0.?.?..
     50d:	00 00 ff 3f ff 3f c0 00 c0 00 c0 00 c0 00 c0 00     ...?.?..........
     51d:	c0 00 ff 3f ff 3f 00 00 00 00 00 00 00 00 03 30     ...?.?.........0
     52d:	03 30 ff 3f ff 3f 03 30 03 30 00 00 00 00 00 00     .0.?.?.0.0......
     53d:	00 00 00 0e 00 1e 00 38 00 30 00 30 00 30 00 30     .......8.0.0.0.0
     54d:	00 38 ff 1f ff 07 00 00 00 00 ff 3f ff 3f c0 00     .8.........?.?..
     55d:	e0 01 f0 03 38 07 1c 0e 0e 1c 07 38 03 30 00 00     ....8......8.0..
     56d:	00 00 ff 3f ff 3f 00 30 00 30 00 30 00 30 00 30     ...?.?.0.0.0.0.0
     57d:	00 30 00 30 00 30 00 00 00 00 ff 3f ff 3f 1e 00     .0.0.0.....?.?..
     58d:	78 00 e0 01 e0 01 78 00 1e 00 ff 3f ff 3f 00 00     x.....x....?.?..
     59d:	00 00 ff 3f ff 3f 0e 00 38 00 f0 00 c0 03 00 07     ...?.?..8.......
     5ad:	00 1c ff 3f ff 3f 00 00 00 00 f0 03 fc 0f 0e 1c     ...?.?..........
     5bd:	07 38 03 30 03 30 07 38 0e 1c fc 0f f0 03 00 00     .8.0.0.8........
     5cd:	00 00 ff 3f ff 3f 83 01 83 01 83 01 83 01 83 01     ...?.?..........
     5dd:	c7 01 fe 00 7c 00 00 00 00 00 f0 03 fc 0f 0e 1c     ....|...........
     5ed:	07 38 03 30 03 36 07 3e 0e 1c fc 3f f0 33 00 00     .8.0.6.>...?.3..
     5fd:	00 00 ff 3f ff 3f 83 01 83 01 83 03 83 07 83 0f     ...?.?..........
     60d:	c7 1d fe 38 7c 30 00 00 00 00 3c 0c 7e 1c e7 38     ...8|0....<.~..8
     61d:	c3 30 c3 30 c3 30 c3 30 c7 39 8e 1f 0c 0f 00 00     .0.0.0.0.9......
     62d:	00 00 00 00 03 00 03 00 03 00 ff 3f ff 3f 03 00     ...........?.?..
     63d:	03 00 03 00 00 00 00 00 00 00 ff 07 ff 1f 00 38     ...............8
     64d:	00 30 00 30 00 30 00 30 00 38 ff 1f ff 07 00 00     .0.0.0.0.8......
     65d:	00 00 07 00 3f 00 f8 01 c0 0f 00 3e 00 3e c0 0f     ....?......>.>..
     66d:	f8 01 3f 00 07 00 00 00 00 00 ff 3f ff 3f 00 1c     ..?........?.?..
     67d:	00 06 80 03 80 03 00 06 00 1c ff 3f ff 3f 00 00     ...........?.?..
     68d:	00 00 03 30 0f 3c 1c 0e 30 03 e0 01 e0 01 30 03     ...0.<..0.....0.
     69d:	1c 0e 0f 3c 03 30 00 00 00 00 03 00 0f 00 3c 00     ...<.0........<.
     6ad:	f0 00 c0 3f c0 3f f0 00 3c 00 0f 00 03 00 00 00     ...?.?..<.......
     6bd:	00 00 03 30 03 3c 03 3e 03 33 c3 31 e3 30 33 30     ...0.<.>.3.1.030
     6cd:	1f 30 0f 30 03 30 00 00 00 00 00 00 00 00 ff 3f     .0.0.0.........?
     6dd:	ff 3f 03 30 03 30 03 30 03 30 00 00 00 00 00 00     .?.0.0.0.0......
     6ed:	00 00 0e 00 1c 00 38 00 70 00 e0 00 c0 01 80 03     ......8.p.......
     6fd:	00 07 00 0e 00 1c 00 18 00 00 00 00 00 00 03 30     ...............0
     70d:	03 30 03 30 03 30 ff 3f ff 3f 00 00 00 00 00 00     .0.0.0.?.?......
     71d:	00 00 60 00 70 00 38 00 1c 00 0e 00 07 00 0e 00     ..`.p.8.........
     72d:	1c 00 38 00 70 00 60 00 00 00 00 c0 00 c0 00 c0     ..8.p.`.........
     73d:	00 c0 00 c0 00 c0 00 c0 00 c0 00 c0 00 c0 00 c0     ................

0000074d <font6x8>:
     74d:	06 08 85 11                                         ....

00000751 <_font6x8map>:
	...
     759:	06 5f 06 00 00 07 03 00 07 03 00 24 7e 24 7e 24     ._.........$~$~$
     769:	00 24 2b 6a 12 00 00 63 13 08 64 63 00 36 49 56     .$+j...c..dc.6IV
     779:	20 50 00 00 07 03 00 00 00 00 3e 41 00 00 00 00      P........>A....
     789:	41 3e 00 00 00 08 3e 1c 3e 08 00 08 08 3e 08 08     A>....>.>....>..
     799:	00 00 e0 60 00 00 00 08 08 08 08 08 00 00 60 60     ...`..........``
     7a9:	00 00 00 20 10 08 04 02 00 3e 51 49 45 3e 00 00     ... .....>QIE>..
     7b9:	42 7f 40 00 00 62 51 49 49 46 00 22 49 49 49 36     B.@..bQIIF."III6
     7c9:	00 18 14 12 7f 10 00 2f 49 49 49 31 00 3c 4a 49     ......./III1.<JI
     7d9:	49 30 00 01 71 09 05 03 00 36 49 49 49 36 00 06     I0..q....6III6..
     7e9:	49 49 29 1e 00 00 6c 6c 00 00 00 00 ec 6c 00 00     II)...ll.....l..
     7f9:	00 08 14 22 41 00 00 24 24 24 24 24 00 00 41 22     ..."A..$$$$$..A"
     809:	14 08 00 02 01 59 09 06 00 3e 41 5d 55 1e 00 7e     .....Y...>A]U..~
     819:	11 11 11 7e 00 7f 49 49 49 36 00 3e 41 41 41 22     ...~..III6.>AAA"
     829:	00 7f 41 41 41 3e 00 7f 49 49 49 41 00 7f 09 09     ..AAA>..IIIA....
     839:	09 01 00 3e 41 49 49 7a 00 7f 08 08 08 7f 00 00     ...>AIIz........
     849:	41 7f 41 00 00 30 40 40 40 3f 00 7f 08 14 22 41     A.A..0@@@?...."A
     859:	00 7f 40 40 40 40 00 7f 02 04 02 7f 00 7f 02 04     ..@@@@..........
     869:	08 7f 00 3e 41 41 41 3e 00 7f 09 09 09 06 00 3e     ...>AAA>.......>
     879:	41 51 21 5e 00 7f 09 09 19 66 00 26 49 49 49 32     AQ!^.....f.&III2
     889:	00 01 01 7f 01 01 00 3f 40 40 40 3f 00 1f 20 40     .......?@@@?.. @
     899:	20 1f 00 3f 40 3c 40 3f 00 63 14 08 14 63 00 07      ..?@<@?.c...c..
     8a9:	08 70 08 07 00 71 49 45 43 00 00 00 7f 41 41 00     .p...qIEC....AA.
     8b9:	00 02 04 08 10 20 00 00 41 41 7f 00 00 04 02 01     ..... ..AA......
     8c9:	02 04 80 80 80 80 80 80 00 00 03 07 00 00 00 20     ............... 
     8d9:	54 54 54 78 00 7f 44 44 44 38 00 38 44 44 44 28     TTTx..DDD8.8DDD(
     8e9:	00 38 44 44 44 7f 00 38 54 54 54 08 00 08 7e 09     .8DDD..8TTT...~.
     8f9:	09 00 00 18 a4 a4 a4 7c 00 7f 04 04 78 00 00 00     .......|....x...
     909:	00 7d 40 00 00 40 80 84 7d 00 00 7f 10 28 44 00     .}@..@..}....(D.
     919:	00 00 00 7f 40 00 00 7c 04 18 04 78 00 7c 04 04     ....@..|...x.|..
     929:	78 00 00 38 44 44 44 38 00 fc 44 44 44 38 00 38     x..8DDD8..DDD8.8
     939:	44 44 44 fc 00 44 78 44 04 08 00 08 54 54 54 20     DDD..DxD....TTT 
     949:	00 04 3e 44 24 00 00 3c 40 20 7c 00 00 1c 20 40     ..>D$..<@ |... @
     959:	20 1c 00 3c 60 30 60 3c 00 6c 10 10 6c 00 00 9c      ..<`0`<.l..l...
     969:	a0 60 3c 00 00 64 54 54 4c 00 00 08 3e 41 41 00     .`<..dTTL...>AA.
     979:	00 00 00 77 00 00 00 00 41 41 3e 08 00 02 01 02     ...w....AA>.....
     989:	01 00 00 3c 26 23 26 3c                             ...<&#&<

00000991 <fonts>:
     991:	4d 07 49 01                                         M.I.

00000995 <glyArrowUp>:
     995:	08 08 30 38 3c 3e 3e 3c 38 30                       ..08<>><80

0000099f <glyArrowDown>:
     99f:	08 08 06 0e 1e 3e 3e 1e 0e 06                       .....>>...

000009a9 <glyBall>:
     9a9:	09 09 38 00 fe 00 fe 00 ff 01 ff 01 ff 01 fe 00     ..8.............
     9b9:	fe 00 38 00                                         ..8.

000009bd <glyDirCW>:
     9bd:	09 03 00 00 00 00 02 02 02 07 02                    ...........

000009c8 <glyDirCCW>:
     9c8:	05 03 02 07 02 02 02                                .......

000009cf <glyLogo>:
     9cf:	40 40 00 00 00 00 01 03 03 03 03 03 03 03 03 03     @@..............
     9df:	03 03 03 03 03 03 07 0f 1f 1f 3f 3f 7f 7f 7f 7f     ..........??....
     9ef:	7f 3f 1f 0f 00 03 03 03 03 03 03 03 03 03 03 03     .?..............
     9ff:	03 03 03 03 03 07 07 07 07 07 07 07 03 03 01 00     ................
     a0f:	00 00 00 00 00 00 ff ff 00 00 00 00 00 00 00 00     ................
     a1f:	00 01 1f 7f ff ff ff ff ff e7 c3 e7 ff ff ff ff     ................
     a2f:	ff ff fe f0 00 00 00 00 00 00 00 00 00 07 0f 3f     ...............?
     a3f:	7f ff ff ff fc fc ff ff ff ff ff ff ff ff 7c c3     ..............|.
     a4f:	00 00 00 00 00 00 ff ff 00 00 00 00 00 00 00 00     ................
     a5f:	00 00 f0 f8 fc fe fe fe fe fc fc fd fb f7 f7 ef     ................
     a6f:	df 0b 00 00 00 00 00 00 00 01 03 03 ff ff ff ff     ................
     a7f:	ff ff ff ff 7f 7f ff ff ff fe fc f8 e0 80 7f ff     ................
     a8f:	00 00 00 00 00 00 ff ff 00 00 00 00 00 00 00 00     ................
	...
     aa7:	00 00 00 80 fd ff ff ff ff ff 7f 1f 3f 7f 7f fe     ............?...
     ab7:	fe fc f8 f8 f0 f0 e0 c0 c0 e0 c0 c0 c0 c0 80 80     ................
     ac7:	00 00 00 00 00 00 ff ff 00 00 00 00 00 00 ff ff     ................
     ad7:	00 00 01 01 03 03 07 07 07 0f 07 07 07 03 03 07     ................
     ae7:	0f 0f 3f 7f ff ff fe fe ff ff ff ff ff af 03 00     ..?.............
	...
     b0b:	00 00 ff ff 00 00 00 00 00 00 ff ff 3f 7f ff ff     ............?...
     b1b:	fc f8 fc ff ff ff ff ff ff ff ff e8 c0 c0 80 80     ................
     b2b:	00 00 00 00 80 f9 ff ff ff ff ff 7f 7f 7f 7f ff     ................
     b3b:	7f 7f 7f 3f 1f 01 00 00 00 00 00 00 00 00 00 00     ...?............
     b4b:	00 00 ff ff 00 00 00 00 00 fe ff ff ff ff ff ff     ................
     b5b:	ff 7f ff ff ff ff fe fc f0 e0 00 00 00 00 00 00     ................
     b6b:	00 00 01 1f 7f ff ff ff ff ff c7 c7 cf ff ff ff     ................
     b7b:	ff ff ff fe f0 00 00 00 00 00 00 00 00 00 00 00     ................
     b8b:	00 00 ff ff 00 00 00 00 00 00 f0 f8 d8 d8 f8 d8     ................
     b9b:	d8 d8 d8 98 18 18 18 18 18 18 18 18 18 18 18 18     ................
     bab:	18 18 18 f8 f8 fc fc fc fe fc fc fc fc f8 f0 f0     ................
     bbb:	d8 d8 18 18 18 18 18 18 18 18 18 18 18 18 18 18     ................
     bcb:	18 18 f8 f0 00 00                                   ......

00000bd1 <scrESCCal>:
     bd1:	f0 0d 5a 0e                                         ..Z.

00000bd5 <lstMenu>:
     bd5:	8e 0e 9e 0e ac 0e ba 0e c8 0e d7 0e e3 0e f1 0e     ................
     be5:	04 0f 14 0f 24 0f 2a 0f                             ....$.*.

00000bed <strAreYouSure>:
     bed:	41 72 65 20 79 6f 75 20 73 75 72 65 3f 00           Are you sure?.

00000bfb <_skMENUSAVE>:
     bfb:	53 41 56 45 20 55 50 20 20 20 44 4f 57 4e 20 20     SAVE UP   DOWN  
     c0b:	45 4e 54 45 52 00                                   ENTER.

00000c11 <__c.2260>:
     c11:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
	...

00000c22 <_skEDIT>:
     c22:	43 41 4e 43 45 4c 20 20 44 4f 57 4e 20 20 20 55     CANCEL  DOWN   U
     c32:	50 20 20 4f 4b 00                                   P  OK.

00000c38 <__c.2250>:
     c38:	41 43 43 2d 5a 20 64 61 6d 70 69 6e 67 00           ACC-Z damping.

00000c46 <__c.2237>:
     c46:	54 72 69 6d 20 50 3a 20 20 20 20 52 3a 00           Trim P:    R:.

00000c54 <__c.2235>:
     c54:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
	...

00000c65 <__c.2230>:
     c65:	52 00                                               R.

00000c67 <__c.2228>:
     c67:	4e 00                                               N.

00000c69 <__c.2226>:
     c69:	52 65 76 65 72 73 65 20 47 59 52 4f 00              Reverse GYRO.

00000c76 <__c.2224>:
     c76:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
	...

00000c87 <__c.2209>:
     c87:	6e 6f 20 00                                         no .

00000c8b <__c.2207>:
     c8b:	79 65 73 00                                         yes.

00000c8f <strYes>:
     c8f:	59 65 73 00                                         Yes.

00000c93 <strNo>:
     c93:	4e 6f 20 00                                         No .

00000c97 <__c.2197>:
     c97:	41 20 54 72 69 20 00                                A Tri .

00000c9e <__c.2195>:
     c9e:	59 20 54 72 69 20 00                                Y Tri .

00000ca5 <__c.2193>:
     ca5:	58 20 51 75 61 64 00                                X Quad.

00000cac <__c.2191>:
     cac:	2b 20 51 75 61 64 00                                + Quad.

00000cb3 <__c.2189>:
     cb3:	58 20 51 75 61 64 00                                X Quad.

00000cba <__c.2187>:
     cba:	2b 20 51 75 61 64 00                                + Quad.

00000cc1 <__c.2185>:
     cc1:	55 41 52 54 20 00                                   UART .

00000cc7 <__c.2183>:
     cc7:	42 75 64 64 79 00                                   Buddy.

00000ccd <__c.2181>:
     ccd:	54 52 49 20 00                                      TRI .

00000cd2 <__c.2179>:
     cd2:	51 75 61 64 00                                      Quad.

00000cd7 <_skBACK>:
     cd7:	42 41 43 4b 20 20 20 20 20 20 20 20 20 20 20 20     BACK            
     ce7:	20 20 20 20 20 00                                        .

00000ced <strSPC1>:
     ced:	20 00                                                .

00000cef <strErr>:
     cef:	45 72 72 00                                         Err.

00000cf3 <strSPC4>:
     cf3:	20 20 20 20 00                                          .

00000cf8 <__c.2152>:
     cf8:	4e 41 00                                            NA.

00000cfb <strARMED>:
     cfb:	41 52 4d 45 44 00                                   ARMED.

00000d01 <strVersionInfo>:
     d01:	48 65 66 6e 79 43 6f 70 74 65 72 32 20 76 31 2e     HefnyCopter2 v1.
     d11:	30 2e 30 00                                         0.0.

00000d15 <strOK>:
     d15:	4f 4b 20 00                                         OK .

00000d19 <str1>:
     d19:	31 00                                               1.

00000d1b <strX>:
     d1b:	58 00                                               X.

00000d1d <str2>:
     d1d:	32 00                                               2.

00000d1f <__c.2123>:
     d1f:	2b 00                                               +.

00000d21 <__c.2121>:
     d21:	58 00                                               X.

00000d23 <__c.2119>:
     d23:	59 00                                               Y.

00000d25 <__c.2117>:
     d25:	2b 00                                               +.

00000d27 <__c.2115>:
     d27:	41 00                                               A.

00000d29 <__c.2113>:
     d29:	58 00                                               X.

00000d2b <__c.2111>:
     d2b:	55 41 52 54 20 00                                   UART .

00000d31 <__c.2109>:
     d31:	42 75 64 64 79 00                                   Buddy.

00000d37 <__c.2107>:
     d37:	54 52 49 20 00                                      TRI .

00000d3c <__c.2105>:
     d3c:	51 75 61 64 00                                      Quad.

00000d41 <__c.2103>:
     d41:	41 4c 54 48 4c 44 00                                ALTHLD.

00000d48 <__c.2101>:
     d48:	53 54 41 42 4c 45 00                                STABLE.

00000d4f <__c.2099>:
     d4f:	41 43 52 4f 20 20 00                                ACRO  .

00000d56 <pages>:
     d56:	38 0f 01 2e 4e 0f 82 0f a2 36 00 00 38 0f e5 2d     8...N....6..8..-
     d66:	98 0f 9c 0f b2 2a b2 0f 9c 0f 94 29 e7 0f 82 0f     .....*.....)....
     d76:	a0 32 fc 0f 82 0f 99 30 fc 0f 82 0f ef 2f fc 0f     .2.....0...../..
     d86:	82 0f 30 35 43 10 7a 10 87 34 90 10 d7 0c 4c 2a     ..05C.z..4....L*
     d96:	da 10 d7 0c 48 2d 10 11 40 11 12 2a da 10 56 11     ....H-..@..*..V.
     da6:	c0 2b 10 11 40 11 c8 2d f0 0d d7 0c ba 29 00 00     .+..@..-.....)..
     db6:	6c 11 b3 2d 00 00                                   l..-..

00000dbc <__c.2032>:
     dbc:	59 41 57 20 20 20 20 20 20 20 20 20 00              YAW         .

00000dc9 <__c.2029>:
     dc9:	52 6f 6c 6c 20 20 20 20 20 20 20 20 00              Roll        .

00000dd6 <__c.2025>:
     dd6:	50 69 74 63 68 20 26 20 52 6f 6c 6c 00              Pitch & Roll.

00000de3 <__c.2023>:
     de3:	50 69 74 63 68 20 20 20 20 20 20 20 00              Pitch       .

00000df0 <scrESCCal0>:
     df0:	2d 54 41 4b 45 20 4f 46 46 20 50 52 4f 50 45 4c     -TAKE OFF PROPEL
     e00:	4c 45 52 53 21 21 0a 2d 50 72 65 73 73 20 63 6f     LERS!!.-Press co
     e10:	6e 74 69 6e 75 65 0a 2d 54 75 72 6e 20 4f 66 66     ntinue.-Turn Off
     e20:	20 51 75 61 64 63 6f 70 74 65 72 2e 0a 0a 2d 51      Quadcopter...-Q
     e30:	75 61 64 20 77 69 6c 6c 20 73 74 61 72 74 65 64     uad will started
     e40:	0a 69 6e 20 41 52 4d 45 44 20 54 41 4b 45 43 41     .in ARMED TAKECA
     e50:	52 45 20 73 74 61 74 65 0a 00                       RE state..

00000e5a <scrESCCal1>:
     e5a:	50 72 65 73 73 20 43 6f 6e 74 69 6e 75 65 20 61     Press Continue a
     e6a:	66 74 65 72 20 63 61 6c 69 62 72 61 74 69 6f 6e     fter calibration
     e7a:	2e 0a 0a 75 6e 70 6c 75 67 20 62 61 74 74 65 72     ...unplug batter
     e8a:	79 2e 0a 00                                         y...

00000e8e <strStabilization>:
     e8e:	47 79 72 6f 20 50 49 44 20 45 64 69 74 6f 72 00     Gyro PID Editor.

00000e9e <strSelflevel>:
     e9e:	53 65 6c 66 20 4c 65 76 65 6c 69 6e 67 00           Self Leveling.

00000eac <strAltitudeHold>:
     eac:	41 6c 74 69 74 75 64 65 20 48 6f 6c 64 00           Altitude Hold.

00000eba <strModeSettings>:
     eba:	4d 6f 64 65 20 53 65 74 74 69 6e 67 73 00           Mode Settings.

00000ec8 <strMiscSettings>:
     ec8:	4d 69 73 63 2e 20 53 65 74 74 69 6e 67 73 00        Misc. Settings.

00000ed7 <strSensorTest>:
     ed7:	53 65 6e 73 6f 72 20 54 65 73 74 00                 Sensor Test.

00000ee3 <strReceiverTest>:
     ee3:	52 65 63 65 69 76 65 72 20 54 65 73 74 00           Receiver Test.

00000ef1 <strSensorCalibration>:
     ef1:	53 65 6e 73 6f 72 20 43 61 6c 69 62 72 61 74 69     Sensor Calibrati
     f01:	6f 6e 00                                            on.

00000f04 <strRadioCalibration>:
     f04:	53 74 69 63 6b 20 43 65 6e 74 65 72 69 6e 67 00     Stick Centering.

00000f14 <strESCCalibration>:
     f14:	45 53 43 20 43 61 6c 69 62 72 61 74 69 6f 6e 00     ESC Calibration.

00000f24 <strDebug>:
     f24:	44 65 62 75 67 00                                   Debug.

00000f2a <strFactoryReset>:
     f2a:	46 61 63 74 6f 72 79 20 52 65 73 65 74 00           Factory Reset.

00000f38 <_skHOME>:
     f38:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     f48:	20 4d 45 4e 55 00                                    MENU.

00000f4e <scrHomePage>:
     f4e:	0a 0a 42 61 74 74 3a 20 20 20 20 20 20 20 76 0a     ..Batt:       v.
     f5e:	0a 0a 52 58 3a 20 2d 20 20 53 4e 3a 20 20 20 20     ..RX: -  SN:    
     f6e:	53 54 3a 20 2d 0a 46 6c 79 3a 20 20 20 42 6f 61     ST: -.Fly:   Boa
     f7e:	72 64 3a 00                                         rd:.

00000f82 <_skMENU>:
     f82:	42 41 43 4b 20 55 50 20 20 20 44 4f 57 4e 20 20     BACK UP   DOWN  
     f92:	45 4e 54 45 52 00                                   ENTER.

00000f98 <scrHomePageArmed>:
     f98:	0a 0a 0a 00                                         ....

00000f9c <_skSAVE>:
     f9c:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     fac:	20 44 4f 4e 45 00                                    DONE.

00000fb2 <scrHomePageArmedESCCalibration>:
     fb2:	0a 0a 0a 4d 31 3a 20 20 20 20 20 20 20 4d 34 3a     ...M1:       M4:
     fc2:	0a 4d 32 3a 20 20 20 20 20 20 20 4d 33 3a 0a 45     .M2:       M3:.E
     fd2:	53 43 20 43 61 6c 69 62 72 61 74 69 6f 6e 20 6d     SC Calibration m
     fe2:	6f 64 65 0a 00                                      ode..

00000fe7 <scrHomePageRestart>:
     fe7:	0a 52 45 53 54 41 52 54 0a 20 20 20 20 20 20 42     .RESTART.      B
     ff7:	4f 41 52 44 00                                      OARD.

00000ffc <scrStabilization>:
     ffc:	0a 50 3a 20 20 20 20 20 20 20 4c 69 6d 3a 0a 49     .P:       Lim:.I
    100c:	3a 20 20 20 20 20 20 20 4c 69 6d 3a 0a 44 3a 20     :       Lim:.D: 
    101c:	20 20 20 20 20 20 4c 69 6d 3a 0a 4e 6f 69 73 65           Lim:.Noise
    102c:	20 46 69 6c 74 65 72 3a 0a 54 72 69 6d 20 50 3a      Filter:.Trim P:
    103c:	20 20 20 20 52 3a 00                                    R:.

00001043 <scrModeSettings>:
    1043:	46 72 61 6d 65 20 54 79 70 65 3a 0a 42 75 64 64     Frame Type:.Budd
    1053:	79 20 53 79 73 74 65 6d 3a 0a 42 6f 61 72 64 20     y System:.Board 
    1063:	44 69 72 3a 0a 46 6c 79 20 20 20 44 69 72 3a 0a     Dir:.Fly   Dir:.
    1073:	53 6f 6e 61 72 3a 00                                Sonar:.

0000107a <_skPAGE>:
    107a:	42 41 43 4b 20 50 52 45 56 20 4e 45 58 54 20 43     BACK PREV NEXT C
    108a:	48 41 4e 47 45 00                                   HANGE.

00001090 <scrMiscSettings>:
    1090:	41 75 74 6f 20 44 69 73 61 72 6d 3a 0a 56 6f 6c     Auto Disarm:.Vol
    10a0:	74 20 41 6c 61 72 6d 3a 20 20 20 20 20 20 2f 31     t Alarm:      /1
    10b0:	30 76 0a 54 68 72 6f 74 74 6c 65 20 6d 69 6e 3a     0v.Throttle min:
    10c0:	0a 53 74 69 63 6b 20 53 63 61 6c 65 3a 0a 50 2d     .Stick Scale:.P-
    10d0:	52 20 4c 69 6e 6b 65 64 3a 00                       R Linked:.

000010da <scrSensorTest>:
    10da:	47 79 72 6f 20 58 3a 0a 47 79 72 6f 20 59 3a 0a     Gyro X:.Gyro Y:.
    10ea:	47 79 72 6f 20 5a 3a 0a 41 63 63 20 20 58 3a 0a     Gyro Z:.Acc  X:.
    10fa:	41 63 63 20 20 59 3a 0a 41 63 63 20 20 5a 3a 0a     Acc  Y:.Acc  Z:.
    110a:	42 61 74 74 3a 00                                   Batt:.

00001110 <scrReceiverTest>:
    1110:	20 43 48 20 20 20 52 58 2d 31 20 20 20 20 52 58      CH   RX-1    RX
    1120:	2d 32 0a 41 69 6c 3a 0a 45 6c 65 3a 0a 52 75 64     -2.Ail:.Ele:.Rud
    1130:	3a 0a 54 68 72 3a 0a 41 75 78 3a 0a 52 58 3a 00     :.Thr:.Aux:.RX:.

00001140 <_skCONTINUE>:
    1140:	42 41 43 4b 20 20 20 20 20 20 20 20 20 43 4f 4e     BACK         CON
    1150:	54 49 4e 55 45 00                                   TINUE.

00001156 <_skCLRDONE>:
    1156:	42 41 43 4b 20 43 4c 52 20 20 20 20 20 20 20 20     BACK CLR        
    1166:	20 44 4f 4e 45 00                                    DONE.

0000116c <_skCANCELYES>:
    116c:	4e 4f 20 20 20 20 20 20 20 20 20 20 20 20 20 20     NO              
    117c:	20 20 59 45 53 00 00 40 7a 10 f3 5a 00 a0 72 4e       YES..@z..Z..rN
    118c:	18 09 00 10 a5 d4 e8 00 00 e8 76 48 17 00 00 e4     ..........vH....
    119c:	0b 54 02 00 00 ca 9a 3b 00 00 00 e1 f5 05 00 00     .T.....;........
    11ac:	80 96 98 00 00 00 40 42 0f 00 00 00 a0 86 01 00     ......@B........
    11bc:	00 00 10 27 00 00 00 00 e8 03 00 00 00 00 64 00     ...'..........d.
    11cc:	00 00 00 00 0a 00 00 00 00 00 01 00 00 00 00 00     ................
    11dc:	2c 76 d8 88 dc 67 4f 08 23 df c1 df ae 59 e1 b1     ,v...gO.#....Y..
    11ec:	b7 96 e5 e3 e4 53 c6 3a e6 51 99 76 96 e8 e6 c2     .....S.:.Q.v....
    11fc:	84 26 eb 89 8c 9b 62 ed 40 7c 6f fc ef bc 9c 9f     .&....b.@|o.....
    120c:	40 f2 ba a5 6f a5 f4 90 05 5a 2a f7 5c 93 6b 6c     @...o....Z*.\.kl
    121c:	f9 67 6d c1 1b fc e0 e4 0d 47 fe f5 20 e6 b5 00     .gm......G.. ...
    122c:	d0 ed 90 2e 03 00 94 35 77 05 00 80 84 1e 08 00     .......5w.......
    123c:	00 20 4e 0a 00 00 00 c8 0c 33 33 33 33 0f 98 6e     . N......3333..n
    124c:	12 83 11 41 ef 8d 21 14 89 3b e6 55 16 cf fe e6     ...A..!..;.U....
    125c:	db 18 d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb e4 24     ....K8..|......$
    126c:	20 32 84 72 5e 22 81 00 c9 f1 24 ec a1 e5 3d 27      2.r^"....$...='

0000127c <__vector_18>:
	sendData(column & 0x0f, LCD_COMMAND);
}

__attribute__ ((section(".lowtext")))
ISR(TIMER0_OVF_vect, ISR_NOBLOCK)
{
    127c:	78 94       	sei
    127e:	1f 92       	push	r1
    1280:	0f 92       	push	r0
    1282:	0f b6       	in	r0, 0x3f	; 63
    1284:	0f 92       	push	r0
    1286:	11 24       	eor	r1, r1
    1288:	2f 93       	push	r18
    128a:	3f 93       	push	r19
    128c:	4f 93       	push	r20
    128e:	5f 93       	push	r21
    1290:	6f 93       	push	r22
    1292:	7f 93       	push	r23
    1294:	8f 93       	push	r24
    1296:	9f 93       	push	r25
    1298:	af 93       	push	r26
    129a:	bf 93       	push	r27
    129c:	cf 93       	push	r28
    129e:	df 93       	push	r29
    12a0:	ef 93       	push	r30
    12a2:	ff 93       	push	r31
	TCNT0_X +=1;
    12a4:	80 91 a6 05 	lds	r24, 0x05A6
    12a8:	90 91 a7 05 	lds	r25, 0x05A7
    12ac:	01 96       	adiw	r24, 0x01	; 1
    12ae:	90 93 a7 05 	sts	0x05A7, r25
    12b2:	80 93 a6 05 	sts	0x05A6, r24
	static uint16_t offset;
	
	if (offset % LCDWIDTH == 0)
    12b6:	c0 91 1d 05 	lds	r28, 0x051D
    12ba:	d0 91 1e 05 	lds	r29, 0x051E
    12be:	ce 01       	movw	r24, r28
    12c0:	8f 77       	andi	r24, 0x7F	; 127
    12c2:	90 70       	andi	r25, 0x00	; 0
    12c4:	00 97       	sbiw	r24, 0x00	; 0
    12c6:	99 f4       	brne	.+38     	; 0x12ee <__vector_18+0x72>
		setPos(offset / LCDWIDTH, 0);
    12c8:	ce 01       	movw	r24, r28
    12ca:	88 0f       	add	r24, r24
    12cc:	89 2f       	mov	r24, r25
    12ce:	88 1f       	adc	r24, r24
    12d0:	99 0b       	sbc	r25, r25
    12d2:	91 95       	neg	r25
	LCD_CS = 1;
}

static void setPos(uint8_t line, uint8_t column)
{
	sendData(0xB0 | (line & 0x07), LCD_COMMAND);
    12d4:	87 70       	andi	r24, 0x07	; 7
    12d6:	80 6b       	ori	r24, 0xB0	; 176
    12d8:	60 e0       	ldi	r22, 0x00	; 0
    12da:	0e 94 ed 0b 	call	0x17da	; 0x17da <sendData>
	sendData(0x10 | (column >> 4), LCD_COMMAND);
    12de:	80 e1       	ldi	r24, 0x10	; 16
    12e0:	60 e0       	ldi	r22, 0x00	; 0
    12e2:	0e 94 ed 0b 	call	0x17da	; 0x17da <sendData>
	sendData(column & 0x0f, LCD_COMMAND);
    12e6:	80 e0       	ldi	r24, 0x00	; 0
    12e8:	60 e0       	ldi	r22, 0x00	; 0
    12ea:	0e 94 ed 0b 	call	0x17da	; 0x17da <sendData>
	static uint16_t offset;
	
	if (offset % LCDWIDTH == 0)
		setPos(offset / LCDWIDTH, 0);
		
	sendData(*(_screen + offset++), LCD_DATA);
    12ee:	fe 01       	movw	r30, r28
    12f0:	e3 5e       	subi	r30, 0xE3	; 227
    12f2:	fe 4f       	sbci	r31, 0xFE	; 254
    12f4:	80 81       	ld	r24, Z
    12f6:	61 e0       	ldi	r22, 0x01	; 1
    12f8:	0e 94 ed 0b 	call	0x17da	; 0x17da <sendData>
    12fc:	21 96       	adiw	r28, 0x01	; 1
	offset %= sizeof(_screen);
    12fe:	d3 70       	andi	r29, 0x03	; 3
    1300:	d0 93 1e 05 	sts	0x051E, r29
    1304:	c0 93 1d 05 	sts	0x051D, r28
}
    1308:	ff 91       	pop	r31
    130a:	ef 91       	pop	r30
    130c:	df 91       	pop	r29
    130e:	cf 91       	pop	r28
    1310:	bf 91       	pop	r27
    1312:	af 91       	pop	r26
    1314:	9f 91       	pop	r25
    1316:	8f 91       	pop	r24
    1318:	7f 91       	pop	r23
    131a:	6f 91       	pop	r22
    131c:	5f 91       	pop	r21
    131e:	4f 91       	pop	r20
    1320:	3f 91       	pop	r19
    1322:	2f 91       	pop	r18
    1324:	0f 90       	pop	r0
    1326:	0f be       	out	0x3f, r0	; 63
    1328:	0f 90       	pop	r0
    132a:	1f 90       	pop	r1
    132c:	18 95       	reti

0000132e <__vector_6>:
 
 uint8_t OldPortCValue;

__attribute__ ((section(".lowtext")))
ISR (RX2_ALL_vect)
{
    132e:	1f 92       	push	r1
    1330:	0f 92       	push	r0
    1332:	0f b6       	in	r0, 0x3f	; 63
    1334:	0f 92       	push	r0
    1336:	11 24       	eor	r1, r1
    1338:	0f 93       	push	r16
    133a:	1f 93       	push	r17
    133c:	2f 93       	push	r18
    133e:	3f 93       	push	r19
    1340:	4f 93       	push	r20
    1342:	5f 93       	push	r21
    1344:	6f 93       	push	r22
    1346:	7f 93       	push	r23
    1348:	8f 93       	push	r24
    134a:	9f 93       	push	r25
    134c:	af 93       	push	r26
    134e:	bf 93       	push	r27
    1350:	cf 93       	push	r28
    1352:	df 93       	push	r29
    1354:	ef 93       	push	r30
    1356:	ff 93       	push	r31
	uint8_t Changes = PINC ^ OldPortCValue;  // capture changed bit
    1358:	16 b1       	in	r17, 0x06	; 6
    135a:	80 91 e9 07 	lds	r24, 0x07E9
    135e:	18 27       	eor	r17, r24
	OldPortCValue = PINC;
    1360:	86 b1       	in	r24, 0x06	; 6
    1362:	80 93 e9 07 	sts	0x07E9, r24
	uint16_t TCNT1_TEMP = TCNT1;
    1366:	c0 91 84 00 	lds	r28, 0x0084
    136a:	d0 91 85 00 	lds	r29, 0x0085
	// if there is a signal change in ROLL
	if ((Changes & RX2_ROLL_PIN)!=0)
    136e:	01 2f       	mov	r16, r17
    1370:	15 ff       	sbrs	r17, 5
    1372:	18 c0       	rjmp	.+48     	; 0x13a4 <__vector_6+0x76>
	{
		if (RX2_ROLL)
    1374:	86 b1       	in	r24, 0x06	; 6
    1376:	85 ff       	sbrs	r24, 5
    1378:	05 c0       	rjmp	.+10     	; 0x1384 <__vector_6+0x56>
		{
			RX_raw[1][RXChannel_AIL]=TCNT1_TEMP;
    137a:	d0 93 f7 07 	sts	0x07F7, r29
    137e:	c0 93 f6 07 	sts	0x07F6, r28
    1382:	10 c0       	rjmp	.+32     	; 0x13a4 <__vector_6+0x76>
		}
		else
		{
			CalculateSignalLength2 (RXChannel_AIL);
    1384:	80 e0       	ldi	r24, 0x00	; 0
    1386:	0e 94 ff 24 	call	0x49fe	; 0x49fe <CalculateSignalLength2>
			
			RX2_LastValidSignal_timestampAux = TCNT1_X;
    138a:	80 91 4e 06 	lds	r24, 0x064E
    138e:	90 91 4f 06 	lds	r25, 0x064F
    1392:	90 93 de 07 	sts	0x07DE, r25
    1396:	80 93 dd 07 	sts	0x07DD, r24
			RX_Good = TX2_FOUND_ERR;  // CLR bit 6 ---  Status = OK
    139a:	80 91 c5 07 	lds	r24, 0x07C5
    139e:	8f 71       	andi	r24, 0x1F	; 31
    13a0:	80 93 c5 07 	sts	0x07C5, r24
		}	
	}
	// if there is a signal change in PITCH
	if ((Changes & RX2_PITCH_PIN)!=0)
    13a4:	00 ff       	sbrs	r16, 0
    13a6:	0b c0       	rjmp	.+22     	; 0x13be <__vector_6+0x90>
	{
		if (RX2_PITCH)
    13a8:	86 b1       	in	r24, 0x06	; 6
    13aa:	80 ff       	sbrs	r24, 0
    13ac:	05 c0       	rjmp	.+10     	; 0x13b8 <__vector_6+0x8a>
		{
			RX_raw[1][RXChannel_ELE]=TCNT1_TEMP;
    13ae:	d0 93 f9 07 	sts	0x07F9, r29
    13b2:	c0 93 f8 07 	sts	0x07F8, r28
    13b6:	03 c0       	rjmp	.+6      	; 0x13be <__vector_6+0x90>
		}
		else
		{
			CalculateSignalLength2 (RXChannel_ELE);
    13b8:	81 e0       	ldi	r24, 0x01	; 1
    13ba:	0e 94 ff 24 	call	0x49fe	; 0x49fe <CalculateSignalLength2>
		}	
	}
	// if there is a signal change in THR
	if ((Changes & RX2_COLL_PIN)!=0)
    13be:	17 ff       	sbrs	r17, 7
    13c0:	2d c0       	rjmp	.+90     	; 0x141c <__vector_6+0xee>
    13c2:	80 91 df 06 	lds	r24, 0x06DF
	{
		if (RX2_COLL)
    13c6:	37 9b       	sbis	0x06, 7	; 6
    13c8:	0b c0       	rjmp	.+22     	; 0x13e0 <__vector_6+0xb2>
		{
			RX_raw[1][RXChannel_THR]=TCNT1_TEMP;
    13ca:	d0 93 fd 07 	sts	0x07FD, r29
    13ce:	c0 93 fc 07 	sts	0x07FC, r28
			
			if (Config.IsESCCalibration==ESCCalibration_ON)
    13d2:	81 30       	cpi	r24, 0x01	; 1
    13d4:	19 f5       	brne	.+70     	; 0x141c <__vector_6+0xee>
			{ 
				M1=1;M2=1;M3=1;M4=1;
    13d6:	46 9a       	sbi	0x08, 6	; 8
    13d8:	44 9a       	sbi	0x08, 4	; 8
    13da:	42 9a       	sbi	0x08, 2	; 8
    13dc:	43 9a       	sbi	0x08, 3	; 8
    13de:	1e c0       	rjmp	.+60     	; 0x141c <__vector_6+0xee>
			}
		}
		else
		{
			if ((Config.IsESCCalibration==ESCCalibration_ON) && (IS_TX2_GOOD) && (!IS_SYS_ACT_DISARM))
    13e0:	81 30       	cpi	r24, 0x01	; 1
    13e2:	61 f4       	brne	.+24     	; 0x13fc <__vector_6+0xce>
    13e4:	80 91 c5 07 	lds	r24, 0x07C5
    13e8:	80 7f       	andi	r24, 0xF0	; 240
    13ea:	41 f4       	brne	.+16     	; 0x13fc <__vector_6+0xce>
    13ec:	80 91 3b 05 	lds	r24, 0x053B
    13f0:	81 fd       	sbrc	r24, 1
    13f2:	04 c0       	rjmp	.+8      	; 0x13fc <__vector_6+0xce>
			{
				M1=0;M2=0;M3=0;M4=0;
    13f4:	46 98       	cbi	0x08, 6	; 8
    13f6:	44 98       	cbi	0x08, 4	; 8
    13f8:	42 98       	cbi	0x08, 2	; 8
    13fa:	43 98       	cbi	0x08, 3	; 8
			}
				
			CalculateSignalLength2 (RXChannel_THR);
    13fc:	83 e0       	ldi	r24, 0x03	; 3
    13fe:	0e 94 ff 24 	call	0x49fe	; 0x49fe <CalculateSignalLength2>
			RX2_LastValidSignal_timestamp = TCNT1_X;
    1402:	80 91 4e 06 	lds	r24, 0x064E
    1406:	90 91 4f 06 	lds	r25, 0x064F
    140a:	90 93 e2 07 	sts	0x07E2, r25
    140e:	80 93 e1 07 	sts	0x07E1, r24
			RX_Good = TX2_CONNECTED_ERR;  // CLR bit 5 ---  Status = OK
    1412:	80 91 c5 07 	lds	r24, 0x07C5
    1416:	8f 72       	andi	r24, 0x2F	; 47
    1418:	80 93 c5 07 	sts	0x07C5, r24
		}	
	}
	// if there is a signal change in YAW
	if ((Changes & RX2_YAW_PIN) !=0)
    141c:	01 ff       	sbrs	r16, 1
    141e:	0b c0       	rjmp	.+22     	; 0x1436 <__vector_6+0x108>
	{
		if (RX2_YAW)
    1420:	86 b1       	in	r24, 0x06	; 6
    1422:	81 ff       	sbrs	r24, 1
    1424:	05 c0       	rjmp	.+10     	; 0x1430 <__vector_6+0x102>
		{
			RX_raw[1][RXChannel_RUD]=TCNT1_TEMP;
    1426:	d0 93 fb 07 	sts	0x07FB, r29
    142a:	c0 93 fa 07 	sts	0x07FA, r28
    142e:	03 c0       	rjmp	.+6      	; 0x1436 <__vector_6+0x108>
		}
		else
		{
			CalculateSignalLength2 (RXChannel_RUD);
    1430:	82 e0       	ldi	r24, 0x02	; 2
    1432:	0e 94 ff 24 	call	0x49fe	; 0x49fe <CalculateSignalLength2>
			
		}	
	}
	
}
    1436:	ff 91       	pop	r31
    1438:	ef 91       	pop	r30
    143a:	df 91       	pop	r29
    143c:	cf 91       	pop	r28
    143e:	bf 91       	pop	r27
    1440:	af 91       	pop	r26
    1442:	9f 91       	pop	r25
    1444:	8f 91       	pop	r24
    1446:	7f 91       	pop	r23
    1448:	6f 91       	pop	r22
    144a:	5f 91       	pop	r21
    144c:	4f 91       	pop	r20
    144e:	3f 91       	pop	r19
    1450:	2f 91       	pop	r18
    1452:	1f 91       	pop	r17
    1454:	0f 91       	pop	r16
    1456:	0f 90       	pop	r0
    1458:	0f be       	out	0x3f, r0	; 63
    145a:	0f 90       	pop	r0
    145c:	1f 90       	pop	r1
    145e:	18 95       	reti

00001460 <__vector_2>:

#ifdef PRIMARY_INPUT_RX

__attribute__ ((section(".lowtext")))
ISR (RX1_COLL_vect)
{
    1460:	1f 92       	push	r1
    1462:	0f 92       	push	r0
    1464:	0f b6       	in	r0, 0x3f	; 63
    1466:	0f 92       	push	r0
    1468:	11 24       	eor	r1, r1
    146a:	2f 93       	push	r18
    146c:	3f 93       	push	r19
    146e:	4f 93       	push	r20
    1470:	5f 93       	push	r21
    1472:	6f 93       	push	r22
    1474:	7f 93       	push	r23
    1476:	8f 93       	push	r24
    1478:	9f 93       	push	r25
    147a:	af 93       	push	r26
    147c:	bf 93       	push	r27
    147e:	ef 93       	push	r30
    1480:	ff 93       	push	r31
	if (RX1_COLL)
    1482:	89 b1       	in	r24, 0x09	; 9
    1484:	83 ff       	sbrs	r24, 3
    1486:	09 c0       	rjmp	.+18     	; 0x149a <__vector_2+0x3a>
	{
		RX_raw[0][RXChannel_THR]=TCNT1;
    1488:	80 91 84 00 	lds	r24, 0x0084
    148c:	90 91 85 00 	lds	r25, 0x0085
    1490:	90 93 f3 07 	sts	0x07F3, r25
    1494:	80 93 f2 07 	sts	0x07F2, r24
    1498:	10 c0       	rjmp	.+32     	; 0x14ba <__vector_2+0x5a>

	}
	else
	{
		CalculateSignalLength1(RXChannel_THR);
    149a:	83 e0       	ldi	r24, 0x03	; 3
    149c:	0e 94 d6 24 	call	0x49ac	; 0x49ac <CalculateSignalLength1>
		
		RX1_LastValidSignal_timestamp = TCNT1_X;
    14a0:	80 91 4e 06 	lds	r24, 0x064E
    14a4:	90 91 4f 06 	lds	r25, 0x064F
    14a8:	90 93 e4 07 	sts	0x07E4, r25
    14ac:	80 93 e3 07 	sts	0x07E3, r24
		RX_Good = TX1_CONNECTED_ERR;		// CLR bit 0 ---  Status = OK
    14b0:	80 91 c5 07 	lds	r24, 0x07C5
    14b4:	82 7f       	andi	r24, 0xF2	; 242
    14b6:	80 93 c5 07 	sts	0x07C5, r24
	}
	
}
    14ba:	ff 91       	pop	r31
    14bc:	ef 91       	pop	r30
    14be:	bf 91       	pop	r27
    14c0:	af 91       	pop	r26
    14c2:	9f 91       	pop	r25
    14c4:	8f 91       	pop	r24
    14c6:	7f 91       	pop	r23
    14c8:	6f 91       	pop	r22
    14ca:	5f 91       	pop	r21
    14cc:	4f 91       	pop	r20
    14ce:	3f 91       	pop	r19
    14d0:	2f 91       	pop	r18
    14d2:	0f 90       	pop	r0
    14d4:	0f be       	out	0x3f, r0	; 63
    14d6:	0f 90       	pop	r0
    14d8:	1f 90       	pop	r1
    14da:	18 95       	reti

000014dc <__vector_1>:



__attribute__ ((section(".lowtext")))
ISR (RX1_ROLL_vect)
{
    14dc:	1f 92       	push	r1
    14de:	0f 92       	push	r0
    14e0:	0f b6       	in	r0, 0x3f	; 63
    14e2:	0f 92       	push	r0
    14e4:	11 24       	eor	r1, r1
    14e6:	2f 93       	push	r18
    14e8:	3f 93       	push	r19
    14ea:	4f 93       	push	r20
    14ec:	5f 93       	push	r21
    14ee:	6f 93       	push	r22
    14f0:	7f 93       	push	r23
    14f2:	8f 93       	push	r24
    14f4:	9f 93       	push	r25
    14f6:	af 93       	push	r26
    14f8:	bf 93       	push	r27
    14fa:	ef 93       	push	r30
    14fc:	ff 93       	push	r31
	if (RX1_ROLL)
    14fe:	89 b1       	in	r24, 0x09	; 9
    1500:	82 ff       	sbrs	r24, 2
    1502:	09 c0       	rjmp	.+18     	; 0x1516 <__vector_1+0x3a>
	{
		RX_raw[0][RXChannel_AIL]=TCNT1;
    1504:	80 91 84 00 	lds	r24, 0x0084
    1508:	90 91 85 00 	lds	r25, 0x0085
    150c:	90 93 ed 07 	sts	0x07ED, r25
    1510:	80 93 ec 07 	sts	0x07EC, r24
    1514:	10 c0       	rjmp	.+32     	; 0x1536 <__vector_1+0x5a>
	}
	else
	{
		CalculateSignalLength1(RXChannel_AIL);
    1516:	80 e0       	ldi	r24, 0x00	; 0
    1518:	0e 94 d6 24 	call	0x49ac	; 0x49ac <CalculateSignalLength1>
		
		RX1_LastValidSignal_timestampAux = TCNT1_X;
    151c:	80 91 4e 06 	lds	r24, 0x064E
    1520:	90 91 4f 06 	lds	r25, 0x064F
    1524:	90 93 e6 07 	sts	0x07E6, r25
    1528:	80 93 e5 07 	sts	0x07E5, r24
		RX_Good = TX1_FOUND_ERR;			// CLR bit 1 ---  Status = OK
    152c:	80 91 c5 07 	lds	r24, 0x07C5
    1530:	81 7f       	andi	r24, 0xF1	; 241
    1532:	80 93 c5 07 	sts	0x07C5, r24

		
	}
	
}
    1536:	ff 91       	pop	r31
    1538:	ef 91       	pop	r30
    153a:	bf 91       	pop	r27
    153c:	af 91       	pop	r26
    153e:	9f 91       	pop	r25
    1540:	8f 91       	pop	r24
    1542:	7f 91       	pop	r23
    1544:	6f 91       	pop	r22
    1546:	5f 91       	pop	r21
    1548:	4f 91       	pop	r20
    154a:	3f 91       	pop	r19
    154c:	2f 91       	pop	r18
    154e:	0f 90       	pop	r0
    1550:	0f be       	out	0x3f, r0	; 63
    1552:	0f 90       	pop	r0
    1554:	1f 90       	pop	r1
    1556:	18 95       	reti

00001558 <__vector_7>:


__attribute__ ((section(".lowtext")))
ISR (RX1_PITCH_vect)
{
    1558:	1f 92       	push	r1
    155a:	0f 92       	push	r0
    155c:	0f b6       	in	r0, 0x3f	; 63
    155e:	0f 92       	push	r0
    1560:	11 24       	eor	r1, r1
    1562:	2f 93       	push	r18
    1564:	3f 93       	push	r19
    1566:	4f 93       	push	r20
    1568:	5f 93       	push	r21
    156a:	6f 93       	push	r22
    156c:	7f 93       	push	r23
    156e:	8f 93       	push	r24
    1570:	9f 93       	push	r25
    1572:	af 93       	push	r26
    1574:	bf 93       	push	r27
    1576:	ef 93       	push	r30
    1578:	ff 93       	push	r31
	if (RX1_PITCH)
    157a:	89 b1       	in	r24, 0x09	; 9
    157c:	80 ff       	sbrs	r24, 0
    157e:	09 c0       	rjmp	.+18     	; 0x1592 <__vector_7+0x3a>
	{
		RX_raw[0][RXChannel_ELE]=TCNT1;
    1580:	80 91 84 00 	lds	r24, 0x0084
    1584:	90 91 85 00 	lds	r25, 0x0085
    1588:	90 93 ef 07 	sts	0x07EF, r25
    158c:	80 93 ee 07 	sts	0x07EE, r24
    1590:	03 c0       	rjmp	.+6      	; 0x1598 <__vector_7+0x40>
	}
	else
	{
		CalculateSignalLength1(RXChannel_ELE);
    1592:	81 e0       	ldi	r24, 0x01	; 1
    1594:	0e 94 d6 24 	call	0x49ac	; 0x49ac <CalculateSignalLength1>
	}
}
    1598:	ff 91       	pop	r31
    159a:	ef 91       	pop	r30
    159c:	bf 91       	pop	r27
    159e:	af 91       	pop	r26
    15a0:	9f 91       	pop	r25
    15a2:	8f 91       	pop	r24
    15a4:	7f 91       	pop	r23
    15a6:	6f 91       	pop	r22
    15a8:	5f 91       	pop	r21
    15aa:	4f 91       	pop	r20
    15ac:	3f 91       	pop	r19
    15ae:	2f 91       	pop	r18
    15b0:	0f 90       	pop	r0
    15b2:	0f be       	out	0x3f, r0	; 63
    15b4:	0f 90       	pop	r0
    15b6:	1f 90       	pop	r1
    15b8:	18 95       	reti

000015ba <__vector_3>:

volatile uint16_t LongTime;
volatile uint16_t ShortTime;
__attribute__ ((section(".lowtext")))
ISR (RX1_YAW_vect)
{   
    15ba:	1f 92       	push	r1
    15bc:	0f 92       	push	r0
    15be:	0f b6       	in	r0, 0x3f	; 63
    15c0:	0f 92       	push	r0
    15c2:	11 24       	eor	r1, r1
    15c4:	2f 93       	push	r18
    15c6:	3f 93       	push	r19
    15c8:	4f 93       	push	r20
    15ca:	5f 93       	push	r21
    15cc:	6f 93       	push	r22
    15ce:	7f 93       	push	r23
    15d0:	8f 93       	push	r24
    15d2:	9f 93       	push	r25
    15d4:	af 93       	push	r26
    15d6:	bf 93       	push	r27
    15d8:	ef 93       	push	r30
    15da:	ff 93       	push	r31
	// SONAR IS HERE IN UART MODE
	// SONAR RAW VALUE = RX_Length[0][RXChannel_RUD]
	if ((Config.RX_mode==RX_mode_UARTMode) && (IS_MISC_SENSOR_SONAR_ENABLED==true))
    15dc:	80 91 db 06 	lds	r24, 0x06DB
    15e0:	8f 3f       	cpi	r24, 0xFF	; 255
    15e2:	f9 f4       	brne	.+62     	; 0x1622 <__vector_3+0x68>
    15e4:	80 91 e6 06 	lds	r24, 0x06E6
    15e8:	80 ff       	sbrs	r24, 0
    15ea:	1b c0       	rjmp	.+54     	; 0x1622 <__vector_3+0x68>
	{
		if (RX1_YAW)
    15ec:	83 b1       	in	r24, 0x03	; 3
    15ee:	82 ff       	sbrs	r24, 2
    15f0:	09 c0       	rjmp	.+18     	; 0x1604 <__vector_3+0x4a>
		{
			//ShortTime = TCNT1;
			LongTime = TCNT0_X;
    15f2:	80 91 a6 05 	lds	r24, 0x05A6
    15f6:	90 91 a7 05 	lds	r25, 0x05A7
    15fa:	90 93 eb 07 	sts	0x07EB, r25
    15fe:	80 93 ea 07 	sts	0x07EA, r24
    1602:	1e c0       	rjmp	.+60     	; 0x1640 <__vector_3+0x86>
		}
		else
		{
			RX_Length[0][RXChannel_RUD] = (TCNT0_X - LongTime) ; // * SONAR_TO_cm_Convert_BIG + (TCNT1 - ShortTime) * SONAR_TO_cm_Convert;
    1604:	80 91 a6 05 	lds	r24, 0x05A6
    1608:	90 91 a7 05 	lds	r25, 0x05A7
    160c:	20 91 ea 07 	lds	r18, 0x07EA
    1610:	30 91 eb 07 	lds	r19, 0x07EB
    1614:	82 1b       	sub	r24, r18
    1616:	93 0b       	sbc	r25, r19
    1618:	90 93 bf 05 	sts	0x05BF, r25
    161c:	80 93 be 05 	sts	0x05BE, r24
    1620:	0f c0       	rjmp	.+30     	; 0x1640 <__vector_3+0x86>

	}
	else
	{
		
		if (RX1_YAW)
    1622:	83 b1       	in	r24, 0x03	; 3
    1624:	82 ff       	sbrs	r24, 2
    1626:	09 c0       	rjmp	.+18     	; 0x163a <__vector_3+0x80>
		{
			RX_raw[0][RXChannel_RUD]=TCNT1;
    1628:	80 91 84 00 	lds	r24, 0x0084
    162c:	90 91 85 00 	lds	r25, 0x0085
    1630:	90 93 f1 07 	sts	0x07F1, r25
    1634:	80 93 f0 07 	sts	0x07F0, r24
    1638:	03 c0       	rjmp	.+6      	; 0x1640 <__vector_3+0x86>
		}
		else
		{
			CalculateSignalLength1(RXChannel_RUD);
    163a:	82 e0       	ldi	r24, 0x02	; 2
    163c:	0e 94 d6 24 	call	0x49ac	; 0x49ac <CalculateSignalLength1>
		}
	}	
}
    1640:	ff 91       	pop	r31
    1642:	ef 91       	pop	r30
    1644:	bf 91       	pop	r27
    1646:	af 91       	pop	r26
    1648:	9f 91       	pop	r25
    164a:	8f 91       	pop	r24
    164c:	7f 91       	pop	r23
    164e:	6f 91       	pop	r22
    1650:	5f 91       	pop	r21
    1652:	4f 91       	pop	r20
    1654:	3f 91       	pop	r19
    1656:	2f 91       	pop	r18
    1658:	0f 90       	pop	r0
    165a:	0f be       	out	0x3f, r0	; 63
    165c:	0f 90       	pop	r0
    165e:	1f 90       	pop	r1
    1660:	18 95       	reti

00001662 <__vector_5>:



__attribute__ ((section(".lowtext")))
ISR (RX_AUX_vect)
{
    1662:	1f 92       	push	r1
    1664:	0f 92       	push	r0
    1666:	0f b6       	in	r0, 0x3f	; 63
    1668:	0f 92       	push	r0
    166a:	11 24       	eor	r1, r1
    166c:	2f 93       	push	r18
    166e:	3f 93       	push	r19
    1670:	4f 93       	push	r20
    1672:	5f 93       	push	r21
    1674:	6f 93       	push	r22
    1676:	7f 93       	push	r23
    1678:	8f 93       	push	r24
    167a:	9f 93       	push	r25
    167c:	af 93       	push	r26
    167e:	bf 93       	push	r27
    1680:	ef 93       	push	r30
    1682:	ff 93       	push	r31
	// There is only ONE AUX PORT - usually assigned to Secondary RX 
	if (RX_AUX)
    1684:	83 b1       	in	r24, 0x03	; 3
    1686:	80 ff       	sbrs	r24, 0
    1688:	0c c0       	rjmp	.+24     	; 0x16a2 <__vector_5+0x40>
	{
		RX_raw[1][RXChannel_AUX]=TCNT1;
    168a:	80 91 84 00 	lds	r24, 0x0084
    168e:	90 91 85 00 	lds	r25, 0x0085
    1692:	90 93 ff 07 	sts	0x07FF, r25
    1696:	80 93 fe 07 	sts	0x07FE, r24
		UpdateServo=true;
    169a:	81 e0       	ldi	r24, 0x01	; 1
    169c:	80 93 be 06 	sts	0x06BE, r24
    16a0:	0b c0       	rjmp	.+22     	; 0x16b8 <__vector_5+0x56>
	}
	else
	{
		CalculateSignalLength2(RXChannel_AUX);
    16a2:	84 e0       	ldi	r24, 0x04	; 4
    16a4:	0e 94 ff 24 	call	0x49fe	; 0x49fe <CalculateSignalLength2>
		RX_Length[0][RXChannel_AUX]=RX_Length[1][RXChannel_AUX];
    16a8:	80 91 cc 05 	lds	r24, 0x05CC
    16ac:	90 91 cd 05 	lds	r25, 0x05CD
    16b0:	90 93 c3 05 	sts	0x05C3, r25
    16b4:	80 93 c2 05 	sts	0x05C2, r24
	}

}
    16b8:	ff 91       	pop	r31
    16ba:	ef 91       	pop	r30
    16bc:	bf 91       	pop	r27
    16be:	af 91       	pop	r26
    16c0:	9f 91       	pop	r25
    16c2:	8f 91       	pop	r24
    16c4:	7f 91       	pop	r23
    16c6:	6f 91       	pop	r22
    16c8:	5f 91       	pop	r21
    16ca:	4f 91       	pop	r20
    16cc:	3f 91       	pop	r19
    16ce:	2f 91       	pop	r18
    16d0:	0f 90       	pop	r0
    16d2:	0f be       	out	0x3f, r0	; 63
    16d4:	0f 90       	pop	r0
    16d6:	1f 90       	pop	r1
    16d8:	18 95       	reti

000016da <__ctors_end>:
    16da:	11 24       	eor	r1, r1
    16dc:	1f be       	out	0x3f, r1	; 63
    16de:	cf ef       	ldi	r28, 0xFF	; 255
    16e0:	d8 e0       	ldi	r29, 0x08	; 8
    16e2:	de bf       	out	0x3e, r29	; 62
    16e4:	cd bf       	out	0x3d, r28	; 61

000016e6 <__do_copy_data>:
    16e6:	11 e0       	ldi	r17, 0x01	; 1
    16e8:	a0 e0       	ldi	r26, 0x00	; 0
    16ea:	b1 e0       	ldi	r27, 0x01	; 1
    16ec:	e0 e0       	ldi	r30, 0x00	; 0
    16ee:	f9 e7       	ldi	r31, 0x79	; 121
    16f0:	02 c0       	rjmp	.+4      	; 0x16f6 <__do_copy_data+0x10>
    16f2:	05 90       	lpm	r0, Z+
    16f4:	0d 92       	st	X+, r0
    16f6:	a4 31       	cpi	r26, 0x14	; 20
    16f8:	b1 07       	cpc	r27, r17
    16fa:	d9 f7       	brne	.-10     	; 0x16f2 <__do_copy_data+0xc>

000016fc <__do_clear_bss>:
    16fc:	18 e0       	ldi	r17, 0x08	; 8
    16fe:	a4 e1       	ldi	r26, 0x14	; 20
    1700:	b1 e0       	ldi	r27, 0x01	; 1
    1702:	01 c0       	rjmp	.+2      	; 0x1706 <.do_clear_bss_start>

00001704 <.do_clear_bss_loop>:
    1704:	1d 92       	st	X+, r1

00001706 <.do_clear_bss_start>:
    1706:	a1 31       	cpi	r26, 0x11	; 17
    1708:	b1 07       	cpc	r27, r17
    170a:	e1 f7       	brne	.-8      	; 0x1704 <.do_clear_bss_loop>
    170c:	0e 94 92 18 	call	0x3124	; 0x3124 <main>
    1710:	0c 94 7e 3c 	jmp	0x78fc	; 0x78fc <_exit>

00001714 <__bad_interrupt>:
    1714:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00001718 <Beeper_Beep>:
#include "../Include/Misc.h"
#include "../Include/IO_config.h"


void Beeper_Beep (uint16_t msDuration, uint8_t Times)
{
    1718:	ef 92       	push	r14
    171a:	ff 92       	push	r15
    171c:	0f 93       	push	r16
    171e:	1f 93       	push	r17
    1720:	cf 93       	push	r28
    1722:	df 93       	push	r29
    1724:	7c 01       	movw	r14, r24
	
	//bool CurrentBuzzer_Status = Buzzer;
	
	for (int i=0; i< Times; ++i)
    1726:	00 e0       	ldi	r16, 0x00	; 0
    1728:	10 e0       	ldi	r17, 0x00	; 0
    172a:	c6 2f       	mov	r28, r22
    172c:	d0 e0       	ldi	r29, 0x00	; 0
    172e:	0a c0       	rjmp	.+20     	; 0x1744 <Beeper_Beep+0x2c>
	{
		Buzzer = ON;
    1730:	29 9a       	sbi	0x05, 1	; 5
		delay_ms(msDuration);
    1732:	c7 01       	movw	r24, r14
    1734:	0e 94 f0 0e 	call	0x1de0	; 0x1de0 <delay_ms>
		Buzzer = OFF;
    1738:	29 98       	cbi	0x05, 1	; 5
		delay_ms(msDuration);		
    173a:	c7 01       	movw	r24, r14
    173c:	0e 94 f0 0e 	call	0x1de0	; 0x1de0 <delay_ms>
void Beeper_Beep (uint16_t msDuration, uint8_t Times)
{
	
	//bool CurrentBuzzer_Status = Buzzer;
	
	for (int i=0; i< Times; ++i)
    1740:	0f 5f       	subi	r16, 0xFF	; 255
    1742:	1f 4f       	sbci	r17, 0xFF	; 255
    1744:	0c 17       	cp	r16, r28
    1746:	1d 07       	cpc	r17, r29
    1748:	9c f3       	brlt	.-26     	; 0x1730 <Beeper_Beep+0x18>
		delay_ms(msDuration);		
	}
	
	//Buzzer = CurrentBuzzer_Status;
	
}
    174a:	df 91       	pop	r29
    174c:	cf 91       	pop	r28
    174e:	1f 91       	pop	r17
    1750:	0f 91       	pop	r16
    1752:	ff 90       	pop	r15
    1754:	ef 90       	pop	r14
    1756:	08 95       	ret

00001758 <KeyBoard_Init>:

void KeyBoard_Init (void)
{

	// key pins to input
	KEYBOARD_DDR |= ALLKEYS;
    1758:	84 b1       	in	r24, 0x04	; 4
    175a:	80 6f       	ori	r24, 0xF0	; 240
    175c:	84 b9       	out	0x04, r24	; 4

	
	// pull up resistors on
	KEYBOARD_PORT |= ALLKEYS;
    175e:	85 b1       	in	r24, 0x05	; 5
    1760:	80 6f       	ori	r24, 0xF0	; 240
    1762:	85 b9       	out	0x05, r24	; 5
	
}
    1764:	08 95       	ret

00001766 <Keyboard_Read>:

uint16_t TCNT_X_snapshot3=0;
uint8_t Keyboard_Read()
{
    1766:	cf 93       	push	r28
    1768:	df 93       	push	r29
	uint8_t keys = ~KEYBOARD_PIN & ALLKEYS;
    176a:	c3 b1       	in	r28, 0x03	; 3
    176c:	c0 95       	com	r28
    176e:	c0 7f       	andi	r28, 0xF0	; 240
	uint8_t newkeys = keys & ~lastKeys; // always equal to ZERO  for repeated buttons.
    1770:	d0 91 ab 05 	lds	r29, 0x05AB
	_keyrepeat = KEYBOARD_NO_REPEAT;
    1774:	10 92 b9 05 	sts	0x05B9, r1
	if (keys !=0) // if any key pressed even repeated.
    1778:	cc 23       	and	r28, r28
    177a:	21 f1       	breq	.+72     	; 0x17c4 <Keyboard_Read+0x5e>
	{
		if (IsArmed==true) Disarm(); // this is for your own safety.
    177c:	80 91 92 07 	lds	r24, 0x0792
    1780:	81 30       	cpi	r24, 0x01	; 1
    1782:	11 f4       	brne	.+4      	; 0x1788 <Keyboard_Read+0x22>
    1784:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <Disarm>
		
		if ((lastKeys!=keys))
    1788:	80 91 ab 05 	lds	r24, 0x05AB
    178c:	8c 17       	cp	r24, r28
    178e:	59 f0       	breq	.+22     	; 0x17a6 <Keyboard_Read+0x40>
		{	// Reset Timer if not the same key.
			TCNT_X_snapshot3 = TCNT1_X+300;
    1790:	80 91 4e 06 	lds	r24, 0x064E
    1794:	90 91 4f 06 	lds	r25, 0x064F
    1798:	84 5d       	subi	r24, 0xD4	; 212
    179a:	9e 4f       	sbci	r25, 0xFE	; 254
    179c:	90 93 15 01 	sts	0x0115, r25
    17a0:	80 93 14 01 	sts	0x0114, r24
    17a4:	0f c0       	rjmp	.+30     	; 0x17c4 <Keyboard_Read+0x5e>
		}
		else
		{	// Count to measure the key press duration.
			if ((TCNT_X_snapshot3 < TCNT1_X)) // some racing condition might happen here but not a problem we  dont need an atomic read for UI btn click.
    17a6:	20 91 4e 06 	lds	r18, 0x064E
    17aa:	30 91 4f 06 	lds	r19, 0x064F
    17ae:	40 91 14 01 	lds	r20, 0x0114
    17b2:	50 91 15 01 	lds	r21, 0x0115
    17b6:	42 17       	cp	r20, r18
    17b8:	53 07       	cpc	r21, r19
    17ba:	20 f4       	brcc	.+8      	; 0x17c4 <Keyboard_Read+0x5e>
			{
				_keyrepeat = KEYBOARD_REPEAT;
    17bc:	91 e0       	ldi	r25, 0x01	; 1
    17be:	90 93 b9 05 	sts	0x05B9, r25
				return keys; // re-press keys and set the repeated flag for more GUI handling.
    17c2:	05 c0       	rjmp	.+10     	; 0x17ce <Keyboard_Read+0x68>

uint16_t TCNT_X_snapshot3=0;
uint8_t Keyboard_Read()
{
	uint8_t keys = ~KEYBOARD_PIN & ALLKEYS;
	uint8_t newkeys = keys & ~lastKeys; // always equal to ZERO  for repeated buttons.
    17c4:	8d 2f       	mov	r24, r29
    17c6:	80 95       	com	r24
				_keyrepeat = KEYBOARD_REPEAT;
				return keys; // re-press keys and set the repeated flag for more GUI handling.
			}
		}
	}	
	lastKeys = keys;
    17c8:	c0 93 ab 05 	sts	0x05AB, r28
	return newkeys;
    17cc:	8c 23       	and	r24, r28
}
    17ce:	df 91       	pop	r29
    17d0:	cf 91       	pop	r28
    17d2:	08 95       	ret

000017d4 <Keyboard_State>:


inline uint8_t Keyboard_State()
{
	return lastKeys;
}
    17d4:	80 91 ab 05 	lds	r24, 0x05AB
    17d8:	08 95       	ret

000017da <sendData>:
	//LCD_CS = 1;
//}

static void sendData(uint8_t data, uint8_t CommandorData)
{
	LCD_CS = 0;
    17da:	5d 98       	cbi	0x0b, 5	; 11
	LCD_A0 = CommandorData;
    17dc:	67 95       	ror	r22
    17de:	66 27       	eor	r22, r22
    17e0:	67 95       	ror	r22
    17e2:	9b b1       	in	r25, 0x0b	; 11
    17e4:	9f 77       	andi	r25, 0x7F	; 127
    17e6:	96 2b       	or	r25, r22
    17e8:	9b b9       	out	0x0b, r25	; 11
    17ea:	98 e0       	ldi	r25, 0x08	; 8

static void sendByte(uint8_t byte)
{
	for (uint8_t i = 8; i; i--)
	{
		LCD_SCL = 0;
    17ec:	5c 98       	cbi	0x0b, 4	; 11
		
		if (byte & 0x80) // read MSB [& b10000000]
    17ee:	87 ff       	sbrs	r24, 7
    17f0:	02 c0       	rjmp	.+4      	; 0x17f6 <sendData+0x1c>
			LCD_SDA = 1;
    17f2:	59 9a       	sbi	0x0b, 1	; 11
    17f4:	01 c0       	rjmp	.+2      	; 0x17f8 <sendData+0x1e>
		else
			LCD_SDA = 0;
    17f6:	59 98       	cbi	0x0b, 1	; 11
		
		LCD_SCL = 1;
    17f8:	5c 9a       	sbi	0x0b, 4	; 11
    17fa:	91 50       	subi	r25, 0x01	; 1
static uint8_t _curx, _cury;
static fontdescriptor_t _font;

static void sendByte(uint8_t byte)
{
	for (uint8_t i = 8; i; i--)
    17fc:	11 f0       	breq	.+4      	; 0x1802 <sendData+0x28>
			LCD_SDA = 1;
		else
			LCD_SDA = 0;
		
		LCD_SCL = 1;
		byte <<= 1;
    17fe:	88 0f       	add	r24, r24
    1800:	f5 cf       	rjmp	.-22     	; 0x17ec <sendData+0x12>
static void sendData(uint8_t data, uint8_t CommandorData)
{
	LCD_CS = 0;
	LCD_A0 = CommandorData;
	sendByte(data);
	LCD_CS = 1;
    1802:	5d 9a       	sbi	0x0b, 5	; 11
}
    1804:	08 95       	ret

00001806 <LCD_SetPos>:
	offset %= sizeof(_screen);
}

void LCD_SetPos(uint8_t line, uint8_t column)
{
	_curx = column % LCDWIDTH;
    1806:	6f 77       	andi	r22, 0x7F	; 127
    1808:	60 93 1c 01 	sts	0x011C, r22
	_cury = line * 8;
    180c:	88 0f       	add	r24, r24
    180e:	88 0f       	add	r24, r24
    1810:	88 0f       	add	r24, r24
    1812:	80 93 1b 01 	sts	0x011B, r24
}
    1816:	08 95       	ret

00001818 <lcdXY>:

void lcdXY(uint8_t x, uint8_t y)
{
	_curx = x;
    1818:	80 93 1c 01 	sts	0x011C, r24
	_cury = y;
    181c:	60 93 1b 01 	sts	0x011B, r22
}
    1820:	08 95       	ret

00001822 <lcdSetPixel>:

void lcdSetPixel(uint8_t x, uint8_t y, uint8_t on)
{
	static const prog_char masks[8] = {0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80};
	uint8_t *scr = _screen + x + (y / 8 * LCDWIDTH); 
    1822:	26 2f       	mov	r18, r22
    1824:	26 95       	lsr	r18
    1826:	26 95       	lsr	r18
    1828:	26 95       	lsr	r18
    182a:	30 e0       	ldi	r19, 0x00	; 0
    182c:	36 95       	lsr	r19
    182e:	32 2f       	mov	r19, r18
    1830:	22 27       	eor	r18, r18
    1832:	37 95       	ror	r19
    1834:	27 95       	ror	r18
    1836:	28 0f       	add	r18, r24
    1838:	31 1d       	adc	r19, r1
	uint8_t mask = pgm_read_byte(&masks[y % 8]);
    183a:	e6 2f       	mov	r30, r22
    183c:	f0 e0       	ldi	r31, 0x00	; 0
    183e:	e7 70       	andi	r30, 0x07	; 7
    1840:	f0 70       	andi	r31, 0x00	; 0
    1842:	e8 57       	subi	r30, 0x78	; 120
    1844:	ff 4f       	sbci	r31, 0xFF	; 255
    1846:	e4 91       	lpm	r30, Z+
	if ((_flags & REVERSED) ^ !on)
    1848:	91 e0       	ldi	r25, 0x01	; 1
    184a:	41 11       	cpse	r20, r1
    184c:	90 e0       	ldi	r25, 0x00	; 0
    184e:	80 91 1a 01 	lds	r24, 0x011A
    1852:	81 70       	andi	r24, 0x01	; 1
    1854:	d9 01       	movw	r26, r18
    1856:	a3 5e       	subi	r26, 0xE3	; 227
    1858:	be 4f       	sbci	r27, 0xFE	; 254
    185a:	89 17       	cp	r24, r25
    185c:	29 f0       	breq	.+10     	; 0x1868 <lcdSetPixel+0x46>
		*scr = *scr & ~mask;
    185e:	e0 95       	com	r30
    1860:	8c 91       	ld	r24, X
    1862:	e8 23       	and	r30, r24
    1864:	ec 93       	st	X, r30
    1866:	08 95       	ret
	else
		*scr = *scr | mask;
    1868:	8c 91       	ld	r24, X
    186a:	8e 2b       	or	r24, r30
    186c:	8c 93       	st	X, r24
    186e:	08 95       	ret

00001870 <LCD_Line>:
			////
		////e2 = 2 * err;
		////if (e2 > dy) { err += dy; x0 += sx; } /* e_xy + e_x > 0 */
		////if (e2 < dx) { err += dx; y0 += sy; } /* e_xy + e_y < 0 */
	////}
}
    1870:	08 95       	ret

00001872 <LCD_Rectangle>:
	//for (a = y0; a <= y1; a++)
	//{
		//lcdSetPixel(x0, a, color);
		//lcdSetPixel(x1, a, color);
	//}
}
    1872:	08 95       	ret

00001874 <LCD_FillRectangle>:
	//if (x0 > x1) { a = x0; x0 = x1; x1 = a;}
	//if (y0 > y1) { a = y0; y0 = y1; y1 = a;}
	//for (a = y0; a <= y1; a++)
		//for(uint8_t i = x0; i <= x1; i++)
			//lcdSetPixel(i, a, color);
}
    1874:	08 95       	ret

00001876 <LCD_Clear>:
 
void LCD_Clear()
{
	memset(_screen, 0, sizeof(_screen));
    1876:	80 e0       	ldi	r24, 0x00	; 0
    1878:	94 e0       	ldi	r25, 0x04	; 4
    187a:	ed e1       	ldi	r30, 0x1D	; 29
    187c:	f1 e0       	ldi	r31, 0x01	; 1
    187e:	df 01       	movw	r26, r30
    1880:	9c 01       	movw	r18, r24
    1882:	1d 92       	st	X+, r1
    1884:	21 50       	subi	r18, 0x01	; 1
    1886:	30 40       	sbci	r19, 0x00	; 0
    1888:	e1 f7       	brne	.-8      	; 0x1882 <LCD_Clear+0xc>
	LCD_SetPos(0, 0);
    188a:	80 e0       	ldi	r24, 0x00	; 0
    188c:	60 e0       	ldi	r22, 0x00	; 0
    188e:	0e 94 03 0c 	call	0x1806	; 0x1806 <LCD_SetPos>
	_flags = 0;
    1892:	10 92 1a 01 	sts	0x011A, r1
}
    1896:	08 95       	ret

00001898 <lcdWriteSprite_P>:

void lcdWriteSprite_P(PGM_P sprite, uint8_t sizeX, uint8_t sizeY, uint8_t mode)
{
    1898:	8f 92       	push	r8
    189a:	9f 92       	push	r9
    189c:	bf 92       	push	r11
    189e:	cf 92       	push	r12
    18a0:	df 92       	push	r13
    18a2:	ef 92       	push	r14
    18a4:	ff 92       	push	r15
    18a6:	0f 93       	push	r16
    18a8:	1f 93       	push	r17
    18aa:	df 93       	push	r29
    18ac:	cf 93       	push	r28
    18ae:	0f 92       	push	r0
    18b0:	cd b7       	in	r28, 0x3d	; 61
    18b2:	de b7       	in	r29, 0x3e	; 62
    18b4:	4c 01       	movw	r8, r24
    18b6:	e6 2e       	mov	r14, r22
    18b8:	f4 2e       	mov	r15, r20
    18ba:	c2 2e       	mov	r12, r18
	uint8_t b = 0;
	for (uint8_t i = 0; i < sizeX; i++)
    18bc:	dd 24       	eor	r13, r13
	_flags = 0;
}

void lcdWriteSprite_P(PGM_P sprite, uint8_t sizeX, uint8_t sizeY, uint8_t mode)
{
	uint8_t b = 0;
    18be:	bb 24       	eor	r11, r11
			if (j % 8 == 0)
					b = pgm_read_byte(sprite++);
					
			if (mode == ROP_COPY)
			{
				if ((_cury % 8 == 0) && (sizeY - j >= 8))
    18c0:	04 2f       	mov	r16, r20
    18c2:	10 e0       	ldi	r17, 0x00	; 0
}

void lcdWriteSprite_P(PGM_P sprite, uint8_t sizeX, uint8_t sizeY, uint8_t mode)
{
	uint8_t b = 0;
	for (uint8_t i = 0; i < sizeX; i++)
    18c4:	4f c0       	rjmp	.+158    	; 0x1964 <lcdWriteSprite_P+0xcc>
	{
		for (uint8_t j = 0; j < sizeY; j++)
		{
			if (j % 8 == 0)
    18c6:	83 2f       	mov	r24, r19
    18c8:	87 70       	andi	r24, 0x07	; 7
    18ca:	29 f4       	brne	.+10     	; 0x18d6 <lcdWriteSprite_P+0x3e>
					b = pgm_read_byte(sprite++);
    18cc:	f4 01       	movw	r30, r8
    18ce:	08 94       	sec
    18d0:	81 1c       	adc	r8, r1
    18d2:	91 1c       	adc	r9, r1
    18d4:	b4 90       	lpm	r11, Z+
					
			if (mode == ROP_COPY)
    18d6:	cc 20       	and	r12, r12
    18d8:	79 f5       	brne	.+94     	; 0x1938 <lcdWriteSprite_P+0xa0>
			{
				if ((_cury % 8 == 0) && (sizeY - j >= 8))
    18da:	60 91 1b 01 	lds	r22, 0x011B
    18de:	86 2f       	mov	r24, r22
    18e0:	87 70       	andi	r24, 0x07	; 7
    18e2:	19 f5       	brne	.+70     	; 0x192a <lcdWriteSprite_P+0x92>
    18e4:	c8 01       	movw	r24, r16
    18e6:	83 1b       	sub	r24, r19
    18e8:	91 09       	sbc	r25, r1
    18ea:	88 30       	cpi	r24, 0x08	; 8
    18ec:	91 05       	cpc	r25, r1
    18ee:	ec f0       	brlt	.+58     	; 0x192a <lcdWriteSprite_P+0x92>
				{
					lcdSetByte(_curx + i, _cury + j, b);
    18f0:	63 0f       	add	r22, r19
		*scr = *scr | mask;
}

static void lcdSetByte(uint8_t x, uint8_t y, uint8_t b)
{
	uint8_t *scr = _screen + x + (y / 8 * LCDWIDTH); 
    18f2:	66 95       	lsr	r22
    18f4:	66 95       	lsr	r22
    18f6:	66 95       	lsr	r22
    18f8:	a6 2f       	mov	r26, r22
    18fa:	b0 e0       	ldi	r27, 0x00	; 0
    18fc:	b6 95       	lsr	r27
    18fe:	ba 2f       	mov	r27, r26
    1900:	aa 27       	eor	r26, r26
    1902:	b7 95       	ror	r27
    1904:	a7 95       	ror	r26
					
			if (mode == ROP_COPY)
			{
				if ((_cury % 8 == 0) && (sizeY - j >= 8))
				{
					lcdSetByte(_curx + i, _cury + j, b);
    1906:	80 91 1c 01 	lds	r24, 0x011C
    190a:	8d 0d       	add	r24, r13
		*scr = *scr | mask;
}

static void lcdSetByte(uint8_t x, uint8_t y, uint8_t b)
{
	uint8_t *scr = _screen + x + (y / 8 * LCDWIDTH); 
    190c:	a8 0f       	add	r26, r24
    190e:	b1 1d       	adc	r27, r1
	if (_flags & REVERSED)
    1910:	80 91 1a 01 	lds	r24, 0x011A
    1914:	a3 5e       	subi	r26, 0xE3	; 227
    1916:	be 4f       	sbci	r27, 0xFE	; 254
    1918:	80 ff       	sbrs	r24, 0
    191a:	04 c0       	rjmp	.+8      	; 0x1924 <lcdWriteSprite_P+0x8c>
		*scr = ~b;
    191c:	8b 2d       	mov	r24, r11
    191e:	80 95       	com	r24
    1920:	8c 93       	st	X, r24
    1922:	01 c0       	rjmp	.+2      	; 0x1926 <lcdWriteSprite_P+0x8e>
	else
		*scr = b;
    1924:	bc 92       	st	X, r11
			if (mode == ROP_COPY)
			{
				if ((_cury % 8 == 0) && (sizeY - j >= 8))
				{
					lcdSetByte(_curx + i, _cury + j, b);
					j += 7; // just +7 b/c the loop increments anyway
    1926:	39 5f       	subi	r19, 0xF9	; 249
    1928:	17 c0       	rjmp	.+46     	; 0x1958 <lcdWriteSprite_P+0xc0>
				}
				else
					lcdSetPixel(_curx + i, _cury + j, b & 0x01);
    192a:	80 91 1c 01 	lds	r24, 0x011C
    192e:	63 0f       	add	r22, r19
    1930:	4b 2d       	mov	r20, r11
    1932:	41 70       	andi	r20, 0x01	; 1
    1934:	8d 0d       	add	r24, r13
    1936:	0c c0       	rjmp	.+24     	; 0x1950 <lcdWriteSprite_P+0xb8>
			}				
			else if (mode == ROP_PAINT)
    1938:	8c 2d       	mov	r24, r12
    193a:	81 30       	cpi	r24, 0x01	; 1
    193c:	69 f4       	brne	.+26     	; 0x1958 <lcdWriteSprite_P+0xc0>
			{
				if (b & 0x01)
    193e:	b0 fe       	sbrs	r11, 0
    1940:	0b c0       	rjmp	.+22     	; 0x1958 <lcdWriteSprite_P+0xc0>
					lcdSetPixel(_curx + i, _cury + j, 1);
    1942:	80 91 1c 01 	lds	r24, 0x011C
    1946:	60 91 1b 01 	lds	r22, 0x011B
    194a:	63 0f       	add	r22, r19
    194c:	8d 0d       	add	r24, r13
    194e:	41 e0       	ldi	r20, 0x01	; 1
    1950:	39 83       	std	Y+1, r19	; 0x01
    1952:	0e 94 11 0c 	call	0x1822	; 0x1822 <lcdSetPixel>
    1956:	39 81       	ldd	r19, Y+1	; 0x01
			}			
			b >>= 1;
    1958:	b6 94       	lsr	r11
void lcdWriteSprite_P(PGM_P sprite, uint8_t sizeX, uint8_t sizeY, uint8_t mode)
{
	uint8_t b = 0;
	for (uint8_t i = 0; i < sizeX; i++)
	{
		for (uint8_t j = 0; j < sizeY; j++)
    195a:	3f 5f       	subi	r19, 0xFF	; 255
    195c:	3f 15       	cp	r19, r15
    195e:	08 f4       	brcc	.+2      	; 0x1962 <lcdWriteSprite_P+0xca>
    1960:	b2 cf       	rjmp	.-156    	; 0x18c6 <lcdWriteSprite_P+0x2e>
}

void lcdWriteSprite_P(PGM_P sprite, uint8_t sizeX, uint8_t sizeY, uint8_t mode)
{
	uint8_t b = 0;
	for (uint8_t i = 0; i < sizeX; i++)
    1962:	d3 94       	inc	r13
    1964:	de 14       	cp	r13, r14
    1966:	10 f4       	brcc	.+4      	; 0x196c <lcdWriteSprite_P+0xd4>
    1968:	30 e0       	ldi	r19, 0x00	; 0
    196a:	f8 cf       	rjmp	.-16     	; 0x195c <lcdWriteSprite_P+0xc4>
					lcdSetPixel(_curx + i, _cury + j, 1);
			}			
			b >>= 1;
		}
	}	
}
    196c:	0f 90       	pop	r0
    196e:	cf 91       	pop	r28
    1970:	df 91       	pop	r29
    1972:	1f 91       	pop	r17
    1974:	0f 91       	pop	r16
    1976:	ff 90       	pop	r15
    1978:	ef 90       	pop	r14
    197a:	df 90       	pop	r13
    197c:	cf 90       	pop	r12
    197e:	bf 90       	pop	r11
    1980:	9f 90       	pop	r9
    1982:	8f 90       	pop	r8
    1984:	08 95       	ret

00001986 <lcdWriteGlyph_P>:

void lcdWriteGlyph_P(const glyph_t *glyph, uint8_t mode)
{
    1986:	26 2f       	mov	r18, r22
	uint8_t sizeX = pgm_read_byte(&glyph->sizeX);
    1988:	fc 01       	movw	r30, r24
    198a:	64 91       	lpm	r22, Z+
	uint8_t sizeY = pgm_read_byte(&glyph->sizeY);
    198c:	31 96       	adiw	r30, 0x01	; 1
    198e:	44 91       	lpm	r20, Z+
	lcdWriteSprite_P((PGM_P)&glyph->glyph, sizeX, sizeY, mode);
    1990:	02 96       	adiw	r24, 0x02	; 2
    1992:	0e 94 4c 0c 	call	0x1898	; 0x1898 <lcdWriteSprite_P>
}
    1996:	08 95       	ret

00001998 <lcdWriteChar>:

void lcdWriteChar(char c)
{
	if (c == '\n')
    1998:	8a 30       	cpi	r24, 0x0A	; 10
    199a:	51 f4       	brne	.+20     	; 0x19b0 <lcdWriteChar+0x18>
	{
		_cury += _font.sizeY;
    199c:	80 91 1b 01 	lds	r24, 0x011B
    19a0:	90 91 17 01 	lds	r25, 0x0117
    19a4:	89 0f       	add	r24, r25
    19a6:	80 93 1b 01 	sts	0x011B, r24
		_curx = 0;
    19aa:	10 92 1c 01 	sts	0x011C, r1
    19ae:	08 95       	ret
	}
	else
	{
		lcdWriteSprite_P(_font.selector(c), _font.sizeX, _font.sizeY, 0);
    19b0:	e0 91 18 01 	lds	r30, 0x0118
    19b4:	f0 91 19 01 	lds	r31, 0x0119
    19b8:	09 95       	icall
    19ba:	60 91 16 01 	lds	r22, 0x0116
    19be:	40 91 17 01 	lds	r20, 0x0117
    19c2:	20 e0       	ldi	r18, 0x00	; 0
    19c4:	0e 94 4c 0c 	call	0x1898	; 0x1898 <lcdWriteSprite_P>
		_curx += _font.sizeX;
    19c8:	80 91 1c 01 	lds	r24, 0x011C
    19cc:	90 91 16 01 	lds	r25, 0x0116
    19d0:	89 0f       	add	r24, r25
    19d2:	80 93 1c 01 	sts	0x011C, r24
    19d6:	08 95       	ret

000019d8 <LCD_WriteString>:
	}
}

void LCD_WriteString(char *s)
{
    19d8:	ef 92       	push	r14
    19da:	ff 92       	push	r15
    19dc:	cf 93       	push	r28
    19de:	df 93       	push	r29
    19e0:	e8 2e       	mov	r14, r24
    19e2:	e7 01       	movw	r28, r14
    19e4:	7e 01       	movw	r14, r28
    19e6:	f9 2e       	mov	r15, r25
    19e8:	e7 01       	movw	r28, r14
	while (*s)
    19ea:	02 c0       	rjmp	.+4      	; 0x19f0 <LCD_WriteString+0x18>
	{
		lcdWriteChar(*s);
    19ec:	0e 94 cc 0c 	call	0x1998	; 0x1998 <lcdWriteChar>
	}
}

void LCD_WriteString(char *s)
{
	while (*s)
    19f0:	89 91       	ld	r24, Y+
    19f2:	88 23       	and	r24, r24
    19f4:	d9 f7       	brne	.-10     	; 0x19ec <LCD_WriteString+0x14>
	{
		lcdWriteChar(*s);
		s++;
	}		
}
    19f6:	df 91       	pop	r29
    19f8:	cf 91       	pop	r28
    19fa:	ff 90       	pop	r15
    19fc:	ef 90       	pop	r14
    19fe:	08 95       	ret

00001a00 <LCD_WriteString_P>:
}



void LCD_WriteString_P(PGM_P s)
{
    1a00:	cf 93       	push	r28
    1a02:	df 93       	push	r29
    1a04:	ec 01       	movw	r28, r24
	char c;
	while ((c = pgm_read_byte(s++)))
    1a06:	02 c0       	rjmp	.+4      	; 0x1a0c <LCD_WriteString_P+0xc>
		lcdWriteChar(c);
    1a08:	0e 94 cc 0c 	call	0x1998	; 0x1998 <lcdWriteChar>
    1a0c:	fe 01       	movw	r30, r28


void LCD_WriteString_P(PGM_P s)
{
	char c;
	while ((c = pgm_read_byte(s++)))
    1a0e:	21 96       	adiw	r28, 0x01	; 1
    1a10:	84 91       	lpm	r24, Z+
    1a12:	88 23       	and	r24, r24
    1a14:	c9 f7       	brne	.-14     	; 0x1a08 <LCD_WriteString_P+0x8>
		lcdWriteChar(c);
}
    1a16:	df 91       	pop	r29
    1a18:	cf 91       	pop	r28
    1a1a:	08 95       	ret

00001a1c <lcdReverse>:
	lcdReverse(0);
}


void lcdReverse(uint8_t reversed)
{
    1a1c:	90 91 1a 01 	lds	r25, 0x011A
	if (reversed)
    1a20:	88 23       	and	r24, r24
    1a22:	11 f0       	breq	.+4      	; 0x1a28 <lcdReverse+0xc>
		_flags |= REVERSED;
    1a24:	91 60       	ori	r25, 0x01	; 1
    1a26:	01 c0       	rjmp	.+2      	; 0x1a2a <lcdReverse+0xe>
	else
		_flags &= ~REVERSED;
    1a28:	9e 7f       	andi	r25, 0xFE	; 254
    1a2a:	90 93 1a 01 	sts	0x011A, r25
    1a2e:	08 95       	ret

00001a30 <LCD_WriteStringex>:
}



void LCD_WriteStringex(uint8_t x, uint8_t y, char *str, BOOL LCDReverse)
{
    1a30:	ef 92       	push	r14
    1a32:	ff 92       	push	r15
    1a34:	0f 93       	push	r16
    1a36:	1f 93       	push	r17
    1a38:	df 93       	push	r29
    1a3a:	cf 93       	push	r28
    1a3c:	00 d0       	rcall	.+0      	; 0x1a3e <LCD_WriteStringex+0xe>
    1a3e:	0f 92       	push	r0
    1a40:	cd b7       	in	r28, 0x3d	; 61
    1a42:	de b7       	in	r29, 0x3e	; 62
    1a44:	18 2f       	mov	r17, r24
    1a46:	82 2f       	mov	r24, r18
	lcdReverse(LCDReverse);
    1a48:	4a 83       	std	Y+2, r20	; 0x02
    1a4a:	5b 83       	std	Y+3, r21	; 0x03
    1a4c:	69 83       	std	Y+1, r22	; 0x01
    1a4e:	0e 94 0e 0d 	call	0x1a1c	; 0x1a1c <lcdReverse>
	LCD_SetPos(x, y);
    1a52:	81 2f       	mov	r24, r17
    1a54:	69 81       	ldd	r22, Y+1	; 0x01
    1a56:	0e 94 03 0c 	call	0x1806	; 0x1806 <LCD_SetPos>
    1a5a:	4a 81       	ldd	r20, Y+2	; 0x02
    1a5c:	5b 81       	ldd	r21, Y+3	; 0x03
    1a5e:	8a 01       	movw	r16, r20
	while (*str)
    1a60:	02 c0       	rjmp	.+4      	; 0x1a66 <LCD_WriteStringex+0x36>
	{
		lcdWriteChar(*str);
    1a62:	0e 94 cc 0c 	call	0x1998	; 0x1998 <lcdWriteChar>

void LCD_WriteStringex(uint8_t x, uint8_t y, char *str, BOOL LCDReverse)
{
	lcdReverse(LCDReverse);
	LCD_SetPos(x, y);
	while (*str)
    1a66:	f8 01       	movw	r30, r16
    1a68:	81 91       	ld	r24, Z+
    1a6a:	8f 01       	movw	r16, r30
    1a6c:	88 23       	and	r24, r24
    1a6e:	c9 f7       	brne	.-14     	; 0x1a62 <LCD_WriteStringex+0x32>
	{
		lcdWriteChar(*str);
		str++;
	}		
	lcdReverse(0);
    1a70:	0e 94 0e 0d 	call	0x1a1c	; 0x1a1c <lcdReverse>
}
    1a74:	0f 90       	pop	r0
    1a76:	0f 90       	pop	r0
    1a78:	0f 90       	pop	r0
    1a7a:	cf 91       	pop	r28
    1a7c:	df 91       	pop	r29
    1a7e:	1f 91       	pop	r17
    1a80:	0f 91       	pop	r16
    1a82:	ff 90       	pop	r15
    1a84:	ef 90       	pop	r14
    1a86:	08 95       	ret

00001a88 <LCD_WriteSpace>:
		_flags &= ~REVERSED;
}


void LCD_WriteSpace(uint8_t len)
{
    1a88:	0f 93       	push	r16
    1a8a:	1f 93       	push	r17
    1a8c:	08 2f       	mov	r16, r24
	for (uint8_t i = 0; i < len; i++)
    1a8e:	10 e0       	ldi	r17, 0x00	; 0
    1a90:	04 c0       	rjmp	.+8      	; 0x1a9a <LCD_WriteSpace+0x12>
		lcdWriteChar(32);
    1a92:	80 e2       	ldi	r24, 0x20	; 32
    1a94:	0e 94 cc 0c 	call	0x1998	; 0x1998 <lcdWriteChar>
}


void LCD_WriteSpace(uint8_t len)
{
	for (uint8_t i = 0; i < len; i++)
    1a98:	1f 5f       	subi	r17, 0xFF	; 255
    1a9a:	10 17       	cp	r17, r16
    1a9c:	d0 f3       	brcs	.-12     	; 0x1a92 <LCD_WriteSpace+0xa>
		lcdWriteChar(32);
}
    1a9e:	1f 91       	pop	r17
    1aa0:	0f 91       	pop	r16
    1aa2:	08 95       	ret

00001aa4 <LCD_WritePadded>:

void LCD_WritePadded(char *s, uint8_t len)
{
    1aa4:	0f 93       	push	r16
    1aa6:	1f 93       	push	r17
    1aa8:	df 93       	push	r29
    1aaa:	cf 93       	push	r28
    1aac:	0f 92       	push	r0
    1aae:	cd b7       	in	r28, 0x3d	; 61
    1ab0:	de b7       	in	r29, 0x3e	; 62
    1ab2:	8c 01       	movw	r16, r24
	LCD_WriteString(s);
    1ab4:	69 83       	std	Y+1, r22	; 0x01
    1ab6:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <LCD_WriteString>
	LCD_WriteSpace(len - strlen(s));
    1aba:	f8 01       	movw	r30, r16
    1abc:	01 90       	ld	r0, Z+
    1abe:	00 20       	and	r0, r0
    1ac0:	e9 f7       	brne	.-6      	; 0x1abc <LCD_WritePadded+0x18>
    1ac2:	31 97       	sbiw	r30, 0x01	; 1
    1ac4:	e0 1b       	sub	r30, r16
    1ac6:	f1 0b       	sbc	r31, r17
    1ac8:	69 81       	ldd	r22, Y+1	; 0x01
    1aca:	86 2f       	mov	r24, r22
    1acc:	8e 1b       	sub	r24, r30
    1ace:	0e 94 44 0d 	call	0x1a88	; 0x1a88 <LCD_WriteSpace>
}
    1ad2:	0f 90       	pop	r0
    1ad4:	cf 91       	pop	r28
    1ad6:	df 91       	pop	r29
    1ad8:	1f 91       	pop	r17
    1ada:	0f 91       	pop	r16
    1adc:	08 95       	ret

00001ade <LCD_WritePadded_P>:


void LCD_WritePadded_P(const char *s, uint8_t len)
{
    1ade:	0f 93       	push	r16
    1ae0:	1f 93       	push	r17
    1ae2:	df 93       	push	r29
    1ae4:	cf 93       	push	r28
    1ae6:	0f 92       	push	r0
    1ae8:	cd b7       	in	r28, 0x3d	; 61
    1aea:	de b7       	in	r29, 0x3e	; 62
    1aec:	8c 01       	movw	r16, r24
	LCD_WriteString_P(s);
    1aee:	69 83       	std	Y+1, r22	; 0x01
    1af0:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <LCD_WriteString_P>
	LCD_WriteSpace(len - strlen_P(s));
    1af4:	c8 01       	movw	r24, r16
    1af6:	0e 94 8e 39 	call	0x731c	; 0x731c <strlen_P>
    1afa:	69 81       	ldd	r22, Y+1	; 0x01
    1afc:	68 1b       	sub	r22, r24
    1afe:	86 2f       	mov	r24, r22
    1b00:	0e 94 44 0d 	call	0x1a88	; 0x1a88 <LCD_WriteSpace>
}
    1b04:	0f 90       	pop	r0
    1b06:	cf 91       	pop	r28
    1b08:	df 91       	pop	r29
    1b0a:	1f 91       	pop	r17
    1b0c:	0f 91       	pop	r16
    1b0e:	08 95       	ret

00001b10 <LCD_WriteString_Pex>:
		lcdWriteChar(c);
}


void LCD_WriteString_Pex(uint8_t x, uint8_t y, PGM_P str, uint8_t len, BOOL LCDReverse)
{
    1b10:	ef 92       	push	r14
    1b12:	ff 92       	push	r15
    1b14:	0f 93       	push	r16
    1b16:	1f 93       	push	r17
    1b18:	df 93       	push	r29
    1b1a:	cf 93       	push	r28
    1b1c:	00 d0       	rcall	.+0      	; 0x1b1e <LCD_WriteString_Pex+0xe>
    1b1e:	cd b7       	in	r28, 0x3d	; 61
    1b20:	de b7       	in	r29, 0x3e	; 62
    1b22:	18 2f       	mov	r17, r24
    1b24:	7a 01       	movw	r14, r20
    1b26:	80 2f       	mov	r24, r16
	lcdReverse(LCDReverse);
    1b28:	2a 83       	std	Y+2, r18	; 0x02
    1b2a:	69 83       	std	Y+1, r22	; 0x01
    1b2c:	0e 94 0e 0d 	call	0x1a1c	; 0x1a1c <lcdReverse>
	LCD_SetPos(x, y);
    1b30:	81 2f       	mov	r24, r17
    1b32:	69 81       	ldd	r22, Y+1	; 0x01
    1b34:	0e 94 03 0c 	call	0x1806	; 0x1806 <LCD_SetPos>
	LCD_WritePadded_P(str, len);
    1b38:	c7 01       	movw	r24, r14
    1b3a:	2a 81       	ldd	r18, Y+2	; 0x02
    1b3c:	62 2f       	mov	r22, r18
    1b3e:	0e 94 6f 0d 	call	0x1ade	; 0x1ade <LCD_WritePadded_P>
	lcdReverse(0);
    1b42:	80 e0       	ldi	r24, 0x00	; 0
    1b44:	0e 94 0e 0d 	call	0x1a1c	; 0x1a1c <lcdReverse>
}
    1b48:	0f 90       	pop	r0
    1b4a:	0f 90       	pop	r0
    1b4c:	cf 91       	pop	r28
    1b4e:	df 91       	pop	r29
    1b50:	1f 91       	pop	r17
    1b52:	0f 91       	pop	r16
    1b54:	ff 90       	pop	r15
    1b56:	ef 90       	pop	r14
    1b58:	08 95       	ret

00001b5a <LCD_WriteValue_double_ex>:
	LCD_WriteString_P(s);
	LCD_WriteSpace(len - strlen_P(s));
}

void LCD_WriteValue_double_ex(uint8_t x, uint8_t y, double value, int8_t len, BOOL LCDReverse)
{
    1b5a:	bf 92       	push	r11
    1b5c:	cf 92       	push	r12
    1b5e:	df 92       	push	r13
    1b60:	ef 92       	push	r14
    1b62:	ff 92       	push	r15
    1b64:	0f 93       	push	r16
    1b66:	1f 93       	push	r17
    1b68:	df 93       	push	r29
    1b6a:	cf 93       	push	r28
    1b6c:	cd b7       	in	r28, 0x3d	; 61
    1b6e:	de b7       	in	r29, 0x3e	; 62
    1b70:	62 97       	sbiw	r28, 0x12	; 18
    1b72:	0f b6       	in	r0, 0x3f	; 63
    1b74:	f8 94       	cli
    1b76:	de bf       	out	0x3e, r29	; 62
    1b78:	0f be       	out	0x3f, r0	; 63
    1b7a:	cd bf       	out	0x3d, r28	; 61
    1b7c:	f8 2e       	mov	r15, r24
    1b7e:	b6 2e       	mov	r11, r22
    1b80:	ca 01       	movw	r24, r20
    1b82:	b9 01       	movw	r22, r18
    1b84:	30 2f       	mov	r19, r16
	char s[17];
	dtostrf(value, len-2,2, s);
    1b86:	32 50       	subi	r19, 0x02	; 2
    1b88:	43 2f       	mov	r20, r19
    1b8a:	22 e0       	ldi	r18, 0x02	; 2
    1b8c:	6e 01       	movw	r12, r28
    1b8e:	08 94       	sec
    1b90:	c1 1c       	adc	r12, r1
    1b92:	d1 1c       	adc	r13, r1
    1b94:	86 01       	movw	r16, r12
    1b96:	3a 8b       	std	Y+18, r19	; 0x12
    1b98:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <dtostrf>
	//itoa(value, s, 10);
	lcdReverse(LCDReverse);
    1b9c:	8e 2d       	mov	r24, r14
    1b9e:	0e 94 0e 0d 	call	0x1a1c	; 0x1a1c <lcdReverse>
	LCD_SetPos(x, y);
    1ba2:	8f 2d       	mov	r24, r15
    1ba4:	6b 2d       	mov	r22, r11
    1ba6:	0e 94 03 0c 	call	0x1806	; 0x1806 <LCD_SetPos>
	LCD_WritePadded(s, len-2);
    1baa:	c6 01       	movw	r24, r12
    1bac:	3a 89       	ldd	r19, Y+18	; 0x12
    1bae:	63 2f       	mov	r22, r19
    1bb0:	0e 94 52 0d 	call	0x1aa4	; 0x1aa4 <LCD_WritePadded>
	lcdReverse(0);
    1bb4:	80 e0       	ldi	r24, 0x00	; 0
    1bb6:	0e 94 0e 0d 	call	0x1a1c	; 0x1a1c <lcdReverse>

}
    1bba:	62 96       	adiw	r28, 0x12	; 18
    1bbc:	0f b6       	in	r0, 0x3f	; 63
    1bbe:	f8 94       	cli
    1bc0:	de bf       	out	0x3e, r29	; 62
    1bc2:	0f be       	out	0x3f, r0	; 63
    1bc4:	cd bf       	out	0x3d, r28	; 61
    1bc6:	cf 91       	pop	r28
    1bc8:	df 91       	pop	r29
    1bca:	1f 91       	pop	r17
    1bcc:	0f 91       	pop	r16
    1bce:	ff 90       	pop	r15
    1bd0:	ef 90       	pop	r14
    1bd2:	df 90       	pop	r13
    1bd4:	cf 90       	pop	r12
    1bd6:	bf 90       	pop	r11
    1bd8:	08 95       	ret

00001bda <LCD_WriteValue_double>:
void LCD_WriteValue_double(uint8_t x, uint8_t y, double value,  BOOL LCDReverse)
{
    1bda:	ef 92       	push	r14
    1bdc:	0f 93       	push	r16
    1bde:	e0 2e       	mov	r14, r16
	LCD_WriteValue_double_ex(x,y,value,5,LCDReverse);
    1be0:	05 e0       	ldi	r16, 0x05	; 5
    1be2:	0e 94 ad 0d 	call	0x1b5a	; 0x1b5a <LCD_WriteValue_double_ex>
}
    1be6:	0f 91       	pop	r16
    1be8:	ef 90       	pop	r14
    1bea:	08 95       	ret

00001bec <LCD_WriteValue>:

void LCD_WriteValue(uint8_t x, uint8_t y, int16_t value, uint8_t len, BOOL LCDReverse)
{
    1bec:	df 92       	push	r13
    1bee:	ef 92       	push	r14
    1bf0:	ff 92       	push	r15
    1bf2:	0f 93       	push	r16
    1bf4:	1f 93       	push	r17
    1bf6:	df 93       	push	r29
    1bf8:	cf 93       	push	r28
    1bfa:	cd b7       	in	r28, 0x3d	; 61
    1bfc:	de b7       	in	r29, 0x3e	; 62
    1bfe:	28 97       	sbiw	r28, 0x08	; 8
    1c00:	0f b6       	in	r0, 0x3f	; 63
    1c02:	f8 94       	cli
    1c04:	de bf       	out	0x3e, r29	; 62
    1c06:	0f be       	out	0x3f, r0	; 63
    1c08:	cd bf       	out	0x3d, r28	; 61
    1c0a:	d8 2e       	mov	r13, r24
    1c0c:	16 2f       	mov	r17, r22
	char s[7];
	itoa(value, s, 10);
    1c0e:	ca 01       	movw	r24, r20
    1c10:	7e 01       	movw	r14, r28
    1c12:	08 94       	sec
    1c14:	e1 1c       	adc	r14, r1
    1c16:	f1 1c       	adc	r15, r1
    1c18:	b7 01       	movw	r22, r14
    1c1a:	4a e0       	ldi	r20, 0x0A	; 10
    1c1c:	50 e0       	ldi	r21, 0x00	; 0
    1c1e:	28 87       	std	Y+8, r18	; 0x08
    1c20:	0e 94 ab 39 	call	0x7356	; 0x7356 <itoa>
	lcdReverse(LCDReverse);
    1c24:	80 2f       	mov	r24, r16
    1c26:	0e 94 0e 0d 	call	0x1a1c	; 0x1a1c <lcdReverse>
	LCD_SetPos(x, y);
    1c2a:	8d 2d       	mov	r24, r13
    1c2c:	61 2f       	mov	r22, r17
    1c2e:	0e 94 03 0c 	call	0x1806	; 0x1806 <LCD_SetPos>
	LCD_WritePadded(s, len);
    1c32:	c7 01       	movw	r24, r14
    1c34:	28 85       	ldd	r18, Y+8	; 0x08
    1c36:	62 2f       	mov	r22, r18
    1c38:	0e 94 52 0d 	call	0x1aa4	; 0x1aa4 <LCD_WritePadded>
	lcdReverse(0);
    1c3c:	80 e0       	ldi	r24, 0x00	; 0
    1c3e:	0e 94 0e 0d 	call	0x1a1c	; 0x1a1c <lcdReverse>
}
    1c42:	28 96       	adiw	r28, 0x08	; 8
    1c44:	0f b6       	in	r0, 0x3f	; 63
    1c46:	f8 94       	cli
    1c48:	de bf       	out	0x3e, r29	; 62
    1c4a:	0f be       	out	0x3f, r0	; 63
    1c4c:	cd bf       	out	0x3d, r28	; 61
    1c4e:	cf 91       	pop	r28
    1c50:	df 91       	pop	r29
    1c52:	1f 91       	pop	r17
    1c54:	0f 91       	pop	r16
    1c56:	ff 90       	pop	r15
    1c58:	ef 90       	pop	r14
    1c5a:	df 90       	pop	r13
    1c5c:	08 95       	ret

00001c5e <LCD_Enable>:
}

void LCD_Enable()
{
	// reset timer0 to avoid re-entrant call of ISR b/c it is non blocking
	TCNT0 = 0;
    1c5e:	16 bc       	out	0x26, r1	; 38
	TIFR0 = _BV(TOV0);
    1c60:	81 e0       	ldi	r24, 0x01	; 1
    1c62:	85 bb       	out	0x15, r24	; 21
	TIMSK0 |= _BV(TOIE0);	// enable interrupt on overflow
    1c64:	ee e6       	ldi	r30, 0x6E	; 110
    1c66:	f0 e0       	ldi	r31, 0x00	; 0
    1c68:	80 81       	ld	r24, Z
    1c6a:	81 60       	ori	r24, 0x01	; 1
    1c6c:	80 83       	st	Z, r24
}
    1c6e:	08 95       	ret

00001c70 <LCD_Disable>:

void LCD_Disable()
{
	TIMSK0 &= ~_BV(TOIE0);	// disable overflow interrupt
    1c70:	ee e6       	ldi	r30, 0x6E	; 110
    1c72:	f0 e0       	ldi	r31, 0x00	; 0
    1c74:	80 81       	ld	r24, Z
    1c76:	8e 7f       	andi	r24, 0xFE	; 254
    1c78:	80 83       	st	Z, r24
}
    1c7a:	08 95       	ret

00001c7c <lcdSetContrast>:
	LCD_WritePadded(s, len);
	lcdReverse(0);
}

void lcdSetContrast(uint8_t contrast)
{
    1c7c:	0f 93       	push	r16
    1c7e:	1f 93       	push	r17
    1c80:	cf 93       	push	r28
    1c82:	df 93       	push	r29
    1c84:	08 2f       	mov	r16, r24
	uint8_t t = TIMSK0;
    1c86:	ce e6       	ldi	r28, 0x6E	; 110
    1c88:	d0 e0       	ldi	r29, 0x00	; 0
    1c8a:	18 81       	ld	r17, Y
	LCD_Disable();
    1c8c:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <LCD_Disable>
	sendData(0x81, LCD_COMMAND);
    1c90:	81 e8       	ldi	r24, 0x81	; 129
    1c92:	60 e0       	ldi	r22, 0x00	; 0
    1c94:	0e 94 ed 0b 	call	0x17da	; 0x17da <sendData>
	sendData(contrast & 0x3F, LCD_COMMAND); 
    1c98:	80 2f       	mov	r24, r16
    1c9a:	8f 73       	andi	r24, 0x3F	; 63
    1c9c:	60 e0       	ldi	r22, 0x00	; 0
    1c9e:	0e 94 ed 0b 	call	0x17da	; 0x17da <sendData>
	TIMSK0 = t;
    1ca2:	18 83       	st	Y, r17
}
    1ca4:	df 91       	pop	r29
    1ca6:	cf 91       	pop	r28
    1ca8:	1f 91       	pop	r17
    1caa:	0f 91       	pop	r16
    1cac:	08 95       	ret

00001cae <LCD_SelectFont>:
{
	TIMSK0 &= ~_BV(TOIE0);	// disable overflow interrupt
}

void LCD_SelectFont(const fontdescriptor_t *font)
{
    1cae:	bc 01       	movw	r22, r24
	if (font == NULL)
    1cb0:	00 97       	sbiw	r24, 0x00	; 0
    1cb2:	11 f4       	brne	.+4      	; 0x1cb8 <LCD_SelectFont+0xa>
		font = &font6x8;
    1cb4:	6d e4       	ldi	r22, 0x4D	; 77
    1cb6:	77 e0       	ldi	r23, 0x07	; 7
	memcpy_P(&_font, font, sizeof(_font));
    1cb8:	86 e1       	ldi	r24, 0x16	; 22
    1cba:	91 e0       	ldi	r25, 0x01	; 1
    1cbc:	44 e0       	ldi	r20, 0x04	; 4
    1cbe:	50 e0       	ldi	r21, 0x00	; 0
    1cc0:	0e 94 7e 39 	call	0x72fc	; 0x72fc <memcpy_P>
}
    1cc4:	08 95       	ret

00001cc6 <LCD_Init>:
	0xff // end of array
	*/
};

void LCD_Init()
{
    1cc6:	cf 93       	push	r28
    1cc8:	df 93       	push	r29
	// pins
	LCD_CS_DIR = OUTPUT;
    1cca:	55 9a       	sbi	0x0a, 5	; 10
	LCD_RST_DIR = OUTPUT;
    1ccc:	56 9a       	sbi	0x0a, 6	; 10
	LCD_A0_DIR = OUTPUT;
    1cce:	57 9a       	sbi	0x0a, 7	; 10
	LCD_SCL_DIR = OUTPUT;
    1cd0:	54 9a       	sbi	0x0a, 4	; 10
	LCD_SDA_DIR = OUTPUT;
    1cd2:	51 9a       	sbi	0x0a, 1	; 10

	// init display
	LCD_RST = 0;
    1cd4:	5e 98       	cbi	0x0b, 6	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1cd6:	89 ef       	ldi	r24, 0xF9	; 249
    1cd8:	90 e0       	ldi	r25, 0x00	; 0
    1cda:	01 97       	sbiw	r24, 0x01	; 1
    1cdc:	f1 f7       	brne	.-4      	; 0x1cda <LCD_Init+0x14>
    1cde:	00 c0       	rjmp	.+0      	; 0x1ce0 <LCD_Init+0x1a>
    1ce0:	00 00       	nop
	_delay_ms(1);	// version 0.9.9
	LCD_RST = 1;
    1ce2:	5e 9a       	sbi	0x0b, 6	; 11
    1ce4:	89 ef       	ldi	r24, 0xF9	; 249
    1ce6:	90 e0       	ldi	r25, 0x00	; 0
    1ce8:	01 97       	sbiw	r24, 0x01	; 1
    1cea:	f1 f7       	brne	.-4      	; 0x1ce8 <LCD_Init+0x22>
    1cec:	00 c0       	rjmp	.+0      	; 0x1cee <LCD_Init+0x28>
    1cee:	00 00       	nop
	_delay_ms(1); // version 0.9.9
	
	const unsigned char* ptr = _initSeq;
    1cf0:	cc e7       	ldi	r28, 0x7C	; 124
    1cf2:	d0 e0       	ldi	r29, 0x00	; 0
	uint8_t c;
	while ((c = pgm_read_byte(ptr++)))
    1cf4:	03 c0       	rjmp	.+6      	; 0x1cfc <LCD_Init+0x36>
	{
		sendData(c, LCD_COMMAND);
    1cf6:	60 e0       	ldi	r22, 0x00	; 0
    1cf8:	0e 94 ed 0b 	call	0x17da	; 0x17da <sendData>
    1cfc:	fe 01       	movw	r30, r28
	LCD_RST = 1;
	_delay_ms(1); // version 0.9.9
	
	const unsigned char* ptr = _initSeq;
	uint8_t c;
	while ((c = pgm_read_byte(ptr++)))
    1cfe:	21 96       	adiw	r28, 0x01	; 1
    1d00:	84 91       	lpm	r24, Z+
    1d02:	88 23       	and	r24, r24
    1d04:	c1 f7       	brne	.-16     	; 0x1cf6 <LCD_Init+0x30>
	{
		sendData(c, LCD_COMMAND);
	}	
	LCD_SelectFont(NULL);		// select default font
    1d06:	80 e0       	ldi	r24, 0x00	; 0
    1d08:	90 e0       	ldi	r25, 0x00	; 0
    1d0a:	0e 94 57 0e 	call	0x1cae	; 0x1cae <LCD_SelectFont>
	
	// use timer0 with clk/8 and overflow
	// at 256 as interrupt based output of data bytes
	// ie every 1024us one byte is send to display. whole screen takes about 105ms
	TCCR0B = _BV(CS01);		// clk/8
    1d0e:	82 e0       	ldi	r24, 0x02	; 2
    1d10:	85 bd       	out	0x25, r24	; 37
	LCD_Enable();
    1d12:	0e 94 2f 0e 	call	0x1c5e	; 0x1c5e <LCD_Enable>
}
    1d16:	df 91       	pop	r29
    1d18:	cf 91       	pop	r28
    1d1a:	08 95       	ret

00001d1c <LED_FlashOrangeLED>:
#include "../Include/Misc.h"
#include "../Include/IO_config.h"


void LED_FlashOrangeLED (uint16_t msDuration, uint8_t Times)
{
    1d1c:	cf 92       	push	r12
    1d1e:	df 92       	push	r13
    1d20:	ef 92       	push	r14
    1d22:	ff 92       	push	r15
    1d24:	0f 93       	push	r16
    1d26:	1f 93       	push	r17
    1d28:	df 93       	push	r29
    1d2a:	cf 93       	push	r28
    1d2c:	0f 92       	push	r0
    1d2e:	cd b7       	in	r28, 0x3d	; 61
    1d30:	de b7       	in	r29, 0x3e	; 62
    1d32:	6c 01       	movw	r12, r24
	bool CurrentLED_Status = LED_Orange;
    1d34:	25 b1       	in	r18, 0x05	; 5
    1d36:	26 95       	lsr	r18
    1d38:	26 95       	lsr	r18
    1d3a:	26 95       	lsr	r18
    1d3c:	21 70       	andi	r18, 0x01	; 1
	
	for (int i=0; i< Times; ++i)
    1d3e:	00 e0       	ldi	r16, 0x00	; 0
    1d40:	10 e0       	ldi	r17, 0x00	; 0
    1d42:	e6 2e       	mov	r14, r22
    1d44:	ff 24       	eor	r15, r15
    1d46:	24 c0       	rjmp	.+72     	; 0x1d90 <LED_FlashOrangeLED+0x74>
	{
		LED_Orange = ~LED_Orange;
    1d48:	85 b1       	in	r24, 0x05	; 5
    1d4a:	86 95       	lsr	r24
    1d4c:	86 95       	lsr	r24
    1d4e:	86 95       	lsr	r24
    1d50:	80 95       	com	r24
    1d52:	81 70       	andi	r24, 0x01	; 1
    1d54:	88 0f       	add	r24, r24
    1d56:	88 0f       	add	r24, r24
    1d58:	88 0f       	add	r24, r24
    1d5a:	95 b1       	in	r25, 0x05	; 5
    1d5c:	97 7f       	andi	r25, 0xF7	; 247
    1d5e:	98 2b       	or	r25, r24
    1d60:	95 b9       	out	0x05, r25	; 5
		delay_ms(msDuration);
    1d62:	c6 01       	movw	r24, r12
    1d64:	29 83       	std	Y+1, r18	; 0x01
    1d66:	0e 94 f0 0e 	call	0x1de0	; 0x1de0 <delay_ms>
		LED_Orange = ~LED_Orange;
    1d6a:	85 b1       	in	r24, 0x05	; 5
    1d6c:	86 95       	lsr	r24
    1d6e:	86 95       	lsr	r24
    1d70:	86 95       	lsr	r24
    1d72:	80 95       	com	r24
    1d74:	81 70       	andi	r24, 0x01	; 1
    1d76:	88 0f       	add	r24, r24
    1d78:	88 0f       	add	r24, r24
    1d7a:	88 0f       	add	r24, r24
    1d7c:	95 b1       	in	r25, 0x05	; 5
    1d7e:	97 7f       	andi	r25, 0xF7	; 247
    1d80:	98 2b       	or	r25, r24
    1d82:	95 b9       	out	0x05, r25	; 5
		delay_ms(msDuration);		
    1d84:	c6 01       	movw	r24, r12
    1d86:	0e 94 f0 0e 	call	0x1de0	; 0x1de0 <delay_ms>

void LED_FlashOrangeLED (uint16_t msDuration, uint8_t Times)
{
	bool CurrentLED_Status = LED_Orange;
	
	for (int i=0; i< Times; ++i)
    1d8a:	0f 5f       	subi	r16, 0xFF	; 255
    1d8c:	1f 4f       	sbci	r17, 0xFF	; 255
    1d8e:	29 81       	ldd	r18, Y+1	; 0x01
    1d90:	0e 15       	cp	r16, r14
    1d92:	1f 05       	cpc	r17, r15
    1d94:	cc f2       	brlt	.-78     	; 0x1d48 <LED_FlashOrangeLED+0x2c>
		delay_ms(msDuration);
		LED_Orange = ~LED_Orange;
		delay_ms(msDuration);		
	}
	
	LED_Orange = CurrentLED_Status;
    1d96:	21 70       	andi	r18, 0x01	; 1
    1d98:	22 0f       	add	r18, r18
    1d9a:	22 0f       	add	r18, r18
    1d9c:	22 0f       	add	r18, r18
    1d9e:	85 b1       	in	r24, 0x05	; 5
    1da0:	87 7f       	andi	r24, 0xF7	; 247
    1da2:	82 2b       	or	r24, r18
    1da4:	85 b9       	out	0x05, r24	; 5
	
    1da6:	0f 90       	pop	r0
    1da8:	cf 91       	pop	r28
    1daa:	df 91       	pop	r29
    1dac:	1f 91       	pop	r17
    1dae:	0f 91       	pop	r16
    1db0:	ff 90       	pop	r15
    1db2:	ef 90       	pop	r14
    1db4:	df 90       	pop	r13
    1db6:	cf 90       	pop	r12
    1db8:	08 95       	ret

00001dba <delay_us>:



void delay_us(uint16_t time)            /* time delay for us */
{ 
 while(time--)
    1dba:	0f c0       	rjmp	.+30     	; 0x1dda <delay_us+0x20>
	...
	asm volatile ("NOP"); asm volatile ("NOP"); 
	asm volatile ("NOP"); 
	asm volatile ("NOP"); asm volatile ("NOP"); 
	asm volatile ("NOP"); asm volatile ("NOP"); 
	asm volatile ("NOP"); asm volatile ("NOP"); 
	asm volatile ("NOP"); 
    1dd8:	01 97       	sbiw	r24, 0x01	; 1



void delay_us(uint16_t time)            /* time delay for us */
{ 
 while(time--)
    1dda:	00 97       	sbiw	r24, 0x00	; 0
    1ddc:	79 f7       	brne	.-34     	; 0x1dbc <delay_us+0x2>
	asm volatile ("NOP"); asm volatile ("NOP"); 
	asm volatile ("NOP"); asm volatile ("NOP"); 
	asm volatile ("NOP"); asm volatile ("NOP"); 
	asm volatile ("NOP"); 
 }
}
    1dde:	08 95       	ret

00001de0 <delay_ms>:

void delay_ms(uint16_t time)
{
    1de0:	1f 93       	push	r17
    1de2:	cf 93       	push	r28
    1de4:	df 93       	push	r29
    1de6:	ec 01       	movw	r28, r24
	uint8_t i;
	while(time--)
    1de8:	08 c0       	rjmp	.+16     	; 0x1dfa <delay_ms+0x1a>
    1dea:	1a e0       	ldi	r17, 0x0A	; 10
	{
		for(i=0;i<10;i++) delay_us(100);
    1dec:	84 e6       	ldi	r24, 0x64	; 100
    1dee:	90 e0       	ldi	r25, 0x00	; 0
    1df0:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <delay_us>
    1df4:	11 50       	subi	r17, 0x01	; 1
    1df6:	d1 f7       	brne	.-12     	; 0x1dec <delay_ms+0xc>
    1df8:	21 97       	sbiw	r28, 0x01	; 1
}

void delay_ms(uint16_t time)
{
	uint8_t i;
	while(time--)
    1dfa:	20 97       	sbiw	r28, 0x00	; 0
    1dfc:	b1 f7       	brne	.-20     	; 0x1dea <delay_ms+0xa>
	{
		for(i=0;i<10;i++) delay_us(100);
	}
}
    1dfe:	df 91       	pop	r29
    1e00:	cf 91       	pop	r28
    1e02:	1f 91       	pop	r17
    1e04:	08 95       	ret

00001e06 <Ultrasonic_Init>:
#include "..\Include\Ultrasonic.h"


void Ultrasonic_Init ()
{
	RX_SONAR_TRIGGER_DIR = OUTPUT;
    1e06:	50 9a       	sbi	0x0a, 0	; 10
	RX_SONAR_TRIGGER=HIGH;   // Active LOW
    1e08:	48 9a       	sbi	0x09, 0	; 9
	RX_SONAR_DIR = INPUT;
    1e0a:	22 98       	cbi	0x04, 2	; 4
	
	// enable interrupts
	EICRA  = _BV(ISC20);	// any edge on INT2
    1e0c:	80 e1       	ldi	r24, 0x10	; 16
    1e0e:	80 93 69 00 	sts	0x0069, r24
	EIMSK  = _BV(INT2);	// enable interrupt for INT0, INT1 and INT2
    1e12:	84 e0       	ldi	r24, 0x04	; 4
    1e14:	8d bb       	out	0x1d, r24	; 29
	EIFR   = _BV(INTF2);	// clear interrupts
    1e16:	8c bb       	out	0x1c, r24	; 28
		
	
}
    1e18:	08 95       	ret

00001e1a <Disarm>:
#include "Include/Beeper.h"


void Disarm (void)
{
	IsArmed = false;
    1e1a:	10 92 92 07 	sts	0x0792, r1
	//LED_FlashOrangeLED (LED_SHORT_TOGGLE,4);
	LED_Orange = OFF;
    1e1e:	2b 98       	cbi	0x05, 3	; 5
	
	TCNT1_X_snapshot1 =0; // reset timer
    1e20:	10 92 d5 05 	sts	0x05D5, r1
    1e24:	10 92 d4 05 	sts	0x05D4, r1
	Beeper_Beep(BEEP_SHORT,2);				
    1e28:	86 e4       	ldi	r24, 0x46	; 70
    1e2a:	90 e0       	ldi	r25, 0x00	; 0
    1e2c:	62 e0       	ldi	r22, 0x02	; 2
    1e2e:	0e 94 8c 0b 	call	0x1718	; 0x1718 <Beeper_Beep>
	Menu_LoadPage (PAGE_HOME);
    1e32:	80 e0       	ldi	r24, 0x00	; 0
    1e34:	90 e0       	ldi	r25, 0x00	; 0
    1e36:	0e 94 a1 2d 	call	0x5b42	; 0x5b42 <Menu_LoadPage>
}
    1e3a:	08 95       	ret

00001e3c <Arm>:


void Arm (void)
{
	if ((Config.FrameType == FRAMETYPE_TRICOPTER) && (Config.BoardOrientationMode==QuadFlyingMode_X))
    1e3c:	80 91 e0 06 	lds	r24, 0x06E0
    1e40:	82 30       	cpi	r24, 0x02	; 2
    1e42:	39 f4       	brne	.+14     	; 0x1e52 <Arm+0x16>
    1e44:	80 91 e1 06 	lds	r24, 0x06E1
    1e48:	81 30       	cpi	r24, 0x01	; 1
    1e4a:	19 f4       	brne	.+6      	; 0x1e52 <Arm+0x16>
	{ // NOT VALID CONFIGURATION
		Disarm();
    1e4c:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <Disarm>
		
		return;
    1e50:	08 95       	ret
	}
	
			
	IsArmed = true;
    1e52:	81 e0       	ldi	r24, 0x01	; 1
    1e54:	80 93 92 07 	sts	0x0792, r24
	LED_FlashOrangeLED (LED_SHORT_TOGGLE,4);
    1e58:	8e e1       	ldi	r24, 0x1E	; 30
    1e5a:	90 e0       	ldi	r25, 0x00	; 0
    1e5c:	64 e0       	ldi	r22, 0x04	; 4
    1e5e:	70 e0       	ldi	r23, 0x00	; 0
    1e60:	0e 94 8e 0e 	call	0x1d1c	; 0x1d1c <LED_FlashOrangeLED>
	LED_Orange = ON;
    1e64:	2b 9a       	sbi	0x05, 3	; 5
	Beeper_Beep(BEEP_LONG,1);				
    1e66:	8c eb       	ldi	r24, 0xBC	; 188
    1e68:	92 e0       	ldi	r25, 0x02	; 2
    1e6a:	61 e0       	ldi	r22, 0x01	; 1
    1e6c:	0e 94 8c 0b 	call	0x1718	; 0x1718 <Beeper_Beep>
	
	TCNT1_X_snapshot1 =0; // reset timer
    1e70:	10 92 d5 05 	sts	0x05D5, r1
    1e74:	10 92 d4 05 	sts	0x05D4, r1
	TCNT_X_snapshotAutoDisarm=0;				
    1e78:	10 92 0a 06 	sts	0x060A, r1
    1e7c:	10 92 09 06 	sts	0x0609, r1
	Menu_LoadPage (PAGE_HOME_ARMED);
    1e80:	82 e0       	ldi	r24, 0x02	; 2
    1e82:	90 e0       	ldi	r25, 0x00	; 0
    1e84:	0e 94 a1 2d 	call	0x5b42	; 0x5b42 <Menu_LoadPage>
	
	PID_GyroTerms[PITCH_INDEX].I=0;
    1e88:	80 e0       	ldi	r24, 0x00	; 0
    1e8a:	90 e0       	ldi	r25, 0x00	; 0
    1e8c:	dc 01       	movw	r26, r24
    1e8e:	80 93 58 06 	sts	0x0658, r24
    1e92:	90 93 59 06 	sts	0x0659, r25
    1e96:	a0 93 5a 06 	sts	0x065A, r26
    1e9a:	b0 93 5b 06 	sts	0x065B, r27
	PID_GyroTerms[ROLL_INDEX].I=0;
    1e9e:	80 93 70 06 	sts	0x0670, r24
    1ea2:	90 93 71 06 	sts	0x0671, r25
    1ea6:	a0 93 72 06 	sts	0x0672, r26
    1eaa:	b0 93 73 06 	sts	0x0673, r27
	PID_GyroTerms[YAW_INDEX].I=0;
    1eae:	80 93 88 06 	sts	0x0688, r24
    1eb2:	90 93 89 06 	sts	0x0689, r25
    1eb6:	a0 93 8a 06 	sts	0x068A, r26
    1eba:	b0 93 8b 06 	sts	0x068B, r27
	PID_AccTerms [PITCH_INDEX].I=0;
    1ebe:	80 93 40 05 	sts	0x0540, r24
    1ec2:	90 93 41 05 	sts	0x0541, r25
    1ec6:	a0 93 42 05 	sts	0x0542, r26
    1eca:	b0 93 43 05 	sts	0x0543, r27
	PID_AccTerms [ROLL_INDEX].I=0;
    1ece:	80 93 58 05 	sts	0x0558, r24
    1ed2:	90 93 59 05 	sts	0x0559, r25
    1ed6:	a0 93 5a 05 	sts	0x055A, r26
    1eda:	b0 93 5b 05 	sts	0x055B, r27
	PID_AccTerms [Z_INDEX].I=0;
    1ede:	80 93 70 05 	sts	0x0570, r24
    1ee2:	90 93 71 05 	sts	0x0571, r25
    1ee6:	a0 93 72 05 	sts	0x0572, r26
    1eea:	b0 93 73 05 	sts	0x0573, r27
    1eee:	08 95       	ret

00001ef0 <Set_EEPROM_Default_Config>:
	Save_Config_to_EEPROM();
}

void Set_EEPROM_Default_Config(void)
{
	memcpy_P ( &Config, &defaultConfig, sizeof(config_t));
    1ef0:	89 ed       	ldi	r24, 0xD9	; 217
    1ef2:	96 e0       	ldi	r25, 0x06	; 6
    1ef4:	60 e9       	ldi	r22, 0x90	; 144
    1ef6:	70 e0       	ldi	r23, 0x00	; 0
    1ef8:	49 eb       	ldi	r20, 0xB9	; 185
    1efa:	50 e0       	ldi	r21, 0x00	; 0
    1efc:	0e 94 7e 39 	call	0x72fc	; 0x72fc <memcpy_P>
}
    1f00:	08 95       	ret

00001f02 <eeprom_write_byte_changed>:
	}
}


void eeprom_write_byte_changed( uint8_t * addr, uint8_t value )
{ 
    1f02:	0f 93       	push	r16
    1f04:	1f 93       	push	r17
    1f06:	df 93       	push	r29
    1f08:	cf 93       	push	r28
    1f0a:	0f 92       	push	r0
    1f0c:	cd b7       	in	r28, 0x3d	; 61
    1f0e:	de b7       	in	r29, 0x3e	; 62
    1f10:	8c 01       	movw	r16, r24
	if(eeprom_read_byte(addr) != value)
    1f12:	69 83       	std	Y+1, r22	; 0x01
    1f14:	0e 94 f2 39 	call	0x73e4	; 0x73e4 <__eerd_byte_m324pa>
    1f18:	69 81       	ldd	r22, Y+1	; 0x01
    1f1a:	86 17       	cp	r24, r22
    1f1c:	19 f0       	breq	.+6      	; 0x1f24 <eeprom_write_byte_changed+0x22>
	{
		eeprom_write_byte( addr, value );
    1f1e:	c8 01       	movw	r24, r16
    1f20:	0e 94 fa 39 	call	0x73f4	; 0x73f4 <__eewr_byte_m324pa>
	}
}
    1f24:	0f 90       	pop	r0
    1f26:	cf 91       	pop	r28
    1f28:	df 91       	pop	r29
    1f2a:	1f 91       	pop	r17
    1f2c:	0f 91       	pop	r16
    1f2e:	08 95       	ret

00001f30 <eeprom_write_block_changes>:
	eeprom_write_block_changes( (const void*) &Config, (void*) EEPROM_DATA_START_POS, sizeof(config_t));	//current_config CONFIG_STRUCT
	
}

void eeprom_write_block_changes( const uint8_t * src, void * dest, size_t size )
{ 
    1f30:	cf 92       	push	r12
    1f32:	df 92       	push	r13
    1f34:	ef 92       	push	r14
    1f36:	ff 92       	push	r15
    1f38:	0f 93       	push	r16
    1f3a:	1f 93       	push	r17
    1f3c:	cf 93       	push	r28
    1f3e:	df 93       	push	r29
    1f40:	ec 01       	movw	r28, r24
    1f42:	7b 01       	movw	r14, r22
    1f44:	6a 01       	movw	r12, r20
	size_t len;

	for(len=0;len<size;len++)
    1f46:	00 e0       	ldi	r16, 0x00	; 0
    1f48:	10 e0       	ldi	r17, 0x00	; 0
    1f4a:	08 c0       	rjmp	.+16     	; 0x1f5c <eeprom_write_block_changes+0x2c>
	{
		eeprom_write_byte_changed( dest,  *src );
    1f4c:	c7 01       	movw	r24, r14
    1f4e:	80 0f       	add	r24, r16
    1f50:	91 1f       	adc	r25, r17
    1f52:	69 91       	ld	r22, Y+
    1f54:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <eeprom_write_byte_changed>

void eeprom_write_block_changes( const uint8_t * src, void * dest, size_t size )
{ 
	size_t len;

	for(len=0;len<size;len++)
    1f58:	0f 5f       	subi	r16, 0xFF	; 255
    1f5a:	1f 4f       	sbci	r17, 0xFF	; 255
    1f5c:	0c 15       	cp	r16, r12
    1f5e:	1d 05       	cpc	r17, r13
    1f60:	a8 f3       	brcs	.-22     	; 0x1f4c <eeprom_write_block_changes+0x1c>
		eeprom_write_byte_changed( dest,  *src );

		src++;
		dest++;
	}
}
    1f62:	df 91       	pop	r29
    1f64:	cf 91       	pop	r28
    1f66:	1f 91       	pop	r17
    1f68:	0f 91       	pop	r16
    1f6a:	ff 90       	pop	r15
    1f6c:	ef 90       	pop	r14
    1f6e:	df 90       	pop	r13
    1f70:	cf 90       	pop	r12
    1f72:	08 95       	ret

00001f74 <Load_Config_from_EEPROM>:

void Load_Config_from_EEPROM(void)
{
	// write to eeProm
	
	eeprom_write_block_changes( (const void*) &Config, (void*) EEPROM_DATA_START_POS, sizeof(config_t));	//current_config CONFIG_STRUCT
    1f74:	89 ed       	ldi	r24, 0xD9	; 217
    1f76:	96 e0       	ldi	r25, 0x06	; 6
    1f78:	60 e0       	ldi	r22, 0x00	; 0
    1f7a:	70 e0       	ldi	r23, 0x00	; 0
    1f7c:	49 eb       	ldi	r20, 0xB9	; 185
    1f7e:	50 e0       	ldi	r21, 0x00	; 0
    1f80:	0e 94 98 0f 	call	0x1f30	; 0x1f30 <eeprom_write_block_changes>
	
}
    1f84:	08 95       	ret

00001f86 <Save_Config_to_EEPROM>:
}

void Save_Config_to_EEPROM(void)
{
	// write to eeProm
	cli();
    1f86:	f8 94       	cli
	eeprom_write_block_changes( (const void*) &Config, (void*) EEPROM_DATA_START_POS, sizeof(config_t));	//current_config CONFIG_STRUCT
    1f88:	89 ed       	ldi	r24, 0xD9	; 217
    1f8a:	96 e0       	ldi	r25, 0x06	; 6
    1f8c:	60 e0       	ldi	r22, 0x00	; 0
    1f8e:	70 e0       	ldi	r23, 0x00	; 0
    1f90:	49 eb       	ldi	r20, 0xB9	; 185
    1f92:	50 e0       	ldi	r21, 0x00	; 0
    1f94:	0e 94 98 0f 	call	0x1f30	; 0x1f30 <eeprom_write_block_changes>
	sei();
    1f98:	78 94       	sei
	
	Beeper_Beep(BEEP_LONG,1);	
    1f9a:	8c eb       	ldi	r24, 0xBC	; 188
    1f9c:	92 e0       	ldi	r25, 0x02	; 2
    1f9e:	61 e0       	ldi	r22, 0x01	; 1
    1fa0:	0e 94 8c 0b 	call	0x1718	; 0x1718 <Beeper_Beep>
}
    1fa4:	08 95       	ret

00001fa6 <Save_Default_Config_to_EEPROM>:

void Save_Default_Config_to_EEPROM (void)
{
	
	// copy default config to config.
	Set_EEPROM_Default_Config();
    1fa6:	0e 94 78 0f 	call	0x1ef0	; 0x1ef0 <Set_EEPROM_Default_Config>
    1faa:	ec e4       	ldi	r30, 0x4C	; 76
    1fac:	f7 e0       	ldi	r31, 0x07	; 7
	
	
	// Init values.
	for (uint8_t i = 0; i < RXChannels; i++)
	{
		Config.RX_Mid[0][i] = PWM_MID;
    1fae:	20 ef       	ldi	r18, 0xF0	; 240
    1fb0:	35 e0       	ldi	r19, 0x05	; 5
		Config.RX_Min[0][i] = PWM_LOW;
    1fb2:	80 e6       	ldi	r24, 0x60	; 96
    1fb4:	94 e0       	ldi	r25, 0x04	; 4
	
	
	// Init values.
	for (uint8_t i = 0; i < RXChannels; i++)
	{
		Config.RX_Mid[0][i] = PWM_MID;
    1fb6:	21 93       	st	Z+, r18
    1fb8:	31 93       	st	Z+, r19
		Config.RX_Min[0][i] = PWM_LOW;
    1fba:	93 8b       	std	Z+19, r25	; 0x13
    1fbc:	82 8b       	std	Z+18, r24	; 0x12
		Config.RX_Mid[1][i] = PWM_MID;
    1fbe:	31 87       	std	Z+9, r19	; 0x09
    1fc0:	20 87       	std	Z+8, r18	; 0x08
		Config.RX_Min[1][i] = PWM_LOW;
    1fc2:	95 8f       	std	Z+29, r25	; 0x1d
    1fc4:	84 8f       	std	Z+28, r24	; 0x1c
	// copy default config to config.
	Set_EEPROM_Default_Config();
	
	
	// Init values.
	for (uint8_t i = 0; i < RXChannels; i++)
    1fc6:	47 e0       	ldi	r20, 0x07	; 7
    1fc8:	e6 35       	cpi	r30, 0x56	; 86
    1fca:	f4 07       	cpc	r31, r20
    1fcc:	a1 f7       	brne	.-24     	; 0x1fb6 <Save_Default_Config_to_EEPROM+0x10>
		Config.RX_Mid[1][i] = PWM_MID;
		Config.RX_Min[1][i] = PWM_LOW;
	}	
	
	// write to eeProm
	Save_Config_to_EEPROM();
    1fce:	0e 94 c3 0f 	call	0x1f86	; 0x1f86 <Save_Config_to_EEPROM>
}
    1fd2:	08 95       	ret

00001fd4 <Initial_EEPROM_Config_Load>:


void Initial_EEPROM_Config_Load(void)
{
	// load up last settings from EEPROM
	if(eeprom_read_byte((uint8_t*) EEPROM_DATA_START_POS )!=HEFNYCOPTER2_SIGNATURE)
    1fd4:	80 e0       	ldi	r24, 0x00	; 0
    1fd6:	90 e0       	ldi	r25, 0x00	; 0
    1fd8:	0e 94 f2 39 	call	0x73e4	; 0x73e4 <__eerd_byte_m324pa>
    1fdc:	8e 3f       	cpi	r24, 0xFE	; 254
    1fde:	19 f0       	breq	.+6      	; 0x1fe6 <Initial_EEPROM_Config_Load+0x12>
	{
		Save_Default_Config_to_EEPROM();
    1fe0:	0e 94 d3 0f 	call	0x1fa6	; 0x1fa6 <Save_Default_Config_to_EEPROM>
    1fe4:	08 95       	ret
		
	} else {
		// read eeprom
		eeprom_read_block(&Config, (void*) EEPROM_DATA_START_POS, sizeof(config_t)); 
    1fe6:	89 ed       	ldi	r24, 0xD9	; 217
    1fe8:	96 e0       	ldi	r25, 0x06	; 6
    1fea:	60 e0       	ldi	r22, 0x00	; 0
    1fec:	70 e0       	ldi	r23, 0x00	; 0
    1fee:	49 eb       	ldi	r20, 0xB9	; 185
    1ff0:	50 e0       	ldi	r21, 0x00	; 0
    1ff2:	0e 94 e2 39 	call	0x73c4	; 0x73c4 <__eerd_block_m324pa>
    1ff6:	08 95       	ret

00001ff8 <__vector_15>:
*/

//volatile uint32_t x=0;

ISR(TIMER1_OVF_vect)
{
    1ff8:	1f 92       	push	r1
    1ffa:	0f 92       	push	r0
    1ffc:	0f b6       	in	r0, 0x3f	; 63
    1ffe:	0f 92       	push	r0
    2000:	11 24       	eor	r1, r1
    2002:	8f 93       	push	r24
    2004:	9f 93       	push	r25
	
	TCNT1_X++; // click every 0.0032768 sec [1 sec = 305.17578125 TCNT1_X] overflows every 214.7483648 sec = 3.579 min
    2006:	80 91 4e 06 	lds	r24, 0x064E
    200a:	90 91 4f 06 	lds	r25, 0x064F
    200e:	01 96       	adiw	r24, 0x01	; 1
    2010:	90 93 4f 06 	sts	0x064F, r25
    2014:	80 93 4e 06 	sts	0x064E, r24
	//TCNT1_X_GlobalTimer +=32;  // 0.0032768
}
    2018:	9f 91       	pop	r25
    201a:	8f 91       	pop	r24
    201c:	0f 90       	pop	r0
    201e:	0f be       	out	0x3f, r0	; 63
    2020:	0f 90       	pop	r0
    2022:	1f 90       	pop	r1
    2024:	18 95       	reti

00002026 <__vector_11>:


ISR(TIMER2_OVF_vect)
{
    2026:	1f 92       	push	r1
    2028:	0f 92       	push	r0
    202a:	0f b6       	in	r0, 0x3f	; 63
    202c:	0f 92       	push	r0
    202e:	11 24       	eor	r1, r1
    2030:	8f 93       	push	r24
    2032:	9f 93       	push	r25
	TCNT2_X++; 
    2034:	80 91 a9 05 	lds	r24, 0x05A9
    2038:	90 91 aa 05 	lds	r25, 0x05AA
    203c:	01 96       	adiw	r24, 0x01	; 1
    203e:	90 93 aa 05 	sts	0x05AA, r25
    2042:	80 93 a9 05 	sts	0x05A9, r24
}	
    2046:	9f 91       	pop	r25
    2048:	8f 91       	pop	r24
    204a:	0f 90       	pop	r0
    204c:	0f be       	out	0x3f, r0	; 63
    204e:	0f 90       	pop	r0
    2050:	1f 90       	pop	r1
    2052:	18 95       	reti

00002054 <Timer_Init>:
{
	
	//TIMER ZERO is RESERVED for LCD DISPLAY.	
	
	// Timer1 @20MHz with overflow interrupt
	TCCR1B = _BV(CS10);
    2054:	81 e0       	ldi	r24, 0x01	; 1
    2056:	80 93 81 00 	sts	0x0081, r24
	TIMSK1 = _BV(TOIE1);
    205a:	80 93 6f 00 	sts	0x006F, r24
	TCNT1_X =0;
    205e:	10 92 4f 06 	sts	0x064F, r1
    2062:	10 92 4e 06 	sts	0x064E, r1
			1 0 0		clkT2S/64 (From prescaler)
			1 0 1		clkT2S/128 (From prescaler)
			1 1 0		clkT2S/256 (From prescaler)
			1 1 1		clkT2S/1024 (From prescaler)
	*/
	TCCR2B  = (1 << CS21) | (1 << CS20);	//  div by 32	
    2066:	93 e0       	ldi	r25, 0x03	; 3
    2068:	90 93 b1 00 	sts	0x00B1, r25
	TIMSK2  = _BV(TOIE2); 
    206c:	80 93 70 00 	sts	0x0070, r24
	TIFR2   = 0;
    2070:	17 ba       	out	0x17, r1	; 23
	TCNT2	= 0;		// this overflows every  1.6us x 0xff = 409.6 us,  value tick 1.6us
    2072:	10 92 b2 00 	sts	0x00B2, r1
	TCNT2_X = 0;
    2076:	10 92 aa 05 	sts	0x05AA, r1
    207a:	10 92 a9 05 	sts	0x05A9, r1
	/* IMPORTANT TCNT2 is used completly by motor and is reset during ESC pulse generation so you cannot depend on it for other purpose
	unless it is not time critical and no accuracy is required such as UI delays*/
	// tick: 12.8u  ov:3.2768ms	: TCNT2_X OV:  214.7483648 sec

    207e:	08 95       	ret

00002080 <UART_Init>:
	
}

void UART_Init( unsigned int ubrr)
{
	if (Config.RX_mode==RX_mode_UARTMode)
    2080:	20 91 db 06 	lds	r18, 0x06DB
    2084:	2f 3f       	cpi	r18, 0xFF	; 255
    2086:	61 f4       	brne	.+24     	; 0x20a0 <UART_Init+0x20>
	{
		//memcpy(DisplayBuffer,"STR",3);
		RXIndex=0;
    2088:	10 92 1f 05 	sts	0x051F, r1
		/*Set baud rate */
		UBRR1H = (unsigned char)(ubrr>>8);	
    208c:	90 93 cd 00 	sts	0x00CD, r25
		UBRR1L = (unsigned char)ubrr;
    2090:	80 93 cc 00 	sts	0x00CC, r24
		
		//UCSR1A = (1 << U2X1); // doubling divisor rate;
		// Set frame format to 8 data bits, no parity, 1 stop bit
		UCSR1C = (0<<USBS1)|(1<<UCSZ11)|(1<<UCSZ10);
    2094:	86 e0       	ldi	r24, 0x06	; 6
    2096:	80 93 ca 00 	sts	0x00CA, r24
		// Enable receiver and transmitter
		UCSR1B =  (1<<TXEN1)	// Enable USART TX
    209a:	88 e9       	ldi	r24, 0x98	; 152
    209c:	80 93 c9 00 	sts	0x00C9, r24
    20a0:	08 95       	ret

000020a2 <send_byte>:

void send_byte(uint8_t u8Data)
{

	// Wait if a byte is being transmitted
	while((UCSR1A & (1<<UDRE1)) == 0);
    20a2:	90 91 c8 00 	lds	r25, 0x00C8
    20a6:	95 ff       	sbrs	r25, 5
    20a8:	fc cf       	rjmp	.-8      	; 0x20a2 <send_byte>
	// Transmit data
	/////////delay_ms(10);
	UDR1 = u8Data;
    20aa:	80 93 ce 00 	sts	0x00CE, r24
}
    20ae:	08 95       	ret

000020b0 <Send_Data>:


void Send_Data (void * msg, uint8_t len)
{
    20b0:	ef 92       	push	r14
    20b2:	ff 92       	push	r15
    20b4:	0f 93       	push	r16
    20b6:	1f 93       	push	r17
    20b8:	cf 93       	push	r28
    20ba:	df 93       	push	r29
	
	for (int i=0; i<len;++i)
    20bc:	08 2f       	mov	r16, r24
    20be:	19 2f       	mov	r17, r25
    20c0:	c0 e0       	ldi	r28, 0x00	; 0
    20c2:	d0 e0       	ldi	r29, 0x00	; 0
    20c4:	e6 2e       	mov	r14, r22
    20c6:	ff 24       	eor	r15, r15
    20c8:	06 c0       	rjmp	.+12     	; 0x20d6 <Send_Data+0x26>
	{
		send_byte (((uint8_t *)msg)[i]);
    20ca:	f8 01       	movw	r30, r16
    20cc:	81 91       	ld	r24, Z+
    20ce:	8f 01       	movw	r16, r30
    20d0:	0e 94 51 10 	call	0x20a2	; 0x20a2 <send_byte>


void Send_Data (void * msg, uint8_t len)
{
	
	for (int i=0; i<len;++i)
    20d4:	21 96       	adiw	r28, 0x01	; 1
    20d6:	ce 15       	cp	r28, r14
    20d8:	df 05       	cpc	r29, r15
    20da:	bc f3       	brlt	.-18     	; 0x20ca <Send_Data+0x1a>
	{
		send_byte (((uint8_t *)msg)[i]);
	}
	
	
}
    20dc:	df 91       	pop	r29
    20de:	cf 91       	pop	r28
    20e0:	1f 91       	pop	r17
    20e2:	0f 91       	pop	r16
    20e4:	ff 90       	pop	r15
    20e6:	ef 90       	pop	r14
    20e8:	08 95       	ret

000020ea <ParseCommand>:
}


void ParseCommand ()
{
	if (IsArmed==true)
    20ea:	80 91 92 07 	lds	r24, 0x0792
    20ee:	81 30       	cpi	r24, 0x01	; 1
    20f0:	09 f4       	brne	.+2      	; 0x20f4 <ParseCommand+0xa>
    20f2:	69 c0       	rjmp	.+210    	; 0x21c6 <ParseCommand+0xdc>
    20f4:	80 e0       	ldi	r24, 0x00	; 0
    20f6:	90 e0       	ldi	r25, 0x00	; 0
    20f8:	20 e0       	ldi	r18, 0x00	; 0
		return ;
	}		
	int8_t CRC=0;
	for (int i=0;i < SERIAL_BUFFERSIZE_1; ++i)
	{
		CRC +=RXBuffer[i];
    20fa:	fc 01       	movw	r30, r24
    20fc:	ed 55       	subi	r30, 0x5D	; 93
    20fe:	f8 4f       	sbci	r31, 0xF8	; 248
    2100:	30 81       	ld	r19, Z
    2102:	23 0f       	add	r18, r19
	{
		//Just ignore for safty reasons....some commands generate beeps or flash led that call delay function which will crash your quadcopter if called.
		return ;
	}		
	int8_t CRC=0;
	for (int i=0;i < SERIAL_BUFFERSIZE_1; ++i)
    2104:	01 96       	adiw	r24, 0x01	; 1
    2106:	88 30       	cpi	r24, 0x08	; 8
    2108:	91 05       	cpc	r25, r1
    210a:	b9 f7       	brne	.-18     	; 0x20fa <ParseCommand+0x10>
	{
		CRC +=RXBuffer[i];
	}
	if (CRC == (int8_t)RXBuffer[SERIAL_CRC_OFFSET])
    210c:	80 91 ab 07 	lds	r24, 0x07AB
    2110:	28 17       	cp	r18, r24
    2112:	09 f0       	breq	.+2      	; 0x2116 <ParseCommand+0x2c>
    2114:	58 c0       	rjmp	.+176    	; 0x21c6 <ParseCommand+0xdc>
	{
		switch (RXBuffer[SERIAL_HEADER])
    2116:	80 91 a3 07 	lds	r24, 0x07A3
    211a:	83 34       	cpi	r24, 0x43	; 67
    211c:	21 f0       	breq	.+8      	; 0x2126 <ParseCommand+0x3c>
    211e:	86 35       	cpi	r24, 0x56	; 86
    2120:	09 f0       	breq	.+2      	; 0x2124 <ParseCommand+0x3a>
    2122:	51 c0       	rjmp	.+162    	; 0x21c6 <ParseCommand+0xdc>
    2124:	37 c0       	rjmp	.+110    	; 0x2194 <ParseCommand+0xaa>
		{
			case SERIAL_HEADER_DOCMD:
				switch (RXBuffer[SERIAL_CMD_ID])
    2126:	80 91 a4 07 	lds	r24, 0x07A4
    212a:	85 30       	cpi	r24, 0x05	; 5
    212c:	e9 f0       	breq	.+58     	; 0x2168 <ParseCommand+0x7e>
    212e:	86 30       	cpi	r24, 0x06	; 6
    2130:	30 f4       	brcc	.+12     	; 0x213e <ParseCommand+0x54>
    2132:	81 30       	cpi	r24, 0x01	; 1
    2134:	51 f0       	breq	.+20     	; 0x214a <ParseCommand+0x60>
    2136:	82 30       	cpi	r24, 0x02	; 2
    2138:	09 f0       	breq	.+2      	; 0x213c <ParseCommand+0x52>
    213a:	45 c0       	rjmp	.+138    	; 0x21c6 <ParseCommand+0xdc>
    213c:	0c c0       	rjmp	.+24     	; 0x2156 <ParseCommand+0x6c>
    213e:	86 30       	cpi	r24, 0x06	; 6
    2140:	19 f1       	breq	.+70     	; 0x2188 <ParseCommand+0x9e>
    2142:	87 30       	cpi	r24, 0x07	; 7
    2144:	09 f0       	breq	.+2      	; 0x2148 <ParseCommand+0x5e>
    2146:	3f c0       	rjmp	.+126    	; 0x21c6 <ParseCommand+0xdc>
    2148:	22 c0       	rjmp	.+68     	; 0x218e <ParseCommand+0xa4>
				{
					case SERIAL_CMD_LED_BLINK: // never  call while ARMED .... calling delay function will affect motor speed.
						LED_FlashOrangeLED (LED_SHORT_TOGGLE,4);
    214a:	8e e1       	ldi	r24, 0x1E	; 30
    214c:	90 e0       	ldi	r25, 0x00	; 0
    214e:	64 e0       	ldi	r22, 0x04	; 4
    2150:	0e 94 8e 0e 	call	0x1d1c	; 0x1d1c <LED_FlashOrangeLED>
					break;
    2154:	08 95       	ret
					case SERIAL_CMD_PID_CONFIG:
						Send_Data("C",1);
    2156:	80 e0       	ldi	r24, 0x00	; 0
    2158:	91 e0       	ldi	r25, 0x01	; 1
    215a:	61 e0       	ldi	r22, 0x01	; 1
    215c:	0e 94 58 10 	call	0x20b0	; 0x20b0 <Send_Data>
						Send_Data(&(Config.GyroParams),98);
    2160:	87 ee       	ldi	r24, 0xE7	; 231
    2162:	96 e0       	ldi	r25, 0x06	; 6
    2164:	62 e6       	ldi	r22, 0x62	; 98
    2166:	08 c0       	rjmp	.+16     	; 0x2178 <ParseCommand+0x8e>
						Send_Data("E",1);
					break;
					case SERIAL_CMD_READ_CONFIG: // BAD
						Send_Data("C",1);
    2168:	80 e0       	ldi	r24, 0x00	; 0
    216a:	91 e0       	ldi	r25, 0x01	; 1
    216c:	61 e0       	ldi	r22, 0x01	; 1
    216e:	0e 94 58 10 	call	0x20b0	; 0x20b0 <Send_Data>
						Send_Data(&Config,86);
    2172:	89 ed       	ldi	r24, 0xD9	; 217
    2174:	96 e0       	ldi	r25, 0x06	; 6
    2176:	66 e5       	ldi	r22, 0x56	; 86
    2178:	0e 94 58 10 	call	0x20b0	; 0x20b0 <Send_Data>
						Send_Data("E",1);
    217c:	82 e0       	ldi	r24, 0x02	; 2
    217e:	91 e0       	ldi	r25, 0x01	; 1
    2180:	61 e0       	ldi	r22, 0x01	; 1
    2182:	0e 94 58 10 	call	0x20b0	; 0x20b0 <Send_Data>
					break;
    2186:	08 95       	ret
					case SERIAL_CMD_SAVE_CONFIG:
						Save_Config_to_EEPROM();
    2188:	0e 94 c3 0f 	call	0x1f86	; 0x1f86 <Save_Config_to_EEPROM>
					break;
    218c:	08 95       	ret
					case SERIAL_CMD_CALIBRATE_ACC:
						Sensors_Calibrate();								
    218e:	0e 94 ea 27 	call	0x4fd4	; 0x4fd4 <Sensors_Calibrate>
					break;
    2192:	08 95       	ret
				}
			break;
			case SERIAL_HEADER_SETVALUE:
				//LED_FlashOrangeLED (LED_SHORT_TOGGLE,4);
				memcpy ((void *)&Config + RXBuffer[SERIAL_DATA_OFFSET] + (RXBuffer[SERIAL_DATA_OFFSET+1] * 0xff),(void *) &RXBuffer[SERIAL_DATA_VALUE], (int8_t) RXBuffer[SERIAL_DATA_LENGHT]);
    2194:	80 91 a4 07 	lds	r24, 0x07A4
    2198:	60 91 a5 07 	lds	r22, 0x07A5
    219c:	40 91 a6 07 	lds	r20, 0x07A6
    21a0:	9f ef       	ldi	r25, 0xFF	; 255
    21a2:	69 9f       	mul	r22, r25
    21a4:	b0 01       	movw	r22, r0
    21a6:	11 24       	eor	r1, r1
    21a8:	68 0f       	add	r22, r24
    21aa:	71 1d       	adc	r23, r1
    21ac:	67 52       	subi	r22, 0x27	; 39
    21ae:	79 4f       	sbci	r23, 0xF9	; 249
    21b0:	24 2f       	mov	r18, r20
    21b2:	33 27       	eor	r19, r19
    21b4:	27 fd       	sbrc	r18, 7
    21b6:	30 95       	com	r19
    21b8:	e7 ea       	ldi	r30, 0xA7	; 167
    21ba:	f7 e0       	ldi	r31, 0x07	; 7
    21bc:	cb 01       	movw	r24, r22
    21be:	bf 01       	movw	r22, r30
    21c0:	53 2f       	mov	r21, r19
    21c2:	0e 94 97 39 	call	0x732e	; 0x732e <memcpy>
    21c6:	08 95       	ret

000021c8 <__vector_28>:
  
  
void ParseCommand();

ISR (USART1_RX_vect)
{
    21c8:	1f 92       	push	r1
    21ca:	0f 92       	push	r0
    21cc:	0f b6       	in	r0, 0x3f	; 63
    21ce:	0f 92       	push	r0
    21d0:	11 24       	eor	r1, r1
    21d2:	2f 93       	push	r18
    21d4:	3f 93       	push	r19
    21d6:	4f 93       	push	r20
    21d8:	5f 93       	push	r21
    21da:	6f 93       	push	r22
    21dc:	7f 93       	push	r23
    21de:	8f 93       	push	r24
    21e0:	9f 93       	push	r25
    21e2:	af 93       	push	r26
    21e4:	bf 93       	push	r27
    21e6:	ef 93       	push	r30
    21e8:	ff 93       	push	r31
	 while ( !(UCSR1A & (1<<RXC1))); 
    21ea:	80 91 c8 00 	lds	r24, 0x00C8
    21ee:	87 ff       	sbrs	r24, 7
    21f0:	fc cf       	rjmp	.-8      	; 0x21ea <__vector_28+0x22>
	 RXChar = UDR1;
    21f2:	80 91 ce 00 	lds	r24, 0x00CE
    21f6:	80 93 9e 07 	sts	0x079E, r24
	 
	  if ((c_state!=IDLE) && (TCNT1_X - LastRXTime) > 20) 
    21fa:	80 91 20 05 	lds	r24, 0x0520
    21fe:	88 23       	and	r24, r24
    2200:	99 f0       	breq	.+38     	; 0x2228 <__vector_28+0x60>
    2202:	80 91 4e 06 	lds	r24, 0x064E
    2206:	90 91 4f 06 	lds	r25, 0x064F
    220a:	20 91 9f 07 	lds	r18, 0x079F
    220e:	30 91 a0 07 	lds	r19, 0x07A0
    2212:	82 1b       	sub	r24, r18
    2214:	93 0b       	sbc	r25, r19
    2216:	85 31       	cpi	r24, 0x15	; 21
    2218:	91 05       	cpc	r25, r1
    221a:	30 f0       	brcs	.+12     	; 0x2228 <__vector_28+0x60>
	   {
		   // timeout ..
		   c_state = IDLE;
    221c:	10 92 20 05 	sts	0x0520, r1
		   RXIndex =0;
    2220:	10 92 1f 05 	sts	0x051F, r1
		   DisplayBuffer[4]=0;
    2224:	10 92 98 07 	sts	0x0798, r1
		   //memcpy(DisplayBuffer,"OUT",3);
		   //return ;
	   }
	   RXBuffer[RXIndex]=RXChar;
    2228:	e0 91 1f 05 	lds	r30, 0x051F
    222c:	f0 e0       	ldi	r31, 0x00	; 0
    222e:	80 91 9e 07 	lds	r24, 0x079E
    2232:	ed 55       	subi	r30, 0x5D	; 93
    2234:	f8 4f       	sbci	r31, 0xF8	; 248
    2236:	80 83       	st	Z, r24
	   switch (c_state)
    2238:	80 91 20 05 	lds	r24, 0x0520
    223c:	88 23       	and	r24, r24
    223e:	19 f0       	breq	.+6      	; 0x2246 <__vector_28+0x7e>
    2240:	81 30       	cpi	r24, 0x01	; 1
    2242:	c1 f4       	brne	.+48     	; 0x2274 <__vector_28+0xac>
    2244:	06 c0       	rjmp	.+12     	; 0x2252 <__vector_28+0x8a>
	   {
		   case IDLE:
		   // Waiting for new command
			   RXIndex=0;
    2246:	10 92 1f 05 	sts	0x051F, r1
			   
			   
			   c_state = HEADER_RX;
    224a:	81 e0       	ldi	r24, 0x01	; 1
    224c:	80 93 20 05 	sts	0x0520, r24
    2250:	07 c0       	rjmp	.+14     	; 0x2260 <__vector_28+0x98>
		   break;
		   
		   case HEADER_RX:
		   // Copy Data
				
			    if (RXIndex==SERIAL_BUFFERSIZE_1)
    2252:	80 91 1f 05 	lds	r24, 0x051F
    2256:	88 30       	cpi	r24, 0x08	; 8
    2258:	19 f4       	brne	.+6      	; 0x2260 <__vector_28+0x98>
				{
					ParseCommand();
    225a:	0e 94 75 10 	call	0x20ea	; 0x20ea <ParseCommand>
    225e:	0a c0       	rjmp	.+20     	; 0x2274 <__vector_28+0xac>
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    2260:	f8 94       	cli
				}
				else
				{
					ATOMIC_BLOCK(ATOMIC_FORCEON)
				   {
					 LastRXTime = TCNT1_X;
    2262:	80 91 4e 06 	lds	r24, 0x064E
    2266:	90 91 4f 06 	lds	r25, 0x064F
    226a:	90 93 a0 07 	sts	0x07A0, r25
    226e:	80 93 9f 07 	sts	0x079F, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    2272:	78 94       	sei
				   }
				}								
		   break;
	   }
	
	 RXIndex+=1;
    2274:	80 91 1f 05 	lds	r24, 0x051F
    2278:	8f 5f       	subi	r24, 0xFF	; 255
    227a:	80 93 1f 05 	sts	0x051F, r24
	 if (RXIndex==SERIAL_BUFFERSIZE) 
    227e:	80 91 1f 05 	lds	r24, 0x051F
    2282:	89 30       	cpi	r24, 0x09	; 9
    2284:	21 f4       	brne	.+8      	; 0x228e <__vector_28+0xc6>
	 {
		RXIndex=0;
    2286:	10 92 1f 05 	sts	0x051F, r1
		c_state = IDLE;
    228a:	10 92 20 05 	sts	0x0520, r1
	 }		
}
    228e:	ff 91       	pop	r31
    2290:	ef 91       	pop	r30
    2292:	bf 91       	pop	r27
    2294:	af 91       	pop	r26
    2296:	9f 91       	pop	r25
    2298:	8f 91       	pop	r24
    229a:	7f 91       	pop	r23
    229c:	6f 91       	pop	r22
    229e:	5f 91       	pop	r21
    22a0:	4f 91       	pop	r20
    22a2:	3f 91       	pop	r19
    22a4:	2f 91       	pop	r18
    22a6:	0f 90       	pop	r0
    22a8:	0f be       	out	0x3f, r0	; 63
    22aa:	0f 90       	pop	r0
    22ac:	1f 90       	pop	r1
    22ae:	18 95       	reti

000022b0 <Send_Data_TEST>:
	
	
}

void Send_Data_TEST (void * msg, uint8_t len)
{
    22b0:	ef 92       	push	r14
    22b2:	ff 92       	push	r15
    22b4:	0f 93       	push	r16
    22b6:	1f 93       	push	r17
    22b8:	cf 93       	push	r28
    22ba:	df 93       	push	r29
	for (int i=0; i<len;++i)
    22bc:	08 2f       	mov	r16, r24
    22be:	19 2f       	mov	r17, r25
    22c0:	c0 e0       	ldi	r28, 0x00	; 0
    22c2:	d0 e0       	ldi	r29, 0x00	; 0
    22c4:	e6 2e       	mov	r14, r22
    22c6:	ff 24       	eor	r15, r15
    22c8:	06 c0       	rjmp	.+12     	; 0x22d6 <Send_Data_TEST+0x26>
	{
		send_byte (((uint8_t *)msg)[i]);
    22ca:	f8 01       	movw	r30, r16
    22cc:	81 91       	ld	r24, Z+
    22ce:	8f 01       	movw	r16, r30
    22d0:	0e 94 51 10 	call	0x20a2	; 0x20a2 <send_byte>
	
}

void Send_Data_TEST (void * msg, uint8_t len)
{
	for (int i=0; i<len;++i)
    22d4:	21 96       	adiw	r28, 0x01	; 1
    22d6:	ce 15       	cp	r28, r14
    22d8:	df 05       	cpc	r29, r15
    22da:	bc f3       	brlt	.-18     	; 0x22ca <Send_Data_TEST+0x1a>
	{
		send_byte (((uint8_t *)msg)[i]);
	}
	
    22dc:	df 91       	pop	r29
    22de:	cf 91       	pop	r28
    22e0:	1f 91       	pop	r17
    22e2:	0f 91       	pop	r16
    22e4:	ff 90       	pop	r15
    22e6:	ef 90       	pop	r14
    22e8:	08 95       	ret

000022ea <_font12x16selector>:
	*/
};

static PGM_P _font12x16selector(unsigned char c)
{
	return (PGM_P) _font12x16map + (c - 0x20) * BYTESPERCHAR;
    22ea:	90 e0       	ldi	r25, 0x00	; 0
    22ec:	80 97       	sbiw	r24, 0x20	; 32
    22ee:	9c 01       	movw	r18, r24
    22f0:	22 0f       	add	r18, r18
    22f2:	33 1f       	adc	r19, r19
    22f4:	28 0f       	add	r18, r24
    22f6:	39 1f       	adc	r19, r25
    22f8:	83 e0       	ldi	r24, 0x03	; 3
    22fa:	22 0f       	add	r18, r18
    22fc:	33 1f       	adc	r19, r19
    22fe:	8a 95       	dec	r24
    2300:	e1 f7       	brne	.-8      	; 0x22fa <_font12x16selector+0x10>
    2302:	23 5b       	subi	r18, 0xB3	; 179
    2304:	3e 4f       	sbci	r19, 0xFE	; 254
}
    2306:	c9 01       	movw	r24, r18
    2308:	08 95       	ret

0000230a <_font6x8selector>:
	*/
};

static PGM_P _font6x8selector(unsigned char c)
{
	return (PGM_P) _font6x8map + (c - 0x20) * BYTESPERCHAR;
    230a:	90 e0       	ldi	r25, 0x00	; 0
    230c:	80 97       	sbiw	r24, 0x20	; 32
    230e:	9c 01       	movw	r18, r24
    2310:	22 0f       	add	r18, r18
    2312:	33 1f       	adc	r19, r19
    2314:	28 0f       	add	r18, r24
    2316:	39 1f       	adc	r19, r25
    2318:	22 0f       	add	r18, r18
    231a:	33 1f       	adc	r19, r19
    231c:	2f 5a       	subi	r18, 0xAF	; 175
    231e:	38 4f       	sbci	r19, 0xF8	; 248
}
    2320:	c9 01       	movw	r24, r18
    2322:	08 95       	ret

00002324 <Setup>:
static uint8_t FlyingModesToggle;

void Setup (void)
{
	
	Menu_EnableAllItems();
    2324:	0e 94 06 37 	call	0x6e0c	; 0x6e0c <Menu_EnableAllItems>
	
	Initial_EEPROM_Config_Load();
    2328:	0e 94 ea 0f 	call	0x1fd4	; 0x1fd4 <Initial_EEPROM_Config_Load>
	
	//Config.QuadFlyingMode = QuadFlyingMode_PLUS;
	
	RX_Init();
    232c:	0e 94 24 25 	call	0x4a48	; 0x4a48 <RX_Init>
	if ((Config.RX_mode==RX_mode_UARTMode) && (IS_MISC_SENSOR_SONAR_ENABLED==true))
    2330:	80 91 db 06 	lds	r24, 0x06DB
    2334:	8f 3f       	cpi	r24, 0xFF	; 255
    2336:	31 f4       	brne	.+12     	; 0x2344 <Setup+0x20>
    2338:	80 91 e6 06 	lds	r24, 0x06E6
    233c:	80 ff       	sbrs	r24, 0
    233e:	02 c0       	rjmp	.+4      	; 0x2344 <Setup+0x20>
	{
		Ultrasonic_Init();
    2340:	0e 94 03 0f 	call	0x1e06	; 0x1e06 <Ultrasonic_Init>
	}		
	// Motors
	M1_DIR = OUTPUT;
    2344:	3e 9a       	sbi	0x07, 6	; 7
	M2_DIR = OUTPUT;
    2346:	3c 9a       	sbi	0x07, 4	; 7
	M3_DIR = OUTPUT;
    2348:	3a 9a       	sbi	0x07, 2	; 7
	M4_DIR = OUTPUT;
    234a:	3b 9a       	sbi	0x07, 3	; 7
	M1 = 0;
    234c:	46 98       	cbi	0x08, 6	; 8
	M2 = 0;
    234e:	44 98       	cbi	0x08, 4	; 8
	M3 = 0;
    2350:	42 98       	cbi	0x08, 2	; 8
	M4 = 0;
    2352:	43 98       	cbi	0x08, 3	; 8
	
	Buzzer_DIR = OUTPUT;
    2354:	21 9a       	sbi	0x04, 1	; 4
	LED_Orange_DIR = OUTPUT;
    2356:	23 9a       	sbi	0x04, 3	; 4
	
	
	// Sensors
	V_BAT  = INPUT;
    2358:	13 98       	cbi	0x02, 3	; 2
	
	
	
	// Timers
	TCCR1A = 0;	//Set timer 1 to run at 2.5MHz
    235a:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;
    235e:	10 92 81 00 	sts	0x0081, r1
	TCCR1C = 0;
    2362:	10 92 82 00 	sts	0x0082, r1
	

if (Config.RX_mode==RX_mode_UARTMode)
    2366:	80 91 db 06 	lds	r24, 0x06DB
    236a:	8f 3f       	cpi	r24, 0xFF	; 255
    236c:	21 f4       	brne	.+8      	; 0x2376 <Setup+0x52>
{
	UART_Init(SERIAL_BAUD_RATE); //57600 = 20   115200=10
    236e:	8a e0       	ldi	r24, 0x0A	; 10
    2370:	90 e0       	ldi	r25, 0x00	; 0
    2372:	0e 94 40 10 	call	0x2080	; 0x2080 <UART_Init>
}	



	ADCPort_Init();
    2376:	0e 94 7f 29 	call	0x52fe	; 0x52fe <ADCPort_Init>
	Sensors_Init();
    237a:	0e 94 ab 27 	call	0x4f56	; 0x4f56 <Sensors_Init>
	KeyBoard_Init();
    237e:	0e 94 ac 0b 	call	0x1758	; 0x1758 <KeyBoard_Init>
	Timer_Init();
    2382:	0e 94 2a 10 	call	0x2054	; 0x2054 <Timer_Init>
	
	LCD_Init();
    2386:	0e 94 63 0e 	call	0x1cc6	; 0x1cc6 <LCD_Init>
	LCD_Clear();
    238a:	0e 94 3b 0c 	call	0x1876	; 0x1876 <LCD_Clear>
	
	Menu_MenuInit();
    238e:	0e 94 fe 36 	call	0x6dfc	; 0x6dfc <Menu_MenuInit>
	
		
	
	
	sei();
    2392:	78 94       	sei
	
	delay_ms(30);
    2394:	8e e1       	ldi	r24, 0x1E	; 30
    2396:	90 e0       	ldi	r25, 0x00	; 0
    2398:	0e 94 f0 0e 	call	0x1de0	; 0x1de0 <delay_ms>
    
}
    239c:	08 95       	ret

0000239e <Loop>:
	We are in this loop because the system is not calibrated.
	This is the minimum functionality.
*/
void Loop(void)
{
	RX_CopyLatestReceiverValues(); // update RX_Latest also IS_TXn_GOOD
    239e:	0e 94 5b 26 	call	0x4cb6	; 0x4cb6 <RX_CopyLatestReceiverValues>
	
	if (TCNT_X_snapshot2==0) TCNT_X_snapshot2 = TCNT2_X;
    23a2:	80 91 d6 05 	lds	r24, 0x05D6
    23a6:	90 91 d7 05 	lds	r25, 0x05D7
    23aa:	00 97       	sbiw	r24, 0x00	; 0
    23ac:	41 f4       	brne	.+16     	; 0x23be <Loop+0x20>
    23ae:	80 91 a9 05 	lds	r24, 0x05A9
    23b2:	90 91 aa 05 	lds	r25, 0x05AA
    23b6:	90 93 d7 05 	sts	0x05D7, r25
    23ba:	80 93 d6 05 	sts	0x05D6, r24
	if ( (TCNT2_X- TCNT_X_snapshot2) > LCD_RefreashRate )  
    23be:	80 91 a9 05 	lds	r24, 0x05A9
    23c2:	90 91 aa 05 	lds	r25, 0x05AA
    23c6:	20 91 d6 05 	lds	r18, 0x05D6
    23ca:	30 91 d7 05 	lds	r19, 0x05D7
    23ce:	82 1b       	sub	r24, r18
    23d0:	93 0b       	sbc	r25, r19
    23d2:	8b 30       	cpi	r24, 0x0B	; 11
    23d4:	91 05       	cpc	r25, r1
    23d6:	30 f0       	brcs	.+12     	; 0x23e4 <Loop+0x46>
	{
		Menu_MenuShow();	
    23d8:	0e 94 bb 36 	call	0x6d76	; 0x6d76 <Menu_MenuShow>
		TCNT_X_snapshot2=0;
    23dc:	10 92 d7 05 	sts	0x05D7, r1
    23e0:	10 92 d6 05 	sts	0x05D6, r1
    23e4:	08 95       	ret

000023e6 <LoopESCCalibration>:
}

void LoopESCCalibration (void)
{
	
	Menu_LoadPage(PAGE_HOME_ESC_CALIBRATION);
    23e6:	83 e0       	ldi	r24, 0x03	; 3
    23e8:	0e 94 a1 2d 	call	0x5b42	; 0x5b42 <Menu_LoadPage>
	while (1)
	{
		Loop();
    23ec:	0e 94 cf 11 	call	0x239e	; 0x239e <Loop>
    23f0:	fd cf       	rjmp	.-6      	; 0x23ec <LoopESCCalibration+0x6>

000023f2 <LoopCalibration>:
// Never go to MainLoop "fly loop" unless Sensors & RX is calibrated.
// This loop to protect against any bug that might make the quad start or KB stick click
// as in this case crash is a must.
void LoopCalibration (void)
{
	menuEnabled[PAGE_STABILIZATION] =0;
    23f2:	10 92 b1 07 	sts	0x07B1, r1
	menuEnabled[PAGE_SELF_LEVELING] =0;
    23f6:	10 92 b2 07 	sts	0x07B2, r1
	menuEnabled[PAGE_ALT_HOLD]		=0;
    23fa:	10 92 b3 07 	sts	0x07B3, r1
	menuEnabled[PAGE_MISC_SETTING]  =0;
    23fe:	10 92 b5 07 	sts	0x07B5, r1
	menuEnabled[PAGE_ESC_CALIBRATION]=0; // u cannot make ESC Calibration as sticks are not ready for testing.
    2402:	10 92 ba 07 	sts	0x07BA, r1
		
	while (!(Config.IsCalibrated & CALIBRATED_SENSOR) || !(Config.IsCalibrated & CALIBRATED_Stick_SECONDARY))
    2406:	02 c0       	rjmp	.+4      	; 0x240c <LoopCalibration+0x1a>
	{	
		Loop();
    2408:	0e 94 cf 11 	call	0x239e	; 0x239e <Loop>
	menuEnabled[PAGE_SELF_LEVELING] =0;
	menuEnabled[PAGE_ALT_HOLD]		=0;
	menuEnabled[PAGE_MISC_SETTING]  =0;
	menuEnabled[PAGE_ESC_CALIBRATION]=0; // u cannot make ESC Calibration as sticks are not ready for testing.
		
	while (!(Config.IsCalibrated & CALIBRATED_SENSOR) || !(Config.IsCalibrated & CALIBRATED_Stick_SECONDARY))
    240c:	80 91 da 06 	lds	r24, 0x06DA
    2410:	82 ff       	sbrs	r24, 2
    2412:	fa cf       	rjmp	.-12     	; 0x2408 <LoopCalibration+0x16>
    2414:	81 ff       	sbrs	r24, 1
    2416:	f8 cf       	rjmp	.-16     	; 0x2408 <LoopCalibration+0x16>
	{	
		Loop();
	}
}
    2418:	08 95       	ret

0000241a <HandleSticksForArming>:
// This function is never called if there is a calibration issue.
// called in true section of if (RX_Snapshot[RXChannel_THR] < STICKThrottle_ARMING) 
void HandleSticksForArming (void)
{
	
	if ((UIEnableStickCommands==false) || (ActiveRXIndex!=1) || (!IS_TX2_GOOD)) return ; // you cannot use Primary to Arm and Disarm
    241a:	80 91 d2 05 	lds	r24, 0x05D2
    241e:	88 23       	and	r24, r24
    2420:	09 f4       	brne	.+2      	; 0x2424 <HandleSticksForArming+0xa>
    2422:	6c c1       	rjmp	.+728    	; 0x26fc <HandleSticksForArming+0x2e2>
    2424:	80 91 b8 05 	lds	r24, 0x05B8
    2428:	81 30       	cpi	r24, 0x01	; 1
    242a:	09 f0       	breq	.+2      	; 0x242e <HandleSticksForArming+0x14>
    242c:	67 c1       	rjmp	.+718    	; 0x26fc <HandleSticksForArming+0x2e2>
    242e:	80 91 c5 07 	lds	r24, 0x07C5
    2432:	80 7f       	andi	r24, 0xF0	; 240
    2434:	09 f0       	breq	.+2      	; 0x2438 <HandleSticksForArming+0x1e>
    2436:	62 c1       	rjmp	.+708    	; 0x26fc <HandleSticksForArming+0x2e2>
	SystemErrorType = CLR_SYS_ERR_SIGNAL;
    2438:	80 91 b5 06 	lds	r24, 0x06B5
    243c:	8e 7f       	andi	r24, 0xFE	; 254
    243e:	80 93 b5 06 	sts	0x06B5, r24
	
	if (TCNT1_X_snapshot1==0)  TCNT1_X_snapshot1 = CurrentTCNT1_X; // start counting
    2442:	80 91 d4 05 	lds	r24, 0x05D4
    2446:	90 91 d5 05 	lds	r25, 0x05D5
    244a:	00 97       	sbiw	r24, 0x00	; 0
    244c:	41 f4       	brne	.+16     	; 0x245e <HandleSticksForArming+0x44>
    244e:	80 91 48 06 	lds	r24, 0x0648
    2452:	90 91 49 06 	lds	r25, 0x0649
    2456:	90 93 d5 05 	sts	0x05D5, r25
    245a:	80 93 d4 05 	sts	0x05D4, r24
		
		// DisArm Check
		if (IsArmed == true) 
    245e:	80 91 92 07 	lds	r24, 0x0792
    2462:	81 30       	cpi	r24, 0x01	; 1
    2464:	09 f0       	breq	.+2      	; 0x2468 <HandleSticksForArming+0x4e>
    2466:	54 c0       	rjmp	.+168    	; 0x2510 <HandleSticksForArming+0xf6>
		{
			if (RX_Latest[ActiveRXIndex][RXChannel_RUD] > STICK_LEFT)
    2468:	20 91 b8 05 	lds	r18, 0x05B8
    246c:	82 2f       	mov	r24, r18
    246e:	90 e0       	ldi	r25, 0x00	; 0
    2470:	fc 01       	movw	r30, r24
    2472:	ee 0f       	add	r30, r30
    2474:	ff 1f       	adc	r31, r31
    2476:	43 e0       	ldi	r20, 0x03	; 3
    2478:	88 0f       	add	r24, r24
    247a:	99 1f       	adc	r25, r25
    247c:	4a 95       	dec	r20
    247e:	e1 f7       	brne	.-8      	; 0x2478 <HandleSticksForArming+0x5e>
    2480:	e8 0f       	add	r30, r24
    2482:	f9 1f       	adc	r31, r25
    2484:	e0 51       	subi	r30, 0x10	; 16
    2486:	fa 4f       	sbci	r31, 0xFA	; 250
    2488:	84 81       	ldd	r24, Z+4	; 0x04
    248a:	95 81       	ldd	r25, Z+5	; 0x05
    248c:	21 e0       	ldi	r18, 0x01	; 1
    248e:	81 39       	cpi	r24, 0x91	; 145
    2490:	92 07       	cpc	r25, r18
    2492:	84 f0       	brlt	.+32     	; 0x24b4 <HandleSticksForArming+0x9a>
			{ // Check DisArming manually.
				bResetTCNR1_X  = false;
    2494:	10 92 43 06 	sts	0x0643, r1
				if ( (CurrentTCNT1_X - TCNT1_X_snapshot1) > STICKPOSITION_LONG_TIME )
    2498:	80 91 48 06 	lds	r24, 0x0648
    249c:	90 91 49 06 	lds	r25, 0x0649
    24a0:	20 91 d4 05 	lds	r18, 0x05D4
    24a4:	30 91 d5 05 	lds	r19, 0x05D5
    24a8:	82 1b       	sub	r24, r18
    24aa:	93 0b       	sbc	r25, r19
    24ac:	21 e0       	ldi	r18, 0x01	; 1
    24ae:	82 33       	cpi	r24, 0x32	; 50
    24b0:	92 07       	cpc	r25, r18
    24b2:	58 f5       	brcc	.+86     	; 0x250a <HandleSticksForArming+0xf0>
					Disarm();
					return ;
				}
			}
			
			if (Config.AutoDisarm!=0)
    24b4:	60 91 de 06 	lds	r22, 0x06DE
    24b8:	66 23       	and	r22, r22
    24ba:	09 f4       	brne	.+2      	; 0x24be <HandleSticksForArming+0xa4>
    24bc:	1f c1       	rjmp	.+574    	; 0x26fc <HandleSticksForArming+0x2e2>
			{ // check auto disArm
				if (TCNT_X_snapshotAutoDisarm==0) TCNT_X_snapshotAutoDisarm = CurrentTCNT1_X;
    24be:	80 91 09 06 	lds	r24, 0x0609
    24c2:	90 91 0a 06 	lds	r25, 0x060A
    24c6:	00 97       	sbiw	r24, 0x00	; 0
    24c8:	41 f4       	brne	.+16     	; 0x24da <HandleSticksForArming+0xc0>
    24ca:	80 91 48 06 	lds	r24, 0x0648
    24ce:	90 91 49 06 	lds	r25, 0x0649
    24d2:	90 93 0a 06 	sts	0x060A, r25
    24d6:	80 93 09 06 	sts	0x0609, r24
				if ((CurrentTCNT1_X - TCNT_X_snapshotAutoDisarm) > (DISARM_TIME * Config.AutoDisarm))
    24da:	80 91 48 06 	lds	r24, 0x0648
    24de:	90 91 49 06 	lds	r25, 0x0649
    24e2:	20 91 09 06 	lds	r18, 0x0609
    24e6:	30 91 0a 06 	lds	r19, 0x060A
    24ea:	82 1b       	sub	r24, r18
    24ec:	93 0b       	sbc	r25, r19
    24ee:	70 e0       	ldi	r23, 0x00	; 0
    24f0:	48 ee       	ldi	r20, 0xE8	; 232
    24f2:	53 e0       	ldi	r21, 0x03	; 3
    24f4:	64 9f       	mul	r22, r20
    24f6:	90 01       	movw	r18, r0
    24f8:	65 9f       	mul	r22, r21
    24fa:	30 0d       	add	r19, r0
    24fc:	74 9f       	mul	r23, r20
    24fe:	30 0d       	add	r19, r0
    2500:	11 24       	eor	r1, r1
    2502:	28 17       	cp	r18, r24
    2504:	39 07       	cpc	r19, r25
    2506:	08 f0       	brcs	.+2      	; 0x250a <HandleSticksForArming+0xf0>
    2508:	f9 c0       	rjmp	.+498    	; 0x26fc <HandleSticksForArming+0x2e2>
				{
					Disarm();
    250a:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <Disarm>
					return ;
    250e:	08 95       	ret
				}
			}
			
		}			
		
		if (IsArmed == false) 
    2510:	88 23       	and	r24, r24
    2512:	09 f0       	breq	.+2      	; 0x2516 <HandleSticksForArming+0xfc>
    2514:	f3 c0       	rjmp	.+486    	; 0x26fc <HandleSticksForArming+0x2e2>
		{
			//int16_t Stick = (Config.RX_Mid[ActiveRXIndex][RXChannel_RUD] + RX_Latest[ActiveRXIndex][RXChannel_RUD] * RX_Div_Factor);
			if (RX_Latest[ActiveRXIndex][RXChannel_RUD]  < STICK_RIGHT)
    2516:	20 91 b8 05 	lds	r18, 0x05B8
    251a:	82 2f       	mov	r24, r18
    251c:	90 e0       	ldi	r25, 0x00	; 0
    251e:	fc 01       	movw	r30, r24
    2520:	ee 0f       	add	r30, r30
    2522:	ff 1f       	adc	r31, r31
    2524:	23 e0       	ldi	r18, 0x03	; 3
    2526:	88 0f       	add	r24, r24
    2528:	99 1f       	adc	r25, r25
    252a:	2a 95       	dec	r18
    252c:	e1 f7       	brne	.-8      	; 0x2526 <HandleSticksForArming+0x10c>
    252e:	e8 0f       	add	r30, r24
    2530:	f9 1f       	adc	r31, r25
    2532:	e0 51       	subi	r30, 0x10	; 16
    2534:	fa 4f       	sbci	r31, 0xFA	; 250
    2536:	84 81       	ldd	r24, Z+4	; 0x04
    2538:	95 81       	ldd	r25, Z+5	; 0x05
    253a:	2e ef       	ldi	r18, 0xFE	; 254
    253c:	80 37       	cpi	r24, 0x70	; 112
    253e:	92 07       	cpc	r25, r18
    2540:	fc f4       	brge	.+62     	; 0x2580 <HandleSticksForArming+0x166>
			{	// Armin Check
				bResetTCNR1_X = false;
    2542:	10 92 43 06 	sts	0x0643, r1
				if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_LONG_TIME )
    2546:	80 91 48 06 	lds	r24, 0x0648
    254a:	90 91 49 06 	lds	r25, 0x0649
    254e:	20 91 d4 05 	lds	r18, 0x05D4
    2552:	30 91 d5 05 	lds	r19, 0x05D5
    2556:	82 1b       	sub	r24, r18
    2558:	93 0b       	sbc	r25, r19
    255a:	21 e0       	ldi	r18, 0x01	; 1
    255c:	82 33       	cpi	r24, 0x32	; 50
    255e:	92 07       	cpc	r25, r18
    2560:	78 f0       	brcs	.+30     	; 0x2580 <HandleSticksForArming+0x166>
				{
					if ((Config.RX_mode==RX_mode_BuddyMode) && (!IS_TX1_GOOD)) return; 
    2562:	80 91 db 06 	lds	r24, 0x06DB
    2566:	88 23       	and	r24, r24
    2568:	41 f4       	brne	.+16     	; 0x257a <HandleSticksForArming+0x160>
    256a:	80 91 c5 07 	lds	r24, 0x07C5
    256e:	90 e0       	ldi	r25, 0x00	; 0
    2570:	8f 70       	andi	r24, 0x0F	; 15
    2572:	90 70       	andi	r25, 0x00	; 0
    2574:	00 97       	sbiw	r24, 0x00	; 0
    2576:	09 f0       	breq	.+2      	; 0x257a <HandleSticksForArming+0x160>
    2578:	c1 c0       	rjmp	.+386    	; 0x26fc <HandleSticksForArming+0x2e2>
					// in Buddy mode you cannot arm is there is no signal from TX1
					
					Arm();
    257a:	0e 94 1e 0f 	call	0x1e3c	; 0x1e3c <Arm>
					return ;
    257e:	08 95       	ret
				}
			}					
		
			//set modes Quad , X-Quad
		
			if (RX_Latest[ActiveRXIndex][RXChannel_AIL]  > STICK_LEFT)
    2580:	20 91 b8 05 	lds	r18, 0x05B8
    2584:	82 2f       	mov	r24, r18
    2586:	90 e0       	ldi	r25, 0x00	; 0
    2588:	fc 01       	movw	r30, r24
    258a:	ee 0f       	add	r30, r30
    258c:	ff 1f       	adc	r31, r31
    258e:	a3 e0       	ldi	r26, 0x03	; 3
    2590:	88 0f       	add	r24, r24
    2592:	99 1f       	adc	r25, r25
    2594:	aa 95       	dec	r26
    2596:	e1 f7       	brne	.-8      	; 0x2590 <HandleSticksForArming+0x176>
    2598:	e8 0f       	add	r30, r24
    259a:	f9 1f       	adc	r31, r25
    259c:	e0 51       	subi	r30, 0x10	; 16
    259e:	fa 4f       	sbci	r31, 0xFA	; 250
    25a0:	80 81       	ld	r24, Z
    25a2:	91 81       	ldd	r25, Z+1	; 0x01
    25a4:	21 e0       	ldi	r18, 0x01	; 1
    25a6:	81 39       	cpi	r24, 0x91	; 145
    25a8:	92 07       	cpc	r25, r18
    25aa:	ac f0       	brlt	.+42     	; 0x25d6 <HandleSticksForArming+0x1bc>
			{// X-QUAD MODE
				bResetTCNR1_X = false;
    25ac:	10 92 43 06 	sts	0x0643, r1
				if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_LONG_TIME )
    25b0:	80 91 48 06 	lds	r24, 0x0648
    25b4:	90 91 49 06 	lds	r25, 0x0649
    25b8:	20 91 d4 05 	lds	r18, 0x05D4
    25bc:	30 91 d5 05 	lds	r19, 0x05D5
    25c0:	82 1b       	sub	r24, r18
    25c2:	93 0b       	sbc	r25, r19
    25c4:	21 e0       	ldi	r18, 0x01	; 1
    25c6:	82 33       	cpi	r24, 0x32	; 50
    25c8:	92 07       	cpc	r25, r18
    25ca:	08 f4       	brcc	.+2      	; 0x25ce <HandleSticksForArming+0x1b4>
    25cc:	97 c0       	rjmp	.+302    	; 0x26fc <HandleSticksForArming+0x2e2>
				{
					Config.QuadFlyingMode=QuadFlyingMode_X;
    25ce:	81 e0       	ldi	r24, 0x01	; 1
    25d0:	80 93 e2 06 	sts	0x06E2, r24
    25d4:	57 c0       	rjmp	.+174    	; 0x2684 <HandleSticksForArming+0x26a>
					LED_FlashOrangeLED (LED_LONG_TOGGLE,8);
					TCNT1_X_snapshot1 =0; // reset timer
				}
			}			
			else if ((RX_Latest[ActiveRXIndex][RXChannel_AIL]  < STICK_RIGHT))
    25d6:	20 91 b8 05 	lds	r18, 0x05B8
    25da:	82 2f       	mov	r24, r18
    25dc:	90 e0       	ldi	r25, 0x00	; 0
    25de:	fc 01       	movw	r30, r24
    25e0:	ee 0f       	add	r30, r30
    25e2:	ff 1f       	adc	r31, r31
    25e4:	63 e0       	ldi	r22, 0x03	; 3
    25e6:	88 0f       	add	r24, r24
    25e8:	99 1f       	adc	r25, r25
    25ea:	6a 95       	dec	r22
    25ec:	e1 f7       	brne	.-8      	; 0x25e6 <HandleSticksForArming+0x1cc>
    25ee:	e8 0f       	add	r30, r24
    25f0:	f9 1f       	adc	r31, r25
    25f2:	e0 51       	subi	r30, 0x10	; 16
    25f4:	fa 4f       	sbci	r31, 0xFA	; 250
    25f6:	80 81       	ld	r24, Z
    25f8:	91 81       	ldd	r25, Z+1	; 0x01
    25fa:	2e ef       	ldi	r18, 0xFE	; 254
    25fc:	80 37       	cpi	r24, 0x70	; 112
    25fe:	92 07       	cpc	r25, r18
    2600:	bc f4       	brge	.+46     	; 0x2630 <HandleSticksForArming+0x216>
				{	// QUAD COPTER MODE
					bResetTCNR1_X = false;
    2602:	10 92 43 06 	sts	0x0643, r1
					if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_LONG_TIME )
    2606:	80 91 48 06 	lds	r24, 0x0648
    260a:	90 91 49 06 	lds	r25, 0x0649
    260e:	20 91 d4 05 	lds	r18, 0x05D4
    2612:	30 91 d5 05 	lds	r19, 0x05D5
    2616:	82 1b       	sub	r24, r18
    2618:	93 0b       	sbc	r25, r19
    261a:	21 e0       	ldi	r18, 0x01	; 1
    261c:	82 33       	cpi	r24, 0x32	; 50
    261e:	92 07       	cpc	r25, r18
    2620:	08 f4       	brcc	.+2      	; 0x2624 <HandleSticksForArming+0x20a>
    2622:	6c c0       	rjmp	.+216    	; 0x26fc <HandleSticksForArming+0x2e2>
					{
						Config.QuadFlyingMode=QuadFlyingMode_PLUS;
    2624:	10 92 e2 06 	sts	0x06E2, r1
						LED_FlashOrangeLED (LED_LONG_TOGGLE,4);
    2628:	80 e5       	ldi	r24, 0x50	; 80
    262a:	90 e0       	ldi	r25, 0x00	; 0
    262c:	64 e0       	ldi	r22, 0x04	; 4
    262e:	2d c0       	rjmp	.+90     	; 0x268a <HandleSticksForArming+0x270>
					}		
			
				} 
				
			// set mode ACRO , Leveling
			else if ((RX_Latest[ActiveRXIndex][RXChannel_ELE]  < STICK_RIGHT))
    2630:	20 91 b8 05 	lds	r18, 0x05B8
    2634:	82 2f       	mov	r24, r18
    2636:	90 e0       	ldi	r25, 0x00	; 0
    2638:	fc 01       	movw	r30, r24
    263a:	ee 0f       	add	r30, r30
    263c:	ff 1f       	adc	r31, r31
    263e:	43 e0       	ldi	r20, 0x03	; 3
    2640:	88 0f       	add	r24, r24
    2642:	99 1f       	adc	r25, r25
    2644:	4a 95       	dec	r20
    2646:	e1 f7       	brne	.-8      	; 0x2640 <HandleSticksForArming+0x226>
    2648:	e8 0f       	add	r30, r24
    264a:	f9 1f       	adc	r31, r25
    264c:	e0 51       	subi	r30, 0x10	; 16
    264e:	fa 4f       	sbci	r31, 0xFA	; 250
    2650:	82 81       	ldd	r24, Z+2	; 0x02
    2652:	93 81       	ldd	r25, Z+3	; 0x03
    2654:	2e ef       	ldi	r18, 0xFE	; 254
    2656:	80 37       	cpi	r24, 0x70	; 112
    2658:	92 07       	cpc	r25, r18
    265a:	f4 f4       	brge	.+60     	; 0x2698 <HandleSticksForArming+0x27e>
				{	//nFlyingModes = FLYINGMODE_LEVEL;
					bResetTCNR1_X = false;
    265c:	10 92 43 06 	sts	0x0643, r1
					if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_LONG_TIME )
    2660:	80 91 48 06 	lds	r24, 0x0648
    2664:	90 91 49 06 	lds	r25, 0x0649
    2668:	20 91 d4 05 	lds	r18, 0x05D4
    266c:	30 91 d5 05 	lds	r19, 0x05D5
    2670:	82 1b       	sub	r24, r18
    2672:	93 0b       	sbc	r25, r19
    2674:	21 e0       	ldi	r18, 0x01	; 1
    2676:	82 33       	cpi	r24, 0x32	; 50
    2678:	92 07       	cpc	r25, r18
    267a:	08 f4       	brcc	.+2      	; 0x267e <HandleSticksForArming+0x264>
    267c:	3f c0       	rjmp	.+126    	; 0x26fc <HandleSticksForArming+0x2e2>
					{
						nFlyingModes = FLYINGMODE_LEVEL;
    267e:	82 e0       	ldi	r24, 0x02	; 2
    2680:	80 93 08 06 	sts	0x0608, r24
						LED_FlashOrangeLED (LED_LONG_TOGGLE,8);
    2684:	80 e5       	ldi	r24, 0x50	; 80
    2686:	90 e0       	ldi	r25, 0x00	; 0
    2688:	68 e0       	ldi	r22, 0x08	; 8
    268a:	0e 94 8e 0e 	call	0x1d1c	; 0x1d1c <LED_FlashOrangeLED>
						TCNT1_X_snapshot1 =0; // reset timer
    268e:	10 92 d5 05 	sts	0x05D5, r1
    2692:	10 92 d4 05 	sts	0x05D4, r1
    2696:	08 95       	ret
					}		
			
				} 
			else if ((RX_Latest[ActiveRXIndex][RXChannel_ELE]  > STICK_LEFT))
    2698:	20 91 b8 05 	lds	r18, 0x05B8
    269c:	82 2f       	mov	r24, r18
    269e:	90 e0       	ldi	r25, 0x00	; 0
    26a0:	fc 01       	movw	r30, r24
    26a2:	ee 0f       	add	r30, r30
    26a4:	ff 1f       	adc	r31, r31
    26a6:	23 e0       	ldi	r18, 0x03	; 3
    26a8:	88 0f       	add	r24, r24
    26aa:	99 1f       	adc	r25, r25
    26ac:	2a 95       	dec	r18
    26ae:	e1 f7       	brne	.-8      	; 0x26a8 <HandleSticksForArming+0x28e>
    26b0:	e8 0f       	add	r30, r24
    26b2:	f9 1f       	adc	r31, r25
    26b4:	e0 51       	subi	r30, 0x10	; 16
    26b6:	fa 4f       	sbci	r31, 0xFA	; 250
    26b8:	82 81       	ldd	r24, Z+2	; 0x02
    26ba:	93 81       	ldd	r25, Z+3	; 0x03
    26bc:	21 e0       	ldi	r18, 0x01	; 1
    26be:	81 39       	cpi	r24, 0x91	; 145
    26c0:	92 07       	cpc	r25, r18
    26c2:	e4 f0       	brlt	.+56     	; 0x26fc <HandleSticksForArming+0x2e2>
				{	//nFlyingModes = FLYINGMODE_ACRO;
					bResetTCNR1_X = false;
    26c4:	10 92 43 06 	sts	0x0643, r1
					if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_LONG_TIME )
    26c8:	80 91 48 06 	lds	r24, 0x0648
    26cc:	90 91 49 06 	lds	r25, 0x0649
    26d0:	20 91 d4 05 	lds	r18, 0x05D4
    26d4:	30 91 d5 05 	lds	r19, 0x05D5
    26d8:	82 1b       	sub	r24, r18
    26da:	93 0b       	sbc	r25, r19
    26dc:	21 e0       	ldi	r18, 0x01	; 1
    26de:	82 33       	cpi	r24, 0x32	; 50
    26e0:	92 07       	cpc	r25, r18
    26e2:	60 f0       	brcs	.+24     	; 0x26fc <HandleSticksForArming+0x2e2>
					{
						nFlyingModes = FLYINGMODE_ACRO;
    26e4:	81 e0       	ldi	r24, 0x01	; 1
    26e6:	80 93 08 06 	sts	0x0608, r24
						LED_FlashOrangeLED (LED_LONG_TOGGLE,4);
    26ea:	80 e5       	ldi	r24, 0x50	; 80
    26ec:	90 e0       	ldi	r25, 0x00	; 0
    26ee:	64 e0       	ldi	r22, 0x04	; 4
    26f0:	0e 94 8e 0e 	call	0x1d1c	; 0x1d1c <LED_FlashOrangeLED>
						TCNT1_X_snapshot1 =0; // reset timer
    26f4:	10 92 d5 05 	sts	0x05D5, r1
    26f8:	10 92 d4 05 	sts	0x05D4, r1
    26fc:	08 95       	ret

000026fe <HandleSticksAsKeys>:

// This function is never called if there is a calibration issue.
// called in FALSE section of if (RX_Snapshot[RXChannel_THR] < STICKThrottle_ARMING) 
void HandleSticksAsKeys (void)
{
		if ((UIEnableStickCommands==false) || (!IS_TX2_GOOD))  return ; // you cannot use Primary as keys
    26fe:	80 91 d2 05 	lds	r24, 0x05D2
    2702:	88 23       	and	r24, r24
    2704:	09 f4       	brne	.+2      	; 0x2708 <HandleSticksAsKeys+0xa>
    2706:	87 c0       	rjmp	.+270    	; 0x2816 <HandleSticksAsKeys+0x118>
    2708:	80 91 c5 07 	lds	r24, 0x07C5
    270c:	80 7f       	andi	r24, 0xF0	; 240
    270e:	09 f0       	breq	.+2      	; 0x2712 <HandleSticksAsKeys+0x14>
    2710:	82 c0       	rjmp	.+260    	; 0x2816 <HandleSticksAsKeys+0x118>

		// if Throttle is high and stick are calibrated
		
		if (TCNT1_X_snapshot1==0)  TCNT1_X_snapshot1 = CurrentTCNT1_X; // start counting
    2712:	80 91 d4 05 	lds	r24, 0x05D4
    2716:	90 91 d5 05 	lds	r25, 0x05D5
    271a:	00 97       	sbiw	r24, 0x00	; 0
    271c:	41 f4       	brne	.+16     	; 0x272e <HandleSticksAsKeys+0x30>
    271e:	80 91 48 06 	lds	r24, 0x0648
    2722:	90 91 49 06 	lds	r25, 0x0649
    2726:	90 93 d5 05 	sts	0x05D5, r25
    272a:	80 93 d4 05 	sts	0x05D4, r24
				
	 	if ((RX_Latest[RX_MAIN][RXChannel_ELE]) > STICK_LEFT) 
    272e:	80 91 fc 05 	lds	r24, 0x05FC
    2732:	90 91 fd 05 	lds	r25, 0x05FD
    2736:	21 e0       	ldi	r18, 0x01	; 1
    2738:	81 39       	cpi	r24, 0x91	; 145
    273a:	92 07       	cpc	r25, r18
    273c:	8c f0       	brlt	.+34     	; 0x2760 <HandleSticksAsKeys+0x62>
		{
			bResetTCNR1_X = false;
    273e:	10 92 43 06 	sts	0x0643, r1
			if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_SHORT_TIME )
    2742:	80 91 48 06 	lds	r24, 0x0648
    2746:	90 91 49 06 	lds	r25, 0x0649
    274a:	20 91 d4 05 	lds	r18, 0x05D4
    274e:	30 91 d5 05 	lds	r19, 0x05D5
    2752:	82 1b       	sub	r24, r18
    2754:	93 0b       	sbc	r25, r19
    2756:	81 35       	cpi	r24, 0x51	; 81
    2758:	91 05       	cpc	r25, r1
    275a:	00 f1       	brcs	.+64     	; 0x279c <HandleSticksAsKeys+0x9e>
			{
				_TXKeys = KEY_3;
    275c:	80 e2       	ldi	r24, 0x20	; 32
    275e:	18 c0       	rjmp	.+48     	; 0x2790 <HandleSticksAsKeys+0x92>
				TCNT1_X_snapshot1 =0; // reset timer
			}		
		
		}
		else if ((RX_Latest[RX_MAIN][RXChannel_ELE]) < STICK_RIGHT) 
    2760:	80 91 fc 05 	lds	r24, 0x05FC
    2764:	90 91 fd 05 	lds	r25, 0x05FD
    2768:	2e ef       	ldi	r18, 0xFE	; 254
    276a:	80 37       	cpi	r24, 0x70	; 112
    276c:	92 07       	cpc	r25, r18
    276e:	b4 f4       	brge	.+44     	; 0x279c <HandleSticksAsKeys+0x9e>
		{
			bResetTCNR1_X = false;
    2770:	10 92 43 06 	sts	0x0643, r1
			if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_SHORT_TIME )
    2774:	80 91 48 06 	lds	r24, 0x0648
    2778:	90 91 49 06 	lds	r25, 0x0649
    277c:	20 91 d4 05 	lds	r18, 0x05D4
    2780:	30 91 d5 05 	lds	r19, 0x05D5
    2784:	82 1b       	sub	r24, r18
    2786:	93 0b       	sbc	r25, r19
    2788:	81 35       	cpi	r24, 0x51	; 81
    278a:	91 05       	cpc	r25, r1
    278c:	38 f0       	brcs	.+14     	; 0x279c <HandleSticksAsKeys+0x9e>
			{
				_TXKeys = KEY_2;
    278e:	80 e4       	ldi	r24, 0x40	; 64
    2790:	80 93 b4 06 	sts	0x06B4, r24
				TCNT1_X_snapshot1 =0; // reset timer
    2794:	10 92 d5 05 	sts	0x05D5, r1
    2798:	10 92 d4 05 	sts	0x05D4, r1
			}		
		
		}		 	 
		
		if ((RX_Latest[RX_MAIN][RXChannel_AIL]) > STICK_LEFT) 
    279c:	80 91 fa 05 	lds	r24, 0x05FA
    27a0:	90 91 fb 05 	lds	r25, 0x05FB
    27a4:	21 e0       	ldi	r18, 0x01	; 1
    27a6:	81 39       	cpi	r24, 0x91	; 145
    27a8:	92 07       	cpc	r25, r18
    27aa:	bc f0       	brlt	.+46     	; 0x27da <HandleSticksAsKeys+0xdc>
		{
			bResetTCNR1_X = false;
    27ac:	10 92 43 06 	sts	0x0643, r1
			if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_SHORT_TIME )
    27b0:	80 91 48 06 	lds	r24, 0x0648
    27b4:	90 91 49 06 	lds	r25, 0x0649
    27b8:	20 91 d4 05 	lds	r18, 0x05D4
    27bc:	30 91 d5 05 	lds	r19, 0x05D5
    27c0:	82 1b       	sub	r24, r18
    27c2:	93 0b       	sbc	r25, r19
    27c4:	81 35       	cpi	r24, 0x51	; 81
    27c6:	91 05       	cpc	r25, r1
    27c8:	30 f1       	brcs	.+76     	; 0x2816 <HandleSticksAsKeys+0x118>
			{
				_TXKeys = KEY_4;
    27ca:	80 e1       	ldi	r24, 0x10	; 16
    27cc:	80 93 b4 06 	sts	0x06B4, r24
				TCNT1_X_snapshot1 =0; // reset timer
    27d0:	10 92 d5 05 	sts	0x05D5, r1
    27d4:	10 92 d4 05 	sts	0x05D4, r1
    27d8:	08 95       	ret
			}		
		
		}
		else if ((RX_Latest[RX_MAIN][RXChannel_AIL]) < STICK_RIGHT) 
    27da:	80 91 fa 05 	lds	r24, 0x05FA
    27de:	90 91 fb 05 	lds	r25, 0x05FB
    27e2:	2e ef       	ldi	r18, 0xFE	; 254
    27e4:	80 37       	cpi	r24, 0x70	; 112
    27e6:	92 07       	cpc	r25, r18
    27e8:	b4 f4       	brge	.+44     	; 0x2816 <HandleSticksAsKeys+0x118>
		{
			bResetTCNR1_X = false;
    27ea:	10 92 43 06 	sts	0x0643, r1
			if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_SHORT_TIME )
    27ee:	80 91 48 06 	lds	r24, 0x0648
    27f2:	90 91 49 06 	lds	r25, 0x0649
    27f6:	20 91 d4 05 	lds	r18, 0x05D4
    27fa:	30 91 d5 05 	lds	r19, 0x05D5
    27fe:	82 1b       	sub	r24, r18
    2800:	93 0b       	sbc	r25, r19
    2802:	81 35       	cpi	r24, 0x51	; 81
    2804:	91 05       	cpc	r25, r1
    2806:	38 f0       	brcs	.+14     	; 0x2816 <HandleSticksAsKeys+0x118>
			{
				_TXKeys = KEY_1;
    2808:	80 e8       	ldi	r24, 0x80	; 128
    280a:	80 93 b4 06 	sts	0x06B4, r24
				TCNT1_X_snapshot1 =0; // reset timer
    280e:	10 92 d5 05 	sts	0x05D5, r1
    2812:	10 92 d4 05 	sts	0x05D4, r1
    2816:	08 95       	ret

00002818 <ZEROMotors>:
/*
// STOPS MOTORS IMMEDIATLY
*/
void ZEROMotors()
{
	MotorOut[0] = 0;
    2818:	10 92 85 05 	sts	0x0585, r1
    281c:	10 92 84 05 	sts	0x0584, r1
	MotorOut[1] = 0;
    2820:	10 92 87 05 	sts	0x0587, r1
    2824:	10 92 86 05 	sts	0x0586, r1
	MotorOut[2] = 0;
    2828:	10 92 89 05 	sts	0x0589, r1
    282c:	10 92 88 05 	sts	0x0588, r1
	if (Config.FrameType == FRAMETYPE_TRICOPTER)
    2830:	80 91 e0 06 	lds	r24, 0x06E0
    2834:	82 30       	cpi	r24, 0x02	; 2
    2836:	39 f4       	brne	.+14     	; 0x2846 <ZEROMotors+0x2e>
	{
		MotorOut[3] = SERVO_IN_MIDDLE;
    2838:	86 e2       	ldi	r24, 0x26	; 38
    283a:	92 e0       	ldi	r25, 0x02	; 2
    283c:	90 93 8b 05 	sts	0x058B, r25
    2840:	80 93 8a 05 	sts	0x058A, r24
    2844:	04 c0       	rjmp	.+8      	; 0x284e <ZEROMotors+0x36>
	}	
	else
	{
		MotorOut[3] = 0;
    2846:	10 92 8b 05 	sts	0x058B, r1
    284a:	10 92 8a 05 	sts	0x058A, r1
	}		
		
	Motor_GenerateOutputSignal();
    284e:	0e 94 ad 23 	call	0x475a	; 0x475a <Motor_GenerateOutputSignal>
    2852:	08 95       	ret

00002854 <MainLoop>:
	This is the main loop of the application.
*/

static uint16_t LowpassOutYaw;
void MainLoop(void)
{
    2854:	8f 92       	push	r8
    2856:	9f 92       	push	r9
    2858:	af 92       	push	r10
    285a:	bf 92       	push	r11
    285c:	cf 92       	push	r12
    285e:	df 92       	push	r13
    2860:	ef 92       	push	r14
    2862:	ff 92       	push	r15
    2864:	0f 93       	push	r16
    2866:	1f 93       	push	r17
    2868:	cf 93       	push	r28
    286a:	df 93       	push	r29
	
	RX_CopyLatestReceiverValues();
    286c:	0e 94 5b 26 	call	0x4cb6	; 0x4cb6 <RX_CopyLatestReceiverValues>
	//RX_Snapshot_1 [RXChannel_THR]= RX_Snapshot[RXChannel_THR];
	RX_Snapshot   [RXChannel_THR]= RX_Latest[ActiveRXIndex][RXChannel_THR];
    2870:	20 91 b8 05 	lds	r18, 0x05B8
    2874:	82 2f       	mov	r24, r18
    2876:	90 e0       	ldi	r25, 0x00	; 0
    2878:	fc 01       	movw	r30, r24
    287a:	ee 0f       	add	r30, r30
    287c:	ff 1f       	adc	r31, r31
    287e:	23 e0       	ldi	r18, 0x03	; 3
    2880:	88 0f       	add	r24, r24
    2882:	99 1f       	adc	r25, r25
    2884:	2a 95       	dec	r18
    2886:	e1 f7       	brne	.-8      	; 0x2880 <MainLoop+0x2c>
    2888:	e8 0f       	add	r30, r24
    288a:	f9 1f       	adc	r31, r25
    288c:	e0 51       	subi	r30, 0x10	; 16
    288e:	fa 4f       	sbci	r31, 0xFA	; 250
    2890:	86 81       	ldd	r24, Z+6	; 0x06
    2892:	97 81       	ldd	r25, Z+7	; 0x07
    2894:	90 93 b3 05 	sts	0x05B3, r25
    2898:	80 93 b2 05 	sts	0x05B2, r24
	Sensors_ReadAll();	
    289c:	0e 94 cb 28 	call	0x5196	; 0x5196 <Sensors_ReadAll>
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    28a0:	f8 94       	cli
	
	
	
	ATOMIC_BLOCK(ATOMIC_FORCEON)
    {
      CurrentTCNT1_X = TCNT1_X;
    28a2:	80 91 4e 06 	lds	r24, 0x064E
    28a6:	90 91 4f 06 	lds	r25, 0x064F
    28aa:	90 93 49 06 	sts	0x0649, r25
    28ae:	80 93 48 06 	sts	0x0648, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    28b2:	78 94       	sei
    }

	IMU();
    28b4:	0e 94 80 1c 	call	0x3900	; 0x3900 <IMU>
 
	bResetTCNR1_X = true;
    28b8:	21 e0       	ldi	r18, 0x01	; 1
    28ba:	20 93 43 06 	sts	0x0643, r18
	
	
	if (Config.RX_mode==RX_mode_BuddyMode)
    28be:	80 91 db 06 	lds	r24, 0x06DB
    28c2:	88 23       	and	r24, r24
    28c4:	89 f4       	brne	.+34     	; 0x28e8 <MainLoop+0x94>
	{   // in Buddy mode AUX channel is used for instance switching.
		if (IS_TX2_GOOD)
    28c6:	80 91 c5 07 	lds	r24, 0x07C5
    28ca:	80 7f       	andi	r24, 0xF0	; 240
    28cc:	69 f4       	brne	.+26     	; 0x28e8 <MainLoop+0x94>
		{
			if (RX_Latest[RX_MAIN][RXChannel_AUX] < STICK_RIGHT)
    28ce:	80 91 02 06 	lds	r24, 0x0602
    28d2:	90 91 03 06 	lds	r25, 0x0603
    28d6:	3e ef       	ldi	r19, 0xFE	; 254
    28d8:	80 37       	cpi	r24, 0x70	; 112
    28da:	93 07       	cpc	r25, r19
    28dc:	1c f4       	brge	.+6      	; 0x28e4 <MainLoop+0x90>
			{
				ActiveRXIndex = 0;		// use Primary RX
    28de:	10 92 b8 05 	sts	0x05B8, r1
    28e2:	02 c0       	rjmp	.+4      	; 0x28e8 <MainLoop+0x94>
			}
			else
			{
				ActiveRXIndex = 1;		// use Secondary RX
    28e4:	20 93 b8 05 	sts	0x05B8, r18
	
		
	////////// Slow Actions inside
	// HINT: you can try to skip this if flying to save time for more useful tasks as user cannot access menu when flying
	
	if (TCNT_X_snapshot2==0) TCNT_X_snapshot2 = CurrentTCNT1_X;
    28e8:	80 91 d6 05 	lds	r24, 0x05D6
    28ec:	90 91 d7 05 	lds	r25, 0x05D7
    28f0:	20 91 48 06 	lds	r18, 0x0648
    28f4:	30 91 49 06 	lds	r19, 0x0649
    28f8:	00 97       	sbiw	r24, 0x00	; 0
    28fa:	29 f4       	brne	.+10     	; 0x2906 <MainLoop+0xb2>
    28fc:	30 93 d7 05 	sts	0x05D7, r19
    2900:	20 93 d6 05 	sts	0x05D6, r18
    2904:	6a c0       	rjmp	.+212    	; 0x29da <MainLoop+0x186>
	else if ( ((CurrentTCNT1_X- TCNT_X_snapshot2) > 4) )  // TCNT1_X ticks in 32.768us
    2906:	28 1b       	sub	r18, r24
    2908:	39 0b       	sbc	r19, r25
    290a:	25 30       	cpi	r18, 0x05	; 5
    290c:	31 05       	cpc	r19, r1
    290e:	08 f4       	brcc	.+2      	; 0x2912 <MainLoop+0xbe>
    2910:	64 c0       	rjmp	.+200    	; 0x29da <MainLoop+0x186>
	{
		Menu_MenuShow();
    2912:	0e 94 bb 36 	call	0x6d76	; 0x6d76 <Menu_MenuShow>
		
		if (Config.VoltageAlarm > 0)
    2916:	80 91 49 07 	lds	r24, 0x0749
    291a:	88 23       	and	r24, r24
    291c:	79 f0       	breq	.+30     	; 0x293c <MainLoop+0xe8>
		{
			//Sensor_GetBattery();
			if (Sensors_Latest[V_BAT_Index] < Config.VoltageAlarm)
    291e:	20 91 35 06 	lds	r18, 0x0635
    2922:	30 91 36 06 	lds	r19, 0x0636
    2926:	90 e0       	ldi	r25, 0x00	; 0
    2928:	40 91 b5 06 	lds	r20, 0x06B5
    292c:	28 17       	cp	r18, r24
    292e:	39 07       	cpc	r19, r25
    2930:	14 f4       	brge	.+4      	; 0x2936 <MainLoop+0xe2>
			{
				
				SystemErrorType = SET_SYS_ERR_VOLTAGE;
    2932:	42 60       	ori	r20, 0x02	; 2
    2934:	01 c0       	rjmp	.+2      	; 0x2938 <MainLoop+0xe4>
			}
			else
			{
				SystemErrorType = CLR_SYS_ERR_VOLTAGE;
    2936:	4d 7f       	andi	r20, 0xFD	; 253
    2938:	40 93 b5 06 	sts	0x06B5, r20
				
			}
		}	
		if (SystemErrorType != SYS_ERR_NON)
    293c:	80 91 b5 06 	lds	r24, 0x06B5
    2940:	88 23       	and	r24, r24
    2942:	51 f0       	breq	.+20     	; 0x2958 <MainLoop+0x104>
		{
			Buzzer =~Buzzer ;	
    2944:	85 b1       	in	r24, 0x05	; 5
    2946:	86 95       	lsr	r24
    2948:	80 95       	com	r24
    294a:	81 70       	andi	r24, 0x01	; 1
    294c:	88 0f       	add	r24, r24
    294e:	95 b1       	in	r25, 0x05	; 5
    2950:	9d 7f       	andi	r25, 0xFD	; 253
    2952:	98 2b       	or	r25, r24
    2954:	95 b9       	out	0x05, r25	; 5
    2956:	01 c0       	rjmp	.+2      	; 0x295a <MainLoop+0x106>
		}
		else
		{
			Buzzer = OFF;
    2958:	29 98       	cbi	0x05, 1	; 5
		}
		
		if (Config.RX_mode==RX_mode_UARTMode)
    295a:	80 91 db 06 	lds	r24, 0x06DB
    295e:	8f 3f       	cpi	r24, 0xFF	; 255
    2960:	c1 f5       	brne	.+112    	; 0x29d2 <MainLoop+0x17e>
		{
				if ((FlyingModesToggle != LOW) && ( RX_Latest[RX_MAIN][RXChannel_AUX] < STICK_RIGHT ))
    2962:	20 91 21 05 	lds	r18, 0x0521
    2966:	22 23       	and	r18, r18
    2968:	81 f0       	breq	.+32     	; 0x298a <MainLoop+0x136>
    296a:	80 91 02 06 	lds	r24, 0x0602
    296e:	90 91 03 06 	lds	r25, 0x0603
    2972:	4e ef       	ldi	r20, 0xFE	; 254
    2974:	80 37       	cpi	r24, 0x70	; 112
    2976:	94 07       	cpc	r25, r20
    2978:	34 f4       	brge	.+12     	; 0x2986 <MainLoop+0x132>
				{
					nFlyingModes = FLYINGMODE_ALTHOLD;
    297a:	84 e0       	ldi	r24, 0x04	; 4
    297c:	80 93 08 06 	sts	0x0608, r24
					FlyingModesToggle = LOW;
    2980:	10 92 21 05 	sts	0x0521, r1
    2984:	26 c0       	rjmp	.+76     	; 0x29d2 <MainLoop+0x17e>
				} else
				if ((FlyingModesToggle != HIGH) && (RX_Latest[RX_MAIN][RXChannel_AUX] > STICK_LEFT ))
    2986:	21 30       	cpi	r18, 0x01	; 1
    2988:	71 f0       	breq	.+28     	; 0x29a6 <MainLoop+0x152>
    298a:	80 91 02 06 	lds	r24, 0x0602
    298e:	90 91 03 06 	lds	r25, 0x0603
    2992:	51 e0       	ldi	r21, 0x01	; 1
    2994:	81 39       	cpi	r24, 0x91	; 145
    2996:	95 07       	cpc	r25, r21
    2998:	24 f0       	brlt	.+8      	; 0x29a2 <MainLoop+0x14e>
				{
					//LED_Orange=ON;
					nFlyingModes = FLYINGMODE_ACRO;
    299a:	81 e0       	ldi	r24, 0x01	; 1
    299c:	80 93 08 06 	sts	0x0608, r24
    29a0:	16 c0       	rjmp	.+44     	; 0x29ce <MainLoop+0x17a>
					FlyingModesToggle = HIGH;
				} else
				if ((FlyingModesToggle != MID) && (RX_Latest[RX_MAIN][RXChannel_AUX]< STICK_LEFT) && ( RX_Latest[RX_MAIN][RXChannel_AUX] > STICK_RIGHT ))
    29a2:	2b 30       	cpi	r18, 0x0B	; 11
    29a4:	b1 f0       	breq	.+44     	; 0x29d2 <MainLoop+0x17e>
    29a6:	80 91 02 06 	lds	r24, 0x0602
    29aa:	90 91 03 06 	lds	r25, 0x0603
    29ae:	21 e0       	ldi	r18, 0x01	; 1
    29b0:	80 39       	cpi	r24, 0x90	; 144
    29b2:	92 07       	cpc	r25, r18
    29b4:	74 f4       	brge	.+28     	; 0x29d2 <MainLoop+0x17e>
    29b6:	80 91 02 06 	lds	r24, 0x0602
    29ba:	90 91 03 06 	lds	r25, 0x0603
    29be:	3e ef       	ldi	r19, 0xFE	; 254
    29c0:	81 37       	cpi	r24, 0x71	; 113
    29c2:	93 07       	cpc	r25, r19
    29c4:	34 f0       	brlt	.+12     	; 0x29d2 <MainLoop+0x17e>
				{
					nFlyingModes = FLYINGMODE_LEVEL;
    29c6:	82 e0       	ldi	r24, 0x02	; 2
    29c8:	80 93 08 06 	sts	0x0608, r24
					FlyingModesToggle = MID;
    29cc:	8b e0       	ldi	r24, 0x0B	; 11
    29ce:	80 93 21 05 	sts	0x0521, r24
		}		
		//if ((IsArmed == true) && (RX_Snapshot[RXChannel_THR] < STICKThrottle_ARMING+160))
		//{ // calibrate when start flying
			//DynamicCalibration();
		//}			
		TCNT_X_snapshot2=0;
    29d2:	10 92 d7 05 	sts	0x05D7, r1
    29d6:	10 92 d6 05 	sts	0x05D6, r1
	}		
	
	//////////////// EOF Slow Loop
	
	if (RX_Snapshot[RXChannel_THR] < STICKThrottle_ARMING) 
    29da:	c0 91 b2 05 	lds	r28, 0x05B2
    29de:	d0 91 b3 05 	lds	r29, 0x05B3
    29e2:	c2 33       	cpi	r28, 0x32	; 50
    29e4:	d1 05       	cpc	r29, r1
    29e6:	4c f4       	brge	.+18     	; 0x29fa <MainLoop+0x1a6>
	{	
		
		// Throttle is LOW
		// Here you can add code without caring about delays. As there quad is already off and on land.
		// here we test different positions of sticks to enable arm/disarm, Quad/X-Quad
		HandleSticksForArming();
    29e8:	0e 94 0d 12 	call	0x241a	; 0x241a <HandleSticksForArming>
		
		// Stop motors if Throttle Stick is less than minimum.
		ZEROMotors();
    29ec:	0e 94 0c 14 	call	0x2818	; 0x2818 <ZEROMotors>
		ZERO_Is();
    29f0:	0e 94 01 1b 	call	0x3602	; 0x3602 <ZERO_Is>
		IMU_Reset(); // reset angles for gyro [STABLE MODE]
    29f4:	0e 94 64 1c 	call	0x38c8	; 0x38c8 <IMU_Reset>
    29f8:	6b c3       	rjmp	.+1750   	; 0x30d0 <MainLoop+0x87c>
	}
	else
	{	// Throttle stick is NOT Down .... TAKE CARE
		
		if (IsArmed==false)
    29fa:	80 91 92 07 	lds	r24, 0x0792
    29fe:	88 23       	and	r24, r24
    2a00:	29 f4       	brne	.+10     	; 0x2a0c <MainLoop+0x1b8>
		{  // However we are still DisArmed
			ZEROMotors();
    2a02:	0e 94 0c 14 	call	0x2818	; 0x2818 <ZEROMotors>
			
			// Sticks as Keyboard --- we are already disarmed to reach here.
			HandleSticksAsKeys();
    2a06:	0e 94 7f 13 	call	0x26fe	; 0x26fe <HandleSticksAsKeys>
    2a0a:	62 c3       	rjmp	.+1732   	; 0x30d0 <MainLoop+0x87c>
		}
		else
		{	// MOTORS ARE ON HERE .... DANGEROUS
			
			
			TCNT_X_snapshotAutoDisarm = 0; // ZERO [user may disarm then fly slowly..in this case the qud will disarm once he turned off the stick...because the counter counts once the quad is armed..e.g. if it takes n sec to disarm automatically..user took n-1 sec keeping the stick low after arming then it will take 1 sec to disarm again after lowing the stick under STICKThrottle_ARMING
    2a0c:	10 92 0a 06 	sts	0x060A, r1
    2a10:	10 92 09 06 	sts	0x0609, r1
			
			// Armed & Throttle Stick > MIN . . . We should Fly now.
			//RX_Snapshot_1 [RXChannel_AIL]= RX_Snapshot[RXChannel_AIL];
			//RX_Snapshot_1 [RXChannel_ELE]= RX_Snapshot[RXChannel_ELE];
			//RX_Snapshot_1 [RXChannel_RUD]= RX_Snapshot[RXChannel_RUD];
			RX_Snapshot	  [RXChannel_AIL] = (RX_Latest[ActiveRXIndex][RXChannel_AIL] * Config.StickScaling * 0.05 );
    2a14:	20 91 b8 05 	lds	r18, 0x05B8
    2a18:	82 2f       	mov	r24, r18
    2a1a:	90 e0       	ldi	r25, 0x00	; 0
    2a1c:	fc 01       	movw	r30, r24
    2a1e:	ee 0f       	add	r30, r30
    2a20:	ff 1f       	adc	r31, r31
    2a22:	13 e0       	ldi	r17, 0x03	; 3
    2a24:	88 0f       	add	r24, r24
    2a26:	99 1f       	adc	r25, r25
    2a28:	1a 95       	dec	r17
    2a2a:	e1 f7       	brne	.-8      	; 0x2a24 <MainLoop+0x1d0>
    2a2c:	e8 0f       	add	r30, r24
    2a2e:	f9 1f       	adc	r31, r25
    2a30:	e0 51       	subi	r30, 0x10	; 16
    2a32:	fa 4f       	sbci	r31, 0xFA	; 250
    2a34:	80 81       	ld	r24, Z
    2a36:	91 81       	ldd	r25, Z+1	; 0x01
    2a38:	e0 90 e5 06 	lds	r14, 0x06E5
    2a3c:	ff 24       	eor	r15, r15
    2a3e:	e8 9e       	mul	r14, r24
    2a40:	b0 01       	movw	r22, r0
    2a42:	e9 9e       	mul	r14, r25
    2a44:	70 0d       	add	r23, r0
    2a46:	f8 9e       	mul	r15, r24
    2a48:	70 0d       	add	r23, r0
    2a4a:	11 24       	eor	r1, r1
    2a4c:	88 27       	eor	r24, r24
    2a4e:	77 fd       	sbrc	r23, 7
    2a50:	80 95       	com	r24
    2a52:	98 2f       	mov	r25, r24
    2a54:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    2a58:	2d ec       	ldi	r18, 0xCD	; 205
    2a5a:	3c ec       	ldi	r19, 0xCC	; 204
    2a5c:	4c e4       	ldi	r20, 0x4C	; 76
    2a5e:	5d e3       	ldi	r21, 0x3D	; 61
    2a60:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    2a64:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <__fixsfsi>
    2a68:	70 93 ad 05 	sts	0x05AD, r23
    2a6c:	60 93 ac 05 	sts	0x05AC, r22
			RX_Snapshot   [RXChannel_ELE] = (RX_Latest[ActiveRXIndex][RXChannel_ELE] * Config.StickScaling * 0.05 ); 
    2a70:	20 91 b8 05 	lds	r18, 0x05B8
    2a74:	82 2f       	mov	r24, r18
    2a76:	90 e0       	ldi	r25, 0x00	; 0
    2a78:	fc 01       	movw	r30, r24
    2a7a:	ee 0f       	add	r30, r30
    2a7c:	ff 1f       	adc	r31, r31
    2a7e:	a3 e0       	ldi	r26, 0x03	; 3
    2a80:	88 0f       	add	r24, r24
    2a82:	99 1f       	adc	r25, r25
    2a84:	aa 95       	dec	r26
    2a86:	e1 f7       	brne	.-8      	; 0x2a80 <MainLoop+0x22c>
    2a88:	e8 0f       	add	r30, r24
    2a8a:	f9 1f       	adc	r31, r25
    2a8c:	e0 51       	subi	r30, 0x10	; 16
    2a8e:	fa 4f       	sbci	r31, 0xFA	; 250
    2a90:	82 81       	ldd	r24, Z+2	; 0x02
    2a92:	93 81       	ldd	r25, Z+3	; 0x03
    2a94:	e8 9e       	mul	r14, r24
    2a96:	b0 01       	movw	r22, r0
    2a98:	e9 9e       	mul	r14, r25
    2a9a:	70 0d       	add	r23, r0
    2a9c:	f8 9e       	mul	r15, r24
    2a9e:	70 0d       	add	r23, r0
    2aa0:	11 24       	eor	r1, r1
    2aa2:	88 27       	eor	r24, r24
    2aa4:	77 fd       	sbrc	r23, 7
    2aa6:	80 95       	com	r24
    2aa8:	98 2f       	mov	r25, r24
    2aaa:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    2aae:	2d ec       	ldi	r18, 0xCD	; 205
    2ab0:	3c ec       	ldi	r19, 0xCC	; 204
    2ab2:	4c e4       	ldi	r20, 0x4C	; 76
    2ab4:	5d e3       	ldi	r21, 0x3D	; 61
    2ab6:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    2aba:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <__fixsfsi>
    2abe:	70 93 af 05 	sts	0x05AF, r23
    2ac2:	60 93 ae 05 	sts	0x05AE, r22
			RX_Snapshot   [RXChannel_RUD] = (RX_Latest[ActiveRXIndex][RXChannel_RUD] * Config.StickScaling * 0.05 ); // version 0.9.9 
    2ac6:	20 91 b8 05 	lds	r18, 0x05B8
    2aca:	82 2f       	mov	r24, r18
    2acc:	90 e0       	ldi	r25, 0x00	; 0
    2ace:	fc 01       	movw	r30, r24
    2ad0:	ee 0f       	add	r30, r30
    2ad2:	ff 1f       	adc	r31, r31
    2ad4:	63 e0       	ldi	r22, 0x03	; 3
    2ad6:	88 0f       	add	r24, r24
    2ad8:	99 1f       	adc	r25, r25
    2ada:	6a 95       	dec	r22
    2adc:	e1 f7       	brne	.-8      	; 0x2ad6 <MainLoop+0x282>
    2ade:	e8 0f       	add	r30, r24
    2ae0:	f9 1f       	adc	r31, r25
    2ae2:	e0 51       	subi	r30, 0x10	; 16
    2ae4:	fa 4f       	sbci	r31, 0xFA	; 250
    2ae6:	84 81       	ldd	r24, Z+4	; 0x04
    2ae8:	95 81       	ldd	r25, Z+5	; 0x05
    2aea:	e8 9e       	mul	r14, r24
    2aec:	b0 01       	movw	r22, r0
    2aee:	e9 9e       	mul	r14, r25
    2af0:	70 0d       	add	r23, r0
    2af2:	f8 9e       	mul	r15, r24
    2af4:	70 0d       	add	r23, r0
    2af6:	11 24       	eor	r1, r1
    2af8:	88 27       	eor	r24, r24
    2afa:	77 fd       	sbrc	r23, 7
    2afc:	80 95       	com	r24
    2afe:	98 2f       	mov	r25, r24
    2b00:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    2b04:	2d ec       	ldi	r18, 0xCD	; 205
    2b06:	3c ec       	ldi	r19, 0xCC	; 204
    2b08:	4c e4       	ldi	r20, 0x4C	; 76
    2b0a:	5d e3       	ldi	r21, 0x3D	; 61
    2b0c:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    2b10:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <__fixsfsi>
    2b14:	70 93 b1 05 	sts	0x05B1, r23
    2b18:	60 93 b0 05 	sts	0x05B0, r22
		
			
			// Add Throttle to Motors
			MotorOut[0] = RX_Snapshot[RXChannel_THR];
			MotorOut[1] = RX_Snapshot[RXChannel_THR];
			if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    2b1c:	80 91 e0 06 	lds	r24, 0x06E0
    2b20:	81 30       	cpi	r24, 0x01	; 1
    2b22:	71 f4       	brne	.+28     	; 0x2b40 <MainLoop+0x2ec>
				* The logic below depends on board orientation i.e. sensor orientation compared to motor directions.
				* the IMU in ACHRO mode is totally independent from user sticks ... so it does not matter how the user
				* flies his quad i.e. in X or PLUS .... it does not matter because it is handled in another code lines not here.
				* here we handle board orientation only.
				*/
				if (Config.BoardOrientationMode==QuadFlyingMode_X)
    2b24:	40 91 e1 06 	lds	r20, 0x06E1
    2b28:	80 91 23 06 	lds	r24, 0x0623
    2b2c:	90 91 24 06 	lds	r25, 0x0624
    2b30:	20 91 a4 05 	lds	r18, 0x05A4
    2b34:	30 91 a5 05 	lds	r19, 0x05A5
    2b38:	41 30       	cpi	r20, 0x01	; 1
    2b3a:	09 f0       	breq	.+2      	; 0x2b3e <MainLoop+0x2ea>
    2b3c:	57 c0       	rjmp	.+174    	; 0x2bec <MainLoop+0x398>
    2b3e:	34 c0       	rjmp	.+104    	; 0x2ba8 <MainLoop+0x354>
			}
			else
			{	// Balance Tri-Copter
				// NOT VALID if Board Orientation is X
					
				MotorOut[2] += gyroPitch; // * 1.0;
    2b40:	60 91 23 06 	lds	r22, 0x0623
    2b44:	70 91 24 06 	lds	r23, 0x0624
    2b48:	cb 01       	movw	r24, r22
    2b4a:	8c 0f       	add	r24, r28
    2b4c:	9d 1f       	adc	r25, r29
    2b4e:	90 93 89 05 	sts	0x0589, r25
    2b52:	80 93 88 05 	sts	0x0588, r24
					
				gyroPitch    = gyroPitch * 0.5; // distribute pitch on two front motors .... half the effect. 
    2b56:	88 27       	eor	r24, r24
    2b58:	77 fd       	sbrc	r23, 7
    2b5a:	80 95       	com	r24
    2b5c:	98 2f       	mov	r25, r24
    2b5e:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    2b62:	20 e0       	ldi	r18, 0x00	; 0
    2b64:	30 e0       	ldi	r19, 0x00	; 0
    2b66:	40 e0       	ldi	r20, 0x00	; 0
    2b68:	5f e3       	ldi	r21, 0x3F	; 63
    2b6a:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    2b6e:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <__fixsfsi>
    2b72:	9b 01       	movw	r18, r22
    2b74:	70 93 24 06 	sts	0x0624, r23
    2b78:	60 93 23 06 	sts	0x0623, r22
				MotorOut[0] -= gyroPitch  ;
				MotorOut[1] -= gyroPitch  ;
					
				gyroRoll = gyroRoll; // * 0.85;
    2b7c:	40 91 a4 05 	lds	r20, 0x05A4
    2b80:	50 91 a5 05 	lds	r21, 0x05A5
				// NOT VALID if Board Orientation is X
					
				MotorOut[2] += gyroPitch; // * 1.0;
					
				gyroPitch    = gyroPitch * 0.5; // distribute pitch on two front motors .... half the effect. 
				MotorOut[0] -= gyroPitch  ;
    2b84:	ce 01       	movw	r24, r28
    2b86:	82 1b       	sub	r24, r18
    2b88:	93 0b       	sbc	r25, r19
				MotorOut[1] -= gyroPitch  ;
					
				gyroRoll = gyroRoll; // * 0.85;
				MotorOut[0] -= gyroRoll  ;
    2b8a:	84 1b       	sub	r24, r20
    2b8c:	95 0b       	sbc	r25, r21
    2b8e:	90 93 85 05 	sts	0x0585, r25
    2b92:	80 93 84 05 	sts	0x0584, r24
					
				MotorOut[2] += gyroPitch; // * 1.0;
					
				gyroPitch    = gyroPitch * 0.5; // distribute pitch on two front motors .... half the effect. 
				MotorOut[0] -= gyroPitch  ;
				MotorOut[1] -= gyroPitch  ;
    2b96:	c4 0f       	add	r28, r20
    2b98:	d5 1f       	adc	r29, r21
					
				gyroRoll = gyroRoll; // * 0.85;
				MotorOut[0] -= gyroRoll  ;
				MotorOut[1] += gyroRoll  ;
    2b9a:	c2 1b       	sub	r28, r18
    2b9c:	d3 0b       	sbc	r29, r19
    2b9e:	d0 93 87 05 	sts	0x0587, r29
    2ba2:	c0 93 86 05 	sts	0x0586, r28
    2ba6:	3d c0       	rjmp	.+122    	; 0x2c22 <MainLoop+0x3ce>
				if (Config.BoardOrientationMode==QuadFlyingMode_X)
				{	// Board Orientation in X-Mode
					// {-1,1,1,-1} QUAD_ROL_X
					MotorOut[0] -= gyroRoll ;
					MotorOut[3] -= gyroRoll ;
					MotorOut[1] += gyroRoll ;
    2ba8:	b9 01       	movw	r22, r18
    2baa:	6c 0f       	add	r22, r28
    2bac:	7d 1f       	adc	r23, r29
				* here we handle board orientation only.
				*/
				if (Config.BoardOrientationMode==QuadFlyingMode_X)
				{	// Board Orientation in X-Mode
					// {-1,1,1,-1} QUAD_ROL_X
					MotorOut[0] -= gyroRoll ;
    2bae:	ae 01       	movw	r20, r28
    2bb0:	42 1b       	sub	r20, r18
    2bb2:	53 0b       	sbc	r21, r19
					MotorOut[3] -= gyroRoll ;
					MotorOut[1] += gyroRoll ;
					MotorOut[2] += gyroRoll ;
					
					// {-1,-1,1,1} QUAD_AIL_X
					MotorOut[0] -= gyroPitch;
    2bb4:	48 1b       	sub	r20, r24
    2bb6:	59 0b       	sbc	r21, r25
    2bb8:	50 93 85 05 	sts	0x0585, r21
    2bbc:	40 93 84 05 	sts	0x0584, r20
					MotorOut[1] -= gyroPitch;
    2bc0:	ab 01       	movw	r20, r22
    2bc2:	48 1b       	sub	r20, r24
    2bc4:	59 0b       	sbc	r21, r25
    2bc6:	50 93 87 05 	sts	0x0587, r21
    2bca:	40 93 86 05 	sts	0x0586, r20
					MotorOut[2] += gyroPitch;
    2bce:	68 0f       	add	r22, r24
    2bd0:	79 1f       	adc	r23, r25
    2bd2:	70 93 89 05 	sts	0x0589, r23
    2bd6:	60 93 88 05 	sts	0x0588, r22
				*/
				if (Config.BoardOrientationMode==QuadFlyingMode_X)
				{	// Board Orientation in X-Mode
					// {-1,1,1,-1} QUAD_ROL_X
					MotorOut[0] -= gyroRoll ;
					MotorOut[3] -= gyroRoll ;
    2bda:	c8 0f       	add	r28, r24
    2bdc:	d9 1f       	adc	r29, r25
					
					// {-1,-1,1,1} QUAD_AIL_X
					MotorOut[0] -= gyroPitch;
					MotorOut[1] -= gyroPitch;
					MotorOut[2] += gyroPitch;
					MotorOut[3] += gyroPitch;
    2bde:	c2 1b       	sub	r28, r18
    2be0:	d3 0b       	sbc	r29, r19
    2be2:	d0 93 8b 05 	sts	0x058B, r29
    2be6:	c0 93 8a 05 	sts	0x058A, r28
    2bea:	1b c0       	rjmp	.+54     	; 0x2c22 <MainLoop+0x3ce>
					
				}
				else
				{	// Board Orientation in Plus-Mode
					// {0,1,0,-1} QUAD_ROL_PLUS
					MotorOut[1] += gyroRoll  ;
    2bec:	a9 01       	movw	r20, r18
    2bee:	4c 0f       	add	r20, r28
    2bf0:	5d 1f       	adc	r21, r29
    2bf2:	50 93 87 05 	sts	0x0587, r21
    2bf6:	40 93 86 05 	sts	0x0586, r20
					MotorOut[3] -= gyroRoll  ;
    2bfa:	ae 01       	movw	r20, r28
    2bfc:	42 1b       	sub	r20, r18
    2bfe:	53 0b       	sbc	r21, r19
    2c00:	50 93 8b 05 	sts	0x058B, r21
    2c04:	40 93 8a 05 	sts	0x058A, r20
				
					// {-1,0,1,0} QUAD_AIL_PLUS
					MotorOut[0] -= gyroPitch ;
    2c08:	9e 01       	movw	r18, r28
    2c0a:	28 1b       	sub	r18, r24
    2c0c:	39 0b       	sbc	r19, r25
    2c0e:	30 93 85 05 	sts	0x0585, r19
    2c12:	20 93 84 05 	sts	0x0584, r18
					MotorOut[2] += gyroPitch ; 
    2c16:	c8 0f       	add	r28, r24
    2c18:	d9 1f       	adc	r29, r25
    2c1a:	d0 93 89 05 	sts	0x0589, r29
    2c1e:	c0 93 88 05 	sts	0x0588, r28
			*
			*	Pilot Control Logic.
			*	Handles signals from remote control in ACRO mode.
			*	in stabilization mode controls are added in IMU logic as angles.
			*/
			if (nFlyingModes == FLYINGMODE_ACRO)
    2c22:	80 91 08 06 	lds	r24, 0x0608
    2c26:	81 30       	cpi	r24, 0x01	; 1
    2c28:	09 f0       	breq	.+2      	; 0x2c2c <MainLoop+0x3d8>
    2c2a:	2e c1       	rjmp	.+604    	; 0x2e88 <MainLoop+0x634>
			{
				if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    2c2c:	90 91 e0 06 	lds	r25, 0x06E0
    2c30:	80 91 e2 06 	lds	r24, 0x06E2
    2c34:	91 30       	cpi	r25, 0x01	; 1
    2c36:	09 f0       	breq	.+2      	; 0x2c3a <MainLoop+0x3e6>
    2c38:	a3 c0       	rjmp	.+326    	; 0x2d80 <MainLoop+0x52c>
    2c3a:	60 91 ac 05 	lds	r22, 0x05AC
    2c3e:	70 91 ad 05 	lds	r23, 0x05AD
    2c42:	e0 90 ae 05 	lds	r14, 0x05AE
    2c46:	f0 90 af 05 	lds	r15, 0x05AF
    2c4a:	80 90 8a 05 	lds	r8, 0x058A
    2c4e:	90 90 8b 05 	lds	r9, 0x058B
    2c52:	a0 90 86 05 	lds	r10, 0x0586
    2c56:	b0 90 87 05 	lds	r11, 0x0587
    2c5a:	c0 90 88 05 	lds	r12, 0x0588
    2c5e:	d0 90 89 05 	lds	r13, 0x0589
    2c62:	00 91 84 05 	lds	r16, 0x0584
    2c66:	10 91 85 05 	lds	r17, 0x0585
				{
				
					if (Config.QuadFlyingMode==QuadFlyingMode_X)
    2c6a:	81 30       	cpi	r24, 0x01	; 1
    2c6c:	09 f0       	breq	.+2      	; 0x2c70 <MainLoop+0x41c>
    2c6e:	49 c0       	rjmp	.+146    	; 0x2d02 <MainLoop+0x4ae>
					{
						RX_Snapshot[RXChannel_AIL] = RX_Snapshot[RXChannel_AIL] * 0.63;		// because we fly X
    2c70:	88 27       	eor	r24, r24
    2c72:	77 fd       	sbrc	r23, 7
    2c74:	80 95       	com	r24
    2c76:	98 2f       	mov	r25, r24
    2c78:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    2c7c:	2e ea       	ldi	r18, 0xAE	; 174
    2c7e:	37 e4       	ldi	r19, 0x47	; 71
    2c80:	41 e2       	ldi	r20, 0x21	; 33
    2c82:	5f e3       	ldi	r21, 0x3F	; 63
    2c84:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    2c88:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <__fixsfsi>
    2c8c:	eb 01       	movw	r28, r22
    2c8e:	70 93 ad 05 	sts	0x05AD, r23
    2c92:	60 93 ac 05 	sts	0x05AC, r22
						RX_Snapshot[RXChannel_ELE] = RX_Snapshot[RXChannel_ELE] * 0.63;
    2c96:	b7 01       	movw	r22, r14
    2c98:	88 27       	eor	r24, r24
    2c9a:	77 fd       	sbrc	r23, 7
    2c9c:	80 95       	com	r24
    2c9e:	98 2f       	mov	r25, r24
    2ca0:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    2ca4:	2e ea       	ldi	r18, 0xAE	; 174
    2ca6:	37 e4       	ldi	r19, 0x47	; 71
    2ca8:	41 e2       	ldi	r20, 0x21	; 33
    2caa:	5f e3       	ldi	r21, 0x3F	; 63
    2cac:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    2cb0:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <__fixsfsi>
    2cb4:	9b 01       	movw	r18, r22
    2cb6:	70 93 af 05 	sts	0x05AF, r23
    2cba:	60 93 ae 05 	sts	0x05AE, r22
					
						// {0.63,-0.63,-0.63,0.63} QUAD_AIL_X
						MotorOut[0] += RX_Snapshot[RXChannel_AIL] ;
						MotorOut[3] += RX_Snapshot[RXChannel_AIL] ;
    2cbe:	8c 0e       	add	r8, r28
    2cc0:	9d 1e       	adc	r9, r29
						MotorOut[1] -= RX_Snapshot[RXChannel_AIL] ;
						MotorOut[2] -= RX_Snapshot[RXChannel_AIL] ;
    2cc2:	cc 1a       	sub	r12, r28
    2cc4:	dd 0a       	sbc	r13, r29
					{
						RX_Snapshot[RXChannel_AIL] = RX_Snapshot[RXChannel_AIL] * 0.63;		// because we fly X
						RX_Snapshot[RXChannel_ELE] = RX_Snapshot[RXChannel_ELE] * 0.63;
					
						// {0.63,-0.63,-0.63,0.63} QUAD_AIL_X
						MotorOut[0] += RX_Snapshot[RXChannel_AIL] ;
    2cc6:	ce 01       	movw	r24, r28
    2cc8:	82 0f       	add	r24, r18
    2cca:	93 1f       	adc	r25, r19
						MotorOut[3] += RX_Snapshot[RXChannel_AIL] ;
						MotorOut[1] -= RX_Snapshot[RXChannel_AIL] ;
						MotorOut[2] -= RX_Snapshot[RXChannel_AIL] ;
				
						// {0.63,0.63,-0.63,-0.63} QUAD_ELE_X
						MotorOut[0] += RX_Snapshot[RXChannel_ELE];
    2ccc:	80 0f       	add	r24, r16
    2cce:	91 1f       	adc	r25, r17
    2cd0:	90 93 85 05 	sts	0x0585, r25
    2cd4:	80 93 84 05 	sts	0x0584, r24
						RX_Snapshot[RXChannel_ELE] = RX_Snapshot[RXChannel_ELE] * 0.63;
					
						// {0.63,-0.63,-0.63,0.63} QUAD_AIL_X
						MotorOut[0] += RX_Snapshot[RXChannel_AIL] ;
						MotorOut[3] += RX_Snapshot[RXChannel_AIL] ;
						MotorOut[1] -= RX_Snapshot[RXChannel_AIL] ;
    2cd8:	a2 0e       	add	r10, r18
    2cda:	b3 1e       	adc	r11, r19
						MotorOut[2] -= RX_Snapshot[RXChannel_AIL] ;
				
						// {0.63,0.63,-0.63,-0.63} QUAD_ELE_X
						MotorOut[0] += RX_Snapshot[RXChannel_ELE];
						MotorOut[1] += RX_Snapshot[RXChannel_ELE];
    2cdc:	ac 1a       	sub	r10, r28
    2cde:	bd 0a       	sbc	r11, r29
    2ce0:	b0 92 87 05 	sts	0x0587, r11
    2ce4:	a0 92 86 05 	sts	0x0586, r10
						MotorOut[2] -= RX_Snapshot[RXChannel_ELE];
    2ce8:	c2 1a       	sub	r12, r18
    2cea:	d3 0a       	sbc	r13, r19
    2cec:	d0 92 89 05 	sts	0x0589, r13
    2cf0:	c0 92 88 05 	sts	0x0588, r12
						MotorOut[3] -= RX_Snapshot[RXChannel_ELE];
    2cf4:	82 1a       	sub	r8, r18
    2cf6:	93 0a       	sbc	r9, r19
    2cf8:	90 92 8b 05 	sts	0x058B, r9
    2cfc:	80 92 8a 05 	sts	0x058A, r8
    2d00:	2e c1       	rjmp	.+604    	; 0x2f5e <MainLoop+0x70a>
					
					}
					else
					{
				
						RX_Snapshot[RXChannel_AIL] = RX_Snapshot[RXChannel_AIL] * 0.9;		// 0.9: to reduce sensitivity more than STABLE mode
    2d02:	88 27       	eor	r24, r24
    2d04:	77 fd       	sbrc	r23, 7
    2d06:	80 95       	com	r24
    2d08:	98 2f       	mov	r25, r24
    2d0a:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    2d0e:	26 e6       	ldi	r18, 0x66	; 102
    2d10:	36 e6       	ldi	r19, 0x66	; 102
    2d12:	46 e6       	ldi	r20, 0x66	; 102
    2d14:	5f e3       	ldi	r21, 0x3F	; 63
    2d16:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    2d1a:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <__fixsfsi>
    2d1e:	eb 01       	movw	r28, r22
    2d20:	70 93 ad 05 	sts	0x05AD, r23
    2d24:	60 93 ac 05 	sts	0x05AC, r22
						RX_Snapshot[RXChannel_ELE] = RX_Snapshot[RXChannel_ELE] * 0.9;
    2d28:	b7 01       	movw	r22, r14
    2d2a:	88 27       	eor	r24, r24
    2d2c:	77 fd       	sbrc	r23, 7
    2d2e:	80 95       	com	r24
    2d30:	98 2f       	mov	r25, r24
    2d32:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    2d36:	26 e6       	ldi	r18, 0x66	; 102
    2d38:	36 e6       	ldi	r19, 0x66	; 102
    2d3a:	46 e6       	ldi	r20, 0x66	; 102
    2d3c:	5f e3       	ldi	r21, 0x3F	; 63
    2d3e:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    2d42:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <__fixsfsi>
    2d46:	70 93 af 05 	sts	0x05AF, r23
    2d4a:	60 93 ae 05 	sts	0x05AE, r22
						// {0.9,0,-0.9,0} QUAD_ELE_PLUS
						MotorOut[0] += RX_Snapshot[RXChannel_ELE] ; 
    2d4e:	06 0f       	add	r16, r22
    2d50:	17 1f       	adc	r17, r23
    2d52:	10 93 85 05 	sts	0x0585, r17
    2d56:	00 93 84 05 	sts	0x0584, r16
						MotorOut[2] -= RX_Snapshot[RXChannel_ELE] ; 
    2d5a:	c6 1a       	sub	r12, r22
    2d5c:	d7 0a       	sbc	r13, r23
    2d5e:	d0 92 89 05 	sts	0x0589, r13
    2d62:	c0 92 88 05 	sts	0x0588, r12
						// {0,-0.9,0,0.9} QUAD_AIL_PLUS	
						MotorOut[1] -= RX_Snapshot[RXChannel_AIL] ; 
    2d66:	ac 1a       	sub	r10, r28
    2d68:	bd 0a       	sbc	r11, r29
    2d6a:	b0 92 87 05 	sts	0x0587, r11
    2d6e:	a0 92 86 05 	sts	0x0586, r10
						MotorOut[3] += RX_Snapshot[RXChannel_AIL] ;  
    2d72:	c8 0d       	add	r28, r8
    2d74:	d9 1d       	adc	r29, r9
    2d76:	d0 93 8b 05 	sts	0x058B, r29
    2d7a:	c0 93 8a 05 	sts	0x058A, r28
    2d7e:	ef c0       	rjmp	.+478    	; 0x2f5e <MainLoop+0x70a>
				}
				else
				{ // TRICopter
					
						int8_t inv=1; // Flying in Y mode
						if (Config.QuadFlyingMode==QuadFlyingMode_X)
    2d80:	81 30       	cpi	r24, 0x01	; 1
    2d82:	11 f0       	breq	.+4      	; 0x2d88 <MainLoop+0x534>
					}
				}
				else
				{ // TRICopter
					
						int8_t inv=1; // Flying in Y mode
    2d84:	01 e0       	ldi	r16, 0x01	; 1
    2d86:	01 c0       	rjmp	.+2      	; 0x2d8a <MainLoop+0x536>
						if (Config.QuadFlyingMode==QuadFlyingMode_X)
						{ // Flying in A mode
							inv = -1;
    2d88:	0f ef       	ldi	r16, 0xFF	; 255
						}							
							// {0.5,0.5,1.1,X} TRI_ELE_FRONT
							MotorOut[2] -= inv * (RX_Snapshot[RXChannel_ELE] * 1.1); 
    2d8a:	c0 91 ae 05 	lds	r28, 0x05AE
    2d8e:	d0 91 af 05 	lds	r29, 0x05AF
    2d92:	60 91 88 05 	lds	r22, 0x0588
    2d96:	70 91 89 05 	lds	r23, 0x0589
    2d9a:	88 27       	eor	r24, r24
    2d9c:	77 fd       	sbrc	r23, 7
    2d9e:	80 95       	com	r24
    2da0:	98 2f       	mov	r25, r24
    2da2:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    2da6:	4b 01       	movw	r8, r22
    2da8:	5c 01       	movw	r10, r24
    2daa:	60 2f       	mov	r22, r16
    2dac:	77 27       	eor	r23, r23
    2dae:	67 fd       	sbrc	r22, 7
    2db0:	70 95       	com	r23
    2db2:	87 2f       	mov	r24, r23
    2db4:	97 2f       	mov	r25, r23
    2db6:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    2dba:	6b 01       	movw	r12, r22
    2dbc:	7c 01       	movw	r14, r24
    2dbe:	be 01       	movw	r22, r28
    2dc0:	88 27       	eor	r24, r24
    2dc2:	77 fd       	sbrc	r23, 7
    2dc4:	80 95       	com	r24
    2dc6:	98 2f       	mov	r25, r24
    2dc8:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    2dcc:	2d ec       	ldi	r18, 0xCD	; 205
    2dce:	3c ec       	ldi	r19, 0xCC	; 204
    2dd0:	4c e8       	ldi	r20, 0x8C	; 140
    2dd2:	5f e3       	ldi	r21, 0x3F	; 63
    2dd4:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    2dd8:	9b 01       	movw	r18, r22
    2dda:	ac 01       	movw	r20, r24
    2ddc:	c7 01       	movw	r24, r14
    2dde:	b6 01       	movw	r22, r12
    2de0:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    2de4:	9b 01       	movw	r18, r22
    2de6:	ac 01       	movw	r20, r24
    2de8:	c5 01       	movw	r24, r10
    2dea:	b4 01       	movw	r22, r8
    2dec:	0e 94 11 37 	call	0x6e22	; 0x6e22 <__subsf3>
    2df0:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <__fixsfsi>
    2df4:	70 93 89 05 	sts	0x0589, r23
    2df8:	60 93 88 05 	sts	0x0588, r22
							RX_Snapshot[RXChannel_ELE] = inv * RX_Snapshot[RXChannel_ELE] * 0.5;
    2dfc:	e0 2e       	mov	r14, r16
    2dfe:	ff 24       	eor	r15, r15
    2e00:	e7 fc       	sbrc	r14, 7
    2e02:	f0 94       	com	r15
    2e04:	ec 9e       	mul	r14, r28
    2e06:	b0 01       	movw	r22, r0
    2e08:	ed 9e       	mul	r14, r29
    2e0a:	70 0d       	add	r23, r0
    2e0c:	fc 9e       	mul	r15, r28
    2e0e:	70 0d       	add	r23, r0
    2e10:	11 24       	eor	r1, r1
    2e12:	88 27       	eor	r24, r24
    2e14:	77 fd       	sbrc	r23, 7
    2e16:	80 95       	com	r24
    2e18:	98 2f       	mov	r25, r24
    2e1a:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    2e1e:	20 e0       	ldi	r18, 0x00	; 0
    2e20:	30 e0       	ldi	r19, 0x00	; 0
    2e22:	40 e0       	ldi	r20, 0x00	; 0
    2e24:	5f e3       	ldi	r21, 0x3F	; 63
    2e26:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    2e2a:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <__fixsfsi>
    2e2e:	fb 01       	movw	r30, r22
    2e30:	70 93 af 05 	sts	0x05AF, r23
    2e34:	60 93 ae 05 	sts	0x05AE, r22
							MotorOut[0] += RX_Snapshot[RXChannel_ELE] ; 
    2e38:	20 91 84 05 	lds	r18, 0x0584
    2e3c:	30 91 85 05 	lds	r19, 0x0585
							MotorOut[1] += RX_Snapshot[RXChannel_ELE] ; 
    2e40:	80 91 86 05 	lds	r24, 0x0586
    2e44:	90 91 87 05 	lds	r25, 0x0587
						
							// {1,-1,0,X} TRI_AIL_FRONT
							RX_Snapshot[RXChannel_AIL] = inv * RX_Snapshot[RXChannel_AIL];
    2e48:	60 91 ac 05 	lds	r22, 0x05AC
    2e4c:	70 91 ad 05 	lds	r23, 0x05AD
    2e50:	e6 9e       	mul	r14, r22
    2e52:	a0 01       	movw	r20, r0
    2e54:	e7 9e       	mul	r14, r23
    2e56:	50 0d       	add	r21, r0
    2e58:	f6 9e       	mul	r15, r22
    2e5a:	50 0d       	add	r21, r0
    2e5c:	11 24       	eor	r1, r1
    2e5e:	50 93 ad 05 	sts	0x05AD, r21
    2e62:	40 93 ac 05 	sts	0x05AC, r20
							inv = -1;
						}							
							// {0.5,0.5,1.1,X} TRI_ELE_FRONT
							MotorOut[2] -= inv * (RX_Snapshot[RXChannel_ELE] * 1.1); 
							RX_Snapshot[RXChannel_ELE] = inv * RX_Snapshot[RXChannel_ELE] * 0.5;
							MotorOut[0] += RX_Snapshot[RXChannel_ELE] ; 
    2e66:	24 0f       	add	r18, r20
    2e68:	35 1f       	adc	r19, r21
							MotorOut[1] += RX_Snapshot[RXChannel_ELE] ; 
						
							// {1,-1,0,X} TRI_AIL_FRONT
							RX_Snapshot[RXChannel_AIL] = inv * RX_Snapshot[RXChannel_AIL];
							MotorOut[0] += RX_Snapshot[RXChannel_AIL] ; 
    2e6a:	2e 0f       	add	r18, r30
    2e6c:	3f 1f       	adc	r19, r31
    2e6e:	30 93 85 05 	sts	0x0585, r19
    2e72:	20 93 84 05 	sts	0x0584, r18
						}							
							// {0.5,0.5,1.1,X} TRI_ELE_FRONT
							MotorOut[2] -= inv * (RX_Snapshot[RXChannel_ELE] * 1.1); 
							RX_Snapshot[RXChannel_ELE] = inv * RX_Snapshot[RXChannel_ELE] * 0.5;
							MotorOut[0] += RX_Snapshot[RXChannel_ELE] ; 
							MotorOut[1] += RX_Snapshot[RXChannel_ELE] ; 
    2e76:	84 1b       	sub	r24, r20
    2e78:	95 0b       	sbc	r25, r21
						
							// {1,-1,0,X} TRI_AIL_FRONT
							RX_Snapshot[RXChannel_AIL] = inv * RX_Snapshot[RXChannel_AIL];
							MotorOut[0] += RX_Snapshot[RXChannel_AIL] ; 
							MotorOut[1] -= RX_Snapshot[RXChannel_AIL] ;  
    2e7a:	8e 0f       	add	r24, r30
    2e7c:	9f 1f       	adc	r25, r31
    2e7e:	90 93 87 05 	sts	0x0587, r25
    2e82:	80 93 86 05 	sts	0x0586, r24
    2e86:	6b c0       	rjmp	.+214    	; 0x2f5e <MainLoop+0x70a>
			{
				// in stabilization mode ... activate Acc-Z & Sonar if enabled.
				
				double Landing;
				
				Landing = IMU_HeightKeeping();
    2e88:	0e 94 74 20 	call	0x40e8	; 0x40e8 <IMU_HeightKeeping>
    2e8c:	7b 01       	movw	r14, r22
    2e8e:	8c 01       	movw	r16, r24
				MotorOut[0] += Landing;
    2e90:	60 91 84 05 	lds	r22, 0x0584
    2e94:	70 91 85 05 	lds	r23, 0x0585
    2e98:	88 27       	eor	r24, r24
    2e9a:	77 fd       	sbrc	r23, 7
    2e9c:	80 95       	com	r24
    2e9e:	98 2f       	mov	r25, r24
    2ea0:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    2ea4:	a8 01       	movw	r20, r16
    2ea6:	97 01       	movw	r18, r14
    2ea8:	0e 94 12 37 	call	0x6e24	; 0x6e24 <__addsf3>
    2eac:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <__fixsfsi>
    2eb0:	70 93 85 05 	sts	0x0585, r23
    2eb4:	60 93 84 05 	sts	0x0584, r22
				MotorOut[1] += Landing;
    2eb8:	60 91 86 05 	lds	r22, 0x0586
    2ebc:	70 91 87 05 	lds	r23, 0x0587
    2ec0:	88 27       	eor	r24, r24
    2ec2:	77 fd       	sbrc	r23, 7
    2ec4:	80 95       	com	r24
    2ec6:	98 2f       	mov	r25, r24
    2ec8:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    2ecc:	a8 01       	movw	r20, r16
    2ece:	97 01       	movw	r18, r14
    2ed0:	0e 94 12 37 	call	0x6e24	; 0x6e24 <__addsf3>
    2ed4:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <__fixsfsi>
    2ed8:	70 93 87 05 	sts	0x0587, r23
    2edc:	60 93 86 05 	sts	0x0586, r22
				if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    2ee0:	80 91 e0 06 	lds	r24, 0x06E0
    2ee4:	c0 90 88 05 	lds	r12, 0x0588
    2ee8:	d0 90 89 05 	lds	r13, 0x0589
    2eec:	81 30       	cpi	r24, 0x01	; 1
    2eee:	31 f5       	brne	.+76     	; 0x2f3c <MainLoop+0x6e8>
				{
					
					MotorOut[2] += Landing;
    2ef0:	b6 01       	movw	r22, r12
    2ef2:	88 27       	eor	r24, r24
    2ef4:	77 fd       	sbrc	r23, 7
    2ef6:	80 95       	com	r24
    2ef8:	98 2f       	mov	r25, r24
    2efa:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    2efe:	a8 01       	movw	r20, r16
    2f00:	97 01       	movw	r18, r14
    2f02:	0e 94 12 37 	call	0x6e24	; 0x6e24 <__addsf3>
    2f06:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <__fixsfsi>
    2f0a:	70 93 89 05 	sts	0x0589, r23
    2f0e:	60 93 88 05 	sts	0x0588, r22
					MotorOut[3] += Landing;		
    2f12:	60 91 8a 05 	lds	r22, 0x058A
    2f16:	70 91 8b 05 	lds	r23, 0x058B
    2f1a:	88 27       	eor	r24, r24
    2f1c:	77 fd       	sbrc	r23, 7
    2f1e:	80 95       	com	r24
    2f20:	98 2f       	mov	r25, r24
    2f22:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    2f26:	a8 01       	movw	r20, r16
    2f28:	97 01       	movw	r18, r14
    2f2a:	0e 94 12 37 	call	0x6e24	; 0x6e24 <__addsf3>
    2f2e:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <__fixsfsi>
    2f32:	70 93 8b 05 	sts	0x058B, r23
    2f36:	60 93 8a 05 	sts	0x058A, r22
    2f3a:	11 c0       	rjmp	.+34     	; 0x2f5e <MainLoop+0x70a>
				}
				else
				{
					MotorOut[2] += Landing;
    2f3c:	b6 01       	movw	r22, r12
    2f3e:	88 27       	eor	r24, r24
    2f40:	77 fd       	sbrc	r23, 7
    2f42:	80 95       	com	r24
    2f44:	98 2f       	mov	r25, r24
    2f46:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    2f4a:	a8 01       	movw	r20, r16
    2f4c:	97 01       	movw	r18, r14
    2f4e:	0e 94 12 37 	call	0x6e24	; 0x6e24 <__addsf3>
    2f52:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <__fixsfsi>
    2f56:	70 93 89 05 	sts	0x0589, r23
    2f5a:	60 93 88 05 	sts	0x0588, r22
													
										
			}
			
									
			if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    2f5e:	00 91 e0 06 	lds	r16, 0x06E0
    2f62:	80 91 bf 06 	lds	r24, 0x06BF
    2f66:	90 91 c0 06 	lds	r25, 0x06C0
    2f6a:	01 30       	cpi	r16, 0x01	; 1
    2f6c:	49 f5       	brne	.+82     	; 0x2fc0 <MainLoop+0x76c>
			{
				MotorOut[0] -= gyroYaw;
    2f6e:	20 91 84 05 	lds	r18, 0x0584
    2f72:	30 91 85 05 	lds	r19, 0x0585
    2f76:	28 1b       	sub	r18, r24
    2f78:	39 0b       	sbc	r19, r25
    2f7a:	30 93 85 05 	sts	0x0585, r19
    2f7e:	20 93 84 05 	sts	0x0584, r18
				MotorOut[2] -= gyroYaw;
    2f82:	20 91 88 05 	lds	r18, 0x0588
    2f86:	30 91 89 05 	lds	r19, 0x0589
    2f8a:	28 1b       	sub	r18, r24
    2f8c:	39 0b       	sbc	r19, r25
    2f8e:	30 93 89 05 	sts	0x0589, r19
    2f92:	20 93 88 05 	sts	0x0588, r18
				MotorOut[1] += gyroYaw;
    2f96:	20 91 86 05 	lds	r18, 0x0586
    2f9a:	30 91 87 05 	lds	r19, 0x0587
    2f9e:	28 0f       	add	r18, r24
    2fa0:	39 1f       	adc	r19, r25
    2fa2:	30 93 87 05 	sts	0x0587, r19
    2fa6:	20 93 86 05 	sts	0x0586, r18
				MotorOut[3] += gyroYaw;
    2faa:	20 91 8a 05 	lds	r18, 0x058A
    2fae:	30 91 8b 05 	lds	r19, 0x058B
    2fb2:	28 0f       	add	r18, r24
    2fb4:	39 1f       	adc	r19, r25
    2fb6:	30 93 8b 05 	sts	0x058B, r19
    2fba:	20 93 8a 05 	sts	0x058A, r18
    2fbe:	3a c0       	rjmp	.+116    	; 0x3034 <MainLoop+0x7e0>
			}
			else
			{
			
				MotorOut[3]  = (Config.ReverseYAW * gyroYaw) + SERVO_IN_MIDDLE; 
    2fc0:	20 91 90 07 	lds	r18, 0x0790
    2fc4:	c2 2f       	mov	r28, r18
    2fc6:	dd 27       	eor	r29, r29
    2fc8:	c7 fd       	sbrc	r28, 7
    2fca:	d0 95       	com	r29
    2fcc:	c8 9f       	mul	r28, r24
    2fce:	b0 01       	movw	r22, r0
    2fd0:	c9 9f       	mul	r28, r25
    2fd2:	70 0d       	add	r23, r0
    2fd4:	d8 9f       	mul	r29, r24
    2fd6:	70 0d       	add	r23, r0
    2fd8:	11 24       	eor	r1, r1
    2fda:	6a 5d       	subi	r22, 0xDA	; 218
    2fdc:	7d 4f       	sbci	r23, 0xFD	; 253
				MotorOut[3]  = MotorOut[3] - (Config.ReverseYAW * RX_Snapshot[RXChannel_RUD] * 0.2);
    2fde:	88 27       	eor	r24, r24
    2fe0:	77 fd       	sbrc	r23, 7
    2fe2:	80 95       	com	r24
    2fe4:	98 2f       	mov	r25, r24
    2fe6:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    2fea:	6b 01       	movw	r12, r22
    2fec:	7c 01       	movw	r14, r24
    2fee:	80 91 b0 05 	lds	r24, 0x05B0
    2ff2:	90 91 b1 05 	lds	r25, 0x05B1
    2ff6:	c8 9f       	mul	r28, r24
    2ff8:	b0 01       	movw	r22, r0
    2ffa:	c9 9f       	mul	r28, r25
    2ffc:	70 0d       	add	r23, r0
    2ffe:	d8 9f       	mul	r29, r24
    3000:	70 0d       	add	r23, r0
    3002:	11 24       	eor	r1, r1
    3004:	88 27       	eor	r24, r24
    3006:	77 fd       	sbrc	r23, 7
    3008:	80 95       	com	r24
    300a:	98 2f       	mov	r25, r24
    300c:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    3010:	2d ec       	ldi	r18, 0xCD	; 205
    3012:	3c ec       	ldi	r19, 0xCC	; 204
    3014:	4c e4       	ldi	r20, 0x4C	; 76
    3016:	5e e3       	ldi	r21, 0x3E	; 62
    3018:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    301c:	9b 01       	movw	r18, r22
    301e:	ac 01       	movw	r20, r24
    3020:	c7 01       	movw	r24, r14
    3022:	b6 01       	movw	r22, r12
    3024:	0e 94 11 37 	call	0x6e22	; 0x6e22 <__subsf3>
    3028:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <__fixsfsi>
    302c:	70 93 8b 05 	sts	0x058B, r23
    3030:	60 93 8a 05 	sts	0x058A, r22
			}						
			
			// Save motors from turning-off
            if (MotorOut[0]<MOTORS_IDLE_VALUE) MotorOut[0]=MOTORS_IDLE_VALUE;
    3034:	80 91 84 05 	lds	r24, 0x0584
    3038:	90 91 85 05 	lds	r25, 0x0585
    303c:	84 36       	cpi	r24, 0x64	; 100
    303e:	91 05       	cpc	r25, r1
    3040:	34 f4       	brge	.+12     	; 0x304e <MainLoop+0x7fa>
    3042:	84 e6       	ldi	r24, 0x64	; 100
    3044:	90 e0       	ldi	r25, 0x00	; 0
    3046:	90 93 85 05 	sts	0x0585, r25
    304a:	80 93 84 05 	sts	0x0584, r24
            if (MotorOut[1]<MOTORS_IDLE_VALUE) MotorOut[1]=MOTORS_IDLE_VALUE;
    304e:	80 91 86 05 	lds	r24, 0x0586
    3052:	90 91 87 05 	lds	r25, 0x0587
    3056:	84 36       	cpi	r24, 0x64	; 100
    3058:	91 05       	cpc	r25, r1
    305a:	34 f4       	brge	.+12     	; 0x3068 <MainLoop+0x814>
    305c:	84 e6       	ldi	r24, 0x64	; 100
    305e:	90 e0       	ldi	r25, 0x00	; 0
    3060:	90 93 87 05 	sts	0x0587, r25
    3064:	80 93 86 05 	sts	0x0586, r24
            if (MotorOut[2]<MOTORS_IDLE_VALUE) MotorOut[2]=MOTORS_IDLE_VALUE;
    3068:	80 91 88 05 	lds	r24, 0x0588
    306c:	90 91 89 05 	lds	r25, 0x0589
    3070:	84 36       	cpi	r24, 0x64	; 100
    3072:	91 05       	cpc	r25, r1
    3074:	34 f4       	brge	.+12     	; 0x3082 <MainLoop+0x82e>
    3076:	84 e6       	ldi	r24, 0x64	; 100
    3078:	90 e0       	ldi	r25, 0x00	; 0
    307a:	90 93 89 05 	sts	0x0589, r25
    307e:	80 93 88 05 	sts	0x0588, r24
            
									
			if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    3082:	01 30       	cpi	r16, 0x01	; 1
    3084:	69 f4       	brne	.+26     	; 0x30a0 <MainLoop+0x84c>
			{
				if (MotorOut[3]<MOTORS_IDLE_VALUE) MotorOut[3]=MOTORS_IDLE_VALUE;
    3086:	80 91 8a 05 	lds	r24, 0x058A
    308a:	90 91 8b 05 	lds	r25, 0x058B
    308e:	84 36       	cpi	r24, 0x64	; 100
    3090:	91 05       	cpc	r25, r1
    3092:	34 f4       	brge	.+12     	; 0x30a0 <MainLoop+0x84c>
    3094:	84 e6       	ldi	r24, 0x64	; 100
    3096:	90 e0       	ldi	r25, 0x00	; 0
    3098:	90 93 8b 05 	sts	0x058B, r25
    309c:	80 93 8a 05 	sts	0x058A, r24
			}
			
		
			// Sending Sensors & Motor Data 
			if (Config.RX_mode==RX_mode_UARTMode)
    30a0:	80 91 db 06 	lds	r24, 0x06DB
    30a4:	8f 3f       	cpi	r24, 0xFF	; 255
    30a6:	a1 f4       	brne	.+40     	; 0x30d0 <MainLoop+0x87c>
			{
				//LED_Orange=~LED_Orange;
				Send_Data("S",1);
    30a8:	84 e0       	ldi	r24, 0x04	; 4
    30aa:	91 e0       	ldi	r25, 0x01	; 1
    30ac:	61 e0       	ldi	r22, 0x01	; 1
    30ae:	0e 94 58 10 	call	0x20b0	; 0x20b0 <Send_Data>
				Send_Data(Sensors_Latest,12);
    30b2:	89 e2       	ldi	r24, 0x29	; 41
    30b4:	96 e0       	ldi	r25, 0x06	; 6
    30b6:	6c e0       	ldi	r22, 0x0C	; 12
    30b8:	0e 94 58 10 	call	0x20b0	; 0x20b0 <Send_Data>
				Send_Data(MotorOut,8);
    30bc:	84 e8       	ldi	r24, 0x84	; 132
    30be:	95 e0       	ldi	r25, 0x05	; 5
    30c0:	68 e0       	ldi	r22, 0x08	; 8
    30c2:	0e 94 58 10 	call	0x20b0	; 0x20b0 <Send_Data>
				Send_Data("E",1);
    30c6:	86 e0       	ldi	r24, 0x06	; 6
    30c8:	91 e0       	ldi	r25, 0x01	; 1
    30ca:	61 e0       	ldi	r22, 0x01	; 1
    30cc:	0e 94 58 10 	call	0x20b0	; 0x20b0 <Send_Data>
		} // End of ARMED & Throttle > Minimum
				
			
	}  // End of Throttle stick is NOT Down [Armed Could be True or not]
	
	if ((!IS_TX2_GOOD)) // if no signal and there is no AutoLandingMode.
    30d0:	80 91 c5 07 	lds	r24, 0x07C5
    30d4:	80 7f       	andi	r24, 0xF0	; 240
    30d6:	79 f0       	breq	.+30     	; 0x30f6 <MainLoop+0x8a2>
	{
		ZEROMotors();
    30d8:	0e 94 0c 14 	call	0x2818	; 0x2818 <ZEROMotors>
		if (IsArmed==true)
    30dc:	80 91 92 07 	lds	r24, 0x0792
    30e0:	81 30       	cpi	r24, 0x01	; 1
    30e2:	49 f4       	brne	.+18     	; 0x30f6 <MainLoop+0x8a2>
		{
			Motor_GenerateOutputSignal();	
    30e4:	0e 94 ad 23 	call	0x475a	; 0x475a <Motor_GenerateOutputSignal>
			Disarm();	
    30e8:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <Disarm>
			SystemErrorType = SET_SYS_ERR_SIGNAL; // only error if signal lost while arming
    30ec:	80 91 b5 06 	lds	r24, 0x06B5
    30f0:	81 60       	ori	r24, 0x01	; 1
    30f2:	80 93 b5 06 	sts	0x06B5, r24
		
		
		//return ; // Do nothing all below depends on TX.
	}
	
	Motor_GenerateOutputSignal();	
    30f6:	0e 94 ad 23 	call	0x475a	; 0x475a <Motor_GenerateOutputSignal>
	
	if (bResetTCNR1_X==true)
    30fa:	80 91 43 06 	lds	r24, 0x0643
    30fe:	81 30       	cpi	r24, 0x01	; 1
    3100:	21 f4       	brne	.+8      	; 0x310a <MainLoop+0x8b6>
	{
		TCNT1_X_snapshot1= 0; // reset timeout
    3102:	10 92 d5 05 	sts	0x05D5, r1
    3106:	10 92 d4 05 	sts	0x05D4, r1
	}
	
	
}	
    310a:	df 91       	pop	r29
    310c:	cf 91       	pop	r28
    310e:	1f 91       	pop	r17
    3110:	0f 91       	pop	r16
    3112:	ff 90       	pop	r15
    3114:	ef 90       	pop	r14
    3116:	df 90       	pop	r13
    3118:	cf 90       	pop	r12
    311a:	bf 90       	pop	r11
    311c:	af 90       	pop	r10
    311e:	9f 90       	pop	r9
    3120:	8f 90       	pop	r8
    3122:	08 95       	ret

00003124 <main>:

int main(void)
{
	// Stick Commands are only available for Secondary Receiver and when Stick is calibrated.
	
	UIEnableStickCommands=false;  
    3124:	10 92 d2 05 	sts	0x05D2, r1
	Setup();
    3128:	0e 94 92 11 	call	0x2324	; 0x2324 <Setup>
	SystemActions = SYS_ACT_NON;
    312c:	10 92 3b 05 	sts	0x053B, r1
    SystemErrorType = SYS_ERR_NON;
    3130:	10 92 b5 06 	sts	0x06B5, r1
	nFlyingModes = FLYINGMODE_ACRO;
    3134:	81 e0       	ldi	r24, 0x01	; 1
    3136:	80 93 08 06 	sts	0x0608, r24
	FlyingModesToggle = HIGH;
    313a:	80 93 21 05 	sts	0x0521, r24
	
	DataPtr = (uint8_t *) (&Sensors_Latest);
    313e:	89 e2       	ldi	r24, 0x29	; 41
    3140:	96 e0       	ldi	r25, 0x06	; 6
    3142:	90 93 a2 07 	sts	0x07A2, r25
    3146:	80 93 a1 07 	sts	0x07A1, r24
	DataCounter=0;
    314a:	10 92 93 07 	sts	0x0793, r1
	
	// Never go to MainLoop "fly loop" unless Sensors & RX is calibrated.
	// This loop to protect against any bug that might make the quad start or KB stick click
	// as in this case crash is a must.
	LoopCalibration ();
    314e:	0e 94 f9 11 	call	0x23f2	; 0x23f2 <LoopCalibration>

	
	
	// This loop better be under the sensor/stick loop to avoid entering this mode is sticks are not calibrated.
	// This is no longer a condition after adding menuEnabled[PAGE_ESC_CALIBRATION]=0
	if (Config.IsESCCalibration==ESCCalibration_ON)		
    3152:	80 91 df 06 	lds	r24, 0x06DF
    3156:	81 30       	cpi	r24, 0x01	; 1
    3158:	11 f4       	brne	.+4      	; 0x315e <main+0x3a>
	{
		LoopESCCalibration ();
    315a:	0e 94 f3 11 	call	0x23e6	; 0x23e6 <LoopESCCalibration>
	Mixer[Mixer_Quad_PLUS].Roll[4]  = {0,-1.0,0,1.0};
//#define Mixer_Quad_X		1
//#define Mixer_TRI			2
*/

	Menu_EnableAllItems();
    315e:	0e 94 06 37 	call	0x6e0c	; 0x6e0c <Menu_EnableAllItems>
	
				
	while(1)
    {
		//LoopESCCalibration();
    	MainLoop();
    3162:	0e 94 2a 14 	call	0x2854	; 0x2854 <MainLoop>
    3166:	fd cf       	rjmp	.-6      	; 0x3162 <main+0x3e>

00003168 <PID_Calculate_ACC>:




float PID_Calculate_ACC (const pid_param_t PID_Params, pid_terms_t *PID_Term, const double  Value)
{
    3168:	6f 92       	push	r6
    316a:	7f 92       	push	r7
    316c:	8f 92       	push	r8
    316e:	9f 92       	push	r9
    3170:	af 92       	push	r10
    3172:	bf 92       	push	r11
    3174:	cf 92       	push	r12
    3176:	df 92       	push	r13
    3178:	ef 92       	push	r14
    317a:	ff 92       	push	r15
    317c:	0f 93       	push	r16
    317e:	1f 93       	push	r17
    3180:	df 93       	push	r29
    3182:	cf 93       	push	r28
    3184:	cd b7       	in	r28, 0x3d	; 61
    3186:	de b7       	in	r29, 0x3e	; 62
    3188:	2e 97       	sbiw	r28, 0x0e	; 14
    318a:	0f b6       	in	r0, 0x3f	; 63
    318c:	f8 94       	cli
    318e:	de bf       	out	0x3e, r29	; 62
    3190:	0f be       	out	0x3f, r0	; 63
    3192:	cd bf       	out	0x3d, r28	; 61
    3194:	c9 82       	std	Y+1, r12	; 0x01
    3196:	da 82       	std	Y+2, r13	; 0x02
    3198:	eb 82       	std	Y+3, r14	; 0x03
    319a:	fc 82       	std	Y+4, r15	; 0x04
    319c:	0d 83       	std	Y+5, r16	; 0x05
    319e:	1e 83       	std	Y+6, r17	; 0x06
    31a0:	2f 83       	std	Y+7, r18	; 0x07
    31a2:	38 87       	std	Y+8, r19	; 0x08
    31a4:	49 87       	std	Y+9, r20	; 0x09
    31a6:	5a 87       	std	Y+10, r21	; 0x0a
    31a8:	6b 87       	std	Y+11, r22	; 0x0b
    31aa:	7c 87       	std	Y+12, r23	; 0x0c
    31ac:	8d 87       	std	Y+13, r24	; 0x0d
    31ae:	9e 87       	std	Y+14, r25	; 0x0e
    31b0:	ef 8c       	ldd	r14, Y+31	; 0x1f
    31b2:	f8 a0       	ldd	r15, Y+32	; 0x20
    31b4:	09 a1       	ldd	r16, Y+33	; 0x21
    31b6:	1a a1       	ldd	r17, Y+34	; 0x22
    31b8:	6d 80       	ldd	r6, Y+5	; 0x05
    31ba:	7e 80       	ldd	r7, Y+6	; 0x06
	#define ACC_I_MIN	4
		
	float Output;
		
		double AbsValue = abs (Value);
    31bc:	c8 01       	movw	r24, r16
    31be:	b7 01       	movw	r22, r14
    31c0:	0e 94 53 39 	call	0x72a6	; 0x72a6 <abs>
    31c4:	9c 01       	movw	r18, r24
    31c6:	b9 01       	movw	r22, r18
    31c8:	88 27       	eor	r24, r24
    31ca:	77 fd       	sbrc	r23, 7
    31cc:	80 95       	com	r24
    31ce:	98 2f       	mov	r25, r24
    31d0:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
		// Calculate Terms 
		if (AbsValue > 1)
    31d4:	20 e0       	ldi	r18, 0x00	; 0
    31d6:	30 e0       	ldi	r19, 0x00	; 0
    31d8:	40 e8       	ldi	r20, 0x80	; 128
    31da:	5f e3       	ldi	r21, 0x3F	; 63
    31dc:	0e 94 c5 38 	call	0x718a	; 0x718a <__gesf2>
    31e0:	18 16       	cp	r1, r24
    31e2:	cc f4       	brge	.+50     	; 0x3216 <PID_Calculate_ACC+0xae>
	    PID_Term->P  = ((float)(Value * PID_Params._P) / 10.0f);						
    31e4:	69 81       	ldd	r22, Y+1	; 0x01
    31e6:	7a 81       	ldd	r23, Y+2	; 0x02
    31e8:	88 27       	eor	r24, r24
    31ea:	77 fd       	sbrc	r23, 7
    31ec:	80 95       	com	r24
    31ee:	98 2f       	mov	r25, r24
    31f0:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    31f4:	9b 01       	movw	r18, r22
    31f6:	ac 01       	movw	r20, r24
    31f8:	c8 01       	movw	r24, r16
    31fa:	b7 01       	movw	r22, r14
    31fc:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    3200:	20 e0       	ldi	r18, 0x00	; 0
    3202:	30 e0       	ldi	r19, 0x00	; 0
    3204:	40 e2       	ldi	r20, 0x20	; 32
    3206:	51 e4       	ldi	r21, 0x41	; 65
    3208:	0e 94 7a 37 	call	0x6ef4	; 0x6ef4 <__divsf3>
    320c:	f5 01       	movw	r30, r10
    320e:	60 83       	st	Z, r22
    3210:	71 83       	std	Z+1, r23	; 0x01
    3212:	82 83       	std	Z+2, r24	; 0x02
    3214:	93 83       	std	Z+3, r25	; 0x03
		//if ((abs(Value - PID_Term->Error) > AbsValue ) || (Value ==0))
		//{  // Zero I if different signs.
			//PID_Term->I =0; ..... removed because it nakes whobbles.S
		//}
		//else 
		int16_t DeltaError = (Value - PID_Term->Error);
    3216:	c8 01       	movw	r24, r16
    3218:	b7 01       	movw	r22, r14
    321a:	f5 01       	movw	r30, r10
    321c:	24 85       	ldd	r18, Z+12	; 0x0c
    321e:	35 85       	ldd	r19, Z+13	; 0x0d
    3220:	46 85       	ldd	r20, Z+14	; 0x0e
    3222:	57 85       	ldd	r21, Z+15	; 0x0f
    3224:	0e 94 11 37 	call	0x6e22	; 0x6e22 <__subsf3>
    3228:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <__fixsfsi>
    322c:	6b 01       	movw	r12, r22
		if (Value > ACC_I_MIN)
    322e:	c8 01       	movw	r24, r16
    3230:	b7 01       	movw	r22, r14
    3232:	20 e0       	ldi	r18, 0x00	; 0
    3234:	30 e0       	ldi	r19, 0x00	; 0
    3236:	40 e8       	ldi	r20, 0x80	; 128
    3238:	50 e4       	ldi	r21, 0x40	; 64
    323a:	0e 94 c5 38 	call	0x718a	; 0x718a <__gesf2>
    323e:	18 16       	cp	r1, r24
    3240:	bc f4       	brge	.+46     	; 0x3270 <PID_Calculate_ACC+0x108>
		{
			PID_Term->I += (float)(PID_Params._I / 100.0f);						    		
    3242:	b3 01       	movw	r22, r6
    3244:	88 27       	eor	r24, r24
    3246:	77 fd       	sbrc	r23, 7
    3248:	80 95       	com	r24
    324a:	98 2f       	mov	r25, r24
    324c:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    3250:	20 e0       	ldi	r18, 0x00	; 0
    3252:	30 e0       	ldi	r19, 0x00	; 0
    3254:	48 ec       	ldi	r20, 0xC8	; 200
    3256:	52 e4       	ldi	r21, 0x42	; 66
    3258:	0e 94 7a 37 	call	0x6ef4	; 0x6ef4 <__divsf3>
    325c:	9b 01       	movw	r18, r22
    325e:	ac 01       	movw	r20, r24
    3260:	f5 01       	movw	r30, r10
    3262:	64 81       	ldd	r22, Z+4	; 0x04
    3264:	75 81       	ldd	r23, Z+5	; 0x05
    3266:	86 81       	ldd	r24, Z+6	; 0x06
    3268:	97 81       	ldd	r25, Z+7	; 0x07
    326a:	0e 94 12 37 	call	0x6e24	; 0x6e24 <__addsf3>
    326e:	32 c0       	rjmp	.+100    	; 0x32d4 <PID_Calculate_ACC+0x16c>
		}
		else if (Value < -ACC_I_MIN)
    3270:	c8 01       	movw	r24, r16
    3272:	b7 01       	movw	r22, r14
    3274:	20 e0       	ldi	r18, 0x00	; 0
    3276:	30 e0       	ldi	r19, 0x00	; 0
    3278:	40 e8       	ldi	r20, 0x80	; 128
    327a:	50 ec       	ldi	r21, 0xC0	; 192
    327c:	0e 94 76 37 	call	0x6eec	; 0x6eec <__cmpsf2>
    3280:	87 ff       	sbrs	r24, 7
    3282:	15 c0       	rjmp	.+42     	; 0x32ae <PID_Calculate_ACC+0x146>
		{	
			PID_Term->I -= (float)(PID_Params._I / 100.0f );						    		
    3284:	b3 01       	movw	r22, r6
    3286:	88 27       	eor	r24, r24
    3288:	77 fd       	sbrc	r23, 7
    328a:	80 95       	com	r24
    328c:	98 2f       	mov	r25, r24
    328e:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    3292:	20 e0       	ldi	r18, 0x00	; 0
    3294:	30 e0       	ldi	r19, 0x00	; 0
    3296:	48 ec       	ldi	r20, 0xC8	; 200
    3298:	52 e4       	ldi	r21, 0x42	; 66
    329a:	0e 94 7a 37 	call	0x6ef4	; 0x6ef4 <__divsf3>
    329e:	9b 01       	movw	r18, r22
    32a0:	ac 01       	movw	r20, r24
    32a2:	f5 01       	movw	r30, r10
    32a4:	64 81       	ldd	r22, Z+4	; 0x04
    32a6:	75 81       	ldd	r23, Z+5	; 0x05
    32a8:	86 81       	ldd	r24, Z+6	; 0x06
    32aa:	97 81       	ldd	r25, Z+7	; 0x07
    32ac:	11 c0       	rjmp	.+34     	; 0x32d0 <PID_Calculate_ACC+0x168>
		}
		else
		{
			PID_Term->I -= (float)(PID_Term->I * PID_I_LEAK_RATE);
    32ae:	f5 01       	movw	r30, r10
    32b0:	64 80       	ldd	r6, Z+4	; 0x04
    32b2:	75 80       	ldd	r7, Z+5	; 0x05
    32b4:	86 80       	ldd	r8, Z+6	; 0x06
    32b6:	97 80       	ldd	r9, Z+7	; 0x07
    32b8:	c4 01       	movw	r24, r8
    32ba:	b3 01       	movw	r22, r6
    32bc:	2a e0       	ldi	r18, 0x0A	; 10
    32be:	37 ed       	ldi	r19, 0xD7	; 215
    32c0:	43 e2       	ldi	r20, 0x23	; 35
    32c2:	5c e3       	ldi	r21, 0x3C	; 60
    32c4:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    32c8:	9b 01       	movw	r18, r22
    32ca:	ac 01       	movw	r20, r24
    32cc:	c4 01       	movw	r24, r8
    32ce:	b3 01       	movw	r22, r6
    32d0:	0e 94 11 37 	call	0x6e22	; 0x6e22 <__subsf3>
    32d4:	f5 01       	movw	r30, r10
    32d6:	64 83       	std	Z+4, r22	; 0x04
    32d8:	75 83       	std	Z+5, r23	; 0x05
    32da:	86 83       	std	Z+6, r24	; 0x06
    32dc:	97 83       	std	Z+7, r25	; 0x07
		}			
				
		
		PID_Term->D= (float)((float)(DeltaError) * (float)PID_Params._D) / 20.0f ;
    32de:	b6 01       	movw	r22, r12
    32e0:	88 27       	eor	r24, r24
    32e2:	77 fd       	sbrc	r23, 7
    32e4:	80 95       	com	r24
    32e6:	98 2f       	mov	r25, r24
    32e8:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    32ec:	3b 01       	movw	r6, r22
    32ee:	4c 01       	movw	r8, r24
    32f0:	69 85       	ldd	r22, Y+9	; 0x09
    32f2:	7a 85       	ldd	r23, Y+10	; 0x0a
    32f4:	88 27       	eor	r24, r24
    32f6:	77 fd       	sbrc	r23, 7
    32f8:	80 95       	com	r24
    32fa:	98 2f       	mov	r25, r24
    32fc:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    3300:	9b 01       	movw	r18, r22
    3302:	ac 01       	movw	r20, r24
    3304:	c4 01       	movw	r24, r8
    3306:	b3 01       	movw	r22, r6
    3308:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    330c:	20 e0       	ldi	r18, 0x00	; 0
    330e:	30 e0       	ldi	r19, 0x00	; 0
    3310:	40 ea       	ldi	r20, 0xA0	; 160
    3312:	51 e4       	ldi	r21, 0x41	; 65
    3314:	0e 94 7a 37 	call	0x6ef4	; 0x6ef4 <__divsf3>
    3318:	f5 01       	movw	r30, r10
    331a:	60 87       	std	Z+8, r22	; 0x08
    331c:	71 87       	std	Z+9, r23	; 0x09
    331e:	82 87       	std	Z+10, r24	; 0x0a
    3320:	93 87       	std	Z+11, r25	; 0x0b
		PID_Term->Error = Value;	
    3322:	e4 86       	std	Z+12, r14	; 0x0c
    3324:	f5 86       	std	Z+13, r15	; 0x0d
    3326:	06 87       	std	Z+14, r16	; 0x0e
    3328:	17 87       	std	Z+15, r17	; 0x0f
		
				
		// Limit boundaries to custom values defined by user.
		PID_Term->I= Limiterf(PID_Term->I, PID_Params._ILimit);
    332a:	e4 80       	ldd	r14, Z+4	; 0x04
    332c:	f5 80       	ldd	r15, Z+5	; 0x05
    332e:	06 81       	ldd	r16, Z+6	; 0x06
    3330:	17 81       	ldd	r17, Z+7	; 0x07
    3332:	6f 81       	ldd	r22, Y+7	; 0x07
    3334:	78 85       	ldd	r23, Y+8	; 0x08
    3336:	88 27       	eor	r24, r24
    3338:	77 fd       	sbrc	r23, 7
    333a:	80 95       	com	r24
    333c:	98 2f       	mov	r25, r24
    333e:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    3342:	9b 01       	movw	r18, r22
    3344:	ac 01       	movw	r20, r24
    3346:	c8 01       	movw	r24, r16
    3348:	b7 01       	movw	r22, r14
    334a:	0e 94 6a 22 	call	0x44d4	; 0x44d4 <Limiterf>
    334e:	f5 01       	movw	r30, r10
    3350:	64 83       	std	Z+4, r22	; 0x04
    3352:	75 83       	std	Z+5, r23	; 0x05
    3354:	86 83       	std	Z+6, r24	; 0x06
    3356:	97 83       	std	Z+7, r25	; 0x07
		PID_Term->P= Limiterf(PID_Term->P, PID_Params._PLimit);
    3358:	e0 80       	ld	r14, Z
    335a:	f1 80       	ldd	r15, Z+1	; 0x01
    335c:	02 81       	ldd	r16, Z+2	; 0x02
    335e:	13 81       	ldd	r17, Z+3	; 0x03
    3360:	6b 81       	ldd	r22, Y+3	; 0x03
    3362:	7c 81       	ldd	r23, Y+4	; 0x04
    3364:	88 27       	eor	r24, r24
    3366:	77 fd       	sbrc	r23, 7
    3368:	80 95       	com	r24
    336a:	98 2f       	mov	r25, r24
    336c:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    3370:	9b 01       	movw	r18, r22
    3372:	ac 01       	movw	r20, r24
    3374:	c8 01       	movw	r24, r16
    3376:	b7 01       	movw	r22, r14
    3378:	0e 94 6a 22 	call	0x44d4	; 0x44d4 <Limiterf>
    337c:	f5 01       	movw	r30, r10
    337e:	60 83       	st	Z, r22
    3380:	71 83       	std	Z+1, r23	; 0x01
    3382:	82 83       	std	Z+2, r24	; 0x02
    3384:	93 83       	std	Z+3, r25	; 0x03
	    PID_Term->D= Limiterf(PID_Term->D, PID_Params._DLimit);
    3386:	e0 84       	ldd	r14, Z+8	; 0x08
    3388:	f1 84       	ldd	r15, Z+9	; 0x09
    338a:	02 85       	ldd	r16, Z+10	; 0x0a
    338c:	13 85       	ldd	r17, Z+11	; 0x0b
    338e:	6b 85       	ldd	r22, Y+11	; 0x0b
    3390:	7c 85       	ldd	r23, Y+12	; 0x0c
    3392:	88 27       	eor	r24, r24
    3394:	77 fd       	sbrc	r23, 7
    3396:	80 95       	com	r24
    3398:	98 2f       	mov	r25, r24
    339a:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    339e:	9b 01       	movw	r18, r22
    33a0:	ac 01       	movw	r20, r24
    33a2:	c8 01       	movw	r24, r16
    33a4:	b7 01       	movw	r22, r14
    33a6:	0e 94 6a 22 	call	0x44d4	; 0x44d4 <Limiterf>
    33aa:	7b 01       	movw	r14, r22
    33ac:	8c 01       	movw	r16, r24
    33ae:	f5 01       	movw	r30, r10
    33b0:	60 87       	std	Z+8, r22	; 0x08
    33b2:	71 87       	std	Z+9, r23	; 0x09
    33b4:	82 87       	std	Z+10, r24	; 0x0a
    33b6:	93 87       	std	Z+11, r25	; 0x0b
	
		Output = (PID_Term->P + PID_Term->I + PID_Term->D);	// P + I + D
    33b8:	60 81       	ld	r22, Z
    33ba:	71 81       	ldd	r23, Z+1	; 0x01
    33bc:	82 81       	ldd	r24, Z+2	; 0x02
    33be:	93 81       	ldd	r25, Z+3	; 0x03
    33c0:	24 81       	ldd	r18, Z+4	; 0x04
    33c2:	35 81       	ldd	r19, Z+5	; 0x05
    33c4:	46 81       	ldd	r20, Z+6	; 0x06
    33c6:	57 81       	ldd	r21, Z+7	; 0x07
    33c8:	0e 94 12 37 	call	0x6e24	; 0x6e24 <__addsf3>
    33cc:	a8 01       	movw	r20, r16
    33ce:	97 01       	movw	r18, r14
    33d0:	0e 94 12 37 	call	0x6e24	; 0x6e24 <__addsf3>
		return  Output; 
}
    33d4:	2e 96       	adiw	r28, 0x0e	; 14
    33d6:	0f b6       	in	r0, 0x3f	; 63
    33d8:	f8 94       	cli
    33da:	de bf       	out	0x3e, r29	; 62
    33dc:	0f be       	out	0x3f, r0	; 63
    33de:	cd bf       	out	0x3d, r28	; 61
    33e0:	cf 91       	pop	r28
    33e2:	df 91       	pop	r29
    33e4:	1f 91       	pop	r17
    33e6:	0f 91       	pop	r16
    33e8:	ff 90       	pop	r15
    33ea:	ef 90       	pop	r14
    33ec:	df 90       	pop	r13
    33ee:	cf 90       	pop	r12
    33f0:	bf 90       	pop	r11
    33f2:	af 90       	pop	r10
    33f4:	9f 90       	pop	r9
    33f6:	8f 90       	pop	r8
    33f8:	7f 90       	pop	r7
    33fa:	6f 90       	pop	r6
    33fc:	08 95       	ret

000033fe <PID_Calculate>:

float PID_Calculate (const pid_param_t PID_Params, pid_terms_t *PID_Term, const double  Value)
{
    33fe:	af 92       	push	r10
    3400:	bf 92       	push	r11
    3402:	cf 92       	push	r12
    3404:	df 92       	push	r13
    3406:	ef 92       	push	r14
    3408:	ff 92       	push	r15
    340a:	0f 93       	push	r16
    340c:	1f 93       	push	r17
    340e:	df 93       	push	r29
    3410:	cf 93       	push	r28
    3412:	cd b7       	in	r28, 0x3d	; 61
    3414:	de b7       	in	r29, 0x3e	; 62
    3416:	2e 97       	sbiw	r28, 0x0e	; 14
    3418:	0f b6       	in	r0, 0x3f	; 63
    341a:	f8 94       	cli
    341c:	de bf       	out	0x3e, r29	; 62
    341e:	0f be       	out	0x3f, r0	; 63
    3420:	cd bf       	out	0x3d, r28	; 61
    3422:	c9 82       	std	Y+1, r12	; 0x01
    3424:	da 82       	std	Y+2, r13	; 0x02
    3426:	eb 82       	std	Y+3, r14	; 0x03
    3428:	fc 82       	std	Y+4, r15	; 0x04
    342a:	0d 83       	std	Y+5, r16	; 0x05
    342c:	1e 83       	std	Y+6, r17	; 0x06
    342e:	2f 83       	std	Y+7, r18	; 0x07
    3430:	38 87       	std	Y+8, r19	; 0x08
    3432:	49 87       	std	Y+9, r20	; 0x09
    3434:	5a 87       	std	Y+10, r21	; 0x0a
    3436:	6b 87       	std	Y+11, r22	; 0x0b
    3438:	7c 87       	std	Y+12, r23	; 0x0c
    343a:	8d 87       	std	Y+13, r24	; 0x0d
    343c:	9e 87       	std	Y+14, r25	; 0x0e
    343e:	eb 8c       	ldd	r14, Y+27	; 0x1b
    3440:	fc 8c       	ldd	r15, Y+28	; 0x1c
    3442:	0d 8d       	ldd	r16, Y+29	; 0x1d
    3444:	1e 8d       	ldd	r17, Y+30	; 0x1e
		float Output;
		
		// Calculate Terms 
	    PID_Term->P  = ((float)(Value * PID_Params._P) / 20.0f);						
    3446:	69 81       	ldd	r22, Y+1	; 0x01
    3448:	7a 81       	ldd	r23, Y+2	; 0x02
    344a:	88 27       	eor	r24, r24
    344c:	77 fd       	sbrc	r23, 7
    344e:	80 95       	com	r24
    3450:	98 2f       	mov	r25, r24
    3452:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    3456:	9b 01       	movw	r18, r22
    3458:	ac 01       	movw	r20, r24
    345a:	c8 01       	movw	r24, r16
    345c:	b7 01       	movw	r22, r14
    345e:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    3462:	20 e0       	ldi	r18, 0x00	; 0
    3464:	30 e0       	ldi	r19, 0x00	; 0
    3466:	40 ea       	ldi	r20, 0xA0	; 160
    3468:	51 e4       	ldi	r21, 0x41	; 65
    346a:	0e 94 7a 37 	call	0x6ef4	; 0x6ef4 <__divsf3>
    346e:	f5 01       	movw	r30, r10
    3470:	60 83       	st	Z, r22
    3472:	71 83       	std	Z+1, r23	; 0x01
    3474:	82 83       	std	Z+2, r24	; 0x02
    3476:	93 83       	std	Z+3, r25	; 0x03
		
		
		
		int16_t DeltaError = (Value - PID_Term->Error);
    3478:	c8 01       	movw	r24, r16
    347a:	b7 01       	movw	r22, r14
    347c:	24 85       	ldd	r18, Z+12	; 0x0c
    347e:	35 85       	ldd	r19, Z+13	; 0x0d
    3480:	46 85       	ldd	r20, Z+14	; 0x0e
    3482:	57 85       	ldd	r21, Z+15	; 0x0f
    3484:	0e 94 11 37 	call	0x6e22	; 0x6e22 <__subsf3>
    3488:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <__fixsfsi>
    348c:	6b 01       	movw	r12, r22
		/*
		// I Logic here:
		// DEAD band = 2
		// Increment or Decrement by Value * PID_Params._I 
		*/
		if ((Value > 1) || (Value < -1))
    348e:	c8 01       	movw	r24, r16
    3490:	b7 01       	movw	r22, r14
    3492:	20 e0       	ldi	r18, 0x00	; 0
    3494:	30 e0       	ldi	r19, 0x00	; 0
    3496:	40 e8       	ldi	r20, 0x80	; 128
    3498:	5f e3       	ldi	r21, 0x3F	; 63
    349a:	0e 94 c5 38 	call	0x718a	; 0x718a <__gesf2>
    349e:	18 16       	cp	r1, r24
    34a0:	54 f0       	brlt	.+20     	; 0x34b6 <PID_Calculate+0xb8>
    34a2:	c8 01       	movw	r24, r16
    34a4:	b7 01       	movw	r22, r14
    34a6:	20 e0       	ldi	r18, 0x00	; 0
    34a8:	30 e0       	ldi	r19, 0x00	; 0
    34aa:	40 e8       	ldi	r20, 0x80	; 128
    34ac:	5f eb       	ldi	r21, 0xBF	; 191
    34ae:	0e 94 76 37 	call	0x6eec	; 0x6eec <__cmpsf2>
    34b2:	87 ff       	sbrs	r24, 7
    34b4:	22 c0       	rjmp	.+68     	; 0x34fa <PID_Calculate+0xfc>
		{	// only increment I when the Value is increasing compared to the old one, also use [-2,2] as deadband.
			PID_Term->I += (float)((float)(Value * PID_Params._I) / 200.0f) ;	// try to replace Value with DeltaError
    34b6:	6d 81       	ldd	r22, Y+5	; 0x05
    34b8:	7e 81       	ldd	r23, Y+6	; 0x06
    34ba:	88 27       	eor	r24, r24
    34bc:	77 fd       	sbrc	r23, 7
    34be:	80 95       	com	r24
    34c0:	98 2f       	mov	r25, r24
    34c2:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    34c6:	9b 01       	movw	r18, r22
    34c8:	ac 01       	movw	r20, r24
    34ca:	c8 01       	movw	r24, r16
    34cc:	b7 01       	movw	r22, r14
    34ce:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    34d2:	20 e0       	ldi	r18, 0x00	; 0
    34d4:	30 e0       	ldi	r19, 0x00	; 0
    34d6:	48 e4       	ldi	r20, 0x48	; 72
    34d8:	53 e4       	ldi	r21, 0x43	; 67
    34da:	0e 94 7a 37 	call	0x6ef4	; 0x6ef4 <__divsf3>
    34de:	9b 01       	movw	r18, r22
    34e0:	ac 01       	movw	r20, r24
    34e2:	f5 01       	movw	r30, r10
    34e4:	64 81       	ldd	r22, Z+4	; 0x04
    34e6:	75 81       	ldd	r23, Z+5	; 0x05
    34e8:	86 81       	ldd	r24, Z+6	; 0x06
    34ea:	97 81       	ldd	r25, Z+7	; 0x07
    34ec:	0e 94 12 37 	call	0x6e24	; 0x6e24 <__addsf3>
    34f0:	f5 01       	movw	r30, r10
    34f2:	64 83       	std	Z+4, r22	; 0x04
    34f4:	75 83       	std	Z+5, r23	; 0x05
    34f6:	86 83       	std	Z+6, r24	; 0x06
    34f8:	97 83       	std	Z+7, r25	; 0x07
			//PID_Term->I -= (float)(PID_Term->I * PID_I_LEAK_RATE);
		//}	
		
		
		
		PID_Term->D= (float)(DeltaError * PID_Params._D) / 20.0f ;
    34fa:	89 85       	ldd	r24, Y+9	; 0x09
    34fc:	9a 85       	ldd	r25, Y+10	; 0x0a
    34fe:	c8 9e       	mul	r12, r24
    3500:	b0 01       	movw	r22, r0
    3502:	c9 9e       	mul	r12, r25
    3504:	70 0d       	add	r23, r0
    3506:	d8 9e       	mul	r13, r24
    3508:	70 0d       	add	r23, r0
    350a:	11 24       	eor	r1, r1
    350c:	88 27       	eor	r24, r24
    350e:	77 fd       	sbrc	r23, 7
    3510:	80 95       	com	r24
    3512:	98 2f       	mov	r25, r24
    3514:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    3518:	20 e0       	ldi	r18, 0x00	; 0
    351a:	30 e0       	ldi	r19, 0x00	; 0
    351c:	40 ea       	ldi	r20, 0xA0	; 160
    351e:	51 e4       	ldi	r21, 0x41	; 65
    3520:	0e 94 7a 37 	call	0x6ef4	; 0x6ef4 <__divsf3>
    3524:	f5 01       	movw	r30, r10
    3526:	60 87       	std	Z+8, r22	; 0x08
    3528:	71 87       	std	Z+9, r23	; 0x09
    352a:	82 87       	std	Z+10, r24	; 0x0a
    352c:	93 87       	std	Z+11, r25	; 0x0b
		PID_Term->Error = Value;	
    352e:	e4 86       	std	Z+12, r14	; 0x0c
    3530:	f5 86       	std	Z+13, r15	; 0x0d
    3532:	06 87       	std	Z+14, r16	; 0x0e
    3534:	17 87       	std	Z+15, r17	; 0x0f
		
				
		// Limit boundaries to custom values defined by user.
		PID_Term->I= Limiterf(PID_Term->I, PID_Params._ILimit);
    3536:	e4 80       	ldd	r14, Z+4	; 0x04
    3538:	f5 80       	ldd	r15, Z+5	; 0x05
    353a:	06 81       	ldd	r16, Z+6	; 0x06
    353c:	17 81       	ldd	r17, Z+7	; 0x07
    353e:	6f 81       	ldd	r22, Y+7	; 0x07
    3540:	78 85       	ldd	r23, Y+8	; 0x08
    3542:	88 27       	eor	r24, r24
    3544:	77 fd       	sbrc	r23, 7
    3546:	80 95       	com	r24
    3548:	98 2f       	mov	r25, r24
    354a:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    354e:	9b 01       	movw	r18, r22
    3550:	ac 01       	movw	r20, r24
    3552:	c8 01       	movw	r24, r16
    3554:	b7 01       	movw	r22, r14
    3556:	0e 94 6a 22 	call	0x44d4	; 0x44d4 <Limiterf>
    355a:	f5 01       	movw	r30, r10
    355c:	64 83       	std	Z+4, r22	; 0x04
    355e:	75 83       	std	Z+5, r23	; 0x05
    3560:	86 83       	std	Z+6, r24	; 0x06
    3562:	97 83       	std	Z+7, r25	; 0x07
		PID_Term->P= Limiterf(PID_Term->P, PID_Params._PLimit);
    3564:	e0 80       	ld	r14, Z
    3566:	f1 80       	ldd	r15, Z+1	; 0x01
    3568:	02 81       	ldd	r16, Z+2	; 0x02
    356a:	13 81       	ldd	r17, Z+3	; 0x03
    356c:	6b 81       	ldd	r22, Y+3	; 0x03
    356e:	7c 81       	ldd	r23, Y+4	; 0x04
    3570:	88 27       	eor	r24, r24
    3572:	77 fd       	sbrc	r23, 7
    3574:	80 95       	com	r24
    3576:	98 2f       	mov	r25, r24
    3578:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    357c:	9b 01       	movw	r18, r22
    357e:	ac 01       	movw	r20, r24
    3580:	c8 01       	movw	r24, r16
    3582:	b7 01       	movw	r22, r14
    3584:	0e 94 6a 22 	call	0x44d4	; 0x44d4 <Limiterf>
    3588:	f5 01       	movw	r30, r10
    358a:	60 83       	st	Z, r22
    358c:	71 83       	std	Z+1, r23	; 0x01
    358e:	82 83       	std	Z+2, r24	; 0x02
    3590:	93 83       	std	Z+3, r25	; 0x03
	    PID_Term->D= Limiterf(PID_Term->D, PID_Params._DLimit);
    3592:	e0 84       	ldd	r14, Z+8	; 0x08
    3594:	f1 84       	ldd	r15, Z+9	; 0x09
    3596:	02 85       	ldd	r16, Z+10	; 0x0a
    3598:	13 85       	ldd	r17, Z+11	; 0x0b
    359a:	6b 85       	ldd	r22, Y+11	; 0x0b
    359c:	7c 85       	ldd	r23, Y+12	; 0x0c
    359e:	88 27       	eor	r24, r24
    35a0:	77 fd       	sbrc	r23, 7
    35a2:	80 95       	com	r24
    35a4:	98 2f       	mov	r25, r24
    35a6:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    35aa:	9b 01       	movw	r18, r22
    35ac:	ac 01       	movw	r20, r24
    35ae:	c8 01       	movw	r24, r16
    35b0:	b7 01       	movw	r22, r14
    35b2:	0e 94 6a 22 	call	0x44d4	; 0x44d4 <Limiterf>
    35b6:	7b 01       	movw	r14, r22
    35b8:	8c 01       	movw	r16, r24
    35ba:	f5 01       	movw	r30, r10
    35bc:	60 87       	std	Z+8, r22	; 0x08
    35be:	71 87       	std	Z+9, r23	; 0x09
    35c0:	82 87       	std	Z+10, r24	; 0x0a
    35c2:	93 87       	std	Z+11, r25	; 0x0b
	
		Output = (PID_Term->P + PID_Term->I + PID_Term->D);	// P + I + D
    35c4:	60 81       	ld	r22, Z
    35c6:	71 81       	ldd	r23, Z+1	; 0x01
    35c8:	82 81       	ldd	r24, Z+2	; 0x02
    35ca:	93 81       	ldd	r25, Z+3	; 0x03
    35cc:	24 81       	ldd	r18, Z+4	; 0x04
    35ce:	35 81       	ldd	r19, Z+5	; 0x05
    35d0:	46 81       	ldd	r20, Z+6	; 0x06
    35d2:	57 81       	ldd	r21, Z+7	; 0x07
    35d4:	0e 94 12 37 	call	0x6e24	; 0x6e24 <__addsf3>
    35d8:	a8 01       	movw	r20, r16
    35da:	97 01       	movw	r18, r14
    35dc:	0e 94 12 37 	call	0x6e24	; 0x6e24 <__addsf3>
		//Output = Output / 10;
		return  Output; //Limiter(Output,(int16_t)300);
}		
    35e0:	2e 96       	adiw	r28, 0x0e	; 14
    35e2:	0f b6       	in	r0, 0x3f	; 63
    35e4:	f8 94       	cli
    35e6:	de bf       	out	0x3e, r29	; 62
    35e8:	0f be       	out	0x3f, r0	; 63
    35ea:	cd bf       	out	0x3d, r28	; 61
    35ec:	cf 91       	pop	r28
    35ee:	df 91       	pop	r29
    35f0:	1f 91       	pop	r17
    35f2:	0f 91       	pop	r16
    35f4:	ff 90       	pop	r15
    35f6:	ef 90       	pop	r14
    35f8:	df 90       	pop	r13
    35fa:	cf 90       	pop	r12
    35fc:	bf 90       	pop	r11
    35fe:	af 90       	pop	r10
    3600:	08 95       	ret

00003602 <ZERO_Is>:

void ZERO_Is()
{
	PID_GyroTerms[PITCH_INDEX].I=0;
    3602:	80 e0       	ldi	r24, 0x00	; 0
    3604:	90 e0       	ldi	r25, 0x00	; 0
    3606:	dc 01       	movw	r26, r24
    3608:	80 93 58 06 	sts	0x0658, r24
    360c:	90 93 59 06 	sts	0x0659, r25
    3610:	a0 93 5a 06 	sts	0x065A, r26
    3614:	b0 93 5b 06 	sts	0x065B, r27
	PID_GyroTerms[ROLL_INDEX].I=0;
    3618:	80 93 70 06 	sts	0x0670, r24
    361c:	90 93 71 06 	sts	0x0671, r25
    3620:	a0 93 72 06 	sts	0x0672, r26
    3624:	b0 93 73 06 	sts	0x0673, r27
	PID_GyroTerms[YAW_INDEX].I=0;
    3628:	80 93 88 06 	sts	0x0688, r24
    362c:	90 93 89 06 	sts	0x0689, r25
    3630:	a0 93 8a 06 	sts	0x068A, r26
    3634:	b0 93 8b 06 	sts	0x068B, r27
	PID_AccTerms[PITCH_INDEX].I=0;
    3638:	80 93 40 05 	sts	0x0540, r24
    363c:	90 93 41 05 	sts	0x0541, r25
    3640:	a0 93 42 05 	sts	0x0542, r26
    3644:	b0 93 43 05 	sts	0x0543, r27
	PID_AccTerms[ROLL_INDEX].I=0;
    3648:	80 93 58 05 	sts	0x0558, r24
    364c:	90 93 59 05 	sts	0x0559, r25
    3650:	a0 93 5a 05 	sts	0x055A, r26
    3654:	b0 93 5b 05 	sts	0x055B, r27
	PID_AccTerms[Z_INDEX].I=0;
    3658:	80 93 70 05 	sts	0x0570, r24
    365c:	90 93 71 05 	sts	0x0571, r25
    3660:	a0 93 72 05 	sts	0x0572, r26
    3664:	b0 93 73 05 	sts	0x0573, r27

	PID_SonarTerms[0].I=0;
    3668:	80 93 c5 06 	sts	0x06C5, r24
    366c:	90 93 c6 06 	sts	0x06C6, r25
    3670:	a0 93 c7 06 	sts	0x06C7, r26
    3674:	b0 93 c8 06 	sts	0x06C8, r27
}
    3678:	08 95       	ret

0000367a <RotateV>:
//#include "../Include/DCM.h"


// Rotate Estimated vector(s) with small angle approximation, according to the gyro data
void RotateV() 
{
    367a:	2f 92       	push	r2
    367c:	3f 92       	push	r3
    367e:	4f 92       	push	r4
    3680:	5f 92       	push	r5
    3682:	6f 92       	push	r6
    3684:	7f 92       	push	r7
    3686:	8f 92       	push	r8
    3688:	9f 92       	push	r9
    368a:	af 92       	push	r10
    368c:	bf 92       	push	r11
    368e:	cf 92       	push	r12
    3690:	df 92       	push	r13
    3692:	ef 92       	push	r14
    3694:	ff 92       	push	r15
    3696:	0f 93       	push	r16
    3698:	1f 93       	push	r17
    369a:	df 93       	push	r29
    369c:	cf 93       	push	r28
    369e:	cd b7       	in	r28, 0x3d	; 61
    36a0:	de b7       	in	r29, 0x3e	; 62
    36a2:	28 97       	sbiw	r28, 0x08	; 8
    36a4:	0f b6       	in	r0, 0x3f	; 63
    36a6:	f8 94       	cli
    36a8:	de bf       	out	0x3e, r29	; 62
    36aa:	0f be       	out	0x3f, r0	; 63
    36ac:	cd bf       	out	0x3d, r28	; 61
	  //fp_vector v_tmp = *v;
	  //v->Z -= delta[ROLL]  * v_tmp.X + delta[PITCH] * v_tmp.Y;
	  //v->X += delta[ROLL]  * v_tmp.Z - delta[YAW]   * v_tmp.Y;
	  //v->Y += delta[PITCH] * v_tmp.Z + delta[YAW]   * v_tmp.X; 
	//*/
	double oAnglePitch = AnglePitch;
    36ae:	60 90 04 06 	lds	r6, 0x0604
    36b2:	70 90 05 06 	lds	r7, 0x0605
    36b6:	80 90 06 06 	lds	r8, 0x0606
    36ba:	90 90 07 06 	lds	r9, 0x0607
	double oAngleRoll = AngleRoll;
    36be:	80 91 ba 06 	lds	r24, 0x06BA
    36c2:	90 91 bb 06 	lds	r25, 0x06BB
    36c6:	a0 91 bc 06 	lds	r26, 0x06BC
    36ca:	b0 91 bd 06 	lds	r27, 0x06BD
    36ce:	89 83       	std	Y+1, r24	; 0x01
    36d0:	9a 83       	std	Y+2, r25	; 0x02
    36d2:	ab 83       	std	Y+3, r26	; 0x03
    36d4:	bc 83       	std	Y+4, r27	; 0x04
	double oAngleZ     = AngleZ     ;
    36d6:	80 91 4a 06 	lds	r24, 0x064A
    36da:	90 91 4b 06 	lds	r25, 0x064B
    36de:	a0 91 4c 06 	lds	r26, 0x064C
    36e2:	b0 91 4d 06 	lds	r27, 0x064D
	AngleZ     -= (CompGyroRoll  * oAngleRoll )  * GYRO_RATE + ( CompGyroPitch * oAnglePitch) * GYRO_RATE;
    36e6:	20 90 4a 06 	lds	r2, 0x064A
    36ea:	30 90 4b 06 	lds	r3, 0x064B
    36ee:	40 90 4c 06 	lds	r4, 0x064C
    36f2:	50 90 4d 06 	lds	r5, 0x064D
    36f6:	e0 90 50 06 	lds	r14, 0x0650
    36fa:	f0 90 51 06 	lds	r15, 0x0651
    36fe:	00 91 52 06 	lds	r16, 0x0652
    3702:	10 91 53 06 	lds	r17, 0x0653
    3706:	80 91 ce 05 	lds	r24, 0x05CE
    370a:	90 91 cf 05 	lds	r25, 0x05CF
    370e:	a0 91 d0 05 	lds	r26, 0x05D0
    3712:	b0 91 d1 05 	lds	r27, 0x05D1
    3716:	8d 83       	std	Y+5, r24	; 0x05
    3718:	9e 83       	std	Y+6, r25	; 0x06
    371a:	af 83       	std	Y+7, r26	; 0x07
    371c:	b8 87       	std	Y+8, r27	; 0x08
    371e:	c8 01       	movw	r24, r16
    3720:	b7 01       	movw	r22, r14
    3722:	29 81       	ldd	r18, Y+1	; 0x01
    3724:	3a 81       	ldd	r19, Y+2	; 0x02
    3726:	4b 81       	ldd	r20, Y+3	; 0x03
    3728:	5c 81       	ldd	r21, Y+4	; 0x04
    372a:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    372e:	2b e1       	ldi	r18, 0x1B	; 27
    3730:	3f e2       	ldi	r19, 0x2F	; 47
    3732:	4d ed       	ldi	r20, 0xDD	; 221
    3734:	5c e3       	ldi	r21, 0x3C	; 60
    3736:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    373a:	5b 01       	movw	r10, r22
    373c:	6c 01       	movw	r12, r24
    373e:	6d 81       	ldd	r22, Y+5	; 0x05
    3740:	7e 81       	ldd	r23, Y+6	; 0x06
    3742:	8f 81       	ldd	r24, Y+7	; 0x07
    3744:	98 85       	ldd	r25, Y+8	; 0x08
    3746:	a4 01       	movw	r20, r8
    3748:	93 01       	movw	r18, r6
    374a:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    374e:	2b e1       	ldi	r18, 0x1B	; 27
    3750:	3f e2       	ldi	r19, 0x2F	; 47
    3752:	4d ed       	ldi	r20, 0xDD	; 221
    3754:	5c e3       	ldi	r21, 0x3C	; 60
    3756:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    375a:	9b 01       	movw	r18, r22
    375c:	ac 01       	movw	r20, r24
    375e:	c6 01       	movw	r24, r12
    3760:	b5 01       	movw	r22, r10
    3762:	0e 94 12 37 	call	0x6e24	; 0x6e24 <__addsf3>
    3766:	9b 01       	movw	r18, r22
    3768:	ac 01       	movw	r20, r24
    376a:	c2 01       	movw	r24, r4
    376c:	b1 01       	movw	r22, r2
    376e:	0e 94 11 37 	call	0x6e22	; 0x6e22 <__subsf3>
    3772:	9b 01       	movw	r18, r22
    3774:	ac 01       	movw	r20, r24
    3776:	20 93 4a 06 	sts	0x064A, r18
    377a:	30 93 4b 06 	sts	0x064B, r19
    377e:	40 93 4c 06 	sts	0x064C, r20
    3782:	50 93 4d 06 	sts	0x064D, r21
	AngleRoll  += (CompGyroRoll  * AngleZ )     * GYRO_RATE - ( CompGyroZ     * oAnglePitch) * GYRO_RATE;
    3786:	20 90 ba 06 	lds	r2, 0x06BA
    378a:	30 90 bb 06 	lds	r3, 0x06BB
    378e:	40 90 bc 06 	lds	r4, 0x06BC
    3792:	50 90 bd 06 	lds	r5, 0x06BD
    3796:	20 91 4a 06 	lds	r18, 0x064A
    379a:	30 91 4b 06 	lds	r19, 0x064B
    379e:	40 91 4c 06 	lds	r20, 0x064C
    37a2:	50 91 4d 06 	lds	r21, 0x064D
    37a6:	a0 90 0b 06 	lds	r10, 0x060B
    37aa:	b0 90 0c 06 	lds	r11, 0x060C
    37ae:	c0 90 0d 06 	lds	r12, 0x060D
    37b2:	d0 90 0e 06 	lds	r13, 0x060E
    37b6:	c8 01       	movw	r24, r16
    37b8:	b7 01       	movw	r22, r14
    37ba:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    37be:	2b e1       	ldi	r18, 0x1B	; 27
    37c0:	3f e2       	ldi	r19, 0x2F	; 47
    37c2:	4d ed       	ldi	r20, 0xDD	; 221
    37c4:	5c e3       	ldi	r21, 0x3C	; 60
    37c6:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    37ca:	7b 01       	movw	r14, r22
    37cc:	8c 01       	movw	r16, r24
    37ce:	c6 01       	movw	r24, r12
    37d0:	b5 01       	movw	r22, r10
    37d2:	a4 01       	movw	r20, r8
    37d4:	93 01       	movw	r18, r6
    37d6:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    37da:	2b e1       	ldi	r18, 0x1B	; 27
    37dc:	3f e2       	ldi	r19, 0x2F	; 47
    37de:	4d ed       	ldi	r20, 0xDD	; 221
    37e0:	5c e3       	ldi	r21, 0x3C	; 60
    37e2:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    37e6:	9b 01       	movw	r18, r22
    37e8:	ac 01       	movw	r20, r24
    37ea:	c8 01       	movw	r24, r16
    37ec:	b7 01       	movw	r22, r14
    37ee:	0e 94 11 37 	call	0x6e22	; 0x6e22 <__subsf3>
    37f2:	9b 01       	movw	r18, r22
    37f4:	ac 01       	movw	r20, r24
    37f6:	c2 01       	movw	r24, r4
    37f8:	b1 01       	movw	r22, r2
    37fa:	0e 94 12 37 	call	0x6e24	; 0x6e24 <__addsf3>
    37fe:	9b 01       	movw	r18, r22
    3800:	ac 01       	movw	r20, r24
    3802:	20 93 ba 06 	sts	0x06BA, r18
    3806:	30 93 bb 06 	sts	0x06BB, r19
    380a:	40 93 bc 06 	sts	0x06BC, r20
    380e:	50 93 bd 06 	sts	0x06BD, r21
	AnglePitch += (CompGyroPitch * AngleZ )		* GYRO_RATE + ( CompGyroZ     * oAngleRoll ) * GYRO_RATE;
    3812:	60 90 04 06 	lds	r6, 0x0604
    3816:	70 90 05 06 	lds	r7, 0x0605
    381a:	80 90 06 06 	lds	r8, 0x0606
    381e:	90 90 07 06 	lds	r9, 0x0607
    3822:	20 91 4a 06 	lds	r18, 0x064A
    3826:	30 91 4b 06 	lds	r19, 0x064B
    382a:	40 91 4c 06 	lds	r20, 0x064C
    382e:	50 91 4d 06 	lds	r21, 0x064D
    3832:	6d 81       	ldd	r22, Y+5	; 0x05
    3834:	7e 81       	ldd	r23, Y+6	; 0x06
    3836:	8f 81       	ldd	r24, Y+7	; 0x07
    3838:	98 85       	ldd	r25, Y+8	; 0x08
    383a:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    383e:	2b e1       	ldi	r18, 0x1B	; 27
    3840:	3f e2       	ldi	r19, 0x2F	; 47
    3842:	4d ed       	ldi	r20, 0xDD	; 221
    3844:	5c e3       	ldi	r21, 0x3C	; 60
    3846:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    384a:	7b 01       	movw	r14, r22
    384c:	8c 01       	movw	r16, r24
    384e:	c6 01       	movw	r24, r12
    3850:	b5 01       	movw	r22, r10
    3852:	29 81       	ldd	r18, Y+1	; 0x01
    3854:	3a 81       	ldd	r19, Y+2	; 0x02
    3856:	4b 81       	ldd	r20, Y+3	; 0x03
    3858:	5c 81       	ldd	r21, Y+4	; 0x04
    385a:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    385e:	2b e1       	ldi	r18, 0x1B	; 27
    3860:	3f e2       	ldi	r19, 0x2F	; 47
    3862:	4d ed       	ldi	r20, 0xDD	; 221
    3864:	5c e3       	ldi	r21, 0x3C	; 60
    3866:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    386a:	9b 01       	movw	r18, r22
    386c:	ac 01       	movw	r20, r24
    386e:	c8 01       	movw	r24, r16
    3870:	b7 01       	movw	r22, r14
    3872:	0e 94 12 37 	call	0x6e24	; 0x6e24 <__addsf3>
    3876:	9b 01       	movw	r18, r22
    3878:	ac 01       	movw	r20, r24
    387a:	c4 01       	movw	r24, r8
    387c:	b3 01       	movw	r22, r6
    387e:	0e 94 12 37 	call	0x6e24	; 0x6e24 <__addsf3>
    3882:	9b 01       	movw	r18, r22
    3884:	ac 01       	movw	r20, r24
    3886:	20 93 04 06 	sts	0x0604, r18
    388a:	30 93 05 06 	sts	0x0605, r19
    388e:	40 93 06 06 	sts	0x0606, r20
    3892:	50 93 07 06 	sts	0x0607, r21

}
    3896:	28 96       	adiw	r28, 0x08	; 8
    3898:	0f b6       	in	r0, 0x3f	; 63
    389a:	f8 94       	cli
    389c:	de bf       	out	0x3e, r29	; 62
    389e:	0f be       	out	0x3f, r0	; 63
    38a0:	cd bf       	out	0x3d, r28	; 61
    38a2:	cf 91       	pop	r28
    38a4:	df 91       	pop	r29
    38a6:	1f 91       	pop	r17
    38a8:	0f 91       	pop	r16
    38aa:	ff 90       	pop	r15
    38ac:	ef 90       	pop	r14
    38ae:	df 90       	pop	r13
    38b0:	cf 90       	pop	r12
    38b2:	bf 90       	pop	r11
    38b4:	af 90       	pop	r10
    38b6:	9f 90       	pop	r9
    38b8:	8f 90       	pop	r8
    38ba:	7f 90       	pop	r7
    38bc:	6f 90       	pop	r6
    38be:	5f 90       	pop	r5
    38c0:	4f 90       	pop	r4
    38c2:	3f 90       	pop	r3
    38c4:	2f 90       	pop	r2
    38c6:	08 95       	ret

000038c8 <IMU_Reset>:


void IMU_Reset()
{
	
	AnglePitch=0;
    38c8:	80 e0       	ldi	r24, 0x00	; 0
    38ca:	90 e0       	ldi	r25, 0x00	; 0
    38cc:	dc 01       	movw	r26, r24
    38ce:	80 93 04 06 	sts	0x0604, r24
    38d2:	90 93 05 06 	sts	0x0605, r25
    38d6:	a0 93 06 06 	sts	0x0606, r26
    38da:	b0 93 07 06 	sts	0x0607, r27
	AngleRoll=0;
    38de:	80 93 ba 06 	sts	0x06BA, r24
    38e2:	90 93 bb 06 	sts	0x06BB, r25
    38e6:	a0 93 bc 06 	sts	0x06BC, r26
    38ea:	b0 93 bd 06 	sts	0x06BD, r27
	AngleZ=0;
    38ee:	80 93 4a 06 	sts	0x064A, r24
    38f2:	90 93 4b 06 	sts	0x064B, r25
    38f6:	a0 93 4c 06 	sts	0x064C, r26
    38fa:	b0 93 4d 06 	sts	0x064D, r27
	
}
    38fe:	08 95       	ret

00003900 <IMU>:
//////////////////////////////////////////////////////////////////////////
// inspired by link: http://scolton.blogspot.com/2012/09/a-bit-more-kk20-modding.html
// Although I implement PID and super position in http://hefnycopter.net/index.php/developing-source-code/22-quadcopter-control-function-layers.html
void IMU (void)
{
    3900:	2f 92       	push	r2
    3902:	3f 92       	push	r3
    3904:	4f 92       	push	r4
    3906:	5f 92       	push	r5
    3908:	6f 92       	push	r6
    390a:	7f 92       	push	r7
    390c:	8f 92       	push	r8
    390e:	9f 92       	push	r9
    3910:	af 92       	push	r10
    3912:	bf 92       	push	r11
    3914:	cf 92       	push	r12
    3916:	df 92       	push	r13
    3918:	ef 92       	push	r14
    391a:	ff 92       	push	r15
    391c:	0f 93       	push	r16
    391e:	1f 93       	push	r17
    3920:	cf 93       	push	r28
    3922:	df 93       	push	r29
	
		double Alpha;	
		double Beta;
	
	    // calculate ACC-Z
		Alpha = Config.AccParams[Z_INDEX].ComplementaryFilterAlpha / 1000.0;
    3924:	60 91 39 07 	lds	r22, 0x0739
    3928:	70 91 3a 07 	lds	r23, 0x073A
    392c:	88 27       	eor	r24, r24
    392e:	77 fd       	sbrc	r23, 7
    3930:	80 95       	com	r24
    3932:	98 2f       	mov	r25, r24
    3934:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    3938:	20 e0       	ldi	r18, 0x00	; 0
    393a:	30 e0       	ldi	r19, 0x00	; 0
    393c:	4a e7       	ldi	r20, 0x7A	; 122
    393e:	54 e4       	ldi	r21, 0x44	; 68
    3940:	0e 94 7a 37 	call	0x6ef4	; 0x6ef4 <__divsf3>
    3944:	7b 01       	movw	r14, r22
    3946:	8c 01       	movw	r16, r24
		Beta = 1- Alpha; // complementary filter to remove noise
		CompAccZ = (double) (Alpha * CompAccZ) + (double) (Beta * Sensors_Latest[ACC_Z_Index]);
    3948:	c0 90 33 06 	lds	r12, 0x0633
    394c:	d0 90 34 06 	lds	r13, 0x0634
    3950:	7f 2d       	mov	r23, r15
    3952:	91 2f       	mov	r25, r17
    3954:	20 91 25 06 	lds	r18, 0x0625
    3958:	30 91 26 06 	lds	r19, 0x0626
    395c:	40 91 27 06 	lds	r20, 0x0627
    3960:	50 91 28 06 	lds	r21, 0x0628
    3964:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    3968:	3b 01       	movw	r6, r22
    396a:	4c 01       	movw	r8, r24
		double Alpha;	
		double Beta;
	
	    // calculate ACC-Z
		Alpha = Config.AccParams[Z_INDEX].ComplementaryFilterAlpha / 1000.0;
		Beta = 1- Alpha; // complementary filter to remove noise
    396c:	60 e0       	ldi	r22, 0x00	; 0
    396e:	70 e0       	ldi	r23, 0x00	; 0
    3970:	80 e8       	ldi	r24, 0x80	; 128
    3972:	9f e3       	ldi	r25, 0x3F	; 63
    3974:	2e 2d       	mov	r18, r14
    3976:	3f 2d       	mov	r19, r15
    3978:	40 2f       	mov	r20, r16
    397a:	51 2f       	mov	r21, r17
    397c:	0e 94 11 37 	call	0x6e22	; 0x6e22 <__subsf3>
    3980:	7b 01       	movw	r14, r22
    3982:	8c 01       	movw	r16, r24
		CompAccZ = (double) (Alpha * CompAccZ) + (double) (Beta * Sensors_Latest[ACC_Z_Index]);
    3984:	b6 01       	movw	r22, r12
    3986:	88 27       	eor	r24, r24
    3988:	77 fd       	sbrc	r23, 7
    398a:	80 95       	com	r24
    398c:	98 2f       	mov	r25, r24
    398e:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    3992:	9b 01       	movw	r18, r22
    3994:	ac 01       	movw	r20, r24
    3996:	c8 01       	movw	r24, r16
    3998:	b7 01       	movw	r22, r14
    399a:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    399e:	9b 01       	movw	r18, r22
    39a0:	ac 01       	movw	r20, r24
    39a2:	c4 01       	movw	r24, r8
    39a4:	b3 01       	movw	r22, r6
    39a6:	0e 94 12 37 	call	0x6e24	; 0x6e24 <__addsf3>
    39aa:	60 93 25 06 	sts	0x0625, r22
    39ae:	70 93 26 06 	sts	0x0626, r23
    39b2:	80 93 27 06 	sts	0x0627, r24
    39b6:	90 93 28 06 	sts	0x0628, r25
		
		// calculate YAW
		Alpha = Config.GyroParams[YAW_INDEX].ComplementaryFilterAlpha / 1000.0;
    39ba:	60 91 0f 07 	lds	r22, 0x070F
    39be:	70 91 10 07 	lds	r23, 0x0710
    39c2:	88 27       	eor	r24, r24
    39c4:	77 fd       	sbrc	r23, 7
    39c6:	80 95       	com	r24
    39c8:	98 2f       	mov	r25, r24
    39ca:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    39ce:	20 e0       	ldi	r18, 0x00	; 0
    39d0:	30 e0       	ldi	r19, 0x00	; 0
    39d2:	4a e7       	ldi	r20, 0x7A	; 122
    39d4:	54 e4       	ldi	r21, 0x44	; 68
    39d6:	0e 94 7a 37 	call	0x6ef4	; 0x6ef4 <__divsf3>
    39da:	7b 01       	movw	r14, r22
    39dc:	8c 01       	movw	r16, r24
		Beta = 1- Alpha; // complementary filter to remove noise
		CompGyroZ = (double) (Alpha * CompGyroZ) + (double) (Beta * Sensors_Latest[GYRO_Z_Index]);
    39de:	c0 90 2d 06 	lds	r12, 0x062D
    39e2:	d0 90 2e 06 	lds	r13, 0x062E
    39e6:	7f 2d       	mov	r23, r15
    39e8:	91 2f       	mov	r25, r17
    39ea:	20 91 0b 06 	lds	r18, 0x060B
    39ee:	30 91 0c 06 	lds	r19, 0x060C
    39f2:	40 91 0d 06 	lds	r20, 0x060D
    39f6:	50 91 0e 06 	lds	r21, 0x060E
    39fa:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    39fe:	3b 01       	movw	r6, r22
    3a00:	4c 01       	movw	r8, r24
		Beta = 1- Alpha; // complementary filter to remove noise
		CompAccZ = (double) (Alpha * CompAccZ) + (double) (Beta * Sensors_Latest[ACC_Z_Index]);
		
		// calculate YAW
		Alpha = Config.GyroParams[YAW_INDEX].ComplementaryFilterAlpha / 1000.0;
		Beta = 1- Alpha; // complementary filter to remove noise
    3a02:	60 e0       	ldi	r22, 0x00	; 0
    3a04:	70 e0       	ldi	r23, 0x00	; 0
    3a06:	80 e8       	ldi	r24, 0x80	; 128
    3a08:	9f e3       	ldi	r25, 0x3F	; 63
    3a0a:	2e 2d       	mov	r18, r14
    3a0c:	3f 2d       	mov	r19, r15
    3a0e:	40 2f       	mov	r20, r16
    3a10:	51 2f       	mov	r21, r17
    3a12:	0e 94 11 37 	call	0x6e22	; 0x6e22 <__subsf3>
    3a16:	7b 01       	movw	r14, r22
    3a18:	8c 01       	movw	r16, r24
		CompGyroZ = (double) (Alpha * CompGyroZ) + (double) (Beta * Sensors_Latest[GYRO_Z_Index]);
    3a1a:	b6 01       	movw	r22, r12
    3a1c:	88 27       	eor	r24, r24
    3a1e:	77 fd       	sbrc	r23, 7
    3a20:	80 95       	com	r24
    3a22:	98 2f       	mov	r25, r24
    3a24:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    3a28:	9b 01       	movw	r18, r22
    3a2a:	ac 01       	movw	r20, r24
    3a2c:	c8 01       	movw	r24, r16
    3a2e:	b7 01       	movw	r22, r14
    3a30:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    3a34:	9b 01       	movw	r18, r22
    3a36:	ac 01       	movw	r20, r24
    3a38:	c4 01       	movw	r24, r8
    3a3a:	b3 01       	movw	r22, r6
    3a3c:	0e 94 12 37 	call	0x6e24	; 0x6e24 <__addsf3>
    3a40:	60 93 0b 06 	sts	0x060B, r22
    3a44:	70 93 0c 06 	sts	0x060C, r23
    3a48:	80 93 0d 06 	sts	0x060D, r24
    3a4c:	90 93 0e 06 	sts	0x060E, r25
		
		Alpha = Config.GyroParams[PITCH_INDEX].ComplementaryFilterAlpha / 1000.0;
    3a50:	60 91 f3 06 	lds	r22, 0x06F3
    3a54:	70 91 f4 06 	lds	r23, 0x06F4
    3a58:	88 27       	eor	r24, r24
    3a5a:	77 fd       	sbrc	r23, 7
    3a5c:	80 95       	com	r24
    3a5e:	98 2f       	mov	r25, r24
    3a60:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    3a64:	20 e0       	ldi	r18, 0x00	; 0
    3a66:	30 e0       	ldi	r19, 0x00	; 0
    3a68:	4a e7       	ldi	r20, 0x7A	; 122
    3a6a:	54 e4       	ldi	r21, 0x44	; 68
    3a6c:	0e 94 7a 37 	call	0x6ef4	; 0x6ef4 <__divsf3>
    3a70:	7b 01       	movw	r14, r22
    3a72:	8c 01       	movw	r16, r24
		Beta = 1- Alpha; // complementary filter to remove noise
		CompGyroPitch = (double) (Alpha * CompGyroPitch) + (double) (Beta * Sensors_Latest[GYRO_PITCH_Index]);
    3a74:	c0 90 2b 06 	lds	r12, 0x062B
    3a78:	d0 90 2c 06 	lds	r13, 0x062C
    3a7c:	7f 2d       	mov	r23, r15
    3a7e:	91 2f       	mov	r25, r17
    3a80:	20 91 ce 05 	lds	r18, 0x05CE
    3a84:	30 91 cf 05 	lds	r19, 0x05CF
    3a88:	40 91 d0 05 	lds	r20, 0x05D0
    3a8c:	50 91 d1 05 	lds	r21, 0x05D1
    3a90:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    3a94:	3b 01       	movw	r6, r22
    3a96:	4c 01       	movw	r8, r24
		Alpha = Config.GyroParams[YAW_INDEX].ComplementaryFilterAlpha / 1000.0;
		Beta = 1- Alpha; // complementary filter to remove noise
		CompGyroZ = (double) (Alpha * CompGyroZ) + (double) (Beta * Sensors_Latest[GYRO_Z_Index]);
		
		Alpha = Config.GyroParams[PITCH_INDEX].ComplementaryFilterAlpha / 1000.0;
		Beta = 1- Alpha; // complementary filter to remove noise
    3a98:	60 e0       	ldi	r22, 0x00	; 0
    3a9a:	70 e0       	ldi	r23, 0x00	; 0
    3a9c:	80 e8       	ldi	r24, 0x80	; 128
    3a9e:	9f e3       	ldi	r25, 0x3F	; 63
    3aa0:	2e 2d       	mov	r18, r14
    3aa2:	3f 2d       	mov	r19, r15
    3aa4:	40 2f       	mov	r20, r16
    3aa6:	51 2f       	mov	r21, r17
    3aa8:	0e 94 11 37 	call	0x6e22	; 0x6e22 <__subsf3>
    3aac:	7b 01       	movw	r14, r22
    3aae:	8c 01       	movw	r16, r24
		CompGyroPitch = (double) (Alpha * CompGyroPitch) + (double) (Beta * Sensors_Latest[GYRO_PITCH_Index]);
    3ab0:	b6 01       	movw	r22, r12
    3ab2:	88 27       	eor	r24, r24
    3ab4:	77 fd       	sbrc	r23, 7
    3ab6:	80 95       	com	r24
    3ab8:	98 2f       	mov	r25, r24
    3aba:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    3abe:	9b 01       	movw	r18, r22
    3ac0:	ac 01       	movw	r20, r24
    3ac2:	c8 01       	movw	r24, r16
    3ac4:	b7 01       	movw	r22, r14
    3ac6:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    3aca:	9b 01       	movw	r18, r22
    3acc:	ac 01       	movw	r20, r24
    3ace:	c4 01       	movw	r24, r8
    3ad0:	b3 01       	movw	r22, r6
    3ad2:	0e 94 12 37 	call	0x6e24	; 0x6e24 <__addsf3>
    3ad6:	a6 2e       	mov	r10, r22
    3ad8:	d7 2e       	mov	r13, r23
    3ada:	c8 2e       	mov	r12, r24
    3adc:	b9 2e       	mov	r11, r25
    3ade:	86 2f       	mov	r24, r22
    3ae0:	9d 2d       	mov	r25, r13
    3ae2:	ac 2d       	mov	r26, r12
    3ae4:	bb 2d       	mov	r27, r11
    3ae6:	80 93 ce 05 	sts	0x05CE, r24
    3aea:	90 93 cf 05 	sts	0x05CF, r25
    3aee:	a0 93 d0 05 	sts	0x05D0, r26
    3af2:	b0 93 d1 05 	sts	0x05D1, r27
		Alpha = Config.GyroParams[ROLL_INDEX].ComplementaryFilterAlpha / 1000.0;
    3af6:	60 91 01 07 	lds	r22, 0x0701
    3afa:	70 91 02 07 	lds	r23, 0x0702
    3afe:	88 27       	eor	r24, r24
    3b00:	77 fd       	sbrc	r23, 7
    3b02:	80 95       	com	r24
    3b04:	98 2f       	mov	r25, r24
    3b06:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    3b0a:	20 e0       	ldi	r18, 0x00	; 0
    3b0c:	30 e0       	ldi	r19, 0x00	; 0
    3b0e:	4a e7       	ldi	r20, 0x7A	; 122
    3b10:	54 e4       	ldi	r21, 0x44	; 68
    3b12:	0e 94 7a 37 	call	0x6ef4	; 0x6ef4 <__divsf3>
    3b16:	7b 01       	movw	r14, r22
    3b18:	8c 01       	movw	r16, r24
		Beta = 1- Alpha; // complementary filter to remove noise
		CompGyroRoll  = (double) (Alpha * CompGyroRoll)  + (double) (Beta * Sensors_Latest[GYRO_ROLL_Index]);
    3b1a:	c0 91 29 06 	lds	r28, 0x0629
    3b1e:	d0 91 2a 06 	lds	r29, 0x062A
    3b22:	7f 2d       	mov	r23, r15
    3b24:	91 2f       	mov	r25, r17
    3b26:	20 91 50 06 	lds	r18, 0x0650
    3b2a:	30 91 51 06 	lds	r19, 0x0651
    3b2e:	40 91 52 06 	lds	r20, 0x0652
    3b32:	50 91 53 06 	lds	r21, 0x0653
    3b36:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    3b3a:	3b 01       	movw	r6, r22
    3b3c:	4c 01       	movw	r8, r24
		
		Alpha = Config.GyroParams[PITCH_INDEX].ComplementaryFilterAlpha / 1000.0;
		Beta = 1- Alpha; // complementary filter to remove noise
		CompGyroPitch = (double) (Alpha * CompGyroPitch) + (double) (Beta * Sensors_Latest[GYRO_PITCH_Index]);
		Alpha = Config.GyroParams[ROLL_INDEX].ComplementaryFilterAlpha / 1000.0;
		Beta = 1- Alpha; // complementary filter to remove noise
    3b3e:	60 e0       	ldi	r22, 0x00	; 0
    3b40:	70 e0       	ldi	r23, 0x00	; 0
    3b42:	80 e8       	ldi	r24, 0x80	; 128
    3b44:	9f e3       	ldi	r25, 0x3F	; 63
    3b46:	2e 2d       	mov	r18, r14
    3b48:	3f 2d       	mov	r19, r15
    3b4a:	40 2f       	mov	r20, r16
    3b4c:	51 2f       	mov	r21, r17
    3b4e:	0e 94 11 37 	call	0x6e22	; 0x6e22 <__subsf3>
    3b52:	7b 01       	movw	r14, r22
    3b54:	8c 01       	movw	r16, r24
		CompGyroRoll  = (double) (Alpha * CompGyroRoll)  + (double) (Beta * Sensors_Latest[GYRO_ROLL_Index]);
    3b56:	be 01       	movw	r22, r28
    3b58:	88 27       	eor	r24, r24
    3b5a:	77 fd       	sbrc	r23, 7
    3b5c:	80 95       	com	r24
    3b5e:	98 2f       	mov	r25, r24
    3b60:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    3b64:	9b 01       	movw	r18, r22
    3b66:	ac 01       	movw	r20, r24
    3b68:	c8 01       	movw	r24, r16
    3b6a:	b7 01       	movw	r22, r14
    3b6c:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    3b70:	9b 01       	movw	r18, r22
    3b72:	ac 01       	movw	r20, r24
    3b74:	c4 01       	movw	r24, r8
    3b76:	b3 01       	movw	r22, r6
    3b78:	0e 94 12 37 	call	0x6e24	; 0x6e24 <__addsf3>
    3b7c:	60 93 50 06 	sts	0x0650, r22
    3b80:	70 93 51 06 	sts	0x0651, r23
    3b84:	80 93 52 06 	sts	0x0652, r24
    3b88:	90 93 53 06 	sts	0x0653, r25
		
					
		// GYRO Always calculated.
		gyroPitch =	PID_Calculate (Config.GyroParams[PITCH_INDEX],	&PID_GyroTerms[PITCH_INDEX],CompGyroPitch);	
    3b8c:	00 d0       	rcall	.+0      	; 0x3b8e <IMU+0x28e>
    3b8e:	00 d0       	rcall	.+0      	; 0x3b90 <IMU+0x290>
    3b90:	8a 2d       	mov	r24, r10
    3b92:	9d 2d       	mov	r25, r13
    3b94:	ac 2d       	mov	r26, r12
    3b96:	bb 2d       	mov	r27, r11
    3b98:	ed b7       	in	r30, 0x3d	; 61
    3b9a:	fe b7       	in	r31, 0x3e	; 62
    3b9c:	81 83       	std	Z+1, r24	; 0x01
    3b9e:	92 83       	std	Z+2, r25	; 0x02
    3ba0:	a3 83       	std	Z+3, r26	; 0x03
    3ba2:	b4 83       	std	Z+4, r27	; 0x04
    3ba4:	c0 90 e7 06 	lds	r12, 0x06E7
    3ba8:	d0 90 e8 06 	lds	r13, 0x06E8
    3bac:	e0 90 e9 06 	lds	r14, 0x06E9
    3bb0:	f0 90 ea 06 	lds	r15, 0x06EA
    3bb4:	00 91 eb 06 	lds	r16, 0x06EB
    3bb8:	10 91 ec 06 	lds	r17, 0x06EC
    3bbc:	20 91 ed 06 	lds	r18, 0x06ED
    3bc0:	30 91 ee 06 	lds	r19, 0x06EE
    3bc4:	40 91 ef 06 	lds	r20, 0x06EF
    3bc8:	50 91 f0 06 	lds	r21, 0x06F0
    3bcc:	60 91 f1 06 	lds	r22, 0x06F1
    3bd0:	70 91 f2 06 	lds	r23, 0x06F2
    3bd4:	80 91 f3 06 	lds	r24, 0x06F3
    3bd8:	90 91 f4 06 	lds	r25, 0x06F4
    3bdc:	a4 e5       	ldi	r26, 0x54	; 84
    3bde:	aa 2e       	mov	r10, r26
    3be0:	a6 e0       	ldi	r26, 0x06	; 6
    3be2:	ba 2e       	mov	r11, r26
    3be4:	0e 94 ff 19 	call	0x33fe	; 0x33fe <PID_Calculate>
    3be8:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <__fixsfsi>
    3bec:	70 93 24 06 	sts	0x0624, r23
    3bf0:	60 93 23 06 	sts	0x0623, r22
		gyroRoll  = PID_Calculate (Config.GyroParams[ROLL_INDEX],	&PID_GyroTerms[ROLL_INDEX],CompGyroRoll); 
    3bf4:	80 91 50 06 	lds	r24, 0x0650
    3bf8:	90 91 51 06 	lds	r25, 0x0651
    3bfc:	a0 91 52 06 	lds	r26, 0x0652
    3c00:	b0 91 53 06 	lds	r27, 0x0653
    3c04:	ed b7       	in	r30, 0x3d	; 61
    3c06:	fe b7       	in	r31, 0x3e	; 62
    3c08:	81 83       	std	Z+1, r24	; 0x01
    3c0a:	92 83       	std	Z+2, r25	; 0x02
    3c0c:	a3 83       	std	Z+3, r26	; 0x03
    3c0e:	b4 83       	std	Z+4, r27	; 0x04
    3c10:	c0 90 f5 06 	lds	r12, 0x06F5
    3c14:	d0 90 f6 06 	lds	r13, 0x06F6
    3c18:	e0 90 f7 06 	lds	r14, 0x06F7
    3c1c:	f0 90 f8 06 	lds	r15, 0x06F8
    3c20:	00 91 f9 06 	lds	r16, 0x06F9
    3c24:	10 91 fa 06 	lds	r17, 0x06FA
    3c28:	20 91 fb 06 	lds	r18, 0x06FB
    3c2c:	30 91 fc 06 	lds	r19, 0x06FC
    3c30:	40 91 fd 06 	lds	r20, 0x06FD
    3c34:	50 91 fe 06 	lds	r21, 0x06FE
    3c38:	60 91 ff 06 	lds	r22, 0x06FF
    3c3c:	70 91 00 07 	lds	r23, 0x0700
    3c40:	80 91 01 07 	lds	r24, 0x0701
    3c44:	90 91 02 07 	lds	r25, 0x0702
    3c48:	fc e6       	ldi	r31, 0x6C	; 108
    3c4a:	af 2e       	mov	r10, r31
    3c4c:	f6 e0       	ldi	r31, 0x06	; 6
    3c4e:	bf 2e       	mov	r11, r31
    3c50:	0e 94 ff 19 	call	0x33fe	; 0x33fe <PID_Calculate>
    3c54:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <__fixsfsi>
    3c58:	70 93 a5 05 	sts	0x05A5, r23
    3c5c:	60 93 a4 05 	sts	0x05A4, r22
		gyroYaw   = PID_Calculate (Config.GyroParams[YAW_INDEX],	&PID_GyroTerms[YAW_INDEX],CompGyroZ -((double)((float)RX_Snapshot[RXChannel_RUD]  * 0.5f))); 
    3c60:	cd b7       	in	r28, 0x3d	; 61
    3c62:	de b7       	in	r29, 0x3e	; 62
    3c64:	21 96       	adiw	r28, 0x01	; 1
    3c66:	60 91 b0 05 	lds	r22, 0x05B0
    3c6a:	70 91 b1 05 	lds	r23, 0x05B1
    3c6e:	88 27       	eor	r24, r24
    3c70:	77 fd       	sbrc	r23, 7
    3c72:	80 95       	com	r24
    3c74:	98 2f       	mov	r25, r24
    3c76:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    3c7a:	20 e0       	ldi	r18, 0x00	; 0
    3c7c:	30 e0       	ldi	r19, 0x00	; 0
    3c7e:	40 e0       	ldi	r20, 0x00	; 0
    3c80:	5f e3       	ldi	r21, 0x3F	; 63
    3c82:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    3c86:	9b 01       	movw	r18, r22
    3c88:	ac 01       	movw	r20, r24
    3c8a:	60 91 0b 06 	lds	r22, 0x060B
    3c8e:	70 91 0c 06 	lds	r23, 0x060C
    3c92:	80 91 0d 06 	lds	r24, 0x060D
    3c96:	90 91 0e 06 	lds	r25, 0x060E
    3c9a:	0e 94 11 37 	call	0x6e22	; 0x6e22 <__subsf3>
    3c9e:	68 83       	st	Y, r22
    3ca0:	79 83       	std	Y+1, r23	; 0x01
    3ca2:	8a 83       	std	Y+2, r24	; 0x02
    3ca4:	9b 83       	std	Y+3, r25	; 0x03
    3ca6:	c0 90 03 07 	lds	r12, 0x0703
    3caa:	d0 90 04 07 	lds	r13, 0x0704
    3cae:	e0 90 05 07 	lds	r14, 0x0705
    3cb2:	f0 90 06 07 	lds	r15, 0x0706
    3cb6:	00 91 07 07 	lds	r16, 0x0707
    3cba:	10 91 08 07 	lds	r17, 0x0708
    3cbe:	20 91 09 07 	lds	r18, 0x0709
    3cc2:	30 91 0a 07 	lds	r19, 0x070A
    3cc6:	40 91 0b 07 	lds	r20, 0x070B
    3cca:	50 91 0c 07 	lds	r21, 0x070C
    3cce:	60 91 0d 07 	lds	r22, 0x070D
    3cd2:	70 91 0e 07 	lds	r23, 0x070E
    3cd6:	80 91 0f 07 	lds	r24, 0x070F
    3cda:	90 91 10 07 	lds	r25, 0x0710
    3cde:	e4 e8       	ldi	r30, 0x84	; 132
    3ce0:	ae 2e       	mov	r10, r30
    3ce2:	e6 e0       	ldi	r30, 0x06	; 6
    3ce4:	be 2e       	mov	r11, r30
    3ce6:	0e 94 ff 19 	call	0x33fe	; 0x33fe <PID_Calculate>
    3cea:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <__fixsfsi>
    3cee:	70 93 c0 06 	sts	0x06C0, r23
    3cf2:	60 93 bf 06 	sts	0x06BF, r22
	
			
		// Read ACC and Trims
		// ACC directions are same as GYRO direction [we added "-" for this purpose] 
		double APitch = - Sensors_Latest[ACC_PITCH_Index] - Config.Acc_Pitch_Trim;
    3cf6:	60 91 2f 06 	lds	r22, 0x062F
    3cfa:	70 91 30 06 	lds	r23, 0x0630
    3cfe:	70 95       	com	r23
    3d00:	61 95       	neg	r22
    3d02:	7f 4f       	sbci	r23, 0xFF	; 255
    3d04:	80 91 4a 07 	lds	r24, 0x074A
    3d08:	99 27       	eor	r25, r25
    3d0a:	87 fd       	sbrc	r24, 7
    3d0c:	90 95       	com	r25
    3d0e:	68 1b       	sub	r22, r24
    3d10:	79 0b       	sbc	r23, r25
    3d12:	88 27       	eor	r24, r24
    3d14:	77 fd       	sbrc	r23, 7
    3d16:	80 95       	com	r24
    3d18:	98 2f       	mov	r25, r24
    3d1a:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    3d1e:	8b 01       	movw	r16, r22
    3d20:	7c 01       	movw	r14, r24
		double ARoll  = - Sensors_Latest[ACC_ROLL_Index]  - Config.Acc_Roll_Trim;
    3d22:	60 91 31 06 	lds	r22, 0x0631
    3d26:	70 91 32 06 	lds	r23, 0x0632
    3d2a:	70 95       	com	r23
    3d2c:	61 95       	neg	r22
    3d2e:	7f 4f       	sbci	r23, 0xFF	; 255
    3d30:	80 91 4b 07 	lds	r24, 0x074B
    3d34:	99 27       	eor	r25, r25
    3d36:	87 fd       	sbrc	r24, 7
    3d38:	90 95       	com	r25
    3d3a:	68 1b       	sub	r22, r24
    3d3c:	79 0b       	sbc	r23, r25
    3d3e:	88 27       	eor	r24, r24
    3d40:	77 fd       	sbrc	r23, 7
    3d42:	80 95       	com	r24
    3d44:	98 2f       	mov	r25, r24
    3d46:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    3d4a:	26 2e       	mov	r2, r22
    3d4c:	57 2e       	mov	r5, r23
    3d4e:	48 2e       	mov	r4, r24
    3d50:	39 2e       	mov	r3, r25
		double DT_YAW =  (double)Sensors_Latest[GYRO_Z_Index] * GYRO_RATE; 
    3d52:	80 91 2d 06 	lds	r24, 0x062D
    3d56:	90 91 2e 06 	lds	r25, 0x062E
						//;
		//AngleRoll = AngleRoll  
				  //+ (double)Sensors_Latest[GYRO_ROLL_Index]  * GYRO_RATE
					 //// - (sin(AnglePitch * DEG_TO_RAD) * DT_YAW)  // integrate component of yaw rate into roll angle
					  //; 
		RotateV();	
    3d5a:	0f 90       	pop	r0
    3d5c:	0f 90       	pop	r0
    3d5e:	0f 90       	pop	r0
    3d60:	0f 90       	pop	r0
    3d62:	0e 94 3d 1b 	call	0x367a	; 0x367a <RotateV>
		// Correct Drift using ACC
		Alpha = Config.AccParams[PITCH_INDEX].ComplementaryFilterAlpha / 1000.0; // TODO: optimize
    3d66:	a0 90 1d 07 	lds	r10, 0x071D
    3d6a:	b0 90 1e 07 	lds	r11, 0x071E
		Beta = 1- Alpha;
		#define ACC_SMALL_ANGLE	40
		// if small angle then correct using ACC
		if ((APitch < ACC_SMALL_ANGLE) && (APitch > -ACC_SMALL_ANGLE)) 
    3d6e:	60 2f       	mov	r22, r16
    3d70:	71 2f       	mov	r23, r17
    3d72:	8e 2d       	mov	r24, r14
    3d74:	9f 2d       	mov	r25, r15
    3d76:	20 e0       	ldi	r18, 0x00	; 0
    3d78:	30 e0       	ldi	r19, 0x00	; 0
    3d7a:	40 e2       	ldi	r20, 0x20	; 32
    3d7c:	52 e4       	ldi	r21, 0x42	; 66
    3d7e:	0e 94 76 37 	call	0x6eec	; 0x6eec <__cmpsf2>
    3d82:	87 ff       	sbrs	r24, 7
    3d84:	50 c0       	rjmp	.+160    	; 0x3e26 <IMU+0x526>
    3d86:	60 2f       	mov	r22, r16
    3d88:	71 2f       	mov	r23, r17
    3d8a:	8e 2d       	mov	r24, r14
    3d8c:	9f 2d       	mov	r25, r15
    3d8e:	20 e0       	ldi	r18, 0x00	; 0
    3d90:	30 e0       	ldi	r19, 0x00	; 0
    3d92:	40 e2       	ldi	r20, 0x20	; 32
    3d94:	52 ec       	ldi	r21, 0xC2	; 194
    3d96:	0e 94 c5 38 	call	0x718a	; 0x718a <__gesf2>
    3d9a:	18 16       	cp	r1, r24
    3d9c:	0c f0       	brlt	.+2      	; 0x3da0 <IMU+0x4a0>
    3d9e:	43 c0       	rjmp	.+134    	; 0x3e26 <IMU+0x526>
				  //+ (double)Sensors_Latest[GYRO_ROLL_Index]  * GYRO_RATE
					 //// - (sin(AnglePitch * DEG_TO_RAD) * DT_YAW)  // integrate component of yaw rate into roll angle
					  //; 
		RotateV();	
		// Correct Drift using ACC
		Alpha = Config.AccParams[PITCH_INDEX].ComplementaryFilterAlpha / 1000.0; // TODO: optimize
    3da0:	b5 01       	movw	r22, r10
    3da2:	88 27       	eor	r24, r24
    3da4:	77 fd       	sbrc	r23, 7
    3da6:	80 95       	com	r24
    3da8:	98 2f       	mov	r25, r24
    3daa:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    3dae:	20 e0       	ldi	r18, 0x00	; 0
    3db0:	30 e0       	ldi	r19, 0x00	; 0
    3db2:	4a e7       	ldi	r20, 0x7A	; 122
    3db4:	54 e4       	ldi	r21, 0x44	; 68
    3db6:	0e 94 7a 37 	call	0x6ef4	; 0x6ef4 <__divsf3>
    3dba:	a6 2e       	mov	r10, r22
    3dbc:	d7 2e       	mov	r13, r23
    3dbe:	c8 2e       	mov	r12, r24
    3dc0:	b9 2e       	mov	r11, r25
		Beta = 1- Alpha;
		#define ACC_SMALL_ANGLE	40
		// if small angle then correct using ACC
		if ((APitch < ACC_SMALL_ANGLE) && (APitch > -ACC_SMALL_ANGLE)) 
		{
			AnglePitch = Alpha * AnglePitch + Beta * APitch  * 10;
    3dc2:	20 91 04 06 	lds	r18, 0x0604
    3dc6:	30 91 05 06 	lds	r19, 0x0605
    3dca:	40 91 06 06 	lds	r20, 0x0606
    3dce:	50 91 07 06 	lds	r21, 0x0607
    3dd2:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    3dd6:	3b 01       	movw	r6, r22
    3dd8:	4c 01       	movw	r8, r24
					 //// - (sin(AnglePitch * DEG_TO_RAD) * DT_YAW)  // integrate component of yaw rate into roll angle
					  //; 
		RotateV();	
		// Correct Drift using ACC
		Alpha = Config.AccParams[PITCH_INDEX].ComplementaryFilterAlpha / 1000.0; // TODO: optimize
		Beta = 1- Alpha;
    3dda:	60 e0       	ldi	r22, 0x00	; 0
    3ddc:	70 e0       	ldi	r23, 0x00	; 0
    3dde:	80 e8       	ldi	r24, 0x80	; 128
    3de0:	9f e3       	ldi	r25, 0x3F	; 63
    3de2:	2a 2d       	mov	r18, r10
    3de4:	3d 2d       	mov	r19, r13
    3de6:	4c 2d       	mov	r20, r12
    3de8:	5b 2d       	mov	r21, r11
    3dea:	0e 94 11 37 	call	0x6e22	; 0x6e22 <__subsf3>
		#define ACC_SMALL_ANGLE	40
		// if small angle then correct using ACC
		if ((APitch < ACC_SMALL_ANGLE) && (APitch > -ACC_SMALL_ANGLE)) 
		{
			AnglePitch = Alpha * AnglePitch + Beta * APitch  * 10;
    3dee:	20 2f       	mov	r18, r16
    3df0:	31 2f       	mov	r19, r17
    3df2:	4e 2d       	mov	r20, r14
    3df4:	5f 2d       	mov	r21, r15
    3df6:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    3dfa:	20 e0       	ldi	r18, 0x00	; 0
    3dfc:	30 e0       	ldi	r19, 0x00	; 0
    3dfe:	40 e2       	ldi	r20, 0x20	; 32
    3e00:	51 e4       	ldi	r21, 0x41	; 65
    3e02:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    3e06:	9b 01       	movw	r18, r22
    3e08:	ac 01       	movw	r20, r24
    3e0a:	c4 01       	movw	r24, r8
    3e0c:	b3 01       	movw	r22, r6
    3e0e:	0e 94 12 37 	call	0x6e24	; 0x6e24 <__addsf3>
    3e12:	9b 01       	movw	r18, r22
    3e14:	ac 01       	movw	r20, r24
    3e16:	20 93 04 06 	sts	0x0604, r18
    3e1a:	30 93 05 06 	sts	0x0605, r19
    3e1e:	40 93 06 06 	sts	0x0606, r20
    3e22:	50 93 07 06 	sts	0x0607, r21
		}
		
		Alpha = Config.AccParams[ROLL_INDEX].ComplementaryFilterAlpha / 1000.0; // TODO: optimize
    3e26:	00 91 2b 07 	lds	r16, 0x072B
    3e2a:	10 91 2c 07 	lds	r17, 0x072C
		Beta = 1- Alpha;
		if ((ARoll  < ACC_SMALL_ANGLE) && (ARoll  > -ACC_SMALL_ANGLE))
    3e2e:	62 2d       	mov	r22, r2
    3e30:	75 2d       	mov	r23, r5
    3e32:	84 2d       	mov	r24, r4
    3e34:	93 2d       	mov	r25, r3
    3e36:	20 e0       	ldi	r18, 0x00	; 0
    3e38:	30 e0       	ldi	r19, 0x00	; 0
    3e3a:	40 e2       	ldi	r20, 0x20	; 32
    3e3c:	52 e4       	ldi	r21, 0x42	; 66
    3e3e:	0e 94 76 37 	call	0x6eec	; 0x6eec <__cmpsf2>
    3e42:	87 ff       	sbrs	r24, 7
    3e44:	90 c0       	rjmp	.+288    	; 0x3f66 <IMU+0x666>
    3e46:	62 2d       	mov	r22, r2
    3e48:	75 2d       	mov	r23, r5
    3e4a:	84 2d       	mov	r24, r4
    3e4c:	93 2d       	mov	r25, r3
    3e4e:	20 e0       	ldi	r18, 0x00	; 0
    3e50:	30 e0       	ldi	r19, 0x00	; 0
    3e52:	40 e2       	ldi	r20, 0x20	; 32
    3e54:	52 ec       	ldi	r21, 0xC2	; 194
    3e56:	0e 94 c5 38 	call	0x718a	; 0x718a <__gesf2>
    3e5a:	18 16       	cp	r1, r24
    3e5c:	0c f0       	brlt	.+2      	; 0x3e60 <IMU+0x560>
    3e5e:	83 c0       	rjmp	.+262    	; 0x3f66 <IMU+0x666>
		if ((APitch < ACC_SMALL_ANGLE) && (APitch > -ACC_SMALL_ANGLE)) 
		{
			AnglePitch = Alpha * AnglePitch + Beta * APitch  * 10;
		}
		
		Alpha = Config.AccParams[ROLL_INDEX].ComplementaryFilterAlpha / 1000.0; // TODO: optimize
    3e60:	b8 01       	movw	r22, r16
    3e62:	88 27       	eor	r24, r24
    3e64:	77 fd       	sbrc	r23, 7
    3e66:	80 95       	com	r24
    3e68:	98 2f       	mov	r25, r24
    3e6a:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    3e6e:	20 e0       	ldi	r18, 0x00	; 0
    3e70:	30 e0       	ldi	r19, 0x00	; 0
    3e72:	4a e7       	ldi	r20, 0x7A	; 122
    3e74:	54 e4       	ldi	r21, 0x44	; 68
    3e76:	0e 94 7a 37 	call	0x6ef4	; 0x6ef4 <__divsf3>
    3e7a:	f6 2e       	mov	r15, r22
    3e7c:	07 2f       	mov	r16, r23
    3e7e:	18 2f       	mov	r17, r24
    3e80:	e9 2e       	mov	r14, r25
		Beta = 1- Alpha;
    3e82:	60 e0       	ldi	r22, 0x00	; 0
    3e84:	70 e0       	ldi	r23, 0x00	; 0
    3e86:	80 e8       	ldi	r24, 0x80	; 128
    3e88:	9f e3       	ldi	r25, 0x3F	; 63
    3e8a:	2f 2d       	mov	r18, r15
    3e8c:	30 2f       	mov	r19, r16
    3e8e:	41 2f       	mov	r20, r17
    3e90:	5e 2d       	mov	r21, r14
    3e92:	0e 94 11 37 	call	0x6e22	; 0x6e22 <__subsf3>
    3e96:	66 2e       	mov	r6, r22
    3e98:	97 2e       	mov	r9, r23
    3e9a:	88 2e       	mov	r8, r24
    3e9c:	79 2e       	mov	r7, r25
		if ((ARoll  < ACC_SMALL_ANGLE) && (ARoll  > -ACC_SMALL_ANGLE))
		{
			AngleRoll =  Alpha * AngleRoll + Beta * ARoll * 10 ;
    3e9e:	20 91 ba 06 	lds	r18, 0x06BA
    3ea2:	30 91 bb 06 	lds	r19, 0x06BB
    3ea6:	40 91 bc 06 	lds	r20, 0x06BC
    3eaa:	50 91 bd 06 	lds	r21, 0x06BD
    3eae:	6f 2d       	mov	r22, r15
    3eb0:	70 2f       	mov	r23, r16
    3eb2:	81 2f       	mov	r24, r17
    3eb4:	9e 2d       	mov	r25, r14
    3eb6:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    3eba:	5b 01       	movw	r10, r22
    3ebc:	6c 01       	movw	r12, r24
    3ebe:	66 2d       	mov	r22, r6
    3ec0:	79 2d       	mov	r23, r9
    3ec2:	88 2d       	mov	r24, r8
    3ec4:	97 2d       	mov	r25, r7
    3ec6:	22 2d       	mov	r18, r2
    3ec8:	35 2d       	mov	r19, r5
    3eca:	44 2d       	mov	r20, r4
    3ecc:	53 2d       	mov	r21, r3
    3ece:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    3ed2:	20 e0       	ldi	r18, 0x00	; 0
    3ed4:	30 e0       	ldi	r19, 0x00	; 0
    3ed6:	40 e2       	ldi	r20, 0x20	; 32
    3ed8:	51 e4       	ldi	r21, 0x41	; 65
    3eda:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    3ede:	9b 01       	movw	r18, r22
    3ee0:	ac 01       	movw	r20, r24
    3ee2:	c6 01       	movw	r24, r12
    3ee4:	b5 01       	movw	r22, r10
    3ee6:	0e 94 12 37 	call	0x6e24	; 0x6e24 <__addsf3>
    3eea:	9b 01       	movw	r18, r22
    3eec:	ac 01       	movw	r20, r24
    3eee:	20 93 ba 06 	sts	0x06BA, r18
    3ef2:	30 93 bb 06 	sts	0x06BB, r19
    3ef6:	40 93 bc 06 	sts	0x06BC, r20
    3efa:	50 93 bd 06 	sts	0x06BD, r21
			AngleZ =  Alpha * AngleZ + Beta * CompAccZ * 10;
    3efe:	20 91 4a 06 	lds	r18, 0x064A
    3f02:	30 91 4b 06 	lds	r19, 0x064B
    3f06:	40 91 4c 06 	lds	r20, 0x064C
    3f0a:	50 91 4d 06 	lds	r21, 0x064D
    3f0e:	6f 2d       	mov	r22, r15
    3f10:	70 2f       	mov	r23, r16
    3f12:	81 2f       	mov	r24, r17
    3f14:	9e 2d       	mov	r25, r14
    3f16:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    3f1a:	7b 01       	movw	r14, r22
    3f1c:	8c 01       	movw	r16, r24
    3f1e:	66 2d       	mov	r22, r6
    3f20:	79 2d       	mov	r23, r9
    3f22:	88 2d       	mov	r24, r8
    3f24:	97 2d       	mov	r25, r7
    3f26:	20 91 25 06 	lds	r18, 0x0625
    3f2a:	30 91 26 06 	lds	r19, 0x0626
    3f2e:	40 91 27 06 	lds	r20, 0x0627
    3f32:	50 91 28 06 	lds	r21, 0x0628
    3f36:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    3f3a:	20 e0       	ldi	r18, 0x00	; 0
    3f3c:	30 e0       	ldi	r19, 0x00	; 0
    3f3e:	40 e2       	ldi	r20, 0x20	; 32
    3f40:	51 e4       	ldi	r21, 0x41	; 65
    3f42:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    3f46:	9b 01       	movw	r18, r22
    3f48:	ac 01       	movw	r20, r24
    3f4a:	c8 01       	movw	r24, r16
    3f4c:	b7 01       	movw	r22, r14
    3f4e:	0e 94 12 37 	call	0x6e24	; 0x6e24 <__addsf3>
    3f52:	9b 01       	movw	r18, r22
    3f54:	ac 01       	movw	r20, r24
    3f56:	20 93 4a 06 	sts	0x064A, r18
    3f5a:	30 93 4b 06 	sts	0x064B, r19
    3f5e:	40 93 4c 06 	sts	0x064C, r20
    3f62:	50 93 4d 06 	sts	0x064D, r21
		
			
		//NavY = AnglePitch;
		//NavX = AngleRoll;
		// Attitude of the estimated vector
		int32_t sqGZ = AngleZ * AngleZ;
    3f66:	a0 90 4a 06 	lds	r10, 0x064A
    3f6a:	b0 90 4b 06 	lds	r11, 0x064B
    3f6e:	c0 90 4c 06 	lds	r12, 0x064C
    3f72:	d0 90 4d 06 	lds	r13, 0x064D
    3f76:	60 90 4a 06 	lds	r6, 0x064A
    3f7a:	70 90 4b 06 	lds	r7, 0x064B
    3f7e:	80 90 4c 06 	lds	r8, 0x064C
    3f82:	90 90 4d 06 	lds	r9, 0x064D
		int32_t sqGRoll = AngleRoll * AngleRoll;
    3f86:	60 91 ba 06 	lds	r22, 0x06BA
    3f8a:	70 91 bb 06 	lds	r23, 0x06BB
    3f8e:	80 91 bc 06 	lds	r24, 0x06BC
    3f92:	90 91 bd 06 	lds	r25, 0x06BD
    3f96:	20 91 ba 06 	lds	r18, 0x06BA
    3f9a:	30 91 bb 06 	lds	r19, 0x06BB
    3f9e:	40 91 bc 06 	lds	r20, 0x06BC
    3fa2:	50 91 bd 06 	lds	r21, 0x06BD
		int32_t sqGPitch = AnglePitch * AnglePitch;
    3fa6:	e0 90 04 06 	lds	r14, 0x0604
    3faa:	f0 90 05 06 	lds	r15, 0x0605
    3fae:	00 91 06 06 	lds	r16, 0x0606
    3fb2:	10 91 07 06 	lds	r17, 0x0607
    3fb6:	e0 90 04 06 	lds	r14, 0x0604
    3fba:	f0 90 05 06 	lds	r15, 0x0605
    3fbe:	00 91 06 06 	lds	r16, 0x0606
    3fc2:	10 91 07 06 	lds	r17, 0x0607
			
		//NavY = AnglePitch;
		//NavX = AngleRoll;
		// Attitude of the estimated vector
		int32_t sqGZ = AngleZ * AngleZ;
		int32_t sqGRoll = AngleRoll * AngleRoll;
    3fc6:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    3fca:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <__fixsfsi>
    3fce:	7b 01       	movw	r14, r22
    3fd0:	8c 01       	movw	r16, r24
		
			
		//NavY = AnglePitch;
		//NavX = AngleRoll;
		// Attitude of the estimated vector
		int32_t sqGZ = AngleZ * AngleZ;
    3fd2:	c6 01       	movw	r24, r12
    3fd4:	b5 01       	movw	r22, r10
    3fd6:	a4 01       	movw	r20, r8
    3fd8:	93 01       	movw	r18, r6
    3fda:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    3fde:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <__fixsfsi>
		int32_t sqGRoll = AngleRoll * AngleRoll;
		int32_t sqGPitch = AnglePitch * AnglePitch;
		int32_t sqGRoll_sqGZ = sqGRoll + sqGZ;
    3fe2:	6e 0d       	add	r22, r14
    3fe4:	7f 1d       	adc	r23, r15
    3fe6:	80 1f       	adc	r24, r16
    3fe8:	91 1f       	adc	r25, r17
		float invmagXZ  = InvSqrt(sqGRoll_sqGZ);
    3fea:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    3fee:	5b 01       	movw	r10, r22
    3ff0:	6c 01       	movw	r12, r24
    3ff2:	0e 94 5e 23 	call	0x46bc	; 0x46bc <InvSqrt>
    3ff6:	1b 01       	movw	r2, r22
    3ff8:	2c 01       	movw	r4, r24
		//invG = InvSqrt(sqGRoll_sqGZ + sqGPitch);
		NavX = _atan2(AngleRoll , AngleZ) / 100.0f;
    3ffa:	60 91 ba 06 	lds	r22, 0x06BA
    3ffe:	70 91 bb 06 	lds	r23, 0x06BB
    4002:	80 91 bc 06 	lds	r24, 0x06BC
    4006:	90 91 bd 06 	lds	r25, 0x06BD
    400a:	e0 90 4a 06 	lds	r14, 0x064A
    400e:	f0 90 4b 06 	lds	r15, 0x064B
    4012:	00 91 4c 06 	lds	r16, 0x064C
    4016:	10 91 4d 06 	lds	r17, 0x064D
    401a:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <__fixsfsi>
    401e:	3b 01       	movw	r6, r22
    4020:	4c 01       	movw	r8, r24
    4022:	c8 01       	movw	r24, r16
    4024:	b7 01       	movw	r22, r14
    4026:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <__fixsfsi>
    402a:	9b 01       	movw	r18, r22
    402c:	ac 01       	movw	r20, r24
    402e:	c4 01       	movw	r24, r8
    4030:	b3 01       	movw	r22, r6
    4032:	0e 94 b6 22 	call	0x456c	; 0x456c <_atan2>
    4036:	9c 01       	movw	r18, r24
    4038:	b9 01       	movw	r22, r18
    403a:	88 27       	eor	r24, r24
    403c:	77 fd       	sbrc	r23, 7
    403e:	80 95       	com	r24
    4040:	98 2f       	mov	r25, r24
    4042:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    4046:	20 e0       	ldi	r18, 0x00	; 0
    4048:	30 e0       	ldi	r19, 0x00	; 0
    404a:	48 ec       	ldi	r20, 0xC8	; 200
    404c:	52 e4       	ldi	r21, 0x42	; 66
    404e:	0e 94 7a 37 	call	0x6ef4	; 0x6ef4 <__divsf3>
    4052:	60 93 36 05 	sts	0x0536, r22
    4056:	70 93 37 05 	sts	0x0537, r23
    405a:	80 93 38 05 	sts	0x0538, r24
    405e:	90 93 39 05 	sts	0x0539, r25
		NavY = _atan2(AnglePitch , invmagXZ*sqGRoll_sqGZ) / 100.0f;
    4062:	60 91 04 06 	lds	r22, 0x0604
    4066:	70 91 05 06 	lds	r23, 0x0605
    406a:	80 91 06 06 	lds	r24, 0x0606
    406e:	90 91 07 06 	lds	r25, 0x0607
    4072:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <__fixsfsi>
    4076:	7b 01       	movw	r14, r22
    4078:	8c 01       	movw	r16, r24
    407a:	c2 01       	movw	r24, r4
    407c:	b1 01       	movw	r22, r2
    407e:	a6 01       	movw	r20, r12
    4080:	95 01       	movw	r18, r10
    4082:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    4086:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <__fixsfsi>
    408a:	9b 01       	movw	r18, r22
    408c:	ac 01       	movw	r20, r24
    408e:	c8 01       	movw	r24, r16
    4090:	b7 01       	movw	r22, r14
    4092:	0e 94 b6 22 	call	0x456c	; 0x456c <_atan2>
    4096:	fc 01       	movw	r30, r24
    4098:	bf 01       	movw	r22, r30
    409a:	88 27       	eor	r24, r24
    409c:	77 fd       	sbrc	r23, 7
    409e:	80 95       	com	r24
    40a0:	98 2f       	mov	r25, r24
    40a2:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    40a6:	20 e0       	ldi	r18, 0x00	; 0
    40a8:	30 e0       	ldi	r19, 0x00	; 0
    40aa:	48 ec       	ldi	r20, 0xC8	; 200
    40ac:	52 e4       	ldi	r21, 0x42	; 66
    40ae:	0e 94 7a 37 	call	0x6ef4	; 0x6ef4 <__divsf3>
    40b2:	60 93 ec 05 	sts	0x05EC, r22
    40b6:	70 93 ed 05 	sts	0x05ED, r23
    40ba:	80 93 ee 05 	sts	0x05EE, r24
    40be:	90 93 ef 05 	sts	0x05EF, r25
			gyroRoll += PID_Calculate_ACC (Config.AccParams[ROLL_INDEX], &PID_AccTerms[ROLL_INDEX],NavX); //AngleRoll); 
		 
		}
		
	
}
    40c2:	df 91       	pop	r29
    40c4:	cf 91       	pop	r28
    40c6:	1f 91       	pop	r17
    40c8:	0f 91       	pop	r16
    40ca:	ff 90       	pop	r15
    40cc:	ef 90       	pop	r14
    40ce:	df 90       	pop	r13
    40d0:	cf 90       	pop	r12
    40d2:	bf 90       	pop	r11
    40d4:	af 90       	pop	r10
    40d6:	9f 90       	pop	r9
    40d8:	8f 90       	pop	r8
    40da:	7f 90       	pop	r7
    40dc:	6f 90       	pop	r6
    40de:	5f 90       	pop	r5
    40e0:	4f 90       	pop	r4
    40e2:	3f 90       	pop	r3
    40e4:	2f 90       	pop	r2
    40e6:	08 95       	ret

000040e8 <IMU_HeightKeeping>:

	

	
double IMU_HeightKeeping ()
{
    40e8:	af 92       	push	r10
    40ea:	bf 92       	push	r11
    40ec:	cf 92       	push	r12
    40ee:	df 92       	push	r13
    40f0:	ef 92       	push	r14
    40f2:	ff 92       	push	r15
    40f4:	0f 93       	push	r16
    40f6:	1f 93       	push	r17
	double Temp;
//	ThrottleTemp = RX_Snapshot[RXChannel_THR];
	
	// calculate damping
	
	Landing = PID_Calculate (Config.AccParams[Z_INDEX], &PID_AccTerms[Z_INDEX],-CompAccZ) ;
    40f8:	00 d0       	rcall	.+0      	; 0x40fa <IMU_HeightKeeping+0x12>
    40fa:	00 d0       	rcall	.+0      	; 0x40fc <IMU_HeightKeeping+0x14>
    40fc:	80 91 25 06 	lds	r24, 0x0625
    4100:	90 91 26 06 	lds	r25, 0x0626
    4104:	a0 91 27 06 	lds	r26, 0x0627
    4108:	b0 91 28 06 	lds	r27, 0x0628
    410c:	b0 58       	subi	r27, 0x80	; 128
    410e:	ed b7       	in	r30, 0x3d	; 61
    4110:	fe b7       	in	r31, 0x3e	; 62
    4112:	81 83       	std	Z+1, r24	; 0x01
    4114:	92 83       	std	Z+2, r25	; 0x02
    4116:	a3 83       	std	Z+3, r26	; 0x03
    4118:	b4 83       	std	Z+4, r27	; 0x04
    411a:	c0 90 2d 07 	lds	r12, 0x072D
    411e:	d0 90 2e 07 	lds	r13, 0x072E
    4122:	e0 90 2f 07 	lds	r14, 0x072F
    4126:	f0 90 30 07 	lds	r15, 0x0730
    412a:	00 91 31 07 	lds	r16, 0x0731
    412e:	10 91 32 07 	lds	r17, 0x0732
    4132:	20 91 33 07 	lds	r18, 0x0733
    4136:	30 91 34 07 	lds	r19, 0x0734
    413a:	40 91 35 07 	lds	r20, 0x0735
    413e:	50 91 36 07 	lds	r21, 0x0736
    4142:	60 91 37 07 	lds	r22, 0x0737
    4146:	70 91 38 07 	lds	r23, 0x0738
    414a:	80 91 39 07 	lds	r24, 0x0739
    414e:	90 91 3a 07 	lds	r25, 0x073A
    4152:	ec e6       	ldi	r30, 0x6C	; 108
    4154:	ae 2e       	mov	r10, r30
    4156:	e5 e0       	ldi	r30, 0x05	; 5
    4158:	be 2e       	mov	r11, r30
    415a:	0e 94 ff 19 	call	0x33fe	; 0x33fe <PID_Calculate>
    415e:	60 93 44 06 	sts	0x0644, r22
    4162:	70 93 45 06 	sts	0x0645, r23
    4166:	80 93 46 06 	sts	0x0646, r24
    416a:	90 93 47 06 	sts	0x0647, r25
			
			
	// Calculate Altitude Hold
	if ((Config.RX_mode==RX_mode_UARTMode) && (IS_MISC_SENSOR_SONAR_ENABLED==true) && (nFlyingModes == FLYINGMODE_ALTHOLD))
    416e:	0f 90       	pop	r0
    4170:	0f 90       	pop	r0
    4172:	0f 90       	pop	r0
    4174:	0f 90       	pop	r0
    4176:	80 91 db 06 	lds	r24, 0x06DB
    417a:	8f 3f       	cpi	r24, 0xFF	; 255
    417c:	09 f0       	breq	.+2      	; 0x4180 <IMU_HeightKeeping+0x98>
    417e:	f4 c0       	rjmp	.+488    	; 0x4368 <IMU_HeightKeeping+0x280>
    4180:	80 91 e6 06 	lds	r24, 0x06E6
    4184:	80 ff       	sbrs	r24, 0
    4186:	f0 c0       	rjmp	.+480    	; 0x4368 <IMU_HeightKeeping+0x280>
    4188:	80 91 08 06 	lds	r24, 0x0608
    418c:	84 30       	cpi	r24, 0x04	; 4
    418e:	09 f0       	breq	.+2      	; 0x4192 <IMU_HeightKeeping+0xaa>
    4190:	eb c0       	rjmp	.+470    	; 0x4368 <IMU_HeightKeeping+0x280>
	{
		RX_SONAR_TRIGGER = HIGH;
    4192:	48 9a       	sbi	0x09, 0	; 9
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    4194:	f8 94       	cli
		ATOMIC_BLOCK(ATOMIC_FORCEON)
		{	
			Temp = RX_SONAR_RAW; 
    4196:	60 91 be 05 	lds	r22, 0x05BE
    419a:	70 91 bf 05 	lds	r23, 0x05BF
    419e:	80 e0       	ldi	r24, 0x00	; 0
    41a0:	90 e0       	ldi	r25, 0x00	; 0
    41a2:	0e 94 13 38 	call	0x7026	; 0x7026 <__floatunsisf>
    41a6:	7b 01       	movw	r14, r22
    41a8:	8c 01       	movw	r16, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    41aa:	78 94       	sei
		}
	
		if (Temp < 550) // if SONAR Reading is VALID - not BEYOND maximum range
    41ac:	7f 2d       	mov	r23, r15
    41ae:	91 2f       	mov	r25, r17
    41b0:	20 e0       	ldi	r18, 0x00	; 0
    41b2:	30 e8       	ldi	r19, 0x80	; 128
    41b4:	49 e0       	ldi	r20, 0x09	; 9
    41b6:	54 e4       	ldi	r21, 0x44	; 68
    41b8:	0e 94 76 37 	call	0x6eec	; 0x6eec <__cmpsf2>
    41bc:	87 ff       	sbrs	r24, 7
    41be:	b4 c0       	rjmp	.+360    	; 0x4328 <IMU_HeightKeeping+0x240>
		{
			
			if ((bALTHOLD == false))
    41c0:	80 91 27 05 	lds	r24, 0x0527
    41c4:	88 23       	and	r24, r24
    41c6:	29 f5       	brne	.+74     	; 0x4212 <IMU_HeightKeeping+0x12a>
			{   
				if (ThrottleTemp<3)
    41c8:	80 91 25 05 	lds	r24, 0x0525
    41cc:	90 91 26 05 	lds	r25, 0x0526
    41d0:	83 30       	cpi	r24, 0x03	; 3
    41d2:	91 05       	cpc	r25, r1
    41d4:	34 f4       	brge	.+12     	; 0x41e2 <IMU_HeightKeeping+0xfa>
				{ // current altitude is the old one so skip readings till update.
					ThrottleTemp+=1;
    41d6:	01 96       	adiw	r24, 0x01	; 1
    41d8:	90 93 26 05 	sts	0x0526, r25
    41dc:	80 93 25 05 	sts	0x0525, r24
    41e0:	c9 c0       	rjmp	.+402    	; 0x4374 <IMU_HeightKeeping+0x28c>
					return Landing ;
				}
				// first time to switch to ALTHOLD
				LastAltitudeHold = Temp; // measure Altitude
    41e2:	6e 2d       	mov	r22, r14
    41e4:	7f 2d       	mov	r23, r15
    41e6:	80 2f       	mov	r24, r16
    41e8:	91 2f       	mov	r25, r17
    41ea:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__fixunssfsi>
    41ee:	70 93 b9 06 	sts	0x06B9, r23
    41f2:	60 93 b8 06 	sts	0x06B8, r22
				PID_SonarTerms[0].I=0;   // ZERO I
    41f6:	80 e0       	ldi	r24, 0x00	; 0
    41f8:	90 e0       	ldi	r25, 0x00	; 0
    41fa:	dc 01       	movw	r26, r24
    41fc:	80 93 c5 06 	sts	0x06C5, r24
    4200:	90 93 c6 06 	sts	0x06C6, r25
    4204:	a0 93 c7 06 	sts	0x06C7, r26
    4208:	b0 93 c8 06 	sts	0x06C8, r27
				bALTHOLD = true;
    420c:	81 e0       	ldi	r24, 0x01	; 1
    420e:	80 93 27 05 	sts	0x0527, r24
			}
			
			AltDiff = LastAltitudeHold - Temp;
    4212:	60 91 b8 06 	lds	r22, 0x06B8
    4216:	70 91 b9 06 	lds	r23, 0x06B9
    421a:	80 e0       	ldi	r24, 0x00	; 0
    421c:	90 e0       	ldi	r25, 0x00	; 0
    421e:	0e 94 13 38 	call	0x7026	; 0x7026 <__floatunsisf>
    4222:	2e 2d       	mov	r18, r14
    4224:	3f 2d       	mov	r19, r15
    4226:	40 2f       	mov	r20, r16
    4228:	51 2f       	mov	r21, r17
    422a:	0e 94 11 37 	call	0x6e22	; 0x6e22 <__subsf3>
    422e:	f6 2e       	mov	r15, r22
    4230:	07 2f       	mov	r16, r23
    4232:	18 2f       	mov	r17, r24
    4234:	e9 2e       	mov	r14, r25
    4236:	86 2f       	mov	r24, r22
    4238:	90 2f       	mov	r25, r16
    423a:	a1 2f       	mov	r26, r17
    423c:	be 2d       	mov	r27, r14
    423e:	80 93 9c 06 	sts	0x069C, r24
    4242:	90 93 9d 06 	sts	0x069D, r25
    4246:	a0 93 9e 06 	sts	0x069E, r26
    424a:	b0 93 9f 06 	sts	0x069F, r27
			if ((AltDiff<50) && (AltDiff>-50)) // no sudden change or false read
    424e:	6f 2d       	mov	r22, r15
    4250:	70 2f       	mov	r23, r16
    4252:	81 2f       	mov	r24, r17
    4254:	9e 2d       	mov	r25, r14
    4256:	20 e0       	ldi	r18, 0x00	; 0
    4258:	30 e0       	ldi	r19, 0x00	; 0
    425a:	48 e4       	ldi	r20, 0x48	; 72
    425c:	52 e4       	ldi	r21, 0x42	; 66
    425e:	0e 94 76 37 	call	0x6eec	; 0x6eec <__cmpsf2>
    4262:	87 ff       	sbrs	r24, 7
    4264:	5c c0       	rjmp	.+184    	; 0x431e <IMU_HeightKeeping+0x236>
    4266:	6f 2d       	mov	r22, r15
    4268:	70 2f       	mov	r23, r16
    426a:	81 2f       	mov	r24, r17
    426c:	9e 2d       	mov	r25, r14
    426e:	20 e0       	ldi	r18, 0x00	; 0
    4270:	30 e0       	ldi	r19, 0x00	; 0
    4272:	48 e4       	ldi	r20, 0x48	; 72
    4274:	52 ec       	ldi	r21, 0xC2	; 194
    4276:	0e 94 c5 38 	call	0x718a	; 0x718a <__gesf2>
    427a:	18 16       	cp	r1, r24
    427c:	0c f0       	brlt	.+2      	; 0x4280 <IMU_HeightKeeping+0x198>
    427e:	4f c0       	rjmp	.+158    	; 0x431e <IMU_HeightKeeping+0x236>
			{
				IgnoreTimeOut=0;
    4280:	10 92 22 05 	sts	0x0522, r1
				ThrottleTemp = PID_Calculate (Config.SonarParams[0], &PID_SonarTerms[0],AltDiff) ;	
    4284:	00 d0       	rcall	.+0      	; 0x4286 <IMU_HeightKeeping+0x19e>
    4286:	00 d0       	rcall	.+0      	; 0x4288 <IMU_HeightKeeping+0x1a0>
    4288:	8f 2d       	mov	r24, r15
    428a:	90 2f       	mov	r25, r16
    428c:	a1 2f       	mov	r26, r17
    428e:	be 2d       	mov	r27, r14
    4290:	ed b7       	in	r30, 0x3d	; 61
    4292:	fe b7       	in	r31, 0x3e	; 62
    4294:	81 83       	std	Z+1, r24	; 0x01
    4296:	92 83       	std	Z+2, r25	; 0x02
    4298:	a3 83       	std	Z+3, r26	; 0x03
    429a:	b4 83       	std	Z+4, r27	; 0x04
    429c:	c0 90 3b 07 	lds	r12, 0x073B
    42a0:	d0 90 3c 07 	lds	r13, 0x073C
    42a4:	e0 90 3d 07 	lds	r14, 0x073D
    42a8:	f0 90 3e 07 	lds	r15, 0x073E
    42ac:	00 91 3f 07 	lds	r16, 0x073F
    42b0:	10 91 40 07 	lds	r17, 0x0740
    42b4:	20 91 41 07 	lds	r18, 0x0741
    42b8:	30 91 42 07 	lds	r19, 0x0742
    42bc:	40 91 43 07 	lds	r20, 0x0743
    42c0:	50 91 44 07 	lds	r21, 0x0744
    42c4:	60 91 45 07 	lds	r22, 0x0745
    42c8:	70 91 46 07 	lds	r23, 0x0746
    42cc:	80 91 47 07 	lds	r24, 0x0747
    42d0:	90 91 48 07 	lds	r25, 0x0748
    42d4:	b1 ec       	ldi	r27, 0xC1	; 193
    42d6:	ab 2e       	mov	r10, r27
    42d8:	b6 e0       	ldi	r27, 0x06	; 6
    42da:	bb 2e       	mov	r11, r27
    42dc:	0e 94 ff 19 	call	0x33fe	; 0x33fe <PID_Calculate>
    42e0:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <__fixsfsi>
    42e4:	7b 01       	movw	r14, r22
    42e6:	8c 01       	movw	r16, r24
    42e8:	70 93 26 05 	sts	0x0526, r23
    42ec:	60 93 25 05 	sts	0x0525, r22
				if (AltDiff==0) 
    42f0:	0f 90       	pop	r0
    42f2:	0f 90       	pop	r0
    42f4:	0f 90       	pop	r0
    42f6:	0f 90       	pop	r0
    42f8:	60 91 9c 06 	lds	r22, 0x069C
    42fc:	70 91 9d 06 	lds	r23, 0x069D
    4300:	80 91 9e 06 	lds	r24, 0x069E
    4304:	90 91 9f 06 	lds	r25, 0x069F
    4308:	20 e0       	ldi	r18, 0x00	; 0
    430a:	30 e0       	ldi	r19, 0x00	; 0
    430c:	a9 01       	movw	r20, r18
    430e:	0e 94 76 37 	call	0x6eec	; 0x6eec <__cmpsf2>
    4312:	88 23       	and	r24, r24
    4314:	21 f4       	brne	.+8      	; 0x431e <IMU_HeightKeeping+0x236>
				{
					ThrottleZERO = ThrottleTemp;
    4316:	f0 92 24 05 	sts	0x0524, r15
    431a:	e0 92 23 05 	sts	0x0523, r14
						
				}
			}
										
			Landing += ThrottleTemp;
    431e:	60 91 25 05 	lds	r22, 0x0525
    4322:	70 91 26 05 	lds	r23, 0x0526
    4326:	04 c0       	rjmp	.+8      	; 0x4330 <IMU_HeightKeeping+0x248>
		}
		else
		{
			Landing += ThrottleZERO;
    4328:	60 91 23 05 	lds	r22, 0x0523
    432c:	70 91 24 05 	lds	r23, 0x0524
    4330:	88 27       	eor	r24, r24
    4332:	77 fd       	sbrc	r23, 7
    4334:	80 95       	com	r24
    4336:	98 2f       	mov	r25, r24
    4338:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    433c:	9b 01       	movw	r18, r22
    433e:	ac 01       	movw	r20, r24
    4340:	60 91 44 06 	lds	r22, 0x0644
    4344:	70 91 45 06 	lds	r23, 0x0645
    4348:	80 91 46 06 	lds	r24, 0x0646
    434c:	90 91 47 06 	lds	r25, 0x0647
    4350:	0e 94 12 37 	call	0x6e24	; 0x6e24 <__addsf3>
    4354:	60 93 44 06 	sts	0x0644, r22
    4358:	70 93 45 06 	sts	0x0645, r23
    435c:	80 93 46 06 	sts	0x0646, r24
    4360:	90 93 47 06 	sts	0x0647, r25
		}
		
		RX_SONAR_TRIGGER = LOW;
    4364:	48 98       	cbi	0x09, 0	; 9
    4366:	06 c0       	rjmp	.+12     	; 0x4374 <IMU_HeightKeeping+0x28c>
	}
	else
	{
			ThrottleTemp=0;
    4368:	10 92 26 05 	sts	0x0526, r1
    436c:	10 92 25 05 	sts	0x0525, r1
			bALTHOLD=false;
    4370:	10 92 27 05 	sts	0x0527, r1
	}
	
	
	return Landing;
    4374:	70 91 44 06 	lds	r23, 0x0644
    4378:	60 91 45 06 	lds	r22, 0x0645
    437c:	90 91 46 06 	lds	r25, 0x0646
    4380:	80 91 47 06 	lds	r24, 0x0647
    4384:	ab 01       	movw	r20, r22
    4386:	9c 01       	movw	r18, r24
    4388:	65 2f       	mov	r22, r21
    438a:	74 2f       	mov	r23, r20
    438c:	83 2f       	mov	r24, r19
    438e:	92 2f       	mov	r25, r18
    4390:	1f 91       	pop	r17
    4392:	0f 91       	pop	r16
    4394:	ff 90       	pop	r15
    4396:	ef 90       	pop	r14
    4398:	df 90       	pop	r13
    439a:	cf 90       	pop	r12
    439c:	bf 90       	pop	r11
    439e:	af 90       	pop	r10
    43a0:	08 95       	ret

000043a2 <arctan2>:
  //}
  //z *= (180.0f / PI * 10); 
  //return z;
//}

int arctan2(int y, int x) {                                    // http://www.dspguru.com/comp.dsp/tricks/alg/fxdatan2.htm
    43a2:	6f 92       	push	r6
    43a4:	7f 92       	push	r7
    43a6:	8f 92       	push	r8
    43a8:	9f 92       	push	r9
    43aa:	af 92       	push	r10
    43ac:	bf 92       	push	r11
    43ae:	cf 92       	push	r12
    43b0:	df 92       	push	r13
    43b2:	ef 92       	push	r14
    43b4:	ff 92       	push	r15
    43b6:	0f 93       	push	r16
    43b8:	1f 93       	push	r17
    43ba:	cf 93       	push	r28
    43bc:	df 93       	push	r29
    43be:	ec 01       	movw	r28, r24
    43c0:	6b 01       	movw	r12, r22
   int coeff_1 = 128;                                          // angle in Quids (1024 Quids=360) <<<<<<<<<<<<<<
   int coeff_2 = 3*coeff_1;
   float abs_y = abs(y)+1e-10;
    43c2:	bc 01       	movw	r22, r24
    43c4:	97 ff       	sbrs	r25, 7
    43c6:	04 c0       	rjmp	.+8      	; 0x43d0 <arctan2+0x2e>
    43c8:	66 27       	eor	r22, r22
    43ca:	77 27       	eor	r23, r23
    43cc:	68 1b       	sub	r22, r24
    43ce:	79 0b       	sbc	r23, r25
    43d0:	88 27       	eor	r24, r24
    43d2:	77 fd       	sbrc	r23, 7
    43d4:	80 95       	com	r24
    43d6:	98 2f       	mov	r25, r24
    43d8:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    43dc:	2f ef       	ldi	r18, 0xFF	; 255
    43de:	36 ee       	ldi	r19, 0xE6	; 230
    43e0:	4b ed       	ldi	r20, 0xDB	; 219
    43e2:	5e e2       	ldi	r21, 0x2E	; 46
    43e4:	0e 94 12 37 	call	0x6e24	; 0x6e24 <__addsf3>
    43e8:	16 2f       	mov	r17, r22
    43ea:	07 2f       	mov	r16, r23
    43ec:	f8 2e       	mov	r15, r24
    43ee:	e9 2e       	mov	r14, r25
    43f0:	b6 01       	movw	r22, r12
    43f2:	88 27       	eor	r24, r24
    43f4:	77 fd       	sbrc	r23, 7
    43f6:	80 95       	com	r24
    43f8:	98 2f       	mov	r25, r24
   float r, angle;

   if (x >= 0) {
    43fa:	d7 fc       	sbrc	r13, 7
    43fc:	2b c0       	rjmp	.+86     	; 0x4454 <arctan2+0xb2>
     r = (x - abs_y) / (x + abs_y);
    43fe:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    4402:	5b 01       	movw	r10, r22
    4404:	6c 01       	movw	r12, r24
    4406:	d8 01       	movw	r26, r16
    4408:	f7 01       	movw	r30, r14
    440a:	2b 2f       	mov	r18, r27
    440c:	3a 2f       	mov	r19, r26
    440e:	4f 2f       	mov	r20, r31
    4410:	5e 2f       	mov	r21, r30
    4412:	0e 94 11 37 	call	0x6e22	; 0x6e22 <__subsf3>
    4416:	3b 01       	movw	r6, r22
    4418:	4c 01       	movw	r8, r24
    441a:	c6 01       	movw	r24, r12
    441c:	b5 01       	movw	r22, r10
    441e:	d8 01       	movw	r26, r16
    4420:	f7 01       	movw	r30, r14
    4422:	2b 2f       	mov	r18, r27
    4424:	3a 2f       	mov	r19, r26
    4426:	4f 2f       	mov	r20, r31
    4428:	5e 2f       	mov	r21, r30
    442a:	0e 94 12 37 	call	0x6e24	; 0x6e24 <__addsf3>
    442e:	9b 01       	movw	r18, r22
    4430:	ac 01       	movw	r20, r24
    4432:	c4 01       	movw	r24, r8
    4434:	b3 01       	movw	r22, r6
    4436:	0e 94 7a 37 	call	0x6ef4	; 0x6ef4 <__divsf3>
     angle = coeff_1 - coeff_1 * r;
    443a:	20 e0       	ldi	r18, 0x00	; 0
    443c:	30 e0       	ldi	r19, 0x00	; 0
    443e:	40 e0       	ldi	r20, 0x00	; 0
    4440:	53 e4       	ldi	r21, 0x43	; 67
    4442:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    4446:	9b 01       	movw	r18, r22
    4448:	ac 01       	movw	r20, r24
    444a:	60 e0       	ldi	r22, 0x00	; 0
    444c:	70 e0       	ldi	r23, 0x00	; 0
    444e:	80 e0       	ldi	r24, 0x00	; 0
    4450:	93 e4       	ldi	r25, 0x43	; 67
    4452:	2a c0       	rjmp	.+84     	; 0x44a8 <arctan2+0x106>
   }  else {
     r = (x + abs_y) / (abs_y - x);
    4454:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    4458:	5b 01       	movw	r10, r22
    445a:	6c 01       	movw	r12, r24
    445c:	d8 01       	movw	r26, r16
    445e:	f7 01       	movw	r30, r14
    4460:	2b 2f       	mov	r18, r27
    4462:	3a 2f       	mov	r19, r26
    4464:	4f 2f       	mov	r20, r31
    4466:	5e 2f       	mov	r21, r30
    4468:	0e 94 12 37 	call	0x6e24	; 0x6e24 <__addsf3>
    446c:	3b 01       	movw	r6, r22
    446e:	4c 01       	movw	r8, r24
    4470:	a8 01       	movw	r20, r16
    4472:	97 01       	movw	r18, r14
    4474:	65 2f       	mov	r22, r21
    4476:	74 2f       	mov	r23, r20
    4478:	83 2f       	mov	r24, r19
    447a:	92 2f       	mov	r25, r18
    447c:	a6 01       	movw	r20, r12
    447e:	95 01       	movw	r18, r10
    4480:	0e 94 11 37 	call	0x6e22	; 0x6e22 <__subsf3>
    4484:	9b 01       	movw	r18, r22
    4486:	ac 01       	movw	r20, r24
    4488:	c4 01       	movw	r24, r8
    448a:	b3 01       	movw	r22, r6
    448c:	0e 94 7a 37 	call	0x6ef4	; 0x6ef4 <__divsf3>
     angle = coeff_2 - coeff_1 * r;
    4490:	20 e0       	ldi	r18, 0x00	; 0
    4492:	30 e0       	ldi	r19, 0x00	; 0
    4494:	40 e0       	ldi	r20, 0x00	; 0
    4496:	53 e4       	ldi	r21, 0x43	; 67
    4498:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    449c:	9b 01       	movw	r18, r22
    449e:	ac 01       	movw	r20, r24
    44a0:	60 e0       	ldi	r22, 0x00	; 0
    44a2:	70 e0       	ldi	r23, 0x00	; 0
    44a4:	80 ec       	ldi	r24, 0xC0	; 192
    44a6:	93 e4       	ldi	r25, 0x43	; 67
    44a8:	0e 94 11 37 	call	0x6e22	; 0x6e22 <__subsf3>
   }
   if (y < 0)      return (int)(-angle);
    44ac:	d7 fd       	sbrc	r29, 7
    44ae:	90 58       	subi	r25, 0x80	; 128
   else            return (int)(angle);
    44b0:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <__fixsfsi>
}
    44b4:	cb 01       	movw	r24, r22
    44b6:	df 91       	pop	r29
    44b8:	cf 91       	pop	r28
    44ba:	1f 91       	pop	r17
    44bc:	0f 91       	pop	r16
    44be:	ff 90       	pop	r15
    44c0:	ef 90       	pop	r14
    44c2:	df 90       	pop	r13
    44c4:	cf 90       	pop	r12
    44c6:	bf 90       	pop	r11
    44c8:	af 90       	pop	r10
    44ca:	9f 90       	pop	r9
    44cc:	8f 90       	pop	r8
    44ce:	7f 90       	pop	r7
    44d0:	6f 90       	pop	r6
    44d2:	08 95       	ret

000044d4 <Limiterf>:


float Limiterf (float Value, float Limit)
{
    44d4:	af 92       	push	r10
    44d6:	bf 92       	push	r11
    44d8:	cf 92       	push	r12
    44da:	df 92       	push	r13
    44dc:	ef 92       	push	r14
    44de:	ff 92       	push	r15
    44e0:	0f 93       	push	r16
    44e2:	1f 93       	push	r17
    44e4:	d6 2e       	mov	r13, r22
    44e6:	c7 2e       	mov	r12, r23
    44e8:	b8 2e       	mov	r11, r24
    44ea:	a9 2e       	mov	r10, r25
    44ec:	79 01       	movw	r14, r18
    44ee:	8a 01       	movw	r16, r20
	if (Value > Limit) return   Limit;
    44f0:	a6 01       	movw	r20, r12
    44f2:	95 01       	movw	r18, r10
    44f4:	65 2f       	mov	r22, r21
    44f6:	74 2f       	mov	r23, r20
    44f8:	83 2f       	mov	r24, r19
    44fa:	92 2f       	mov	r25, r18
    44fc:	a8 01       	movw	r20, r16
    44fe:	97 01       	movw	r18, r14
    4500:	0e 94 c5 38 	call	0x718a	; 0x718a <__gesf2>
    4504:	18 16       	cp	r1, r24
    4506:	b4 f0       	brlt	.+44     	; 0x4534 <Limiterf+0x60>
	if (Value < -Limit) return -Limit;
    4508:	17 fb       	bst	r17, 7
    450a:	10 95       	com	r17
    450c:	17 f9       	bld	r17, 7
    450e:	10 95       	com	r17
    4510:	a6 01       	movw	r20, r12
    4512:	95 01       	movw	r18, r10
    4514:	65 2f       	mov	r22, r21
    4516:	74 2f       	mov	r23, r20
    4518:	83 2f       	mov	r24, r19
    451a:	92 2f       	mov	r25, r18
    451c:	a8 01       	movw	r20, r16
    451e:	97 01       	movw	r18, r14
    4520:	0e 94 76 37 	call	0x6eec	; 0x6eec <__cmpsf2>
    4524:	87 fd       	sbrc	r24, 7
    4526:	06 c0       	rjmp	.+12     	; 0x4534 <Limiterf+0x60>
	
	return Value;
    4528:	96 01       	movw	r18, r12
    452a:	c5 01       	movw	r24, r10
    452c:	e3 2e       	mov	r14, r19
    452e:	f2 2e       	mov	r15, r18
    4530:	09 2f       	mov	r16, r25
    4532:	18 2f       	mov	r17, r24
}
    4534:	6e 2d       	mov	r22, r14
    4536:	7f 2d       	mov	r23, r15
    4538:	80 2f       	mov	r24, r16
    453a:	91 2f       	mov	r25, r17
    453c:	1f 91       	pop	r17
    453e:	0f 91       	pop	r16
    4540:	ff 90       	pop	r15
    4542:	ef 90       	pop	r14
    4544:	df 90       	pop	r13
    4546:	cf 90       	pop	r12
    4548:	bf 90       	pop	r11
    454a:	af 90       	pop	r10
    454c:	08 95       	ret

0000454e <Limiter>:

int16_t Limiter (int16_t Value, int16_t Limit)
{
	if (Value > Limit) return   Limit;
    454e:	68 17       	cp	r22, r24
    4550:	79 07       	cpc	r23, r25
    4552:	3c f0       	brlt	.+14     	; 0x4562 <Limiter+0x14>
	if (Value < -Limit) return -Limit;
    4554:	70 95       	com	r23
    4556:	61 95       	neg	r22
    4558:	7f 4f       	sbci	r23, 0xFF	; 255
    455a:	68 17       	cp	r22, r24
    455c:	79 07       	cpc	r23, r25
    455e:	0c f4       	brge	.+2      	; 0x4562 <Limiter+0x14>
    4560:	bc 01       	movw	r22, r24
	
	return Value;
}
    4562:	cb 01       	movw	r24, r22
    4564:	08 95       	ret

00004566 <ScaleSensor>:
			 return (int16_t) y;
		}
	   }	
		*/
	return 0;	
}
    4566:	80 e0       	ldi	r24, 0x00	; 0
    4568:	90 e0       	ldi	r25, 0x00	; 0
    456a:	08 95       	ret

0000456c <_atan2>:



int16_t _atan2(int32_t y, int32_t x)
{
    456c:	2f 92       	push	r2
    456e:	3f 92       	push	r3
    4570:	4f 92       	push	r4
    4572:	5f 92       	push	r5
    4574:	6f 92       	push	r6
    4576:	7f 92       	push	r7
    4578:	8f 92       	push	r8
    457a:	9f 92       	push	r9
    457c:	af 92       	push	r10
    457e:	bf 92       	push	r11
    4580:	cf 92       	push	r12
    4582:	df 92       	push	r13
    4584:	ef 92       	push	r14
    4586:	ff 92       	push	r15
    4588:	0f 93       	push	r16
    458a:	1f 93       	push	r17
    458c:	5b 01       	movw	r10, r22
    458e:	6c 01       	movw	r12, r24
    4590:	39 01       	movw	r6, r18
    4592:	4a 01       	movw	r8, r20
	float z = (float)y / x;
    4594:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    4598:	7b 01       	movw	r14, r22
    459a:	8c 01       	movw	r16, r24
    459c:	c4 01       	movw	r24, r8
    459e:	b3 01       	movw	r22, r6
    45a0:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    45a4:	9b 01       	movw	r18, r22
    45a6:	ac 01       	movw	r20, r24
    45a8:	c8 01       	movw	r24, r16
    45aa:	b7 01       	movw	r22, r14
    45ac:	0e 94 7a 37 	call	0x6ef4	; 0x6ef4 <__divsf3>
    45b0:	f6 2e       	mov	r15, r22
    45b2:	07 2f       	mov	r16, r23
    45b4:	18 2f       	mov	r17, r24
    45b6:	e9 2e       	mov	r14, r25
	int16_t a;
	if ( abs(y) < abs(x) ){
    45b8:	95 01       	movw	r18, r10
    45ba:	b7 fe       	sbrs	r11, 7
    45bc:	03 c0       	rjmp	.+6      	; 0x45c4 <_atan2+0x58>
    45be:	30 95       	com	r19
    45c0:	21 95       	neg	r18
    45c2:	3f 4f       	sbci	r19, 0xFF	; 255
    45c4:	c3 01       	movw	r24, r6
    45c6:	77 fe       	sbrs	r7, 7
    45c8:	03 c0       	rjmp	.+6      	; 0x45d0 <_atan2+0x64>
    45ca:	90 95       	com	r25
    45cc:	81 95       	neg	r24
    45ce:	9f 4f       	sbci	r25, 0xFF	; 255
    45d0:	28 17       	cp	r18, r24
    45d2:	39 07       	cpc	r19, r25
    45d4:	8c f5       	brge	.+98     	; 0x4638 <_atan2+0xcc>
		a = 573 * z / (1.0f + 0.28f * z * z);
    45d6:	6f 2d       	mov	r22, r15
    45d8:	70 2f       	mov	r23, r16
    45da:	81 2f       	mov	r24, r17
    45dc:	9e 2d       	mov	r25, r14
    45de:	20 e0       	ldi	r18, 0x00	; 0
    45e0:	30 e4       	ldi	r19, 0x40	; 64
    45e2:	4f e0       	ldi	r20, 0x0F	; 15
    45e4:	54 e4       	ldi	r21, 0x44	; 68
    45e6:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    45ea:	1b 01       	movw	r2, r22
    45ec:	2c 01       	movw	r4, r24
    45ee:	6f 2d       	mov	r22, r15
    45f0:	70 2f       	mov	r23, r16
    45f2:	81 2f       	mov	r24, r17
    45f4:	9e 2d       	mov	r25, r14
    45f6:	29 e2       	ldi	r18, 0x29	; 41
    45f8:	3c e5       	ldi	r19, 0x5C	; 92
    45fa:	4f e8       	ldi	r20, 0x8F	; 143
    45fc:	5e e3       	ldi	r21, 0x3E	; 62
    45fe:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    4602:	2f 2d       	mov	r18, r15
    4604:	30 2f       	mov	r19, r16
    4606:	41 2f       	mov	r20, r17
    4608:	5e 2d       	mov	r21, r14
    460a:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    460e:	20 e0       	ldi	r18, 0x00	; 0
    4610:	30 e0       	ldi	r19, 0x00	; 0
    4612:	40 e8       	ldi	r20, 0x80	; 128
    4614:	5f e3       	ldi	r21, 0x3F	; 63
    4616:	0e 94 12 37 	call	0x6e24	; 0x6e24 <__addsf3>
    461a:	9b 01       	movw	r18, r22
    461c:	ac 01       	movw	r20, r24
    461e:	c2 01       	movw	r24, r4
    4620:	b1 01       	movw	r22, r2
    4622:	0e 94 7a 37 	call	0x6ef4	; 0x6ef4 <__divsf3>
    4626:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <__fixsfsi>
		if (x<0) {
    462a:	97 fe       	sbrs	r9, 7
    462c:	35 c0       	rjmp	.+106    	; 0x4698 <_atan2+0x12c>
			if (y<0) a -= 1800;
    462e:	d7 fc       	sbrc	r13, 7
    4630:	31 c0       	rjmp	.+98     	; 0x4694 <_atan2+0x128>
			else a += 1800;
    4632:	68 5f       	subi	r22, 0xF8	; 248
    4634:	78 4f       	sbci	r23, 0xF8	; 248
    4636:	30 c0       	rjmp	.+96     	; 0x4698 <_atan2+0x12c>
		}
	} else {
		a = 900 - 573 * z / (z * z + 0.28f);
    4638:	6f 2d       	mov	r22, r15
    463a:	70 2f       	mov	r23, r16
    463c:	81 2f       	mov	r24, r17
    463e:	9e 2d       	mov	r25, r14
    4640:	20 e0       	ldi	r18, 0x00	; 0
    4642:	30 e4       	ldi	r19, 0x40	; 64
    4644:	4f e0       	ldi	r20, 0x0F	; 15
    4646:	54 e4       	ldi	r21, 0x44	; 68
    4648:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    464c:	3b 01       	movw	r6, r22
    464e:	4c 01       	movw	r8, r24
    4650:	6f 2d       	mov	r22, r15
    4652:	70 2f       	mov	r23, r16
    4654:	81 2f       	mov	r24, r17
    4656:	9e 2d       	mov	r25, r14
    4658:	2f 2d       	mov	r18, r15
    465a:	30 2f       	mov	r19, r16
    465c:	41 2f       	mov	r20, r17
    465e:	5e 2d       	mov	r21, r14
    4660:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    4664:	29 e2       	ldi	r18, 0x29	; 41
    4666:	3c e5       	ldi	r19, 0x5C	; 92
    4668:	4f e8       	ldi	r20, 0x8F	; 143
    466a:	5e e3       	ldi	r21, 0x3E	; 62
    466c:	0e 94 12 37 	call	0x6e24	; 0x6e24 <__addsf3>
    4670:	9b 01       	movw	r18, r22
    4672:	ac 01       	movw	r20, r24
    4674:	c4 01       	movw	r24, r8
    4676:	b3 01       	movw	r22, r6
    4678:	0e 94 7a 37 	call	0x6ef4	; 0x6ef4 <__divsf3>
    467c:	9b 01       	movw	r18, r22
    467e:	ac 01       	movw	r20, r24
    4680:	60 e0       	ldi	r22, 0x00	; 0
    4682:	70 e0       	ldi	r23, 0x00	; 0
    4684:	81 e6       	ldi	r24, 0x61	; 97
    4686:	94 e4       	ldi	r25, 0x44	; 68
    4688:	0e 94 11 37 	call	0x6e22	; 0x6e22 <__subsf3>
    468c:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <__fixsfsi>
		if (y<0) a -= 1800;
    4690:	d7 fe       	sbrs	r13, 7
    4692:	02 c0       	rjmp	.+4      	; 0x4698 <_atan2+0x12c>
    4694:	68 50       	subi	r22, 0x08	; 8
    4696:	77 40       	sbci	r23, 0x07	; 7
	}
	return a;
}
    4698:	cb 01       	movw	r24, r22
    469a:	1f 91       	pop	r17
    469c:	0f 91       	pop	r16
    469e:	ff 90       	pop	r15
    46a0:	ef 90       	pop	r14
    46a2:	df 90       	pop	r13
    46a4:	cf 90       	pop	r12
    46a6:	bf 90       	pop	r11
    46a8:	af 90       	pop	r10
    46aa:	9f 90       	pop	r9
    46ac:	8f 90       	pop	r8
    46ae:	7f 90       	pop	r7
    46b0:	6f 90       	pop	r6
    46b2:	5f 90       	pop	r5
    46b4:	4f 90       	pop	r4
    46b6:	3f 90       	pop	r3
    46b8:	2f 90       	pop	r2
    46ba:	08 95       	ret

000046bc <InvSqrt>:

float InvSqrt (float x)
{
    46bc:	6f 92       	push	r6
    46be:	7f 92       	push	r7
    46c0:	8f 92       	push	r8
    46c2:	9f 92       	push	r9
    46c4:	af 92       	push	r10
    46c6:	bf 92       	push	r11
    46c8:	cf 92       	push	r12
    46ca:	df 92       	push	r13
    46cc:	ef 92       	push	r14
    46ce:	ff 92       	push	r15
    46d0:	0f 93       	push	r16
    46d2:	1f 93       	push	r17
    46d4:	5b 01       	movw	r10, r22
    46d6:	6c 01       	movw	r12, r24
	union{
		int32_t i;
		float   f;
	} conv;
	conv.f = x;
	conv.i = 0x5f3759df - (conv.i >> 1);
    46d8:	dc 01       	movw	r26, r24
    46da:	cb 01       	movw	r24, r22
    46dc:	b5 95       	asr	r27
    46de:	a7 95       	ror	r26
    46e0:	97 95       	ror	r25
    46e2:	87 95       	ror	r24
    46e4:	2f ed       	ldi	r18, 0xDF	; 223
    46e6:	e2 2e       	mov	r14, r18
    46e8:	29 e5       	ldi	r18, 0x59	; 89
    46ea:	f2 2e       	mov	r15, r18
    46ec:	27 e3       	ldi	r18, 0x37	; 55
    46ee:	02 2f       	mov	r16, r18
    46f0:	2f e5       	ldi	r18, 0x5F	; 95
    46f2:	12 2f       	mov	r17, r18
    46f4:	e8 1a       	sub	r14, r24
    46f6:	f9 0a       	sbc	r15, r25
    46f8:	0a 0b       	sbc	r16, r26
    46fa:	1b 0b       	sbc	r17, r27
	return 0.5f * conv.f * (3.0f - x * conv.f * conv.f);
    46fc:	c8 01       	movw	r24, r16
    46fe:	b7 01       	movw	r22, r14
    4700:	20 e0       	ldi	r18, 0x00	; 0
    4702:	30 e0       	ldi	r19, 0x00	; 0
    4704:	40 e0       	ldi	r20, 0x00	; 0
    4706:	5f e3       	ldi	r21, 0x3F	; 63
    4708:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    470c:	3b 01       	movw	r6, r22
    470e:	4c 01       	movw	r8, r24
    4710:	c6 01       	movw	r24, r12
    4712:	b5 01       	movw	r22, r10
    4714:	a8 01       	movw	r20, r16
    4716:	97 01       	movw	r18, r14
    4718:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    471c:	a8 01       	movw	r20, r16
    471e:	97 01       	movw	r18, r14
    4720:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
    4724:	9b 01       	movw	r18, r22
    4726:	ac 01       	movw	r20, r24
    4728:	60 e0       	ldi	r22, 0x00	; 0
    472a:	70 e0       	ldi	r23, 0x00	; 0
    472c:	80 e4       	ldi	r24, 0x40	; 64
    472e:	90 e4       	ldi	r25, 0x40	; 64
    4730:	0e 94 11 37 	call	0x6e22	; 0x6e22 <__subsf3>
    4734:	9b 01       	movw	r18, r22
    4736:	ac 01       	movw	r20, r24
    4738:	c4 01       	movw	r24, r8
    473a:	b3 01       	movw	r22, r6
    473c:	0e 94 c9 38 	call	0x7192	; 0x7192 <__mulsf3>
}
    4740:	1f 91       	pop	r17
    4742:	0f 91       	pop	r16
    4744:	ff 90       	pop	r15
    4746:	ef 90       	pop	r14
    4748:	df 90       	pop	r13
    474a:	cf 90       	pop	r12
    474c:	bf 90       	pop	r11
    474e:	af 90       	pop	r10
    4750:	9f 90       	pop	r9
    4752:	8f 90       	pop	r8
    4754:	7f 90       	pop	r7
    4756:	6f 90       	pop	r6
    4758:	08 95       	ret

0000475a <Motor_GenerateOutputSignal>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    475a:	f8 94       	cli
	
	// Make sure we have spent enough time between pulses
	// Also, handle the odd case where the TCNT2_X rolls over and TCNT2_X < ElapsedTCNT2
	ATOMIC_BLOCK(ATOMIC_FORCEON)
   {
      CurrentTCNT2 = TCNT2_X;
    475c:	80 91 a9 05 	lds	r24, 0x05A9
    4760:	90 91 aa 05 	lds	r25, 0x05AA
    4764:	90 93 dc 07 	sts	0x07DC, r25
    4768:	80 93 db 07 	sts	0x07DB, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    476c:	78 94       	sei
   }

   if (CurrentTCNT2 >= MotorStartTCNT) 
    476e:	20 91 db 07 	lds	r18, 0x07DB
    4772:	30 91 dc 07 	lds	r19, 0x07DC
    4776:	80 91 ce 07 	lds	r24, 0x07CE
    477a:	90 91 cf 07 	lds	r25, 0x07CF
    477e:	28 17       	cp	r18, r24
    4780:	39 07       	cpc	r19, r25
    4782:	38 f0       	brcs	.+14     	; 0x4792 <Motor_GenerateOutputSignal+0x38>
   {
		ElapsedTCNT2 = CurrentTCNT2 - MotorStartTCNT;
    4784:	28 1b       	sub	r18, r24
    4786:	39 0b       	sbc	r19, r25
    4788:	30 93 c9 07 	sts	0x07C9, r19
    478c:	20 93 c8 07 	sts	0x07C8, r18
    4790:	08 c0       	rjmp	.+16     	; 0x47a2 <Motor_GenerateOutputSignal+0x48>
   }
   else 
   {
		ElapsedTCNT2 = (0xffff - MotorStartTCNT) + CurrentTCNT2;
    4792:	80 95       	com	r24
    4794:	90 95       	com	r25
    4796:	82 0f       	add	r24, r18
    4798:	93 1f       	adc	r25, r19
    479a:	90 93 c9 07 	sts	0x07C9, r25
    479e:	80 93 c8 07 	sts	0x07C8, r24
	
	// If period less than 1/ESC_RATE, pad it out.
	// check Timer.c for timing table
	
	//interval in us
	PMW_Pulse_Interval = (PWM_LOW_PULSE_INTERVAL - ( ElapsedTCNT2 * 409)); // 409 = OV time of TCNT2
    47a2:	40 91 c8 07 	lds	r20, 0x07C8
    47a6:	50 91 c9 07 	lds	r21, 0x07C9
    47aa:	89 e9       	ldi	r24, 0x99	; 153
    47ac:	91 e0       	ldi	r25, 0x01	; 1
    47ae:	48 9f       	mul	r20, r24
    47b0:	90 01       	movw	r18, r0
    47b2:	49 9f       	mul	r20, r25
    47b4:	30 0d       	add	r19, r0
    47b6:	58 9f       	mul	r21, r24
    47b8:	30 0d       	add	r19, r0
    47ba:	11 24       	eor	r1, r1
    47bc:	80 ea       	ldi	r24, 0xA0	; 160
    47be:	9f e0       	ldi	r25, 0x0F	; 15
    47c0:	82 1b       	sub	r24, r18
    47c2:	93 0b       	sbc	r25, r19
    47c4:	0d c0       	rjmp	.+26     	; 0x47e0 <Motor_GenerateOutputSignal+0x86>
	while (PMW_Pulse_Interval > 0)
	{
		//LED_Orange=~LED_Orange;
			TCNT2 =0;
    47c6:	10 92 b2 00 	sts	0x00B2, r1
			if (PMW_Pulse_Interval>100)
    47ca:	85 36       	cpi	r24, 0x65	; 101
    47cc:	91 05       	cpc	r25, r1
    47ce:	3c f0       	brlt	.+14     	; 0x47de <Motor_GenerateOutputSignal+0x84>
			{   // make big jumps if PWM_Low_Pulse_Interval is high
				// [more accurate to decrease the % between the while loop and the PWM_Low_Pulse_Interval -=80 execution time.]
				while (TCNT2 < 40); //=8us 1.50
    47d0:	20 91 b2 00 	lds	r18, 0x00B2
    47d4:	28 32       	cpi	r18, 0x28	; 40
    47d6:	e0 f3       	brcs	.-8      	; 0x47d0 <Motor_GenerateOutputSignal+0x76>
				PMW_Pulse_Interval -=80;	
    47d8:	80 55       	subi	r24, 0x50	; 80
    47da:	90 40       	sbci	r25, 0x00	; 0
    47dc:	01 c0       	rjmp	.+2      	; 0x47e0 <Motor_GenerateOutputSignal+0x86>
			}
			else
			{   //
				///////////while (TCNT2 < 5); //=8us
				PMW_Pulse_Interval -=1;
    47de:	01 97       	sbiw	r24, 0x01	; 1
    47e0:	90 93 d4 07 	sts	0x07D4, r25
    47e4:	80 93 d3 07 	sts	0x07D3, r24
	// If period less than 1/ESC_RATE, pad it out.
	// check Timer.c for timing table
	
	//interval in us
	PMW_Pulse_Interval = (PWM_LOW_PULSE_INTERVAL - ( ElapsedTCNT2 * 409)); // 409 = OV time of TCNT2
	while (PMW_Pulse_Interval > 0)
    47e8:	80 91 d3 07 	lds	r24, 0x07D3
    47ec:	90 91 d4 07 	lds	r25, 0x07D4
    47f0:	18 16       	cp	r1, r24
    47f2:	19 06       	cpc	r1, r25
    47f4:	44 f3       	brlt	.-48     	; 0x47c6 <Motor_GenerateOutputSignal+0x6c>
				PMW_Pulse_Interval -=1;
			}
			
	}
	
	times+=1;
    47f6:	80 91 28 05 	lds	r24, 0x0528
    47fa:	8f 5f       	subi	r24, 0xFF	; 255
    47fc:	80 93 28 05 	sts	0x0528, r24
	
	// Set motor limits (0 -> MOTORS_HIGH_VALUE)
	if ( MotorOut[0] < 0 ) m1 = 0;
    4800:	80 91 84 05 	lds	r24, 0x0584
    4804:	90 91 85 05 	lds	r25, 0x0585
    4808:	97 ff       	sbrs	r25, 7
    480a:	05 c0       	rjmp	.+10     	; 0x4816 <Motor_GenerateOutputSignal+0xbc>
    480c:	10 92 d6 07 	sts	0x07D6, r1
    4810:	10 92 d5 07 	sts	0x07D5, r1
    4814:	0a c0       	rjmp	.+20     	; 0x482a <Motor_GenerateOutputSignal+0xd0>
	else if ( MotorOut[0] > MOTORS_HIGH_VALUE ) m1 = MOTORS_HIGH_VALUE;
    4816:	24 e0       	ldi	r18, 0x04	; 4
    4818:	8f 37       	cpi	r24, 0x7F	; 127
    481a:	92 07       	cpc	r25, r18
    481c:	14 f0       	brlt	.+4      	; 0x4822 <Motor_GenerateOutputSignal+0xc8>
    481e:	8e e7       	ldi	r24, 0x7E	; 126
    4820:	94 e0       	ldi	r25, 0x04	; 4
	else m1 = MotorOut[0];
    4822:	90 93 d6 07 	sts	0x07D6, r25
    4826:	80 93 d5 07 	sts	0x07D5, r24
	
	if ( MotorOut[1] < 0 ) m2 = 0;
    482a:	80 91 86 05 	lds	r24, 0x0586
    482e:	90 91 87 05 	lds	r25, 0x0587
    4832:	97 ff       	sbrs	r25, 7
    4834:	05 c0       	rjmp	.+10     	; 0x4840 <Motor_GenerateOutputSignal+0xe6>
    4836:	10 92 cd 07 	sts	0x07CD, r1
    483a:	10 92 cc 07 	sts	0x07CC, r1
    483e:	0a c0       	rjmp	.+20     	; 0x4854 <Motor_GenerateOutputSignal+0xfa>
	else if ( MotorOut[1] > MOTORS_HIGH_VALUE ) m2 = MOTORS_HIGH_VALUE;
    4840:	24 e0       	ldi	r18, 0x04	; 4
    4842:	8f 37       	cpi	r24, 0x7F	; 127
    4844:	92 07       	cpc	r25, r18
    4846:	14 f0       	brlt	.+4      	; 0x484c <Motor_GenerateOutputSignal+0xf2>
    4848:	8e e7       	ldi	r24, 0x7E	; 126
    484a:	94 e0       	ldi	r25, 0x04	; 4
	else m2 = MotorOut[1];
    484c:	90 93 cd 07 	sts	0x07CD, r25
    4850:	80 93 cc 07 	sts	0x07CC, r24

	if ( MotorOut[2] < 0 ) m3 = 0;
    4854:	80 91 88 05 	lds	r24, 0x0588
    4858:	90 91 89 05 	lds	r25, 0x0589
    485c:	97 ff       	sbrs	r25, 7
    485e:	05 c0       	rjmp	.+10     	; 0x486a <Motor_GenerateOutputSignal+0x110>
    4860:	10 92 da 07 	sts	0x07DA, r1
    4864:	10 92 d9 07 	sts	0x07D9, r1
    4868:	0a c0       	rjmp	.+20     	; 0x487e <Motor_GenerateOutputSignal+0x124>
	else if ( MotorOut[2] > MOTORS_HIGH_VALUE ) m3 = MOTORS_HIGH_VALUE;
    486a:	24 e0       	ldi	r18, 0x04	; 4
    486c:	8f 37       	cpi	r24, 0x7F	; 127
    486e:	92 07       	cpc	r25, r18
    4870:	14 f0       	brlt	.+4      	; 0x4876 <Motor_GenerateOutputSignal+0x11c>
    4872:	8e e7       	ldi	r24, 0x7E	; 126
    4874:	94 e0       	ldi	r25, 0x04	; 4
	else m3 = MotorOut[2];
    4876:	90 93 da 07 	sts	0x07DA, r25
    487a:	80 93 d9 07 	sts	0x07D9, r24

	if ( MotorOut[3] < 0 ) m4 = 0;
    487e:	80 91 8a 05 	lds	r24, 0x058A
    4882:	90 91 8b 05 	lds	r25, 0x058B
    4886:	97 ff       	sbrs	r25, 7
    4888:	05 c0       	rjmp	.+10     	; 0x4894 <Motor_GenerateOutputSignal+0x13a>
    488a:	10 92 cb 07 	sts	0x07CB, r1
    488e:	10 92 ca 07 	sts	0x07CA, r1
    4892:	0a c0       	rjmp	.+20     	; 0x48a8 <Motor_GenerateOutputSignal+0x14e>
	else if ( MotorOut[3] > MOTORS_HIGH_VALUE ) m4 = MOTORS_HIGH_VALUE;
    4894:	24 e0       	ldi	r18, 0x04	; 4
    4896:	8f 37       	cpi	r24, 0x7F	; 127
    4898:	92 07       	cpc	r25, r18
    489a:	14 f0       	brlt	.+4      	; 0x48a0 <Motor_GenerateOutputSignal+0x146>
    489c:	8e e7       	ldi	r24, 0x7E	; 126
    489e:	94 e0       	ldi	r25, 0x04	; 4
	else m4 = MotorOut[3];
    48a0:	90 93 cb 07 	sts	0x07CB, r25
    48a4:	80 93 ca 07 	sts	0x07CA, r24
	
	
	// Minimum pulse we want to make is 1ms, max is 2ms
	// So to start, let's make the 1ms base pulse.
	// First, we switch on the motor outputs
	M1 = 1;
    48a8:	46 9a       	sbi	0x08, 6	; 8
	M2 = 1;
    48aa:	44 9a       	sbi	0x08, 4	; 8
	M3 = 1;
    48ac:	42 9a       	sbi	0x08, 2	; 8
	if (Config.FrameType== FRAMETYPE_QUADCOPTER) 
    48ae:	80 91 e0 06 	lds	r24, 0x06E0
    48b2:	81 30       	cpi	r24, 0x01	; 1
    48b4:	11 f4       	brne	.+4      	; 0x48ba <Motor_GenerateOutputSignal+0x160>
	{
		M4 =1;
    48b6:	43 9a       	sbi	0x08, 3	; 8
    48b8:	09 c0       	rjmp	.+18     	; 0x48cc <Motor_GenerateOutputSignal+0x172>
	}
	else if (Config.FrameType== FRAMETYPE_TRICOPTER)
    48ba:	82 30       	cpi	r24, 0x02	; 2
    48bc:	39 f4       	brne	.+14     	; 0x48cc <Motor_GenerateOutputSignal+0x172>
	{
		if (times==5)
    48be:	80 91 28 05 	lds	r24, 0x0528
    48c2:	85 30       	cpi	r24, 0x05	; 5
    48c4:	19 f4       	brne	.+6      	; 0x48cc <Motor_GenerateOutputSignal+0x172>
		{
			M4 = 1;		// time to update servo
    48c6:	43 9a       	sbi	0x08, 3	; 8
			//UpdateServo = FALSE;
			times=0;	// reset time divider
    48c8:	10 92 28 05 	sts	0x0528, r1
		} // else keep it zero.			
	} 
	
	
	// Minimum pulse width we want to make is 1ms, max is 2ms
	PMW_Pulse_Interval = BASE_PULSE + Config.ThrottleMin;
    48cc:	80 91 e4 06 	lds	r24, 0x06E4
    48d0:	90 e0       	ldi	r25, 0x00	; 0
    48d2:	80 5e       	subi	r24, 0xE0	; 224
    48d4:	9c 4f       	sbci	r25, 0xFC	; 252
    48d6:	0d c0       	rjmp	.+26     	; 0x48f2 <Motor_GenerateOutputSignal+0x198>
	while (PMW_Pulse_Interval > 0)
	{
			TCNT2 =0;
    48d8:	10 92 b2 00 	sts	0x00B2, r1
			if (PMW_Pulse_Interval>100)
    48dc:	85 36       	cpi	r24, 0x65	; 101
    48de:	91 05       	cpc	r25, r1
    48e0:	3c f0       	brlt	.+14     	; 0x48f0 <Motor_GenerateOutputSignal+0x196>
			{   // make big jumps if PWM_Low_Pulse_Interval is high
				// [more accurate to decrease the % between the while loop and the PWM_Low_Pulse_Interval -=80 execution time.]
				while (TCNT2 < 45); //=8us //1. 50
    48e2:	20 91 b2 00 	lds	r18, 0x00B2
    48e6:	2d 32       	cpi	r18, 0x2D	; 45
    48e8:	e0 f3       	brcs	.-8      	; 0x48e2 <Motor_GenerateOutputSignal+0x188>
				PMW_Pulse_Interval -=80;	
    48ea:	80 55       	subi	r24, 0x50	; 80
    48ec:	90 40       	sbci	r25, 0x00	; 0
    48ee:	01 c0       	rjmp	.+2      	; 0x48f2 <Motor_GenerateOutputSignal+0x198>
			}
			else
			{   //
				//////while (TCNT2 < 5); //=8us
				PMW_Pulse_Interval -=1;
    48f0:	01 97       	sbiw	r24, 0x01	; 1
    48f2:	90 93 d4 07 	sts	0x07D4, r25
    48f6:	80 93 d3 07 	sts	0x07D3, r24
	} 
	
	
	// Minimum pulse width we want to make is 1ms, max is 2ms
	PMW_Pulse_Interval = BASE_PULSE + Config.ThrottleMin;
	while (PMW_Pulse_Interval > 0)
    48fa:	80 91 d3 07 	lds	r24, 0x07D3
    48fe:	90 91 d4 07 	lds	r25, 0x07D4
    4902:	18 16       	cp	r1, r24
    4904:	19 06       	cpc	r1, r25
    4906:	44 f3       	brlt	.-48     	; 0x48d8 <Motor_GenerateOutputSignal+0x17e>
				PMW_Pulse_Interval -=1;
			}
	}
		
	
	for (i=0;i<MOTORS_HIGH_VALUE+4;i+=4)			// 1000 gives a max of 2200us 
    4908:	10 92 d2 07 	sts	0x07D2, r1
    490c:	10 92 d1 07 	sts	0x07D1, r1
    4910:	39 c0       	rjmp	.+114    	; 0x4984 <Motor_GenerateOutputSignal+0x22a>
		/*
		MOTORS_HIGH_VALUE+4
		in order to guarantee that all Ms are zeros when getting out of this loop.
		*/
		
		if (i>=m1) M1 = 0;
    4912:	20 91 d1 07 	lds	r18, 0x07D1
    4916:	30 91 d2 07 	lds	r19, 0x07D2
    491a:	80 91 d5 07 	lds	r24, 0x07D5
    491e:	90 91 d6 07 	lds	r25, 0x07D6
    4922:	28 17       	cp	r18, r24
    4924:	39 07       	cpc	r19, r25
    4926:	08 f0       	brcs	.+2      	; 0x492a <Motor_GenerateOutputSignal+0x1d0>
    4928:	46 98       	cbi	0x08, 6	; 8
		if (i>=m2) M2 = 0;
    492a:	20 91 d1 07 	lds	r18, 0x07D1
    492e:	30 91 d2 07 	lds	r19, 0x07D2
    4932:	80 91 cc 07 	lds	r24, 0x07CC
    4936:	90 91 cd 07 	lds	r25, 0x07CD
    493a:	28 17       	cp	r18, r24
    493c:	39 07       	cpc	r19, r25
    493e:	08 f0       	brcs	.+2      	; 0x4942 <Motor_GenerateOutputSignal+0x1e8>
    4940:	44 98       	cbi	0x08, 4	; 8
		if (i>=m3) M3 = 0;
    4942:	20 91 d1 07 	lds	r18, 0x07D1
    4946:	30 91 d2 07 	lds	r19, 0x07D2
    494a:	80 91 d9 07 	lds	r24, 0x07D9
    494e:	90 91 da 07 	lds	r25, 0x07DA
    4952:	28 17       	cp	r18, r24
    4954:	39 07       	cpc	r19, r25
    4956:	08 f0       	brcs	.+2      	; 0x495a <Motor_GenerateOutputSignal+0x200>
    4958:	42 98       	cbi	0x08, 2	; 8
		if (i>=m4) M4 = 0;
    495a:	20 91 d1 07 	lds	r18, 0x07D1
    495e:	30 91 d2 07 	lds	r19, 0x07D2
    4962:	80 91 ca 07 	lds	r24, 0x07CA
    4966:	90 91 cb 07 	lds	r25, 0x07CB
    496a:	28 17       	cp	r18, r24
    496c:	39 07       	cpc	r19, r25
    496e:	08 f0       	brcs	.+2      	; 0x4972 <Motor_GenerateOutputSignal+0x218>
    4970:	43 98       	cbi	0x08, 3	; 8
				PMW_Pulse_Interval -=1;
			}
	}
		
	
	for (i=0;i<MOTORS_HIGH_VALUE+4;i+=4)			// 1000 gives a max of 2200us 
    4972:	80 91 d1 07 	lds	r24, 0x07D1
    4976:	90 91 d2 07 	lds	r25, 0x07D2
    497a:	04 96       	adiw	r24, 0x04	; 4
    497c:	90 93 d2 07 	sts	0x07D2, r25
    4980:	80 93 d1 07 	sts	0x07D1, r24
    4984:	80 91 d1 07 	lds	r24, 0x07D1
    4988:	90 91 d2 07 	lds	r25, 0x07D2
    498c:	24 e0       	ldi	r18, 0x04	; 4
    498e:	82 38       	cpi	r24, 0x82	; 130
    4990:	92 07       	cpc	r25, r18
    4992:	08 f4       	brcc	.+2      	; 0x4996 <Motor_GenerateOutputSignal+0x23c>
    4994:	be cf       	rjmp	.-132    	; 0x4912 <Motor_GenerateOutputSignal+0x1b8>
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    4996:	f8 94       	cli
		if (i>=m4) M4 = 0;
	}
	// Measure period of ESC rate from here
    ATOMIC_BLOCK(ATOMIC_FORCEON)
    {
      MotorStartTCNT = TCNT2_X;
    4998:	80 91 a9 05 	lds	r24, 0x05A9
    499c:	90 91 aa 05 	lds	r25, 0x05AA
    49a0:	90 93 cf 07 	sts	0x07CF, r25
    49a4:	80 93 ce 07 	sts	0x07CE, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    49a8:	78 94       	sei
    }
	
	
 }
    49aa:	08 95       	ret

000049ac <CalculateSignalLength1>:



void CalculateSignalLength1(uint8_t ChannelIndex)
{
	if (TCNT1 > RX_raw[0][ChannelIndex] )
    49ac:	20 91 84 00 	lds	r18, 0x0084
    49b0:	30 91 85 00 	lds	r19, 0x0085
    49b4:	90 e0       	ldi	r25, 0x00	; 0
    49b6:	88 0f       	add	r24, r24
    49b8:	99 1f       	adc	r25, r25
    49ba:	fc 01       	movw	r30, r24
    49bc:	e4 51       	subi	r30, 0x14	; 20
    49be:	f8 4f       	sbci	r31, 0xF8	; 248
    49c0:	40 81       	ld	r20, Z
    49c2:	51 81       	ldd	r21, Z+1	; 0x01
    49c4:	dc 01       	movw	r26, r24
    49c6:	a6 54       	subi	r26, 0x46	; 70
    49c8:	ba 4f       	sbci	r27, 0xFA	; 250
    49ca:	42 17       	cp	r20, r18
    49cc:	53 07       	cpc	r21, r19
    49ce:	48 f4       	brcc	.+18     	; 0x49e2 <CalculateSignalLength1+0x36>
	{
		RX_Length[0][ChannelIndex] = TCNT1 - RX_raw[0][ChannelIndex] ;	
    49d0:	20 91 84 00 	lds	r18, 0x0084
    49d4:	30 91 85 00 	lds	r19, 0x0085
    49d8:	80 81       	ld	r24, Z
    49da:	91 81       	ldd	r25, Z+1	; 0x01
    49dc:	28 1b       	sub	r18, r24
    49de:	39 0b       	sbc	r19, r25
    49e0:	0a c0       	rjmp	.+20     	; 0x49f6 <CalculateSignalLength1+0x4a>
	}
	else
	{
		RX_Length[0][ChannelIndex] = (0xffff - RX_raw[0][ChannelIndex] + TCNT1 );	
    49e2:	20 81       	ld	r18, Z
    49e4:	31 81       	ldd	r19, Z+1	; 0x01
    49e6:	80 91 84 00 	lds	r24, 0x0084
    49ea:	90 91 85 00 	lds	r25, 0x0085
    49ee:	20 95       	com	r18
    49f0:	30 95       	com	r19
    49f2:	28 0f       	add	r18, r24
    49f4:	39 1f       	adc	r19, r25
    49f6:	11 96       	adiw	r26, 0x01	; 1
    49f8:	3c 93       	st	X, r19
    49fa:	2e 93       	st	-X, r18
    49fc:	08 95       	ret

000049fe <CalculateSignalLength2>:
	}
	
}
void CalculateSignalLength2(uint8_t ChannelIndex)
{
	uint16_t TCNT1_TEMP = TCNT1;
    49fe:	20 91 84 00 	lds	r18, 0x0084
    4a02:	30 91 85 00 	lds	r19, 0x0085
	if (TCNT1_TEMP > RX_raw[1][ChannelIndex] )
    4a06:	90 e0       	ldi	r25, 0x00	; 0
    4a08:	05 96       	adiw	r24, 0x05	; 5
    4a0a:	88 0f       	add	r24, r24
    4a0c:	99 1f       	adc	r25, r25
    4a0e:	fc 01       	movw	r30, r24
    4a10:	e4 51       	subi	r30, 0x14	; 20
    4a12:	f8 4f       	sbci	r31, 0xF8	; 248
    4a14:	40 81       	ld	r20, Z
    4a16:	51 81       	ldd	r21, Z+1	; 0x01
    4a18:	dc 01       	movw	r26, r24
    4a1a:	a6 54       	subi	r26, 0x46	; 70
    4a1c:	ba 4f       	sbci	r27, 0xFA	; 250
    4a1e:	42 17       	cp	r20, r18
    4a20:	53 07       	cpc	r21, r19
    4a22:	40 f4       	brcc	.+16     	; 0x4a34 <CalculateSignalLength2+0x36>
	{
		RX_Length[1][ChannelIndex] = TCNT1_TEMP - RX_raw[1][ChannelIndex] ;	
    4a24:	80 81       	ld	r24, Z
    4a26:	91 81       	ldd	r25, Z+1	; 0x01
    4a28:	28 1b       	sub	r18, r24
    4a2a:	39 0b       	sbc	r19, r25
    4a2c:	11 96       	adiw	r26, 0x01	; 1
    4a2e:	3c 93       	st	X, r19
    4a30:	2e 93       	st	-X, r18
    4a32:	08 95       	ret
	}
	else
	{
		RX_Length[1][ChannelIndex] = (0xffff - RX_raw[1][ChannelIndex] + TCNT1_TEMP);	
    4a34:	40 81       	ld	r20, Z
    4a36:	51 81       	ldd	r21, Z+1	; 0x01
    4a38:	40 95       	com	r20
    4a3a:	50 95       	com	r21
    4a3c:	42 0f       	add	r20, r18
    4a3e:	53 1f       	adc	r21, r19
    4a40:	11 96       	adiw	r26, 0x01	; 1
    4a42:	5c 93       	st	X, r21
    4a44:	4e 93       	st	-X, r20
    4a46:	08 95       	ret

00004a48 <RX_Init>:


void RX_Init(void)
{
	
	RX_AUX_DIR   	 	= INPUT;
    4a48:	20 98       	cbi	0x04, 0	; 4

#ifdef PRIMARY_INPUT_RX

	if (Config.RX_mode==RX_mode_BuddyMode)
    4a4a:	80 91 db 06 	lds	r24, 0x06DB
    4a4e:	88 23       	and	r24, r24
    4a50:	f1 f4       	brne	.+60     	; 0x4a8e <RX_Init+0x46>
	{
	
		ActiveRXIndex=0;
    4a52:	10 92 b8 05 	sts	0x05B8, r1
		RX1_ROLL_DIR 		= INPUT;
    4a56:	52 98       	cbi	0x0a, 2	; 10
		RX1_PITCH_DIR 		= INPUT;
    4a58:	50 98       	cbi	0x0a, 0	; 10
		RX1_COLL_DIR   		= INPUT;
    4a5a:	53 98       	cbi	0x0a, 3	; 10
		RX1_YAW_DIR   	 	= INPUT;
    4a5c:	22 98       	cbi	0x04, 2	; 4

		// enable interrupts
		EICRA  = _BV(ISC00) | _BV(ISC10) | _BV(ISC20);	// any edge on INT0, INT1 and INT2
    4a5e:	85 e1       	ldi	r24, 0x15	; 21
    4a60:	80 93 69 00 	sts	0x0069, r24
		EIMSK  = _BV(INT0)  | _BV(INT1)  | _BV(INT2);	// enable interrupt for INT0, INT1 and INT2
    4a64:	87 e0       	ldi	r24, 0x07	; 7
    4a66:	8d bb       	out	0x1d, r24	; 29
		EIFR   = _BV(INTF0) | _BV(INTF1) | _BV(INTF2);	// clear interrupts
    4a68:	8c bb       	out	0x1c, r24	; 28
		
		PCICR  |= _BV(PCIE1) | _BV(PCIE3);				// enable PCI1 and PCI3
    4a6a:	80 91 68 00 	lds	r24, 0x0068
    4a6e:	8a 60       	ori	r24, 0x0A	; 10
    4a70:	80 93 68 00 	sts	0x0068, r24
		PCMSK1 |= _BV(PCINT8);							// enable PCINT8 (AUX) -> PCI1
    4a74:	80 91 6c 00 	lds	r24, 0x006C
    4a78:	81 60       	ori	r24, 0x01	; 1
    4a7a:	80 93 6c 00 	sts	0x006C, r24
		PCMSK3 |= _BV(PCINT24);							// enable PCINT24 (THR) -> PCI3
    4a7e:	80 91 73 00 	lds	r24, 0x0073
    4a82:	81 60       	ori	r24, 0x01	; 1
    4a84:	80 93 73 00 	sts	0x0073, r24
		PCIFR  |= _BV(PCIF1) | _BV(PCIF3);
    4a88:	8b b3       	in	r24, 0x1b	; 27
    4a8a:	8a 60       	ori	r24, 0x0A	; 10
    4a8c:	8b bb       	out	0x1b, r24	; 27
#endif

	
#ifdef SECONDARY_INPUT_RX

	ActiveRXIndex=1;
    4a8e:	81 e0       	ldi	r24, 0x01	; 1
    4a90:	80 93 b8 05 	sts	0x05B8, r24
	RX2_ROLL_DIR 		= INPUT;
    4a94:	3d 98       	cbi	0x07, 5	; 7
	RX2_PITCH_DIR 		= INPUT;
    4a96:	38 98       	cbi	0x07, 0	; 7
	RX2_COLL_DIR   		= INPUT;
    4a98:	3f 98       	cbi	0x07, 7	; 7
	RX2_YAW_DIR   	 	= INPUT;
    4a9a:	39 98       	cbi	0x07, 1	; 7
	PCINT16 - PC0 - OUTPUT 6
	PCINT17 - PC1 - OUTPUT 5 
	PCINT21 - PC5 - OUTPUT 7
	PCINT23 - PC7 - OUTPUT 8 
	*/
	PCICR  |= _BV(PCIE1)   | _BV(PCIE2);														// enable PCI1 and PCI2
    4a9c:	80 91 68 00 	lds	r24, 0x0068
    4aa0:	86 60       	ori	r24, 0x06	; 6
    4aa2:	80 93 68 00 	sts	0x0068, r24
	PCMSK1 |= _BV(PCINT8);																		// enable PCINT8 (AUX) -> PCI1
    4aa6:	80 91 6c 00 	lds	r24, 0x006C
    4aaa:	81 60       	ori	r24, 0x01	; 1
    4aac:	80 93 6c 00 	sts	0x006C, r24
	PCMSK2 |= _BV(PCINT16) | _BV(PCINT17) | _BV(PCINT21) |_BV(PCINT23);							// enable PCINT24 (THR) -> PCI3
    4ab0:	80 91 6d 00 	lds	r24, 0x006D
    4ab4:	83 6a       	ori	r24, 0xA3	; 163
    4ab6:	80 93 6d 00 	sts	0x006D, r24
	PCIFR  |= _BV(PCIF1)   | _BV(PCIF2);														// clear interrupts
    4aba:	8b b3       	in	r24, 0x1b	; 27
    4abc:	86 60       	ori	r24, 0x06	; 6
    4abe:	8b bb       	out	0x1b, r24	; 27
#endif
	

		
	
	RX_Good =TX1_NOT_FOUND;
    4ac0:	80 91 c5 07 	lds	r24, 0x07C5
    4ac4:	81 60       	ori	r24, 0x01	; 1
    4ac6:	80 93 c5 07 	sts	0x07C5, r24
	RX_Good =TX2_NOT_FOUND;
    4aca:	80 91 c5 07 	lds	r24, 0x07C5
    4ace:	80 61       	ori	r24, 0x10	; 16
    4ad0:	80 93 c5 07 	sts	0x07C5, r24
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    4ad4:	f8 94       	cli
	
	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		RX1_LastValidSignal_timestamp= TCNT1_X;
    4ad6:	80 91 4e 06 	lds	r24, 0x064E
    4ada:	90 91 4f 06 	lds	r25, 0x064F
    4ade:	90 93 e4 07 	sts	0x07E4, r25
    4ae2:	80 93 e3 07 	sts	0x07E3, r24
		RX1_LastValidSignal_timestampAux= TCNT1_X;
    4ae6:	80 91 4e 06 	lds	r24, 0x064E
    4aea:	90 91 4f 06 	lds	r25, 0x064F
    4aee:	90 93 e6 07 	sts	0x07E6, r25
    4af2:	80 93 e5 07 	sts	0x07E5, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    4af6:	78 94       	sei
	}	
	
	RX2_LastValidSignal_timestamp= RX2_LastValidSignal_timestamp;
    4af8:	80 91 e1 07 	lds	r24, 0x07E1
    4afc:	90 91 e2 07 	lds	r25, 0x07E2
    4b00:	90 93 e2 07 	sts	0x07E2, r25
    4b04:	80 93 e1 07 	sts	0x07E1, r24
	RX2_LastValidSignal_timestampAux= RX2_LastValidSignal_timestampAux;	
    4b08:	80 91 dd 07 	lds	r24, 0x07DD
    4b0c:	90 91 de 07 	lds	r25, 0x07DE
    4b10:	90 93 de 07 	sts	0x07DE, r25
    4b14:	80 93 dd 07 	sts	0x07DD, r24
}
    4b18:	08 95       	ret

00004b1a <RX_raw_GetReceiverValues>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    4b1a:	f8 94       	cli
  uint16_t RX_raw_GetReceiverValues (uint8_t RXIndex, uint8_t Channel)
{
	uint16_t _t;
	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		_t = RX_Length[RXIndex][Channel];
    4b1c:	90 e0       	ldi	r25, 0x00	; 0
    4b1e:	fc 01       	movw	r30, r24
    4b20:	ee 0f       	add	r30, r30
    4b22:	ff 1f       	adc	r31, r31
    4b24:	ee 0f       	add	r30, r30
    4b26:	ff 1f       	adc	r31, r31
    4b28:	e8 0f       	add	r30, r24
    4b2a:	f9 1f       	adc	r31, r25
    4b2c:	e6 0f       	add	r30, r22
    4b2e:	f1 1d       	adc	r31, r1
    4b30:	ee 0f       	add	r30, r30
    4b32:	ff 1f       	adc	r31, r31
    4b34:	e6 54       	subi	r30, 0x46	; 70
    4b36:	fa 4f       	sbci	r31, 0xFA	; 250
    4b38:	20 81       	ld	r18, Z
    4b3a:	31 81       	ldd	r19, Z+1	; 0x01
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    4b3c:	78 94       	sei
	}		
	return _t;
}
    4b3e:	c9 01       	movw	r24, r18
    4b40:	08 95       	ret

00004b42 <RX_GetReceiverValues>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    4b42:	f8 94       	cli
{
	int16_t _t;
	//////if (RX_Good != TX_GOOD) return 0;
	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		_t = ((int)(RX_Length[RXIndex][Channel]));
    4b44:	90 e0       	ldi	r25, 0x00	; 0
    4b46:	70 e0       	ldi	r23, 0x00	; 0
    4b48:	9c 01       	movw	r18, r24
    4b4a:	22 0f       	add	r18, r18
    4b4c:	33 1f       	adc	r19, r19
    4b4e:	22 0f       	add	r18, r18
    4b50:	33 1f       	adc	r19, r19
    4b52:	28 0f       	add	r18, r24
    4b54:	39 1f       	adc	r19, r25
    4b56:	a9 01       	movw	r20, r18
    4b58:	46 0f       	add	r20, r22
    4b5a:	57 1f       	adc	r21, r23
    4b5c:	44 0f       	add	r20, r20
    4b5e:	55 1f       	adc	r21, r21
    4b60:	fa 01       	movw	r30, r20
    4b62:	e6 54       	subi	r30, 0x46	; 70
    4b64:	fa 4f       	sbci	r31, 0xFA	; 250
    4b66:	80 81       	ld	r24, Z
    4b68:	91 81       	ldd	r25, Z+1	; 0x01
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    4b6a:	78 94       	sei
	}		
	_t -= Config.RX_Mid[RXIndex][Channel];
    4b6c:	44 5b       	subi	r20, 0xB4	; 180
    4b6e:	58 4f       	sbci	r21, 0xF8	; 248
    4b70:	fa 01       	movw	r30, r20
    4b72:	40 81       	ld	r20, Z
    4b74:	51 81       	ldd	r21, Z+1	; 0x01
    4b76:	84 1b       	sub	r24, r20
    4b78:	95 0b       	sbc	r25, r21
	_t /=Config.RX_DiV_Value[RXIndex][Channel]; //RX_Div_Factor;
    4b7a:	26 0f       	add	r18, r22
    4b7c:	37 1f       	adc	r19, r23
    4b7e:	2a 57       	subi	r18, 0x7A	; 122
    4b80:	38 4f       	sbci	r19, 0xF8	; 248
    4b82:	f9 01       	movw	r30, r18
    4b84:	60 81       	ld	r22, Z
    4b86:	77 27       	eor	r23, r23
    4b88:	67 fd       	sbrc	r22, 7
    4b8a:	70 95       	com	r23
    4b8c:	0e 94 40 39 	call	0x7280	; 0x7280 <__divmodhi4>
	return _t;
}
    4b90:	cb 01       	movw	r24, r22
    4b92:	08 95       	ret

00004b94 <RX_GetReceiverThrottleValue>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    4b94:	f8 94       	cli
	
	///if (RX_Good != TX_GOOD) return 0;
	
	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		if (RXIndex==0)
    4b96:	88 23       	and	r24, r24
    4b98:	11 f5       	brne	.+68     	; 0x4bde <RX_GetReceiverThrottleValue+0x4a>
		{
			if ( (TCNT1_X - RX1_LastValidSignal_timestamp) > RX_SIGNAL_LOST_DURATION)
    4b9a:	40 91 4e 06 	lds	r20, 0x064E
    4b9e:	50 91 4f 06 	lds	r21, 0x064F
    4ba2:	60 91 e3 07 	lds	r22, 0x07E3
    4ba6:	70 91 e4 07 	lds	r23, 0x07E4
    4baa:	46 1b       	sub	r20, r22
    4bac:	57 0b       	sbc	r21, r23
    4bae:	45 31       	cpi	r20, 0x15	; 21
    4bb0:	51 05       	cpc	r21, r1
    4bb2:	20 f0       	brcs	.+8      	; 0x4bbc <RX_GetReceiverThrottleValue+0x28>
			{
				RX_Good =TX1_NOT_FOUND;
    4bb4:	80 91 c5 07 	lds	r24, 0x07C5
    4bb8:	81 60       	ori	r24, 0x01	; 1
    4bba:	34 c0       	rjmp	.+104    	; 0x4c24 <RX_GetReceiverThrottleValue+0x90>
				return 0;
			}	
		
			if ( (TCNT1_X - RX1_LastValidSignal_timestampAux) > RX_SIGNAL_LOST_DURATION)
    4bbc:	40 91 4e 06 	lds	r20, 0x064E
    4bc0:	50 91 4f 06 	lds	r21, 0x064F
    4bc4:	60 91 e5 07 	lds	r22, 0x07E5
    4bc8:	70 91 e6 07 	lds	r23, 0x07E6
    4bcc:	46 1b       	sub	r20, r22
    4bce:	57 0b       	sbc	r21, r23
    4bd0:	45 31       	cpi	r20, 0x15	; 21
    4bd2:	51 05       	cpc	r21, r1
    4bd4:	68 f1       	brcs	.+90     	; 0x4c30 <RX_GetReceiverThrottleValue+0x9c>
			{
				RX_Good =TX1_DISCONNECTED;
    4bd6:	80 91 c5 07 	lds	r24, 0x07C5
    4bda:	82 60       	ori	r24, 0x02	; 2
    4bdc:	23 c0       	rjmp	.+70     	; 0x4c24 <RX_GetReceiverThrottleValue+0x90>
				return 0;
			}
		}	
		if (RXIndex==1)
    4bde:	81 30       	cpi	r24, 0x01	; 1
    4be0:	39 f5       	brne	.+78     	; 0x4c30 <RX_GetReceiverThrottleValue+0x9c>
		{
			if ( (TCNT1_X - RX2_LastValidSignal_timestamp) > RX_SIGNAL_LOST_DURATION)
    4be2:	40 91 4e 06 	lds	r20, 0x064E
    4be6:	50 91 4f 06 	lds	r21, 0x064F
    4bea:	60 91 e1 07 	lds	r22, 0x07E1
    4bee:	70 91 e2 07 	lds	r23, 0x07E2
    4bf2:	46 1b       	sub	r20, r22
    4bf4:	57 0b       	sbc	r21, r23
    4bf6:	45 31       	cpi	r20, 0x15	; 21
    4bf8:	51 05       	cpc	r21, r1
    4bfa:	20 f0       	brcs	.+8      	; 0x4c04 <RX_GetReceiverThrottleValue+0x70>
			{
				RX_Good =TX2_NOT_FOUND;
    4bfc:	80 91 c5 07 	lds	r24, 0x07C5
    4c00:	80 61       	ori	r24, 0x10	; 16
    4c02:	10 c0       	rjmp	.+32     	; 0x4c24 <RX_GetReceiverThrottleValue+0x90>
				return 0;
			}	
		
			if ( (TCNT1_X - RX2_LastValidSignal_timestampAux) > RX_SIGNAL_LOST_DURATION)
    4c04:	40 91 4e 06 	lds	r20, 0x064E
    4c08:	50 91 4f 06 	lds	r21, 0x064F
    4c0c:	60 91 dd 07 	lds	r22, 0x07DD
    4c10:	70 91 de 07 	lds	r23, 0x07DE
    4c14:	46 1b       	sub	r20, r22
    4c16:	57 0b       	sbc	r21, r23
    4c18:	45 31       	cpi	r20, 0x15	; 21
    4c1a:	51 05       	cpc	r21, r1
    4c1c:	48 f0       	brcs	.+18     	; 0x4c30 <RX_GetReceiverThrottleValue+0x9c>
			{
				RX_Good =TX2_DISCONNECTED;
    4c1e:	80 91 c5 07 	lds	r24, 0x07C5
    4c22:	80 62       	ori	r24, 0x20	; 32
    4c24:	80 93 c5 07 	sts	0x07C5, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    4c28:	78 94       	sei
    __asm__ volatile ("" ::: "memory");
    4c2a:	20 e0       	ldi	r18, 0x00	; 0
    4c2c:	30 e0       	ldi	r19, 0x00	; 0
    4c2e:	41 c0       	rjmp	.+130    	; 0x4cb2 <RX_GetReceiverThrottleValue+0x11e>
				return 0;
			}
		}			
		
		
		iTemp16 = ((int)(RX_Length[RXIndex][RXChannel_THR]));
    4c30:	28 2f       	mov	r18, r24
    4c32:	30 e0       	ldi	r19, 0x00	; 0
    4c34:	c9 01       	movw	r24, r18
    4c36:	88 0f       	add	r24, r24
    4c38:	99 1f       	adc	r25, r25
    4c3a:	a9 01       	movw	r20, r18
    4c3c:	b3 e0       	ldi	r27, 0x03	; 3
    4c3e:	44 0f       	add	r20, r20
    4c40:	55 1f       	adc	r21, r21
    4c42:	ba 95       	dec	r27
    4c44:	e1 f7       	brne	.-8      	; 0x4c3e <RX_GetReceiverThrottleValue+0xaa>
    4c46:	84 0f       	add	r24, r20
    4c48:	95 1f       	adc	r25, r21
    4c4a:	fc 01       	movw	r30, r24
    4c4c:	e6 54       	subi	r30, 0x46	; 70
    4c4e:	fa 4f       	sbci	r31, 0xFA	; 250
    4c50:	46 81       	ldd	r20, Z+6	; 0x06
    4c52:	57 81       	ldd	r21, Z+7	; 0x07
    4c54:	50 93 e8 07 	sts	0x07E8, r21
    4c58:	40 93 e7 07 	sts	0x07E7, r20
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    4c5c:	78 94       	sei
	}		
	
	iTemp16 -= Config.RX_Min[RXIndex][RXChannel_THR];
    4c5e:	40 91 e7 07 	lds	r20, 0x07E7
    4c62:	50 91 e8 07 	lds	r21, 0x07E8
    4c66:	8a 59       	subi	r24, 0x9A	; 154
    4c68:	98 4f       	sbci	r25, 0xF8	; 248
    4c6a:	fc 01       	movw	r30, r24
    4c6c:	80 81       	ld	r24, Z
    4c6e:	91 81       	ldd	r25, Z+1	; 0x01
    4c70:	48 1b       	sub	r20, r24
    4c72:	59 0b       	sbc	r21, r25
    4c74:	50 93 e8 07 	sts	0x07E8, r21
    4c78:	40 93 e7 07 	sts	0x07E7, r20
	iTemp16 /= Config.RX_DiV_Value[RXIndex][RXChannel_THR]; //RX_Div_Factor;
    4c7c:	80 91 e7 07 	lds	r24, 0x07E7
    4c80:	90 91 e8 07 	lds	r25, 0x07E8
    4c84:	f9 01       	movw	r30, r18
    4c86:	ee 0f       	add	r30, r30
    4c88:	ff 1f       	adc	r31, r31
    4c8a:	ee 0f       	add	r30, r30
    4c8c:	ff 1f       	adc	r31, r31
    4c8e:	e2 0f       	add	r30, r18
    4c90:	f3 1f       	adc	r31, r19
    4c92:	e7 57       	subi	r30, 0x77	; 119
    4c94:	f8 4f       	sbci	r31, 0xF8	; 248
    4c96:	60 81       	ld	r22, Z
    4c98:	77 27       	eor	r23, r23
    4c9a:	67 fd       	sbrc	r22, 7
    4c9c:	70 95       	com	r23
    4c9e:	0e 94 40 39 	call	0x7280	; 0x7280 <__divmodhi4>
    4ca2:	70 93 e8 07 	sts	0x07E8, r23
    4ca6:	60 93 e7 07 	sts	0x07E7, r22
	 
	return iTemp16;
    4caa:	20 91 e7 07 	lds	r18, 0x07E7
    4cae:	30 91 e8 07 	lds	r19, 0x07E8
}
    4cb2:	c9 01       	movw	r24, r18
    4cb4:	08 95       	ret

00004cb6 <RX_CopyLatestReceiverValues>:
 
void RX_CopyLatestReceiverValues (void)
{
    4cb6:	cf 92       	push	r12
    4cb8:	df 92       	push	r13
    4cba:	ef 92       	push	r14
    4cbc:	ff 92       	push	r15
    4cbe:	0f 93       	push	r16
    4cc0:	1f 93       	push	r17
    4cc2:	cf 93       	push	r28
    4cc4:	df 93       	push	r29
	for (int ch=0;ch<2;++ch)
    4cc6:	c0 e0       	ldi	r28, 0x00	; 0
    4cc8:	d0 e0       	ldi	r29, 0x00	; 0
    4cca:	2d c0       	rjmp	.+90     	; 0x4d26 <RX_CopyLatestReceiverValues+0x70>
	{
		for (int i=0;i<RXChannels;++i)
		{
			if (i == RXChannel_THR)
    4ccc:	03 30       	cpi	r16, 0x03	; 3
    4cce:	11 05       	cpc	r17, r1
    4cd0:	39 f4       	brne	.+14     	; 0x4ce0 <RX_CopyLatestReceiverValues+0x2a>
			{
				RX_Latest[ch][i]= RX_GetReceiverThrottleValue(ch);	 
    4cd2:	8c 2f       	mov	r24, r28
    4cd4:	0e 94 ca 25 	call	0x4b94	; 0x4b94 <RX_GetReceiverThrottleValue>
    4cd8:	f7 01       	movw	r30, r14
    4cda:	91 83       	std	Z+1, r25	; 0x01
    4cdc:	80 83       	st	Z, r24
    4cde:	1a c0       	rjmp	.+52     	; 0x4d14 <RX_CopyLatestReceiverValues+0x5e>
			}
			else
			{
				RX_Latest[ch][i]= RX_GetReceiverValues(ch,i);	 
    4ce0:	8c 2f       	mov	r24, r28
    4ce2:	60 2f       	mov	r22, r16
    4ce4:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <RX_GetReceiverValues>
    4ce8:	f6 01       	movw	r30, r12
    4cea:	e0 0f       	add	r30, r16
    4cec:	f1 1f       	adc	r31, r17
    4cee:	ee 0f       	add	r30, r30
    4cf0:	ff 1f       	adc	r31, r31
    4cf2:	e0 51       	subi	r30, 0x10	; 16
    4cf4:	fa 4f       	sbci	r31, 0xFA	; 250
    4cf6:	91 83       	std	Z+1, r25	; 0x01
    4cf8:	80 83       	st	Z, r24
				if ((RX_Latest[ch][i]<STICK_DEADBAND) && (RX_Latest[ch][i]>-STICK_DEADBAND)) RX_Latest[ch][i]=0;
    4cfa:	80 81       	ld	r24, Z
    4cfc:	91 81       	ldd	r25, Z+1	; 0x01
    4cfe:	8f 30       	cpi	r24, 0x0F	; 15
    4d00:	91 05       	cpc	r25, r1
    4d02:	44 f4       	brge	.+16     	; 0x4d14 <RX_CopyLatestReceiverValues+0x5e>
    4d04:	80 81       	ld	r24, Z
    4d06:	91 81       	ldd	r25, Z+1	; 0x01
    4d08:	3f ef       	ldi	r19, 0xFF	; 255
    4d0a:	82 3f       	cpi	r24, 0xF2	; 242
    4d0c:	93 07       	cpc	r25, r19
    4d0e:	14 f0       	brlt	.+4      	; 0x4d14 <RX_CopyLatestReceiverValues+0x5e>
    4d10:	11 82       	std	Z+1, r1	; 0x01
    4d12:	10 82       	st	Z, r1
 
void RX_CopyLatestReceiverValues (void)
{
	for (int ch=0;ch<2;++ch)
	{
		for (int i=0;i<RXChannels;++i)
    4d14:	0f 5f       	subi	r16, 0xFF	; 255
    4d16:	1f 4f       	sbci	r17, 0xFF	; 255
    4d18:	05 30       	cpi	r16, 0x05	; 5
    4d1a:	11 05       	cpc	r17, r1
    4d1c:	b9 f6       	brne	.-82     	; 0x4ccc <RX_CopyLatestReceiverValues+0x16>
	return iTemp16;
}
 
void RX_CopyLatestReceiverValues (void)
{
	for (int ch=0;ch<2;++ch)
    4d1e:	21 96       	adiw	r28, 0x01	; 1
    4d20:	c2 30       	cpi	r28, 0x02	; 2
    4d22:	d1 05       	cpc	r29, r1
    4d24:	c9 f0       	breq	.+50     	; 0x4d58 <RX_CopyLatestReceiverValues+0xa2>
	 
	return iTemp16;
}
 
void RX_CopyLatestReceiverValues (void)
{
    4d26:	00 e0       	ldi	r16, 0x00	; 0
    4d28:	10 e0       	ldi	r17, 0x00	; 0
			{
				RX_Latest[ch][i]= RX_GetReceiverThrottleValue(ch);	 
			}
			else
			{
				RX_Latest[ch][i]= RX_GetReceiverValues(ch,i);	 
    4d2a:	6e 01       	movw	r12, r28
    4d2c:	cc 0c       	add	r12, r12
    4d2e:	dd 1c       	adc	r13, r13
    4d30:	cc 0c       	add	r12, r12
    4d32:	dd 1c       	adc	r13, r13
    4d34:	cc 0e       	add	r12, r28
    4d36:	dd 1e       	adc	r13, r29
	{
		for (int i=0;i<RXChannels;++i)
		{
			if (i == RXChannel_THR)
			{
				RX_Latest[ch][i]= RX_GetReceiverThrottleValue(ch);	 
    4d38:	7e 01       	movw	r14, r28
    4d3a:	ee 0c       	add	r14, r14
    4d3c:	ff 1c       	adc	r15, r15
    4d3e:	ce 01       	movw	r24, r28
    4d40:	53 e0       	ldi	r21, 0x03	; 3
    4d42:	88 0f       	add	r24, r24
    4d44:	99 1f       	adc	r25, r25
    4d46:	5a 95       	dec	r21
    4d48:	e1 f7       	brne	.-8      	; 0x4d42 <RX_CopyLatestReceiverValues+0x8c>
    4d4a:	e8 0e       	add	r14, r24
    4d4c:	f9 1e       	adc	r15, r25
    4d4e:	86 ef       	ldi	r24, 0xF6	; 246
    4d50:	95 e0       	ldi	r25, 0x05	; 5
    4d52:	e8 0e       	add	r14, r24
    4d54:	f9 1e       	adc	r15, r25
    4d56:	ba cf       	rjmp	.-140    	; 0x4ccc <RX_CopyLatestReceiverValues+0x16>
				if ((RX_Latest[ch][i]<STICK_DEADBAND) && (RX_Latest[ch][i]>-STICK_DEADBAND)) RX_Latest[ch][i]=0;
			}
		}	
	}
				
}
    4d58:	df 91       	pop	r29
    4d5a:	cf 91       	pop	r28
    4d5c:	1f 91       	pop	r17
    4d5e:	0f 91       	pop	r16
    4d60:	ff 90       	pop	r15
    4d62:	ef 90       	pop	r14
    4d64:	df 90       	pop	r13
    4d66:	cf 90       	pop	r12
    4d68:	08 95       	ret

00004d6a <RX_StickCenterCalibrationInit>:

void RX_StickCenterCalibrationInit(uint8_t RXIndex)
{
	for (int i=0; i<RXChannels; ++i)
	{
		RX_MAX_raw[RXIndex][i]=0;
    4d6a:	6f e0       	ldi	r22, 0x0F	; 15
    4d6c:	76 e0       	ldi	r23, 0x06	; 6
    4d6e:	28 2f       	mov	r18, r24
    4d70:	30 e0       	ldi	r19, 0x00	; 0
    4d72:	f9 01       	movw	r30, r18
    4d74:	ee 0f       	add	r30, r30
    4d76:	ff 1f       	adc	r31, r31
    4d78:	93 e0       	ldi	r25, 0x03	; 3
    4d7a:	22 0f       	add	r18, r18
    4d7c:	33 1f       	adc	r19, r19
    4d7e:	9a 95       	dec	r25
    4d80:	e1 f7       	brne	.-8      	; 0x4d7a <RX_StickCenterCalibrationInit+0x10>
    4d82:	e2 0f       	add	r30, r18
    4d84:	f3 1f       	adc	r31, r19
    4d86:	e6 0f       	add	r30, r22
    4d88:	f7 1f       	adc	r31, r23
    4d8a:	11 82       	std	Z+1, r1	; 0x01
    4d8c:	10 82       	st	Z, r1
		RX_MIN_raw[RXIndex][i]=0xfffe;
    4d8e:	40 ea       	ldi	r20, 0xA0	; 160
    4d90:	56 e0       	ldi	r21, 0x06	; 6
    4d92:	28 2f       	mov	r18, r24
    4d94:	30 e0       	ldi	r19, 0x00	; 0
    4d96:	f9 01       	movw	r30, r18
    4d98:	ee 0f       	add	r30, r30
    4d9a:	ff 1f       	adc	r31, r31
    4d9c:	a3 e0       	ldi	r26, 0x03	; 3
    4d9e:	22 0f       	add	r18, r18
    4da0:	33 1f       	adc	r19, r19
    4da2:	aa 95       	dec	r26
    4da4:	e1 f7       	brne	.-8      	; 0x4d9e <RX_StickCenterCalibrationInit+0x34>
    4da6:	e2 0f       	add	r30, r18
    4da8:	f3 1f       	adc	r31, r19
    4daa:	e4 0f       	add	r30, r20
    4dac:	f5 1f       	adc	r31, r21
    4dae:	2e ef       	ldi	r18, 0xFE	; 254
    4db0:	3f ef       	ldi	r19, 0xFF	; 255
    4db2:	31 83       	std	Z+1, r19	; 0x01
    4db4:	20 83       	st	Z, r18

void RX_StickCenterCalibrationInit(uint8_t RXIndex)
{
	for (int i=0; i<RXChannels; ++i)
	{
		RX_MAX_raw[RXIndex][i]=0;
    4db6:	a8 2f       	mov	r26, r24
    4db8:	b0 e0       	ldi	r27, 0x00	; 0
    4dba:	fd 01       	movw	r30, r26
    4dbc:	ee 0f       	add	r30, r30
    4dbe:	ff 1f       	adc	r31, r31
    4dc0:	93 e0       	ldi	r25, 0x03	; 3
    4dc2:	aa 0f       	add	r26, r26
    4dc4:	bb 1f       	adc	r27, r27
    4dc6:	9a 95       	dec	r25
    4dc8:	e1 f7       	brne	.-8      	; 0x4dc2 <RX_StickCenterCalibrationInit+0x58>
    4dca:	ea 0f       	add	r30, r26
    4dcc:	fb 1f       	adc	r31, r27
    4dce:	e6 0f       	add	r30, r22
    4dd0:	f7 1f       	adc	r31, r23
    4dd2:	13 82       	std	Z+3, r1	; 0x03
    4dd4:	12 82       	std	Z+2, r1	; 0x02
		RX_MIN_raw[RXIndex][i]=0xfffe;
    4dd6:	a8 2f       	mov	r26, r24
    4dd8:	b0 e0       	ldi	r27, 0x00	; 0
    4dda:	fd 01       	movw	r30, r26
    4ddc:	ee 0f       	add	r30, r30
    4dde:	ff 1f       	adc	r31, r31
    4de0:	93 e0       	ldi	r25, 0x03	; 3
    4de2:	aa 0f       	add	r26, r26
    4de4:	bb 1f       	adc	r27, r27
    4de6:	9a 95       	dec	r25
    4de8:	e1 f7       	brne	.-8      	; 0x4de2 <RX_StickCenterCalibrationInit+0x78>
    4dea:	ea 0f       	add	r30, r26
    4dec:	fb 1f       	adc	r31, r27
    4dee:	e4 0f       	add	r30, r20
    4df0:	f5 1f       	adc	r31, r21
    4df2:	33 83       	std	Z+3, r19	; 0x03
    4df4:	22 83       	std	Z+2, r18	; 0x02

void RX_StickCenterCalibrationInit(uint8_t RXIndex)
{
	for (int i=0; i<RXChannels; ++i)
	{
		RX_MAX_raw[RXIndex][i]=0;
    4df6:	a8 2f       	mov	r26, r24
    4df8:	b0 e0       	ldi	r27, 0x00	; 0
    4dfa:	fd 01       	movw	r30, r26
    4dfc:	ee 0f       	add	r30, r30
    4dfe:	ff 1f       	adc	r31, r31
    4e00:	93 e0       	ldi	r25, 0x03	; 3
    4e02:	aa 0f       	add	r26, r26
    4e04:	bb 1f       	adc	r27, r27
    4e06:	9a 95       	dec	r25
    4e08:	e1 f7       	brne	.-8      	; 0x4e02 <RX_StickCenterCalibrationInit+0x98>
    4e0a:	ea 0f       	add	r30, r26
    4e0c:	fb 1f       	adc	r31, r27
    4e0e:	e6 0f       	add	r30, r22
    4e10:	f7 1f       	adc	r31, r23
    4e12:	15 82       	std	Z+5, r1	; 0x05
    4e14:	14 82       	std	Z+4, r1	; 0x04
		RX_MIN_raw[RXIndex][i]=0xfffe;
    4e16:	a8 2f       	mov	r26, r24
    4e18:	b0 e0       	ldi	r27, 0x00	; 0
    4e1a:	fd 01       	movw	r30, r26
    4e1c:	ee 0f       	add	r30, r30
    4e1e:	ff 1f       	adc	r31, r31
    4e20:	93 e0       	ldi	r25, 0x03	; 3
    4e22:	aa 0f       	add	r26, r26
    4e24:	bb 1f       	adc	r27, r27
    4e26:	9a 95       	dec	r25
    4e28:	e1 f7       	brne	.-8      	; 0x4e22 <RX_StickCenterCalibrationInit+0xb8>
    4e2a:	ea 0f       	add	r30, r26
    4e2c:	fb 1f       	adc	r31, r27
    4e2e:	e4 0f       	add	r30, r20
    4e30:	f5 1f       	adc	r31, r21
    4e32:	35 83       	std	Z+5, r19	; 0x05
    4e34:	24 83       	std	Z+4, r18	; 0x04

void RX_StickCenterCalibrationInit(uint8_t RXIndex)
{
	for (int i=0; i<RXChannels; ++i)
	{
		RX_MAX_raw[RXIndex][i]=0;
    4e36:	a8 2f       	mov	r26, r24
    4e38:	b0 e0       	ldi	r27, 0x00	; 0
    4e3a:	fd 01       	movw	r30, r26
    4e3c:	ee 0f       	add	r30, r30
    4e3e:	ff 1f       	adc	r31, r31
    4e40:	93 e0       	ldi	r25, 0x03	; 3
    4e42:	aa 0f       	add	r26, r26
    4e44:	bb 1f       	adc	r27, r27
    4e46:	9a 95       	dec	r25
    4e48:	e1 f7       	brne	.-8      	; 0x4e42 <RX_StickCenterCalibrationInit+0xd8>
    4e4a:	ea 0f       	add	r30, r26
    4e4c:	fb 1f       	adc	r31, r27
    4e4e:	e6 0f       	add	r30, r22
    4e50:	f7 1f       	adc	r31, r23
    4e52:	17 82       	std	Z+7, r1	; 0x07
    4e54:	16 82       	std	Z+6, r1	; 0x06
		RX_MIN_raw[RXIndex][i]=0xfffe;
    4e56:	a8 2f       	mov	r26, r24
    4e58:	b0 e0       	ldi	r27, 0x00	; 0
    4e5a:	fd 01       	movw	r30, r26
    4e5c:	ee 0f       	add	r30, r30
    4e5e:	ff 1f       	adc	r31, r31
    4e60:	93 e0       	ldi	r25, 0x03	; 3
    4e62:	aa 0f       	add	r26, r26
    4e64:	bb 1f       	adc	r27, r27
    4e66:	9a 95       	dec	r25
    4e68:	e1 f7       	brne	.-8      	; 0x4e62 <RX_StickCenterCalibrationInit+0xf8>
    4e6a:	ea 0f       	add	r30, r26
    4e6c:	fb 1f       	adc	r31, r27
    4e6e:	e4 0f       	add	r30, r20
    4e70:	f5 1f       	adc	r31, r21
    4e72:	37 83       	std	Z+7, r19	; 0x07
    4e74:	26 83       	std	Z+6, r18	; 0x06

void RX_StickCenterCalibrationInit(uint8_t RXIndex)
{
	for (int i=0; i<RXChannels; ++i)
	{
		RX_MAX_raw[RXIndex][i]=0;
    4e76:	a8 2f       	mov	r26, r24
    4e78:	b0 e0       	ldi	r27, 0x00	; 0
    4e7a:	fd 01       	movw	r30, r26
    4e7c:	ee 0f       	add	r30, r30
    4e7e:	ff 1f       	adc	r31, r31
    4e80:	93 e0       	ldi	r25, 0x03	; 3
    4e82:	aa 0f       	add	r26, r26
    4e84:	bb 1f       	adc	r27, r27
    4e86:	9a 95       	dec	r25
    4e88:	e1 f7       	brne	.-8      	; 0x4e82 <RX_StickCenterCalibrationInit+0x118>
    4e8a:	ea 0f       	add	r30, r26
    4e8c:	fb 1f       	adc	r31, r27
    4e8e:	e6 0f       	add	r30, r22
    4e90:	f7 1f       	adc	r31, r23
    4e92:	11 86       	std	Z+9, r1	; 0x09
    4e94:	10 86       	std	Z+8, r1	; 0x08
		RX_MIN_raw[RXIndex][i]=0xfffe;
    4e96:	68 2f       	mov	r22, r24
    4e98:	70 e0       	ldi	r23, 0x00	; 0
    4e9a:	fb 01       	movw	r30, r22
    4e9c:	ee 0f       	add	r30, r30
    4e9e:	ff 1f       	adc	r31, r31
    4ea0:	b3 e0       	ldi	r27, 0x03	; 3
    4ea2:	66 0f       	add	r22, r22
    4ea4:	77 1f       	adc	r23, r23
    4ea6:	ba 95       	dec	r27
    4ea8:	e1 f7       	brne	.-8      	; 0x4ea2 <RX_StickCenterCalibrationInit+0x138>
    4eaa:	e6 0f       	add	r30, r22
    4eac:	f7 1f       	adc	r31, r23
    4eae:	e4 0f       	add	r30, r20
    4eb0:	f5 1f       	adc	r31, r21
    4eb2:	31 87       	std	Z+9, r19	; 0x09
    4eb4:	20 87       	std	Z+8, r18	; 0x08
	}
}
    4eb6:	08 95       	ret

00004eb8 <RX_StickCenterCalibration>:


void RX_StickCenterCalibration (uint8_t RXIndex)
{
    4eb8:	df 92       	push	r13
    4eba:	ef 92       	push	r14
    4ebc:	ff 92       	push	r15
    4ebe:	0f 93       	push	r16
    4ec0:	1f 93       	push	r17
    4ec2:	cf 93       	push	r28
    4ec4:	df 93       	push	r29
    4ec6:	d8 2e       	mov	r13, r24
		RX_MIN_raw[RXIndex][i]=0xfffe;
	}
}


void RX_StickCenterCalibration (uint8_t RXIndex)
    4ec8:	28 2f       	mov	r18, r24
    4eca:	30 e0       	ldi	r19, 0x00	; 0
    4ecc:	89 01       	movw	r16, r18
    4ece:	00 0f       	add	r16, r16
    4ed0:	11 1f       	adc	r17, r17
    4ed2:	73 e0       	ldi	r23, 0x03	; 3
    4ed4:	22 0f       	add	r18, r18
    4ed6:	33 1f       	adc	r19, r19
    4ed8:	7a 95       	dec	r23
    4eda:	e1 f7       	brne	.-8      	; 0x4ed4 <RX_StickCenterCalibration+0x1c>
    4edc:	02 0f       	add	r16, r18
    4ede:	13 1f       	adc	r17, r19
    4ee0:	01 5f       	subi	r16, 0xF1	; 241
    4ee2:	19 4f       	sbci	r17, 0xF9	; 249
    4ee4:	28 2f       	mov	r18, r24
    4ee6:	30 e0       	ldi	r19, 0x00	; 0
    4ee8:	e9 01       	movw	r28, r18
    4eea:	cc 0f       	add	r28, r28
    4eec:	dd 1f       	adc	r29, r29
    4eee:	53 e0       	ldi	r21, 0x03	; 3
    4ef0:	22 0f       	add	r18, r18
    4ef2:	33 1f       	adc	r19, r19
    4ef4:	5a 95       	dec	r21
    4ef6:	e1 f7       	brne	.-8      	; 0x4ef0 <RX_StickCenterCalibration+0x38>
    4ef8:	c2 0f       	add	r28, r18
    4efa:	d3 1f       	adc	r29, r19
    4efc:	c0 56       	subi	r28, 0x60	; 96
    4efe:	d9 4f       	sbci	r29, 0xF9	; 249
{
	
	uint16_t tempRX;
	for (int i=0;i<RXChannels;++i)
    4f00:	ee 24       	eor	r14, r14
    4f02:	ff 24       	eor	r15, r15
	{
		tempRX = RX_raw_GetReceiverValues(RXIndex,i);
    4f04:	8d 2d       	mov	r24, r13
    4f06:	6e 2d       	mov	r22, r14
    4f08:	0e 94 8d 25 	call	0x4b1a	; 0x4b1a <RX_raw_GetReceiverValues>
    4f0c:	9c 01       	movw	r18, r24
		if (tempRX!=0)
    4f0e:	00 97       	sbiw	r24, 0x00	; 0
    4f10:	81 f0       	breq	.+32     	; 0x4f32 <RX_StickCenterCalibration+0x7a>
		{
			
			if ( tempRX > RX_MAX_raw[RXIndex][i]) 
    4f12:	f8 01       	movw	r30, r16
    4f14:	80 81       	ld	r24, Z
    4f16:	91 81       	ldd	r25, Z+1	; 0x01
    4f18:	82 17       	cp	r24, r18
    4f1a:	93 07       	cpc	r25, r19
    4f1c:	18 f4       	brcc	.+6      	; 0x4f24 <RX_StickCenterCalibration+0x6c>
			{
				RX_MAX_raw[RXIndex][i] = tempRX;
    4f1e:	31 83       	std	Z+1, r19	; 0x01
    4f20:	20 83       	st	Z, r18
    4f22:	07 c0       	rjmp	.+14     	; 0x4f32 <RX_StickCenterCalibration+0x7a>
			}
			else if (tempRX < RX_MIN_raw[RXIndex][i]) 
    4f24:	88 81       	ld	r24, Y
    4f26:	99 81       	ldd	r25, Y+1	; 0x01
    4f28:	28 17       	cp	r18, r24
    4f2a:	39 07       	cpc	r19, r25
    4f2c:	10 f4       	brcc	.+4      	; 0x4f32 <RX_StickCenterCalibration+0x7a>
			{
				RX_MIN_raw[RXIndex][i] = tempRX;
    4f2e:	39 83       	std	Y+1, r19	; 0x01
    4f30:	28 83       	st	Y, r18

void RX_StickCenterCalibration (uint8_t RXIndex)
{
	
	uint16_t tempRX;
	for (int i=0;i<RXChannels;++i)
    4f32:	08 94       	sec
    4f34:	e1 1c       	adc	r14, r1
    4f36:	f1 1c       	adc	r15, r1
    4f38:	0e 5f       	subi	r16, 0xFE	; 254
    4f3a:	1f 4f       	sbci	r17, 0xFF	; 255
    4f3c:	22 96       	adiw	r28, 0x02	; 2
    4f3e:	f5 e0       	ldi	r31, 0x05	; 5
    4f40:	ef 16       	cp	r14, r31
    4f42:	f1 04       	cpc	r15, r1
    4f44:	f9 f6       	brne	.-66     	; 0x4f04 <RX_StickCenterCalibration+0x4c>
			{
				RX_MIN_raw[RXIndex][i] = tempRX;
			}
		}
	}				
    4f46:	df 91       	pop	r29
    4f48:	cf 91       	pop	r28
    4f4a:	1f 91       	pop	r17
    4f4c:	0f 91       	pop	r16
    4f4e:	ff 90       	pop	r15
    4f50:	ef 90       	pop	r14
    4f52:	df 90       	pop	r13
    4f54:	08 95       	ret

00004f56 <Sensors_Init>:
	


void Sensors_Init(void)
{
	ACC_PITCH  = INPUT;
    4f56:	15 98       	cbi	0x02, 5	; 2
	ACC_ROLL  = INPUT;
    4f58:	16 98       	cbi	0x02, 6	; 2
	ACC_Z  = INPUT;
    4f5a:	17 98       	cbi	0x02, 7	; 2
	
	GYRO_ROLL = INPUT;
    4f5c:	11 98       	cbi	0x02, 1	; 2
	GYRO_PITCH = INPUT;
    4f5e:	14 98       	cbi	0x02, 4	; 2
	GYRO_Z = INPUT;
    4f60:	12 98       	cbi	0x02, 2	; 2
	//{
		//
		//StabilityMatrix_GX[i]=0;
		//StabilityMatrix_GY[i]=0;
	//}
}
    4f62:	08 95       	ret

00004f64 <Sensors_Test>:

/*
// This function Test if sensors are working OK or not.
*/
char *Sensors_Test(uint8_t channel, uint16_t LowLimit ,uint16_t HighLimit)
{
    4f64:	ef 92       	push	r14
    4f66:	ff 92       	push	r15
    4f68:	0f 93       	push	r16
    4f6a:	1f 93       	push	r17
    4f6c:	cf 93       	push	r28
    4f6e:	df 93       	push	r29
    4f70:	8b 01       	movw	r16, r22
    4f72:	7a 01       	movw	r14, r20
	
	nResult[channel] = ADCPort_Get(channel);
    4f74:	c8 2f       	mov	r28, r24
    4f76:	d0 e0       	ldi	r29, 0x00	; 0
    4f78:	0e 94 88 29 	call	0x5310	; 0x5310 <ADCPort_Get>
    4f7c:	cc 0f       	add	r28, r28
    4f7e:	dd 1f       	adc	r29, r29
    4f80:	c4 57       	subi	r28, 0x74	; 116
    4f82:	da 4f       	sbci	r29, 0xFA	; 250
    4f84:	99 83       	std	Y+1, r25	; 0x01
    4f86:	88 83       	st	Y, r24
	  
	utoa (nResult[channel],Result,10);
    4f88:	88 81       	ld	r24, Y
    4f8a:	99 81       	ldd	r25, Y+1	; 0x01
    4f8c:	6c e9       	ldi	r22, 0x9C	; 156
    4f8e:	75 e0       	ldi	r23, 0x05	; 5
    4f90:	4a e0       	ldi	r20, 0x0A	; 10
    4f92:	50 e0       	ldi	r21, 0x00	; 0
    4f94:	0e 94 cc 39 	call	0x7398	; 0x7398 <utoa>
	
	if ((nResult[channel]  >= LowLimit)  
    4f98:	88 81       	ld	r24, Y
    4f9a:	99 81       	ldd	r25, Y+1	; 0x01
    4f9c:	80 17       	cp	r24, r16
    4f9e:	91 07       	cpc	r25, r17
    4fa0:	50 f0       	brcs	.+20     	; 0x4fb6 <Sensors_Test+0x52>
	 && (nResult[channel]  <= HighLimit))
    4fa2:	88 81       	ld	r24, Y
    4fa4:	99 81       	ldd	r25, Y+1	; 0x01
    4fa6:	e8 16       	cp	r14, r24
    4fa8:	f9 06       	cpc	r15, r25
    4faa:	28 f0       	brcs	.+10     	; 0x4fb6 <Sensors_Test+0x52>
	{
		strcat (Result, ("  "));  
    4fac:	8c e9       	ldi	r24, 0x9C	; 156
    4fae:	95 e0       	ldi	r25, 0x05	; 5
    4fb0:	68 e0       	ldi	r22, 0x08	; 8
    4fb2:	71 e0       	ldi	r23, 0x01	; 1
    4fb4:	04 c0       	rjmp	.+8      	; 0x4fbe <Sensors_Test+0x5a>
	}
	else
	{
		strcat (Result, (" X"));  
    4fb6:	8c e9       	ldi	r24, 0x9C	; 156
    4fb8:	95 e0       	ldi	r25, 0x05	; 5
    4fba:	6b e0       	ldi	r22, 0x0B	; 11
    4fbc:	71 e0       	ldi	r23, 0x01	; 1
    4fbe:	0e 94 a0 39 	call	0x7340	; 0x7340 <strcat>
	}
	  
	return Result;
}
    4fc2:	8c e9       	ldi	r24, 0x9C	; 156
    4fc4:	95 e0       	ldi	r25, 0x05	; 5
    4fc6:	df 91       	pop	r29
    4fc8:	cf 91       	pop	r28
    4fca:	1f 91       	pop	r17
    4fcc:	0f 91       	pop	r16
    4fce:	ff 90       	pop	r15
    4fd0:	ef 90       	pop	r14
    4fd2:	08 95       	ret

00004fd4 <Sensors_Calibrate>:

/*
// Calibrate Sensors and return result in nResult global variable.
*/
void Sensors_Calibrate (void)
{
    4fd4:	ef 92       	push	r14
    4fd6:	ff 92       	push	r15
    4fd8:	0f 93       	push	r16
    4fda:	1f 93       	push	r17
    4fdc:	df 93       	push	r29
    4fde:	cf 93       	push	r28
    4fe0:	0f 92       	push	r0
    4fe2:	cd b7       	in	r28, 0x3d	; 61
    4fe4:	de b7       	in	r29, 0x3e	; 62
	BOOL LEDOLD = LED_Orange;
    4fe6:	25 b1       	in	r18, 0x05	; 5
    4fe8:	26 95       	lsr	r18
    4fea:	26 95       	lsr	r18
    4fec:	26 95       	lsr	r18
    4fee:	21 70       	andi	r18, 0x01	; 1
	int i;
	for (i=0;i<6;++i)
	{
		nResult [i]=0;
    4ff0:	10 92 8d 05 	sts	0x058D, r1
    4ff4:	10 92 8c 05 	sts	0x058C, r1
    4ff8:	10 92 8f 05 	sts	0x058F, r1
    4ffc:	10 92 8e 05 	sts	0x058E, r1
    5000:	10 92 91 05 	sts	0x0591, r1
    5004:	10 92 90 05 	sts	0x0590, r1
    5008:	10 92 93 05 	sts	0x0593, r1
    500c:	10 92 92 05 	sts	0x0592, r1
    5010:	10 92 95 05 	sts	0x0595, r1
    5014:	10 92 94 05 	sts	0x0594, r1
    5018:	10 92 97 05 	sts	0x0597, r1
    501c:	10 92 96 05 	sts	0x0596, r1
    5020:	59 e1       	ldi	r21, 0x19	; 25
    5022:	e5 2e       	mov	r14, r21
    5024:	f1 2c       	mov	r15, r1
	}
	
	// check: http://www.x-firm.com/?page_id=191
	for (int i=0;i<25;++i)
	{
		nResult[ACC_PITCH_Index] += ADCPort_Get(ACC_PITCH_PNUM);
    5026:	00 91 92 05 	lds	r16, 0x0592
    502a:	10 91 93 05 	lds	r17, 0x0593
    502e:	85 e0       	ldi	r24, 0x05	; 5
    5030:	29 83       	std	Y+1, r18	; 0x01
    5032:	0e 94 88 29 	call	0x5310	; 0x5310 <ADCPort_Get>
    5036:	08 0f       	add	r16, r24
    5038:	19 1f       	adc	r17, r25
    503a:	10 93 93 05 	sts	0x0593, r17
    503e:	00 93 92 05 	sts	0x0592, r16
		nResult[ACC_ROLL_Index] += ADCPort_Get(ACC_ROLL_PNUM);
    5042:	00 91 94 05 	lds	r16, 0x0594
    5046:	10 91 95 05 	lds	r17, 0x0595
    504a:	86 e0       	ldi	r24, 0x06	; 6
    504c:	0e 94 88 29 	call	0x5310	; 0x5310 <ADCPort_Get>
    5050:	08 0f       	add	r16, r24
    5052:	19 1f       	adc	r17, r25
    5054:	10 93 95 05 	sts	0x0595, r17
    5058:	00 93 94 05 	sts	0x0594, r16
		nResult[ACC_Z_Index] += ADCPort_Get(ACC_Z_PNUM);
    505c:	00 91 96 05 	lds	r16, 0x0596
    5060:	10 91 97 05 	lds	r17, 0x0597
    5064:	87 e0       	ldi	r24, 0x07	; 7
    5066:	0e 94 88 29 	call	0x5310	; 0x5310 <ADCPort_Get>
    506a:	08 0f       	add	r16, r24
    506c:	19 1f       	adc	r17, r25
    506e:	10 93 97 05 	sts	0x0597, r17
    5072:	00 93 96 05 	sts	0x0596, r16
		
		nResult[GYRO_ROLL_Index] += ADCPort_Get(GYRO_ROLL_PNUM);
    5076:	00 91 8c 05 	lds	r16, 0x058C
    507a:	10 91 8d 05 	lds	r17, 0x058D
    507e:	81 e0       	ldi	r24, 0x01	; 1
    5080:	0e 94 88 29 	call	0x5310	; 0x5310 <ADCPort_Get>
    5084:	08 0f       	add	r16, r24
    5086:	19 1f       	adc	r17, r25
    5088:	10 93 8d 05 	sts	0x058D, r17
    508c:	00 93 8c 05 	sts	0x058C, r16
		nResult[GYRO_PITCH_Index] += ADCPort_Get(GYRO_PITCH_PNUM);
    5090:	00 91 8e 05 	lds	r16, 0x058E
    5094:	10 91 8f 05 	lds	r17, 0x058F
    5098:	84 e0       	ldi	r24, 0x04	; 4
    509a:	0e 94 88 29 	call	0x5310	; 0x5310 <ADCPort_Get>
    509e:	08 0f       	add	r16, r24
    50a0:	19 1f       	adc	r17, r25
    50a2:	10 93 8f 05 	sts	0x058F, r17
    50a6:	00 93 8e 05 	sts	0x058E, r16
		nResult[GYRO_Z_Index] += ADCPort_Get(GYRO_Z_PNUM); 
    50aa:	00 91 90 05 	lds	r16, 0x0590
    50ae:	10 91 91 05 	lds	r17, 0x0591
    50b2:	82 e0       	ldi	r24, 0x02	; 2
    50b4:	0e 94 88 29 	call	0x5310	; 0x5310 <ADCPort_Get>
    50b8:	08 0f       	add	r16, r24
    50ba:	19 1f       	adc	r17, r25
    50bc:	10 93 91 05 	sts	0x0591, r17
    50c0:	00 93 90 05 	sts	0x0590, r16
    50c4:	8f e0       	ldi	r24, 0x0F	; 15
    50c6:	97 e2       	ldi	r25, 0x27	; 39
    50c8:	01 97       	sbiw	r24, 0x01	; 1
    50ca:	f1 f7       	brne	.-4      	; 0x50c8 <Sensors_Calibrate+0xf4>
    50cc:	00 c0       	rjmp	.+0      	; 0x50ce <Sensors_Calibrate+0xfa>
    50ce:	00 00       	nop
		_delay_ms(40);
		LED_Orange =~LED_Orange;
    50d0:	85 b1       	in	r24, 0x05	; 5
    50d2:	86 95       	lsr	r24
    50d4:	86 95       	lsr	r24
    50d6:	86 95       	lsr	r24
    50d8:	80 95       	com	r24
    50da:	81 70       	andi	r24, 0x01	; 1
    50dc:	88 0f       	add	r24, r24
    50de:	88 0f       	add	r24, r24
    50e0:	88 0f       	add	r24, r24
    50e2:	95 b1       	in	r25, 0x05	; 5
    50e4:	97 7f       	andi	r25, 0xF7	; 247
    50e6:	98 2b       	or	r25, r24
    50e8:	95 b9       	out	0x05, r25	; 5
    50ea:	08 94       	sec
    50ec:	e1 08       	sbc	r14, r1
    50ee:	f1 08       	sbc	r15, r1
	{
		nResult [i]=0;
	}
	
	// check: http://www.x-firm.com/?page_id=191
	for (int i=0;i<25;++i)
    50f0:	29 81       	ldd	r18, Y+1	; 0x01
    50f2:	e1 14       	cp	r14, r1
    50f4:	f1 04       	cpc	r15, r1
    50f6:	09 f0       	breq	.+2      	; 0x50fa <Sensors_Calibrate+0x126>
    50f8:	96 cf       	rjmp	.-212    	; 0x5026 <Sensors_Calibrate+0x52>
		nResult[GYRO_Z_Index] += ADCPort_Get(GYRO_Z_PNUM); 
		_delay_ms(40);
		LED_Orange =~LED_Orange;
	}
	
	LED_Orange = LEDOLD;
    50fa:	21 70       	andi	r18, 0x01	; 1
    50fc:	22 0f       	add	r18, r18
    50fe:	22 0f       	add	r18, r18
    5100:	22 0f       	add	r18, r18
    5102:	85 b1       	in	r24, 0x05	; 5
    5104:	87 7f       	andi	r24, 0xF7	; 247
    5106:	82 2b       	or	r24, r18
    5108:	85 b9       	out	0x05, r24	; 5
	
	for (i=0;i<6;++i)
    510a:	20 e0       	ldi	r18, 0x00	; 0
    510c:	30 e0       	ldi	r19, 0x00	; 0
	{
		nResult[i] /=25;
    510e:	09 e1       	ldi	r16, 0x19	; 25
    5110:	10 e0       	ldi	r17, 0x00	; 0
    5112:	f9 01       	movw	r30, r18
    5114:	ee 0f       	add	r30, r30
    5116:	ff 1f       	adc	r31, r31
    5118:	e4 57       	subi	r30, 0x74	; 116
    511a:	fa 4f       	sbci	r31, 0xFA	; 250
    511c:	80 81       	ld	r24, Z
    511e:	91 81       	ldd	r25, Z+1	; 0x01
    5120:	b8 01       	movw	r22, r16
    5122:	0e 94 2c 39 	call	0x7258	; 0x7258 <__udivmodhi4>
    5126:	71 83       	std	Z+1, r23	; 0x01
    5128:	60 83       	st	Z, r22
		LED_Orange =~LED_Orange;
	}
	
	LED_Orange = LEDOLD;
	
	for (i=0;i<6;++i)
    512a:	2f 5f       	subi	r18, 0xFF	; 255
    512c:	3f 4f       	sbci	r19, 0xFF	; 255
    512e:	26 30       	cpi	r18, 0x06	; 6
    5130:	31 05       	cpc	r19, r1
    5132:	79 f7       	brne	.-34     	; 0x5112 <Sensors_Calibrate+0x13e>
	{
		nResult[i] /=25;
	}	
	
	Config.IsCalibrated = (Config.IsCalibrated | CALIBRATED_SENSOR);
    5134:	80 91 da 06 	lds	r24, 0x06DA
    5138:	84 60       	ori	r24, 0x04	; 4
    513a:	80 93 da 06 	sts	0x06DA, r24
    513e:	a8 e7       	ldi	r26, 0x78	; 120
    5140:	b7 e0       	ldi	r27, 0x07	; 7
	for (i=0;i<6;++i)
    5142:	80 e0       	ldi	r24, 0x00	; 0
    5144:	90 e0       	ldi	r25, 0x00	; 0
	Config.Sensor_zero[i] = nResult[i];
    5146:	fc 01       	movw	r30, r24
    5148:	ee 0f       	add	r30, r30
    514a:	ff 1f       	adc	r31, r31
    514c:	e4 57       	subi	r30, 0x74	; 116
    514e:	fa 4f       	sbci	r31, 0xFA	; 250
    5150:	20 81       	ld	r18, Z
    5152:	31 81       	ldd	r19, Z+1	; 0x01
    5154:	2d 93       	st	X+, r18
    5156:	3d 93       	st	X+, r19
	{
		nResult[i] /=25;
	}	
	
	Config.IsCalibrated = (Config.IsCalibrated | CALIBRATED_SENSOR);
	for (i=0;i<6;++i)
    5158:	01 96       	adiw	r24, 0x01	; 1
    515a:	86 30       	cpi	r24, 0x06	; 6
    515c:	91 05       	cpc	r25, r1
    515e:	99 f7       	brne	.-26     	; 0x5146 <Sensors_Calibrate+0x172>
	Config.Sensor_zero[i] = nResult[i];
		
	
	//nResult[ACC_Z_Index]-=100; // Sensor: horizontal, upward ... the caller of this function is responsible for updating Config.Sensor_zero[i] = nResult[i];
		
}
    5160:	0f 90       	pop	r0
    5162:	cf 91       	pop	r28
    5164:	df 91       	pop	r29
    5166:	1f 91       	pop	r17
    5168:	0f 91       	pop	r16
    516a:	ff 90       	pop	r15
    516c:	ef 90       	pop	r14
    516e:	08 95       	ret

00005170 <Sensor_GetBattery>:
}*/

int16_t  Sensor_GetBattery(void)
{
	 // because the V_BAT is connected to a voltage divider R1 & R2
	return (ADCPort_Get(V_BAT_PNUM) *  BAT_VOLT_RATIO);
    5170:	83 e0       	ldi	r24, 0x03	; 3
    5172:	0e 94 88 29 	call	0x5310	; 0x5310 <ADCPort_Get>
    5176:	24 e6       	ldi	r18, 0x64	; 100
    5178:	30 e0       	ldi	r19, 0x00	; 0
    517a:	ac 01       	movw	r20, r24
    517c:	42 9f       	mul	r20, r18
    517e:	c0 01       	movw	r24, r0
    5180:	43 9f       	mul	r20, r19
    5182:	90 0d       	add	r25, r0
    5184:	52 9f       	mul	r21, r18
    5186:	90 0d       	add	r25, r0
    5188:	11 24       	eor	r1, r1
    518a:	64 e7       	ldi	r22, 0x74	; 116
    518c:	71 e0       	ldi	r23, 0x01	; 1
    518e:	0e 94 2c 39 	call	0x7258	; 0x7258 <__udivmodhi4>
} 
    5192:	cb 01       	movw	r24, r22
    5194:	08 95       	ret

00005196 <Sensors_ReadAll>:
   //{
		//TX1= TCNT1;
		//TX= TCNT1_X;
   //}   
	//
	Sensors_Latest[ACC_PITCH_Index] = ADCPort_Get(ACC_PITCH_PNUM)-Config.Sensor_zero[ACC_PITCH_Index]; 
    5196:	85 e0       	ldi	r24, 0x05	; 5
    5198:	0e 94 88 29 	call	0x5310	; 0x5310 <ADCPort_Get>
    519c:	20 91 7e 07 	lds	r18, 0x077E
    51a0:	30 91 7f 07 	lds	r19, 0x077F
    51a4:	82 1b       	sub	r24, r18
    51a6:	93 0b       	sbc	r25, r19
    51a8:	90 93 30 06 	sts	0x0630, r25
    51ac:	80 93 2f 06 	sts	0x062F, r24
	Sensors_Latest[ACC_ROLL_Index] = ADCPort_Get(ACC_ROLL_PNUM)-Config.Sensor_zero[ACC_ROLL_Index];
    51b0:	86 e0       	ldi	r24, 0x06	; 6
    51b2:	0e 94 88 29 	call	0x5310	; 0x5310 <ADCPort_Get>
    51b6:	20 91 80 07 	lds	r18, 0x0780
    51ba:	30 91 81 07 	lds	r19, 0x0781
    51be:	82 1b       	sub	r24, r18
    51c0:	93 0b       	sbc	r25, r19
    51c2:	90 93 32 06 	sts	0x0632, r25
    51c6:	80 93 31 06 	sts	0x0631, r24
	Sensors_Latest[ACC_Z_Index] = ADCPort_Get(ACC_Z_PNUM)-Config.Sensor_zero[ACC_Z_Index];
    51ca:	87 e0       	ldi	r24, 0x07	; 7
    51cc:	0e 94 88 29 	call	0x5310	; 0x5310 <ADCPort_Get>
    51d0:	20 91 82 07 	lds	r18, 0x0782
    51d4:	30 91 83 07 	lds	r19, 0x0783
    51d8:	82 1b       	sub	r24, r18
    51da:	93 0b       	sbc	r25, r19
    51dc:	90 93 34 06 	sts	0x0634, r25
    51e0:	80 93 33 06 	sts	0x0633, r24
		
	Sensors_Latest[GYRO_ROLL_Index] = ADCPort_Get(GYRO_ROLL_PNUM)-Config.Sensor_zero[GYRO_ROLL_Index];
    51e4:	81 e0       	ldi	r24, 0x01	; 1
    51e6:	0e 94 88 29 	call	0x5310	; 0x5310 <ADCPort_Get>
    51ea:	20 91 78 07 	lds	r18, 0x0778
    51ee:	30 91 79 07 	lds	r19, 0x0779
    51f2:	82 1b       	sub	r24, r18
    51f4:	93 0b       	sbc	r25, r19
    51f6:	90 93 2a 06 	sts	0x062A, r25
    51fa:	80 93 29 06 	sts	0x0629, r24
	if (abs(Sensors_Latest[GYRO_ROLL_Index])< DEAD_BAND_GYRO) Sensors_Latest[GYRO_ROLL_Index] = 0;
    51fe:	80 91 29 06 	lds	r24, 0x0629
    5202:	90 91 2a 06 	lds	r25, 0x062A
    5206:	97 ff       	sbrs	r25, 7
    5208:	03 c0       	rjmp	.+6      	; 0x5210 <Sensors_ReadAll+0x7a>
    520a:	90 95       	com	r25
    520c:	81 95       	neg	r24
    520e:	9f 4f       	sbci	r25, 0xFF	; 255
    5210:	82 30       	cpi	r24, 0x02	; 2
    5212:	91 05       	cpc	r25, r1
    5214:	24 f4       	brge	.+8      	; 0x521e <Sensors_ReadAll+0x88>
    5216:	10 92 2a 06 	sts	0x062A, r1
    521a:	10 92 29 06 	sts	0x0629, r1
	Sensors_Latest[GYRO_PITCH_Index] = ADCPort_Get(GYRO_PITCH_PNUM)-Config.Sensor_zero[GYRO_PITCH_Index];
    521e:	84 e0       	ldi	r24, 0x04	; 4
    5220:	0e 94 88 29 	call	0x5310	; 0x5310 <ADCPort_Get>
    5224:	20 91 7a 07 	lds	r18, 0x077A
    5228:	30 91 7b 07 	lds	r19, 0x077B
    522c:	82 1b       	sub	r24, r18
    522e:	93 0b       	sbc	r25, r19
    5230:	90 93 2c 06 	sts	0x062C, r25
    5234:	80 93 2b 06 	sts	0x062B, r24
	if (abs(Sensors_Latest[GYRO_PITCH_Index])< DEAD_BAND_GYRO) Sensors_Latest[GYRO_PITCH_Index] = 0;
    5238:	80 91 2b 06 	lds	r24, 0x062B
    523c:	90 91 2c 06 	lds	r25, 0x062C
    5240:	97 ff       	sbrs	r25, 7
    5242:	03 c0       	rjmp	.+6      	; 0x524a <Sensors_ReadAll+0xb4>
    5244:	90 95       	com	r25
    5246:	81 95       	neg	r24
    5248:	9f 4f       	sbci	r25, 0xFF	; 255
    524a:	82 30       	cpi	r24, 0x02	; 2
    524c:	91 05       	cpc	r25, r1
    524e:	24 f4       	brge	.+8      	; 0x5258 <Sensors_ReadAll+0xc2>
    5250:	10 92 2c 06 	sts	0x062C, r1
    5254:	10 92 2b 06 	sts	0x062B, r1
	Sensors_Latest[GYRO_Z_Index] = ADCPort_Get(GYRO_Z_PNUM)-Config.Sensor_zero[GYRO_Z_Index];
    5258:	82 e0       	ldi	r24, 0x02	; 2
    525a:	0e 94 88 29 	call	0x5310	; 0x5310 <ADCPort_Get>
    525e:	20 91 7c 07 	lds	r18, 0x077C
    5262:	30 91 7d 07 	lds	r19, 0x077D
    5266:	82 1b       	sub	r24, r18
    5268:	93 0b       	sbc	r25, r19
    526a:	90 93 2e 06 	sts	0x062E, r25
    526e:	80 93 2d 06 	sts	0x062D, r24
	if (abs(Sensors_Latest[GYRO_Z_Index])< DEAD_BAND_GYRO) Sensors_Latest[GYRO_Z_Index] = 0;
    5272:	80 91 2d 06 	lds	r24, 0x062D
    5276:	90 91 2e 06 	lds	r25, 0x062E
    527a:	97 ff       	sbrs	r25, 7
    527c:	03 c0       	rjmp	.+6      	; 0x5284 <Sensors_ReadAll+0xee>
    527e:	90 95       	com	r25
    5280:	81 95       	neg	r24
    5282:	9f 4f       	sbci	r25, 0xFF	; 255
    5284:	82 30       	cpi	r24, 0x02	; 2
    5286:	91 05       	cpc	r25, r1
    5288:	24 f4       	brge	.+8      	; 0x5292 <Sensors_ReadAll+0xfc>
    528a:	10 92 2e 06 	sts	0x062E, r1
    528e:	10 92 2d 06 	sts	0x062D, r1
	
	Sensors_Latest[V_BAT_Index] = Sensor_GetBattery(); 
    5292:	0e 94 b8 28 	call	0x5170	; 0x5170 <Sensor_GetBattery>
    5296:	90 93 36 06 	sts	0x0636, r25
    529a:	80 93 35 06 	sts	0x0635, r24
	//else
	//{
		//Sensors_dt = TX1 - TX2;
	//}
	//TX2=TX1;
}
    529e:	08 95       	ret

000052a0 <__vector_24>:
 * 
 *  8.913kHz on mega128 16MHz 1kHz/channel ??
 ***** I used 20 MHz 13 - 260 us conv average = (260-13)/2 + 13 = 136.5 us = 7.326 KHz
*/
ISR(ADC_vect, ISR_NOBLOCK)
{
    52a0:	78 94       	sei
    52a2:	1f 92       	push	r1
    52a4:	0f 92       	push	r0
    52a6:	0f b6       	in	r0, 0x3f	; 63
    52a8:	0f 92       	push	r0
    52aa:	11 24       	eor	r1, r1
    52ac:	2f 93       	push	r18
    52ae:	8f 93       	push	r24
    52b0:	9f 93       	push	r25
    52b2:	ef 93       	push	r30
    52b4:	ff 93       	push	r31
	static uint8_t _index;
	ADCValues[_index] = ADC;
    52b6:	20 91 29 05 	lds	r18, 0x0529
    52ba:	e2 2f       	mov	r30, r18
    52bc:	f0 e0       	ldi	r31, 0x00	; 0
    52be:	80 91 78 00 	lds	r24, 0x0078
    52c2:	90 91 79 00 	lds	r25, 0x0079
    52c6:	ee 0f       	add	r30, r30
    52c8:	ff 1f       	adc	r31, r31
    52ca:	e0 50       	subi	r30, 0x00	; 0
    52cc:	f8 4f       	sbci	r31, 0xF8	; 248
    52ce:	91 83       	std	Z+1, r25	; 0x01
    52d0:	80 83       	st	Z, r24
	_index = (_index + 1) % 8U;
    52d2:	82 2f       	mov	r24, r18
    52d4:	8f 5f       	subi	r24, 0xFF	; 255
    52d6:	87 70       	andi	r24, 0x07	; 7
    52d8:	80 93 29 05 	sts	0x0529, r24
	ADMUX = _index;
    52dc:	80 93 7c 00 	sts	0x007C, r24
	ADCSRA |= _BV(ADSC);
    52e0:	ea e7       	ldi	r30, 0x7A	; 122
    52e2:	f0 e0       	ldi	r31, 0x00	; 0
    52e4:	80 81       	ld	r24, Z
    52e6:	80 64       	ori	r24, 0x40	; 64
    52e8:	80 83       	st	Z, r24
	
	
}
    52ea:	ff 91       	pop	r31
    52ec:	ef 91       	pop	r30
    52ee:	9f 91       	pop	r25
    52f0:	8f 91       	pop	r24
    52f2:	2f 91       	pop	r18
    52f4:	0f 90       	pop	r0
    52f6:	0f be       	out	0x3f, r0	; 63
    52f8:	0f 90       	pop	r0
    52fa:	1f 90       	pop	r1
    52fc:	18 95       	reti

000052fe <ADCPort_Init>:

void ADCPort_Init ()
{
	DIDR0 = 0xFF;	// disable all digital inputs on Port A
    52fe:	8f ef       	ldi	r24, 0xFF	; 255
    5300:	80 93 7e 00 	sts	0x007E, r24
	ADMUX = 0;
    5304:	10 92 7c 00 	sts	0x007C, r1
	ADCSRA = 0b11011111;	// ADEN, ADSC, ADIE, 
    5308:	8f ed       	ldi	r24, 0xDF	; 223
    530a:	80 93 7a 00 	sts	0x007A, r24
		
}
    530e:	08 95       	ret

00005310 <ADCPort_Get>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    5310:	f8 94       	cli
*/
inline uint16_t ADCPort_Get(uint8_t channel)
{
	uint16_t _t;
	ATOMIC_BLOCK(ATOMIC_FORCEON)
		_t = ADCValues[channel];
    5312:	e8 2f       	mov	r30, r24
    5314:	f0 e0       	ldi	r31, 0x00	; 0
    5316:	ee 0f       	add	r30, r30
    5318:	ff 1f       	adc	r31, r31
    531a:	e0 50       	subi	r30, 0x00	; 0
    531c:	f8 4f       	sbci	r31, 0xF8	; 248
    531e:	20 81       	ld	r18, Z
    5320:	31 81       	ldd	r19, Z+1	; 0x01
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    5322:	78 94       	sei
	return _t;
    5324:	c9 01       	movw	r24, r18
    5326:	08 95       	ret

00005328 <_hHomeRestart>:
}


void _hHomeRestart (void)
{
	NOKEYRETURN
    5328:	80 91 a8 05 	lds	r24, 0x05A8
    532c:	88 23       	and	r24, r24
    532e:	11 f0       	breq	.+4      	; 0x5334 <_hHomeRestart+0xc>
	
	if (KEY4)
    5330:	84 fd       	sbrc	r24, 4
    5332:	ff cf       	rjmp	.-2      	; 0x5332 <_hHomeRestart+0xa>
    5334:	08 95       	ret

00005336 <tsmMain>:
	Menu_LoadPage(PAGE_HOME);
}

PGM_P tsmMain(uint8_t index)
{
	return (PGM_P)pgm_read_word(&lstMenu[index]);
    5336:	90 e0       	ldi	r25, 0x00	; 0
    5338:	88 0f       	add	r24, r24
    533a:	99 1f       	adc	r25, r25
    533c:	8b 52       	subi	r24, 0x2B	; 43
    533e:	94 4f       	sbci	r25, 0xF4	; 244
    5340:	fc 01       	movw	r30, r24
    5342:	25 91       	lpm	r18, Z+
    5344:	34 91       	lpm	r19, Z+
}
    5346:	c9 01       	movw	r24, r18
    5348:	08 95       	ret

0000534a <writeSoftkeys>:
		//LCD_WriteString_P(e.text);
	//}
//}

static void writeSoftkeys(const char* sk)
{
    534a:	cf 93       	push	r28
    534c:	df 93       	push	r29
    534e:	ec 01       	movw	r28, r24
	if (!sk)
    5350:	00 97       	sbiw	r24, 0x00	; 0
    5352:	31 f4       	brne	.+12     	; 0x5360 <writeSoftkeys+0x16>
		sk = currentPage.softkeys;
    5354:	c0 91 30 05 	lds	r28, 0x0530
    5358:	d0 91 31 05 	lds	r29, 0x0531
	if (sk)
    535c:	20 97       	sbiw	r28, 0x00	; 0
    535e:	39 f0       	breq	.+14     	; 0x536e <writeSoftkeys+0x24>
	{
		LCD_SetPos(7, 0);
    5360:	87 e0       	ldi	r24, 0x07	; 7
    5362:	60 e0       	ldi	r22, 0x00	; 0
    5364:	0e 94 03 0c 	call	0x1806	; 0x1806 <LCD_SetPos>
		LCD_WriteString_P(sk);
    5368:	ce 01       	movw	r24, r28
    536a:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <LCD_WriteString_P>
	}
}
    536e:	df 91       	pop	r29
    5370:	cf 91       	pop	r28
    5372:	08 95       	ret

00005374 <_hDebug>:

	static double YAWAngle;
static double OldAngle;
	static double YAWAngle2;
void _hDebug()
{
    5374:	ef 92       	push	r14
    5376:	0f 93       	push	r16

	if (IS_INIT)
    5378:	80 91 a8 05 	lds	r24, 0x05A8
    537c:	80 fd       	sbrc	r24, 0
    537e:	4f c0       	rjmp	.+158    	; 0x541e <_hDebug+0xaa>
			//send_byte(0x01);
			//send_byte(0x01);send_byte(0x00);send_byte(0x00);send_byte(0x00);
			//send_byte(98);
	
		}
		if (KEY3)
    5380:	85 ff       	sbrs	r24, 5
    5382:	1b c0       	rjmp	.+54     	; 0x53ba <_hDebug+0x46>
		{
			//gyroZangle=0;
			//gyroYangle=0;
			//gyroXangle=0;
			AnglePitch=0;
    5384:	80 e0       	ldi	r24, 0x00	; 0
    5386:	90 e0       	ldi	r25, 0x00	; 0
    5388:	dc 01       	movw	r26, r24
    538a:	80 93 04 06 	sts	0x0604, r24
    538e:	90 93 05 06 	sts	0x0605, r25
    5392:	a0 93 06 06 	sts	0x0606, r26
    5396:	b0 93 07 06 	sts	0x0607, r27
			AngleRoll=0;
    539a:	80 93 ba 06 	sts	0x06BA, r24
    539e:	90 93 bb 06 	sts	0x06BB, r25
    53a2:	a0 93 bc 06 	sts	0x06BC, r26
    53a6:	b0 93 bd 06 	sts	0x06BD, r27
			AngleZ =0;
    53aa:	80 93 4a 06 	sts	0x064A, r24
    53ae:	90 93 4b 06 	sts	0x064B, r25
    53b2:	a0 93 4c 06 	sts	0x064C, r26
    53b6:	b0 93 4d 06 	sts	0x064D, r27
		}	
		
		LCD_WriteValue_double_ex(0,48, AnglePitch,9,false);
    53ba:	20 91 04 06 	lds	r18, 0x0604
    53be:	30 91 05 06 	lds	r19, 0x0605
    53c2:	40 91 06 06 	lds	r20, 0x0606
    53c6:	50 91 07 06 	lds	r21, 0x0607
    53ca:	80 e0       	ldi	r24, 0x00	; 0
    53cc:	60 e3       	ldi	r22, 0x30	; 48
    53ce:	09 e0       	ldi	r16, 0x09	; 9
    53d0:	ee 24       	eor	r14, r14
    53d2:	0e 94 ad 0d 	call	0x1b5a	; 0x1b5a <LCD_WriteValue_double_ex>
		LCD_WriteValue_double_ex(1,48, AngleRoll,9,false);
    53d6:	20 91 ba 06 	lds	r18, 0x06BA
    53da:	30 91 bb 06 	lds	r19, 0x06BB
    53de:	40 91 bc 06 	lds	r20, 0x06BC
    53e2:	50 91 bd 06 	lds	r21, 0x06BD
    53e6:	81 e0       	ldi	r24, 0x01	; 1
    53e8:	60 e3       	ldi	r22, 0x30	; 48
    53ea:	0e 94 ad 0d 	call	0x1b5a	; 0x1b5a <LCD_WriteValue_double_ex>
		LCD_WriteValue_double_ex(2,48, AngleZ,9,false);
    53ee:	20 91 4a 06 	lds	r18, 0x064A
    53f2:	30 91 4b 06 	lds	r19, 0x064B
    53f6:	40 91 4c 06 	lds	r20, 0x064C
    53fa:	50 91 4d 06 	lds	r21, 0x064D
    53fe:	82 e0       	ldi	r24, 0x02	; 2
    5400:	60 e3       	ldi	r22, 0x30	; 48
    5402:	0e 94 ad 0d 	call	0x1b5a	; 0x1b5a <LCD_WriteValue_double_ex>
		LCD_WriteValue_double_ex(3,48, NavX,9,false);
    5406:	20 91 36 05 	lds	r18, 0x0536
    540a:	30 91 37 05 	lds	r19, 0x0537
    540e:	40 91 38 05 	lds	r20, 0x0538
    5412:	50 91 39 05 	lds	r21, 0x0539
    5416:	83 e0       	ldi	r24, 0x03	; 3
    5418:	60 e3       	ldi	r22, 0x30	; 48
    541a:	0e 94 ad 0d 	call	0x1b5a	; 0x1b5a <LCD_WriteValue_double_ex>
		//LCD_WriteValue(4,48, MotorOut[3],9,false);
	}
}
    541e:	0f 91       	pop	r16
    5420:	ef 90       	pop	r14
    5422:	08 95       	ret

00005424 <_hSensorCalibration>:

	_helper_DisplayRXStatus(6);
}

void _hSensorCalibration()
{
    5424:	0f 93       	push	r16
    5426:	1f 93       	push	r17
    5428:	cf 93       	push	r28
    542a:	df 93       	push	r29
	NOKEYRETURN;
    542c:	80 91 a8 05 	lds	r24, 0x05A8
    5430:	88 23       	and	r24, r24
    5432:	69 f1       	breq	.+90     	; 0x548e <_hSensorCalibration+0x6a>
	uint8_t i;
		
	if (KEY4)
    5434:	84 ff       	sbrs	r24, 4
    5436:	19 c0       	rjmp	.+50     	; 0x546a <_hSensorCalibration+0x46>
    5438:	15 e0       	ldi	r17, 0x05	; 5
	{
		// Delay to allow not touching the board.		
		for (i=0; i<5;++i)
		{
			LED_FlashOrangeLED (200,2);
    543a:	88 ec       	ldi	r24, 0xC8	; 200
    543c:	90 e0       	ldi	r25, 0x00	; 0
    543e:	62 e0       	ldi	r22, 0x02	; 2
    5440:	0e 94 8e 0e 	call	0x1d1c	; 0x1d1c <LED_FlashOrangeLED>
			Beeper_Beep(BEEP_SHORT,1);
    5444:	86 e4       	ldi	r24, 0x46	; 70
    5446:	90 e0       	ldi	r25, 0x00	; 0
    5448:	61 e0       	ldi	r22, 0x01	; 1
    544a:	0e 94 8c 0b 	call	0x1718	; 0x1718 <Beeper_Beep>
    544e:	11 50       	subi	r17, 0x01	; 1
	uint8_t i;
		
	if (KEY4)
	{
		// Delay to allow not touching the board.		
		for (i=0; i<5;++i)
    5450:	a1 f7       	brne	.-24     	; 0x543a <_hSensorCalibration+0x16>
		{
			LED_FlashOrangeLED (200,2);
			Beeper_Beep(BEEP_SHORT,1);
		}
	
		Sensors_Calibrate ();
    5452:	0e 94 ea 27 	call	0x4fd4	; 0x4fd4 <Sensors_Calibrate>
		
		Save_Config_to_EEPROM();
    5456:	0e 94 c3 0f 	call	0x1f86	; 0x1f86 <Save_Config_to_EEPROM>
		currentPage.softkeys = _skBACK;
    545a:	87 ed       	ldi	r24, 0xD7	; 215
    545c:	9c e0       	ldi	r25, 0x0C	; 12
    545e:	90 93 31 05 	sts	0x0531, r25
    5462:	80 93 30 05 	sts	0x0530, r24
		writeSoftkeys(currentPage.softkeys);
    5466:	0e 94 a5 29 	call	0x534a	; 0x534a <writeSoftkeys>
    546a:	c8 e7       	ldi	r28, 0x78	; 120
    546c:	d7 e0       	ldi	r29, 0x07	; 7
void _hSensorCalibration()
{
	NOKEYRETURN;
	uint8_t i;
		
	if (KEY4)
    546e:	10 e0       	ldi	r17, 0x00	; 0
	}
	
	
	for (i=0; i<6;++i)
	{ // order is aligned with ACC_PITCH_Index & GYRO_ROLL_Index
		LCD_SetPos(i, 48);
    5470:	81 2f       	mov	r24, r17
    5472:	60 e3       	ldi	r22, 0x30	; 48
    5474:	0e 94 03 0c 	call	0x1806	; 0x1806 <LCD_SetPos>
		LCD_WriteValue(i,48,Config.Sensor_zero[i],5,false);
    5478:	49 91       	ld	r20, Y+
    547a:	59 91       	ld	r21, Y+
    547c:	81 2f       	mov	r24, r17
    547e:	60 e3       	ldi	r22, 0x30	; 48
    5480:	25 e0       	ldi	r18, 0x05	; 5
    5482:	00 e0       	ldi	r16, 0x00	; 0
    5484:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <LCD_WriteValue>
		currentPage.softkeys = _skBACK;
		writeSoftkeys(currentPage.softkeys);
	}
	
	
	for (i=0; i<6;++i)
    5488:	1f 5f       	subi	r17, 0xFF	; 255
    548a:	16 30       	cpi	r17, 0x06	; 6
    548c:	89 f7       	brne	.-30     	; 0x5470 <_hSensorCalibration+0x4c>
	{ // order is aligned with ACC_PITCH_Index & GYRO_ROLL_Index
		LCD_SetPos(i, 48);
		LCD_WriteValue(i,48,Config.Sensor_zero[i],5,false);
	}	
	
}
    548e:	df 91       	pop	r29
    5490:	cf 91       	pop	r28
    5492:	1f 91       	pop	r17
    5494:	0f 91       	pop	r16
    5496:	08 95       	ret

00005498 <_hSensorTest>:
	}
}


void _hSensorTest()
{
    5498:	0f 93       	push	r16
	#define AccHighLimit		850
	#define GyroLowLimit		500		
	#define GyroHighLimit		630

	
	LCD_SetPos(0, 48);
    549a:	80 e0       	ldi	r24, 0x00	; 0
    549c:	60 e3       	ldi	r22, 0x30	; 48
    549e:	0e 94 03 0c 	call	0x1806	; 0x1806 <LCD_SetPos>
	LCD_WriteString(Sensors_Test(GYRO_ROLL_PNUM,GyroLowLimit,GyroHighLimit));
    54a2:	81 e0       	ldi	r24, 0x01	; 1
    54a4:	64 ef       	ldi	r22, 0xF4	; 244
    54a6:	71 e0       	ldi	r23, 0x01	; 1
    54a8:	46 e7       	ldi	r20, 0x76	; 118
    54aa:	52 e0       	ldi	r21, 0x02	; 2
    54ac:	0e 94 b2 27 	call	0x4f64	; 0x4f64 <Sensors_Test>
    54b0:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <LCD_WriteString>
	LCD_SetPos(1, 48);
    54b4:	81 e0       	ldi	r24, 0x01	; 1
    54b6:	60 e3       	ldi	r22, 0x30	; 48
    54b8:	0e 94 03 0c 	call	0x1806	; 0x1806 <LCD_SetPos>
	LCD_WriteString(Sensors_Test(GYRO_PITCH_PNUM,GyroLowLimit,GyroHighLimit));
    54bc:	84 e0       	ldi	r24, 0x04	; 4
    54be:	64 ef       	ldi	r22, 0xF4	; 244
    54c0:	71 e0       	ldi	r23, 0x01	; 1
    54c2:	46 e7       	ldi	r20, 0x76	; 118
    54c4:	52 e0       	ldi	r21, 0x02	; 2
    54c6:	0e 94 b2 27 	call	0x4f64	; 0x4f64 <Sensors_Test>
    54ca:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <LCD_WriteString>
	LCD_SetPos(2, 48);
    54ce:	82 e0       	ldi	r24, 0x02	; 2
    54d0:	60 e3       	ldi	r22, 0x30	; 48
    54d2:	0e 94 03 0c 	call	0x1806	; 0x1806 <LCD_SetPos>
	LCD_WriteString(Sensors_Test(GYRO_Z_PNUM,GyroLowLimit,GyroHighLimit));
    54d6:	82 e0       	ldi	r24, 0x02	; 2
    54d8:	64 ef       	ldi	r22, 0xF4	; 244
    54da:	71 e0       	ldi	r23, 0x01	; 1
    54dc:	46 e7       	ldi	r20, 0x76	; 118
    54de:	52 e0       	ldi	r21, 0x02	; 2
    54e0:	0e 94 b2 27 	call	0x4f64	; 0x4f64 <Sensors_Test>
    54e4:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <LCD_WriteString>
	
	LCD_SetPos(3, 48);
    54e8:	83 e0       	ldi	r24, 0x03	; 3
    54ea:	60 e3       	ldi	r22, 0x30	; 48
    54ec:	0e 94 03 0c 	call	0x1806	; 0x1806 <LCD_SetPos>
	LCD_WriteString(Sensors_Test(ACC_PITCH_PNUM,AccLowLimit,AccHighLimit));
    54f0:	85 e0       	ldi	r24, 0x05	; 5
    54f2:	62 ec       	ldi	r22, 0xC2	; 194
    54f4:	71 e0       	ldi	r23, 0x01	; 1
    54f6:	42 e5       	ldi	r20, 0x52	; 82
    54f8:	53 e0       	ldi	r21, 0x03	; 3
    54fa:	0e 94 b2 27 	call	0x4f64	; 0x4f64 <Sensors_Test>
    54fe:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <LCD_WriteString>
	LCD_SetPos(4, 48);
    5502:	84 e0       	ldi	r24, 0x04	; 4
    5504:	60 e3       	ldi	r22, 0x30	; 48
    5506:	0e 94 03 0c 	call	0x1806	; 0x1806 <LCD_SetPos>
	LCD_WriteString(Sensors_Test(ACC_ROLL_PNUM,AccLowLimit,AccHighLimit));
    550a:	86 e0       	ldi	r24, 0x06	; 6
    550c:	62 ec       	ldi	r22, 0xC2	; 194
    550e:	71 e0       	ldi	r23, 0x01	; 1
    5510:	42 e5       	ldi	r20, 0x52	; 82
    5512:	53 e0       	ldi	r21, 0x03	; 3
    5514:	0e 94 b2 27 	call	0x4f64	; 0x4f64 <Sensors_Test>
    5518:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <LCD_WriteString>
	LCD_SetPos(5, 48);
    551c:	85 e0       	ldi	r24, 0x05	; 5
    551e:	60 e3       	ldi	r22, 0x30	; 48
    5520:	0e 94 03 0c 	call	0x1806	; 0x1806 <LCD_SetPos>
	LCD_WriteString(Sensors_Test(ACC_Z_PNUM,AccLowLimit,AccHighLimit));
    5524:	87 e0       	ldi	r24, 0x07	; 7
    5526:	62 ec       	ldi	r22, 0xC2	; 194
    5528:	71 e0       	ldi	r23, 0x01	; 1
    552a:	42 e5       	ldi	r20, 0x52	; 82
    552c:	53 e0       	ldi	r21, 0x03	; 3
    552e:	0e 94 b2 27 	call	0x4f64	; 0x4f64 <Sensors_Test>
    5532:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <LCD_WriteString>
	LCD_SetPos(6, 48);
    5536:	86 e0       	ldi	r24, 0x06	; 6
    5538:	60 e3       	ldi	r22, 0x30	; 48
    553a:	0e 94 03 0c 	call	0x1806	; 0x1806 <LCD_SetPos>
	LCD_WriteValue_double(6,48,Sensor_GetBattery(),false);
    553e:	0e 94 b8 28 	call	0x5170	; 0x5170 <Sensor_GetBattery>
    5542:	9c 01       	movw	r18, r24
    5544:	b9 01       	movw	r22, r18
    5546:	88 27       	eor	r24, r24
    5548:	77 fd       	sbrc	r23, 7
    554a:	80 95       	com	r24
    554c:	98 2f       	mov	r25, r24
    554e:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    5552:	9b 01       	movw	r18, r22
    5554:	ac 01       	movw	r20, r24
    5556:	86 e0       	ldi	r24, 0x06	; 6
    5558:	60 e3       	ldi	r22, 0x30	; 48
    555a:	00 e0       	ldi	r16, 0x00	; 0
    555c:	0e 94 ed 0d 	call	0x1bda	; 0x1bda <LCD_WriteValue_double>
}
    5560:	0f 91       	pop	r16
    5562:	08 95       	ret

00005564 <_hHomeArmedESC>:


void _hHomeArmedESC (void)
{
	
	if (IS_INIT)	
    5564:	80 91 a8 05 	lds	r24, 0x05A8
    5568:	80 ff       	sbrs	r24, 0
    556a:	10 c0       	rjmp	.+32     	; 0x558c <_hHomeArmedESC+0x28>
	{
		LCD_SelectFont (&font12x16);
    556c:	89 e4       	ldi	r24, 0x49	; 73
    556e:	91 e0       	ldi	r25, 0x01	; 1
    5570:	0e 94 57 0e 	call	0x1cae	; 0x1cae <LCD_SelectFont>
		LCD_SetPos(0,0);
    5574:	80 e0       	ldi	r24, 0x00	; 0
    5576:	60 e0       	ldi	r22, 0x00	; 0
    5578:	0e 94 03 0c 	call	0x1806	; 0x1806 <LCD_SetPos>
		LCD_WriteString_P(strARMED);
    557c:	8b ef       	ldi	r24, 0xFB	; 251
    557e:	9c e0       	ldi	r25, 0x0C	; 12
    5580:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <LCD_WriteString_P>
		LCD_SelectFont (NULL);
    5584:	80 e0       	ldi	r24, 0x00	; 0
    5586:	90 e0       	ldi	r25, 0x00	; 0
    5588:	0e 94 57 0e 	call	0x1cae	; 0x1cae <LCD_SelectFont>
	}
	
	if (KEY4)
    558c:	80 91 a8 05 	lds	r24, 0x05A8
    5590:	84 ff       	sbrs	r24, 4
    5592:	04 c0       	rjmp	.+8      	; 0x559c <_hHomeArmedESC+0x38>
	{
		//reset ESC Calibration mode.
		Config.IsESCCalibration=ESCCalibration_OFF;
    5594:	10 92 df 06 	sts	0x06DF, r1
		Save_Config_to_EEPROM();
    5598:	0e 94 c3 0f 	call	0x1f86	; 0x1f86 <Save_Config_to_EEPROM>
	}
	
	LCD_SetPos(3,18);
    559c:	83 e0       	ldi	r24, 0x03	; 3
    559e:	62 e1       	ldi	r22, 0x12	; 18
    55a0:	0e 94 03 0c 	call	0x1806	; 0x1806 <LCD_SetPos>
	itoa(MotorOut[0],sXDeg,10);
    55a4:	80 91 84 05 	lds	r24, 0x0584
    55a8:	90 91 85 05 	lds	r25, 0x0585
    55ac:	68 ed       	ldi	r22, 0xD8	; 216
    55ae:	75 e0       	ldi	r23, 0x05	; 5
    55b0:	4a e0       	ldi	r20, 0x0A	; 10
    55b2:	50 e0       	ldi	r21, 0x00	; 0
    55b4:	0e 94 ab 39 	call	0x7356	; 0x7356 <itoa>
	LCD_WritePadded(sXDeg,5);
    55b8:	88 ed       	ldi	r24, 0xD8	; 216
    55ba:	95 e0       	ldi	r25, 0x05	; 5
    55bc:	65 e0       	ldi	r22, 0x05	; 5
    55be:	0e 94 52 0d 	call	0x1aa4	; 0x1aa4 <LCD_WritePadded>
	
	LCD_SetPos(3,78);
    55c2:	83 e0       	ldi	r24, 0x03	; 3
    55c4:	6e e4       	ldi	r22, 0x4E	; 78
    55c6:	0e 94 03 0c 	call	0x1806	; 0x1806 <LCD_SetPos>
	itoa(MotorOut[3],sXDeg,10);
    55ca:	80 91 8a 05 	lds	r24, 0x058A
    55ce:	90 91 8b 05 	lds	r25, 0x058B
    55d2:	68 ed       	ldi	r22, 0xD8	; 216
    55d4:	75 e0       	ldi	r23, 0x05	; 5
    55d6:	4a e0       	ldi	r20, 0x0A	; 10
    55d8:	50 e0       	ldi	r21, 0x00	; 0
    55da:	0e 94 ab 39 	call	0x7356	; 0x7356 <itoa>
	LCD_WritePadded(sXDeg,5);
    55de:	88 ed       	ldi	r24, 0xD8	; 216
    55e0:	95 e0       	ldi	r25, 0x05	; 5
    55e2:	65 e0       	ldi	r22, 0x05	; 5
    55e4:	0e 94 52 0d 	call	0x1aa4	; 0x1aa4 <LCD_WritePadded>
	
	LCD_SetPos(4,18);
    55e8:	84 e0       	ldi	r24, 0x04	; 4
    55ea:	62 e1       	ldi	r22, 0x12	; 18
    55ec:	0e 94 03 0c 	call	0x1806	; 0x1806 <LCD_SetPos>
	itoa(MotorOut[1],sXDeg,10);
    55f0:	80 91 86 05 	lds	r24, 0x0586
    55f4:	90 91 87 05 	lds	r25, 0x0587
    55f8:	68 ed       	ldi	r22, 0xD8	; 216
    55fa:	75 e0       	ldi	r23, 0x05	; 5
    55fc:	4a e0       	ldi	r20, 0x0A	; 10
    55fe:	50 e0       	ldi	r21, 0x00	; 0
    5600:	0e 94 ab 39 	call	0x7356	; 0x7356 <itoa>
	LCD_WritePadded(sXDeg,5);
    5604:	88 ed       	ldi	r24, 0xD8	; 216
    5606:	95 e0       	ldi	r25, 0x05	; 5
    5608:	65 e0       	ldi	r22, 0x05	; 5
    560a:	0e 94 52 0d 	call	0x1aa4	; 0x1aa4 <LCD_WritePadded>
	
	LCD_SetPos(4,78);
    560e:	84 e0       	ldi	r24, 0x04	; 4
    5610:	6e e4       	ldi	r22, 0x4E	; 78
    5612:	0e 94 03 0c 	call	0x1806	; 0x1806 <LCD_SetPos>
	itoa(MotorOut[2],sXDeg,10);
    5616:	80 91 88 05 	lds	r24, 0x0588
    561a:	90 91 89 05 	lds	r25, 0x0589
    561e:	68 ed       	ldi	r22, 0xD8	; 216
    5620:	75 e0       	ldi	r23, 0x05	; 5
    5622:	4a e0       	ldi	r20, 0x0A	; 10
    5624:	50 e0       	ldi	r21, 0x00	; 0
    5626:	0e 94 ab 39 	call	0x7356	; 0x7356 <itoa>
	LCD_WritePadded(sXDeg,5);
    562a:	88 ed       	ldi	r24, 0xD8	; 216
    562c:	95 e0       	ldi	r25, 0x05	; 5
    562e:	65 e0       	ldi	r22, 0x05	; 5
    5630:	0e 94 52 0d 	call	0x1aa4	; 0x1aa4 <LCD_WritePadded>
	
}
    5634:	08 95       	ret

00005636 <_helper_DisplayPitchRollYaw>:
	};
//////////////////////////////////////////////////////////////////////////

void _helper_DisplayPitchRollYaw (const uint8_t subindex)
{
	switch (subindex)
    5636:	81 30       	cpi	r24, 0x01	; 1
    5638:	99 f0       	breq	.+38     	; 0x5660 <_helper_DisplayPitchRollYaw+0x2a>
    563a:	81 30       	cpi	r24, 0x01	; 1
    563c:	18 f0       	brcs	.+6      	; 0x5644 <_helper_DisplayPitchRollYaw+0xe>
    563e:	82 30       	cpi	r24, 0x02	; 2
    5640:	e1 f4       	brne	.+56     	; 0x567a <_helper_DisplayPitchRollYaw+0x44>
    5642:	15 c0       	rjmp	.+42     	; 0x566e <_helper_DisplayPitchRollYaw+0x38>
	{
		case 0:	
			if (Config.PitchRollLinked==0)
    5644:	80 91 91 07 	lds	r24, 0x0791
    5648:	88 23       	and	r24, r24
    564a:	29 f4       	brne	.+10     	; 0x5656 <_helper_DisplayPitchRollYaw+0x20>
			{
				strcpy_P(sXDeg,PSTR("Pitch       "));
    564c:	88 ed       	ldi	r24, 0xD8	; 216
    564e:	95 e0       	ldi	r25, 0x05	; 5
    5650:	63 ee       	ldi	r22, 0xE3	; 227
    5652:	7d e0       	ldi	r23, 0x0D	; 13
    5654:	09 c0       	rjmp	.+18     	; 0x5668 <_helper_DisplayPitchRollYaw+0x32>
			}
			else
			{
				strcpy_P(sXDeg,PSTR("Pitch & Roll"));
    5656:	88 ed       	ldi	r24, 0xD8	; 216
    5658:	95 e0       	ldi	r25, 0x05	; 5
    565a:	66 ed       	ldi	r22, 0xD6	; 214
    565c:	7d e0       	ldi	r23, 0x0D	; 13
    565e:	04 c0       	rjmp	.+8      	; 0x5668 <_helper_DisplayPitchRollYaw+0x32>
			}
			break;
		case 1:	
				strcpy_P(sXDeg,PSTR("Roll        "));
    5660:	88 ed       	ldi	r24, 0xD8	; 216
    5662:	95 e0       	ldi	r25, 0x05	; 5
    5664:	69 ec       	ldi	r22, 0xC9	; 201
    5666:	7d e0       	ldi	r23, 0x0D	; 13
    5668:	0e 94 87 39 	call	0x730e	; 0x730e <strcpy_P>
			break;
    566c:	08 95       	ret
		case 2:	
				strcpy_P(sXDeg,PSTR("YAW         "));
    566e:	88 ed       	ldi	r24, 0xD8	; 216
    5670:	95 e0       	ldi	r25, 0x05	; 5
    5672:	6c eb       	ldi	r22, 0xBC	; 188
    5674:	7d e0       	ldi	r23, 0x0D	; 13
    5676:	0e 94 87 39 	call	0x730e	; 0x730e <strcpy_P>
    567a:	08 95       	ret

0000567c <_helper_SwitchPitchRollYaw>:
			break;
	}
}

void _helper_SwitchPitchRollYaw (uint8_t *subindex)
{
    567c:	fc 01       	movw	r30, r24
	switch (subindex[0])
    567e:	80 81       	ld	r24, Z
    5680:	81 30       	cpi	r24, 0x01	; 1
    5682:	59 f0       	breq	.+22     	; 0x569a <_helper_SwitchPitchRollYaw+0x1e>
    5684:	81 30       	cpi	r24, 0x01	; 1
    5686:	18 f0       	brcs	.+6      	; 0x568e <_helper_SwitchPitchRollYaw+0x12>
    5688:	82 30       	cpi	r24, 0x02	; 2
    568a:	59 f4       	brne	.+22     	; 0x56a2 <_helper_SwitchPitchRollYaw+0x26>
    568c:	09 c0       	rjmp	.+18     	; 0x56a0 <_helper_SwitchPitchRollYaw+0x24>
	{
		case 0:	if (Config.PitchRollLinked==0) subindex[0]=1; else subindex[0]=2;
    568e:	80 91 91 07 	lds	r24, 0x0791
    5692:	88 23       	and	r24, r24
    5694:	11 f4       	brne	.+4      	; 0x569a <_helper_SwitchPitchRollYaw+0x1e>
    5696:	81 e0       	ldi	r24, 0x01	; 1
    5698:	01 c0       	rjmp	.+2      	; 0x569c <_helper_SwitchPitchRollYaw+0x20>
		break;
		case 1:	subindex[0] +=1;
    569a:	82 e0       	ldi	r24, 0x02	; 2
    569c:	80 83       	st	Z, r24
		break;
    569e:	08 95       	ret
		case 2: subindex[0]=0;
    56a0:	10 82       	st	Z, r1
    56a2:	08 95       	ret

000056a4 <_helper_DisplayBiStateText>:

	return;	
}	

void _helper_DisplayBiStateText(const uint8_t Row, const uint8_t Col, PGM_P strTrue, PGM_P strFalse, const bool Condition, const BOOL LCDReverse )
{
    56a4:	af 92       	push	r10
    56a6:	bf 92       	push	r11
    56a8:	cf 92       	push	r12
    56aa:	df 92       	push	r13
    56ac:	ef 92       	push	r14
    56ae:	0f 93       	push	r16
    56b0:	1f 93       	push	r17
    56b2:	df 93       	push	r29
    56b4:	cf 93       	push	r28
    56b6:	0f 92       	push	r0
    56b8:	cd b7       	in	r28, 0x3d	; 61
    56ba:	de b7       	in	r29, 0x3e	; 62
    56bc:	18 2f       	mov	r17, r24
    56be:	6a 01       	movw	r12, r20
    56c0:	59 01       	movw	r10, r18
    56c2:	8e 2d       	mov	r24, r14
		lcdReverse(LCDReverse);
    56c4:	69 83       	std	Y+1, r22	; 0x01
    56c6:	0e 94 0e 0d 	call	0x1a1c	; 0x1a1c <lcdReverse>
		LCD_SetPos(Row, Col);
    56ca:	81 2f       	mov	r24, r17
    56cc:	69 81       	ldd	r22, Y+1	; 0x01
    56ce:	0e 94 03 0c 	call	0x1806	; 0x1806 <LCD_SetPos>
		if (Condition==true) 
    56d2:	00 23       	and	r16, r16
    56d4:	11 f0       	breq	.+4      	; 0x56da <_helper_DisplayBiStateText+0x36>
		{
			LCD_WriteString_P(strTrue);
    56d6:	c6 01       	movw	r24, r12
    56d8:	01 c0       	rjmp	.+2      	; 0x56dc <_helper_DisplayBiStateText+0x38>
		}
		else
		{
			LCD_WriteString_P(strFalse);
    56da:	c5 01       	movw	r24, r10
    56dc:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <LCD_WriteString_P>
		}	
		lcdReverse(false);
    56e0:	80 e0       	ldi	r24, 0x00	; 0
    56e2:	0e 94 0e 0d 	call	0x1a1c	; 0x1a1c <lcdReverse>
}
    56e6:	0f 90       	pop	r0
    56e8:	cf 91       	pop	r28
    56ea:	df 91       	pop	r29
    56ec:	1f 91       	pop	r17
    56ee:	0f 91       	pop	r16
    56f0:	ef 90       	pop	r14
    56f2:	df 90       	pop	r13
    56f4:	cf 90       	pop	r12
    56f6:	bf 90       	pop	r11
    56f8:	af 90       	pop	r10
    56fa:	08 95       	ret

000056fc <_helper_SaveinEEPROM_ifChanged>:


void _helper_SaveinEEPROM_ifChanged()
{
	if (bValueChanged==true)
    56fc:	80 91 2a 05 	lds	r24, 0x052A
    5700:	81 30       	cpi	r24, 0x01	; 1
    5702:	21 f4       	brne	.+8      	; 0x570c <_helper_SaveinEEPROM_ifChanged+0x10>
		{
			Save_Config_to_EEPROM();
    5704:	0e 94 c3 0f 	call	0x1f86	; 0x1f86 <Save_Config_to_EEPROM>
			bValueChanged = false;
    5708:	10 92 2a 05 	sts	0x052A, r1
    570c:	08 95       	ret

0000570e <_helper_DisplayRXStatus>:
			return ;
	}
}

void _helper_DisplayRXStatus(const uint8_t Row)
{
    570e:	ef 92       	push	r14
    5710:	0f 93       	push	r16
    5712:	1f 93       	push	r17
    5714:	18 2f       	mov	r17, r24
	// Write RX Status
	// FIX: highlighted is the selected one.
	_helper_DisplayBiStateText(Row,18,str1,strX,IS_TX1_GOOD,(ActiveRXIndex!=1));
    5716:	20 91 c5 07 	lds	r18, 0x07C5
    571a:	80 91 b8 05 	lds	r24, 0x05B8
    571e:	30 e0       	ldi	r19, 0x00	; 0
    5720:	2f 70       	andi	r18, 0x0F	; 15
    5722:	30 70       	andi	r19, 0x00	; 0
    5724:	01 e0       	ldi	r16, 0x01	; 1
    5726:	21 15       	cp	r18, r1
    5728:	31 05       	cpc	r19, r1
    572a:	09 f0       	breq	.+2      	; 0x572e <_helper_DisplayRXStatus+0x20>
    572c:	00 e0       	ldi	r16, 0x00	; 0
    572e:	91 e0       	ldi	r25, 0x01	; 1
    5730:	81 30       	cpi	r24, 0x01	; 1
    5732:	09 f4       	brne	.+2      	; 0x5736 <_helper_DisplayRXStatus+0x28>
    5734:	90 e0       	ldi	r25, 0x00	; 0
    5736:	81 2f       	mov	r24, r17
    5738:	62 e1       	ldi	r22, 0x12	; 18
    573a:	49 e1       	ldi	r20, 0x19	; 25
    573c:	5d e0       	ldi	r21, 0x0D	; 13
    573e:	2b e1       	ldi	r18, 0x1B	; 27
    5740:	3d e0       	ldi	r19, 0x0D	; 13
    5742:	e9 2e       	mov	r14, r25
    5744:	0e 94 52 2b 	call	0x56a4	; 0x56a4 <_helper_DisplayBiStateText>
	
	_helper_DisplayBiStateText(Row,30,str2,strX,IS_TX2_GOOD,(ActiveRXIndex!=0));
    5748:	80 91 c5 07 	lds	r24, 0x07C5
    574c:	20 91 b8 05 	lds	r18, 0x05B8
    5750:	80 7f       	andi	r24, 0xF0	; 240
    5752:	01 e0       	ldi	r16, 0x01	; 1
    5754:	09 f0       	breq	.+2      	; 0x5758 <_helper_DisplayRXStatus+0x4a>
    5756:	00 e0       	ldi	r16, 0x00	; 0
    5758:	91 e0       	ldi	r25, 0x01	; 1
    575a:	22 23       	and	r18, r18
    575c:	09 f4       	brne	.+2      	; 0x5760 <_helper_DisplayRXStatus+0x52>
    575e:	90 e0       	ldi	r25, 0x00	; 0
    5760:	81 2f       	mov	r24, r17
    5762:	6e e1       	ldi	r22, 0x1E	; 30
    5764:	4d e1       	ldi	r20, 0x1D	; 29
    5766:	5d e0       	ldi	r21, 0x0D	; 13
    5768:	2b e1       	ldi	r18, 0x1B	; 27
    576a:	3d e0       	ldi	r19, 0x0D	; 13
    576c:	e9 2e       	mov	r14, r25
    576e:	0e 94 52 2b 	call	0x56a4	; 0x56a4 <_helper_DisplayBiStateText>
	
	lcdReverse(false);
    5772:	80 e0       	ldi	r24, 0x00	; 0
    5774:	0e 94 0e 0d 	call	0x1a1c	; 0x1a1c <lcdReverse>
	
}
    5778:	1f 91       	pop	r17
    577a:	0f 91       	pop	r16
    577c:	ef 90       	pop	r14
    577e:	08 95       	ret

00005780 <_hStickCentering>:



BOOL bError; 
void _hStickCentering()
{
    5780:	0f 93       	push	r16
    5782:	1f 93       	push	r17
    5784:	cf 93       	push	r28
    5786:	df 93       	push	r29
	uint8_t i ;
	UIEnableStickCommands=false; // you cannot use sticks here. for arming or as buttons.
    5788:	10 92 d2 05 	sts	0x05D2, r1
	
	if (IS_INIT)
    578c:	80 91 a8 05 	lds	r24, 0x05A8
    5790:	80 ff       	sbrs	r24, 0
    5792:	0c c0       	rjmp	.+24     	; 0x57ac <_hStickCentering+0x2c>
	{
		RX_StickCenterCalibrationInit(ActiveRXIndex);
    5794:	80 91 b8 05 	lds	r24, 0x05B8
    5798:	0e 94 b5 26 	call	0x4d6a	; 0x4d6a <RX_StickCenterCalibrationInit>
		LCD_WriteString_Pex(0,0,strSPC1,18,false); // clear the header
    579c:	80 e0       	ldi	r24, 0x00	; 0
    579e:	60 e0       	ldi	r22, 0x00	; 0
    57a0:	4d ee       	ldi	r20, 0xED	; 237
    57a2:	5c e0       	ldi	r21, 0x0C	; 12
    57a4:	22 e1       	ldi	r18, 0x12	; 18
    57a6:	00 e0       	ldi	r16, 0x00	; 0
    57a8:	0e 94 88 0d 	call	0x1b10	; 0x1b10 <LCD_WriteString_Pex>
	}
	
	if (KEY4)
    57ac:	80 91 a8 05 	lds	r24, 0x05A8
    57b0:	84 ff       	sbrs	r24, 4
    57b2:	bf c0       	rjmp	.+382    	; 0x5932 <_hStickCentering+0x1b2>
	{
		if (!bError)
    57b4:	80 91 10 08 	lds	r24, 0x0810
    57b8:	88 23       	and	r24, r24
    57ba:	09 f0       	breq	.+2      	; 0x57be <_hStickCentering+0x3e>
    57bc:	b5 c0       	rjmp	.+362    	; 0x5928 <_hStickCentering+0x1a8>
    57be:	20 e0       	ldi	r18, 0x00	; 0
    57c0:	30 e0       	ldi	r19, 0x00	; 0
			// Save config
			for (i = 0; i < RXChannels; i++)
			{
				Config.RX_Mid[ActiveRXIndex][i] = (RX_MAX_raw[ActiveRXIndex][i]+RX_MIN_raw[ActiveRXIndex][i])/2;
				Config.RX_Min[ActiveRXIndex][i] = RX_MIN_raw[ActiveRXIndex][i];
				Config.RX_DiV_Value[ActiveRXIndex][i] = ((RX_MAX_raw[ActiveRXIndex][i] - RX_MIN_raw[ActiveRXIndex][i]) / 1000);
    57c2:	08 ee       	ldi	r16, 0xE8	; 232
    57c4:	13 e0       	ldi	r17, 0x03	; 3
		if (!bError)
		{
			// Save config
			for (i = 0; i < RXChannels; i++)
			{
				Config.RX_Mid[ActiveRXIndex][i] = (RX_MAX_raw[ActiveRXIndex][i]+RX_MIN_raw[ActiveRXIndex][i])/2;
    57c6:	80 91 b8 05 	lds	r24, 0x05B8
    57ca:	40 91 b8 05 	lds	r20, 0x05B8
    57ce:	60 91 b8 05 	lds	r22, 0x05B8
    57d2:	90 e0       	ldi	r25, 0x00	; 0
    57d4:	fc 01       	movw	r30, r24
    57d6:	ee 0f       	add	r30, r30
    57d8:	ff 1f       	adc	r31, r31
    57da:	ee 0f       	add	r30, r30
    57dc:	ff 1f       	adc	r31, r31
    57de:	e8 0f       	add	r30, r24
    57e0:	f9 1f       	adc	r31, r25
    57e2:	e2 0f       	add	r30, r18
    57e4:	f3 1f       	adc	r31, r19
    57e6:	ee 0f       	add	r30, r30
    57e8:	ff 1f       	adc	r31, r31
    57ea:	e4 5b       	subi	r30, 0xB4	; 180
    57ec:	f8 4f       	sbci	r31, 0xF8	; 248
    57ee:	70 e0       	ldi	r23, 0x00	; 0
    57f0:	cb 01       	movw	r24, r22
    57f2:	88 0f       	add	r24, r24
    57f4:	99 1f       	adc	r25, r25
    57f6:	88 0f       	add	r24, r24
    57f8:	99 1f       	adc	r25, r25
    57fa:	86 0f       	add	r24, r22
    57fc:	97 1f       	adc	r25, r23
    57fe:	82 0f       	add	r24, r18
    5800:	93 1f       	adc	r25, r19
    5802:	88 0f       	add	r24, r24
    5804:	99 1f       	adc	r25, r25
    5806:	80 56       	subi	r24, 0x60	; 96
    5808:	99 4f       	sbci	r25, 0xF9	; 249
    580a:	50 e0       	ldi	r21, 0x00	; 0
    580c:	da 01       	movw	r26, r20
    580e:	aa 0f       	add	r26, r26
    5810:	bb 1f       	adc	r27, r27
    5812:	aa 0f       	add	r26, r26
    5814:	bb 1f       	adc	r27, r27
    5816:	a4 0f       	add	r26, r20
    5818:	b5 1f       	adc	r27, r21
    581a:	a2 0f       	add	r26, r18
    581c:	b3 1f       	adc	r27, r19
    581e:	aa 0f       	add	r26, r26
    5820:	bb 1f       	adc	r27, r27
    5822:	a1 5f       	subi	r26, 0xF1	; 241
    5824:	b9 4f       	sbci	r27, 0xF9	; 249
    5826:	ec 01       	movw	r28, r24
    5828:	88 81       	ld	r24, Y
    582a:	99 81       	ldd	r25, Y+1	; 0x01
    582c:	4d 91       	ld	r20, X+
    582e:	5c 91       	ld	r21, X
    5830:	84 0f       	add	r24, r20
    5832:	95 1f       	adc	r25, r21
    5834:	96 95       	lsr	r25
    5836:	87 95       	ror	r24
    5838:	91 83       	std	Z+1, r25	; 0x01
    583a:	80 83       	st	Z, r24
				Config.RX_Min[ActiveRXIndex][i] = RX_MIN_raw[ActiveRXIndex][i];
    583c:	40 91 b8 05 	lds	r20, 0x05B8
    5840:	80 91 b8 05 	lds	r24, 0x05B8
    5844:	50 e0       	ldi	r21, 0x00	; 0
    5846:	fa 01       	movw	r30, r20
    5848:	ee 0f       	add	r30, r30
    584a:	ff 1f       	adc	r31, r31
    584c:	ee 0f       	add	r30, r30
    584e:	ff 1f       	adc	r31, r31
    5850:	e4 0f       	add	r30, r20
    5852:	f5 1f       	adc	r31, r21
    5854:	e2 0f       	add	r30, r18
    5856:	f3 1f       	adc	r31, r19
    5858:	ee 0f       	add	r30, r30
    585a:	ff 1f       	adc	r31, r31
    585c:	e0 5a       	subi	r30, 0xA0	; 160
    585e:	f8 4f       	sbci	r31, 0xF8	; 248
    5860:	90 e0       	ldi	r25, 0x00	; 0
    5862:	dc 01       	movw	r26, r24
    5864:	aa 0f       	add	r26, r26
    5866:	bb 1f       	adc	r27, r27
    5868:	aa 0f       	add	r26, r26
    586a:	bb 1f       	adc	r27, r27
    586c:	a8 0f       	add	r26, r24
    586e:	b9 1f       	adc	r27, r25
    5870:	a2 0f       	add	r26, r18
    5872:	b3 1f       	adc	r27, r19
    5874:	aa 0f       	add	r26, r26
    5876:	bb 1f       	adc	r27, r27
    5878:	a0 56       	subi	r26, 0x60	; 96
    587a:	b9 4f       	sbci	r27, 0xF9	; 249
    587c:	8d 91       	ld	r24, X+
    587e:	9c 91       	ld	r25, X
    5880:	91 83       	std	Z+1, r25	; 0x01
    5882:	80 83       	st	Z, r24
				Config.RX_DiV_Value[ActiveRXIndex][i] = ((RX_MAX_raw[ActiveRXIndex][i] - RX_MIN_raw[ActiveRXIndex][i]) / 1000);
    5884:	80 91 b8 05 	lds	r24, 0x05B8
    5888:	60 91 b8 05 	lds	r22, 0x05B8
    588c:	40 91 b8 05 	lds	r20, 0x05B8
    5890:	90 e0       	ldi	r25, 0x00	; 0
    5892:	fc 01       	movw	r30, r24
    5894:	ee 0f       	add	r30, r30
    5896:	ff 1f       	adc	r31, r31
    5898:	ee 0f       	add	r30, r30
    589a:	ff 1f       	adc	r31, r31
    589c:	e8 0f       	add	r30, r24
    589e:	f9 1f       	adc	r31, r25
    58a0:	e2 0f       	add	r30, r18
    58a2:	f3 1f       	adc	r31, r19
    58a4:	ea 57       	subi	r30, 0x7A	; 122
    58a6:	f8 4f       	sbci	r31, 0xF8	; 248
    58a8:	70 e0       	ldi	r23, 0x00	; 0
    58aa:	cb 01       	movw	r24, r22
    58ac:	88 0f       	add	r24, r24
    58ae:	99 1f       	adc	r25, r25
    58b0:	88 0f       	add	r24, r24
    58b2:	99 1f       	adc	r25, r25
    58b4:	86 0f       	add	r24, r22
    58b6:	97 1f       	adc	r25, r23
    58b8:	82 0f       	add	r24, r18
    58ba:	93 1f       	adc	r25, r19
    58bc:	88 0f       	add	r24, r24
    58be:	99 1f       	adc	r25, r25
    58c0:	81 5f       	subi	r24, 0xF1	; 241
    58c2:	99 4f       	sbci	r25, 0xF9	; 249
    58c4:	50 e0       	ldi	r21, 0x00	; 0
    58c6:	da 01       	movw	r26, r20
    58c8:	aa 0f       	add	r26, r26
    58ca:	bb 1f       	adc	r27, r27
    58cc:	aa 0f       	add	r26, r26
    58ce:	bb 1f       	adc	r27, r27
    58d0:	a4 0f       	add	r26, r20
    58d2:	b5 1f       	adc	r27, r21
    58d4:	a2 0f       	add	r26, r18
    58d6:	b3 1f       	adc	r27, r19
    58d8:	aa 0f       	add	r26, r26
    58da:	bb 1f       	adc	r27, r27
    58dc:	a0 56       	subi	r26, 0x60	; 96
    58de:	b9 4f       	sbci	r27, 0xF9	; 249
    58e0:	ec 01       	movw	r28, r24
    58e2:	88 81       	ld	r24, Y
    58e4:	99 81       	ldd	r25, Y+1	; 0x01
    58e6:	4d 91       	ld	r20, X+
    58e8:	5c 91       	ld	r21, X
    58ea:	11 97       	sbiw	r26, 0x01	; 1
    58ec:	84 1b       	sub	r24, r20
    58ee:	95 0b       	sbc	r25, r21
    58f0:	b8 01       	movw	r22, r16
    58f2:	0e 94 2c 39 	call	0x7258	; 0x7258 <__udivmodhi4>
    58f6:	60 83       	st	Z, r22
    58f8:	2f 5f       	subi	r18, 0xFF	; 255
    58fa:	3f 4f       	sbci	r19, 0xFF	; 255
	if (KEY4)
	{
		if (!bError)
		{
			// Save config
			for (i = 0; i < RXChannels; i++)
    58fc:	25 30       	cpi	r18, 0x05	; 5
    58fe:	31 05       	cpc	r19, r1
    5900:	09 f0       	breq	.+2      	; 0x5904 <_hStickCentering+0x184>
    5902:	61 cf       	rjmp	.-318    	; 0x57c6 <_hStickCentering+0x46>
				Config.RX_Min[ActiveRXIndex][i] = RX_MIN_raw[ActiveRXIndex][i];
				Config.RX_DiV_Value[ActiveRXIndex][i] = ((RX_MAX_raw[ActiveRXIndex][i] - RX_MIN_raw[ActiveRXIndex][i]) / 1000);
				
			}		
			
			Config.IsCalibrated= (Config.IsCalibrated | (1 << ActiveRXIndex));	// either 0b00000001 or 0b00000010
    5904:	20 91 b8 05 	lds	r18, 0x05B8
    5908:	81 e0       	ldi	r24, 0x01	; 1
    590a:	90 e0       	ldi	r25, 0x00	; 0
    590c:	02 c0       	rjmp	.+4      	; 0x5912 <_hStickCentering+0x192>
    590e:	88 0f       	add	r24, r24
    5910:	99 1f       	adc	r25, r25
    5912:	2a 95       	dec	r18
    5914:	e2 f7       	brpl	.-8      	; 0x590e <_hStickCentering+0x18e>
    5916:	20 91 da 06 	lds	r18, 0x06DA
    591a:	28 2b       	or	r18, r24
    591c:	e9 ed       	ldi	r30, 0xD9	; 217
    591e:	f6 e0       	ldi	r31, 0x06	; 6
    5920:	21 83       	std	Z+1, r18	; 0x01
			Save_Config_to_EEPROM();
    5922:	0e 94 c3 0f 	call	0x1f86	; 0x1f86 <Save_Config_to_EEPROM>
    5926:	05 c0       	rjmp	.+10     	; 0x5932 <_hStickCentering+0x1b2>
		}
		else
		{
			Beeper_Beep(BEEP_ERROR,3);	
    5928:	88 ec       	ldi	r24, 0xC8	; 200
    592a:	90 e0       	ldi	r25, 0x00	; 0
    592c:	63 e0       	ldi	r22, 0x03	; 3
    592e:	0e 94 8c 0b 	call	0x1718	; 0x1718 <Beeper_Beep>
		}
		
	}
	
	if (KEY2)
    5932:	80 91 a8 05 	lds	r24, 0x05A8
    5936:	86 ff       	sbrs	r24, 6
    5938:	04 c0       	rjmp	.+8      	; 0x5942 <_hStickCentering+0x1c2>
	{
		RX_StickCenterCalibrationInit(ActiveRXIndex);				
    593a:	80 91 b8 05 	lds	r24, 0x05B8
    593e:	0e 94 b5 26 	call	0x4d6a	; 0x4d6a <RX_StickCenterCalibrationInit>
	}
	
	bError = false;
    5942:	10 92 10 08 	sts	0x0810, r1
	RX_StickCenterCalibration(ActiveRXIndex);
    5946:	80 91 b8 05 	lds	r24, 0x05B8
    594a:	0e 94 5c 27 	call	0x4eb8	; 0x4eb8 <RX_StickCenterCalibration>
    594e:	c0 e0       	ldi	r28, 0x00	; 0
    5950:	d0 e0       	ldi	r29, 0x00	; 0
		else
		{
			if ((RX_MAX_raw[ActiveRXIndex][i]< RX_MIN_raw[ActiveRXIndex][i]) || (RX_MIN_raw[ActiveRXIndex][i]==0))  // RX_MIN_raw[i]=0 if the Remote is OFF when entering the test
			{
				LCD_WriteString_P(strErr);	
				bError = TRUE;
    5952:	11 e0       	ldi	r17, 0x01	; 1
}



BOOL bError; 
void _hStickCentering()
    5954:	ce 01       	movw	r24, r28
	
	bError = false;
	RX_StickCenterCalibration(ActiveRXIndex);
	for (uint8_t i = 0; i < RXChannels; i++)
	{
		LCD_SetPos(i+1, 30);
    5956:	8f 5f       	subi	r24, 0xFF	; 255
    5958:	6e e1       	ldi	r22, 0x1E	; 30
    595a:	0e 94 03 0c 	call	0x1806	; 0x1806 <LCD_SetPos>
		utoa(RX_MAX_raw[ActiveRXIndex][i], sXDeg, 10);
    595e:	80 91 b8 05 	lds	r24, 0x05B8
    5962:	90 e0       	ldi	r25, 0x00	; 0
    5964:	fc 01       	movw	r30, r24
    5966:	ee 0f       	add	r30, r30
    5968:	ff 1f       	adc	r31, r31
    596a:	ee 0f       	add	r30, r30
    596c:	ff 1f       	adc	r31, r31
    596e:	e8 0f       	add	r30, r24
    5970:	f9 1f       	adc	r31, r25
    5972:	ec 0f       	add	r30, r28
    5974:	fd 1f       	adc	r31, r29
    5976:	ee 0f       	add	r30, r30
    5978:	ff 1f       	adc	r31, r31
    597a:	e1 5f       	subi	r30, 0xF1	; 241
    597c:	f9 4f       	sbci	r31, 0xF9	; 249
    597e:	80 81       	ld	r24, Z
    5980:	91 81       	ldd	r25, Z+1	; 0x01
    5982:	68 ed       	ldi	r22, 0xD8	; 216
    5984:	75 e0       	ldi	r23, 0x05	; 5
    5986:	4a e0       	ldi	r20, 0x0A	; 10
    5988:	50 e0       	ldi	r21, 0x00	; 0
    598a:	0e 94 cc 39 	call	0x7398	; 0x7398 <utoa>
		LCD_WriteString(sXDeg);
    598e:	88 ed       	ldi	r24, 0xD8	; 216
    5990:	95 e0       	ldi	r25, 0x05	; 5
    5992:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <LCD_WriteString>
		LCD_WriteString_P(strSPC1);
    5996:	8d ee       	ldi	r24, 0xED	; 237
    5998:	9c e0       	ldi	r25, 0x0C	; 12
    599a:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <LCD_WriteString_P>
		utoa(RX_MIN_raw[ActiveRXIndex][i], sXDeg, 10);
    599e:	80 91 b8 05 	lds	r24, 0x05B8
    59a2:	90 e0       	ldi	r25, 0x00	; 0
    59a4:	fc 01       	movw	r30, r24
    59a6:	ee 0f       	add	r30, r30
    59a8:	ff 1f       	adc	r31, r31
    59aa:	ee 0f       	add	r30, r30
    59ac:	ff 1f       	adc	r31, r31
    59ae:	e8 0f       	add	r30, r24
    59b0:	f9 1f       	adc	r31, r25
    59b2:	ec 0f       	add	r30, r28
    59b4:	fd 1f       	adc	r31, r29
    59b6:	ee 0f       	add	r30, r30
    59b8:	ff 1f       	adc	r31, r31
    59ba:	e0 56       	subi	r30, 0x60	; 96
    59bc:	f9 4f       	sbci	r31, 0xF9	; 249
    59be:	80 81       	ld	r24, Z
    59c0:	91 81       	ldd	r25, Z+1	; 0x01
    59c2:	68 ed       	ldi	r22, 0xD8	; 216
    59c4:	75 e0       	ldi	r23, 0x05	; 5
    59c6:	4a e0       	ldi	r20, 0x0A	; 10
    59c8:	50 e0       	ldi	r21, 0x00	; 0
    59ca:	0e 94 cc 39 	call	0x7398	; 0x7398 <utoa>
		LCD_WriteString(sXDeg);
    59ce:	88 ed       	ldi	r24, 0xD8	; 216
    59d0:	95 e0       	ldi	r25, 0x05	; 5
    59d2:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <LCD_WriteString>
		if ((ActiveRXIndex==0) && (i == RXChannel_AUX))
    59d6:	80 91 b8 05 	lds	r24, 0x05B8
    59da:	88 23       	and	r24, r24
    59dc:	29 f4       	brne	.+10     	; 0x59e8 <_hStickCentering+0x268>
    59de:	c4 30       	cpi	r28, 0x04	; 4
    59e0:	19 f4       	brne	.+6      	; 0x59e8 <_hStickCentering+0x268>
		{
			LCD_WriteString_P(PSTR("NA"));
    59e2:	88 ef       	ldi	r24, 0xF8	; 248
    59e4:	9c e0       	ldi	r25, 0x0C	; 12
    59e6:	45 c0       	rjmp	.+138    	; 0x5a72 <_hStickCentering+0x2f2>
		}
		else
		{
			if ((RX_MAX_raw[ActiveRXIndex][i]< RX_MIN_raw[ActiveRXIndex][i]) || (RX_MIN_raw[ActiveRXIndex][i]==0))  // RX_MIN_raw[i]=0 if the Remote is OFF when entering the test
    59e8:	20 91 b8 05 	lds	r18, 0x05B8
    59ec:	80 91 b8 05 	lds	r24, 0x05B8
    59f0:	30 e0       	ldi	r19, 0x00	; 0
    59f2:	d9 01       	movw	r26, r18
    59f4:	aa 0f       	add	r26, r26
    59f6:	bb 1f       	adc	r27, r27
    59f8:	aa 0f       	add	r26, r26
    59fa:	bb 1f       	adc	r27, r27
    59fc:	a2 0f       	add	r26, r18
    59fe:	b3 1f       	adc	r27, r19
    5a00:	ac 0f       	add	r26, r28
    5a02:	bd 1f       	adc	r27, r29
    5a04:	aa 0f       	add	r26, r26
    5a06:	bb 1f       	adc	r27, r27
    5a08:	a1 5f       	subi	r26, 0xF1	; 241
    5a0a:	b9 4f       	sbci	r27, 0xF9	; 249
    5a0c:	90 e0       	ldi	r25, 0x00	; 0
    5a0e:	fc 01       	movw	r30, r24
    5a10:	ee 0f       	add	r30, r30
    5a12:	ff 1f       	adc	r31, r31
    5a14:	ee 0f       	add	r30, r30
    5a16:	ff 1f       	adc	r31, r31
    5a18:	e8 0f       	add	r30, r24
    5a1a:	f9 1f       	adc	r31, r25
    5a1c:	ec 0f       	add	r30, r28
    5a1e:	fd 1f       	adc	r31, r29
    5a20:	ee 0f       	add	r30, r30
    5a22:	ff 1f       	adc	r31, r31
    5a24:	e0 56       	subi	r30, 0x60	; 96
    5a26:	f9 4f       	sbci	r31, 0xF9	; 249
    5a28:	2d 91       	ld	r18, X+
    5a2a:	3c 91       	ld	r19, X
    5a2c:	11 97       	sbiw	r26, 0x01	; 1
    5a2e:	80 81       	ld	r24, Z
    5a30:	91 81       	ldd	r25, Z+1	; 0x01
    5a32:	28 17       	cp	r18, r24
    5a34:	39 07       	cpc	r19, r25
    5a36:	a0 f0       	brcs	.+40     	; 0x5a60 <_hStickCentering+0x2e0>
    5a38:	80 91 b8 05 	lds	r24, 0x05B8
    5a3c:	90 e0       	ldi	r25, 0x00	; 0
    5a3e:	fc 01       	movw	r30, r24
    5a40:	ee 0f       	add	r30, r30
    5a42:	ff 1f       	adc	r31, r31
    5a44:	ee 0f       	add	r30, r30
    5a46:	ff 1f       	adc	r31, r31
    5a48:	e8 0f       	add	r30, r24
    5a4a:	f9 1f       	adc	r31, r25
    5a4c:	ec 0f       	add	r30, r28
    5a4e:	fd 1f       	adc	r31, r29
    5a50:	ee 0f       	add	r30, r30
    5a52:	ff 1f       	adc	r31, r31
    5a54:	e0 56       	subi	r30, 0x60	; 96
    5a56:	f9 4f       	sbci	r31, 0xF9	; 249
    5a58:	80 81       	ld	r24, Z
    5a5a:	91 81       	ldd	r25, Z+1	; 0x01
    5a5c:	00 97       	sbiw	r24, 0x00	; 0
    5a5e:	39 f4       	brne	.+14     	; 0x5a6e <_hStickCentering+0x2ee>
			{
				LCD_WriteString_P(strErr);	
    5a60:	8f ee       	ldi	r24, 0xEF	; 239
    5a62:	9c e0       	ldi	r25, 0x0C	; 12
    5a64:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <LCD_WriteString_P>
				bError = TRUE;
    5a68:	10 93 10 08 	sts	0x0810, r17
    5a6c:	04 c0       	rjmp	.+8      	; 0x5a76 <_hStickCentering+0x2f6>
			}
			else
			{
				LCD_WriteString_P(strSPC4);	
    5a6e:	83 ef       	ldi	r24, 0xF3	; 243
    5a70:	9c e0       	ldi	r25, 0x0C	; 12
    5a72:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <LCD_WriteString_P>
    5a76:	21 96       	adiw	r28, 0x01	; 1
		RX_StickCenterCalibrationInit(ActiveRXIndex);				
	}
	
	bError = false;
	RX_StickCenterCalibration(ActiveRXIndex);
	for (uint8_t i = 0; i < RXChannels; i++)
    5a78:	c5 30       	cpi	r28, 0x05	; 5
    5a7a:	d1 05       	cpc	r29, r1
    5a7c:	09 f0       	breq	.+2      	; 0x5a80 <_hStickCentering+0x300>
    5a7e:	6a cf       	rjmp	.-300    	; 0x5954 <_hStickCentering+0x1d4>
			}
		}	
	}
	

	_helper_DisplayRXStatus(6);
    5a80:	86 e0       	ldi	r24, 0x06	; 6
    5a82:	0e 94 87 2b 	call	0x570e	; 0x570e <_helper_DisplayRXStatus>
}
    5a86:	df 91       	pop	r29
    5a88:	cf 91       	pop	r28
    5a8a:	1f 91       	pop	r17
    5a8c:	0f 91       	pop	r16
    5a8e:	08 95       	ret

00005a90 <_hReceiverTest>:
	LCD_SetPos(6, 48);
	LCD_WriteValue_double(6,48,Sensor_GetBattery(),false);
}

void _hReceiverTest()
{
    5a90:	0f 93       	push	r16
    5a92:	1f 93       	push	r17
    5a94:	cf 93       	push	r28
    5a96:	df 93       	push	r29
	UIEnableStickCommands=false; // you cannot use sticks here. for arming or as buttons.
    5a98:	10 92 d2 05 	sts	0x05D2, r1
	
	RX_CopyLatestReceiverValues();
    5a9c:	0e 94 5b 26 	call	0x4cb6	; 0x4cb6 <RX_CopyLatestReceiverValues>
    5aa0:	c0 e0       	ldi	r28, 0x00	; 0
    5aa2:	d0 e0       	ldi	r29, 0x00	; 0
    5aa4:	ce 01       	movw	r24, r28
    5aa6:	8f 5f       	subi	r24, 0xFF	; 255
    5aa8:	18 2f       	mov	r17, r24
		
		
	for (uint8_t i = 0; i < RXChannels; i++)
	{
		LCD_SetPos(i+1, 24);
    5aaa:	68 e1       	ldi	r22, 0x18	; 24
    5aac:	0e 94 03 0c 	call	0x1806	; 0x1806 <LCD_SetPos>
			
		//itoa(RX_Latest[ActiveRXIndex][i], sXDeg, 10);
		LCD_WriteValue(i+1,36,RX_Latest[0][i],5,(!IS_TX1_GOOD));
    5ab0:	fe 01       	movw	r30, r28
    5ab2:	ee 0f       	add	r30, r30
    5ab4:	ff 1f       	adc	r31, r31
    5ab6:	e0 51       	subi	r30, 0x10	; 16
    5ab8:	fa 4f       	sbci	r31, 0xFA	; 250
    5aba:	40 81       	ld	r20, Z
    5abc:	51 81       	ldd	r21, Z+1	; 0x01
    5abe:	80 91 c5 07 	lds	r24, 0x07C5
    5ac2:	90 e0       	ldi	r25, 0x00	; 0
    5ac4:	8f 70       	andi	r24, 0x0F	; 15
    5ac6:	90 70       	andi	r25, 0x00	; 0
    5ac8:	01 e0       	ldi	r16, 0x01	; 1
    5aca:	00 97       	sbiw	r24, 0x00	; 0
    5acc:	09 f4       	brne	.+2      	; 0x5ad0 <_hReceiverTest+0x40>
    5ace:	00 e0       	ldi	r16, 0x00	; 0
    5ad0:	81 2f       	mov	r24, r17
    5ad2:	64 e2       	ldi	r22, 0x24	; 36
    5ad4:	25 e0       	ldi	r18, 0x05	; 5
    5ad6:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <LCD_WriteValue>
		LCD_WriteValue(i+1,84,RX_Latest[1][i],5,(!IS_TX2_GOOD));
    5ada:	fe 01       	movw	r30, r28
    5adc:	ee 0f       	add	r30, r30
    5ade:	ff 1f       	adc	r31, r31
    5ae0:	e6 50       	subi	r30, 0x06	; 6
    5ae2:	fa 4f       	sbci	r31, 0xFA	; 250
    5ae4:	40 81       	ld	r20, Z
    5ae6:	51 81       	ldd	r21, Z+1	; 0x01
    5ae8:	80 91 c5 07 	lds	r24, 0x07C5
    5aec:	80 7f       	andi	r24, 0xF0	; 240
    5aee:	01 e0       	ldi	r16, 0x01	; 1
    5af0:	09 f4       	brne	.+2      	; 0x5af4 <_hReceiverTest+0x64>
    5af2:	00 e0       	ldi	r16, 0x00	; 0
    5af4:	81 2f       	mov	r24, r17
    5af6:	64 e5       	ldi	r22, 0x54	; 84
    5af8:	25 e0       	ldi	r18, 0x05	; 5
    5afa:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <LCD_WriteValue>
    5afe:	21 96       	adiw	r28, 0x01	; 1
	UIEnableStickCommands=false; // you cannot use sticks here. for arming or as buttons.
	
	RX_CopyLatestReceiverValues();
		
		
	for (uint8_t i = 0; i < RXChannels; i++)
    5b00:	c5 30       	cpi	r28, 0x05	; 5
    5b02:	d1 05       	cpc	r29, r1
    5b04:	79 f6       	brne	.-98     	; 0x5aa4 <_hReceiverTest+0x14>
		LCD_WriteValue(i+1,84,RX_Latest[1][i],5,(!IS_TX2_GOOD));
		
	}			
	
	
	_helper_DisplayRXStatus(6);
    5b06:	86 e0       	ldi	r24, 0x06	; 6
    5b08:	0e 94 87 2b 	call	0x570e	; 0x570e <_helper_DisplayRXStatus>
	
}
    5b0c:	df 91       	pop	r29
    5b0e:	cf 91       	pop	r28
    5b10:	1f 91       	pop	r17
    5b12:	0f 91       	pop	r16
    5b14:	08 95       	ret

00005b16 <_helper_Words>:
	
}


void _helper_Words (const int8_t row, const int8_t col,  const BOOL LCDReverse, const bool Condition, PGM_P TrueString, PGM_P FalseString, int8_t Len)
{
    5b16:	cf 92       	push	r12
    5b18:	ef 92       	push	r14
    5b1a:	ff 92       	push	r15
    5b1c:	0f 93       	push	r16
    5b1e:	1f 93       	push	r17
    5b20:	94 2f       	mov	r25, r20
    5b22:	32 2f       	mov	r19, r18
    5b24:	2c 2d       	mov	r18, r12
	if (Condition== TRUE)
    5b26:	33 23       	and	r19, r19
    5b28:	11 f0       	breq	.+4      	; 0x5b2e <_helper_Words+0x18>
	{
		LCD_WriteString_Pex(row,col,TrueString,Len,LCDReverse);
    5b2a:	a8 01       	movw	r20, r16
    5b2c:	01 c0       	rjmp	.+2      	; 0x5b30 <_helper_Words+0x1a>
	}
	else
	{
		LCD_WriteString_Pex(row,col,FalseString,Len,LCDReverse);
    5b2e:	a7 01       	movw	r20, r14
    5b30:	09 2f       	mov	r16, r25
    5b32:	0e 94 88 0d 	call	0x1b10	; 0x1b10 <LCD_WriteString_Pex>
	}
}
    5b36:	1f 91       	pop	r17
    5b38:	0f 91       	pop	r16
    5b3a:	ff 90       	pop	r15
    5b3c:	ef 90       	pop	r14
    5b3e:	cf 90       	pop	r12
    5b40:	08 95       	ret

00005b42 <Menu_LoadPage>:

/*
//	Put screen into CurrentPage ==> MemoryScreen
*/
void Menu_LoadPage(const uint8_t pageIndex)
{
    5b42:	1f 93       	push	r17
    5b44:	18 2f       	mov	r17, r24
	memcpy_P(&currentPage, &pages[pageIndex], sizeof(currentPage));
    5b46:	66 e0       	ldi	r22, 0x06	; 6
    5b48:	86 9f       	mul	r24, r22
    5b4a:	b0 01       	movw	r22, r0
    5b4c:	11 24       	eor	r1, r1
    5b4e:	6a 5a       	subi	r22, 0xAA	; 170
    5b50:	72 4f       	sbci	r23, 0xF2	; 242
    5b52:	80 e3       	ldi	r24, 0x30	; 48
    5b54:	95 e0       	ldi	r25, 0x05	; 5
    5b56:	46 e0       	ldi	r20, 0x06	; 6
    5b58:	50 e0       	ldi	r21, 0x00	; 0
    5b5a:	0e 94 7e 39 	call	0x72fc	; 0x72fc <memcpy_P>
	page = pageIndex;
    5b5e:	10 93 2d 05 	sts	0x052D, r17
}
    5b62:	1f 91       	pop	r17
    5b64:	08 95       	ret

00005b66 <_hFactoryReset>:
		//LCD_WriteValue(4,48, MotorOut[3],9,false);
	}
}
void _hFactoryReset()
{
	if (IS_INIT)
    5b66:	80 91 a8 05 	lds	r24, 0x05A8
    5b6a:	80 ff       	sbrs	r24, 0
    5b6c:	09 c0       	rjmp	.+18     	; 0x5b80 <_hFactoryReset+0x1a>
	{
		LCD_SetPos(3, 18);
    5b6e:	83 e0       	ldi	r24, 0x03	; 3
    5b70:	62 e1       	ldi	r22, 0x12	; 18
    5b72:	0e 94 03 0c 	call	0x1806	; 0x1806 <LCD_SetPos>
		LCD_WriteString_P(strAreYouSure);
    5b76:	8d ee       	ldi	r24, 0xED	; 237
    5b78:	9b e0       	ldi	r25, 0x0B	; 11
    5b7a:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <LCD_WriteString_P>
    5b7e:	08 95       	ret
	}
	else if (KEY4)	// Yes
    5b80:	84 ff       	sbrs	r24, 4
    5b82:	05 c0       	rjmp	.+10     	; 0x5b8e <_hFactoryReset+0x28>
	{
		Save_Default_Config_to_EEPROM();
    5b84:	0e 94 d3 0f 	call	0x1fa6	; 0x1fa6 <Save_Default_Config_to_EEPROM>
		//RST_CTRL
		Menu_LoadPage(PAGE_RESTART);
    5b88:	84 e0       	ldi	r24, 0x04	; 4
    5b8a:	0e 94 a1 2d 	call	0x5b42	; 0x5b42 <Menu_LoadPage>
    5b8e:	08 95       	ret

00005b90 <_hESCCalibration>:
	
}

void _hESCCalibration()
{
	NOKEYRETURN
    5b90:	80 91 a8 05 	lds	r24, 0x05A8
    5b94:	88 23       	and	r24, r24
    5b96:	c1 f0       	breq	.+48     	; 0x5bc8 <_hESCCalibration+0x38>
	
	if (KEY4)
    5b98:	84 ff       	sbrs	r24, 4
    5b9a:	16 c0       	rjmp	.+44     	; 0x5bc8 <_hESCCalibration+0x38>
	{
		if ((Config.IsCalibrated & CALIBRATED_SENSOR) && ((Config.IsCalibrated & CALIBRATED_Stick_SECONDARY)==CALIBRATED_Stick_SECONDARY))
    5b9c:	80 91 da 06 	lds	r24, 0x06DA
		LCD_WriteValue(i,48,Config.Sensor_zero[i],5,false);
	}	
	
}

void _hESCCalibration()
    5ba0:	86 70       	andi	r24, 0x06	; 6
{
	NOKEYRETURN
	
	if (KEY4)
	{
		if ((Config.IsCalibrated & CALIBRATED_SENSOR) && ((Config.IsCalibrated & CALIBRATED_Stick_SECONDARY)==CALIBRATED_Stick_SECONDARY))
    5ba2:	86 30       	cpi	r24, 0x06	; 6
    5ba4:	61 f4       	brne	.+24     	; 0x5bbe <_hESCCalibration+0x2e>
		{
			SystemActions = SYS_ACT_DISARM;
    5ba6:	82 e0       	ldi	r24, 0x02	; 2
    5ba8:	80 93 3b 05 	sts	0x053B, r24
			Config.IsESCCalibration=ESCCalibration_ON;
    5bac:	81 e0       	ldi	r24, 0x01	; 1
    5bae:	80 93 df 06 	sts	0x06DF, r24
			Save_Config_to_EEPROM();
    5bb2:	0e 94 c3 0f 	call	0x1f86	; 0x1f86 <Save_Config_to_EEPROM>
			Menu_LoadPage(PAGE_RESTART);
    5bb6:	84 e0       	ldi	r24, 0x04	; 4
    5bb8:	0e 94 a1 2d 	call	0x5b42	; 0x5b42 <Menu_LoadPage>
			return;
    5bbc:	08 95       	ret
		}
		else
		{ //...flash as error
			LED_FlashOrangeLED(LED_SHORT_TOGGLE,2);
    5bbe:	8e e1       	ldi	r24, 0x1E	; 30
    5bc0:	90 e0       	ldi	r25, 0x00	; 0
    5bc2:	62 e0       	ldi	r22, 0x02	; 2
    5bc4:	0e 94 8e 0e 	call	0x1d1c	; 0x1d1c <LED_FlashOrangeLED>
    5bc8:	08 95       	ret

00005bca <_hHomeArmed>:
}

void _hHomeArmed()
{
	
	if (IS_INIT)	
    5bca:	80 91 a8 05 	lds	r24, 0x05A8
    5bce:	80 ff       	sbrs	r24, 0
    5bd0:	10 c0       	rjmp	.+32     	; 0x5bf2 <_hHomeArmed+0x28>
	{
		LCD_SelectFont (&font12x16);
    5bd2:	89 e4       	ldi	r24, 0x49	; 73
    5bd4:	91 e0       	ldi	r25, 0x01	; 1
    5bd6:	0e 94 57 0e 	call	0x1cae	; 0x1cae <LCD_SelectFont>
		LCD_SetPos(0,0);
    5bda:	80 e0       	ldi	r24, 0x00	; 0
    5bdc:	60 e0       	ldi	r22, 0x00	; 0
    5bde:	0e 94 03 0c 	call	0x1806	; 0x1806 <LCD_SetPos>
		LCD_WriteString_P(strARMED);
    5be2:	8b ef       	ldi	r24, 0xFB	; 251
    5be4:	9c e0       	ldi	r25, 0x0C	; 12
    5be6:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <LCD_WriteString_P>
		LCD_SelectFont (NULL);
    5bea:	80 e0       	ldi	r24, 0x00	; 0
    5bec:	90 e0       	ldi	r25, 0x00	; 0
    5bee:	0e 94 57 0e 	call	0x1cae	; 0x1cae <LCD_SelectFont>
	}
	
	
	if (KEY4)	// MENU
    5bf2:	80 91 a8 05 	lds	r24, 0x05A8
    5bf6:	84 ff       	sbrs	r24, 4
    5bf8:	03 c0       	rjmp	.+6      	; 0x5c00 <_hHomeArmed+0x36>
	{
		Menu_LoadPage(PAGE_MENU);
    5bfa:	81 e0       	ldi	r24, 0x01	; 1
    5bfc:	0e 94 a1 2d 	call	0x5b42	; 0x5b42 <Menu_LoadPage>
    5c00:	08 95       	ret

00005c02 <_hHomePage>:
}



void _hHomePage()
{
    5c02:	cf 92       	push	r12
    5c04:	ef 92       	push	r14
    5c06:	ff 92       	push	r15
    5c08:	0f 93       	push	r16
    5c0a:	1f 93       	push	r17
	
	if (IS_INIT)
    5c0c:	80 91 a8 05 	lds	r24, 0x05A8
    5c10:	80 ff       	sbrs	r24, 0
    5c12:	31 c0       	rjmp	.+98     	; 0x5c76 <_hHomePage+0x74>
	{
		// Version
		LCD_SetPos(0,0);
    5c14:	80 e0       	ldi	r24, 0x00	; 0
    5c16:	60 e0       	ldi	r22, 0x00	; 0
    5c18:	0e 94 03 0c 	call	0x1806	; 0x1806 <LCD_SetPos>
		LCD_WriteString_P(strVersionInfo);
    5c1c:	81 e0       	ldi	r24, 0x01	; 1
    5c1e:	9d e0       	ldi	r25, 0x0D	; 13
    5c20:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <LCD_WriteString_P>
		// Sensors
		_helper_DisplayBiStateText(5, 60, strOK, strErr, (Config.IsCalibrated & CALIBRATED_SENSOR),false);
    5c24:	80 91 da 06 	lds	r24, 0x06DA
    5c28:	01 e0       	ldi	r16, 0x01	; 1
    5c2a:	82 ff       	sbrs	r24, 2
    5c2c:	00 e0       	ldi	r16, 0x00	; 0
    5c2e:	85 e0       	ldi	r24, 0x05	; 5
    5c30:	6c e3       	ldi	r22, 0x3C	; 60
    5c32:	45 e1       	ldi	r20, 0x15	; 21
    5c34:	5d e0       	ldi	r21, 0x0D	; 13
    5c36:	2f ee       	ldi	r18, 0xEF	; 239
    5c38:	3c e0       	ldi	r19, 0x0C	; 12
    5c3a:	ee 24       	eor	r14, r14
    5c3c:	0e 94 52 2b 	call	0x56a4	; 0x56a4 <_helper_DisplayBiStateText>
		
		//Stick Centering & Calibration
		_helper_DisplayBiStateText(5, 102, str1, strX, (Config.IsCalibrated & CALIBRATED_Stick_PRIMARY),false);
    5c40:	00 91 da 06 	lds	r16, 0x06DA
    5c44:	10 e0       	ldi	r17, 0x00	; 0
    5c46:	01 70       	andi	r16, 0x01	; 1
    5c48:	10 70       	andi	r17, 0x00	; 0
    5c4a:	85 e0       	ldi	r24, 0x05	; 5
    5c4c:	66 e6       	ldi	r22, 0x66	; 102
    5c4e:	49 e1       	ldi	r20, 0x19	; 25
    5c50:	5d e0       	ldi	r21, 0x0D	; 13
    5c52:	2b e1       	ldi	r18, 0x1B	; 27
    5c54:	3d e0       	ldi	r19, 0x0D	; 13
    5c56:	0e 94 52 2b 	call	0x56a4	; 0x56a4 <_helper_DisplayBiStateText>
		
		_helper_DisplayBiStateText(5, 114, str2, strX, (Config.IsCalibrated & CALIBRATED_Stick_SECONDARY),false);
    5c5a:	80 91 da 06 	lds	r24, 0x06DA
    5c5e:	01 e0       	ldi	r16, 0x01	; 1
    5c60:	81 ff       	sbrs	r24, 1
    5c62:	00 e0       	ldi	r16, 0x00	; 0
    5c64:	85 e0       	ldi	r24, 0x05	; 5
    5c66:	62 e7       	ldi	r22, 0x72	; 114
    5c68:	4d e1       	ldi	r20, 0x1D	; 29
    5c6a:	5d e0       	ldi	r21, 0x0D	; 13
    5c6c:	2b e1       	ldi	r18, 0x1B	; 27
    5c6e:	3d e0       	ldi	r19, 0x0D	; 13
    5c70:	ee 24       	eor	r14, r14
    5c72:	0e 94 52 2b 	call	0x56a4	; 0x56a4 <_helper_DisplayBiStateText>
		
		
	}
	
	if (KEY4)	// MENU
    5c76:	80 91 a8 05 	lds	r24, 0x05A8
    5c7a:	84 ff       	sbrs	r24, 4
    5c7c:	04 c0       	rjmp	.+8      	; 0x5c86 <_hHomePage+0x84>
	{
		Menu_LoadPage(PAGE_MENU);
    5c7e:	81 e0       	ldi	r24, 0x01	; 1
    5c80:	0e 94 a1 2d 	call	0x5b42	; 0x5b42 <Menu_LoadPage>
		return;
    5c84:	94 c0       	rjmp	.+296    	; 0x5dae <_hHomePage+0x1ac>
	}
	
	// Write Voltage
	//LCD_SetPos(2, 30);
	double volt = (double)(Sensor_GetBattery()/10.0f);
    5c86:	0e 94 b8 28 	call	0x5170	; 0x5170 <Sensor_GetBattery>
    5c8a:	9c 01       	movw	r18, r24
    5c8c:	b9 01       	movw	r22, r18
    5c8e:	88 27       	eor	r24, r24
    5c90:	77 fd       	sbrc	r23, 7
    5c92:	80 95       	com	r24
    5c94:	98 2f       	mov	r25, r24
    5c96:	0e 94 15 38 	call	0x702a	; 0x702a <__floatsisf>
    5c9a:	20 e0       	ldi	r18, 0x00	; 0
    5c9c:	30 e0       	ldi	r19, 0x00	; 0
    5c9e:	40 e2       	ldi	r20, 0x20	; 32
    5ca0:	51 e4       	ldi	r21, 0x41	; 65
    5ca2:	0e 94 7a 37 	call	0x6ef4	; 0x6ef4 <__divsf3>
    5ca6:	9b 01       	movw	r18, r22
    5ca8:	ac 01       	movw	r20, r24
	LCD_WriteValue_double_ex(2,36,volt,8,IS_SYS_ERR_VOLTAGE); // FIX: 8 to display 2 digits volt besides floating point
    5caa:	90 91 b5 06 	lds	r25, 0x06B5
    5cae:	92 70       	andi	r25, 0x02	; 2
    5cb0:	82 e0       	ldi	r24, 0x02	; 2
    5cb2:	64 e2       	ldi	r22, 0x24	; 36
    5cb4:	08 e0       	ldi	r16, 0x08	; 8
    5cb6:	e9 2e       	mov	r14, r25
    5cb8:	0e 94 ad 0d 	call	0x1b5a	; 0x1b5a <LCD_WriteValue_double_ex>
	//LCD_WriteValue(2,36,Sensor_GetBattery(),4,IS_SYS_ERR_VOLTAGE);
	LCD_SetPos (3,6);
    5cbc:	83 e0       	ldi	r24, 0x03	; 3
    5cbe:	66 e0       	ldi	r22, 0x06	; 6
    5cc0:	0e 94 03 0c 	call	0x1806	; 0x1806 <LCD_SetPos>
	if (nFlyingModes == FLYINGMODE_ACRO)
    5cc4:	80 91 08 06 	lds	r24, 0x0608
    5cc8:	81 30       	cpi	r24, 0x01	; 1
    5cca:	19 f4       	brne	.+6      	; 0x5cd2 <_hHomePage+0xd0>
	{
		LCD_WriteString_P(PSTR("ACRO  "));
    5ccc:	8f e4       	ldi	r24, 0x4F	; 79
    5cce:	9d e0       	ldi	r25, 0x0D	; 13
    5cd0:	09 c0       	rjmp	.+18     	; 0x5ce4 <_hHomePage+0xe2>
	}
	else if (nFlyingModes == FLYINGMODE_LEVEL)
    5cd2:	82 30       	cpi	r24, 0x02	; 2
    5cd4:	19 f4       	brne	.+6      	; 0x5cdc <_hHomePage+0xda>
	{
		LCD_WriteString_P(PSTR("STABLE"));
    5cd6:	88 e4       	ldi	r24, 0x48	; 72
    5cd8:	9d e0       	ldi	r25, 0x0D	; 13
    5cda:	04 c0       	rjmp	.+8      	; 0x5ce4 <_hHomePage+0xe2>
	}
	else if (nFlyingModes == FLYINGMODE_ALTHOLD)
    5cdc:	84 30       	cpi	r24, 0x04	; 4
    5cde:	21 f4       	brne	.+8      	; 0x5ce8 <_hHomePage+0xe6>
	{
		LCD_WriteString_P(PSTR("ALTHLD"));
    5ce0:	81 e4       	ldi	r24, 0x41	; 65
    5ce2:	9d e0       	ldi	r25, 0x0D	; 13
    5ce4:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <LCD_WriteString_P>
	}
	
	_helper_Words (3,48,  0,(Config.FrameType== FRAMETYPE_QUADCOPTER),PSTR("Quad"),PSTR("TRI "),5);
    5ce8:	21 e0       	ldi	r18, 0x01	; 1
    5cea:	80 91 e0 06 	lds	r24, 0x06E0
    5cee:	81 30       	cpi	r24, 0x01	; 1
    5cf0:	09 f0       	breq	.+2      	; 0x5cf4 <_hHomePage+0xf2>
    5cf2:	20 e0       	ldi	r18, 0x00	; 0
    5cf4:	83 e0       	ldi	r24, 0x03	; 3
    5cf6:	60 e3       	ldi	r22, 0x30	; 48
    5cf8:	40 e0       	ldi	r20, 0x00	; 0
    5cfa:	0c e3       	ldi	r16, 0x3C	; 60
    5cfc:	1d e0       	ldi	r17, 0x0D	; 13
    5cfe:	b7 e3       	ldi	r27, 0x37	; 55
    5d00:	eb 2e       	mov	r14, r27
    5d02:	bd e0       	ldi	r27, 0x0D	; 13
    5d04:	fb 2e       	mov	r15, r27
    5d06:	a5 e0       	ldi	r26, 0x05	; 5
    5d08:	ca 2e       	mov	r12, r26
    5d0a:	0e 94 8b 2d 	call	0x5b16	; 0x5b16 <_helper_Words>
	_helper_Words (3,84,0,(Config.RX_mode == RX_mode_BuddyMode),PSTR("Buddy"),PSTR("UART "),5);
    5d0e:	21 e0       	ldi	r18, 0x01	; 1
    5d10:	80 91 db 06 	lds	r24, 0x06DB
    5d14:	81 11       	cpse	r24, r1
    5d16:	20 e0       	ldi	r18, 0x00	; 0
    5d18:	83 e0       	ldi	r24, 0x03	; 3
    5d1a:	64 e5       	ldi	r22, 0x54	; 84
    5d1c:	40 e0       	ldi	r20, 0x00	; 0
    5d1e:	01 e3       	ldi	r16, 0x31	; 49
    5d20:	1d e0       	ldi	r17, 0x0D	; 13
    5d22:	fb e2       	ldi	r31, 0x2B	; 43
    5d24:	ef 2e       	mov	r14, r31
    5d26:	fd e0       	ldi	r31, 0x0D	; 13
    5d28:	ff 2e       	mov	r15, r31
    5d2a:	e5 e0       	ldi	r30, 0x05	; 5
    5d2c:	ce 2e       	mov	r12, r30
    5d2e:	0e 94 8b 2d 	call	0x5b16	; 0x5b16 <_helper_Words>
	
	_helper_DisplayRXStatus(5);
    5d32:	85 e0       	ldi	r24, 0x05	; 5
    5d34:	0e 94 87 2b 	call	0x570e	; 0x570e <_helper_DisplayRXStatus>
	
		
	///////// Flying Mode
	LCD_SetPos (6,24);
    5d38:	86 e0       	ldi	r24, 0x06	; 6
    5d3a:	68 e1       	ldi	r22, 0x18	; 24
    5d3c:	0e 94 03 0c 	call	0x1806	; 0x1806 <LCD_SetPos>
	LCD_SelectFont (&font12x16);
    5d40:	89 e4       	ldi	r24, 0x49	; 73
    5d42:	91 e0       	ldi	r25, 0x01	; 1
    5d44:	0e 94 57 0e 	call	0x1cae	; 0x1cae <LCD_SelectFont>
	
	if (Config.QuadFlyingMode==QuadFlyingMode_X)
    5d48:	80 91 e2 06 	lds	r24, 0x06E2
    5d4c:	81 30       	cpi	r24, 0x01	; 1
    5d4e:	51 f4       	brne	.+20     	; 0x5d64 <_hHomePage+0x162>
	{
		if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    5d50:	80 91 e0 06 	lds	r24, 0x06E0
    5d54:	81 30       	cpi	r24, 0x01	; 1
    5d56:	19 f4       	brne	.+6      	; 0x5d5e <_hHomePage+0x15c>
		{
			LCD_WriteString_P(PSTR ("X"));
    5d58:	89 e2       	ldi	r24, 0x29	; 41
    5d5a:	9d e0       	ldi	r25, 0x0D	; 13
    5d5c:	0c c0       	rjmp	.+24     	; 0x5d76 <_hHomePage+0x174>
		}
		else
		{
			LCD_WriteString_P(PSTR ("A"));
    5d5e:	87 e2       	ldi	r24, 0x27	; 39
    5d60:	9d e0       	ldi	r25, 0x0D	; 13
    5d62:	09 c0       	rjmp	.+18     	; 0x5d76 <_hHomePage+0x174>
		}			
	}
	else
	{
		if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    5d64:	80 91 e0 06 	lds	r24, 0x06E0
    5d68:	81 30       	cpi	r24, 0x01	; 1
    5d6a:	19 f4       	brne	.+6      	; 0x5d72 <_hHomePage+0x170>
		{
			LCD_WriteString_P(PSTR ("+"));
    5d6c:	85 e2       	ldi	r24, 0x25	; 37
    5d6e:	9d e0       	ldi	r25, 0x0D	; 13
    5d70:	02 c0       	rjmp	.+4      	; 0x5d76 <_hHomePage+0x174>
		}
		else
		{
			LCD_WriteString_P(PSTR ("Y"));
    5d72:	83 e2       	ldi	r24, 0x23	; 35
    5d74:	9d e0       	ldi	r25, 0x0D	; 13
    5d76:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <LCD_WriteString_P>
		}			
	}
	
	LCD_SetPos (6,80);
    5d7a:	86 e0       	ldi	r24, 0x06	; 6
    5d7c:	60 e5       	ldi	r22, 0x50	; 80
    5d7e:	0e 94 03 0c 	call	0x1806	; 0x1806 <LCD_SetPos>
	LCD_SelectFont (&font12x16);
    5d82:	89 e4       	ldi	r24, 0x49	; 73
    5d84:	91 e0       	ldi	r25, 0x01	; 1
    5d86:	0e 94 57 0e 	call	0x1cae	; 0x1cae <LCD_SelectFont>
	if (Config.BoardOrientationMode==QuadFlyingMode_X)
    5d8a:	80 91 e1 06 	lds	r24, 0x06E1
    5d8e:	81 30       	cpi	r24, 0x01	; 1
    5d90:	19 f4       	brne	.+6      	; 0x5d98 <_hHomePage+0x196>
	{
		LCD_WriteString_P(PSTR ("X"));
    5d92:	81 e2       	ldi	r24, 0x21	; 33
    5d94:	9d e0       	ldi	r25, 0x0D	; 13
    5d96:	02 c0       	rjmp	.+4      	; 0x5d9c <_hHomePage+0x19a>
	}
	else
	{
		LCD_WriteString_P(PSTR ("+"));
    5d98:	8f e1       	ldi	r24, 0x1F	; 31
    5d9a:	9d e0       	ldi	r25, 0x0D	; 13
    5d9c:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <LCD_WriteString_P>
	}
	LCD_SelectFont (NULL);
    5da0:	80 e0       	ldi	r24, 0x00	; 0
    5da2:	90 e0       	ldi	r25, 0x00	; 0
    5da4:	0e 94 57 0e 	call	0x1cae	; 0x1cae <LCD_SelectFont>
	///////
	UIEnableStickCommands=true;
    5da8:	81 e0       	ldi	r24, 0x01	; 1
    5daa:	80 93 d2 05 	sts	0x05D2, r24
	
}
    5dae:	1f 91       	pop	r17
    5db0:	0f 91       	pop	r16
    5db2:	ff 90       	pop	r15
    5db4:	ef 90       	pop	r14
    5db6:	cf 90       	pop	r12
    5db8:	08 95       	ret

00005dba <defaultHandler>:


void defaultHandler()
{
	
	if (editMode==true)
    5dba:	80 91 c2 07 	lds	r24, 0x07C2
    5dbe:	81 30       	cpi	r24, 0x01	; 1
    5dc0:	19 f4       	brne	.+6      	; 0x5dc8 <defaultHandler+0xe>
	{		// edit mode?
		editModeHandler();
    5dc2:	0e 94 03 2f 	call	0x5e06	; 0x5e06 <editModeHandler>
    5dc6:	08 95       	ret
	}
	else
	{
		if (IS_INIT | IS_KEYREFRESH) 
    5dc8:	80 91 a8 05 	lds	r24, 0x05A8
    5dcc:	90 e0       	ldi	r25, 0x00	; 0
    5dce:	83 70       	andi	r24, 0x03	; 3
    5dd0:	90 70       	andi	r25, 0x00	; 0
    5dd2:	00 97       	sbiw	r24, 0x00	; 0
    5dd4:	81 f0       	breq	.+32     	; 0x5df6 <defaultHandler+0x3c>
		{
			LCD_Clear();
    5dd6:	0e 94 3b 0c 	call	0x1876	; 0x1876 <LCD_Clear>
			// 1- display screen content
			if (currentPage.screen)
    5dda:	80 91 34 05 	lds	r24, 0x0534
    5dde:	90 91 35 05 	lds	r25, 0x0535
    5de2:	00 97       	sbiw	r24, 0x00	; 0
    5de4:	11 f0       	breq	.+4      	; 0x5dea <defaultHandler+0x30>
				LCD_WriteString_P(currentPage.screen);
    5de6:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <LCD_WriteString_P>
			// 2- Display control buttons... always be last to overwrite any graphics on it.
			writeSoftkeys(currentPage.softkeys);
    5dea:	80 91 30 05 	lds	r24, 0x0530
    5dee:	90 91 31 05 	lds	r25, 0x0531
    5df2:	0e 94 a5 29 	call	0x534a	; 0x534a <writeSoftkeys>
			//LCD_SetPos(0, 0);
		}
		
		if (currentPage.handler)
    5df6:	e0 91 32 05 	lds	r30, 0x0532
    5dfa:	f0 91 33 05 	lds	r31, 0x0533
    5dfe:	30 97       	sbiw	r30, 0x00	; 0
    5e00:	09 f0       	breq	.+2      	; 0x5e04 <defaultHandler+0x4a>
		{
			currentPage.handler();
    5e02:	09 95       	icall
    5e04:	08 95       	ret

00005e06 <editModeHandler>:
		subpage = (subpage + 1) % num;
}


void editModeHandler()
{
    5e06:	0f 93       	push	r16
	if (KEY4)	// DONE;
    5e08:	80 91 a8 05 	lds	r24, 0x05A8
    5e0c:	84 ff       	sbrs	r24, 4
    5e0e:	23 c0       	rjmp	.+70     	; 0x5e56 <editModeHandler+0x50>
	{
		editMode = false;
    5e10:	10 92 c2 07 	sts	0x07C2, r1
		_mykey = KEY_REFRESH;
    5e14:	82 e0       	ldi	r24, 0x02	; 2
    5e16:	80 93 a8 05 	sts	0x05A8, r24
		
		if (editValueType == TYPE_UINT8)
    5e1a:	80 91 c1 07 	lds	r24, 0x07C1
    5e1e:	82 30       	cpi	r24, 0x02	; 2
    5e20:	11 f0       	breq	.+4      	; 0x5e26 <editModeHandler+0x20>
			*((uint8_t*)editValuePtr) = (uint8_t) editValue;
		else if (editValueType == TYPE_INT8)
    5e22:	81 30       	cpi	r24, 0x01	; 1
    5e24:	41 f4       	brne	.+16     	; 0x5e36 <editModeHandler+0x30>
			*((int8_t*)editValuePtr) = (int8_t) editValue;
    5e26:	e0 91 bf 07 	lds	r30, 0x07BF
    5e2a:	f0 91 c0 07 	lds	r31, 0x07C0
    5e2e:	80 91 c6 07 	lds	r24, 0x07C6
    5e32:	80 83       	st	Z, r24
    5e34:	58 c0       	rjmp	.+176    	; 0x5ee6 <editModeHandler+0xe0>
		else if (editValueType == TYPE_INT16)
    5e36:	83 30       	cpi	r24, 0x03	; 3
    5e38:	19 f0       	breq	.+6      	; 0x5e40 <editModeHandler+0x3a>
			*(int16_t*)editValuePtr = (int16_t) editValue;
		else if (editValueType == TYPE_UINT16)
    5e3a:	84 30       	cpi	r24, 0x04	; 4
    5e3c:	09 f0       	breq	.+2      	; 0x5e40 <editModeHandler+0x3a>
    5e3e:	53 c0       	rjmp	.+166    	; 0x5ee6 <editModeHandler+0xe0>
			*(uint16_t*)editValuePtr =(uint16_t) editValue;
    5e40:	e0 91 bf 07 	lds	r30, 0x07BF
    5e44:	f0 91 c0 07 	lds	r31, 0x07C0
    5e48:	80 91 c6 07 	lds	r24, 0x07C6
    5e4c:	90 91 c7 07 	lds	r25, 0x07C7
    5e50:	91 83       	std	Z+1, r25	; 0x01
    5e52:	80 83       	st	Z, r24
    5e54:	48 c0       	rjmp	.+144    	; 0x5ee6 <editModeHandler+0xe0>
		
		LCD_SelectFont(NULL);
		defaultHandler();
		return;
	}
	if (ANYKEY)
    5e56:	88 23       	and	r24, r24
    5e58:	09 f4       	brne	.+2      	; 0x5e5c <editModeHandler+0x56>
    5e5a:	56 c0       	rjmp	.+172    	; 0x5f08 <editModeHandler+0x102>
	{
		if (KEY2)	// DOWN?
    5e5c:	86 ff       	sbrs	r24, 6
    5e5e:	1b c0       	rjmp	.+54     	; 0x5e96 <editModeHandler+0x90>
		{
			
				if (_keyrepeat == KEYBOARD_REPEAT)
    5e60:	20 91 b9 05 	lds	r18, 0x05B9
    5e64:	80 91 c6 07 	lds	r24, 0x07C6
    5e68:	90 91 c7 07 	lds	r25, 0x07C7
    5e6c:	21 30       	cpi	r18, 0x01	; 1
    5e6e:	11 f4       	brne	.+4      	; 0x5e74 <editModeHandler+0x6e>
				{
					editValue-=10;
    5e70:	0a 97       	sbiw	r24, 0x0a	; 10
    5e72:	01 c0       	rjmp	.+2      	; 0x5e76 <editModeHandler+0x70>
				}
				else
				{
					editValue--;	
    5e74:	01 97       	sbiw	r24, 0x01	; 1
    5e76:	90 93 c7 07 	sts	0x07C7, r25
    5e7a:	80 93 c6 07 	sts	0x07C6, r24
				}
				
				if (editValue < editLoLimit)				
    5e7e:	80 91 c3 07 	lds	r24, 0x07C3
    5e82:	90 91 c4 07 	lds	r25, 0x07C4
    5e86:	20 91 c6 07 	lds	r18, 0x07C6
    5e8a:	30 91 c7 07 	lds	r19, 0x07C7
    5e8e:	28 17       	cp	r18, r24
    5e90:	39 07       	cpc	r19, r25
    5e92:	84 f5       	brge	.+96     	; 0x5ef4 <editModeHandler+0xee>
    5e94:	1c c0       	rjmp	.+56     	; 0x5ece <editModeHandler+0xc8>
				{
					editValue = editLoLimit;
				}
		}
		else if (KEY3)	// UP?
    5e96:	85 ff       	sbrs	r24, 5
    5e98:	1f c0       	rjmp	.+62     	; 0x5ed8 <editModeHandler+0xd2>
		{
				if (_keyrepeat == KEYBOARD_REPEAT)
    5e9a:	20 91 b9 05 	lds	r18, 0x05B9
    5e9e:	80 91 c6 07 	lds	r24, 0x07C6
    5ea2:	90 91 c7 07 	lds	r25, 0x07C7
    5ea6:	21 30       	cpi	r18, 0x01	; 1
    5ea8:	11 f4       	brne	.+4      	; 0x5eae <editModeHandler+0xa8>
				{
					editValue+=10;
    5eaa:	0a 96       	adiw	r24, 0x0a	; 10
    5eac:	01 c0       	rjmp	.+2      	; 0x5eb0 <editModeHandler+0xaa>
				}
				else
				{
					editValue++;	
    5eae:	01 96       	adiw	r24, 0x01	; 1
    5eb0:	90 93 c7 07 	sts	0x07C7, r25
    5eb4:	80 93 c6 07 	sts	0x07C6, r24
				}
				
				if (editValue > editHiLimit)
    5eb8:	80 91 bd 07 	lds	r24, 0x07BD
    5ebc:	90 91 be 07 	lds	r25, 0x07BE
    5ec0:	20 91 c6 07 	lds	r18, 0x07C6
    5ec4:	30 91 c7 07 	lds	r19, 0x07C7
    5ec8:	82 17       	cp	r24, r18
    5eca:	93 07       	cpc	r25, r19
    5ecc:	9c f4       	brge	.+38     	; 0x5ef4 <editModeHandler+0xee>
				{
					editValue=editHiLimit;
    5ece:	90 93 c7 07 	sts	0x07C7, r25
    5ed2:	80 93 c6 07 	sts	0x07C6, r24
    5ed6:	0e c0       	rjmp	.+28     	; 0x5ef4 <editModeHandler+0xee>
				}					
		}
		else if (KEY1)	// CLR?
    5ed8:	87 ff       	sbrs	r24, 7
    5eda:	0c c0       	rjmp	.+24     	; 0x5ef4 <editModeHandler+0xee>
		{
			editMode = false;
    5edc:	10 92 c2 07 	sts	0x07C2, r1
			_mykey = KEY_REFRESH;
    5ee0:	82 e0       	ldi	r24, 0x02	; 2
    5ee2:	80 93 a8 05 	sts	0x05A8, r24
	
			LCD_SelectFont(NULL);
    5ee6:	80 e0       	ldi	r24, 0x00	; 0
    5ee8:	90 e0       	ldi	r25, 0x00	; 0
    5eea:	0e 94 57 0e 	call	0x1cae	; 0x1cae <LCD_SelectFont>
			defaultHandler();
    5eee:	0e 94 dd 2e 	call	0x5dba	; 0x5dba <defaultHandler>
			return;	
    5ef2:	0a c0       	rjmp	.+20     	; 0x5f08 <editModeHandler+0x102>
		}
			
		LCD_WriteValue(2, 34, editValue, 5, -1);
    5ef4:	40 91 c6 07 	lds	r20, 0x07C6
    5ef8:	50 91 c7 07 	lds	r21, 0x07C7
    5efc:	82 e0       	ldi	r24, 0x02	; 2
    5efe:	62 e2       	ldi	r22, 0x22	; 34
    5f00:	25 e0       	ldi	r18, 0x05	; 5
    5f02:	0f ef       	ldi	r16, 0xFF	; 255
    5f04:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <LCD_WriteValue>
	}
}
    5f08:	0f 91       	pop	r16
    5f0a:	08 95       	ret

00005f0c <startEditMode>:

static void startEditMode(void* valuePtr, int16_t loLimit, int16_t hiLimit, uint8_t valueType)
{
    5f0c:	0f 93       	push	r16
    5f0e:	fc 01       	movw	r30, r24
	editMode = true;
    5f10:	81 e0       	ldi	r24, 0x01	; 1
    5f12:	80 93 c2 07 	sts	0x07C2, r24
	_mykey = KEY_INIT;
    5f16:	80 93 a8 05 	sts	0x05A8, r24
	editValuePtr = valuePtr;
    5f1a:	f0 93 c0 07 	sts	0x07C0, r31
    5f1e:	e0 93 bf 07 	sts	0x07BF, r30
	editValueType = valueType;
    5f22:	20 93 c1 07 	sts	0x07C1, r18
	
	if (valueType == TYPE_UINT8)
    5f26:	22 30       	cpi	r18, 0x02	; 2
    5f28:	31 f4       	brne	.+12     	; 0x5f36 <startEditMode+0x2a>
		editValue = *(uint8_t*)valuePtr;
    5f2a:	80 81       	ld	r24, Z
    5f2c:	80 93 c6 07 	sts	0x07C6, r24
    5f30:	10 92 c7 07 	sts	0x07C7, r1
    5f34:	11 c0       	rjmp	.+34     	; 0x5f58 <startEditMode+0x4c>
	else if (valueType == TYPE_INT8)
    5f36:	21 30       	cpi	r18, 0x01	; 1
    5f38:	29 f4       	brne	.+10     	; 0x5f44 <startEditMode+0x38>
		editValue = *(int8_t*)valuePtr;
    5f3a:	80 81       	ld	r24, Z
    5f3c:	99 27       	eor	r25, r25
    5f3e:	87 fd       	sbrc	r24, 7
    5f40:	90 95       	com	r25
    5f42:	06 c0       	rjmp	.+12     	; 0x5f50 <startEditMode+0x44>
	else if (valueType == TYPE_INT16)
    5f44:	23 30       	cpi	r18, 0x03	; 3
    5f46:	11 f0       	breq	.+4      	; 0x5f4c <startEditMode+0x40>
 		editValue = *(int16_t*)valuePtr;
	else if (valueType == TYPE_UINT16)
    5f48:	24 30       	cpi	r18, 0x04	; 4
    5f4a:	31 f4       	brne	.+12     	; 0x5f58 <startEditMode+0x4c>
 		editValue = *(uint16_t*)valuePtr;
    5f4c:	80 81       	ld	r24, Z
    5f4e:	91 81       	ldd	r25, Z+1	; 0x01
    5f50:	90 93 c7 07 	sts	0x07C7, r25
    5f54:	80 93 c6 07 	sts	0x07C6, r24
	
	editLoLimit = loLimit;
    5f58:	70 93 c4 07 	sts	0x07C4, r23
    5f5c:	60 93 c3 07 	sts	0x07C3, r22
	editHiLimit = hiLimit;
    5f60:	50 93 be 07 	sts	0x07BE, r21
    5f64:	40 93 bd 07 	sts	0x07BD, r20
	
	LCD_FillRectangle(30, 11, 98, 34, 0);
    5f68:	8e e1       	ldi	r24, 0x1E	; 30
    5f6a:	6b e0       	ldi	r22, 0x0B	; 11
    5f6c:	42 e6       	ldi	r20, 0x62	; 98
    5f6e:	22 e2       	ldi	r18, 0x22	; 34
    5f70:	00 e0       	ldi	r16, 0x00	; 0
    5f72:	0e 94 3a 0c 	call	0x1874	; 0x1874 <LCD_FillRectangle>
	LCD_Rectangle(30, 11, 98, 34, 1);
    5f76:	8e e1       	ldi	r24, 0x1E	; 30
    5f78:	6b e0       	ldi	r22, 0x0B	; 11
    5f7a:	42 e6       	ldi	r20, 0x62	; 98
    5f7c:	22 e2       	ldi	r18, 0x22	; 34
    5f7e:	01 e0       	ldi	r16, 0x01	; 1
    5f80:	0e 94 39 0c 	call	0x1872	; 0x1872 <LCD_Rectangle>
	LCD_Rectangle(31, 12, 97, 33, 1);
    5f84:	8f e1       	ldi	r24, 0x1F	; 31
    5f86:	6c e0       	ldi	r22, 0x0C	; 12
    5f88:	41 e6       	ldi	r20, 0x61	; 97
    5f8a:	21 e2       	ldi	r18, 0x21	; 33
    5f8c:	0e 94 39 0c 	call	0x1872	; 0x1872 <LCD_Rectangle>
	writeSoftkeys(_skEDIT);
    5f90:	82 e2       	ldi	r24, 0x22	; 34
    5f92:	9c e0       	ldi	r25, 0x0C	; 12
    5f94:	0e 94 a5 29 	call	0x534a	; 0x534a <writeSoftkeys>
	LCD_SelectFont(&font12x16);
    5f98:	89 e4       	ldi	r24, 0x49	; 73
    5f9a:	91 e0       	ldi	r25, 0x01	; 1
    5f9c:	0e 94 57 0e 	call	0x1cae	; 0x1cae <LCD_SelectFont>
	editModeHandler();
    5fa0:	0e 94 03 2f 	call	0x5e06	; 0x5e06 <editModeHandler>
}
    5fa4:	0f 91       	pop	r16
    5fa6:	08 95       	ret

00005fa8 <PageKey>:
}


void PageKey(const uint8_t num)
{
	if (KEY2)	// PREV
    5fa8:	90 91 a8 05 	lds	r25, 0x05A8
    5fac:	96 ff       	sbrs	r25, 6
    5fae:	08 c0       	rjmp	.+16     	; 0x5fc0 <PageKey+0x18>
		subpage = subpage == 0 ? num - 1 : subpage - 1;
    5fb0:	60 91 2e 05 	lds	r22, 0x052E
    5fb4:	61 11       	cpse	r22, r1
    5fb6:	86 2f       	mov	r24, r22
    5fb8:	81 50       	subi	r24, 0x01	; 1
    5fba:	80 93 2e 05 	sts	0x052E, r24
    5fbe:	08 95       	ret
	else if (KEY3) // NEXT
    5fc0:	95 ff       	sbrs	r25, 5
    5fc2:	0c c0       	rjmp	.+24     	; 0x5fdc <PageKey+0x34>
		subpage = (subpage + 1) % num;
    5fc4:	20 91 2e 05 	lds	r18, 0x052E
    5fc8:	30 e0       	ldi	r19, 0x00	; 0
    5fca:	2f 5f       	subi	r18, 0xFF	; 255
    5fcc:	3f 4f       	sbci	r19, 0xFF	; 255
    5fce:	68 2f       	mov	r22, r24
    5fd0:	c9 01       	movw	r24, r18
    5fd2:	70 e0       	ldi	r23, 0x00	; 0
    5fd4:	0e 94 40 39 	call	0x7280	; 0x7280 <__divmodhi4>
    5fd8:	80 93 2e 05 	sts	0x052E, r24
    5fdc:	08 95       	ret

00005fde <_hAltitudeHold>:




void _hAltitudeHold()
{
    5fde:	0f 93       	push	r16
	
	NOKEYRETURN;
    5fe0:	80 91 a8 05 	lds	r24, 0x05A8
    5fe4:	88 23       	and	r24, r24
    5fe6:	09 f4       	brne	.+2      	; 0x5fea <_hAltitudeHold+0xc>
    5fe8:	a2 c0       	rjmp	.+324    	; 0x612e <_hAltitudeHold+0x150>
	PageKey(6);
    5fea:	86 e0       	ldi	r24, 0x06	; 6
    5fec:	0e 94 d4 2f 	call	0x5fa8	; 0x5fa8 <PageKey>
	
	
	if (KEY4)
    5ff0:	20 91 a8 05 	lds	r18, 0x05A8
    5ff4:	24 ff       	sbrs	r18, 4
    5ff6:	36 c0       	rjmp	.+108    	; 0x6064 <_hAltitudeHold+0x86>
	{
		bValueChanged = true;
    5ff8:	81 e0       	ldi	r24, 0x01	; 1
    5ffa:	80 93 2a 05 	sts	0x052A, r24
		currentPage.softkeys = _skMENUSAVE;
    5ffe:	8b ef       	ldi	r24, 0xFB	; 251
    6000:	9b e0       	ldi	r25, 0x0B	; 11
    6002:	90 93 31 05 	sts	0x0531, r25
    6006:	80 93 30 05 	sts	0x0530, r24
		switch (subpage)
    600a:	80 91 2e 05 	lds	r24, 0x052E
    600e:	82 30       	cpi	r24, 0x02	; 2
    6010:	a1 f0       	breq	.+40     	; 0x603a <_hAltitudeHold+0x5c>
    6012:	83 30       	cpi	r24, 0x03	; 3
    6014:	28 f4       	brcc	.+10     	; 0x6020 <_hAltitudeHold+0x42>
    6016:	88 23       	and	r24, r24
    6018:	51 f0       	breq	.+20     	; 0x602e <_hAltitudeHold+0x50>
    601a:	81 30       	cpi	r24, 0x01	; 1
    601c:	19 f5       	brne	.+70     	; 0x6064 <_hAltitudeHold+0x86>
    601e:	0a c0       	rjmp	.+20     	; 0x6034 <_hAltitudeHold+0x56>
    6020:	84 30       	cpi	r24, 0x04	; 4
    6022:	89 f0       	breq	.+34     	; 0x6046 <_hAltitudeHold+0x68>
    6024:	84 30       	cpi	r24, 0x04	; 4
    6026:	60 f0       	brcs	.+24     	; 0x6040 <_hAltitudeHold+0x62>
    6028:	85 30       	cpi	r24, 0x05	; 5
    602a:	e1 f4       	brne	.+56     	; 0x6064 <_hAltitudeHold+0x86>
    602c:	11 c0       	rjmp	.+34     	; 0x6050 <_hAltitudeHold+0x72>
		{
			case 0: startEditMode(&(Config.SonarParams[0]._P),-500,500,TYPE_INT16); return ;
    602e:	8b e3       	ldi	r24, 0x3B	; 59
    6030:	97 e0       	ldi	r25, 0x07	; 7
    6032:	0b c0       	rjmp	.+22     	; 0x604a <_hAltitudeHold+0x6c>
			case 1: startEditMode(&(Config.SonarParams[0]._PLimit),0,500,TYPE_INT16); return ;
    6034:	8d e3       	ldi	r24, 0x3D	; 61
    6036:	97 e0       	ldi	r25, 0x07	; 7
    6038:	0d c0       	rjmp	.+26     	; 0x6054 <_hAltitudeHold+0x76>
			case 2: startEditMode(&(Config.SonarParams[0]._I),-500,500,TYPE_INT16);  return ;
    603a:	8f e3       	ldi	r24, 0x3F	; 63
    603c:	97 e0       	ldi	r25, 0x07	; 7
    603e:	05 c0       	rjmp	.+10     	; 0x604a <_hAltitudeHold+0x6c>
			case 3: startEditMode(&(Config.SonarParams[0]._ILimit),0,500,TYPE_INT16); return ;
    6040:	81 e4       	ldi	r24, 0x41	; 65
    6042:	97 e0       	ldi	r25, 0x07	; 7
    6044:	07 c0       	rjmp	.+14     	; 0x6054 <_hAltitudeHold+0x76>
			case 4: startEditMode(&(Config.SonarParams[0]._D),-500,500,TYPE_INT16);  return ; // negative D
    6046:	83 e4       	ldi	r24, 0x43	; 67
    6048:	97 e0       	ldi	r25, 0x07	; 7
    604a:	6c e0       	ldi	r22, 0x0C	; 12
    604c:	7e ef       	ldi	r23, 0xFE	; 254
    604e:	04 c0       	rjmp	.+8      	; 0x6058 <_hAltitudeHold+0x7a>
			case 5: startEditMode(&(Config.SonarParams[0]._DLimit),0,500,TYPE_INT16); return ;
    6050:	85 e4       	ldi	r24, 0x45	; 69
    6052:	97 e0       	ldi	r25, 0x07	; 7
    6054:	60 e0       	ldi	r22, 0x00	; 0
    6056:	70 e0       	ldi	r23, 0x00	; 0
    6058:	44 ef       	ldi	r20, 0xF4	; 244
    605a:	51 e0       	ldi	r21, 0x01	; 1
    605c:	23 e0       	ldi	r18, 0x03	; 3
    605e:	0e 94 86 2f 	call	0x5f0c	; 0x5f0c <startEditMode>
    6062:	65 c0       	rjmp	.+202    	; 0x612e <_hAltitudeHold+0x150>
		}
	}
	
	if (KEY1)
    6064:	27 ff       	sbrs	r18, 7
    6066:	02 c0       	rjmp	.+4      	; 0x606c <_hAltitudeHold+0x8e>
	{
		_helper_SaveinEEPROM_ifChanged();
    6068:	0e 94 7e 2b 	call	0x56fc	; 0x56fc <_helper_SaveinEEPROM_ifChanged>
	}
	
	LCD_WriteValue(1,30,Config.SonarParams[0]._P,3,0==subpage);
    606c:	40 91 3b 07 	lds	r20, 0x073B
    6070:	50 91 3c 07 	lds	r21, 0x073C
    6074:	01 e0       	ldi	r16, 0x01	; 1
    6076:	80 91 2e 05 	lds	r24, 0x052E
    607a:	81 11       	cpse	r24, r1
    607c:	00 e0       	ldi	r16, 0x00	; 0
    607e:	81 e0       	ldi	r24, 0x01	; 1
    6080:	6e e1       	ldi	r22, 0x1E	; 30
    6082:	23 e0       	ldi	r18, 0x03	; 3
    6084:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <LCD_WriteValue>
	LCD_WriteValue(1,84,Config.SonarParams[0]._PLimit,3,1==subpage);
    6088:	40 91 3d 07 	lds	r20, 0x073D
    608c:	50 91 3e 07 	lds	r21, 0x073E
    6090:	01 e0       	ldi	r16, 0x01	; 1
    6092:	80 91 2e 05 	lds	r24, 0x052E
    6096:	81 30       	cpi	r24, 0x01	; 1
    6098:	09 f0       	breq	.+2      	; 0x609c <_hAltitudeHold+0xbe>
    609a:	00 e0       	ldi	r16, 0x00	; 0
    609c:	81 e0       	ldi	r24, 0x01	; 1
    609e:	64 e5       	ldi	r22, 0x54	; 84
    60a0:	23 e0       	ldi	r18, 0x03	; 3
    60a2:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <LCD_WriteValue>
	LCD_WriteValue(2,30,Config.SonarParams[0]._I,3,2==subpage);
    60a6:	40 91 3f 07 	lds	r20, 0x073F
    60aa:	50 91 40 07 	lds	r21, 0x0740
    60ae:	01 e0       	ldi	r16, 0x01	; 1
    60b0:	80 91 2e 05 	lds	r24, 0x052E
    60b4:	82 30       	cpi	r24, 0x02	; 2
    60b6:	09 f0       	breq	.+2      	; 0x60ba <_hAltitudeHold+0xdc>
    60b8:	00 e0       	ldi	r16, 0x00	; 0
    60ba:	82 e0       	ldi	r24, 0x02	; 2
    60bc:	6e e1       	ldi	r22, 0x1E	; 30
    60be:	23 e0       	ldi	r18, 0x03	; 3
    60c0:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <LCD_WriteValue>
	LCD_WriteValue(2,84,Config.SonarParams[0]._ILimit,3,3==subpage);
    60c4:	40 91 41 07 	lds	r20, 0x0741
    60c8:	50 91 42 07 	lds	r21, 0x0742
    60cc:	01 e0       	ldi	r16, 0x01	; 1
    60ce:	80 91 2e 05 	lds	r24, 0x052E
    60d2:	83 30       	cpi	r24, 0x03	; 3
    60d4:	09 f0       	breq	.+2      	; 0x60d8 <_hAltitudeHold+0xfa>
    60d6:	00 e0       	ldi	r16, 0x00	; 0
    60d8:	82 e0       	ldi	r24, 0x02	; 2
    60da:	64 e5       	ldi	r22, 0x54	; 84
    60dc:	23 e0       	ldi	r18, 0x03	; 3
    60de:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <LCD_WriteValue>
	LCD_WriteValue(3,30,Config.SonarParams[0]._D,3,4==subpage);
    60e2:	40 91 43 07 	lds	r20, 0x0743
    60e6:	50 91 44 07 	lds	r21, 0x0744
    60ea:	01 e0       	ldi	r16, 0x01	; 1
    60ec:	80 91 2e 05 	lds	r24, 0x052E
    60f0:	84 30       	cpi	r24, 0x04	; 4
    60f2:	09 f0       	breq	.+2      	; 0x60f6 <_hAltitudeHold+0x118>
    60f4:	00 e0       	ldi	r16, 0x00	; 0
    60f6:	83 e0       	ldi	r24, 0x03	; 3
    60f8:	6e e1       	ldi	r22, 0x1E	; 30
    60fa:	23 e0       	ldi	r18, 0x03	; 3
    60fc:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <LCD_WriteValue>
	LCD_WriteValue(3,84,Config.SonarParams[0]._DLimit,3,5==subpage);
    6100:	40 91 45 07 	lds	r20, 0x0745
    6104:	50 91 46 07 	lds	r21, 0x0746
    6108:	01 e0       	ldi	r16, 0x01	; 1
    610a:	80 91 2e 05 	lds	r24, 0x052E
    610e:	85 30       	cpi	r24, 0x05	; 5
    6110:	09 f0       	breq	.+2      	; 0x6114 <_hAltitudeHold+0x136>
    6112:	00 e0       	ldi	r16, 0x00	; 0
    6114:	83 e0       	ldi	r24, 0x03	; 3
    6116:	64 e5       	ldi	r22, 0x54	; 84
    6118:	23 e0       	ldi	r18, 0x03	; 3
    611a:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <LCD_WriteValue>
	LCD_WriteString_Pex(5,0,PSTR("                "),16,false);    
    611e:	85 e0       	ldi	r24, 0x05	; 5
    6120:	60 e0       	ldi	r22, 0x00	; 0
    6122:	41 e1       	ldi	r20, 0x11	; 17
    6124:	5c e0       	ldi	r21, 0x0C	; 12
    6126:	20 e1       	ldi	r18, 0x10	; 16
    6128:	00 e0       	ldi	r16, 0x00	; 0
    612a:	0e 94 88 0d 	call	0x1b10	; 0x1b10 <LCD_WriteString_Pex>
				
}
    612e:	0f 91       	pop	r16
    6130:	08 95       	ret

00006132 <_hSelfLeveling>:
}



void _hSelfLeveling()
{
    6132:	0f 93       	push	r16
	NOKEYRETURN;
    6134:	80 91 a8 05 	lds	r24, 0x05A8
    6138:	88 23       	and	r24, r24
    613a:	09 f4       	brne	.+2      	; 0x613e <_hSelfLeveling+0xc>
    613c:	ff c1       	rjmp	.+1022   	; 0x653c <_hSelfLeveling+0x40a>
	PageKey(10);
    613e:	8a e0       	ldi	r24, 0x0A	; 10
    6140:	0e 94 d4 2f 	call	0x5fa8	; 0x5fa8 <PageKey>
	
	if ((subindex==2) && (subpage>7)) subpage=0;
    6144:	80 91 2f 05 	lds	r24, 0x052F
    6148:	82 30       	cpi	r24, 0x02	; 2
    614a:	31 f4       	brne	.+12     	; 0x6158 <_hSelfLeveling+0x26>
    614c:	80 91 2e 05 	lds	r24, 0x052E
    6150:	88 30       	cpi	r24, 0x08	; 8
    6152:	10 f0       	brcs	.+4      	; 0x6158 <_hSelfLeveling+0x26>
    6154:	10 92 2e 05 	sts	0x052E, r1
		
	
	
	if (KEY4)
    6158:	80 91 a8 05 	lds	r24, 0x05A8
    615c:	84 ff       	sbrs	r24, 4
    615e:	d6 c0       	rjmp	.+428    	; 0x630c <_hSelfLeveling+0x1da>
	{
		if (subpage!=0) bValueChanged = true;
    6160:	20 91 2e 05 	lds	r18, 0x052E
    6164:	22 23       	and	r18, r18
    6166:	19 f0       	breq	.+6      	; 0x616e <_hSelfLeveling+0x3c>
    6168:	81 e0       	ldi	r24, 0x01	; 1
    616a:	80 93 2a 05 	sts	0x052A, r24
		currentPage.softkeys = _skMENUSAVE;
    616e:	8b ef       	ldi	r24, 0xFB	; 251
    6170:	9b e0       	ldi	r25, 0x0B	; 11
    6172:	90 93 31 05 	sts	0x0531, r25
    6176:	80 93 30 05 	sts	0x0530, r24
		
		switch (subpage)
    617a:	24 30       	cpi	r18, 0x04	; 4
    617c:	09 f4       	brne	.+2      	; 0x6180 <_hSelfLeveling+0x4e>
    617e:	6e c0       	rjmp	.+220    	; 0x625c <_hSelfLeveling+0x12a>
    6180:	25 30       	cpi	r18, 0x05	; 5
    6182:	58 f4       	brcc	.+22     	; 0x619a <_hSelfLeveling+0x68>
    6184:	21 30       	cpi	r18, 0x01	; 1
    6186:	99 f1       	breq	.+102    	; 0x61ee <_hSelfLeveling+0xbc>
    6188:	21 30       	cpi	r18, 0x01	; 1
    618a:	d0 f0       	brcs	.+52     	; 0x61c0 <_hSelfLeveling+0x8e>
    618c:	22 30       	cpi	r18, 0x02	; 2
    618e:	09 f4       	brne	.+2      	; 0x6192 <_hSelfLeveling+0x60>
    6190:	3f c0       	rjmp	.+126    	; 0x6210 <_hSelfLeveling+0xde>
    6192:	23 30       	cpi	r18, 0x03	; 3
    6194:	09 f0       	breq	.+2      	; 0x6198 <_hSelfLeveling+0x66>
    6196:	ba c0       	rjmp	.+372    	; 0x630c <_hSelfLeveling+0x1da>
    6198:	50 c0       	rjmp	.+160    	; 0x623a <_hSelfLeveling+0x108>
    619a:	27 30       	cpi	r18, 0x07	; 7
    619c:	09 f4       	brne	.+2      	; 0x61a0 <_hSelfLeveling+0x6e>
    619e:	93 c0       	rjmp	.+294    	; 0x62c6 <_hSelfLeveling+0x194>
    61a0:	28 30       	cpi	r18, 0x08	; 8
    61a2:	38 f4       	brcc	.+14     	; 0x61b2 <_hSelfLeveling+0x80>
    61a4:	25 30       	cpi	r18, 0x05	; 5
    61a6:	09 f4       	brne	.+2      	; 0x61aa <_hSelfLeveling+0x78>
    61a8:	6a c0       	rjmp	.+212    	; 0x627e <_hSelfLeveling+0x14c>
    61aa:	26 30       	cpi	r18, 0x06	; 6
    61ac:	09 f0       	breq	.+2      	; 0x61b0 <_hSelfLeveling+0x7e>
    61ae:	ae c0       	rjmp	.+348    	; 0x630c <_hSelfLeveling+0x1da>
    61b0:	79 c0       	rjmp	.+242    	; 0x62a4 <_hSelfLeveling+0x172>
    61b2:	28 30       	cpi	r18, 0x08	; 8
    61b4:	09 f4       	brne	.+2      	; 0x61b8 <_hSelfLeveling+0x86>
    61b6:	9d c0       	rjmp	.+314    	; 0x62f2 <_hSelfLeveling+0x1c0>
    61b8:	29 30       	cpi	r18, 0x09	; 9
    61ba:	09 f0       	breq	.+2      	; 0x61be <_hSelfLeveling+0x8c>
    61bc:	a7 c0       	rjmp	.+334    	; 0x630c <_hSelfLeveling+0x1da>
    61be:	9c c0       	rjmp	.+312    	; 0x62f8 <_hSelfLeveling+0x1c6>
		{
			case 0: _helper_SwitchPitchRollYaw(&subindex); 
    61c0:	8f e2       	ldi	r24, 0x2F	; 47
    61c2:	95 e0       	ldi	r25, 0x05	; 5
    61c4:	0e 94 3e 2b 	call	0x567c	; 0x567c <_helper_SwitchPitchRollYaw>
					if (subindex==2) 
    61c8:	80 91 2f 05 	lds	r24, 0x052F
    61cc:	82 30       	cpi	r24, 0x02	; 2
    61ce:	31 f4       	brne	.+12     	; 0x61dc <_hSelfLeveling+0xaa>
					{
						LCD_WriteString_Pex(5,0,PSTR("                "),16,false);    
    61d0:	85 e0       	ldi	r24, 0x05	; 5
    61d2:	60 e0       	ldi	r22, 0x00	; 0
    61d4:	44 e5       	ldi	r20, 0x54	; 84
    61d6:	5c e0       	ldi	r21, 0x0C	; 12
    61d8:	20 e1       	ldi	r18, 0x10	; 16
    61da:	05 c0       	rjmp	.+10     	; 0x61e6 <_hSelfLeveling+0xb4>
					}
					else
					{
						LCD_WriteString_Pex(5,0,PSTR("Trim P:    R:"),13,false);
    61dc:	85 e0       	ldi	r24, 0x05	; 5
    61de:	60 e0       	ldi	r22, 0x00	; 0
    61e0:	46 e4       	ldi	r20, 0x46	; 70
    61e2:	5c e0       	ldi	r21, 0x0C	; 12
    61e4:	2d e0       	ldi	r18, 0x0D	; 13
    61e6:	00 e0       	ldi	r16, 0x00	; 0
    61e8:	0e 94 88 0d 	call	0x1b10	; 0x1b10 <LCD_WriteString_Pex>
    61ec:	8f c0       	rjmp	.+286    	; 0x630c <_hSelfLeveling+0x1da>
					}				
					break;		
			case 1: startEditMode(&(Config.AccParams[subindex]._P),-500,500,TYPE_INT16); return ;
    61ee:	80 91 2f 05 	lds	r24, 0x052F
    61f2:	90 e0       	ldi	r25, 0x00	; 0
    61f4:	9c 01       	movw	r18, r24
    61f6:	22 0f       	add	r18, r18
    61f8:	33 1f       	adc	r19, r19
    61fa:	c9 01       	movw	r24, r18
    61fc:	e3 e0       	ldi	r30, 0x03	; 3
    61fe:	88 0f       	add	r24, r24
    6200:	99 1f       	adc	r25, r25
    6202:	ea 95       	dec	r30
    6204:	e1 f7       	brne	.-8      	; 0x61fe <_hSelfLeveling+0xcc>
    6206:	82 1b       	sub	r24, r18
    6208:	93 0b       	sbc	r25, r19
    620a:	8f 5e       	subi	r24, 0xEF	; 239
    620c:	98 4f       	sbci	r25, 0xF8	; 248
    620e:	47 c0       	rjmp	.+142    	; 0x629e <_hSelfLeveling+0x16c>
			case 2: startEditMode(&(Config.AccParams[subindex]._PLimit),0,500,TYPE_INT16); return ;
    6210:	80 91 2f 05 	lds	r24, 0x052F
    6214:	90 e0       	ldi	r25, 0x00	; 0
    6216:	9c 01       	movw	r18, r24
    6218:	22 0f       	add	r18, r18
    621a:	33 1f       	adc	r19, r19
    621c:	c9 01       	movw	r24, r18
    621e:	63 e0       	ldi	r22, 0x03	; 3
    6220:	88 0f       	add	r24, r24
    6222:	99 1f       	adc	r25, r25
    6224:	6a 95       	dec	r22
    6226:	e1 f7       	brne	.-8      	; 0x6220 <_hSelfLeveling+0xee>
    6228:	82 1b       	sub	r24, r18
    622a:	93 0b       	sbc	r25, r19
    622c:	8d 5e       	subi	r24, 0xED	; 237
    622e:	98 4f       	sbci	r25, 0xF8	; 248
    6230:	60 e0       	ldi	r22, 0x00	; 0
    6232:	70 e0       	ldi	r23, 0x00	; 0
    6234:	44 ef       	ldi	r20, 0xF4	; 244
    6236:	51 e0       	ldi	r21, 0x01	; 1
    6238:	5a c0       	rjmp	.+180    	; 0x62ee <_hSelfLeveling+0x1bc>
			case 3: startEditMode(&(Config.AccParams[subindex]._I),-500,500,TYPE_INT16);  return ;
    623a:	80 91 2f 05 	lds	r24, 0x052F
    623e:	90 e0       	ldi	r25, 0x00	; 0
    6240:	9c 01       	movw	r18, r24
    6242:	22 0f       	add	r18, r18
    6244:	33 1f       	adc	r19, r19
    6246:	c9 01       	movw	r24, r18
    6248:	43 e0       	ldi	r20, 0x03	; 3
    624a:	88 0f       	add	r24, r24
    624c:	99 1f       	adc	r25, r25
    624e:	4a 95       	dec	r20
    6250:	e1 f7       	brne	.-8      	; 0x624a <_hSelfLeveling+0x118>
    6252:	82 1b       	sub	r24, r18
    6254:	93 0b       	sbc	r25, r19
    6256:	8b 5e       	subi	r24, 0xEB	; 235
    6258:	98 4f       	sbci	r25, 0xF8	; 248
    625a:	21 c0       	rjmp	.+66     	; 0x629e <_hSelfLeveling+0x16c>
			case 4: startEditMode(&(Config.AccParams[subindex]._ILimit),0,500,TYPE_INT16); return ;
    625c:	80 91 2f 05 	lds	r24, 0x052F
    6260:	90 e0       	ldi	r25, 0x00	; 0
    6262:	9c 01       	movw	r18, r24
    6264:	22 0f       	add	r18, r18
    6266:	33 1f       	adc	r19, r19
    6268:	c9 01       	movw	r24, r18
    626a:	b3 e0       	ldi	r27, 0x03	; 3
    626c:	88 0f       	add	r24, r24
    626e:	99 1f       	adc	r25, r25
    6270:	ba 95       	dec	r27
    6272:	e1 f7       	brne	.-8      	; 0x626c <_hSelfLeveling+0x13a>
    6274:	82 1b       	sub	r24, r18
    6276:	93 0b       	sbc	r25, r19
    6278:	89 5e       	subi	r24, 0xE9	; 233
    627a:	98 4f       	sbci	r25, 0xF8	; 248
    627c:	d9 cf       	rjmp	.-78     	; 0x6230 <_hSelfLeveling+0xfe>
			case 5: startEditMode(&(Config.AccParams[subindex]._D),-500,500,TYPE_INT16);  return ; // negative D
    627e:	80 91 2f 05 	lds	r24, 0x052F
    6282:	90 e0       	ldi	r25, 0x00	; 0
    6284:	9c 01       	movw	r18, r24
    6286:	22 0f       	add	r18, r18
    6288:	33 1f       	adc	r19, r19
    628a:	c9 01       	movw	r24, r18
    628c:	f3 e0       	ldi	r31, 0x03	; 3
    628e:	88 0f       	add	r24, r24
    6290:	99 1f       	adc	r25, r25
    6292:	fa 95       	dec	r31
    6294:	e1 f7       	brne	.-8      	; 0x628e <_hSelfLeveling+0x15c>
    6296:	82 1b       	sub	r24, r18
    6298:	93 0b       	sbc	r25, r19
    629a:	87 5e       	subi	r24, 0xE7	; 231
    629c:	98 4f       	sbci	r25, 0xF8	; 248
    629e:	6c e0       	ldi	r22, 0x0C	; 12
    62a0:	7e ef       	ldi	r23, 0xFE	; 254
    62a2:	c8 cf       	rjmp	.-112    	; 0x6234 <_hSelfLeveling+0x102>
			case 6: startEditMode(&(Config.AccParams[subindex]._DLimit),0,500,TYPE_INT16); return ;
    62a4:	80 91 2f 05 	lds	r24, 0x052F
    62a8:	90 e0       	ldi	r25, 0x00	; 0
    62aa:	9c 01       	movw	r18, r24
    62ac:	22 0f       	add	r18, r18
    62ae:	33 1f       	adc	r19, r19
    62b0:	c9 01       	movw	r24, r18
    62b2:	73 e0       	ldi	r23, 0x03	; 3
    62b4:	88 0f       	add	r24, r24
    62b6:	99 1f       	adc	r25, r25
    62b8:	7a 95       	dec	r23
    62ba:	e1 f7       	brne	.-8      	; 0x62b4 <_hSelfLeveling+0x182>
    62bc:	82 1b       	sub	r24, r18
    62be:	93 0b       	sbc	r25, r19
    62c0:	85 5e       	subi	r24, 0xE5	; 229
    62c2:	98 4f       	sbci	r25, 0xF8	; 248
    62c4:	b5 cf       	rjmp	.-150    	; 0x6230 <_hSelfLeveling+0xfe>
			case 7: startEditMode(&(Config.AccParams[subindex].ComplementaryFilterAlpha),0,999,TYPE_INT16); return ;
    62c6:	80 91 2f 05 	lds	r24, 0x052F
    62ca:	90 e0       	ldi	r25, 0x00	; 0
    62cc:	9c 01       	movw	r18, r24
    62ce:	22 0f       	add	r18, r18
    62d0:	33 1f       	adc	r19, r19
    62d2:	c9 01       	movw	r24, r18
    62d4:	53 e0       	ldi	r21, 0x03	; 3
    62d6:	88 0f       	add	r24, r24
    62d8:	99 1f       	adc	r25, r25
    62da:	5a 95       	dec	r21
    62dc:	e1 f7       	brne	.-8      	; 0x62d6 <_hSelfLeveling+0x1a4>
    62de:	82 1b       	sub	r24, r18
    62e0:	93 0b       	sbc	r25, r19
    62e2:	83 5e       	subi	r24, 0xE3	; 227
    62e4:	98 4f       	sbci	r25, 0xF8	; 248
    62e6:	60 e0       	ldi	r22, 0x00	; 0
    62e8:	70 e0       	ldi	r23, 0x00	; 0
    62ea:	47 ee       	ldi	r20, 0xE7	; 231
    62ec:	53 e0       	ldi	r21, 0x03	; 3
    62ee:	23 e0       	ldi	r18, 0x03	; 3
    62f0:	0a c0       	rjmp	.+20     	; 0x6306 <_hSelfLeveling+0x1d4>
			case 8: startEditMode(&(Config.Acc_Pitch_Trim),-25,25,TYPE_INT8);  return ; 
    62f2:	8a e4       	ldi	r24, 0x4A	; 74
    62f4:	97 e0       	ldi	r25, 0x07	; 7
    62f6:	02 c0       	rjmp	.+4      	; 0x62fc <_hSelfLeveling+0x1ca>
			case 9: startEditMode(&(Config.Acc_Roll_Trim),-25,25,TYPE_INT8); return ;
    62f8:	8b e4       	ldi	r24, 0x4B	; 75
    62fa:	97 e0       	ldi	r25, 0x07	; 7
    62fc:	67 ee       	ldi	r22, 0xE7	; 231
    62fe:	7f ef       	ldi	r23, 0xFF	; 255
    6300:	49 e1       	ldi	r20, 0x19	; 25
    6302:	50 e0       	ldi	r21, 0x00	; 0
    6304:	21 e0       	ldi	r18, 0x01	; 1
    6306:	0e 94 86 2f 	call	0x5f0c	; 0x5f0c <startEditMode>
    630a:	18 c1       	rjmp	.+560    	; 0x653c <_hSelfLeveling+0x40a>
		}
	}
	
	if (KEY1)
    630c:	80 91 a8 05 	lds	r24, 0x05A8
    6310:	87 ff       	sbrs	r24, 7
    6312:	0f c0       	rjmp	.+30     	; 0x6332 <_hSelfLeveling+0x200>
	{
		if (Config.PitchRollLinked==1)
    6314:	80 91 91 07 	lds	r24, 0x0791
    6318:	81 30       	cpi	r24, 0x01	; 1
    631a:	49 f4       	brne	.+18     	; 0x632e <_hSelfLeveling+0x1fc>
		{ 
			memcpy(&(Config.AccParams[ROLL_INDEX]),&(Config.AccParams[PITCH_INDEX]), sizeof(pid_param_t));
    631c:	ef e1       	ldi	r30, 0x1F	; 31
    631e:	f7 e0       	ldi	r31, 0x07	; 7
    6320:	df 01       	movw	r26, r30
    6322:	1e 97       	sbiw	r26, 0x0e	; 14
    6324:	8e e0       	ldi	r24, 0x0E	; 14
    6326:	0d 90       	ld	r0, X+
    6328:	01 92       	st	Z+, r0
    632a:	81 50       	subi	r24, 0x01	; 1
    632c:	e1 f7       	brne	.-8      	; 0x6326 <_hSelfLeveling+0x1f4>
		}
		
		_helper_SaveinEEPROM_ifChanged();
    632e:	0e 94 7e 2b 	call	0x56fc	; 0x56fc <_helper_SaveinEEPROM_ifChanged>
	}
	
	lcdReverse(subpage == 0);
    6332:	81 e0       	ldi	r24, 0x01	; 1
    6334:	90 91 2e 05 	lds	r25, 0x052E
    6338:	91 11       	cpse	r25, r1
    633a:	80 e0       	ldi	r24, 0x00	; 0
    633c:	0e 94 0e 0d 	call	0x1a1c	; 0x1a1c <lcdReverse>
	_helper_DisplayPitchRollYaw(subindex);
    6340:	80 91 2f 05 	lds	r24, 0x052F
    6344:	0e 94 1b 2b 	call	0x5636	; 0x5636 <_helper_DisplayPitchRollYaw>
	if (subindex<2)
    6348:	80 91 2f 05 	lds	r24, 0x052F
    634c:	82 30       	cpi	r24, 0x02	; 2
    634e:	08 f5       	brcc	.+66     	; 0x6392 <_hSelfLeveling+0x260>
	{
		LCD_WriteValue(5,42,Config.Acc_Pitch_Trim,3,8==subpage);
    6350:	40 91 4a 07 	lds	r20, 0x074A
    6354:	55 27       	eor	r21, r21
    6356:	47 fd       	sbrc	r20, 7
    6358:	50 95       	com	r21
    635a:	01 e0       	ldi	r16, 0x01	; 1
    635c:	80 91 2e 05 	lds	r24, 0x052E
    6360:	88 30       	cpi	r24, 0x08	; 8
    6362:	09 f0       	breq	.+2      	; 0x6366 <_hSelfLeveling+0x234>
    6364:	00 e0       	ldi	r16, 0x00	; 0
    6366:	85 e0       	ldi	r24, 0x05	; 5
    6368:	6a e2       	ldi	r22, 0x2A	; 42
    636a:	23 e0       	ldi	r18, 0x03	; 3
    636c:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <LCD_WriteValue>
		LCD_WriteValue(5,78,Config.Acc_Roll_Trim,3,9==subpage);
    6370:	40 91 4b 07 	lds	r20, 0x074B
    6374:	55 27       	eor	r21, r21
    6376:	47 fd       	sbrc	r20, 7
    6378:	50 95       	com	r21
    637a:	01 e0       	ldi	r16, 0x01	; 1
    637c:	80 91 2e 05 	lds	r24, 0x052E
    6380:	89 30       	cpi	r24, 0x09	; 9
    6382:	09 f0       	breq	.+2      	; 0x6386 <_hSelfLeveling+0x254>
    6384:	00 e0       	ldi	r16, 0x00	; 0
    6386:	85 e0       	ldi	r24, 0x05	; 5
    6388:	6e e4       	ldi	r22, 0x4E	; 78
    638a:	23 e0       	ldi	r18, 0x03	; 3
    638c:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <LCD_WriteValue>
    6390:	06 c0       	rjmp	.+12     	; 0x639e <_hSelfLeveling+0x26c>
	}
	else
	{
		strcpy_P(sXDeg,PSTR("ACC-Z damping"));
    6392:	88 ed       	ldi	r24, 0xD8	; 216
    6394:	95 e0       	ldi	r25, 0x05	; 5
    6396:	68 e3       	ldi	r22, 0x38	; 56
    6398:	7c e0       	ldi	r23, 0x0C	; 12
    639a:	0e 94 87 39 	call	0x730e	; 0x730e <strcpy_P>
	}
	
	LCD_WriteStringex (0,0,sXDeg,0==subpage);
    639e:	21 e0       	ldi	r18, 0x01	; 1
    63a0:	80 91 2e 05 	lds	r24, 0x052E
    63a4:	81 11       	cpse	r24, r1
    63a6:	20 e0       	ldi	r18, 0x00	; 0
    63a8:	80 e0       	ldi	r24, 0x00	; 0
    63aa:	60 e0       	ldi	r22, 0x00	; 0
    63ac:	48 ed       	ldi	r20, 0xD8	; 216
    63ae:	55 e0       	ldi	r21, 0x05	; 5
    63b0:	0e 94 18 0d 	call	0x1a30	; 0x1a30 <LCD_WriteStringex>
	LCD_WriteValue(1,30,Config.AccParams[subindex]._P,3,1==subpage);
    63b4:	80 91 2f 05 	lds	r24, 0x052F
    63b8:	90 e0       	ldi	r25, 0x00	; 0
    63ba:	88 0f       	add	r24, r24
    63bc:	99 1f       	adc	r25, r25
    63be:	fc 01       	movw	r30, r24
    63c0:	33 e0       	ldi	r19, 0x03	; 3
    63c2:	ee 0f       	add	r30, r30
    63c4:	ff 1f       	adc	r31, r31
    63c6:	3a 95       	dec	r19
    63c8:	e1 f7       	brne	.-8      	; 0x63c2 <_hSelfLeveling+0x290>
    63ca:	e8 1b       	sub	r30, r24
    63cc:	f9 0b       	sbc	r31, r25
    63ce:	e7 52       	subi	r30, 0x27	; 39
    63d0:	f9 4f       	sbci	r31, 0xF9	; 249
    63d2:	40 ad       	ldd	r20, Z+56	; 0x38
    63d4:	51 ad       	ldd	r21, Z+57	; 0x39
    63d6:	01 e0       	ldi	r16, 0x01	; 1
    63d8:	80 91 2e 05 	lds	r24, 0x052E
    63dc:	81 30       	cpi	r24, 0x01	; 1
    63de:	09 f0       	breq	.+2      	; 0x63e2 <_hSelfLeveling+0x2b0>
    63e0:	00 e0       	ldi	r16, 0x00	; 0
    63e2:	81 e0       	ldi	r24, 0x01	; 1
    63e4:	6e e1       	ldi	r22, 0x1E	; 30
    63e6:	23 e0       	ldi	r18, 0x03	; 3
    63e8:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <LCD_WriteValue>
	LCD_WriteValue(1,84,Config.AccParams[subindex]._PLimit,3,2==subpage);
    63ec:	80 91 2f 05 	lds	r24, 0x052F
    63f0:	90 e0       	ldi	r25, 0x00	; 0
    63f2:	88 0f       	add	r24, r24
    63f4:	99 1f       	adc	r25, r25
    63f6:	fc 01       	movw	r30, r24
    63f8:	03 e0       	ldi	r16, 0x03	; 3
    63fa:	ee 0f       	add	r30, r30
    63fc:	ff 1f       	adc	r31, r31
    63fe:	0a 95       	dec	r16
    6400:	e1 f7       	brne	.-8      	; 0x63fa <_hSelfLeveling+0x2c8>
    6402:	e8 1b       	sub	r30, r24
    6404:	f9 0b       	sbc	r31, r25
    6406:	e7 52       	subi	r30, 0x27	; 39
    6408:	f9 4f       	sbci	r31, 0xF9	; 249
    640a:	42 ad       	ldd	r20, Z+58	; 0x3a
    640c:	53 ad       	ldd	r21, Z+59	; 0x3b
    640e:	01 e0       	ldi	r16, 0x01	; 1
    6410:	80 91 2e 05 	lds	r24, 0x052E
    6414:	82 30       	cpi	r24, 0x02	; 2
    6416:	09 f0       	breq	.+2      	; 0x641a <_hSelfLeveling+0x2e8>
    6418:	00 e0       	ldi	r16, 0x00	; 0
    641a:	81 e0       	ldi	r24, 0x01	; 1
    641c:	64 e5       	ldi	r22, 0x54	; 84
    641e:	23 e0       	ldi	r18, 0x03	; 3
    6420:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <LCD_WriteValue>
	LCD_WriteValue(2,30,Config.AccParams[subindex]._I,3,3==subpage);
    6424:	80 91 2f 05 	lds	r24, 0x052F
    6428:	90 e0       	ldi	r25, 0x00	; 0
    642a:	88 0f       	add	r24, r24
    642c:	99 1f       	adc	r25, r25
    642e:	fc 01       	movw	r30, r24
    6430:	a3 e0       	ldi	r26, 0x03	; 3
    6432:	ee 0f       	add	r30, r30
    6434:	ff 1f       	adc	r31, r31
    6436:	aa 95       	dec	r26
    6438:	e1 f7       	brne	.-8      	; 0x6432 <_hSelfLeveling+0x300>
    643a:	e8 1b       	sub	r30, r24
    643c:	f9 0b       	sbc	r31, r25
    643e:	e7 52       	subi	r30, 0x27	; 39
    6440:	f9 4f       	sbci	r31, 0xF9	; 249
    6442:	44 ad       	ldd	r20, Z+60	; 0x3c
    6444:	55 ad       	ldd	r21, Z+61	; 0x3d
    6446:	01 e0       	ldi	r16, 0x01	; 1
    6448:	80 91 2e 05 	lds	r24, 0x052E
    644c:	83 30       	cpi	r24, 0x03	; 3
    644e:	09 f0       	breq	.+2      	; 0x6452 <_hSelfLeveling+0x320>
    6450:	00 e0       	ldi	r16, 0x00	; 0
    6452:	82 e0       	ldi	r24, 0x02	; 2
    6454:	6e e1       	ldi	r22, 0x1E	; 30
    6456:	23 e0       	ldi	r18, 0x03	; 3
    6458:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <LCD_WriteValue>
	LCD_WriteValue(2,84,Config.AccParams[subindex]._ILimit,3,4==subpage);
    645c:	80 91 2f 05 	lds	r24, 0x052F
    6460:	90 e0       	ldi	r25, 0x00	; 0
    6462:	88 0f       	add	r24, r24
    6464:	99 1f       	adc	r25, r25
    6466:	fc 01       	movw	r30, r24
    6468:	73 e0       	ldi	r23, 0x03	; 3
    646a:	ee 0f       	add	r30, r30
    646c:	ff 1f       	adc	r31, r31
    646e:	7a 95       	dec	r23
    6470:	e1 f7       	brne	.-8      	; 0x646a <_hSelfLeveling+0x338>
    6472:	e8 1b       	sub	r30, r24
    6474:	f9 0b       	sbc	r31, r25
    6476:	e9 5e       	subi	r30, 0xE9	; 233
    6478:	f8 4f       	sbci	r31, 0xF8	; 248
    647a:	40 81       	ld	r20, Z
    647c:	51 81       	ldd	r21, Z+1	; 0x01
    647e:	01 e0       	ldi	r16, 0x01	; 1
    6480:	80 91 2e 05 	lds	r24, 0x052E
    6484:	84 30       	cpi	r24, 0x04	; 4
    6486:	09 f0       	breq	.+2      	; 0x648a <_hSelfLeveling+0x358>
    6488:	00 e0       	ldi	r16, 0x00	; 0
    648a:	82 e0       	ldi	r24, 0x02	; 2
    648c:	64 e5       	ldi	r22, 0x54	; 84
    648e:	23 e0       	ldi	r18, 0x03	; 3
    6490:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <LCD_WriteValue>
	LCD_WriteValue(3,30,Config.AccParams[subindex]._D,3,5==subpage);
    6494:	80 91 2f 05 	lds	r24, 0x052F
    6498:	90 e0       	ldi	r25, 0x00	; 0
    649a:	88 0f       	add	r24, r24
    649c:	99 1f       	adc	r25, r25
    649e:	fc 01       	movw	r30, r24
    64a0:	53 e0       	ldi	r21, 0x03	; 3
    64a2:	ee 0f       	add	r30, r30
    64a4:	ff 1f       	adc	r31, r31
    64a6:	5a 95       	dec	r21
    64a8:	e1 f7       	brne	.-8      	; 0x64a2 <_hSelfLeveling+0x370>
    64aa:	e8 1b       	sub	r30, r24
    64ac:	f9 0b       	sbc	r31, r25
    64ae:	e7 5e       	subi	r30, 0xE7	; 231
    64b0:	f8 4f       	sbci	r31, 0xF8	; 248
    64b2:	40 81       	ld	r20, Z
    64b4:	51 81       	ldd	r21, Z+1	; 0x01
    64b6:	01 e0       	ldi	r16, 0x01	; 1
    64b8:	80 91 2e 05 	lds	r24, 0x052E
    64bc:	85 30       	cpi	r24, 0x05	; 5
    64be:	09 f0       	breq	.+2      	; 0x64c2 <_hSelfLeveling+0x390>
    64c0:	00 e0       	ldi	r16, 0x00	; 0
    64c2:	83 e0       	ldi	r24, 0x03	; 3
    64c4:	6e e1       	ldi	r22, 0x1E	; 30
    64c6:	23 e0       	ldi	r18, 0x03	; 3
    64c8:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <LCD_WriteValue>
	LCD_WriteValue(3,84,Config.AccParams[subindex]._DLimit,3,6==subpage);
    64cc:	80 91 2f 05 	lds	r24, 0x052F
    64d0:	90 e0       	ldi	r25, 0x00	; 0
    64d2:	88 0f       	add	r24, r24
    64d4:	99 1f       	adc	r25, r25
    64d6:	fc 01       	movw	r30, r24
    64d8:	33 e0       	ldi	r19, 0x03	; 3
    64da:	ee 0f       	add	r30, r30
    64dc:	ff 1f       	adc	r31, r31
    64de:	3a 95       	dec	r19
    64e0:	e1 f7       	brne	.-8      	; 0x64da <_hSelfLeveling+0x3a8>
    64e2:	e8 1b       	sub	r30, r24
    64e4:	f9 0b       	sbc	r31, r25
    64e6:	e5 5e       	subi	r30, 0xE5	; 229
    64e8:	f8 4f       	sbci	r31, 0xF8	; 248
    64ea:	40 81       	ld	r20, Z
    64ec:	51 81       	ldd	r21, Z+1	; 0x01
    64ee:	01 e0       	ldi	r16, 0x01	; 1
    64f0:	80 91 2e 05 	lds	r24, 0x052E
    64f4:	86 30       	cpi	r24, 0x06	; 6
    64f6:	09 f0       	breq	.+2      	; 0x64fa <_hSelfLeveling+0x3c8>
    64f8:	00 e0       	ldi	r16, 0x00	; 0
    64fa:	83 e0       	ldi	r24, 0x03	; 3
    64fc:	64 e5       	ldi	r22, 0x54	; 84
    64fe:	23 e0       	ldi	r18, 0x03	; 3
    6500:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <LCD_WriteValue>
	LCD_WriteValue(4,84,Config.AccParams[subindex].ComplementaryFilterAlpha,3,7==subpage);
    6504:	80 91 2f 05 	lds	r24, 0x052F
    6508:	90 e0       	ldi	r25, 0x00	; 0
    650a:	88 0f       	add	r24, r24
    650c:	99 1f       	adc	r25, r25
    650e:	fc 01       	movw	r30, r24
    6510:	03 e0       	ldi	r16, 0x03	; 3
    6512:	ee 0f       	add	r30, r30
    6514:	ff 1f       	adc	r31, r31
    6516:	0a 95       	dec	r16
    6518:	e1 f7       	brne	.-8      	; 0x6512 <_hSelfLeveling+0x3e0>
    651a:	e8 1b       	sub	r30, r24
    651c:	f9 0b       	sbc	r31, r25
    651e:	e3 5e       	subi	r30, 0xE3	; 227
    6520:	f8 4f       	sbci	r31, 0xF8	; 248
    6522:	40 81       	ld	r20, Z
    6524:	51 81       	ldd	r21, Z+1	; 0x01
    6526:	01 e0       	ldi	r16, 0x01	; 1
    6528:	80 91 2e 05 	lds	r24, 0x052E
    652c:	87 30       	cpi	r24, 0x07	; 7
    652e:	09 f0       	breq	.+2      	; 0x6532 <_hSelfLeveling+0x400>
    6530:	00 e0       	ldi	r16, 0x00	; 0
    6532:	84 e0       	ldi	r24, 0x04	; 4
    6534:	64 e5       	ldi	r22, 0x54	; 84
    6536:	23 e0       	ldi	r18, 0x03	; 3
    6538:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <LCD_WriteValue>
	
}
    653c:	0f 91       	pop	r16
    653e:	08 95       	ret

00006540 <_hStabilization>:

/*
* check : http://code.google.com/p/ardupirates/wiki/PID_Setting_SuperStable_Code
*/ 
void _hStabilization()
{
    6540:	ef 92       	push	r14
    6542:	0f 93       	push	r16
	NOKEYRETURN;
    6544:	80 91 a8 05 	lds	r24, 0x05A8
    6548:	88 23       	and	r24, r24
    654a:	09 f4       	brne	.+2      	; 0x654e <_hStabilization+0xe>
    654c:	dd c1       	rjmp	.+954    	; 0x6908 <_hStabilization+0x3c8>
	PageKey(9);
    654e:	89 e0       	ldi	r24, 0x09	; 9
    6550:	0e 94 d4 2f 	call	0x5fa8	; 0x5fa8 <PageKey>
	
	if (KEY4)
    6554:	80 91 a8 05 	lds	r24, 0x05A8
    6558:	84 ff       	sbrs	r24, 4
    655a:	bc c0       	rjmp	.+376    	; 0x66d4 <_hStabilization+0x194>
	{
		if (subpage!=0) bValueChanged = true;
    655c:	20 91 2e 05 	lds	r18, 0x052E
    6560:	22 23       	and	r18, r18
    6562:	19 f0       	breq	.+6      	; 0x656a <_hStabilization+0x2a>
    6564:	81 e0       	ldi	r24, 0x01	; 1
    6566:	80 93 2a 05 	sts	0x052A, r24
		currentPage.softkeys = _skMENUSAVE;
    656a:	8b ef       	ldi	r24, 0xFB	; 251
    656c:	9b e0       	ldi	r25, 0x0B	; 11
    656e:	90 93 31 05 	sts	0x0531, r25
    6572:	80 93 30 05 	sts	0x0530, r24
		
		switch (subpage)
    6576:	24 30       	cpi	r18, 0x04	; 4
    6578:	09 f4       	brne	.+2      	; 0x657c <_hStabilization+0x3c>
    657a:	54 c0       	rjmp	.+168    	; 0x6624 <_hStabilization+0xe4>
    657c:	25 30       	cpi	r18, 0x05	; 5
    657e:	50 f4       	brcc	.+20     	; 0x6594 <_hStabilization+0x54>
    6580:	21 30       	cpi	r18, 0x01	; 1
    6582:	d1 f0       	breq	.+52     	; 0x65b8 <_hStabilization+0x78>
    6584:	21 30       	cpi	r18, 0x01	; 1
    6586:	98 f0       	brcs	.+38     	; 0x65ae <_hStabilization+0x6e>
    6588:	22 30       	cpi	r18, 0x02	; 2
    658a:	41 f1       	breq	.+80     	; 0x65dc <_hStabilization+0x9c>
    658c:	23 30       	cpi	r18, 0x03	; 3
    658e:	09 f0       	breq	.+2      	; 0x6592 <_hStabilization+0x52>
    6590:	a1 c0       	rjmp	.+322    	; 0x66d4 <_hStabilization+0x194>
    6592:	35 c0       	rjmp	.+106    	; 0x65fe <_hStabilization+0xbe>
    6594:	26 30       	cpi	r18, 0x06	; 6
    6596:	09 f4       	brne	.+2      	; 0x659a <_hStabilization+0x5a>
    6598:	67 c0       	rjmp	.+206    	; 0x6668 <_hStabilization+0x128>
    659a:	26 30       	cpi	r18, 0x06	; 6
    659c:	08 f4       	brcc	.+2      	; 0x65a0 <_hStabilization+0x60>
    659e:	53 c0       	rjmp	.+166    	; 0x6646 <_hStabilization+0x106>
    65a0:	27 30       	cpi	r18, 0x07	; 7
    65a2:	09 f4       	brne	.+2      	; 0x65a6 <_hStabilization+0x66>
    65a4:	76 c0       	rjmp	.+236    	; 0x6692 <_hStabilization+0x152>
    65a6:	28 30       	cpi	r18, 0x08	; 8
    65a8:	09 f0       	breq	.+2      	; 0x65ac <_hStabilization+0x6c>
    65aa:	94 c0       	rjmp	.+296    	; 0x66d4 <_hStabilization+0x194>
    65ac:	8a c0       	rjmp	.+276    	; 0x66c2 <_hStabilization+0x182>
		{
			case 0: _helper_SwitchPitchRollYaw(&subindex); break;
    65ae:	8f e2       	ldi	r24, 0x2F	; 47
    65b0:	95 e0       	ldi	r25, 0x05	; 5
    65b2:	0e 94 3e 2b 	call	0x567c	; 0x567c <_helper_SwitchPitchRollYaw>
    65b6:	8e c0       	rjmp	.+284    	; 0x66d4 <_hStabilization+0x194>
			case 1: startEditMode(&(Config.GyroParams[subindex]._P),-500,500,TYPE_INT16); return ;
    65b8:	20 91 2f 05 	lds	r18, 0x052F
    65bc:	30 e0       	ldi	r19, 0x00	; 0
    65be:	2f 5f       	subi	r18, 0xFF	; 255
    65c0:	3f 4f       	sbci	r19, 0xFF	; 255
    65c2:	22 0f       	add	r18, r18
    65c4:	33 1f       	adc	r19, r19
    65c6:	c9 01       	movw	r24, r18
    65c8:	63 e0       	ldi	r22, 0x03	; 3
    65ca:	88 0f       	add	r24, r24
    65cc:	99 1f       	adc	r25, r25
    65ce:	6a 95       	dec	r22
    65d0:	e1 f7       	brne	.-8      	; 0x65ca <_hStabilization+0x8a>
    65d2:	82 1b       	sub	r24, r18
    65d4:	93 0b       	sbc	r25, r19
    65d6:	87 52       	subi	r24, 0x27	; 39
    65d8:	99 4f       	sbci	r25, 0xF9	; 249
    65da:	21 c0       	rjmp	.+66     	; 0x661e <_hStabilization+0xde>
			case 2: startEditMode(&(Config.GyroParams[subindex]._PLimit),0,500,TYPE_INT16); return ;
    65dc:	80 91 2f 05 	lds	r24, 0x052F
    65e0:	90 e0       	ldi	r25, 0x00	; 0
    65e2:	9c 01       	movw	r18, r24
    65e4:	22 0f       	add	r18, r18
    65e6:	33 1f       	adc	r19, r19
    65e8:	c9 01       	movw	r24, r18
    65ea:	43 e0       	ldi	r20, 0x03	; 3
    65ec:	88 0f       	add	r24, r24
    65ee:	99 1f       	adc	r25, r25
    65f0:	4a 95       	dec	r20
    65f2:	e1 f7       	brne	.-8      	; 0x65ec <_hStabilization+0xac>
    65f4:	82 1b       	sub	r24, r18
    65f6:	93 0b       	sbc	r25, r19
    65f8:	87 51       	subi	r24, 0x17	; 23
    65fa:	99 4f       	sbci	r25, 0xF9	; 249
    65fc:	45 c0       	rjmp	.+138    	; 0x6688 <_hStabilization+0x148>
			case 3: startEditMode(&(Config.GyroParams[subindex]._I),-500,500,TYPE_INT16);  return ;
    65fe:	80 91 2f 05 	lds	r24, 0x052F
    6602:	90 e0       	ldi	r25, 0x00	; 0
    6604:	9c 01       	movw	r18, r24
    6606:	22 0f       	add	r18, r18
    6608:	33 1f       	adc	r19, r19
    660a:	c9 01       	movw	r24, r18
    660c:	03 e0       	ldi	r16, 0x03	; 3
    660e:	88 0f       	add	r24, r24
    6610:	99 1f       	adc	r25, r25
    6612:	0a 95       	dec	r16
    6614:	e1 f7       	brne	.-8      	; 0x660e <_hStabilization+0xce>
    6616:	82 1b       	sub	r24, r18
    6618:	93 0b       	sbc	r25, r19
    661a:	85 51       	subi	r24, 0x15	; 21
    661c:	99 4f       	sbci	r25, 0xF9	; 249
    661e:	6c e0       	ldi	r22, 0x0C	; 12
    6620:	7e ef       	ldi	r23, 0xFE	; 254
    6622:	34 c0       	rjmp	.+104    	; 0x668c <_hStabilization+0x14c>
			case 4: startEditMode(&(Config.GyroParams[subindex]._ILimit),0,500,TYPE_INT16); return ;
    6624:	80 91 2f 05 	lds	r24, 0x052F
    6628:	90 e0       	ldi	r25, 0x00	; 0
    662a:	9c 01       	movw	r18, r24
    662c:	22 0f       	add	r18, r18
    662e:	33 1f       	adc	r19, r19
    6630:	c9 01       	movw	r24, r18
    6632:	a3 e0       	ldi	r26, 0x03	; 3
    6634:	88 0f       	add	r24, r24
    6636:	99 1f       	adc	r25, r25
    6638:	aa 95       	dec	r26
    663a:	e1 f7       	brne	.-8      	; 0x6634 <_hStabilization+0xf4>
    663c:	82 1b       	sub	r24, r18
    663e:	93 0b       	sbc	r25, r19
    6640:	83 51       	subi	r24, 0x13	; 19
    6642:	99 4f       	sbci	r25, 0xF9	; 249
    6644:	21 c0       	rjmp	.+66     	; 0x6688 <_hStabilization+0x148>
			case 5: startEditMode(&(Config.GyroParams[subindex]._D),-500,500,TYPE_INT16);  return ; 
    6646:	80 91 2f 05 	lds	r24, 0x052F
    664a:	90 e0       	ldi	r25, 0x00	; 0
    664c:	9c 01       	movw	r18, r24
    664e:	22 0f       	add	r18, r18
    6650:	33 1f       	adc	r19, r19
    6652:	c9 01       	movw	r24, r18
    6654:	e3 e0       	ldi	r30, 0x03	; 3
    6656:	88 0f       	add	r24, r24
    6658:	99 1f       	adc	r25, r25
    665a:	ea 95       	dec	r30
    665c:	e1 f7       	brne	.-8      	; 0x6656 <_hStabilization+0x116>
    665e:	82 1b       	sub	r24, r18
    6660:	93 0b       	sbc	r25, r19
    6662:	81 51       	subi	r24, 0x11	; 17
    6664:	99 4f       	sbci	r25, 0xF9	; 249
    6666:	db cf       	rjmp	.-74     	; 0x661e <_hStabilization+0xde>
			case 6: startEditMode(&(Config.GyroParams[subindex]._DLimit),0,500,TYPE_INT16); return ;
    6668:	80 91 2f 05 	lds	r24, 0x052F
    666c:	90 e0       	ldi	r25, 0x00	; 0
    666e:	9c 01       	movw	r18, r24
    6670:	22 0f       	add	r18, r18
    6672:	33 1f       	adc	r19, r19
    6674:	c9 01       	movw	r24, r18
    6676:	63 e0       	ldi	r22, 0x03	; 3
    6678:	88 0f       	add	r24, r24
    667a:	99 1f       	adc	r25, r25
    667c:	6a 95       	dec	r22
    667e:	e1 f7       	brne	.-8      	; 0x6678 <_hStabilization+0x138>
    6680:	82 1b       	sub	r24, r18
    6682:	93 0b       	sbc	r25, r19
    6684:	8f 50       	subi	r24, 0x0F	; 15
    6686:	99 4f       	sbci	r25, 0xF9	; 249
    6688:	60 e0       	ldi	r22, 0x00	; 0
    668a:	70 e0       	ldi	r23, 0x00	; 0
    668c:	44 ef       	ldi	r20, 0xF4	; 244
    668e:	51 e0       	ldi	r21, 0x01	; 1
    6690:	14 c0       	rjmp	.+40     	; 0x66ba <_hStabilization+0x17a>
			case 7: startEditMode(&(Config.GyroParams[subindex].ComplementaryFilterAlpha),0,999,TYPE_INT16); return ;
    6692:	80 91 2f 05 	lds	r24, 0x052F
    6696:	90 e0       	ldi	r25, 0x00	; 0
    6698:	9c 01       	movw	r18, r24
    669a:	22 0f       	add	r18, r18
    669c:	33 1f       	adc	r19, r19
    669e:	c9 01       	movw	r24, r18
    66a0:	43 e0       	ldi	r20, 0x03	; 3
    66a2:	88 0f       	add	r24, r24
    66a4:	99 1f       	adc	r25, r25
    66a6:	4a 95       	dec	r20
    66a8:	e1 f7       	brne	.-8      	; 0x66a2 <_hStabilization+0x162>
    66aa:	82 1b       	sub	r24, r18
    66ac:	93 0b       	sbc	r25, r19
    66ae:	8d 50       	subi	r24, 0x0D	; 13
    66b0:	99 4f       	sbci	r25, 0xF9	; 249
    66b2:	60 e0       	ldi	r22, 0x00	; 0
    66b4:	70 e0       	ldi	r23, 0x00	; 0
    66b6:	47 ee       	ldi	r20, 0xE7	; 231
    66b8:	53 e0       	ldi	r21, 0x03	; 3
    66ba:	23 e0       	ldi	r18, 0x03	; 3
    66bc:	0e 94 86 2f 	call	0x5f0c	; 0x5f0c <startEditMode>
    66c0:	23 c1       	rjmp	.+582    	; 0x6908 <_hStabilization+0x3c8>
			case 8: if (Config.ReverseYAW==GYRO_NORMAL) Config.ReverseYAW =GYRO_REVERSE; else Config.ReverseYAW = GYRO_NORMAL; break; // update the UI
    66c2:	80 91 90 07 	lds	r24, 0x0790
    66c6:	81 30       	cpi	r24, 0x01	; 1
    66c8:	11 f4       	brne	.+4      	; 0x66ce <_hStabilization+0x18e>
    66ca:	8f ef       	ldi	r24, 0xFF	; 255
    66cc:	01 c0       	rjmp	.+2      	; 0x66d0 <_hStabilization+0x190>
    66ce:	81 e0       	ldi	r24, 0x01	; 1
    66d0:	80 93 90 07 	sts	0x0790, r24
		}
		
		
	}
	
	if (KEY1)
    66d4:	80 91 a8 05 	lds	r24, 0x05A8
    66d8:	87 ff       	sbrs	r24, 7
    66da:	0f c0       	rjmp	.+30     	; 0x66fa <_hStabilization+0x1ba>
	{
		if (Config.PitchRollLinked==1)
    66dc:	80 91 91 07 	lds	r24, 0x0791
    66e0:	81 30       	cpi	r24, 0x01	; 1
    66e2:	49 f4       	brne	.+18     	; 0x66f6 <_hStabilization+0x1b6>
		{
			memcpy(&(Config.GyroParams[ROLL_INDEX]),&(Config.GyroParams[PITCH_INDEX]), sizeof(pid_param_t));
    66e4:	e5 ef       	ldi	r30, 0xF5	; 245
    66e6:	f6 e0       	ldi	r31, 0x06	; 6
    66e8:	df 01       	movw	r26, r30
    66ea:	1e 97       	sbiw	r26, 0x0e	; 14
    66ec:	8e e0       	ldi	r24, 0x0E	; 14
    66ee:	0d 90       	ld	r0, X+
    66f0:	01 92       	st	Z+, r0
    66f2:	81 50       	subi	r24, 0x01	; 1
    66f4:	e1 f7       	brne	.-8      	; 0x66ee <_hStabilization+0x1ae>
		}
		
		_helper_SaveinEEPROM_ifChanged();
    66f6:	0e 94 7e 2b 	call	0x56fc	; 0x56fc <_helper_SaveinEEPROM_ifChanged>
	}
	
	lcdReverse(subpage == 0);
    66fa:	81 e0       	ldi	r24, 0x01	; 1
    66fc:	90 91 2e 05 	lds	r25, 0x052E
    6700:	91 11       	cpse	r25, r1
    6702:	80 e0       	ldi	r24, 0x00	; 0
    6704:	0e 94 0e 0d 	call	0x1a1c	; 0x1a1c <lcdReverse>
	_helper_DisplayPitchRollYaw(subindex);
    6708:	80 91 2f 05 	lds	r24, 0x052F
    670c:	0e 94 1b 2b 	call	0x5636	; 0x5636 <_helper_DisplayPitchRollYaw>
	LCD_WriteString_Pex(5,0,PSTR("                "),16,false);    
    6710:	85 e0       	ldi	r24, 0x05	; 5
    6712:	60 e0       	ldi	r22, 0x00	; 0
    6714:	46 e7       	ldi	r20, 0x76	; 118
    6716:	5c e0       	ldi	r21, 0x0C	; 12
    6718:	20 e1       	ldi	r18, 0x10	; 16
    671a:	00 e0       	ldi	r16, 0x00	; 0
    671c:	0e 94 88 0d 	call	0x1b10	; 0x1b10 <LCD_WriteString_Pex>
	
	if ((subindex==2) && (Config.FrameType == FRAMETYPE_TRICOPTER))
    6720:	80 91 2f 05 	lds	r24, 0x052F
    6724:	82 30       	cpi	r24, 0x02	; 2
    6726:	01 f5       	brne	.+64     	; 0x6768 <_hStabilization+0x228>
    6728:	80 91 e0 06 	lds	r24, 0x06E0
    672c:	82 30       	cpi	r24, 0x02	; 2
    672e:	e1 f4       	brne	.+56     	; 0x6768 <_hStabilization+0x228>
	{
		LCD_WriteString_Pex(5,0,PSTR("Reverse GYRO"),12,false);    
    6730:	85 e0       	ldi	r24, 0x05	; 5
    6732:	60 e0       	ldi	r22, 0x00	; 0
    6734:	49 e6       	ldi	r20, 0x69	; 105
    6736:	5c e0       	ldi	r21, 0x0C	; 12
    6738:	2c e0       	ldi	r18, 0x0C	; 12
    673a:	0e 94 88 0d 	call	0x1b10	; 0x1b10 <LCD_WriteString_Pex>
		_helper_DisplayBiStateText(5,84 ,PSTR("N"), PSTR("R"), Config.ReverseYAW==GYRO_NORMAL, 8==subpage);
    673e:	01 e0       	ldi	r16, 0x01	; 1
    6740:	80 91 90 07 	lds	r24, 0x0790
    6744:	81 30       	cpi	r24, 0x01	; 1
    6746:	09 f0       	breq	.+2      	; 0x674a <_hStabilization+0x20a>
    6748:	00 e0       	ldi	r16, 0x00	; 0
    674a:	91 e0       	ldi	r25, 0x01	; 1
    674c:	80 91 2e 05 	lds	r24, 0x052E
    6750:	88 30       	cpi	r24, 0x08	; 8
    6752:	09 f0       	breq	.+2      	; 0x6756 <_hStabilization+0x216>
    6754:	90 e0       	ldi	r25, 0x00	; 0
    6756:	85 e0       	ldi	r24, 0x05	; 5
    6758:	64 e5       	ldi	r22, 0x54	; 84
    675a:	47 e6       	ldi	r20, 0x67	; 103
    675c:	5c e0       	ldi	r21, 0x0C	; 12
    675e:	25 e6       	ldi	r18, 0x65	; 101
    6760:	3c e0       	ldi	r19, 0x0C	; 12
    6762:	e9 2e       	mov	r14, r25
    6764:	0e 94 52 2b 	call	0x56a4	; 0x56a4 <_helper_DisplayBiStateText>
	}		

	
	LCD_WriteStringex (0,0,sXDeg,0==subpage);
    6768:	21 e0       	ldi	r18, 0x01	; 1
    676a:	80 91 2e 05 	lds	r24, 0x052E
    676e:	81 11       	cpse	r24, r1
    6770:	20 e0       	ldi	r18, 0x00	; 0
    6772:	80 e0       	ldi	r24, 0x00	; 0
    6774:	60 e0       	ldi	r22, 0x00	; 0
    6776:	48 ed       	ldi	r20, 0xD8	; 216
    6778:	55 e0       	ldi	r21, 0x05	; 5
    677a:	0e 94 18 0d 	call	0x1a30	; 0x1a30 <LCD_WriteStringex>
	LCD_WriteValue(1,30,Config.GyroParams[subindex]._P,3,1==subpage);
    677e:	80 91 2f 05 	lds	r24, 0x052F
    6782:	90 e0       	ldi	r25, 0x00	; 0
    6784:	01 96       	adiw	r24, 0x01	; 1
    6786:	88 0f       	add	r24, r24
    6788:	99 1f       	adc	r25, r25
    678a:	fc 01       	movw	r30, r24
    678c:	03 e0       	ldi	r16, 0x03	; 3
    678e:	ee 0f       	add	r30, r30
    6790:	ff 1f       	adc	r31, r31
    6792:	0a 95       	dec	r16
    6794:	e1 f7       	brne	.-8      	; 0x678e <_hStabilization+0x24e>
    6796:	e8 1b       	sub	r30, r24
    6798:	f9 0b       	sbc	r31, r25
    679a:	e7 52       	subi	r30, 0x27	; 39
    679c:	f9 4f       	sbci	r31, 0xF9	; 249
    679e:	40 81       	ld	r20, Z
    67a0:	51 81       	ldd	r21, Z+1	; 0x01
    67a2:	01 e0       	ldi	r16, 0x01	; 1
    67a4:	80 91 2e 05 	lds	r24, 0x052E
    67a8:	81 30       	cpi	r24, 0x01	; 1
    67aa:	09 f0       	breq	.+2      	; 0x67ae <_hStabilization+0x26e>
    67ac:	00 e0       	ldi	r16, 0x00	; 0
    67ae:	81 e0       	ldi	r24, 0x01	; 1
    67b0:	6e e1       	ldi	r22, 0x1E	; 30
    67b2:	23 e0       	ldi	r18, 0x03	; 3
    67b4:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <LCD_WriteValue>
	LCD_WriteValue(1,84,Config.GyroParams[subindex]._PLimit,3,2==subpage);
    67b8:	80 91 2f 05 	lds	r24, 0x052F
    67bc:	90 e0       	ldi	r25, 0x00	; 0
    67be:	88 0f       	add	r24, r24
    67c0:	99 1f       	adc	r25, r25
    67c2:	fc 01       	movw	r30, r24
    67c4:	a3 e0       	ldi	r26, 0x03	; 3
    67c6:	ee 0f       	add	r30, r30
    67c8:	ff 1f       	adc	r31, r31
    67ca:	aa 95       	dec	r26
    67cc:	e1 f7       	brne	.-8      	; 0x67c6 <_hStabilization+0x286>
    67ce:	e8 1b       	sub	r30, r24
    67d0:	f9 0b       	sbc	r31, r25
    67d2:	e7 52       	subi	r30, 0x27	; 39
    67d4:	f9 4f       	sbci	r31, 0xF9	; 249
    67d6:	40 89       	ldd	r20, Z+16	; 0x10
    67d8:	51 89       	ldd	r21, Z+17	; 0x11
    67da:	01 e0       	ldi	r16, 0x01	; 1
    67dc:	80 91 2e 05 	lds	r24, 0x052E
    67e0:	82 30       	cpi	r24, 0x02	; 2
    67e2:	09 f0       	breq	.+2      	; 0x67e6 <_hStabilization+0x2a6>
    67e4:	00 e0       	ldi	r16, 0x00	; 0
    67e6:	81 e0       	ldi	r24, 0x01	; 1
    67e8:	64 e5       	ldi	r22, 0x54	; 84
    67ea:	23 e0       	ldi	r18, 0x03	; 3
    67ec:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <LCD_WriteValue>
	LCD_WriteValue(2,30,Config.GyroParams[subindex]._I,3,3==subpage);
    67f0:	80 91 2f 05 	lds	r24, 0x052F
    67f4:	90 e0       	ldi	r25, 0x00	; 0
    67f6:	88 0f       	add	r24, r24
    67f8:	99 1f       	adc	r25, r25
    67fa:	fc 01       	movw	r30, r24
    67fc:	73 e0       	ldi	r23, 0x03	; 3
    67fe:	ee 0f       	add	r30, r30
    6800:	ff 1f       	adc	r31, r31
    6802:	7a 95       	dec	r23
    6804:	e1 f7       	brne	.-8      	; 0x67fe <_hStabilization+0x2be>
    6806:	e8 1b       	sub	r30, r24
    6808:	f9 0b       	sbc	r31, r25
    680a:	e7 52       	subi	r30, 0x27	; 39
    680c:	f9 4f       	sbci	r31, 0xF9	; 249
    680e:	42 89       	ldd	r20, Z+18	; 0x12
    6810:	53 89       	ldd	r21, Z+19	; 0x13
    6812:	01 e0       	ldi	r16, 0x01	; 1
    6814:	80 91 2e 05 	lds	r24, 0x052E
    6818:	83 30       	cpi	r24, 0x03	; 3
    681a:	09 f0       	breq	.+2      	; 0x681e <_hStabilization+0x2de>
    681c:	00 e0       	ldi	r16, 0x00	; 0
    681e:	82 e0       	ldi	r24, 0x02	; 2
    6820:	6e e1       	ldi	r22, 0x1E	; 30
    6822:	23 e0       	ldi	r18, 0x03	; 3
    6824:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <LCD_WriteValue>
	LCD_WriteValue(2,84,Config.GyroParams[subindex]._ILimit,3,4==subpage);
    6828:	80 91 2f 05 	lds	r24, 0x052F
    682c:	90 e0       	ldi	r25, 0x00	; 0
    682e:	88 0f       	add	r24, r24
    6830:	99 1f       	adc	r25, r25
    6832:	fc 01       	movw	r30, r24
    6834:	53 e0       	ldi	r21, 0x03	; 3
    6836:	ee 0f       	add	r30, r30
    6838:	ff 1f       	adc	r31, r31
    683a:	5a 95       	dec	r21
    683c:	e1 f7       	brne	.-8      	; 0x6836 <_hStabilization+0x2f6>
    683e:	e8 1b       	sub	r30, r24
    6840:	f9 0b       	sbc	r31, r25
    6842:	e7 52       	subi	r30, 0x27	; 39
    6844:	f9 4f       	sbci	r31, 0xF9	; 249
    6846:	44 89       	ldd	r20, Z+20	; 0x14
    6848:	55 89       	ldd	r21, Z+21	; 0x15
    684a:	01 e0       	ldi	r16, 0x01	; 1
    684c:	80 91 2e 05 	lds	r24, 0x052E
    6850:	84 30       	cpi	r24, 0x04	; 4
    6852:	09 f0       	breq	.+2      	; 0x6856 <_hStabilization+0x316>
    6854:	00 e0       	ldi	r16, 0x00	; 0
    6856:	82 e0       	ldi	r24, 0x02	; 2
    6858:	64 e5       	ldi	r22, 0x54	; 84
    685a:	23 e0       	ldi	r18, 0x03	; 3
    685c:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <LCD_WriteValue>
	LCD_WriteValue(3,30,Config.GyroParams[subindex]._D,3,5==subpage);
    6860:	80 91 2f 05 	lds	r24, 0x052F
    6864:	90 e0       	ldi	r25, 0x00	; 0
    6866:	88 0f       	add	r24, r24
    6868:	99 1f       	adc	r25, r25
    686a:	fc 01       	movw	r30, r24
    686c:	33 e0       	ldi	r19, 0x03	; 3
    686e:	ee 0f       	add	r30, r30
    6870:	ff 1f       	adc	r31, r31
    6872:	3a 95       	dec	r19
    6874:	e1 f7       	brne	.-8      	; 0x686e <_hStabilization+0x32e>
    6876:	e8 1b       	sub	r30, r24
    6878:	f9 0b       	sbc	r31, r25
    687a:	e7 52       	subi	r30, 0x27	; 39
    687c:	f9 4f       	sbci	r31, 0xF9	; 249
    687e:	46 89       	ldd	r20, Z+22	; 0x16
    6880:	57 89       	ldd	r21, Z+23	; 0x17
    6882:	01 e0       	ldi	r16, 0x01	; 1
    6884:	80 91 2e 05 	lds	r24, 0x052E
    6888:	85 30       	cpi	r24, 0x05	; 5
    688a:	09 f0       	breq	.+2      	; 0x688e <_hStabilization+0x34e>
    688c:	00 e0       	ldi	r16, 0x00	; 0
    688e:	83 e0       	ldi	r24, 0x03	; 3
    6890:	6e e1       	ldi	r22, 0x1E	; 30
    6892:	23 e0       	ldi	r18, 0x03	; 3
    6894:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <LCD_WriteValue>
	LCD_WriteValue(3,84,Config.GyroParams[subindex]._DLimit,3,6==subpage);
    6898:	80 91 2f 05 	lds	r24, 0x052F
    689c:	90 e0       	ldi	r25, 0x00	; 0
    689e:	88 0f       	add	r24, r24
    68a0:	99 1f       	adc	r25, r25
    68a2:	fc 01       	movw	r30, r24
    68a4:	03 e0       	ldi	r16, 0x03	; 3
    68a6:	ee 0f       	add	r30, r30
    68a8:	ff 1f       	adc	r31, r31
    68aa:	0a 95       	dec	r16
    68ac:	e1 f7       	brne	.-8      	; 0x68a6 <_hStabilization+0x366>
    68ae:	e8 1b       	sub	r30, r24
    68b0:	f9 0b       	sbc	r31, r25
    68b2:	e7 52       	subi	r30, 0x27	; 39
    68b4:	f9 4f       	sbci	r31, 0xF9	; 249
    68b6:	40 8d       	ldd	r20, Z+24	; 0x18
    68b8:	51 8d       	ldd	r21, Z+25	; 0x19
    68ba:	01 e0       	ldi	r16, 0x01	; 1
    68bc:	80 91 2e 05 	lds	r24, 0x052E
    68c0:	86 30       	cpi	r24, 0x06	; 6
    68c2:	09 f0       	breq	.+2      	; 0x68c6 <_hStabilization+0x386>
    68c4:	00 e0       	ldi	r16, 0x00	; 0
    68c6:	83 e0       	ldi	r24, 0x03	; 3
    68c8:	64 e5       	ldi	r22, 0x54	; 84
    68ca:	23 e0       	ldi	r18, 0x03	; 3
    68cc:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <LCD_WriteValue>
	LCD_WriteValue(4,84,Config.GyroParams[subindex].ComplementaryFilterAlpha,3,7==subpage);
    68d0:	80 91 2f 05 	lds	r24, 0x052F
    68d4:	90 e0       	ldi	r25, 0x00	; 0
    68d6:	88 0f       	add	r24, r24
    68d8:	99 1f       	adc	r25, r25
    68da:	fc 01       	movw	r30, r24
    68dc:	a3 e0       	ldi	r26, 0x03	; 3
    68de:	ee 0f       	add	r30, r30
    68e0:	ff 1f       	adc	r31, r31
    68e2:	aa 95       	dec	r26
    68e4:	e1 f7       	brne	.-8      	; 0x68de <_hStabilization+0x39e>
    68e6:	e8 1b       	sub	r30, r24
    68e8:	f9 0b       	sbc	r31, r25
    68ea:	e7 52       	subi	r30, 0x27	; 39
    68ec:	f9 4f       	sbci	r31, 0xF9	; 249
    68ee:	42 8d       	ldd	r20, Z+26	; 0x1a
    68f0:	53 8d       	ldd	r21, Z+27	; 0x1b
    68f2:	01 e0       	ldi	r16, 0x01	; 1
    68f4:	80 91 2e 05 	lds	r24, 0x052E
    68f8:	87 30       	cpi	r24, 0x07	; 7
    68fa:	09 f0       	breq	.+2      	; 0x68fe <_hStabilization+0x3be>
    68fc:	00 e0       	ldi	r16, 0x00	; 0
    68fe:	84 e0       	ldi	r24, 0x04	; 4
    6900:	64 e5       	ldi	r22, 0x54	; 84
    6902:	23 e0       	ldi	r18, 0x03	; 3
    6904:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <LCD_WriteValue>
	
	
}
    6908:	0f 91       	pop	r16
    690a:	ef 90       	pop	r14
    690c:	08 95       	ret

0000690e <_hMiscSettings>:
	_helper_DisplayBiStateText(4,84, strYes, strNo, (IS_MISC_SENSOR_SONAR_ENABLED ==true),(subpage==4));
}


void _hMiscSettings()
{
    690e:	cf 92       	push	r12
    6910:	ef 92       	push	r14
    6912:	ff 92       	push	r15
    6914:	0f 93       	push	r16
    6916:	1f 93       	push	r17
	NOKEYRETURN;
    6918:	80 91 a8 05 	lds	r24, 0x05A8
    691c:	88 23       	and	r24, r24
    691e:	09 f4       	brne	.+2      	; 0x6922 <_hMiscSettings+0x14>
    6920:	99 c0       	rjmp	.+306    	; 0x6a54 <_hMiscSettings+0x146>
	PageKey(5);
    6922:	85 e0       	ldi	r24, 0x05	; 5
    6924:	0e 94 d4 2f 	call	0x5fa8	; 0x5fa8 <PageKey>
	
		
	if (KEY4)
    6928:	20 91 a8 05 	lds	r18, 0x05A8
    692c:	24 ff       	sbrs	r18, 4
    692e:	3f c0       	rjmp	.+126    	; 0x69ae <_hMiscSettings+0xa0>
	{
		bValueChanged = true;
    6930:	81 e0       	ldi	r24, 0x01	; 1
    6932:	80 93 2a 05 	sts	0x052A, r24
		currentPage.softkeys = _skMENUSAVE;
    6936:	8b ef       	ldi	r24, 0xFB	; 251
    6938:	9b e0       	ldi	r25, 0x0B	; 11
    693a:	90 93 31 05 	sts	0x0531, r25
    693e:	80 93 30 05 	sts	0x0530, r24
		
		switch (subpage)
    6942:	80 91 2e 05 	lds	r24, 0x052E
    6946:	82 30       	cpi	r24, 0x02	; 2
    6948:	d1 f0       	breq	.+52     	; 0x697e <_hMiscSettings+0x70>
    694a:	83 30       	cpi	r24, 0x03	; 3
    694c:	28 f4       	brcc	.+10     	; 0x6958 <_hMiscSettings+0x4a>
    694e:	88 23       	and	r24, r24
    6950:	41 f0       	breq	.+16     	; 0x6962 <_hMiscSettings+0x54>
    6952:	81 30       	cpi	r24, 0x01	; 1
    6954:	61 f5       	brne	.+88     	; 0x69ae <_hMiscSettings+0xa0>
    6956:	0c c0       	rjmp	.+24     	; 0x6970 <_hMiscSettings+0x62>
    6958:	83 30       	cpi	r24, 0x03	; 3
    695a:	c1 f0       	breq	.+48     	; 0x698c <_hMiscSettings+0x7e>
    695c:	84 30       	cpi	r24, 0x04	; 4
    695e:	39 f5       	brne	.+78     	; 0x69ae <_hMiscSettings+0xa0>
    6960:	1f c0       	rjmp	.+62     	; 0x69a0 <_hMiscSettings+0x92>
		{
			case 0: startEditMode(&(Config.AutoDisarm),0,10,TYPE_UINT8); return ;
    6962:	8e ed       	ldi	r24, 0xDE	; 222
    6964:	96 e0       	ldi	r25, 0x06	; 6
    6966:	60 e0       	ldi	r22, 0x00	; 0
    6968:	70 e0       	ldi	r23, 0x00	; 0
    696a:	4a e0       	ldi	r20, 0x0A	; 10
    696c:	50 e0       	ldi	r21, 0x00	; 0
    696e:	14 c0       	rjmp	.+40     	; 0x6998 <_hMiscSettings+0x8a>
			case 1: startEditMode(&(Config.VoltageAlarm),0,100,TYPE_UINT8);  return ;
    6970:	89 e4       	ldi	r24, 0x49	; 73
    6972:	97 e0       	ldi	r25, 0x07	; 7
    6974:	60 e0       	ldi	r22, 0x00	; 0
    6976:	70 e0       	ldi	r23, 0x00	; 0
    6978:	44 e6       	ldi	r20, 0x64	; 100
    697a:	50 e0       	ldi	r21, 0x00	; 0
    697c:	0d c0       	rjmp	.+26     	; 0x6998 <_hMiscSettings+0x8a>
			case 2: startEditMode(&(Config.ThrottleMin),0,255,TYPE_UINT8);  return ;
    697e:	84 ee       	ldi	r24, 0xE4	; 228
    6980:	96 e0       	ldi	r25, 0x06	; 6
    6982:	60 e0       	ldi	r22, 0x00	; 0
    6984:	70 e0       	ldi	r23, 0x00	; 0
    6986:	4f ef       	ldi	r20, 0xFF	; 255
    6988:	50 e0       	ldi	r21, 0x00	; 0
    698a:	06 c0       	rjmp	.+12     	; 0x6998 <_hMiscSettings+0x8a>
			case 3: startEditMode(&(Config.StickScaling),1,20,TYPE_UINT8);  return ;
    698c:	85 ee       	ldi	r24, 0xE5	; 229
    698e:	96 e0       	ldi	r25, 0x06	; 6
    6990:	61 e0       	ldi	r22, 0x01	; 1
    6992:	70 e0       	ldi	r23, 0x00	; 0
    6994:	44 e1       	ldi	r20, 0x14	; 20
    6996:	50 e0       	ldi	r21, 0x00	; 0
    6998:	22 e0       	ldi	r18, 0x02	; 2
    699a:	0e 94 86 2f 	call	0x5f0c	; 0x5f0c <startEditMode>
    699e:	5a c0       	rjmp	.+180    	; 0x6a54 <_hMiscSettings+0x146>
			case 4:	Config.PitchRollLinked=  ((~Config.PitchRollLinked) & 0x01); break; 
    69a0:	90 91 91 07 	lds	r25, 0x0791
    69a4:	81 e0       	ldi	r24, 0x01	; 1
    69a6:	90 fd       	sbrc	r25, 0
    69a8:	80 e0       	ldi	r24, 0x00	; 0
    69aa:	80 93 91 07 	sts	0x0791, r24
		}
		
	}
	
	if (KEY1)
    69ae:	27 ff       	sbrs	r18, 7
    69b0:	02 c0       	rjmp	.+4      	; 0x69b6 <_hMiscSettings+0xa8>
	{
		_helper_SaveinEEPROM_ifChanged();
    69b2:	0e 94 7e 2b 	call	0x56fc	; 0x56fc <_helper_SaveinEEPROM_ifChanged>
	}
	
	LCD_WriteValue(0,84,Config.AutoDisarm,3,0==subpage);
    69b6:	40 91 de 06 	lds	r20, 0x06DE
    69ba:	01 e0       	ldi	r16, 0x01	; 1
    69bc:	80 91 2e 05 	lds	r24, 0x052E
    69c0:	81 11       	cpse	r24, r1
    69c2:	00 e0       	ldi	r16, 0x00	; 0
    69c4:	80 e0       	ldi	r24, 0x00	; 0
    69c6:	64 e5       	ldi	r22, 0x54	; 84
    69c8:	50 e0       	ldi	r21, 0x00	; 0
    69ca:	23 e0       	ldi	r18, 0x03	; 3
    69cc:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <LCD_WriteValue>
	LCD_WriteValue(1,84,Config.VoltageAlarm,3,1==subpage);
    69d0:	40 91 49 07 	lds	r20, 0x0749
    69d4:	01 e0       	ldi	r16, 0x01	; 1
    69d6:	80 91 2e 05 	lds	r24, 0x052E
    69da:	81 30       	cpi	r24, 0x01	; 1
    69dc:	09 f0       	breq	.+2      	; 0x69e0 <_hMiscSettings+0xd2>
    69de:	00 e0       	ldi	r16, 0x00	; 0
    69e0:	81 e0       	ldi	r24, 0x01	; 1
    69e2:	64 e5       	ldi	r22, 0x54	; 84
    69e4:	50 e0       	ldi	r21, 0x00	; 0
    69e6:	23 e0       	ldi	r18, 0x03	; 3
    69e8:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <LCD_WriteValue>
	LCD_WriteValue(2,84,Config.ThrottleMin,3,2==subpage);
    69ec:	40 91 e4 06 	lds	r20, 0x06E4
    69f0:	01 e0       	ldi	r16, 0x01	; 1
    69f2:	80 91 2e 05 	lds	r24, 0x052E
    69f6:	82 30       	cpi	r24, 0x02	; 2
    69f8:	09 f0       	breq	.+2      	; 0x69fc <_hMiscSettings+0xee>
    69fa:	00 e0       	ldi	r16, 0x00	; 0
    69fc:	82 e0       	ldi	r24, 0x02	; 2
    69fe:	64 e5       	ldi	r22, 0x54	; 84
    6a00:	50 e0       	ldi	r21, 0x00	; 0
    6a02:	23 e0       	ldi	r18, 0x03	; 3
    6a04:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <LCD_WriteValue>
	LCD_WriteValue(3,84,Config.StickScaling,3,3==subpage);
    6a08:	40 91 e5 06 	lds	r20, 0x06E5
    6a0c:	01 e0       	ldi	r16, 0x01	; 1
    6a0e:	80 91 2e 05 	lds	r24, 0x052E
    6a12:	83 30       	cpi	r24, 0x03	; 3
    6a14:	09 f0       	breq	.+2      	; 0x6a18 <_hMiscSettings+0x10a>
    6a16:	00 e0       	ldi	r16, 0x00	; 0
    6a18:	83 e0       	ldi	r24, 0x03	; 3
    6a1a:	64 e5       	ldi	r22, 0x54	; 84
    6a1c:	50 e0       	ldi	r21, 0x00	; 0
    6a1e:	23 e0       	ldi	r18, 0x03	; 3
    6a20:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <LCD_WriteValue>
	_helper_Words (4,84,(4==subpage),(Config.PitchRollLinked),PSTR("yes"),PSTR("no "),5);
    6a24:	41 e0       	ldi	r20, 0x01	; 1
    6a26:	80 91 2e 05 	lds	r24, 0x052E
    6a2a:	84 30       	cpi	r24, 0x04	; 4
    6a2c:	09 f0       	breq	.+2      	; 0x6a30 <_hMiscSettings+0x122>
    6a2e:	40 e0       	ldi	r20, 0x00	; 0
    6a30:	21 e0       	ldi	r18, 0x01	; 1
    6a32:	80 91 91 07 	lds	r24, 0x0791
    6a36:	88 23       	and	r24, r24
    6a38:	09 f4       	brne	.+2      	; 0x6a3c <_hMiscSettings+0x12e>
    6a3a:	20 e0       	ldi	r18, 0x00	; 0
    6a3c:	84 e0       	ldi	r24, 0x04	; 4
    6a3e:	64 e5       	ldi	r22, 0x54	; 84
    6a40:	0b e8       	ldi	r16, 0x8B	; 139
    6a42:	1c e0       	ldi	r17, 0x0C	; 12
    6a44:	f7 e8       	ldi	r31, 0x87	; 135
    6a46:	ef 2e       	mov	r14, r31
    6a48:	fc e0       	ldi	r31, 0x0C	; 12
    6a4a:	ff 2e       	mov	r15, r31
    6a4c:	e5 e0       	ldi	r30, 0x05	; 5
    6a4e:	ce 2e       	mov	r12, r30
    6a50:	0e 94 8b 2d 	call	0x5b16	; 0x5b16 <_helper_Words>
	
		
}
    6a54:	1f 91       	pop	r17
    6a56:	0f 91       	pop	r16
    6a58:	ff 90       	pop	r15
    6a5a:	ef 90       	pop	r14
    6a5c:	cf 90       	pop	r12
    6a5e:	08 95       	ret

00006a60 <_hModeSettings>:
	
}

bool bNeedRestart=false;
void _hModeSettings ()
{
    6a60:	cf 92       	push	r12
    6a62:	ef 92       	push	r14
    6a64:	ff 92       	push	r15
    6a66:	0f 93       	push	r16
    6a68:	1f 93       	push	r17
	NOKEYRETURN;
    6a6a:	80 91 a8 05 	lds	r24, 0x05A8
    6a6e:	88 23       	and	r24, r24
    6a70:	09 f4       	brne	.+2      	; 0x6a74 <_hModeSettings+0x14>
    6a72:	db c0       	rjmp	.+438    	; 0x6c2a <_hModeSettings+0x1ca>
	PageKey(5);
    6a74:	85 e0       	ldi	r24, 0x05	; 5
    6a76:	0e 94 d4 2f 	call	0x5fa8	; 0x5fa8 <PageKey>
	
	if ((KEY1) && (bValueChanged==true))
    6a7a:	80 91 a8 05 	lds	r24, 0x05A8
    6a7e:	87 ff       	sbrs	r24, 7
    6a80:	0f c0       	rjmp	.+30     	; 0x6aa0 <_hModeSettings+0x40>
    6a82:	90 91 2a 05 	lds	r25, 0x052A
    6a86:	91 30       	cpi	r25, 0x01	; 1
    6a88:	59 f4       	brne	.+22     	; 0x6aa0 <_hModeSettings+0x40>
	{
		_helper_SaveinEEPROM_ifChanged();
    6a8a:	0e 94 7e 2b 	call	0x56fc	; 0x56fc <_helper_SaveinEEPROM_ifChanged>
		if (bNeedRestart==true) Menu_LoadPage(PAGE_RESTART);
    6a8e:	80 91 2b 05 	lds	r24, 0x052B
    6a92:	88 23       	and	r24, r24
    6a94:	09 f4       	brne	.+2      	; 0x6a98 <_hModeSettings+0x38>
    6a96:	c9 c0       	rjmp	.+402    	; 0x6c2a <_hModeSettings+0x1ca>
    6a98:	84 e0       	ldi	r24, 0x04	; 4
    6a9a:	0e 94 a1 2d 	call	0x5b42	; 0x5b42 <Menu_LoadPage>
    6a9e:	c5 c0       	rjmp	.+394    	; 0x6c2a <_hModeSettings+0x1ca>
		return;
	}
	
	if (KEY4)
    6aa0:	84 ff       	sbrs	r24, 4
    6aa2:	3d c0       	rjmp	.+122    	; 0x6b1e <_hModeSettings+0xbe>
	{
		bValueChanged = true;
    6aa4:	91 e0       	ldi	r25, 0x01	; 1
    6aa6:	90 93 2a 05 	sts	0x052A, r25
		//currentPage.softkeys = _skMENUSAVE;
		switch (subpage)
    6aaa:	80 91 2e 05 	lds	r24, 0x052E
    6aae:	82 30       	cpi	r24, 0x02	; 2
    6ab0:	f9 f0       	breq	.+62     	; 0x6af0 <_hModeSettings+0x90>
    6ab2:	83 30       	cpi	r24, 0x03	; 3
    6ab4:	28 f4       	brcc	.+10     	; 0x6ac0 <_hModeSettings+0x60>
    6ab6:	88 23       	and	r24, r24
    6ab8:	41 f0       	breq	.+16     	; 0x6aca <_hModeSettings+0x6a>
    6aba:	81 30       	cpi	r24, 0x01	; 1
    6abc:	81 f5       	brne	.+96     	; 0x6b1e <_hModeSettings+0xbe>
    6abe:	10 c0       	rjmp	.+32     	; 0x6ae0 <_hModeSettings+0x80>
    6ac0:	83 30       	cpi	r24, 0x03	; 3
    6ac2:	f1 f0       	breq	.+60     	; 0x6b00 <_hModeSettings+0xa0>
    6ac4:	84 30       	cpi	r24, 0x04	; 4
    6ac6:	59 f5       	brne	.+86     	; 0x6b1e <_hModeSettings+0xbe>
    6ac8:	23 c0       	rjmp	.+70     	; 0x6b10 <_hModeSettings+0xb0>
		{
			case 0: if (Config.FrameType==FRAMETYPE_QUADCOPTER) Config.FrameType=FRAMETYPE_TRICOPTER; else Config.FrameType=FRAMETYPE_QUADCOPTER; break;
    6aca:	80 91 e0 06 	lds	r24, 0x06E0
    6ace:	81 30       	cpi	r24, 0x01	; 1
    6ad0:	21 f4       	brne	.+8      	; 0x6ada <_hModeSettings+0x7a>
    6ad2:	82 e0       	ldi	r24, 0x02	; 2
    6ad4:	80 93 e0 06 	sts	0x06E0, r24
    6ad8:	22 c0       	rjmp	.+68     	; 0x6b1e <_hModeSettings+0xbe>
    6ada:	90 93 e0 06 	sts	0x06E0, r25
    6ade:	1f c0       	rjmp	.+62     	; 0x6b1e <_hModeSettings+0xbe>
			case 1: Config.RX_mode=~Config.RX_mode; bNeedRestart = true; break;
    6ae0:	90 91 db 06 	lds	r25, 0x06DB
    6ae4:	90 95       	com	r25
    6ae6:	90 93 db 06 	sts	0x06DB, r25
    6aea:	80 93 2b 05 	sts	0x052B, r24
    6aee:	17 c0       	rjmp	.+46     	; 0x6b1e <_hModeSettings+0xbe>
			case 2: Config.BoardOrientationMode=((~Config.BoardOrientationMode) & 0x01); /* value either 0 or 1*/break;
    6af0:	90 91 e1 06 	lds	r25, 0x06E1
    6af4:	81 e0       	ldi	r24, 0x01	; 1
    6af6:	90 fd       	sbrc	r25, 0
    6af8:	80 e0       	ldi	r24, 0x00	; 0
    6afa:	80 93 e1 06 	sts	0x06E1, r24
    6afe:	0f c0       	rjmp	.+30     	; 0x6b1e <_hModeSettings+0xbe>
			case 3: Config.QuadFlyingMode = ((~Config.QuadFlyingMode) & 0x01); /* value either 0 or 1*/break;
    6b00:	90 91 e2 06 	lds	r25, 0x06E2
    6b04:	81 e0       	ldi	r24, 0x01	; 1
    6b06:	90 fd       	sbrc	r25, 0
    6b08:	80 e0       	ldi	r24, 0x00	; 0
    6b0a:	80 93 e2 06 	sts	0x06E2, r24
    6b0e:	07 c0       	rjmp	.+14     	; 0x6b1e <_hModeSettings+0xbe>
			case 4: Config.MiscSensors =  ((~Config.MiscSensors) & 0x01); break; // this condition should be rewritten if another sensor is added.
    6b10:	90 91 e6 06 	lds	r25, 0x06E6
    6b14:	81 e0       	ldi	r24, 0x01	; 1
    6b16:	90 fd       	sbrc	r25, 0
    6b18:	80 e0       	ldi	r24, 0x00	; 0
    6b1a:	80 93 e6 06 	sts	0x06E6, r24
		}
	}
	
	_helper_Words  (0,84,(subpage==0),(Config.FrameType== FRAMETYPE_QUADCOPTER),PSTR("Quad"),PSTR("TRI "),5);
    6b1e:	41 e0       	ldi	r20, 0x01	; 1
    6b20:	80 91 2e 05 	lds	r24, 0x052E
    6b24:	81 11       	cpse	r24, r1
    6b26:	40 e0       	ldi	r20, 0x00	; 0
    6b28:	21 e0       	ldi	r18, 0x01	; 1
    6b2a:	80 91 e0 06 	lds	r24, 0x06E0
    6b2e:	81 30       	cpi	r24, 0x01	; 1
    6b30:	09 f0       	breq	.+2      	; 0x6b34 <_hModeSettings+0xd4>
    6b32:	20 e0       	ldi	r18, 0x00	; 0
    6b34:	80 e0       	ldi	r24, 0x00	; 0
    6b36:	64 e5       	ldi	r22, 0x54	; 84
    6b38:	02 ed       	ldi	r16, 0xD2	; 210
    6b3a:	1c e0       	ldi	r17, 0x0C	; 12
    6b3c:	ad ec       	ldi	r26, 0xCD	; 205
    6b3e:	ea 2e       	mov	r14, r26
    6b40:	ac e0       	ldi	r26, 0x0C	; 12
    6b42:	fa 2e       	mov	r15, r26
    6b44:	f5 e0       	ldi	r31, 0x05	; 5
    6b46:	cf 2e       	mov	r12, r31
    6b48:	0e 94 8b 2d 	call	0x5b16	; 0x5b16 <_helper_Words>
	_helper_Words  (1,84,(subpage==1),(Config.RX_mode== RX_mode_BuddyMode),PSTR("Buddy"),PSTR("UART "),5);
    6b4c:	41 e0       	ldi	r20, 0x01	; 1
    6b4e:	80 91 2e 05 	lds	r24, 0x052E
    6b52:	81 30       	cpi	r24, 0x01	; 1
    6b54:	09 f0       	breq	.+2      	; 0x6b58 <_hModeSettings+0xf8>
    6b56:	40 e0       	ldi	r20, 0x00	; 0
    6b58:	21 e0       	ldi	r18, 0x01	; 1
    6b5a:	80 91 db 06 	lds	r24, 0x06DB
    6b5e:	81 11       	cpse	r24, r1
    6b60:	20 e0       	ldi	r18, 0x00	; 0
    6b62:	81 e0       	ldi	r24, 0x01	; 1
    6b64:	64 e5       	ldi	r22, 0x54	; 84
    6b66:	07 ec       	ldi	r16, 0xC7	; 199
    6b68:	1c e0       	ldi	r17, 0x0C	; 12
    6b6a:	e1 ec       	ldi	r30, 0xC1	; 193
    6b6c:	ee 2e       	mov	r14, r30
    6b6e:	ec e0       	ldi	r30, 0x0C	; 12
    6b70:	fe 2e       	mov	r15, r30
    6b72:	75 e0       	ldi	r23, 0x05	; 5
    6b74:	c7 2e       	mov	r12, r23
    6b76:	0e 94 8b 2d 	call	0x5b16	; 0x5b16 <_helper_Words>
	_helper_Words (2,84,(subpage==2),(Config.BoardOrientationMode == QuadFlyingMode_PLUS),PSTR("+ Quad"),PSTR("X Quad"),6);
    6b7a:	41 e0       	ldi	r20, 0x01	; 1
    6b7c:	80 91 2e 05 	lds	r24, 0x052E
    6b80:	82 30       	cpi	r24, 0x02	; 2
    6b82:	09 f0       	breq	.+2      	; 0x6b86 <_hModeSettings+0x126>
    6b84:	40 e0       	ldi	r20, 0x00	; 0
    6b86:	21 e0       	ldi	r18, 0x01	; 1
    6b88:	80 91 e1 06 	lds	r24, 0x06E1
    6b8c:	81 11       	cpse	r24, r1
    6b8e:	20 e0       	ldi	r18, 0x00	; 0
    6b90:	82 e0       	ldi	r24, 0x02	; 2
    6b92:	64 e5       	ldi	r22, 0x54	; 84
    6b94:	0a eb       	ldi	r16, 0xBA	; 186
    6b96:	1c e0       	ldi	r17, 0x0C	; 12
    6b98:	53 eb       	ldi	r21, 0xB3	; 179
    6b9a:	e5 2e       	mov	r14, r21
    6b9c:	5c e0       	ldi	r21, 0x0C	; 12
    6b9e:	f5 2e       	mov	r15, r21
    6ba0:	36 e0       	ldi	r19, 0x06	; 6
    6ba2:	c3 2e       	mov	r12, r19
    6ba4:	0e 94 8b 2d 	call	0x5b16	; 0x5b16 <_helper_Words>
	if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    6ba8:	90 91 e0 06 	lds	r25, 0x06E0
    6bac:	80 91 2e 05 	lds	r24, 0x052E
    6bb0:	91 30       	cpi	r25, 0x01	; 1
    6bb2:	91 f4       	brne	.+36     	; 0x6bd8 <_hModeSettings+0x178>
	{
		_helper_Words (3,84,(subpage==3),(Config.QuadFlyingMode == QuadFlyingMode_PLUS),PSTR("+ Quad"),PSTR("X Quad"),6);
    6bb4:	41 e0       	ldi	r20, 0x01	; 1
    6bb6:	83 30       	cpi	r24, 0x03	; 3
    6bb8:	09 f0       	breq	.+2      	; 0x6bbc <_hModeSettings+0x15c>
    6bba:	40 e0       	ldi	r20, 0x00	; 0
    6bbc:	21 e0       	ldi	r18, 0x01	; 1
    6bbe:	80 91 e2 06 	lds	r24, 0x06E2
    6bc2:	81 11       	cpse	r24, r1
    6bc4:	20 e0       	ldi	r18, 0x00	; 0
    6bc6:	83 e0       	ldi	r24, 0x03	; 3
    6bc8:	64 e5       	ldi	r22, 0x54	; 84
    6bca:	0c ea       	ldi	r16, 0xAC	; 172
    6bcc:	1c e0       	ldi	r17, 0x0C	; 12
    6bce:	95 ea       	ldi	r25, 0xA5	; 165
    6bd0:	e9 2e       	mov	r14, r25
    6bd2:	9c e0       	ldi	r25, 0x0C	; 12
    6bd4:	f9 2e       	mov	r15, r25
    6bd6:	11 c0       	rjmp	.+34     	; 0x6bfa <_hModeSettings+0x19a>
	}
	else
	{
		_helper_Words (3,84,(subpage==3),(Config.QuadFlyingMode == QuadFlyingMode_PLUS),PSTR("Y Tri "),PSTR("A Tri "),6);
    6bd8:	41 e0       	ldi	r20, 0x01	; 1
    6bda:	83 30       	cpi	r24, 0x03	; 3
    6bdc:	09 f0       	breq	.+2      	; 0x6be0 <_hModeSettings+0x180>
    6bde:	40 e0       	ldi	r20, 0x00	; 0
    6be0:	21 e0       	ldi	r18, 0x01	; 1
    6be2:	80 91 e2 06 	lds	r24, 0x06E2
    6be6:	81 11       	cpse	r24, r1
    6be8:	20 e0       	ldi	r18, 0x00	; 0
    6bea:	83 e0       	ldi	r24, 0x03	; 3
    6bec:	64 e5       	ldi	r22, 0x54	; 84
    6bee:	0e e9       	ldi	r16, 0x9E	; 158
    6bf0:	1c e0       	ldi	r17, 0x0C	; 12
    6bf2:	b7 e9       	ldi	r27, 0x97	; 151
    6bf4:	eb 2e       	mov	r14, r27
    6bf6:	bc e0       	ldi	r27, 0x0C	; 12
    6bf8:	fb 2e       	mov	r15, r27
    6bfa:	a6 e0       	ldi	r26, 0x06	; 6
    6bfc:	ca 2e       	mov	r12, r26
    6bfe:	0e 94 8b 2d 	call	0x5b16	; 0x5b16 <_helper_Words>
	}	
	_helper_DisplayBiStateText(4,84, strYes, strNo, (IS_MISC_SENSOR_SONAR_ENABLED ==true),(subpage==4));
    6c02:	00 91 e6 06 	lds	r16, 0x06E6
    6c06:	10 e0       	ldi	r17, 0x00	; 0
    6c08:	01 70       	andi	r16, 0x01	; 1
    6c0a:	10 70       	andi	r17, 0x00	; 0
    6c0c:	91 e0       	ldi	r25, 0x01	; 1
    6c0e:	80 91 2e 05 	lds	r24, 0x052E
    6c12:	84 30       	cpi	r24, 0x04	; 4
    6c14:	09 f0       	breq	.+2      	; 0x6c18 <_hModeSettings+0x1b8>
    6c16:	90 e0       	ldi	r25, 0x00	; 0
    6c18:	84 e0       	ldi	r24, 0x04	; 4
    6c1a:	64 e5       	ldi	r22, 0x54	; 84
    6c1c:	4f e8       	ldi	r20, 0x8F	; 143
    6c1e:	5c e0       	ldi	r21, 0x0C	; 12
    6c20:	23 e9       	ldi	r18, 0x93	; 147
    6c22:	3c e0       	ldi	r19, 0x0C	; 12
    6c24:	e9 2e       	mov	r14, r25
    6c26:	0e 94 52 2b 	call	0x56a4	; 0x56a4 <_helper_DisplayBiStateText>
}
    6c2a:	1f 91       	pop	r17
    6c2c:	0f 91       	pop	r16
    6c2e:	ff 90       	pop	r15
    6c30:	ef 90       	pop	r14
    6c32:	cf 90       	pop	r12
    6c34:	08 95       	ret

00006c36 <doMenu>:

/*
//	Draw the menu
*/
uint8_t doMenu(menu_t *menu)
{
    6c36:	ef 92       	push	r14
    6c38:	ff 92       	push	r15
    6c3a:	0f 93       	push	r16
    6c3c:	1f 93       	push	r17
    6c3e:	cf 93       	push	r28
    6c40:	df 93       	push	r29
    6c42:	ec 01       	movw	r28, r24
	UIEnableStickCommands=true;
    6c44:	81 e0       	ldi	r24, 0x01	; 1
    6c46:	80 93 d2 05 	sts	0x05D2, r24
	
	if (!_mykey) return 0;
    6c4a:	80 91 a8 05 	lds	r24, 0x05A8
    6c4e:	88 23       	and	r24, r24
    6c50:	09 f4       	brne	.+2      	; 0x6c54 <doMenu+0x1e>
    6c52:	70 c0       	rjmp	.+224    	; 0x6d34 <doMenu+0xfe>
	
	// key handling
	if (KEY2)		// UP
    6c54:	86 ff       	sbrs	r24, 6
    6c56:	06 c0       	rjmp	.+12     	; 0x6c64 <doMenu+0x2e>
	{
		if (menu->marked > 0) 
    6c58:	8c 81       	ldd	r24, Y+4	; 0x04
    6c5a:	88 23       	and	r24, r24
    6c5c:	99 f0       	breq	.+38     	; 0x6c84 <doMenu+0x4e>
			menu->marked--;
    6c5e:	81 50       	subi	r24, 0x01	; 1
    6c60:	8c 83       	std	Y+4, r24	; 0x04
    6c62:	10 c0       	rjmp	.+32     	; 0x6c84 <doMenu+0x4e>
	}
	else if (KEY3)		// DOWN
    6c64:	85 ff       	sbrs	r24, 5
    6c66:	0c c0       	rjmp	.+24     	; 0x6c80 <doMenu+0x4a>
	{
		if (menu->marked < menu->len - 1) 
    6c68:	4c 81       	ldd	r20, Y+4	; 0x04
    6c6a:	24 2f       	mov	r18, r20
    6c6c:	30 e0       	ldi	r19, 0x00	; 0
    6c6e:	88 81       	ld	r24, Y
    6c70:	90 e0       	ldi	r25, 0x00	; 0
    6c72:	01 97       	sbiw	r24, 0x01	; 1
    6c74:	28 17       	cp	r18, r24
    6c76:	39 07       	cpc	r19, r25
    6c78:	2c f4       	brge	.+10     	; 0x6c84 <doMenu+0x4e>
			menu->marked++;
    6c7a:	4f 5f       	subi	r20, 0xFF	; 255
    6c7c:	4c 83       	std	Y+4, r20	; 0x04
    6c7e:	02 c0       	rjmp	.+4      	; 0x6c84 <doMenu+0x4e>
	}
	else if (KEY4)		// ENTER
    6c80:	84 fd       	sbrc	r24, 4
    6c82:	56 c0       	rjmp	.+172    	; 0x6d30 <doMenu+0xfa>
		return 1;

	if (menu->marked < menu->top)
    6c84:	2c 81       	ldd	r18, Y+4	; 0x04
    6c86:	3b 81       	ldd	r19, Y+3	; 0x03
    6c88:	23 17       	cp	r18, r19
    6c8a:	40 f0       	brcs	.+16     	; 0x6c9c <doMenu+0x66>
		menu->top = menu->marked;
	else if (menu->marked - menu->top >= 5)
    6c8c:	82 2f       	mov	r24, r18
    6c8e:	90 e0       	ldi	r25, 0x00	; 0
    6c90:	83 1b       	sub	r24, r19
    6c92:	91 09       	sbc	r25, r1
    6c94:	85 30       	cpi	r24, 0x05	; 5
    6c96:	91 05       	cpc	r25, r1
    6c98:	14 f0       	brlt	.+4      	; 0x6c9e <doMenu+0x68>
		menu->top = menu->marked - 4;
    6c9a:	24 50       	subi	r18, 0x04	; 4
    6c9c:	2b 83       	std	Y+3, r18	; 0x03
	
	// text output
	LCD_SetPos(0, 58);
    6c9e:	80 e0       	ldi	r24, 0x00	; 0
    6ca0:	6a e3       	ldi	r22, 0x3A	; 58
    6ca2:	0e 94 03 0c 	call	0x1806	; 0x1806 <LCD_SetPos>
	if (menu->top > 0)
    6ca6:	8b 81       	ldd	r24, Y+3	; 0x03
    6ca8:	88 23       	and	r24, r24
    6caa:	29 f0       	breq	.+10     	; 0x6cb6 <doMenu+0x80>
		lcdWriteGlyph_P(&glyArrowUp, 0);
    6cac:	85 e9       	ldi	r24, 0x95	; 149
    6cae:	99 e0       	ldi	r25, 0x09	; 9
    6cb0:	60 e0       	ldi	r22, 0x00	; 0
    6cb2:	0e 94 c3 0c 	call	0x1986	; 0x1986 <lcdWriteGlyph_P>

/*
//	Draw the menu
*/
uint8_t doMenu(menu_t *menu)
{
    6cb6:	00 e0       	ldi	r16, 0x00	; 0
    6cb8:	10 e0       	ldi	r17, 0x00	; 0
    6cba:	21 c0       	rjmp	.+66     	; 0x6cfe <doMenu+0xc8>
	if (menu->top > 0)
		lcdWriteGlyph_P(&glyArrowUp, 0);
		
	for (uint8_t i = 0; i < 5 && i < menu->len; i++)
	{
		LCD_SetPos(i + 1, 0);
    6cbc:	8e 2d       	mov	r24, r14
    6cbe:	8f 5f       	subi	r24, 0xFF	; 255
    6cc0:	60 e0       	ldi	r22, 0x00	; 0
    6cc2:	0e 94 03 0c 	call	0x1806	; 0x1806 <LCD_SetPos>
		PGM_P item = menu->textSelector(menu->top + i);
    6cc6:	8b 81       	ldd	r24, Y+3	; 0x03
    6cc8:	e9 81       	ldd	r30, Y+1	; 0x01
    6cca:	fa 81       	ldd	r31, Y+2	; 0x02
    6ccc:	8e 0d       	add	r24, r14
    6cce:	09 95       	icall
    6cd0:	7c 01       	movw	r14, r24
		lcdReverse(menu->top + i == menu->marked);
    6cd2:	8b 81       	ldd	r24, Y+3	; 0x03
    6cd4:	a8 01       	movw	r20, r16
    6cd6:	48 0f       	add	r20, r24
    6cd8:	51 1d       	adc	r21, r1
    6cda:	2c 81       	ldd	r18, Y+4	; 0x04
    6cdc:	30 e0       	ldi	r19, 0x00	; 0
    6cde:	81 e0       	ldi	r24, 0x01	; 1
    6ce0:	42 17       	cp	r20, r18
    6ce2:	53 07       	cpc	r21, r19
    6ce4:	09 f0       	breq	.+2      	; 0x6ce8 <doMenu+0xb2>
    6ce6:	80 e0       	ldi	r24, 0x00	; 0
    6ce8:	0e 94 0e 0d 	call	0x1a1c	; 0x1a1c <lcdReverse>
		LCD_WritePadded_P(item, 21);
    6cec:	c7 01       	movw	r24, r14
    6cee:	65 e1       	ldi	r22, 0x15	; 21
    6cf0:	0e 94 6f 0d 	call	0x1ade	; 0x1ade <LCD_WritePadded_P>
    6cf4:	0f 5f       	subi	r16, 0xFF	; 255
    6cf6:	1f 4f       	sbci	r17, 0xFF	; 255
	// text output
	LCD_SetPos(0, 58);
	if (menu->top > 0)
		lcdWriteGlyph_P(&glyArrowUp, 0);
		
	for (uint8_t i = 0; i < 5 && i < menu->len; i++)
    6cf8:	05 30       	cpi	r16, 0x05	; 5
    6cfa:	11 05       	cpc	r17, r1
    6cfc:	21 f0       	breq	.+8      	; 0x6d06 <doMenu+0xd0>
    6cfe:	e0 2e       	mov	r14, r16
    6d00:	88 81       	ld	r24, Y
    6d02:	08 17       	cp	r16, r24
    6d04:	d8 f2       	brcs	.-74     	; 0x6cbc <doMenu+0x86>
		PGM_P item = menu->textSelector(menu->top + i);
		lcdReverse(menu->top + i == menu->marked);
		LCD_WritePadded_P(item, 21);
	}

	lcdReverse(0);
    6d06:	80 e0       	ldi	r24, 0x00	; 0
    6d08:	0e 94 0e 0d 	call	0x1a1c	; 0x1a1c <lcdReverse>


	LCD_SetPos(6, 58);
    6d0c:	86 e0       	ldi	r24, 0x06	; 6
    6d0e:	6a e3       	ldi	r22, 0x3A	; 58
    6d10:	0e 94 03 0c 	call	0x1806	; 0x1806 <LCD_SetPos>
	if (menu->top < menu->len - 5)
    6d14:	2b 81       	ldd	r18, Y+3	; 0x03
    6d16:	30 e0       	ldi	r19, 0x00	; 0
    6d18:	88 81       	ld	r24, Y
    6d1a:	90 e0       	ldi	r25, 0x00	; 0
    6d1c:	05 97       	sbiw	r24, 0x05	; 5
    6d1e:	28 17       	cp	r18, r24
    6d20:	39 07       	cpc	r19, r25
    6d22:	44 f4       	brge	.+16     	; 0x6d34 <doMenu+0xfe>
		lcdWriteGlyph_P(&glyArrowDown, 0);
    6d24:	8f e9       	ldi	r24, 0x9F	; 159
    6d26:	99 e0       	ldi	r25, 0x09	; 9
    6d28:	60 e0       	ldi	r22, 0x00	; 0
    6d2a:	0e 94 c3 0c 	call	0x1986	; 0x1986 <lcdWriteGlyph_P>
    6d2e:	02 c0       	rjmp	.+4      	; 0x6d34 <doMenu+0xfe>
	{
		if (menu->marked < menu->len - 1) 
			menu->marked++;
	}
	else if (KEY4)		// ENTER
		return 1;
    6d30:	81 e0       	ldi	r24, 0x01	; 1
    6d32:	01 c0       	rjmp	.+2      	; 0x6d36 <doMenu+0x100>

	LCD_SetPos(6, 58);
	if (menu->top < menu->len - 5)
		lcdWriteGlyph_P(&glyArrowDown, 0);
	
	return 0;
    6d34:	80 e0       	ldi	r24, 0x00	; 0
}
    6d36:	df 91       	pop	r29
    6d38:	cf 91       	pop	r28
    6d3a:	1f 91       	pop	r17
    6d3c:	0f 91       	pop	r16
    6d3e:	ff 90       	pop	r15
    6d40:	ef 90       	pop	r14
    6d42:	08 95       	ret

00006d44 <_hMenu>:


void _hMenu()
{
	if (doMenu(&mnuMain))
    6d44:	8e e0       	ldi	r24, 0x0E	; 14
    6d46:	91 e0       	ldi	r25, 0x01	; 1
    6d48:	0e 94 1b 36 	call	0x6c36	; 0x6c36 <doMenu>
    6d4c:	88 23       	and	r24, r24
    6d4e:	91 f0       	breq	.+36     	; 0x6d74 <_hMenu+0x30>
	{	// if menu item selected then open it if...
		if (menuEnabled[mnuMain.marked + MENU_START_INDEX]==1)
    6d50:	80 91 12 01 	lds	r24, 0x0112
    6d54:	e8 2f       	mov	r30, r24
    6d56:	f0 e0       	ldi	r31, 0x00	; 0
    6d58:	e4 55       	subi	r30, 0x54	; 84
    6d5a:	f8 4f       	sbci	r31, 0xF8	; 248
    6d5c:	95 81       	ldd	r25, Z+5	; 0x05
    6d5e:	91 30       	cpi	r25, 0x01	; 1
    6d60:	21 f4       	brne	.+8      	; 0x6d6a <_hMenu+0x26>
		{ //... the menu item is enabled 
			Menu_LoadPage(mnuMain.marked + MENU_START_INDEX);
    6d62:	8b 5f       	subi	r24, 0xFB	; 251
    6d64:	0e 94 a1 2d 	call	0x5b42	; 0x5b42 <Menu_LoadPage>
    6d68:	08 95       	ret
		}
		else
		{ //... else flash light and ignore command
			LED_FlashOrangeLED(LED_SHORT_TOGGLE,2);
    6d6a:	8e e1       	ldi	r24, 0x1E	; 30
    6d6c:	90 e0       	ldi	r25, 0x00	; 0
    6d6e:	62 e0       	ldi	r22, 0x02	; 2
    6d70:	0e 94 8e 0e 	call	0x1d1c	; 0x1d1c <LED_FlashOrangeLED>
    6d74:	08 95       	ret

00006d76 <Menu_MenuShow>:

void Menu_MenuShow()
{
	
	
	_mykey = Keyboard_Read();
    6d76:	0e 94 b3 0b 	call	0x1766	; 0x1766 <Keyboard_Read>
	_mykey = _mykey | _TXKeys;
    6d7a:	90 91 b4 06 	lds	r25, 0x06B4
    6d7e:	98 2b       	or	r25, r24
    6d80:	90 93 a8 05 	sts	0x05A8, r25

	
	LCD_Disable();
    6d84:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <LCD_Disable>
	if (oldPage != page)
    6d88:	90 91 2d 05 	lds	r25, 0x052D
    6d8c:	80 91 2c 05 	lds	r24, 0x052C
    6d90:	89 17       	cp	r24, r25
    6d92:	59 f0       	breq	.+22     	; 0x6daa <Menu_MenuShow+0x34>
	{	// if this is a new page then KEY_INIT = true
		_mykey |= KEY_INIT;
    6d94:	80 91 a8 05 	lds	r24, 0x05A8
    6d98:	81 60       	ori	r24, 0x01	; 1
    6d9a:	80 93 a8 05 	sts	0x05A8, r24
		subpage = 0;
    6d9e:	10 92 2e 05 	sts	0x052E, r1
		subindex = 0;
    6da2:	10 92 2f 05 	sts	0x052F, r1
		oldPage = page;
    6da6:	90 93 2c 05 	sts	0x052C, r25
	}
	defaultHandler();
    6daa:	0e 94 dd 2e 	call	0x5dba	; 0x5dba <defaultHandler>
	LCD_Enable();
    6dae:	0e 94 2f 0e 	call	0x1c5e	; 0x1c5e <LCD_Enable>

	
	
	if (KEY1 && !editMode)	// BACK
    6db2:	80 91 a8 05 	lds	r24, 0x05A8
    6db6:	87 ff       	sbrs	r24, 7
    6db8:	15 c0       	rjmp	.+42     	; 0x6de4 <Menu_MenuShow+0x6e>
    6dba:	80 91 c2 07 	lds	r24, 0x07C2
    6dbe:	88 23       	and	r24, r24
    6dc0:	89 f4       	brne	.+34     	; 0x6de4 <Menu_MenuShow+0x6e>
	{
		if (page > PAGE_MENU) // if any page then go to main menu
    6dc2:	80 91 2d 05 	lds	r24, 0x052D
    6dc6:	82 30       	cpi	r24, 0x02	; 2
    6dc8:	10 f0       	brcs	.+4      	; 0x6dce <Menu_MenuShow+0x58>
			Menu_LoadPage(PAGE_MENU);
    6dca:	81 e0       	ldi	r24, 0x01	; 1
    6dcc:	09 c0       	rjmp	.+18     	; 0x6de0 <Menu_MenuShow+0x6a>
		else if (page == PAGE_MENU)  // if menu page then goto HomePage
    6dce:	81 30       	cpi	r24, 0x01	; 1
    6dd0:	49 f4       	brne	.+18     	; 0x6de4 <Menu_MenuShow+0x6e>
			{
				if (IsArmed == true)
    6dd2:	80 91 92 07 	lds	r24, 0x0792
    6dd6:	81 30       	cpi	r24, 0x01	; 1
    6dd8:	11 f4       	brne	.+4      	; 0x6dde <Menu_MenuShow+0x68>
				{
					Menu_LoadPage(PAGE_HOME_ARMED);
    6dda:	82 e0       	ldi	r24, 0x02	; 2
    6ddc:	01 c0       	rjmp	.+2      	; 0x6de0 <Menu_MenuShow+0x6a>
				}
				else
				{
					Menu_LoadPage(PAGE_HOME);
    6dde:	80 e0       	ldi	r24, 0x00	; 0
    6de0:	0e 94 a1 2d 	call	0x5b42	; 0x5b42 <Menu_LoadPage>
				}
			}							
	}
	
	
	if (KEYPRESS)
    6de4:	80 91 a8 05 	lds	r24, 0x05A8
    6de8:	80 7f       	andi	r24, 0xF0	; 240
    6dea:	29 f0       	breq	.+10     	; 0x6df6 <Menu_MenuShow+0x80>
		Beeper_Beep(BEEP_KEY,1);
    6dec:	86 e4       	ldi	r24, 0x46	; 70
    6dee:	90 e0       	ldi	r25, 0x00	; 0
    6df0:	61 e0       	ldi	r22, 0x01	; 1
    6df2:	0e 94 8c 0b 	call	0x1718	; 0x1718 <Beeper_Beep>
		
	_TXKeys = 0; // No Key Pressed
    6df6:	10 92 b4 06 	sts	0x06B4, r1
}
    6dfa:	08 95       	ret

00006dfc <Menu_MenuInit>:

void Menu_MenuInit()
{
	oldPage=0xff;
    6dfc:	8f ef       	ldi	r24, 0xFF	; 255
    6dfe:	80 93 2c 05 	sts	0x052C, r24
	Menu_LoadPage(PAGE_HOME);
    6e02:	80 e0       	ldi	r24, 0x00	; 0
    6e04:	0e 94 a1 2d 	call	0x5b42	; 0x5b42 <Menu_LoadPage>
}
    6e08:	08 95       	ret

00006e0a <tsmLoadModelLayout>:
}

PGM_P tsmLoadModelLayout(uint8_t index)
{
	//return (PGM_P)pgm_read_word(&mixerTable[index].Name);
}
    6e0a:	08 95       	ret

00006e0c <Menu_EnableAllItems>:


void Menu_EnableAllItems ()
{
    6e0c:	ec ea       	ldi	r30, 0xAC	; 172
    6e0e:	f7 e0       	ldi	r31, 0x07	; 7
	
	for (int i=0;i <MENU_ITEMS_COUNT;++i)
	{
		
		menuEnabled[i]=1;
    6e10:	81 e0       	ldi	r24, 0x01	; 1
    6e12:	81 93       	st	Z+, r24


void Menu_EnableAllItems ()
{
	
	for (int i=0;i <MENU_ITEMS_COUNT;++i)
    6e14:	97 e0       	ldi	r25, 0x07	; 7
    6e16:	ed 3b       	cpi	r30, 0xBD	; 189
    6e18:	f9 07       	cpc	r31, r25
    6e1a:	d9 f7       	brne	.-10     	; 0x6e12 <Menu_EnableAllItems+0x6>
	{
		
		menuEnabled[i]=1;
	}
	menuEnabled[PAGE_DEBUG]=1;
    6e1c:	80 93 bb 07 	sts	0x07BB, r24
	
    6e20:	08 95       	ret

00006e22 <__subsf3>:
    6e22:	50 58       	subi	r21, 0x80	; 128

00006e24 <__addsf3>:
    6e24:	bb 27       	eor	r27, r27
    6e26:	aa 27       	eor	r26, r26
    6e28:	0e d0       	rcall	.+28     	; 0x6e46 <__addsf3x>
    6e2a:	75 c1       	rjmp	.+746    	; 0x7116 <__fp_round>
    6e2c:	66 d1       	rcall	.+716    	; 0x70fa <__fp_pscA>
    6e2e:	30 f0       	brcs	.+12     	; 0x6e3c <__addsf3+0x18>
    6e30:	6b d1       	rcall	.+726    	; 0x7108 <__fp_pscB>
    6e32:	20 f0       	brcs	.+8      	; 0x6e3c <__addsf3+0x18>
    6e34:	31 f4       	brne	.+12     	; 0x6e42 <__addsf3+0x1e>
    6e36:	9f 3f       	cpi	r25, 0xFF	; 255
    6e38:	11 f4       	brne	.+4      	; 0x6e3e <__addsf3+0x1a>
    6e3a:	1e f4       	brtc	.+6      	; 0x6e42 <__addsf3+0x1e>
    6e3c:	5b c1       	rjmp	.+694    	; 0x70f4 <__fp_nan>
    6e3e:	0e f4       	brtc	.+2      	; 0x6e42 <__addsf3+0x1e>
    6e40:	e0 95       	com	r30
    6e42:	e7 fb       	bst	r30, 7
    6e44:	51 c1       	rjmp	.+674    	; 0x70e8 <__fp_inf>

00006e46 <__addsf3x>:
    6e46:	e9 2f       	mov	r30, r25
    6e48:	77 d1       	rcall	.+750    	; 0x7138 <__fp_split3>
    6e4a:	80 f3       	brcs	.-32     	; 0x6e2c <__addsf3+0x8>
    6e4c:	ba 17       	cp	r27, r26
    6e4e:	62 07       	cpc	r22, r18
    6e50:	73 07       	cpc	r23, r19
    6e52:	84 07       	cpc	r24, r20
    6e54:	95 07       	cpc	r25, r21
    6e56:	18 f0       	brcs	.+6      	; 0x6e5e <__addsf3x+0x18>
    6e58:	71 f4       	brne	.+28     	; 0x6e76 <__addsf3x+0x30>
    6e5a:	9e f5       	brtc	.+102    	; 0x6ec2 <__addsf3x+0x7c>
    6e5c:	8f c1       	rjmp	.+798    	; 0x717c <__fp_zero>
    6e5e:	0e f4       	brtc	.+2      	; 0x6e62 <__addsf3x+0x1c>
    6e60:	e0 95       	com	r30
    6e62:	0b 2e       	mov	r0, r27
    6e64:	ba 2f       	mov	r27, r26
    6e66:	a0 2d       	mov	r26, r0
    6e68:	0b 01       	movw	r0, r22
    6e6a:	b9 01       	movw	r22, r18
    6e6c:	90 01       	movw	r18, r0
    6e6e:	0c 01       	movw	r0, r24
    6e70:	ca 01       	movw	r24, r20
    6e72:	a0 01       	movw	r20, r0
    6e74:	11 24       	eor	r1, r1
    6e76:	ff 27       	eor	r31, r31
    6e78:	59 1b       	sub	r21, r25
    6e7a:	99 f0       	breq	.+38     	; 0x6ea2 <__addsf3x+0x5c>
    6e7c:	59 3f       	cpi	r21, 0xF9	; 249
    6e7e:	50 f4       	brcc	.+20     	; 0x6e94 <__addsf3x+0x4e>
    6e80:	50 3e       	cpi	r21, 0xE0	; 224
    6e82:	68 f1       	brcs	.+90     	; 0x6ede <__addsf3x+0x98>
    6e84:	1a 16       	cp	r1, r26
    6e86:	f0 40       	sbci	r31, 0x00	; 0
    6e88:	a2 2f       	mov	r26, r18
    6e8a:	23 2f       	mov	r18, r19
    6e8c:	34 2f       	mov	r19, r20
    6e8e:	44 27       	eor	r20, r20
    6e90:	58 5f       	subi	r21, 0xF8	; 248
    6e92:	f3 cf       	rjmp	.-26     	; 0x6e7a <__addsf3x+0x34>
    6e94:	46 95       	lsr	r20
    6e96:	37 95       	ror	r19
    6e98:	27 95       	ror	r18
    6e9a:	a7 95       	ror	r26
    6e9c:	f0 40       	sbci	r31, 0x00	; 0
    6e9e:	53 95       	inc	r21
    6ea0:	c9 f7       	brne	.-14     	; 0x6e94 <__addsf3x+0x4e>
    6ea2:	7e f4       	brtc	.+30     	; 0x6ec2 <__addsf3x+0x7c>
    6ea4:	1f 16       	cp	r1, r31
    6ea6:	ba 0b       	sbc	r27, r26
    6ea8:	62 0b       	sbc	r22, r18
    6eaa:	73 0b       	sbc	r23, r19
    6eac:	84 0b       	sbc	r24, r20
    6eae:	ba f0       	brmi	.+46     	; 0x6ede <__addsf3x+0x98>
    6eb0:	91 50       	subi	r25, 0x01	; 1
    6eb2:	a1 f0       	breq	.+40     	; 0x6edc <__addsf3x+0x96>
    6eb4:	ff 0f       	add	r31, r31
    6eb6:	bb 1f       	adc	r27, r27
    6eb8:	66 1f       	adc	r22, r22
    6eba:	77 1f       	adc	r23, r23
    6ebc:	88 1f       	adc	r24, r24
    6ebe:	c2 f7       	brpl	.-16     	; 0x6eb0 <__addsf3x+0x6a>
    6ec0:	0e c0       	rjmp	.+28     	; 0x6ede <__addsf3x+0x98>
    6ec2:	ba 0f       	add	r27, r26
    6ec4:	62 1f       	adc	r22, r18
    6ec6:	73 1f       	adc	r23, r19
    6ec8:	84 1f       	adc	r24, r20
    6eca:	48 f4       	brcc	.+18     	; 0x6ede <__addsf3x+0x98>
    6ecc:	87 95       	ror	r24
    6ece:	77 95       	ror	r23
    6ed0:	67 95       	ror	r22
    6ed2:	b7 95       	ror	r27
    6ed4:	f7 95       	ror	r31
    6ed6:	9e 3f       	cpi	r25, 0xFE	; 254
    6ed8:	08 f0       	brcs	.+2      	; 0x6edc <__addsf3x+0x96>
    6eda:	b3 cf       	rjmp	.-154    	; 0x6e42 <__addsf3+0x1e>
    6edc:	93 95       	inc	r25
    6ede:	88 0f       	add	r24, r24
    6ee0:	08 f0       	brcs	.+2      	; 0x6ee4 <__addsf3x+0x9e>
    6ee2:	99 27       	eor	r25, r25
    6ee4:	ee 0f       	add	r30, r30
    6ee6:	97 95       	ror	r25
    6ee8:	87 95       	ror	r24
    6eea:	08 95       	ret

00006eec <__cmpsf2>:
    6eec:	d9 d0       	rcall	.+434    	; 0x70a0 <__fp_cmp>
    6eee:	08 f4       	brcc	.+2      	; 0x6ef2 <__cmpsf2+0x6>
    6ef0:	81 e0       	ldi	r24, 0x01	; 1
    6ef2:	08 95       	ret

00006ef4 <__divsf3>:
    6ef4:	0c d0       	rcall	.+24     	; 0x6f0e <__divsf3x>
    6ef6:	0f c1       	rjmp	.+542    	; 0x7116 <__fp_round>
    6ef8:	07 d1       	rcall	.+526    	; 0x7108 <__fp_pscB>
    6efa:	40 f0       	brcs	.+16     	; 0x6f0c <__divsf3+0x18>
    6efc:	fe d0       	rcall	.+508    	; 0x70fa <__fp_pscA>
    6efe:	30 f0       	brcs	.+12     	; 0x6f0c <__divsf3+0x18>
    6f00:	21 f4       	brne	.+8      	; 0x6f0a <__divsf3+0x16>
    6f02:	5f 3f       	cpi	r21, 0xFF	; 255
    6f04:	19 f0       	breq	.+6      	; 0x6f0c <__divsf3+0x18>
    6f06:	f0 c0       	rjmp	.+480    	; 0x70e8 <__fp_inf>
    6f08:	51 11       	cpse	r21, r1
    6f0a:	39 c1       	rjmp	.+626    	; 0x717e <__fp_szero>
    6f0c:	f3 c0       	rjmp	.+486    	; 0x70f4 <__fp_nan>

00006f0e <__divsf3x>:
    6f0e:	14 d1       	rcall	.+552    	; 0x7138 <__fp_split3>
    6f10:	98 f3       	brcs	.-26     	; 0x6ef8 <__divsf3+0x4>

00006f12 <__divsf3_pse>:
    6f12:	99 23       	and	r25, r25
    6f14:	c9 f3       	breq	.-14     	; 0x6f08 <__divsf3+0x14>
    6f16:	55 23       	and	r21, r21
    6f18:	b1 f3       	breq	.-20     	; 0x6f06 <__divsf3+0x12>
    6f1a:	95 1b       	sub	r25, r21
    6f1c:	55 0b       	sbc	r21, r21
    6f1e:	bb 27       	eor	r27, r27
    6f20:	aa 27       	eor	r26, r26
    6f22:	62 17       	cp	r22, r18
    6f24:	73 07       	cpc	r23, r19
    6f26:	84 07       	cpc	r24, r20
    6f28:	38 f0       	brcs	.+14     	; 0x6f38 <__divsf3_pse+0x26>
    6f2a:	9f 5f       	subi	r25, 0xFF	; 255
    6f2c:	5f 4f       	sbci	r21, 0xFF	; 255
    6f2e:	22 0f       	add	r18, r18
    6f30:	33 1f       	adc	r19, r19
    6f32:	44 1f       	adc	r20, r20
    6f34:	aa 1f       	adc	r26, r26
    6f36:	a9 f3       	breq	.-22     	; 0x6f22 <__divsf3_pse+0x10>
    6f38:	33 d0       	rcall	.+102    	; 0x6fa0 <__divsf3_pse+0x8e>
    6f3a:	0e 2e       	mov	r0, r30
    6f3c:	3a f0       	brmi	.+14     	; 0x6f4c <__divsf3_pse+0x3a>
    6f3e:	e0 e8       	ldi	r30, 0x80	; 128
    6f40:	30 d0       	rcall	.+96     	; 0x6fa2 <__divsf3_pse+0x90>
    6f42:	91 50       	subi	r25, 0x01	; 1
    6f44:	50 40       	sbci	r21, 0x00	; 0
    6f46:	e6 95       	lsr	r30
    6f48:	00 1c       	adc	r0, r0
    6f4a:	ca f7       	brpl	.-14     	; 0x6f3e <__divsf3_pse+0x2c>
    6f4c:	29 d0       	rcall	.+82     	; 0x6fa0 <__divsf3_pse+0x8e>
    6f4e:	fe 2f       	mov	r31, r30
    6f50:	27 d0       	rcall	.+78     	; 0x6fa0 <__divsf3_pse+0x8e>
    6f52:	66 0f       	add	r22, r22
    6f54:	77 1f       	adc	r23, r23
    6f56:	88 1f       	adc	r24, r24
    6f58:	bb 1f       	adc	r27, r27
    6f5a:	26 17       	cp	r18, r22
    6f5c:	37 07       	cpc	r19, r23
    6f5e:	48 07       	cpc	r20, r24
    6f60:	ab 07       	cpc	r26, r27
    6f62:	b0 e8       	ldi	r27, 0x80	; 128
    6f64:	09 f0       	breq	.+2      	; 0x6f68 <__divsf3_pse+0x56>
    6f66:	bb 0b       	sbc	r27, r27
    6f68:	80 2d       	mov	r24, r0
    6f6a:	bf 01       	movw	r22, r30
    6f6c:	ff 27       	eor	r31, r31
    6f6e:	93 58       	subi	r25, 0x83	; 131
    6f70:	5f 4f       	sbci	r21, 0xFF	; 255
    6f72:	2a f0       	brmi	.+10     	; 0x6f7e <__divsf3_pse+0x6c>
    6f74:	9e 3f       	cpi	r25, 0xFE	; 254
    6f76:	51 05       	cpc	r21, r1
    6f78:	68 f0       	brcs	.+26     	; 0x6f94 <__divsf3_pse+0x82>
    6f7a:	b6 c0       	rjmp	.+364    	; 0x70e8 <__fp_inf>
    6f7c:	00 c1       	rjmp	.+512    	; 0x717e <__fp_szero>
    6f7e:	5f 3f       	cpi	r21, 0xFF	; 255
    6f80:	ec f3       	brlt	.-6      	; 0x6f7c <__divsf3_pse+0x6a>
    6f82:	98 3e       	cpi	r25, 0xE8	; 232
    6f84:	dc f3       	brlt	.-10     	; 0x6f7c <__divsf3_pse+0x6a>
    6f86:	86 95       	lsr	r24
    6f88:	77 95       	ror	r23
    6f8a:	67 95       	ror	r22
    6f8c:	b7 95       	ror	r27
    6f8e:	f7 95       	ror	r31
    6f90:	9f 5f       	subi	r25, 0xFF	; 255
    6f92:	c9 f7       	brne	.-14     	; 0x6f86 <__divsf3_pse+0x74>
    6f94:	88 0f       	add	r24, r24
    6f96:	91 1d       	adc	r25, r1
    6f98:	96 95       	lsr	r25
    6f9a:	87 95       	ror	r24
    6f9c:	97 f9       	bld	r25, 7
    6f9e:	08 95       	ret
    6fa0:	e1 e0       	ldi	r30, 0x01	; 1
    6fa2:	66 0f       	add	r22, r22
    6fa4:	77 1f       	adc	r23, r23
    6fa6:	88 1f       	adc	r24, r24
    6fa8:	bb 1f       	adc	r27, r27
    6faa:	62 17       	cp	r22, r18
    6fac:	73 07       	cpc	r23, r19
    6fae:	84 07       	cpc	r24, r20
    6fb0:	ba 07       	cpc	r27, r26
    6fb2:	20 f0       	brcs	.+8      	; 0x6fbc <__divsf3_pse+0xaa>
    6fb4:	62 1b       	sub	r22, r18
    6fb6:	73 0b       	sbc	r23, r19
    6fb8:	84 0b       	sbc	r24, r20
    6fba:	ba 0b       	sbc	r27, r26
    6fbc:	ee 1f       	adc	r30, r30
    6fbe:	88 f7       	brcc	.-30     	; 0x6fa2 <__divsf3_pse+0x90>
    6fc0:	e0 95       	com	r30
    6fc2:	08 95       	ret

00006fc4 <__fixsfsi>:
    6fc4:	04 d0       	rcall	.+8      	; 0x6fce <__fixunssfsi>
    6fc6:	68 94       	set
    6fc8:	b1 11       	cpse	r27, r1
    6fca:	d9 c0       	rjmp	.+434    	; 0x717e <__fp_szero>
    6fcc:	08 95       	ret

00006fce <__fixunssfsi>:
    6fce:	bc d0       	rcall	.+376    	; 0x7148 <__fp_splitA>
    6fd0:	88 f0       	brcs	.+34     	; 0x6ff4 <__fixunssfsi+0x26>
    6fd2:	9f 57       	subi	r25, 0x7F	; 127
    6fd4:	90 f0       	brcs	.+36     	; 0x6ffa <__fixunssfsi+0x2c>
    6fd6:	b9 2f       	mov	r27, r25
    6fd8:	99 27       	eor	r25, r25
    6fda:	b7 51       	subi	r27, 0x17	; 23
    6fdc:	a0 f0       	brcs	.+40     	; 0x7006 <__fixunssfsi+0x38>
    6fde:	d1 f0       	breq	.+52     	; 0x7014 <__fixunssfsi+0x46>
    6fe0:	66 0f       	add	r22, r22
    6fe2:	77 1f       	adc	r23, r23
    6fe4:	88 1f       	adc	r24, r24
    6fe6:	99 1f       	adc	r25, r25
    6fe8:	1a f0       	brmi	.+6      	; 0x6ff0 <__fixunssfsi+0x22>
    6fea:	ba 95       	dec	r27
    6fec:	c9 f7       	brne	.-14     	; 0x6fe0 <__fixunssfsi+0x12>
    6fee:	12 c0       	rjmp	.+36     	; 0x7014 <__fixunssfsi+0x46>
    6ff0:	b1 30       	cpi	r27, 0x01	; 1
    6ff2:	81 f0       	breq	.+32     	; 0x7014 <__fixunssfsi+0x46>
    6ff4:	c3 d0       	rcall	.+390    	; 0x717c <__fp_zero>
    6ff6:	b1 e0       	ldi	r27, 0x01	; 1
    6ff8:	08 95       	ret
    6ffa:	c0 c0       	rjmp	.+384    	; 0x717c <__fp_zero>
    6ffc:	67 2f       	mov	r22, r23
    6ffe:	78 2f       	mov	r23, r24
    7000:	88 27       	eor	r24, r24
    7002:	b8 5f       	subi	r27, 0xF8	; 248
    7004:	39 f0       	breq	.+14     	; 0x7014 <__fixunssfsi+0x46>
    7006:	b9 3f       	cpi	r27, 0xF9	; 249
    7008:	cc f3       	brlt	.-14     	; 0x6ffc <__fixunssfsi+0x2e>
    700a:	86 95       	lsr	r24
    700c:	77 95       	ror	r23
    700e:	67 95       	ror	r22
    7010:	b3 95       	inc	r27
    7012:	d9 f7       	brne	.-10     	; 0x700a <__fixunssfsi+0x3c>
    7014:	3e f4       	brtc	.+14     	; 0x7024 <__fixunssfsi+0x56>
    7016:	90 95       	com	r25
    7018:	80 95       	com	r24
    701a:	70 95       	com	r23
    701c:	61 95       	neg	r22
    701e:	7f 4f       	sbci	r23, 0xFF	; 255
    7020:	8f 4f       	sbci	r24, 0xFF	; 255
    7022:	9f 4f       	sbci	r25, 0xFF	; 255
    7024:	08 95       	ret

00007026 <__floatunsisf>:
    7026:	e8 94       	clt
    7028:	09 c0       	rjmp	.+18     	; 0x703c <__floatsisf+0x12>

0000702a <__floatsisf>:
    702a:	97 fb       	bst	r25, 7
    702c:	3e f4       	brtc	.+14     	; 0x703c <__floatsisf+0x12>
    702e:	90 95       	com	r25
    7030:	80 95       	com	r24
    7032:	70 95       	com	r23
    7034:	61 95       	neg	r22
    7036:	7f 4f       	sbci	r23, 0xFF	; 255
    7038:	8f 4f       	sbci	r24, 0xFF	; 255
    703a:	9f 4f       	sbci	r25, 0xFF	; 255
    703c:	99 23       	and	r25, r25
    703e:	a9 f0       	breq	.+42     	; 0x706a <__floatsisf+0x40>
    7040:	f9 2f       	mov	r31, r25
    7042:	96 e9       	ldi	r25, 0x96	; 150
    7044:	bb 27       	eor	r27, r27
    7046:	93 95       	inc	r25
    7048:	f6 95       	lsr	r31
    704a:	87 95       	ror	r24
    704c:	77 95       	ror	r23
    704e:	67 95       	ror	r22
    7050:	b7 95       	ror	r27
    7052:	f1 11       	cpse	r31, r1
    7054:	f8 cf       	rjmp	.-16     	; 0x7046 <__floatsisf+0x1c>
    7056:	fa f4       	brpl	.+62     	; 0x7096 <__floatsisf+0x6c>
    7058:	bb 0f       	add	r27, r27
    705a:	11 f4       	brne	.+4      	; 0x7060 <__floatsisf+0x36>
    705c:	60 ff       	sbrs	r22, 0
    705e:	1b c0       	rjmp	.+54     	; 0x7096 <__floatsisf+0x6c>
    7060:	6f 5f       	subi	r22, 0xFF	; 255
    7062:	7f 4f       	sbci	r23, 0xFF	; 255
    7064:	8f 4f       	sbci	r24, 0xFF	; 255
    7066:	9f 4f       	sbci	r25, 0xFF	; 255
    7068:	16 c0       	rjmp	.+44     	; 0x7096 <__floatsisf+0x6c>
    706a:	88 23       	and	r24, r24
    706c:	11 f0       	breq	.+4      	; 0x7072 <__floatsisf+0x48>
    706e:	96 e9       	ldi	r25, 0x96	; 150
    7070:	11 c0       	rjmp	.+34     	; 0x7094 <__floatsisf+0x6a>
    7072:	77 23       	and	r23, r23
    7074:	21 f0       	breq	.+8      	; 0x707e <__floatsisf+0x54>
    7076:	9e e8       	ldi	r25, 0x8E	; 142
    7078:	87 2f       	mov	r24, r23
    707a:	76 2f       	mov	r23, r22
    707c:	05 c0       	rjmp	.+10     	; 0x7088 <__floatsisf+0x5e>
    707e:	66 23       	and	r22, r22
    7080:	71 f0       	breq	.+28     	; 0x709e <__floatsisf+0x74>
    7082:	96 e8       	ldi	r25, 0x86	; 134
    7084:	86 2f       	mov	r24, r22
    7086:	70 e0       	ldi	r23, 0x00	; 0
    7088:	60 e0       	ldi	r22, 0x00	; 0
    708a:	2a f0       	brmi	.+10     	; 0x7096 <__floatsisf+0x6c>
    708c:	9a 95       	dec	r25
    708e:	66 0f       	add	r22, r22
    7090:	77 1f       	adc	r23, r23
    7092:	88 1f       	adc	r24, r24
    7094:	da f7       	brpl	.-10     	; 0x708c <__floatsisf+0x62>
    7096:	88 0f       	add	r24, r24
    7098:	96 95       	lsr	r25
    709a:	87 95       	ror	r24
    709c:	97 f9       	bld	r25, 7
    709e:	08 95       	ret

000070a0 <__fp_cmp>:
    70a0:	99 0f       	add	r25, r25
    70a2:	00 08       	sbc	r0, r0
    70a4:	55 0f       	add	r21, r21
    70a6:	aa 0b       	sbc	r26, r26
    70a8:	e0 e8       	ldi	r30, 0x80	; 128
    70aa:	fe ef       	ldi	r31, 0xFE	; 254
    70ac:	16 16       	cp	r1, r22
    70ae:	17 06       	cpc	r1, r23
    70b0:	e8 07       	cpc	r30, r24
    70b2:	f9 07       	cpc	r31, r25
    70b4:	c0 f0       	brcs	.+48     	; 0x70e6 <__fp_cmp+0x46>
    70b6:	12 16       	cp	r1, r18
    70b8:	13 06       	cpc	r1, r19
    70ba:	e4 07       	cpc	r30, r20
    70bc:	f5 07       	cpc	r31, r21
    70be:	98 f0       	brcs	.+38     	; 0x70e6 <__fp_cmp+0x46>
    70c0:	62 1b       	sub	r22, r18
    70c2:	73 0b       	sbc	r23, r19
    70c4:	84 0b       	sbc	r24, r20
    70c6:	95 0b       	sbc	r25, r21
    70c8:	39 f4       	brne	.+14     	; 0x70d8 <__fp_cmp+0x38>
    70ca:	0a 26       	eor	r0, r26
    70cc:	61 f0       	breq	.+24     	; 0x70e6 <__fp_cmp+0x46>
    70ce:	23 2b       	or	r18, r19
    70d0:	24 2b       	or	r18, r20
    70d2:	25 2b       	or	r18, r21
    70d4:	21 f4       	brne	.+8      	; 0x70de <__fp_cmp+0x3e>
    70d6:	08 95       	ret
    70d8:	0a 26       	eor	r0, r26
    70da:	09 f4       	brne	.+2      	; 0x70de <__fp_cmp+0x3e>
    70dc:	a1 40       	sbci	r26, 0x01	; 1
    70de:	a6 95       	lsr	r26
    70e0:	8f ef       	ldi	r24, 0xFF	; 255
    70e2:	81 1d       	adc	r24, r1
    70e4:	81 1d       	adc	r24, r1
    70e6:	08 95       	ret

000070e8 <__fp_inf>:
    70e8:	97 f9       	bld	r25, 7
    70ea:	9f 67       	ori	r25, 0x7F	; 127
    70ec:	80 e8       	ldi	r24, 0x80	; 128
    70ee:	70 e0       	ldi	r23, 0x00	; 0
    70f0:	60 e0       	ldi	r22, 0x00	; 0
    70f2:	08 95       	ret

000070f4 <__fp_nan>:
    70f4:	9f ef       	ldi	r25, 0xFF	; 255
    70f6:	80 ec       	ldi	r24, 0xC0	; 192
    70f8:	08 95       	ret

000070fa <__fp_pscA>:
    70fa:	00 24       	eor	r0, r0
    70fc:	0a 94       	dec	r0
    70fe:	16 16       	cp	r1, r22
    7100:	17 06       	cpc	r1, r23
    7102:	18 06       	cpc	r1, r24
    7104:	09 06       	cpc	r0, r25
    7106:	08 95       	ret

00007108 <__fp_pscB>:
    7108:	00 24       	eor	r0, r0
    710a:	0a 94       	dec	r0
    710c:	12 16       	cp	r1, r18
    710e:	13 06       	cpc	r1, r19
    7110:	14 06       	cpc	r1, r20
    7112:	05 06       	cpc	r0, r21
    7114:	08 95       	ret

00007116 <__fp_round>:
    7116:	09 2e       	mov	r0, r25
    7118:	03 94       	inc	r0
    711a:	00 0c       	add	r0, r0
    711c:	11 f4       	brne	.+4      	; 0x7122 <__fp_round+0xc>
    711e:	88 23       	and	r24, r24
    7120:	52 f0       	brmi	.+20     	; 0x7136 <__fp_round+0x20>
    7122:	bb 0f       	add	r27, r27
    7124:	40 f4       	brcc	.+16     	; 0x7136 <__fp_round+0x20>
    7126:	bf 2b       	or	r27, r31
    7128:	11 f4       	brne	.+4      	; 0x712e <__fp_round+0x18>
    712a:	60 ff       	sbrs	r22, 0
    712c:	04 c0       	rjmp	.+8      	; 0x7136 <__fp_round+0x20>
    712e:	6f 5f       	subi	r22, 0xFF	; 255
    7130:	7f 4f       	sbci	r23, 0xFF	; 255
    7132:	8f 4f       	sbci	r24, 0xFF	; 255
    7134:	9f 4f       	sbci	r25, 0xFF	; 255
    7136:	08 95       	ret

00007138 <__fp_split3>:
    7138:	57 fd       	sbrc	r21, 7
    713a:	90 58       	subi	r25, 0x80	; 128
    713c:	44 0f       	add	r20, r20
    713e:	55 1f       	adc	r21, r21
    7140:	59 f0       	breq	.+22     	; 0x7158 <__fp_splitA+0x10>
    7142:	5f 3f       	cpi	r21, 0xFF	; 255
    7144:	71 f0       	breq	.+28     	; 0x7162 <__fp_splitA+0x1a>
    7146:	47 95       	ror	r20

00007148 <__fp_splitA>:
    7148:	88 0f       	add	r24, r24
    714a:	97 fb       	bst	r25, 7
    714c:	99 1f       	adc	r25, r25
    714e:	61 f0       	breq	.+24     	; 0x7168 <__fp_splitA+0x20>
    7150:	9f 3f       	cpi	r25, 0xFF	; 255
    7152:	79 f0       	breq	.+30     	; 0x7172 <__fp_splitA+0x2a>
    7154:	87 95       	ror	r24
    7156:	08 95       	ret
    7158:	12 16       	cp	r1, r18
    715a:	13 06       	cpc	r1, r19
    715c:	14 06       	cpc	r1, r20
    715e:	55 1f       	adc	r21, r21
    7160:	f2 cf       	rjmp	.-28     	; 0x7146 <__fp_split3+0xe>
    7162:	46 95       	lsr	r20
    7164:	f1 df       	rcall	.-30     	; 0x7148 <__fp_splitA>
    7166:	08 c0       	rjmp	.+16     	; 0x7178 <__fp_splitA+0x30>
    7168:	16 16       	cp	r1, r22
    716a:	17 06       	cpc	r1, r23
    716c:	18 06       	cpc	r1, r24
    716e:	99 1f       	adc	r25, r25
    7170:	f1 cf       	rjmp	.-30     	; 0x7154 <__fp_splitA+0xc>
    7172:	86 95       	lsr	r24
    7174:	71 05       	cpc	r23, r1
    7176:	61 05       	cpc	r22, r1
    7178:	08 94       	sec
    717a:	08 95       	ret

0000717c <__fp_zero>:
    717c:	e8 94       	clt

0000717e <__fp_szero>:
    717e:	bb 27       	eor	r27, r27
    7180:	66 27       	eor	r22, r22
    7182:	77 27       	eor	r23, r23
    7184:	cb 01       	movw	r24, r22
    7186:	97 f9       	bld	r25, 7
    7188:	08 95       	ret

0000718a <__gesf2>:
    718a:	8a df       	rcall	.-236    	; 0x70a0 <__fp_cmp>
    718c:	08 f4       	brcc	.+2      	; 0x7190 <__gesf2+0x6>
    718e:	8f ef       	ldi	r24, 0xFF	; 255
    7190:	08 95       	ret

00007192 <__mulsf3>:
    7192:	0b d0       	rcall	.+22     	; 0x71aa <__mulsf3x>
    7194:	c0 cf       	rjmp	.-128    	; 0x7116 <__fp_round>
    7196:	b1 df       	rcall	.-158    	; 0x70fa <__fp_pscA>
    7198:	28 f0       	brcs	.+10     	; 0x71a4 <__mulsf3+0x12>
    719a:	b6 df       	rcall	.-148    	; 0x7108 <__fp_pscB>
    719c:	18 f0       	brcs	.+6      	; 0x71a4 <__mulsf3+0x12>
    719e:	95 23       	and	r25, r21
    71a0:	09 f0       	breq	.+2      	; 0x71a4 <__mulsf3+0x12>
    71a2:	a2 cf       	rjmp	.-188    	; 0x70e8 <__fp_inf>
    71a4:	a7 cf       	rjmp	.-178    	; 0x70f4 <__fp_nan>
    71a6:	11 24       	eor	r1, r1
    71a8:	ea cf       	rjmp	.-44     	; 0x717e <__fp_szero>

000071aa <__mulsf3x>:
    71aa:	c6 df       	rcall	.-116    	; 0x7138 <__fp_split3>
    71ac:	a0 f3       	brcs	.-24     	; 0x7196 <__mulsf3+0x4>

000071ae <__mulsf3_pse>:
    71ae:	95 9f       	mul	r25, r21
    71b0:	d1 f3       	breq	.-12     	; 0x71a6 <__mulsf3+0x14>
    71b2:	95 0f       	add	r25, r21
    71b4:	50 e0       	ldi	r21, 0x00	; 0
    71b6:	55 1f       	adc	r21, r21
    71b8:	62 9f       	mul	r22, r18
    71ba:	f0 01       	movw	r30, r0
    71bc:	72 9f       	mul	r23, r18
    71be:	bb 27       	eor	r27, r27
    71c0:	f0 0d       	add	r31, r0
    71c2:	b1 1d       	adc	r27, r1
    71c4:	63 9f       	mul	r22, r19
    71c6:	aa 27       	eor	r26, r26
    71c8:	f0 0d       	add	r31, r0
    71ca:	b1 1d       	adc	r27, r1
    71cc:	aa 1f       	adc	r26, r26
    71ce:	64 9f       	mul	r22, r20
    71d0:	66 27       	eor	r22, r22
    71d2:	b0 0d       	add	r27, r0
    71d4:	a1 1d       	adc	r26, r1
    71d6:	66 1f       	adc	r22, r22
    71d8:	82 9f       	mul	r24, r18
    71da:	22 27       	eor	r18, r18
    71dc:	b0 0d       	add	r27, r0
    71de:	a1 1d       	adc	r26, r1
    71e0:	62 1f       	adc	r22, r18
    71e2:	73 9f       	mul	r23, r19
    71e4:	b0 0d       	add	r27, r0
    71e6:	a1 1d       	adc	r26, r1
    71e8:	62 1f       	adc	r22, r18
    71ea:	83 9f       	mul	r24, r19
    71ec:	a0 0d       	add	r26, r0
    71ee:	61 1d       	adc	r22, r1
    71f0:	22 1f       	adc	r18, r18
    71f2:	74 9f       	mul	r23, r20
    71f4:	33 27       	eor	r19, r19
    71f6:	a0 0d       	add	r26, r0
    71f8:	61 1d       	adc	r22, r1
    71fa:	23 1f       	adc	r18, r19
    71fc:	84 9f       	mul	r24, r20
    71fe:	60 0d       	add	r22, r0
    7200:	21 1d       	adc	r18, r1
    7202:	82 2f       	mov	r24, r18
    7204:	76 2f       	mov	r23, r22
    7206:	6a 2f       	mov	r22, r26
    7208:	11 24       	eor	r1, r1
    720a:	9f 57       	subi	r25, 0x7F	; 127
    720c:	50 40       	sbci	r21, 0x00	; 0
    720e:	8a f0       	brmi	.+34     	; 0x7232 <__mulsf3_pse+0x84>
    7210:	e1 f0       	breq	.+56     	; 0x724a <__mulsf3_pse+0x9c>
    7212:	88 23       	and	r24, r24
    7214:	4a f0       	brmi	.+18     	; 0x7228 <__mulsf3_pse+0x7a>
    7216:	ee 0f       	add	r30, r30
    7218:	ff 1f       	adc	r31, r31
    721a:	bb 1f       	adc	r27, r27
    721c:	66 1f       	adc	r22, r22
    721e:	77 1f       	adc	r23, r23
    7220:	88 1f       	adc	r24, r24
    7222:	91 50       	subi	r25, 0x01	; 1
    7224:	50 40       	sbci	r21, 0x00	; 0
    7226:	a9 f7       	brne	.-22     	; 0x7212 <__mulsf3_pse+0x64>
    7228:	9e 3f       	cpi	r25, 0xFE	; 254
    722a:	51 05       	cpc	r21, r1
    722c:	70 f0       	brcs	.+28     	; 0x724a <__mulsf3_pse+0x9c>
    722e:	5c cf       	rjmp	.-328    	; 0x70e8 <__fp_inf>
    7230:	a6 cf       	rjmp	.-180    	; 0x717e <__fp_szero>
    7232:	5f 3f       	cpi	r21, 0xFF	; 255
    7234:	ec f3       	brlt	.-6      	; 0x7230 <__mulsf3_pse+0x82>
    7236:	98 3e       	cpi	r25, 0xE8	; 232
    7238:	dc f3       	brlt	.-10     	; 0x7230 <__mulsf3_pse+0x82>
    723a:	86 95       	lsr	r24
    723c:	77 95       	ror	r23
    723e:	67 95       	ror	r22
    7240:	b7 95       	ror	r27
    7242:	f7 95       	ror	r31
    7244:	e7 95       	ror	r30
    7246:	9f 5f       	subi	r25, 0xFF	; 255
    7248:	c1 f7       	brne	.-16     	; 0x723a <__mulsf3_pse+0x8c>
    724a:	fe 2b       	or	r31, r30
    724c:	88 0f       	add	r24, r24
    724e:	91 1d       	adc	r25, r1
    7250:	96 95       	lsr	r25
    7252:	87 95       	ror	r24
    7254:	97 f9       	bld	r25, 7
    7256:	08 95       	ret

00007258 <__udivmodhi4>:
    7258:	aa 1b       	sub	r26, r26
    725a:	bb 1b       	sub	r27, r27
    725c:	51 e1       	ldi	r21, 0x11	; 17
    725e:	07 c0       	rjmp	.+14     	; 0x726e <__udivmodhi4_ep>

00007260 <__udivmodhi4_loop>:
    7260:	aa 1f       	adc	r26, r26
    7262:	bb 1f       	adc	r27, r27
    7264:	a6 17       	cp	r26, r22
    7266:	b7 07       	cpc	r27, r23
    7268:	10 f0       	brcs	.+4      	; 0x726e <__udivmodhi4_ep>
    726a:	a6 1b       	sub	r26, r22
    726c:	b7 0b       	sbc	r27, r23

0000726e <__udivmodhi4_ep>:
    726e:	88 1f       	adc	r24, r24
    7270:	99 1f       	adc	r25, r25
    7272:	5a 95       	dec	r21
    7274:	a9 f7       	brne	.-22     	; 0x7260 <__udivmodhi4_loop>
    7276:	80 95       	com	r24
    7278:	90 95       	com	r25
    727a:	bc 01       	movw	r22, r24
    727c:	cd 01       	movw	r24, r26
    727e:	08 95       	ret

00007280 <__divmodhi4>:
    7280:	97 fb       	bst	r25, 7
    7282:	09 2e       	mov	r0, r25
    7284:	07 26       	eor	r0, r23
    7286:	0a d0       	rcall	.+20     	; 0x729c <__divmodhi4_neg1>
    7288:	77 fd       	sbrc	r23, 7
    728a:	04 d0       	rcall	.+8      	; 0x7294 <__divmodhi4_neg2>
    728c:	e5 df       	rcall	.-54     	; 0x7258 <__udivmodhi4>
    728e:	06 d0       	rcall	.+12     	; 0x729c <__divmodhi4_neg1>
    7290:	00 20       	and	r0, r0
    7292:	1a f4       	brpl	.+6      	; 0x729a <__divmodhi4_exit>

00007294 <__divmodhi4_neg2>:
    7294:	70 95       	com	r23
    7296:	61 95       	neg	r22
    7298:	7f 4f       	sbci	r23, 0xFF	; 255

0000729a <__divmodhi4_exit>:
    729a:	08 95       	ret

0000729c <__divmodhi4_neg1>:
    729c:	f6 f7       	brtc	.-4      	; 0x729a <__divmodhi4_exit>
    729e:	90 95       	com	r25
    72a0:	81 95       	neg	r24
    72a2:	9f 4f       	sbci	r25, 0xFF	; 255
    72a4:	08 95       	ret

000072a6 <abs>:
    72a6:	28 2f       	mov	r18, r24
    72a8:	39 2f       	mov	r19, r25
    72aa:	37 ff       	sbrs	r19, 7
    72ac:	03 c0       	rjmp	.+6      	; 0x72b4 <abs+0xe>
    72ae:	30 95       	com	r19
    72b0:	21 95       	neg	r18
    72b2:	3f 4f       	sbci	r19, 0xFF	; 255
    72b4:	c9 01       	movw	r24, r18
    72b6:	08 95       	ret

000072b8 <dtostrf>:
    72b8:	ef 92       	push	r14
    72ba:	ff 92       	push	r15
    72bc:	0f 93       	push	r16
    72be:	1f 93       	push	r17
    72c0:	32 2f       	mov	r19, r18
    72c2:	f0 2e       	mov	r15, r16
    72c4:	47 ff       	sbrs	r20, 7
    72c6:	02 c0       	rjmp	.+4      	; 0x72cc <dtostrf+0x14>
    72c8:	a4 e1       	ldi	r26, 0x14	; 20
    72ca:	01 c0       	rjmp	.+2      	; 0x72ce <dtostrf+0x16>
    72cc:	a4 e0       	ldi	r26, 0x04	; 4
    72ce:	e4 2f       	mov	r30, r20
    72d0:	ff 27       	eor	r31, r31
    72d2:	e7 fd       	sbrc	r30, 7
    72d4:	f0 95       	com	r31
    72d6:	f7 ff       	sbrs	r31, 7
    72d8:	03 c0       	rjmp	.+6      	; 0x72e0 <dtostrf+0x28>
    72da:	f0 95       	com	r31
    72dc:	e1 95       	neg	r30
    72de:	ff 4f       	sbci	r31, 0xFF	; 255
    72e0:	4f 2d       	mov	r20, r15
    72e2:	51 2f       	mov	r21, r17
    72e4:	2e 2f       	mov	r18, r30
    72e6:	03 2f       	mov	r16, r19
    72e8:	ea 2e       	mov	r14, r26
    72ea:	0e 94 08 3a 	call	0x7410	; 0x7410 <dtoa_prf>
    72ee:	8f 2d       	mov	r24, r15
    72f0:	91 2f       	mov	r25, r17
    72f2:	1f 91       	pop	r17
    72f4:	0f 91       	pop	r16
    72f6:	ff 90       	pop	r15
    72f8:	ef 90       	pop	r14
    72fa:	08 95       	ret

000072fc <memcpy_P>:
    72fc:	fb 01       	movw	r30, r22
    72fe:	dc 01       	movw	r26, r24
    7300:	02 c0       	rjmp	.+4      	; 0x7306 <memcpy_P+0xa>
    7302:	05 90       	lpm	r0, Z+
    7304:	0d 92       	st	X+, r0
    7306:	41 50       	subi	r20, 0x01	; 1
    7308:	50 40       	sbci	r21, 0x00	; 0
    730a:	d8 f7       	brcc	.-10     	; 0x7302 <memcpy_P+0x6>
    730c:	08 95       	ret

0000730e <strcpy_P>:
    730e:	fb 01       	movw	r30, r22
    7310:	dc 01       	movw	r26, r24
    7312:	05 90       	lpm	r0, Z+
    7314:	0d 92       	st	X+, r0
    7316:	00 20       	and	r0, r0
    7318:	e1 f7       	brne	.-8      	; 0x7312 <strcpy_P+0x4>
    731a:	08 95       	ret

0000731c <strlen_P>:
    731c:	fc 01       	movw	r30, r24
    731e:	05 90       	lpm	r0, Z+
    7320:	00 20       	and	r0, r0
    7322:	e9 f7       	brne	.-6      	; 0x731e <strlen_P+0x2>
    7324:	80 95       	com	r24
    7326:	90 95       	com	r25
    7328:	8e 0f       	add	r24, r30
    732a:	9f 1f       	adc	r25, r31
    732c:	08 95       	ret

0000732e <memcpy>:
    732e:	fb 01       	movw	r30, r22
    7330:	dc 01       	movw	r26, r24
    7332:	02 c0       	rjmp	.+4      	; 0x7338 <memcpy+0xa>
    7334:	01 90       	ld	r0, Z+
    7336:	0d 92       	st	X+, r0
    7338:	41 50       	subi	r20, 0x01	; 1
    733a:	50 40       	sbci	r21, 0x00	; 0
    733c:	d8 f7       	brcc	.-10     	; 0x7334 <memcpy+0x6>
    733e:	08 95       	ret

00007340 <strcat>:
    7340:	fb 01       	movw	r30, r22
    7342:	dc 01       	movw	r26, r24
    7344:	0d 90       	ld	r0, X+
    7346:	00 20       	and	r0, r0
    7348:	e9 f7       	brne	.-6      	; 0x7344 <strcat+0x4>
    734a:	11 97       	sbiw	r26, 0x01	; 1
    734c:	01 90       	ld	r0, Z+
    734e:	0d 92       	st	X+, r0
    7350:	00 20       	and	r0, r0
    7352:	e1 f7       	brne	.-8      	; 0x734c <strcat+0xc>
    7354:	08 95       	ret

00007356 <itoa>:
    7356:	fb 01       	movw	r30, r22
    7358:	9f 01       	movw	r18, r30
    735a:	e8 94       	clt
    735c:	42 30       	cpi	r20, 0x02	; 2
    735e:	c4 f0       	brlt	.+48     	; 0x7390 <itoa+0x3a>
    7360:	45 32       	cpi	r20, 0x25	; 37
    7362:	b4 f4       	brge	.+44     	; 0x7390 <itoa+0x3a>
    7364:	4a 30       	cpi	r20, 0x0A	; 10
    7366:	29 f4       	brne	.+10     	; 0x7372 <itoa+0x1c>
    7368:	97 fb       	bst	r25, 7
    736a:	1e f4       	brtc	.+6      	; 0x7372 <itoa+0x1c>
    736c:	90 95       	com	r25
    736e:	81 95       	neg	r24
    7370:	9f 4f       	sbci	r25, 0xFF	; 255
    7372:	64 2f       	mov	r22, r20
    7374:	77 27       	eor	r23, r23
    7376:	0e 94 2c 39 	call	0x7258	; 0x7258 <__udivmodhi4>
    737a:	80 5d       	subi	r24, 0xD0	; 208
    737c:	8a 33       	cpi	r24, 0x3A	; 58
    737e:	0c f0       	brlt	.+2      	; 0x7382 <itoa+0x2c>
    7380:	89 5d       	subi	r24, 0xD9	; 217
    7382:	81 93       	st	Z+, r24
    7384:	cb 01       	movw	r24, r22
    7386:	00 97       	sbiw	r24, 0x00	; 0
    7388:	a1 f7       	brne	.-24     	; 0x7372 <itoa+0x1c>
    738a:	16 f4       	brtc	.+4      	; 0x7390 <itoa+0x3a>
    738c:	5d e2       	ldi	r21, 0x2D	; 45
    738e:	51 93       	st	Z+, r21
    7390:	10 82       	st	Z, r1
    7392:	c9 01       	movw	r24, r18
    7394:	0c 94 37 3c 	jmp	0x786e	; 0x786e <strrev>

00007398 <utoa>:
    7398:	fb 01       	movw	r30, r22
    739a:	9f 01       	movw	r18, r30
    739c:	42 30       	cpi	r20, 0x02	; 2
    739e:	74 f0       	brlt	.+28     	; 0x73bc <utoa+0x24>
    73a0:	45 32       	cpi	r20, 0x25	; 37
    73a2:	64 f4       	brge	.+24     	; 0x73bc <utoa+0x24>
    73a4:	64 2f       	mov	r22, r20
    73a6:	77 27       	eor	r23, r23
    73a8:	0e 94 2c 39 	call	0x7258	; 0x7258 <__udivmodhi4>
    73ac:	80 5d       	subi	r24, 0xD0	; 208
    73ae:	8a 33       	cpi	r24, 0x3A	; 58
    73b0:	0c f0       	brlt	.+2      	; 0x73b4 <utoa+0x1c>
    73b2:	89 5d       	subi	r24, 0xD9	; 217
    73b4:	81 93       	st	Z+, r24
    73b6:	cb 01       	movw	r24, r22
    73b8:	00 97       	sbiw	r24, 0x00	; 0
    73ba:	a1 f7       	brne	.-24     	; 0x73a4 <utoa+0xc>
    73bc:	10 82       	st	Z, r1
    73be:	c9 01       	movw	r24, r18
    73c0:	0c 94 37 3c 	jmp	0x786e	; 0x786e <strrev>

000073c4 <__eerd_block_m324pa>:
    73c4:	dc 01       	movw	r26, r24
    73c6:	cb 01       	movw	r24, r22

000073c8 <__eerd_blraw_m324pa>:
    73c8:	fc 01       	movw	r30, r24
    73ca:	f9 99       	sbic	0x1f, 1	; 31
    73cc:	fe cf       	rjmp	.-4      	; 0x73ca <__eerd_blraw_m324pa+0x2>
    73ce:	06 c0       	rjmp	.+12     	; 0x73dc <__eerd_blraw_m324pa+0x14>
    73d0:	f2 bd       	out	0x22, r31	; 34
    73d2:	e1 bd       	out	0x21, r30	; 33
    73d4:	f8 9a       	sbi	0x1f, 0	; 31
    73d6:	31 96       	adiw	r30, 0x01	; 1
    73d8:	00 b4       	in	r0, 0x20	; 32
    73da:	0d 92       	st	X+, r0
    73dc:	41 50       	subi	r20, 0x01	; 1
    73de:	50 40       	sbci	r21, 0x00	; 0
    73e0:	b8 f7       	brcc	.-18     	; 0x73d0 <__eerd_blraw_m324pa+0x8>
    73e2:	08 95       	ret

000073e4 <__eerd_byte_m324pa>:
    73e4:	f9 99       	sbic	0x1f, 1	; 31
    73e6:	fe cf       	rjmp	.-4      	; 0x73e4 <__eerd_byte_m324pa>
    73e8:	92 bd       	out	0x22, r25	; 34
    73ea:	81 bd       	out	0x21, r24	; 33
    73ec:	f8 9a       	sbi	0x1f, 0	; 31
    73ee:	99 27       	eor	r25, r25
    73f0:	80 b5       	in	r24, 0x20	; 32
    73f2:	08 95       	ret

000073f4 <__eewr_byte_m324pa>:
    73f4:	26 2f       	mov	r18, r22

000073f6 <__eewr_r18_m324pa>:
    73f6:	f9 99       	sbic	0x1f, 1	; 31
    73f8:	fe cf       	rjmp	.-4      	; 0x73f6 <__eewr_r18_m324pa>
    73fa:	1f ba       	out	0x1f, r1	; 31
    73fc:	92 bd       	out	0x22, r25	; 34
    73fe:	81 bd       	out	0x21, r24	; 33
    7400:	20 bd       	out	0x20, r18	; 32
    7402:	0f b6       	in	r0, 0x3f	; 63
    7404:	f8 94       	cli
    7406:	fa 9a       	sbi	0x1f, 2	; 31
    7408:	f9 9a       	sbi	0x1f, 1	; 31
    740a:	0f be       	out	0x3f, r0	; 63
    740c:	01 96       	adiw	r24, 0x01	; 1
    740e:	08 95       	ret

00007410 <dtoa_prf>:
    7410:	a9 e0       	ldi	r26, 0x09	; 9
    7412:	b0 e0       	ldi	r27, 0x00	; 0
    7414:	ee e0       	ldi	r30, 0x0E	; 14
    7416:	fa e3       	ldi	r31, 0x3A	; 58
    7418:	0c 94 4f 3c 	jmp	0x789e	; 0x789e <__prologue_saves__+0x10>
    741c:	6a 01       	movw	r12, r20
    741e:	f2 2e       	mov	r15, r18
    7420:	10 2f       	mov	r17, r16
    7422:	0c 33       	cpi	r16, 0x3C	; 60
    7424:	18 f4       	brcc	.+6      	; 0x742c <dtoa_prf+0x1c>
    7426:	b0 2e       	mov	r11, r16
    7428:	b3 94       	inc	r11
    742a:	02 c0       	rjmp	.+4      	; 0x7430 <dtoa_prf+0x20>
    742c:	ec e3       	ldi	r30, 0x3C	; 60
    742e:	be 2e       	mov	r11, r30
    7430:	ae 01       	movw	r20, r28
    7432:	4f 5f       	subi	r20, 0xFF	; 255
    7434:	5f 4f       	sbci	r21, 0xFF	; 255
    7436:	27 e0       	ldi	r18, 0x07	; 7
    7438:	0b 2d       	mov	r16, r11
    743a:	0e 94 5f 3b 	call	0x76be	; 0x76be <__ftoa_engine>
    743e:	29 81       	ldd	r18, Y+1	; 0x01
    7440:	30 e0       	ldi	r19, 0x00	; 0
    7442:	a9 01       	movw	r20, r18
    7444:	49 70       	andi	r20, 0x09	; 9
    7446:	50 70       	andi	r21, 0x00	; 0
    7448:	41 30       	cpi	r20, 0x01	; 1
    744a:	51 05       	cpc	r21, r1
    744c:	31 f0       	breq	.+12     	; 0x745a <dtoa_prf+0x4a>
    744e:	e1 fc       	sbrc	r14, 1
    7450:	06 c0       	rjmp	.+12     	; 0x745e <dtoa_prf+0x4e>
    7452:	e0 fe       	sbrs	r14, 0
    7454:	06 c0       	rjmp	.+12     	; 0x7462 <dtoa_prf+0x52>
    7456:	e0 e2       	ldi	r30, 0x20	; 32
    7458:	05 c0       	rjmp	.+10     	; 0x7464 <dtoa_prf+0x54>
    745a:	ed e2       	ldi	r30, 0x2D	; 45
    745c:	03 c0       	rjmp	.+6      	; 0x7464 <dtoa_prf+0x54>
    745e:	eb e2       	ldi	r30, 0x2B	; 43
    7460:	01 c0       	rjmp	.+2      	; 0x7464 <dtoa_prf+0x54>
    7462:	e0 e0       	ldi	r30, 0x00	; 0
    7464:	23 ff       	sbrs	r18, 3
    7466:	37 c0       	rjmp	.+110    	; 0x74d6 <dtoa_prf+0xc6>
    7468:	ee 23       	and	r30, r30
    746a:	11 f0       	breq	.+4      	; 0x7470 <dtoa_prf+0x60>
    746c:	84 e0       	ldi	r24, 0x04	; 4
    746e:	01 c0       	rjmp	.+2      	; 0x7472 <dtoa_prf+0x62>
    7470:	83 e0       	ldi	r24, 0x03	; 3
    7472:	8f 15       	cp	r24, r15
    7474:	18 f4       	brcc	.+6      	; 0x747c <dtoa_prf+0x6c>
    7476:	f8 1a       	sub	r15, r24
    7478:	8f 2d       	mov	r24, r15
    747a:	01 c0       	rjmp	.+2      	; 0x747e <dtoa_prf+0x6e>
    747c:	80 e0       	ldi	r24, 0x00	; 0
    747e:	e4 fc       	sbrc	r14, 4
    7480:	0b c0       	rjmp	.+22     	; 0x7498 <dtoa_prf+0x88>
    7482:	98 2f       	mov	r25, r24
    7484:	d6 01       	movw	r26, r12
    7486:	20 e2       	ldi	r18, 0x20	; 32
    7488:	02 c0       	rjmp	.+4      	; 0x748e <dtoa_prf+0x7e>
    748a:	2d 93       	st	X+, r18
    748c:	91 50       	subi	r25, 0x01	; 1
    748e:	99 23       	and	r25, r25
    7490:	e1 f7       	brne	.-8      	; 0x748a <dtoa_prf+0x7a>
    7492:	c8 0e       	add	r12, r24
    7494:	d1 1c       	adc	r13, r1
    7496:	80 e0       	ldi	r24, 0x00	; 0
    7498:	ee 23       	and	r30, r30
    749a:	19 f0       	breq	.+6      	; 0x74a2 <dtoa_prf+0x92>
    749c:	d6 01       	movw	r26, r12
    749e:	ed 93       	st	X+, r30
    74a0:	6d 01       	movw	r12, r26
    74a2:	f6 01       	movw	r30, r12
    74a4:	31 96       	adiw	r30, 0x01	; 1
    74a6:	e2 fe       	sbrs	r14, 2
    74a8:	05 c0       	rjmp	.+10     	; 0x74b4 <dtoa_prf+0xa4>
    74aa:	9e e4       	ldi	r25, 0x4E	; 78
    74ac:	d6 01       	movw	r26, r12
    74ae:	9c 93       	st	X, r25
    74b0:	21 e4       	ldi	r18, 0x41	; 65
    74b2:	04 c0       	rjmp	.+8      	; 0x74bc <dtoa_prf+0xac>
    74b4:	9e e6       	ldi	r25, 0x6E	; 110
    74b6:	d6 01       	movw	r26, r12
    74b8:	9c 93       	st	X, r25
    74ba:	21 e6       	ldi	r18, 0x61	; 97
    74bc:	11 96       	adiw	r26, 0x01	; 1
    74be:	2c 93       	st	X, r18
    74c0:	91 83       	std	Z+1, r25	; 0x01
    74c2:	32 96       	adiw	r30, 0x02	; 2
    74c4:	98 2f       	mov	r25, r24
    74c6:	df 01       	movw	r26, r30
    74c8:	20 e2       	ldi	r18, 0x20	; 32
    74ca:	02 c0       	rjmp	.+4      	; 0x74d0 <dtoa_prf+0xc0>
    74cc:	2d 93       	st	X+, r18
    74ce:	91 50       	subi	r25, 0x01	; 1
    74d0:	99 23       	and	r25, r25
    74d2:	e1 f7       	brne	.-8      	; 0x74cc <dtoa_prf+0xbc>
    74d4:	3d c0       	rjmp	.+122    	; 0x7550 <dtoa_prf+0x140>
    74d6:	22 ff       	sbrs	r18, 2
    74d8:	41 c0       	rjmp	.+130    	; 0x755c <dtoa_prf+0x14c>
    74da:	ee 23       	and	r30, r30
    74dc:	11 f0       	breq	.+4      	; 0x74e2 <dtoa_prf+0xd2>
    74de:	84 e0       	ldi	r24, 0x04	; 4
    74e0:	01 c0       	rjmp	.+2      	; 0x74e4 <dtoa_prf+0xd4>
    74e2:	83 e0       	ldi	r24, 0x03	; 3
    74e4:	8f 15       	cp	r24, r15
    74e6:	18 f4       	brcc	.+6      	; 0x74ee <dtoa_prf+0xde>
    74e8:	f8 1a       	sub	r15, r24
    74ea:	8f 2d       	mov	r24, r15
    74ec:	01 c0       	rjmp	.+2      	; 0x74f0 <dtoa_prf+0xe0>
    74ee:	80 e0       	ldi	r24, 0x00	; 0
    74f0:	e4 fc       	sbrc	r14, 4
    74f2:	0b c0       	rjmp	.+22     	; 0x750a <dtoa_prf+0xfa>
    74f4:	98 2f       	mov	r25, r24
    74f6:	d6 01       	movw	r26, r12
    74f8:	20 e2       	ldi	r18, 0x20	; 32
    74fa:	02 c0       	rjmp	.+4      	; 0x7500 <dtoa_prf+0xf0>
    74fc:	2d 93       	st	X+, r18
    74fe:	91 50       	subi	r25, 0x01	; 1
    7500:	99 23       	and	r25, r25
    7502:	e1 f7       	brne	.-8      	; 0x74fc <dtoa_prf+0xec>
    7504:	c8 0e       	add	r12, r24
    7506:	d1 1c       	adc	r13, r1
    7508:	80 e0       	ldi	r24, 0x00	; 0
    750a:	ee 23       	and	r30, r30
    750c:	19 f0       	breq	.+6      	; 0x7514 <dtoa_prf+0x104>
    750e:	d6 01       	movw	r26, r12
    7510:	ed 93       	st	X+, r30
    7512:	6d 01       	movw	r12, r26
    7514:	f6 01       	movw	r30, r12
    7516:	31 96       	adiw	r30, 0x01	; 1
    7518:	e2 fe       	sbrs	r14, 2
    751a:	09 c0       	rjmp	.+18     	; 0x752e <dtoa_prf+0x11e>
    751c:	99 e4       	ldi	r25, 0x49	; 73
    751e:	d6 01       	movw	r26, r12
    7520:	9c 93       	st	X, r25
    7522:	9e e4       	ldi	r25, 0x4E	; 78
    7524:	11 96       	adiw	r26, 0x01	; 1
    7526:	9c 93       	st	X, r25
    7528:	11 97       	sbiw	r26, 0x01	; 1
    752a:	96 e4       	ldi	r25, 0x46	; 70
    752c:	07 c0       	rjmp	.+14     	; 0x753c <dtoa_prf+0x12c>
    752e:	99 e6       	ldi	r25, 0x69	; 105
    7530:	d6 01       	movw	r26, r12
    7532:	9c 93       	st	X, r25
    7534:	9e e6       	ldi	r25, 0x6E	; 110
    7536:	11 96       	adiw	r26, 0x01	; 1
    7538:	9c 93       	st	X, r25
    753a:	96 e6       	ldi	r25, 0x66	; 102
    753c:	91 83       	std	Z+1, r25	; 0x01
    753e:	32 96       	adiw	r30, 0x02	; 2
    7540:	98 2f       	mov	r25, r24
    7542:	df 01       	movw	r26, r30
    7544:	20 e2       	ldi	r18, 0x20	; 32
    7546:	02 c0       	rjmp	.+4      	; 0x754c <dtoa_prf+0x13c>
    7548:	2d 93       	st	X+, r18
    754a:	91 50       	subi	r25, 0x01	; 1
    754c:	99 23       	and	r25, r25
    754e:	e1 f7       	brne	.-8      	; 0x7548 <dtoa_prf+0x138>
    7550:	e8 0f       	add	r30, r24
    7552:	f1 1d       	adc	r31, r1
    7554:	10 82       	st	Z, r1
    7556:	2e ef       	ldi	r18, 0xFE	; 254
    7558:	3f ef       	ldi	r19, 0xFF	; 255
    755a:	ac c0       	rjmp	.+344    	; 0x76b4 <dtoa_prf+0x2a4>
    755c:	41 e0       	ldi	r20, 0x01	; 1
    755e:	50 e0       	ldi	r21, 0x00	; 0
    7560:	ee 23       	and	r30, r30
    7562:	11 f4       	brne	.+4      	; 0x7568 <dtoa_prf+0x158>
    7564:	40 e0       	ldi	r20, 0x00	; 0
    7566:	50 e0       	ldi	r21, 0x00	; 0
    7568:	18 16       	cp	r1, r24
    756a:	19 06       	cpc	r1, r25
    756c:	24 f4       	brge	.+8      	; 0x7576 <dtoa_prf+0x166>
    756e:	bc 01       	movw	r22, r24
    7570:	6f 5f       	subi	r22, 0xFF	; 255
    7572:	7f 4f       	sbci	r23, 0xFF	; 255
    7574:	02 c0       	rjmp	.+4      	; 0x757a <dtoa_prf+0x16a>
    7576:	61 e0       	ldi	r22, 0x01	; 1
    7578:	70 e0       	ldi	r23, 0x00	; 0
    757a:	64 0f       	add	r22, r20
    757c:	75 1f       	adc	r23, r21
    757e:	11 23       	and	r17, r17
    7580:	29 f0       	breq	.+10     	; 0x758c <dtoa_prf+0x17c>
    7582:	41 2f       	mov	r20, r17
    7584:	50 e0       	ldi	r21, 0x00	; 0
    7586:	4f 5f       	subi	r20, 0xFF	; 255
    7588:	5f 4f       	sbci	r21, 0xFF	; 255
    758a:	02 c0       	rjmp	.+4      	; 0x7590 <dtoa_prf+0x180>
    758c:	40 e0       	ldi	r20, 0x00	; 0
    758e:	50 e0       	ldi	r21, 0x00	; 0
    7590:	46 0f       	add	r20, r22
    7592:	57 1f       	adc	r21, r23
    7594:	6f 2d       	mov	r22, r15
    7596:	70 e0       	ldi	r23, 0x00	; 0
    7598:	46 17       	cp	r20, r22
    759a:	57 07       	cpc	r21, r23
    759c:	1c f4       	brge	.+6      	; 0x75a4 <dtoa_prf+0x194>
    759e:	0f 2d       	mov	r16, r15
    75a0:	04 1b       	sub	r16, r20
    75a2:	01 c0       	rjmp	.+2      	; 0x75a6 <dtoa_prf+0x196>
    75a4:	00 e0       	ldi	r16, 0x00	; 0
    75a6:	ff 24       	eor	r15, r15
    75a8:	a7 01       	movw	r20, r14
    75aa:	40 71       	andi	r20, 0x10	; 16
    75ac:	50 70       	andi	r21, 0x00	; 0
    75ae:	e4 fc       	sbrc	r14, 4
    75b0:	0d c0       	rjmp	.+26     	; 0x75cc <dtoa_prf+0x1bc>
    75b2:	e3 fc       	sbrc	r14, 3
    75b4:	0b c0       	rjmp	.+22     	; 0x75cc <dtoa_prf+0x1bc>
    75b6:	60 2f       	mov	r22, r16
    75b8:	d6 01       	movw	r26, r12
    75ba:	70 e2       	ldi	r23, 0x20	; 32
    75bc:	02 c0       	rjmp	.+4      	; 0x75c2 <dtoa_prf+0x1b2>
    75be:	7d 93       	st	X+, r23
    75c0:	61 50       	subi	r22, 0x01	; 1
    75c2:	66 23       	and	r22, r22
    75c4:	e1 f7       	brne	.-8      	; 0x75be <dtoa_prf+0x1ae>
    75c6:	c0 0e       	add	r12, r16
    75c8:	d1 1c       	adc	r13, r1
    75ca:	00 e0       	ldi	r16, 0x00	; 0
    75cc:	ee 23       	and	r30, r30
    75ce:	19 f0       	breq	.+6      	; 0x75d6 <dtoa_prf+0x1c6>
    75d0:	d6 01       	movw	r26, r12
    75d2:	ed 93       	st	X+, r30
    75d4:	6d 01       	movw	r12, r26
    75d6:	41 15       	cp	r20, r1
    75d8:	51 05       	cpc	r21, r1
    75da:	59 f4       	brne	.+22     	; 0x75f2 <dtoa_prf+0x1e2>
    75dc:	40 2f       	mov	r20, r16
    75de:	f6 01       	movw	r30, r12
    75e0:	50 e3       	ldi	r21, 0x30	; 48
    75e2:	02 c0       	rjmp	.+4      	; 0x75e8 <dtoa_prf+0x1d8>
    75e4:	51 93       	st	Z+, r21
    75e6:	41 50       	subi	r20, 0x01	; 1
    75e8:	44 23       	and	r20, r20
    75ea:	e1 f7       	brne	.-8      	; 0x75e4 <dtoa_prf+0x1d4>
    75ec:	c0 0e       	add	r12, r16
    75ee:	d1 1c       	adc	r13, r1
    75f0:	00 e0       	ldi	r16, 0x00	; 0
    75f2:	b8 0e       	add	r11, r24
    75f4:	fa 80       	ldd	r15, Y+2	; 0x02
    75f6:	a9 01       	movw	r20, r18
    75f8:	40 71       	andi	r20, 0x10	; 16
    75fa:	50 70       	andi	r21, 0x00	; 0
    75fc:	24 ff       	sbrs	r18, 4
    75fe:	04 c0       	rjmp	.+8      	; 0x7608 <dtoa_prf+0x1f8>
    7600:	bf 2d       	mov	r27, r15
    7602:	b1 33       	cpi	r27, 0x31	; 49
    7604:	09 f4       	brne	.+2      	; 0x7608 <dtoa_prf+0x1f8>
    7606:	ba 94       	dec	r11
    7608:	1b 14       	cp	r1, r11
    760a:	2c f4       	brge	.+10     	; 0x7616 <dtoa_prf+0x206>
    760c:	ab 2d       	mov	r26, r11
    760e:	a9 30       	cpi	r26, 0x09	; 9
    7610:	18 f0       	brcs	.+6      	; 0x7618 <dtoa_prf+0x208>
    7612:	a8 e0       	ldi	r26, 0x08	; 8
    7614:	01 c0       	rjmp	.+2      	; 0x7618 <dtoa_prf+0x208>
    7616:	a1 e0       	ldi	r26, 0x01	; 1
    7618:	9c 01       	movw	r18, r24
    761a:	97 ff       	sbrs	r25, 7
    761c:	02 c0       	rjmp	.+4      	; 0x7622 <dtoa_prf+0x212>
    761e:	20 e0       	ldi	r18, 0x00	; 0
    7620:	30 e0       	ldi	r19, 0x00	; 0
    7622:	bc 01       	movw	r22, r24
    7624:	6f 5f       	subi	r22, 0xFF	; 255
    7626:	7f 4f       	sbci	r23, 0xFF	; 255
    7628:	62 1b       	sub	r22, r18
    762a:	73 0b       	sbc	r23, r19
    762c:	fe 01       	movw	r30, r28
    762e:	31 96       	adiw	r30, 0x01	; 1
    7630:	e6 0f       	add	r30, r22
    7632:	f7 1f       	adc	r31, r23
    7634:	6e e2       	ldi	r22, 0x2E	; 46
    7636:	e6 2e       	mov	r14, r22
    7638:	bc 01       	movw	r22, r24
    763a:	6a 1b       	sub	r22, r26
    763c:	71 09       	sbc	r23, r1
    763e:	a1 2f       	mov	r26, r17
    7640:	b0 e0       	ldi	r27, 0x00	; 0
    7642:	aa 24       	eor	r10, r10
    7644:	bb 24       	eor	r11, r11
    7646:	aa 1a       	sub	r10, r26
    7648:	bb 0a       	sbc	r11, r27
    764a:	1f ef       	ldi	r17, 0xFF	; 255
    764c:	2f 3f       	cpi	r18, 0xFF	; 255
    764e:	31 07       	cpc	r19, r17
    7650:	19 f4       	brne	.+6      	; 0x7658 <dtoa_prf+0x248>
    7652:	d6 01       	movw	r26, r12
    7654:	ed 92       	st	X+, r14
    7656:	6d 01       	movw	r12, r26
    7658:	82 17       	cp	r24, r18
    765a:	93 07       	cpc	r25, r19
    765c:	2c f0       	brlt	.+10     	; 0x7668 <dtoa_prf+0x258>
    765e:	62 17       	cp	r22, r18
    7660:	73 07       	cpc	r23, r19
    7662:	14 f4       	brge	.+4      	; 0x7668 <dtoa_prf+0x258>
    7664:	10 81       	ld	r17, Z
    7666:	01 c0       	rjmp	.+2      	; 0x766a <dtoa_prf+0x25a>
    7668:	10 e3       	ldi	r17, 0x30	; 48
    766a:	21 50       	subi	r18, 0x01	; 1
    766c:	30 40       	sbci	r19, 0x00	; 0
    766e:	31 96       	adiw	r30, 0x01	; 1
    7670:	2a 15       	cp	r18, r10
    7672:	3b 05       	cpc	r19, r11
    7674:	24 f0       	brlt	.+8      	; 0x767e <dtoa_prf+0x26e>
    7676:	d6 01       	movw	r26, r12
    7678:	1d 93       	st	X+, r17
    767a:	6d 01       	movw	r12, r26
    767c:	e6 cf       	rjmp	.-52     	; 0x764a <dtoa_prf+0x23a>
    767e:	28 17       	cp	r18, r24
    7680:	39 07       	cpc	r19, r25
    7682:	49 f4       	brne	.+18     	; 0x7696 <dtoa_prf+0x286>
    7684:	bf 2d       	mov	r27, r15
    7686:	b6 33       	cpi	r27, 0x36	; 54
    7688:	28 f4       	brcc	.+10     	; 0x7694 <dtoa_prf+0x284>
    768a:	b5 33       	cpi	r27, 0x35	; 53
    768c:	21 f4       	brne	.+8      	; 0x7696 <dtoa_prf+0x286>
    768e:	41 15       	cp	r20, r1
    7690:	51 05       	cpc	r21, r1
    7692:	09 f4       	brne	.+2      	; 0x7696 <dtoa_prf+0x286>
    7694:	11 e3       	ldi	r17, 0x31	; 49
    7696:	f6 01       	movw	r30, r12
    7698:	11 93       	st	Z+, r17
    769a:	80 2f       	mov	r24, r16
    769c:	df 01       	movw	r26, r30
    769e:	90 e2       	ldi	r25, 0x20	; 32
    76a0:	02 c0       	rjmp	.+4      	; 0x76a6 <dtoa_prf+0x296>
    76a2:	9d 93       	st	X+, r25
    76a4:	81 50       	subi	r24, 0x01	; 1
    76a6:	88 23       	and	r24, r24
    76a8:	e1 f7       	brne	.-8      	; 0x76a2 <dtoa_prf+0x292>
    76aa:	e0 0f       	add	r30, r16
    76ac:	f1 1d       	adc	r31, r1
    76ae:	10 82       	st	Z, r1
    76b0:	20 e0       	ldi	r18, 0x00	; 0
    76b2:	30 e0       	ldi	r19, 0x00	; 0
    76b4:	c9 01       	movw	r24, r18
    76b6:	29 96       	adiw	r28, 0x09	; 9
    76b8:	ea e0       	ldi	r30, 0x0A	; 10
    76ba:	0c 94 6b 3c 	jmp	0x78d6	; 0x78d6 <__epilogue_restores__+0x10>

000076be <__ftoa_engine>:
    76be:	28 30       	cpi	r18, 0x08	; 8
    76c0:	08 f0       	brcs	.+2      	; 0x76c4 <__ftoa_engine+0x6>
    76c2:	27 e0       	ldi	r18, 0x07	; 7
    76c4:	33 27       	eor	r19, r19
    76c6:	da 01       	movw	r26, r20
    76c8:	99 0f       	add	r25, r25
    76ca:	31 1d       	adc	r19, r1
    76cc:	87 fd       	sbrc	r24, 7
    76ce:	91 60       	ori	r25, 0x01	; 1
    76d0:	00 96       	adiw	r24, 0x00	; 0
    76d2:	61 05       	cpc	r22, r1
    76d4:	71 05       	cpc	r23, r1
    76d6:	39 f4       	brne	.+14     	; 0x76e6 <__ftoa_engine+0x28>
    76d8:	32 60       	ori	r19, 0x02	; 2
    76da:	2e 5f       	subi	r18, 0xFE	; 254
    76dc:	3d 93       	st	X+, r19
    76de:	30 e3       	ldi	r19, 0x30	; 48
    76e0:	2a 95       	dec	r18
    76e2:	e1 f7       	brne	.-8      	; 0x76dc <__ftoa_engine+0x1e>
    76e4:	08 95       	ret
    76e6:	9f 3f       	cpi	r25, 0xFF	; 255
    76e8:	30 f0       	brcs	.+12     	; 0x76f6 <__ftoa_engine+0x38>
    76ea:	80 38       	cpi	r24, 0x80	; 128
    76ec:	71 05       	cpc	r23, r1
    76ee:	61 05       	cpc	r22, r1
    76f0:	09 f0       	breq	.+2      	; 0x76f4 <__ftoa_engine+0x36>
    76f2:	3c 5f       	subi	r19, 0xFC	; 252
    76f4:	3c 5f       	subi	r19, 0xFC	; 252
    76f6:	3d 93       	st	X+, r19
    76f8:	91 30       	cpi	r25, 0x01	; 1
    76fa:	08 f0       	brcs	.+2      	; 0x76fe <__ftoa_engine+0x40>
    76fc:	80 68       	ori	r24, 0x80	; 128
    76fe:	91 1d       	adc	r25, r1
    7700:	df 93       	push	r29
    7702:	cf 93       	push	r28
    7704:	1f 93       	push	r17
    7706:	0f 93       	push	r16
    7708:	ff 92       	push	r15
    770a:	ef 92       	push	r14
    770c:	19 2f       	mov	r17, r25
    770e:	98 7f       	andi	r25, 0xF8	; 248
    7710:	96 95       	lsr	r25
    7712:	e9 2f       	mov	r30, r25
    7714:	96 95       	lsr	r25
    7716:	96 95       	lsr	r25
    7718:	e9 0f       	add	r30, r25
    771a:	ff 27       	eor	r31, r31
    771c:	e4 52       	subi	r30, 0x24	; 36
    771e:	fe 4e       	sbci	r31, 0xEE	; 238
    7720:	99 27       	eor	r25, r25
    7722:	33 27       	eor	r19, r19
    7724:	ee 24       	eor	r14, r14
    7726:	ff 24       	eor	r15, r15
    7728:	a7 01       	movw	r20, r14
    772a:	e7 01       	movw	r28, r14
    772c:	05 90       	lpm	r0, Z+
    772e:	08 94       	sec
    7730:	07 94       	ror	r0
    7732:	28 f4       	brcc	.+10     	; 0x773e <__ftoa_engine+0x80>
    7734:	36 0f       	add	r19, r22
    7736:	e7 1e       	adc	r14, r23
    7738:	f8 1e       	adc	r15, r24
    773a:	49 1f       	adc	r20, r25
    773c:	51 1d       	adc	r21, r1
    773e:	66 0f       	add	r22, r22
    7740:	77 1f       	adc	r23, r23
    7742:	88 1f       	adc	r24, r24
    7744:	99 1f       	adc	r25, r25
    7746:	06 94       	lsr	r0
    7748:	a1 f7       	brne	.-24     	; 0x7732 <__ftoa_engine+0x74>
    774a:	05 90       	lpm	r0, Z+
    774c:	07 94       	ror	r0
    774e:	28 f4       	brcc	.+10     	; 0x775a <__ftoa_engine+0x9c>
    7750:	e7 0e       	add	r14, r23
    7752:	f8 1e       	adc	r15, r24
    7754:	49 1f       	adc	r20, r25
    7756:	56 1f       	adc	r21, r22
    7758:	c1 1d       	adc	r28, r1
    775a:	77 0f       	add	r23, r23
    775c:	88 1f       	adc	r24, r24
    775e:	99 1f       	adc	r25, r25
    7760:	66 1f       	adc	r22, r22
    7762:	06 94       	lsr	r0
    7764:	a1 f7       	brne	.-24     	; 0x774e <__ftoa_engine+0x90>
    7766:	05 90       	lpm	r0, Z+
    7768:	07 94       	ror	r0
    776a:	28 f4       	brcc	.+10     	; 0x7776 <__ftoa_engine+0xb8>
    776c:	f8 0e       	add	r15, r24
    776e:	49 1f       	adc	r20, r25
    7770:	56 1f       	adc	r21, r22
    7772:	c7 1f       	adc	r28, r23
    7774:	d1 1d       	adc	r29, r1
    7776:	88 0f       	add	r24, r24
    7778:	99 1f       	adc	r25, r25
    777a:	66 1f       	adc	r22, r22
    777c:	77 1f       	adc	r23, r23
    777e:	06 94       	lsr	r0
    7780:	a1 f7       	brne	.-24     	; 0x776a <__ftoa_engine+0xac>
    7782:	05 90       	lpm	r0, Z+
    7784:	07 94       	ror	r0
    7786:	20 f4       	brcc	.+8      	; 0x7790 <__ftoa_engine+0xd2>
    7788:	49 0f       	add	r20, r25
    778a:	56 1f       	adc	r21, r22
    778c:	c7 1f       	adc	r28, r23
    778e:	d8 1f       	adc	r29, r24
    7790:	99 0f       	add	r25, r25
    7792:	66 1f       	adc	r22, r22
    7794:	77 1f       	adc	r23, r23
    7796:	88 1f       	adc	r24, r24
    7798:	06 94       	lsr	r0
    779a:	a9 f7       	brne	.-22     	; 0x7786 <__ftoa_engine+0xc8>
    779c:	84 91       	lpm	r24, Z+
    779e:	10 95       	com	r17
    77a0:	17 70       	andi	r17, 0x07	; 7
    77a2:	41 f0       	breq	.+16     	; 0x77b4 <__ftoa_engine+0xf6>
    77a4:	d6 95       	lsr	r29
    77a6:	c7 95       	ror	r28
    77a8:	57 95       	ror	r21
    77aa:	47 95       	ror	r20
    77ac:	f7 94       	ror	r15
    77ae:	e7 94       	ror	r14
    77b0:	1a 95       	dec	r17
    77b2:	c1 f7       	brne	.-16     	; 0x77a4 <__ftoa_engine+0xe6>
    77b4:	e2 e8       	ldi	r30, 0x82	; 130
    77b6:	f1 e1       	ldi	r31, 0x11	; 17
    77b8:	68 94       	set
    77ba:	15 90       	lpm	r1, Z+
    77bc:	15 91       	lpm	r17, Z+
    77be:	35 91       	lpm	r19, Z+
    77c0:	65 91       	lpm	r22, Z+
    77c2:	95 91       	lpm	r25, Z+
    77c4:	05 90       	lpm	r0, Z+
    77c6:	7f e2       	ldi	r23, 0x2F	; 47
    77c8:	73 95       	inc	r23
    77ca:	e1 18       	sub	r14, r1
    77cc:	f1 0a       	sbc	r15, r17
    77ce:	43 0b       	sbc	r20, r19
    77d0:	56 0b       	sbc	r21, r22
    77d2:	c9 0b       	sbc	r28, r25
    77d4:	d0 09       	sbc	r29, r0
    77d6:	c0 f7       	brcc	.-16     	; 0x77c8 <__ftoa_engine+0x10a>
    77d8:	e1 0c       	add	r14, r1
    77da:	f1 1e       	adc	r15, r17
    77dc:	43 1f       	adc	r20, r19
    77de:	56 1f       	adc	r21, r22
    77e0:	c9 1f       	adc	r28, r25
    77e2:	d0 1d       	adc	r29, r0
    77e4:	7e f4       	brtc	.+30     	; 0x7804 <__ftoa_engine+0x146>
    77e6:	70 33       	cpi	r23, 0x30	; 48
    77e8:	11 f4       	brne	.+4      	; 0x77ee <__ftoa_engine+0x130>
    77ea:	8a 95       	dec	r24
    77ec:	e6 cf       	rjmp	.-52     	; 0x77ba <__ftoa_engine+0xfc>
    77ee:	e8 94       	clt
    77f0:	01 50       	subi	r16, 0x01	; 1
    77f2:	30 f0       	brcs	.+12     	; 0x7800 <__ftoa_engine+0x142>
    77f4:	08 0f       	add	r16, r24
    77f6:	0a f4       	brpl	.+2      	; 0x77fa <__ftoa_engine+0x13c>
    77f8:	00 27       	eor	r16, r16
    77fa:	02 17       	cp	r16, r18
    77fc:	08 f4       	brcc	.+2      	; 0x7800 <__ftoa_engine+0x142>
    77fe:	20 2f       	mov	r18, r16
    7800:	23 95       	inc	r18
    7802:	02 2f       	mov	r16, r18
    7804:	7a 33       	cpi	r23, 0x3A	; 58
    7806:	28 f0       	brcs	.+10     	; 0x7812 <__ftoa_engine+0x154>
    7808:	79 e3       	ldi	r23, 0x39	; 57
    780a:	7d 93       	st	X+, r23
    780c:	2a 95       	dec	r18
    780e:	e9 f7       	brne	.-6      	; 0x780a <__ftoa_engine+0x14c>
    7810:	10 c0       	rjmp	.+32     	; 0x7832 <__ftoa_engine+0x174>
    7812:	7d 93       	st	X+, r23
    7814:	2a 95       	dec	r18
    7816:	89 f6       	brne	.-94     	; 0x77ba <__ftoa_engine+0xfc>
    7818:	06 94       	lsr	r0
    781a:	97 95       	ror	r25
    781c:	67 95       	ror	r22
    781e:	37 95       	ror	r19
    7820:	17 95       	ror	r17
    7822:	17 94       	ror	r1
    7824:	e1 18       	sub	r14, r1
    7826:	f1 0a       	sbc	r15, r17
    7828:	43 0b       	sbc	r20, r19
    782a:	56 0b       	sbc	r21, r22
    782c:	c9 0b       	sbc	r28, r25
    782e:	d0 09       	sbc	r29, r0
    7830:	98 f0       	brcs	.+38     	; 0x7858 <__ftoa_engine+0x19a>
    7832:	23 95       	inc	r18
    7834:	7e 91       	ld	r23, -X
    7836:	73 95       	inc	r23
    7838:	7a 33       	cpi	r23, 0x3A	; 58
    783a:	08 f0       	brcs	.+2      	; 0x783e <__ftoa_engine+0x180>
    783c:	70 e3       	ldi	r23, 0x30	; 48
    783e:	7c 93       	st	X, r23
    7840:	20 13       	cpse	r18, r16
    7842:	b8 f7       	brcc	.-18     	; 0x7832 <__ftoa_engine+0x174>
    7844:	7e 91       	ld	r23, -X
    7846:	70 61       	ori	r23, 0x10	; 16
    7848:	7d 93       	st	X+, r23
    784a:	30 f0       	brcs	.+12     	; 0x7858 <__ftoa_engine+0x19a>
    784c:	83 95       	inc	r24
    784e:	71 e3       	ldi	r23, 0x31	; 49
    7850:	7d 93       	st	X+, r23
    7852:	70 e3       	ldi	r23, 0x30	; 48
    7854:	2a 95       	dec	r18
    7856:	e1 f7       	brne	.-8      	; 0x7850 <__ftoa_engine+0x192>
    7858:	11 24       	eor	r1, r1
    785a:	ef 90       	pop	r14
    785c:	ff 90       	pop	r15
    785e:	0f 91       	pop	r16
    7860:	1f 91       	pop	r17
    7862:	cf 91       	pop	r28
    7864:	df 91       	pop	r29
    7866:	99 27       	eor	r25, r25
    7868:	87 fd       	sbrc	r24, 7
    786a:	90 95       	com	r25
    786c:	08 95       	ret

0000786e <strrev>:
    786e:	dc 01       	movw	r26, r24
    7870:	fc 01       	movw	r30, r24
    7872:	67 2f       	mov	r22, r23
    7874:	71 91       	ld	r23, Z+
    7876:	77 23       	and	r23, r23
    7878:	e1 f7       	brne	.-8      	; 0x7872 <strrev+0x4>
    787a:	32 97       	sbiw	r30, 0x02	; 2
    787c:	04 c0       	rjmp	.+8      	; 0x7886 <strrev+0x18>
    787e:	7c 91       	ld	r23, X
    7880:	6d 93       	st	X+, r22
    7882:	70 83       	st	Z, r23
    7884:	62 91       	ld	r22, -Z
    7886:	ae 17       	cp	r26, r30
    7888:	bf 07       	cpc	r27, r31
    788a:	c8 f3       	brcs	.-14     	; 0x787e <strrev+0x10>
    788c:	08 95       	ret

0000788e <__prologue_saves__>:
    788e:	2f 92       	push	r2
    7890:	3f 92       	push	r3
    7892:	4f 92       	push	r4
    7894:	5f 92       	push	r5
    7896:	6f 92       	push	r6
    7898:	7f 92       	push	r7
    789a:	8f 92       	push	r8
    789c:	9f 92       	push	r9
    789e:	af 92       	push	r10
    78a0:	bf 92       	push	r11
    78a2:	cf 92       	push	r12
    78a4:	df 92       	push	r13
    78a6:	ef 92       	push	r14
    78a8:	ff 92       	push	r15
    78aa:	0f 93       	push	r16
    78ac:	1f 93       	push	r17
    78ae:	cf 93       	push	r28
    78b0:	df 93       	push	r29
    78b2:	cd b7       	in	r28, 0x3d	; 61
    78b4:	de b7       	in	r29, 0x3e	; 62
    78b6:	ca 1b       	sub	r28, r26
    78b8:	db 0b       	sbc	r29, r27
    78ba:	0f b6       	in	r0, 0x3f	; 63
    78bc:	f8 94       	cli
    78be:	de bf       	out	0x3e, r29	; 62
    78c0:	0f be       	out	0x3f, r0	; 63
    78c2:	cd bf       	out	0x3d, r28	; 61
    78c4:	09 94       	ijmp

000078c6 <__epilogue_restores__>:
    78c6:	2a 88       	ldd	r2, Y+18	; 0x12
    78c8:	39 88       	ldd	r3, Y+17	; 0x11
    78ca:	48 88       	ldd	r4, Y+16	; 0x10
    78cc:	5f 84       	ldd	r5, Y+15	; 0x0f
    78ce:	6e 84       	ldd	r6, Y+14	; 0x0e
    78d0:	7d 84       	ldd	r7, Y+13	; 0x0d
    78d2:	8c 84       	ldd	r8, Y+12	; 0x0c
    78d4:	9b 84       	ldd	r9, Y+11	; 0x0b
    78d6:	aa 84       	ldd	r10, Y+10	; 0x0a
    78d8:	b9 84       	ldd	r11, Y+9	; 0x09
    78da:	c8 84       	ldd	r12, Y+8	; 0x08
    78dc:	df 80       	ldd	r13, Y+7	; 0x07
    78de:	ee 80       	ldd	r14, Y+6	; 0x06
    78e0:	fd 80       	ldd	r15, Y+5	; 0x05
    78e2:	0c 81       	ldd	r16, Y+4	; 0x04
    78e4:	1b 81       	ldd	r17, Y+3	; 0x03
    78e6:	aa 81       	ldd	r26, Y+2	; 0x02
    78e8:	b9 81       	ldd	r27, Y+1	; 0x01
    78ea:	ce 0f       	add	r28, r30
    78ec:	d1 1d       	adc	r29, r1
    78ee:	0f b6       	in	r0, 0x3f	; 63
    78f0:	f8 94       	cli
    78f2:	de bf       	out	0x3e, r29	; 62
    78f4:	0f be       	out	0x3f, r0	; 63
    78f6:	cd bf       	out	0x3d, r28	; 61
    78f8:	ed 01       	movw	r28, r26
    78fa:	08 95       	ret

000078fc <_exit>:
    78fc:	f8 94       	cli

000078fe <__stop_program>:
    78fe:	ff cf       	rjmp	.-2      	; 0x78fe <__stop_program>
