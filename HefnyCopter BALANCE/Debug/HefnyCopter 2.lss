
HefnyCopter 2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000014  00800100  00007668  000076fc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00007668  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000701  00800114  00800114  00007710  2**0
                  ALLOC
  3 .stab         00003744  00000000  00000000  00007710  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000ddf  00000000  00000000  0000ae54  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000338  00000000  00000000  0000bc33  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00003f0f  00000000  00000000  0000bf6b  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000d3d6  00000000  00000000  0000fe7a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000024e0  00000000  00000000  0001d250  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000064a7  00000000  00000000  0001f730  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000a40  00000000  00000000  00025bd8  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000019b5  00000000  00000000  00026618  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000020d8  00000000  00000000  00027fcd  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubtypes 00000b63  00000000  00000000  0002a0a5  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000118  00000000  00000000  0002ac08  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 72 0b 	jmp	0x16e4	; 0x16e4 <__ctors_end>
       4:	0c 94 73 0a 	jmp	0x14e6	; 0x14e6 <__vector_1>
       8:	0c 94 35 0a 	jmp	0x146a	; 0x146a <__vector_2>
       c:	0c 94 e2 0a 	jmp	0x15c4	; 0x15c4 <__vector_3>
      10:	0c 94 8f 0b 	jmp	0x171e	; 0x171e <__bad_interrupt>
      14:	0c 94 36 0b 	jmp	0x166c	; 0x166c <__vector_5>
      18:	0c 94 9c 09 	jmp	0x1338	; 0x1338 <__vector_6>
      1c:	0c 94 b1 0a 	jmp	0x1562	; 0x1562 <__vector_7>
      20:	0c 94 8f 0b 	jmp	0x171e	; 0x171e <__bad_interrupt>
      24:	0c 94 8f 0b 	jmp	0x171e	; 0x171e <__bad_interrupt>
      28:	0c 94 8f 0b 	jmp	0x171e	; 0x171e <__bad_interrupt>
      2c:	0c 94 18 10 	jmp	0x2030	; 0x2030 <__vector_11>
      30:	0c 94 8f 0b 	jmp	0x171e	; 0x171e <__bad_interrupt>
      34:	0c 94 8f 0b 	jmp	0x171e	; 0x171e <__bad_interrupt>
      38:	0c 94 8f 0b 	jmp	0x171e	; 0x171e <__bad_interrupt>
      3c:	0c 94 01 10 	jmp	0x2002	; 0x2002 <__vector_15>
      40:	0c 94 8f 0b 	jmp	0x171e	; 0x171e <__bad_interrupt>
      44:	0c 94 8f 0b 	jmp	0x171e	; 0x171e <__bad_interrupt>
      48:	0c 94 43 09 	jmp	0x1286	; 0x1286 <__vector_18>
      4c:	0c 94 8f 0b 	jmp	0x171e	; 0x171e <__bad_interrupt>
      50:	0c 94 8f 0b 	jmp	0x171e	; 0x171e <__bad_interrupt>
      54:	0c 94 8f 0b 	jmp	0x171e	; 0x171e <__bad_interrupt>
      58:	0c 94 8f 0b 	jmp	0x171e	; 0x171e <__bad_interrupt>
      5c:	0c 94 8f 0b 	jmp	0x171e	; 0x171e <__bad_interrupt>
      60:	0c 94 ed 27 	jmp	0x4fda	; 0x4fda <__vector_24>
      64:	0c 94 8f 0b 	jmp	0x171e	; 0x171e <__bad_interrupt>
      68:	0c 94 8f 0b 	jmp	0x171e	; 0x171e <__bad_interrupt>
      6c:	0c 94 8f 0b 	jmp	0x171e	; 0x171e <__bad_interrupt>
      70:	0c 94 e9 10 	jmp	0x21d2	; 0x21d2 <__vector_28>
      74:	0c 94 8f 0b 	jmp	0x171e	; 0x171e <__bad_interrupt>
      78:	0c 94 8f 0b 	jmp	0x171e	; 0x171e <__bad_interrupt>

0000007c <_initSeq>:
      7c:	a2 a0 c8 40 a6 a4 2f 24 81 20 af 00                 ...@../$. ..

00000088 <masks.1993>:
      88:	01 02 04 08 10 20 40 80                             ..... @.

00000090 <defaultConfig>:
      90:	fe 00 ff 00 00 03 00 01 00 00 00 96 04 00 19 00     ................
      a0:	64 00 00 00 00 00 fd ff 14 00 00 00 19 00 64 00     d.............d.
      b0:	00 00 00 00 fd ff 14 00 00 00 32 00 5a 00 32 00     ..........2.Z.2.
      c0:	5a 00 00 00 14 00 c8 00 0a 00 5a 00 14 00 0f 00     Z.........Z.....
      d0:	fe ff 32 00 de 03 0a 00 5a 00 14 00 0f 00 fe ff     ..2.....Z.......
      e0:	32 00 de 03 0f 00 1e 00 00 00 00 00 00 00 00 00     2...............
      f0:	58 02 0f 00 19 00 00 00 00 00 00 00 00 00 00 00     X...............
	...
     144:	00 00 00 01 00                                      .....

00000149 <font12x16>:
     149:	0c 10 7a 11                                         ..z.

0000014d <_font12x16map>:
	...
     16d:	7c 00 ff 33 ff 33 7c 00 00 00 00 00 00 00 00 00     |..3.3|.........
     17d:	00 00 00 00 00 00 3c 00 3c 00 00 00 00 00 3c 00     ......<.<.....<.
     18d:	3c 00 00 00 00 00 00 00 00 00 00 02 10 1e 90 1f     <...............
     19d:	f0 03 7e 02 1e 1e 90 1f f0 03 7e 02 1e 00 10 00     ..~.......~.....
     1ad:	00 00 00 00 78 04 fc 0c cc 0c ff 3f ff 3f cc 0c     ....x......?.?..
     1bd:	cc 0f 88 07 00 00 00 00 00 00 00 30 38 38 38 1c     ...........0888.
     1cd:	38 0e 00 07 80 03 c0 01 e0 38 70 38 38 38 1c 00     8........8p888..
     1dd:	00 00 00 00 00 1f b8 3f fc 31 c6 21 e2 37 3e 1e     .......?.1.!.7>.
     1ed:	1c 1c 00 36 00 22 00 00 00 00 00 00 00 00 00 00     ...6."..........
     1fd:	27 00 3f 00 1f 00 00 00 00 00 00 00 00 00 00 00     '.?.............
     20d:	00 00 00 00 00 00 f0 03 fc 0f fe 1f 07 38 01 20     .............8. 
     21d:	01 20 00 00 00 00 00 00 00 00 00 00 00 00 01 20     . ............. 
     22d:	01 20 07 38 fe 1f fc 0f f0 03 00 00 00 00 00 00     . .8............
     23d:	00 00 00 00 98 0c b8 0e e0 03 f8 0f f8 0f e0 03     ................
     24d:	b8 0e 98 0c 00 00 00 00 00 00 00 00 80 01 80 01     ................
     25d:	80 01 f0 0f f0 0f 80 01 80 01 80 01 00 00 00 00     ................
	...
     275:	00 b8 00 f8 00 78 00 00 00 00 00 00 00 00 00 00     .....x..........
     285:	00 00 00 00 80 01 80 01 80 01 80 01 80 01 80 01     ................
     295:	80 01 80 01 00 00 00 00 00 00 00 00 00 00 00 00     ................
     2a5:	00 38 00 38 00 38 00 00 00 00 00 00 00 00 00 00     .8.8.8..........
     2b5:	00 00 00 18 00 1c 00 0e 00 07 80 03 c0 01 e0 00     ................
     2c5:	70 00 38 00 1c 00 0e 00 00 00 f8 07 fe 1f 06 1e     p.8.............
     2d5:	03 33 83 31 c3 30 63 30 33 30 1e 18 fe 1f f8 07     .3.1.0c030......
     2e5:	00 00 00 00 00 00 0c 30 0c 30 0e 30 ff 3f ff 3f     .......0.0.0.?.?
     2f5:	00 30 00 30 00 30 00 00 00 00 1c 30 1e 38 07 3c     .0.0.0.....0.8.<
     305:	03 3e 03 37 83 33 c3 31 e3 30 77 30 3e 30 1c 30     .>.7.3.1.0w0>0.0
     315:	00 00 0c 0c 0e 1c 07 38 c3 30 c3 30 c3 30 c3 30     .......8.0.0.0.0
     325:	c3 30 e7 39 7e 1f 3c 0e 00 00 c0 03 e0 03 70 03     .0.9~.<.......p.
     335:	38 03 1c 03 0e 03 07 03 ff 3f ff 3f 00 03 00 03     8........?.?....
     345:	00 00 3f 0c 7f 1c 63 38 63 30 63 30 63 30 63 30     ..?...c8c0c0c0c0
     355:	63 30 e3 38 c3 1f 83 0f 00 00 c0 0f f0 1f f8 39     c0.8...........9
     365:	dc 30 ce 30 c7 30 c3 30 c3 30 c3 39 80 1f 00 0f     .0.0.0.0.0.9....
     375:	00 00 03 00 03 00 03 00 03 30 03 3c 03 0f c3 03     .........0.<....
     385:	f3 00 3f 00 0f 00 03 00 00 00 00 0f bc 1f fe 39     ..?............9
     395:	e7 30 c3 30 c3 30 c3 30 e7 30 fe 39 bc 1f 00 0f     .0.0.0.0.0.9....
     3a5:	00 00 3c 00 7e 00 e7 30 c3 30 c3 30 c3 38 c3 1c     ..<.~..0.0.0.8..
     3b5:	c3 0e e7 07 fe 03 fc 00 00 00 00 00 00 00 00 00     ................
     3c5:	70 1c 70 1c 70 1c 00 00 00 00 00 00 00 00 00 00     p.p.p...........
	...
     3dd:	70 9c 70 fc 70 7c 00 00 00 00 00 00 00 00 00 00     p.p.p|..........
     3ed:	00 00 00 00 c0 00 e0 01 f0 03 38 07 1c 0e 0e 1c     ..........8.....
     3fd:	07 38 03 30 00 00 00 00 00 00 00 00 60 06 60 06     .8.0........`.`.
     40d:	60 06 60 06 60 06 60 06 60 06 60 06 60 06 00 00     `.`.`.`.`.`.`...
     41d:	00 00 00 00 03 30 07 38 0e 1c 1c 0e 38 07 f0 03     .....0.8....8...
     42d:	e0 01 c0 00 00 00 00 00 00 00 1c 00 1e 00 07 00     ................
     43d:	03 00 83 37 c3 37 e3 00 77 00 3e 00 1c 00 00 00     ...7.7..w.>.....
     44d:	00 00 f8 0f fe 1f 07 18 f3 33 fb 37 1b 36 fb 37     .........3.7.6.7
     45d:	fb 37 07 36 fe 03 f8 01 00 00 00 38 00 3f e0 07     .7.6.......8.?..
     46d:	fc 06 1f 06 1f 06 fc 06 e0 07 00 3f 00 38 00 00     ...........?.8..
     47d:	00 00 ff 3f ff 3f c3 30 c3 30 c3 30 c3 30 e7 30     ...?.?.0.0.0.0.0
     48d:	fe 39 bc 1f 00 0f 00 00 00 00 f0 03 fc 0f 0e 1c     .9..............
     49d:	07 38 03 30 03 30 03 30 07 38 0e 1c 0c 0c 00 00     .8.0.0.0.8......
     4ad:	00 00 ff 3f ff 3f 03 30 03 30 03 30 03 30 07 38     ...?.?.0.0.0.0.8
     4bd:	0e 1c fc 0f f0 03 00 00 00 00 ff 3f ff 3f c3 30     ...........?.?.0
     4cd:	c3 30 c3 30 c3 30 c3 30 c3 30 03 30 03 30 00 00     .0.0.0.0.0.0.0..
     4dd:	00 00 ff 3f ff 3f c3 00 c3 00 c3 00 c3 00 c3 00     ...?.?..........
     4ed:	c3 00 03 00 03 00 00 00 00 00 f0 03 fc 0f 0e 1c     ................
     4fd:	07 38 03 30 c3 30 c3 30 c3 30 c7 3f c6 3f 00 00     .8.0.0.0.0.?.?..
     50d:	00 00 ff 3f ff 3f c0 00 c0 00 c0 00 c0 00 c0 00     ...?.?..........
     51d:	c0 00 ff 3f ff 3f 00 00 00 00 00 00 00 00 03 30     ...?.?.........0
     52d:	03 30 ff 3f ff 3f 03 30 03 30 00 00 00 00 00 00     .0.?.?.0.0......
     53d:	00 00 00 0e 00 1e 00 38 00 30 00 30 00 30 00 30     .......8.0.0.0.0
     54d:	00 38 ff 1f ff 07 00 00 00 00 ff 3f ff 3f c0 00     .8.........?.?..
     55d:	e0 01 f0 03 38 07 1c 0e 0e 1c 07 38 03 30 00 00     ....8......8.0..
     56d:	00 00 ff 3f ff 3f 00 30 00 30 00 30 00 30 00 30     ...?.?.0.0.0.0.0
     57d:	00 30 00 30 00 30 00 00 00 00 ff 3f ff 3f 1e 00     .0.0.0.....?.?..
     58d:	78 00 e0 01 e0 01 78 00 1e 00 ff 3f ff 3f 00 00     x.....x....?.?..
     59d:	00 00 ff 3f ff 3f 0e 00 38 00 f0 00 c0 03 00 07     ...?.?..8.......
     5ad:	00 1c ff 3f ff 3f 00 00 00 00 f0 03 fc 0f 0e 1c     ...?.?..........
     5bd:	07 38 03 30 03 30 07 38 0e 1c fc 0f f0 03 00 00     .8.0.0.8........
     5cd:	00 00 ff 3f ff 3f 83 01 83 01 83 01 83 01 83 01     ...?.?..........
     5dd:	c7 01 fe 00 7c 00 00 00 00 00 f0 03 fc 0f 0e 1c     ....|...........
     5ed:	07 38 03 30 03 36 07 3e 0e 1c fc 3f f0 33 00 00     .8.0.6.>...?.3..
     5fd:	00 00 ff 3f ff 3f 83 01 83 01 83 03 83 07 83 0f     ...?.?..........
     60d:	c7 1d fe 38 7c 30 00 00 00 00 3c 0c 7e 1c e7 38     ...8|0....<.~..8
     61d:	c3 30 c3 30 c3 30 c3 30 c7 39 8e 1f 0c 0f 00 00     .0.0.0.0.9......
     62d:	00 00 00 00 03 00 03 00 03 00 ff 3f ff 3f 03 00     ...........?.?..
     63d:	03 00 03 00 00 00 00 00 00 00 ff 07 ff 1f 00 38     ...............8
     64d:	00 30 00 30 00 30 00 30 00 38 ff 1f ff 07 00 00     .0.0.0.0.8......
     65d:	00 00 07 00 3f 00 f8 01 c0 0f 00 3e 00 3e c0 0f     ....?......>.>..
     66d:	f8 01 3f 00 07 00 00 00 00 00 ff 3f ff 3f 00 1c     ..?........?.?..
     67d:	00 06 80 03 80 03 00 06 00 1c ff 3f ff 3f 00 00     ...........?.?..
     68d:	00 00 03 30 0f 3c 1c 0e 30 03 e0 01 e0 01 30 03     ...0.<..0.....0.
     69d:	1c 0e 0f 3c 03 30 00 00 00 00 03 00 0f 00 3c 00     ...<.0........<.
     6ad:	f0 00 c0 3f c0 3f f0 00 3c 00 0f 00 03 00 00 00     ...?.?..<.......
     6bd:	00 00 03 30 03 3c 03 3e 03 33 c3 31 e3 30 33 30     ...0.<.>.3.1.030
     6cd:	1f 30 0f 30 03 30 00 00 00 00 00 00 00 00 ff 3f     .0.0.0.........?
     6dd:	ff 3f 03 30 03 30 03 30 03 30 00 00 00 00 00 00     .?.0.0.0.0......
     6ed:	00 00 0e 00 1c 00 38 00 70 00 e0 00 c0 01 80 03     ......8.p.......
     6fd:	00 07 00 0e 00 1c 00 18 00 00 00 00 00 00 03 30     ...............0
     70d:	03 30 03 30 03 30 ff 3f ff 3f 00 00 00 00 00 00     .0.0.0.?.?......
     71d:	00 00 60 00 70 00 38 00 1c 00 0e 00 07 00 0e 00     ..`.p.8.........
     72d:	1c 00 38 00 70 00 60 00 00 00 00 c0 00 c0 00 c0     ..8.p.`.........
     73d:	00 c0 00 c0 00 c0 00 c0 00 c0 00 c0 00 c0 00 c0     ................

0000074d <font6x8>:
     74d:	06 08 8a 11                                         ....

00000751 <_font6x8map>:
	...
     759:	06 5f 06 00 00 07 03 00 07 03 00 24 7e 24 7e 24     ._.........$~$~$
     769:	00 24 2b 6a 12 00 00 63 13 08 64 63 00 36 49 56     .$+j...c..dc.6IV
     779:	20 50 00 00 07 03 00 00 00 00 3e 41 00 00 00 00      P........>A....
     789:	41 3e 00 00 00 08 3e 1c 3e 08 00 08 08 3e 08 08     A>....>.>....>..
     799:	00 00 e0 60 00 00 00 08 08 08 08 08 00 00 60 60     ...`..........``
     7a9:	00 00 00 20 10 08 04 02 00 3e 51 49 45 3e 00 00     ... .....>QIE>..
     7b9:	42 7f 40 00 00 62 51 49 49 46 00 22 49 49 49 36     B.@..bQIIF."III6
     7c9:	00 18 14 12 7f 10 00 2f 49 49 49 31 00 3c 4a 49     ......./III1.<JI
     7d9:	49 30 00 01 71 09 05 03 00 36 49 49 49 36 00 06     I0..q....6III6..
     7e9:	49 49 29 1e 00 00 6c 6c 00 00 00 00 ec 6c 00 00     II)...ll.....l..
     7f9:	00 08 14 22 41 00 00 24 24 24 24 24 00 00 41 22     ..."A..$$$$$..A"
     809:	14 08 00 02 01 59 09 06 00 3e 41 5d 55 1e 00 7e     .....Y...>A]U..~
     819:	11 11 11 7e 00 7f 49 49 49 36 00 3e 41 41 41 22     ...~..III6.>AAA"
     829:	00 7f 41 41 41 3e 00 7f 49 49 49 41 00 7f 09 09     ..AAA>..IIIA....
     839:	09 01 00 3e 41 49 49 7a 00 7f 08 08 08 7f 00 00     ...>AIIz........
     849:	41 7f 41 00 00 30 40 40 40 3f 00 7f 08 14 22 41     A.A..0@@@?...."A
     859:	00 7f 40 40 40 40 00 7f 02 04 02 7f 00 7f 02 04     ..@@@@..........
     869:	08 7f 00 3e 41 41 41 3e 00 7f 09 09 09 06 00 3e     ...>AAA>.......>
     879:	41 51 21 5e 00 7f 09 09 19 66 00 26 49 49 49 32     AQ!^.....f.&III2
     889:	00 01 01 7f 01 01 00 3f 40 40 40 3f 00 1f 20 40     .......?@@@?.. @
     899:	20 1f 00 3f 40 3c 40 3f 00 63 14 08 14 63 00 07      ..?@<@?.c...c..
     8a9:	08 70 08 07 00 71 49 45 43 00 00 00 7f 41 41 00     .p...qIEC....AA.
     8b9:	00 02 04 08 10 20 00 00 41 41 7f 00 00 04 02 01     ..... ..AA......
     8c9:	02 04 80 80 80 80 80 80 00 00 03 07 00 00 00 20     ............... 
     8d9:	54 54 54 78 00 7f 44 44 44 38 00 38 44 44 44 28     TTTx..DDD8.8DDD(
     8e9:	00 38 44 44 44 7f 00 38 54 54 54 08 00 08 7e 09     .8DDD..8TTT...~.
     8f9:	09 00 00 18 a4 a4 a4 7c 00 7f 04 04 78 00 00 00     .......|....x...
     909:	00 7d 40 00 00 40 80 84 7d 00 00 7f 10 28 44 00     .}@..@..}....(D.
     919:	00 00 00 7f 40 00 00 7c 04 18 04 78 00 7c 04 04     ....@..|...x.|..
     929:	78 00 00 38 44 44 44 38 00 fc 44 44 44 38 00 38     x..8DDD8..DDD8.8
     939:	44 44 44 fc 00 44 78 44 04 08 00 08 54 54 54 20     DDD..DxD....TTT 
     949:	00 04 3e 44 24 00 00 3c 40 20 7c 00 00 1c 20 40     ..>D$..<@ |... @
     959:	20 1c 00 3c 60 30 60 3c 00 6c 10 10 6c 00 00 9c      ..<`0`<.l..l...
     969:	a0 60 3c 00 00 64 54 54 4c 00 00 08 3e 41 41 00     .`<..dTTL...>AA.
     979:	00 00 00 77 00 00 00 00 41 41 3e 08 00 02 01 02     ...w....AA>.....
     989:	01 00 00 3c 26 23 26 3c                             ...<&#&<

00000991 <fonts>:
     991:	4d 07 49 01                                         M.I.

00000995 <glyArrowUp>:
     995:	08 08 30 38 3c 3e 3e 3c 38 30                       ..08<>><80

0000099f <glyArrowDown>:
     99f:	08 08 06 0e 1e 3e 3e 1e 0e 06                       .....>>...

000009a9 <glyBall>:
     9a9:	09 09 38 00 fe 00 fe 00 ff 01 ff 01 ff 01 fe 00     ..8.............
     9b9:	fe 00 38 00                                         ..8.

000009bd <glyDirCW>:
     9bd:	09 03 00 00 00 00 02 02 02 07 02                    ...........

000009c8 <glyDirCCW>:
     9c8:	05 03 02 07 02 02 02                                .......

000009cf <glyLogo>:
     9cf:	40 40 00 00 00 00 01 03 03 03 03 03 03 03 03 03     @@..............
     9df:	03 03 03 03 03 03 07 0f 1f 1f 3f 3f 7f 7f 7f 7f     ..........??....
     9ef:	7f 3f 1f 0f 00 03 03 03 03 03 03 03 03 03 03 03     .?..............
     9ff:	03 03 03 03 03 07 07 07 07 07 07 07 03 03 01 00     ................
     a0f:	00 00 00 00 00 00 ff ff 00 00 00 00 00 00 00 00     ................
     a1f:	00 01 1f 7f ff ff ff ff ff e7 c3 e7 ff ff ff ff     ................
     a2f:	ff ff fe f0 00 00 00 00 00 00 00 00 00 07 0f 3f     ...............?
     a3f:	7f ff ff ff fc fc ff ff ff ff ff ff ff ff 7c c3     ..............|.
     a4f:	00 00 00 00 00 00 ff ff 00 00 00 00 00 00 00 00     ................
     a5f:	00 00 f0 f8 fc fe fe fe fe fc fc fd fb f7 f7 ef     ................
     a6f:	df 0b 00 00 00 00 00 00 00 01 03 03 ff ff ff ff     ................
     a7f:	ff ff ff ff 7f 7f ff ff ff fe fc f8 e0 80 7f ff     ................
     a8f:	00 00 00 00 00 00 ff ff 00 00 00 00 00 00 00 00     ................
	...
     aa7:	00 00 00 80 fd ff ff ff ff ff 7f 1f 3f 7f 7f fe     ............?...
     ab7:	fe fc f8 f8 f0 f0 e0 c0 c0 e0 c0 c0 c0 c0 80 80     ................
     ac7:	00 00 00 00 00 00 ff ff 00 00 00 00 00 00 ff ff     ................
     ad7:	00 00 01 01 03 03 07 07 07 0f 07 07 07 03 03 07     ................
     ae7:	0f 0f 3f 7f ff ff fe fe ff ff ff ff ff af 03 00     ..?.............
	...
     b0b:	00 00 ff ff 00 00 00 00 00 00 ff ff 3f 7f ff ff     ............?...
     b1b:	fc f8 fc ff ff ff ff ff ff ff ff e8 c0 c0 80 80     ................
     b2b:	00 00 00 00 80 f9 ff ff ff ff ff 7f 7f 7f 7f ff     ................
     b3b:	7f 7f 7f 3f 1f 01 00 00 00 00 00 00 00 00 00 00     ...?............
     b4b:	00 00 ff ff 00 00 00 00 00 fe ff ff ff ff ff ff     ................
     b5b:	ff 7f ff ff ff ff fe fc f0 e0 00 00 00 00 00 00     ................
     b6b:	00 00 01 1f 7f ff ff ff ff ff c7 c7 cf ff ff ff     ................
     b7b:	ff ff ff fe f0 00 00 00 00 00 00 00 00 00 00 00     ................
     b8b:	00 00 ff ff 00 00 00 00 00 00 f0 f8 d8 d8 f8 d8     ................
     b9b:	d8 d8 d8 98 18 18 18 18 18 18 18 18 18 18 18 18     ................
     bab:	18 18 18 f8 f8 fc fc fc fe fc fc fc fc f8 f0 f0     ................
     bbb:	d8 d8 18 18 18 18 18 18 18 18 18 18 18 18 18 18     ................
     bcb:	18 18 f8 f0 00 00                                   ......

00000bd1 <scrESCCal>:
     bd1:	f9 0d 63 0e                                         ..c.

00000bd5 <lstMenu>:
     bd5:	97 0e a7 0e b5 0e c3 0e d1 0e e0 0e ec 0e fa 0e     ................
     be5:	0d 0f 1d 0f 2d 0f 33 0f                             ....-.3.

00000bed <strAreYouSure>:
     bed:	41 72 65 20 79 6f 75 20 73 75 72 65 3f 00           Are you sure?.

00000bfb <__c.2269>:
     bfb:	4d 65 61 73 00                                      Meas.

00000c00 <_skMENUSAVE>:
     c00:	53 41 56 45 20 55 50 20 20 20 44 4f 57 4e 20 20     SAVE UP   DOWN  
     c10:	45 4e 54 45 52 00                                   ENTER.

00000c16 <__c.2262>:
     c16:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
	...

00000c27 <_skEDIT>:
     c27:	43 41 4e 43 45 4c 20 20 44 4f 57 4e 20 20 20 55     CANCEL  DOWN   U
     c37:	50 20 20 4f 4b 00                                   P  OK.

00000c3d <__c.2252>:
     c3d:	41 43 43 2d 5a 20 64 61 6d 70 69 6e 67 00           ACC-Z damping.

00000c4b <__c.2239>:
     c4b:	54 72 69 6d 20 50 3a 20 20 20 20 52 3a 00           Trim P:    R:.

00000c59 <__c.2237>:
     c59:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
	...

00000c6a <__c.2232>:
     c6a:	52 00                                               R.

00000c6c <__c.2230>:
     c6c:	4e 00                                               N.

00000c6e <__c.2228>:
     c6e:	52 65 76 65 72 73 65 20 47 59 52 4f 00              Reverse GYRO.

00000c7b <__c.2226>:
     c7b:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
	...

00000c8c <__c.2211>:
     c8c:	6e 6f 20 00                                         no .

00000c90 <__c.2209>:
     c90:	79 65 73 00                                         yes.

00000c94 <strYes>:
     c94:	59 65 73 00                                         Yes.

00000c98 <strNo>:
     c98:	4e 6f 20 00                                         No .

00000c9c <__c.2199>:
     c9c:	41 20 54 72 69 20 00                                A Tri .

00000ca3 <__c.2197>:
     ca3:	59 20 54 72 69 20 00                                Y Tri .

00000caa <__c.2195>:
     caa:	58 20 51 75 61 64 00                                X Quad.

00000cb1 <__c.2193>:
     cb1:	2b 20 51 75 61 64 00                                + Quad.

00000cb8 <__c.2191>:
     cb8:	58 20 51 75 61 64 00                                X Quad.

00000cbf <__c.2189>:
     cbf:	2b 20 51 75 61 64 00                                + Quad.

00000cc6 <__c.2187>:
     cc6:	55 41 52 54 20 00                                   UART .

00000ccc <__c.2185>:
     ccc:	42 75 64 64 79 00                                   Buddy.

00000cd2 <__c.2183>:
     cd2:	54 52 49 20 00                                      TRI .

00000cd7 <__c.2181>:
     cd7:	51 75 61 64 00                                      Quad.

00000cdc <_skBACK>:
     cdc:	42 41 43 4b 20 20 20 20 20 20 20 20 20 20 20 20     BACK            
     cec:	20 20 20 20 20 00                                        .

00000cf2 <strSPC1>:
     cf2:	20 00                                                .

00000cf4 <strErr>:
     cf4:	45 72 72 00                                         Err.

00000cf8 <strSPC4>:
     cf8:	20 20 20 20 00                                          .

00000cfd <__c.2154>:
     cfd:	4e 41 00                                            NA.

00000d00 <strARMED>:
     d00:	41 52 4d 45 44 00                                   ARMED.

00000d06 <strVersionInfo>:
     d06:	48 65 66 6e 79 43 6f 70 74 65 72 32 20 76 31 2e     HefnyCopter2 v1.
     d16:	30 2e 30 00                                         0.0.

00000d1a <strOK>:
     d1a:	4f 4b 20 00                                         OK .

00000d1e <str1>:
     d1e:	31 00                                               1.

00000d20 <strX>:
     d20:	58 00                                               X.

00000d22 <str2>:
     d22:	32 00                                               2.

00000d24 <__c.2125>:
     d24:	2b 00                                               +.

00000d26 <__c.2123>:
     d26:	58 00                                               X.

00000d28 <__c.2121>:
     d28:	59 00                                               Y.

00000d2a <__c.2119>:
     d2a:	2b 00                                               +.

00000d2c <__c.2117>:
     d2c:	41 00                                               A.

00000d2e <__c.2115>:
     d2e:	58 00                                               X.

00000d30 <__c.2113>:
     d30:	55 41 52 54 20 00                                   UART .

00000d36 <__c.2111>:
     d36:	42 75 64 64 79 00                                   Buddy.

00000d3c <__c.2109>:
     d3c:	54 52 49 20 00                                      TRI .

00000d41 <__c.2107>:
     d41:	51 75 61 64 00                                      Quad.

00000d46 <__c.2105>:
     d46:	41 4c 54 48 4c 44 00                                ALTHLD.

00000d4d <__c.2103>:
     d4d:	53 54 41 42 4c 45 00                                STABLE.

00000d54 <__c.2101>:
     d54:	41 43 52 4f 20 20 00                                ACRO  .

00000d5b <pages>:
     d5b:	41 0f b5 2c 57 0f 8b 0f 56 35 00 00 41 0f 99 2c     A..,W...V5..A..,
     d6b:	a1 0f a5 0f 6a 29 bb 0f a5 0f 31 28 f0 0f 8b 0f     ....j)....1(....
     d7b:	54 31 05 10 8b 0f 4d 2f 05 10 8b 0f a3 2e 05 10     T1....M/........
     d8b:	8b 0f e4 33 4c 10 83 10 3b 33 99 10 dc 0c 04 29     ...3L...;3.....)
     d9b:	e3 10 dc 0c 00 2c 19 11 49 11 ca 28 e3 10 5f 11     .....,..I..(.._.
     dab:	78 2a 19 11 49 11 7c 2c f9 0d dc 0c 57 28 00 00     x*..I.|,....W(..
     dbb:	75 11 6b 2c 00 00                                   u.k,..

00000dc1 <__c.2034>:
     dc1:	59 41 57 20 20 20 20 20 20 20 20 20 20 00           YAW          .

00000dcf <__c.2031>:
     dcf:	52 6f 6c 6c 20 20 20 20 20 20 20 20 20 00           Roll         .

00000ddd <__c.2027>:
     ddd:	50 69 74 63 68 20 26 20 52 6f 6c 6c 20 00           Pitch & Roll .

00000deb <__c.2025>:
     deb:	50 69 74 63 68 20 20 20 20 20 20 20 20 00           Pitch        .

00000df9 <scrESCCal0>:
     df9:	2d 54 41 4b 45 20 4f 46 46 20 50 52 4f 50 45 4c     -TAKE OFF PROPEL
     e09:	4c 45 52 53 21 21 0a 2d 50 72 65 73 73 20 63 6f     LERS!!.-Press co
     e19:	6e 74 69 6e 75 65 0a 2d 54 75 72 6e 20 4f 66 66     ntinue.-Turn Off
     e29:	20 51 75 61 64 63 6f 70 74 65 72 2e 0a 0a 2d 51      Quadcopter...-Q
     e39:	75 61 64 20 77 69 6c 6c 20 73 74 61 72 74 65 64     uad will started
     e49:	0a 69 6e 20 41 52 4d 45 44 20 54 41 4b 45 43 41     .in ARMED TAKECA
     e59:	52 45 20 73 74 61 74 65 0a 00                       RE state..

00000e63 <scrESCCal1>:
     e63:	50 72 65 73 73 20 43 6f 6e 74 69 6e 75 65 20 61     Press Continue a
     e73:	66 74 65 72 20 63 61 6c 69 62 72 61 74 69 6f 6e     fter calibration
     e83:	2e 0a 0a 75 6e 70 6c 75 67 20 62 61 74 74 65 72     ...unplug batter
     e93:	79 2e 0a 00                                         y...

00000e97 <strStabilization>:
     e97:	47 79 72 6f 20 50 49 44 20 45 64 69 74 6f 72 00     Gyro PID Editor.

00000ea7 <strSelflevel>:
     ea7:	53 65 6c 66 20 4c 65 76 65 6c 69 6e 67 00           Self Leveling.

00000eb5 <strAltitudeHold>:
     eb5:	41 6c 74 69 74 75 64 65 20 48 6f 6c 64 00           Altitude Hold.

00000ec3 <strModeSettings>:
     ec3:	4d 6f 64 65 20 53 65 74 74 69 6e 67 73 00           Mode Settings.

00000ed1 <strMiscSettings>:
     ed1:	4d 69 73 63 2e 20 53 65 74 74 69 6e 67 73 00        Misc. Settings.

00000ee0 <strSensorTest>:
     ee0:	53 65 6e 73 6f 72 20 54 65 73 74 00                 Sensor Test.

00000eec <strReceiverTest>:
     eec:	52 65 63 65 69 76 65 72 20 54 65 73 74 00           Receiver Test.

00000efa <strSensorCalibration>:
     efa:	53 65 6e 73 6f 72 20 43 61 6c 69 62 72 61 74 69     Sensor Calibrati
     f0a:	6f 6e 00                                            on.

00000f0d <strRadioCalibration>:
     f0d:	53 74 69 63 6b 20 43 65 6e 74 65 72 69 6e 67 00     Stick Centering.

00000f1d <strESCCalibration>:
     f1d:	45 53 43 20 43 61 6c 69 62 72 61 74 69 6f 6e 00     ESC Calibration.

00000f2d <strDebug>:
     f2d:	44 65 62 75 67 00                                   Debug.

00000f33 <strFactoryReset>:
     f33:	46 61 63 74 6f 72 79 20 52 65 73 65 74 00           Factory Reset.

00000f41 <_skHOME>:
     f41:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     f51:	20 4d 45 4e 55 00                                    MENU.

00000f57 <scrHomePage>:
     f57:	0a 0a 42 61 74 74 3a 20 20 20 20 20 20 20 76 0a     ..Batt:       v.
     f67:	0a 0a 52 58 3a 20 2d 20 20 53 4e 3a 20 20 20 20     ..RX: -  SN:    
     f77:	53 54 3a 20 2d 0a 46 6c 79 3a 20 20 20 42 6f 61     ST: -.Fly:   Boa
     f87:	72 64 3a 00                                         rd:.

00000f8b <_skMENU>:
     f8b:	42 41 43 4b 20 55 50 20 20 20 44 4f 57 4e 20 20     BACK UP   DOWN  
     f9b:	45 4e 54 45 52 00                                   ENTER.

00000fa1 <scrHomePageArmed>:
     fa1:	0a 0a 0a 00                                         ....

00000fa5 <_skSAVE>:
     fa5:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     fb5:	20 44 4f 4e 45 00                                    DONE.

00000fbb <scrHomePageArmedESCCalibration>:
     fbb:	0a 0a 0a 4d 31 3a 20 20 20 20 20 20 20 4d 34 3a     ...M1:       M4:
     fcb:	0a 4d 32 3a 20 20 20 20 20 20 20 4d 33 3a 0a 45     .M2:       M3:.E
     fdb:	53 43 20 43 61 6c 69 62 72 61 74 69 6f 6e 20 6d     SC Calibration m
     feb:	6f 64 65 0a 00                                      ode..

00000ff0 <scrHomePageRestart>:
     ff0:	0a 52 45 53 54 41 52 54 0a 20 20 20 20 20 20 42     .RESTART.      B
    1000:	4f 41 52 44 00                                      OARD.

00001005 <scrStabilization>:
    1005:	0a 50 3a 20 20 20 20 20 20 20 4c 69 6d 3a 0a 49     .P:       Lim:.I
    1015:	3a 20 20 20 20 20 20 20 4c 69 6d 3a 0a 44 3a 20     :       Lim:.D: 
    1025:	20 20 20 20 20 20 4c 69 6d 3a 0a 4e 6f 69 73 65           Lim:.Noise
    1035:	20 46 69 6c 74 65 72 3a 0a 54 72 69 6d 20 50 3a      Filter:.Trim P:
    1045:	20 20 20 20 52 3a 00                                    R:.

0000104c <scrModeSettings>:
    104c:	46 72 61 6d 65 20 54 79 70 65 3a 0a 42 75 64 64     Frame Type:.Budd
    105c:	79 20 53 79 73 74 65 6d 3a 0a 42 6f 61 72 64 20     y System:.Board 
    106c:	44 69 72 3a 0a 46 6c 79 20 20 20 44 69 72 3a 0a     Dir:.Fly   Dir:.
    107c:	53 6f 6e 61 72 3a 00                                Sonar:.

00001083 <_skPAGE>:
    1083:	42 41 43 4b 20 50 52 45 56 20 4e 45 58 54 20 43     BACK PREV NEXT C
    1093:	48 41 4e 47 45 00                                   HANGE.

00001099 <scrMiscSettings>:
    1099:	41 75 74 6f 20 44 69 73 61 72 6d 3a 0a 56 6f 6c     Auto Disarm:.Vol
    10a9:	74 20 41 6c 61 72 6d 3a 20 20 20 20 20 20 2f 31     t Alarm:      /1
    10b9:	30 76 0a 54 68 72 6f 74 74 6c 65 20 6d 69 6e 3a     0v.Throttle min:
    10c9:	0a 53 74 69 63 6b 20 53 63 61 6c 65 3a 0a 50 2d     .Stick Scale:.P-
    10d9:	52 20 4c 69 6e 6b 65 64 3a 00                       R Linked:.

000010e3 <scrSensorTest>:
    10e3:	47 79 72 6f 20 58 3a 0a 47 79 72 6f 20 59 3a 0a     Gyro X:.Gyro Y:.
    10f3:	47 79 72 6f 20 5a 3a 0a 41 63 63 20 20 58 3a 0a     Gyro Z:.Acc  X:.
    1103:	41 63 63 20 20 59 3a 0a 41 63 63 20 20 5a 3a 0a     Acc  Y:.Acc  Z:.
    1113:	42 61 74 74 3a 00                                   Batt:.

00001119 <scrReceiverTest>:
    1119:	20 43 48 20 20 20 52 58 2d 31 20 20 20 20 52 58      CH   RX-1    RX
    1129:	2d 32 0a 41 69 6c 3a 0a 45 6c 65 3a 0a 52 75 64     -2.Ail:.Ele:.Rud
    1139:	3a 0a 54 68 72 3a 0a 41 75 78 3a 0a 52 58 3a 00     :.Thr:.Aux:.RX:.

00001149 <_skCONTINUE>:
    1149:	42 41 43 4b 20 20 20 20 20 20 20 20 20 43 4f 4e     BACK         CON
    1159:	54 49 4e 55 45 00                                   TINUE.

0000115f <_skCLRDONE>:
    115f:	42 41 43 4b 20 43 4c 52 20 20 20 20 20 20 20 20     BACK CLR        
    116f:	20 44 4f 4e 45 00                                    DONE.

00001175 <_skCANCELYES>:
    1175:	4e 4f 20 20 20 20 20 20 20 20 20 20 20 20 20 20     NO              
    1185:	20 20 59 45 53 00 00 40 7a 10 f3 5a 00 a0 72 4e       YES..@z..Z..rN
    1195:	18 09 00 10 a5 d4 e8 00 00 e8 76 48 17 00 00 e4     ..........vH....
    11a5:	0b 54 02 00 00 ca 9a 3b 00 00 00 e1 f5 05 00 00     .T.....;........
    11b5:	80 96 98 00 00 00 40 42 0f 00 00 00 a0 86 01 00     ......@B........
    11c5:	00 00 10 27 00 00 00 00 e8 03 00 00 00 00 64 00     ...'..........d.
    11d5:	00 00 00 00 0a 00 00 00 00 00 01 00 00 00 00 00     ................
    11e5:	2c 76 d8 88 dc 67 4f 08 23 df c1 df ae 59 e1 b1     ,v...gO.#....Y..
    11f5:	b7 96 e5 e3 e4 53 c6 3a e6 51 99 76 96 e8 e6 c2     .....S.:.Q.v....
    1205:	84 26 eb 89 8c 9b 62 ed 40 7c 6f fc ef bc 9c 9f     .&....b.@|o.....
    1215:	40 f2 ba a5 6f a5 f4 90 05 5a 2a f7 5c 93 6b 6c     @...o....Z*.\.kl
    1225:	f9 67 6d c1 1b fc e0 e4 0d 47 fe f5 20 e6 b5 00     .gm......G.. ...
    1235:	d0 ed 90 2e 03 00 94 35 77 05 00 80 84 1e 08 00     .......5w.......
    1245:	00 20 4e 0a 00 00 00 c8 0c 33 33 33 33 0f 98 6e     . N......3333..n
    1255:	12 83 11 41 ef 8d 21 14 89 3b e6 55 16 cf fe e6     ...A..!..;.U....
    1265:	db 18 d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb e4 24     ....K8..|......$
    1275:	20 32 84 72 5e 22 81 00 c9 f1 24 ec a1 e5 3d 27      2.r^"....$...='
	...

00001286 <__vector_18>:
	sendData(column & 0x0f, LCD_COMMAND);
}

__attribute__ ((section(".lowtext")))
ISR(TIMER0_OVF_vect, ISR_NOBLOCK)
{
    1286:	78 94       	sei
    1288:	1f 92       	push	r1
    128a:	0f 92       	push	r0
    128c:	0f b6       	in	r0, 0x3f	; 63
    128e:	0f 92       	push	r0
    1290:	11 24       	eor	r1, r1
    1292:	2f 93       	push	r18
    1294:	3f 93       	push	r19
    1296:	4f 93       	push	r20
    1298:	5f 93       	push	r21
    129a:	6f 93       	push	r22
    129c:	7f 93       	push	r23
    129e:	8f 93       	push	r24
    12a0:	9f 93       	push	r25
    12a2:	af 93       	push	r26
    12a4:	bf 93       	push	r27
    12a6:	cf 93       	push	r28
    12a8:	df 93       	push	r29
    12aa:	ef 93       	push	r30
    12ac:	ff 93       	push	r31
	TCNT0_X +=1;
    12ae:	80 91 a6 05 	lds	r24, 0x05A6
    12b2:	90 91 a7 05 	lds	r25, 0x05A7
    12b6:	01 96       	adiw	r24, 0x01	; 1
    12b8:	90 93 a7 05 	sts	0x05A7, r25
    12bc:	80 93 a6 05 	sts	0x05A6, r24
	static uint16_t offset;
	
	if (offset % LCDWIDTH == 0)
    12c0:	c0 91 1d 05 	lds	r28, 0x051D
    12c4:	d0 91 1e 05 	lds	r29, 0x051E
    12c8:	ce 01       	movw	r24, r28
    12ca:	8f 77       	andi	r24, 0x7F	; 127
    12cc:	90 70       	andi	r25, 0x00	; 0
    12ce:	00 97       	sbiw	r24, 0x00	; 0
    12d0:	99 f4       	brne	.+38     	; 0x12f8 <__vector_18+0x72>
		setPos(offset / LCDWIDTH, 0);
    12d2:	ce 01       	movw	r24, r28
    12d4:	88 0f       	add	r24, r24
    12d6:	89 2f       	mov	r24, r25
    12d8:	88 1f       	adc	r24, r24
    12da:	99 0b       	sbc	r25, r25
    12dc:	91 95       	neg	r25
	LCD_CS = 1;
}

static void setPos(uint8_t line, uint8_t column)
{
	sendData(0xB0 | (line & 0x07), LCD_COMMAND);
    12de:	87 70       	andi	r24, 0x07	; 7
    12e0:	80 6b       	ori	r24, 0xB0	; 176
    12e2:	60 e0       	ldi	r22, 0x00	; 0
    12e4:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <sendData>
	sendData(0x10 | (column >> 4), LCD_COMMAND);
    12e8:	80 e1       	ldi	r24, 0x10	; 16
    12ea:	60 e0       	ldi	r22, 0x00	; 0
    12ec:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <sendData>
	sendData(column & 0x0f, LCD_COMMAND);
    12f0:	80 e0       	ldi	r24, 0x00	; 0
    12f2:	60 e0       	ldi	r22, 0x00	; 0
    12f4:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <sendData>
	static uint16_t offset;
	
	if (offset % LCDWIDTH == 0)
		setPos(offset / LCDWIDTH, 0);
		
	sendData(*(_screen + offset++), LCD_DATA);
    12f8:	fe 01       	movw	r30, r28
    12fa:	e3 5e       	subi	r30, 0xE3	; 227
    12fc:	fe 4f       	sbci	r31, 0xFE	; 254
    12fe:	80 81       	ld	r24, Z
    1300:	61 e0       	ldi	r22, 0x01	; 1
    1302:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <sendData>
    1306:	21 96       	adiw	r28, 0x01	; 1
	offset %= sizeof(_screen);
    1308:	d3 70       	andi	r29, 0x03	; 3
    130a:	d0 93 1e 05 	sts	0x051E, r29
    130e:	c0 93 1d 05 	sts	0x051D, r28
}
    1312:	ff 91       	pop	r31
    1314:	ef 91       	pop	r30
    1316:	df 91       	pop	r29
    1318:	cf 91       	pop	r28
    131a:	bf 91       	pop	r27
    131c:	af 91       	pop	r26
    131e:	9f 91       	pop	r25
    1320:	8f 91       	pop	r24
    1322:	7f 91       	pop	r23
    1324:	6f 91       	pop	r22
    1326:	5f 91       	pop	r21
    1328:	4f 91       	pop	r20
    132a:	3f 91       	pop	r19
    132c:	2f 91       	pop	r18
    132e:	0f 90       	pop	r0
    1330:	0f be       	out	0x3f, r0	; 63
    1332:	0f 90       	pop	r0
    1334:	1f 90       	pop	r1
    1336:	18 95       	reti

00001338 <__vector_6>:
 
 uint8_t OldPortCValue;

__attribute__ ((section(".lowtext")))
ISR (RX2_ALL_vect)
{
    1338:	1f 92       	push	r1
    133a:	0f 92       	push	r0
    133c:	0f b6       	in	r0, 0x3f	; 63
    133e:	0f 92       	push	r0
    1340:	11 24       	eor	r1, r1
    1342:	0f 93       	push	r16
    1344:	1f 93       	push	r17
    1346:	2f 93       	push	r18
    1348:	3f 93       	push	r19
    134a:	4f 93       	push	r20
    134c:	5f 93       	push	r21
    134e:	6f 93       	push	r22
    1350:	7f 93       	push	r23
    1352:	8f 93       	push	r24
    1354:	9f 93       	push	r25
    1356:	af 93       	push	r26
    1358:	bf 93       	push	r27
    135a:	cf 93       	push	r28
    135c:	df 93       	push	r29
    135e:	ef 93       	push	r30
    1360:	ff 93       	push	r31
	uint8_t Changes = PINC ^ OldPortCValue;  // capture changed bit
    1362:	16 b1       	in	r17, 0x06	; 6
    1364:	80 91 ed 07 	lds	r24, 0x07ED
    1368:	18 27       	eor	r17, r24
	OldPortCValue = PINC;
    136a:	86 b1       	in	r24, 0x06	; 6
    136c:	80 93 ed 07 	sts	0x07ED, r24
	uint16_t TCNT1_TEMP = TCNT1;
    1370:	c0 91 84 00 	lds	r28, 0x0084
    1374:	d0 91 85 00 	lds	r29, 0x0085
	// if there is a signal change in ROLL
	if ((Changes & RX2_ROLL_PIN)!=0)
    1378:	01 2f       	mov	r16, r17
    137a:	15 ff       	sbrs	r17, 5
    137c:	18 c0       	rjmp	.+48     	; 0x13ae <__vector_6+0x76>
	{
		if (RX2_ROLL)
    137e:	86 b1       	in	r24, 0x06	; 6
    1380:	85 ff       	sbrs	r24, 5
    1382:	05 c0       	rjmp	.+10     	; 0x138e <__vector_6+0x56>
		{
			RX_raw[1][RXChannel_AIL]=TCNT1_TEMP;
    1384:	d0 93 fb 07 	sts	0x07FB, r29
    1388:	c0 93 fa 07 	sts	0x07FA, r28
    138c:	10 c0       	rjmp	.+32     	; 0x13ae <__vector_6+0x76>
		}
		else
		{
			CalculateSignalLength2 (RXChannel_AIL);
    138e:	80 e0       	ldi	r24, 0x00	; 0
    1390:	0e 94 c8 23 	call	0x4790	; 0x4790 <CalculateSignalLength2>
			
			RX2_LastValidSignal_timestampAux = TCNT1_X;
    1394:	80 91 4e 06 	lds	r24, 0x064E
    1398:	90 91 4f 06 	lds	r25, 0x064F
    139c:	90 93 e2 07 	sts	0x07E2, r25
    13a0:	80 93 e1 07 	sts	0x07E1, r24
			RX_Good = TX2_FOUND_ERR;  // CLR bit 6 ---  Status = OK
    13a4:	80 91 c9 07 	lds	r24, 0x07C9
    13a8:	8f 71       	andi	r24, 0x1F	; 31
    13aa:	80 93 c9 07 	sts	0x07C9, r24
		}	
	}
	// if there is a signal change in PITCH
	if ((Changes & RX2_PITCH_PIN)!=0)
    13ae:	00 ff       	sbrs	r16, 0
    13b0:	0b c0       	rjmp	.+22     	; 0x13c8 <__vector_6+0x90>
	{
		if (RX2_PITCH)
    13b2:	86 b1       	in	r24, 0x06	; 6
    13b4:	80 ff       	sbrs	r24, 0
    13b6:	05 c0       	rjmp	.+10     	; 0x13c2 <__vector_6+0x8a>
		{
			RX_raw[1][RXChannel_ELE]=TCNT1_TEMP;
    13b8:	d0 93 fd 07 	sts	0x07FD, r29
    13bc:	c0 93 fc 07 	sts	0x07FC, r28
    13c0:	03 c0       	rjmp	.+6      	; 0x13c8 <__vector_6+0x90>
		}
		else
		{
			CalculateSignalLength2 (RXChannel_ELE);
    13c2:	81 e0       	ldi	r24, 0x01	; 1
    13c4:	0e 94 c8 23 	call	0x4790	; 0x4790 <CalculateSignalLength2>
		}	
	}
	// if there is a signal change in THR
	if ((Changes & RX2_COLL_PIN)!=0)
    13c8:	17 ff       	sbrs	r17, 7
    13ca:	2d c0       	rjmp	.+90     	; 0x1426 <__vector_6+0xee>
    13cc:	80 91 cb 06 	lds	r24, 0x06CB
	{
		if (RX2_COLL)
    13d0:	37 9b       	sbis	0x06, 7	; 6
    13d2:	0b c0       	rjmp	.+22     	; 0x13ea <__vector_6+0xb2>
		{
			RX_raw[1][RXChannel_THR]=TCNT1_TEMP;
    13d4:	d0 93 01 08 	sts	0x0801, r29
    13d8:	c0 93 00 08 	sts	0x0800, r28
			
			if (Config.IsESCCalibration==ESCCalibration_ON)
    13dc:	81 30       	cpi	r24, 0x01	; 1
    13de:	19 f5       	brne	.+70     	; 0x1426 <__vector_6+0xee>
			{ 
				M1=1;M2=1;M3=1;M4=1;
    13e0:	46 9a       	sbi	0x08, 6	; 8
    13e2:	44 9a       	sbi	0x08, 4	; 8
    13e4:	42 9a       	sbi	0x08, 2	; 8
    13e6:	43 9a       	sbi	0x08, 3	; 8
    13e8:	1e c0       	rjmp	.+60     	; 0x1426 <__vector_6+0xee>
			}
		}
		else
		{
			if ((Config.IsESCCalibration==ESCCalibration_ON) && (IS_TX2_GOOD) && (!IS_SYS_ACT_DISARM))
    13ea:	81 30       	cpi	r24, 0x01	; 1
    13ec:	61 f4       	brne	.+24     	; 0x1406 <__vector_6+0xce>
    13ee:	80 91 c9 07 	lds	r24, 0x07C9
    13f2:	80 7f       	andi	r24, 0xF0	; 240
    13f4:	41 f4       	brne	.+16     	; 0x1406 <__vector_6+0xce>
    13f6:	80 91 3b 05 	lds	r24, 0x053B
    13fa:	81 fd       	sbrc	r24, 1
    13fc:	04 c0       	rjmp	.+8      	; 0x1406 <__vector_6+0xce>
			{
				M1=0;M2=0;M3=0;M4=0;
    13fe:	46 98       	cbi	0x08, 6	; 8
    1400:	44 98       	cbi	0x08, 4	; 8
    1402:	42 98       	cbi	0x08, 2	; 8
    1404:	43 98       	cbi	0x08, 3	; 8
			}
				
			CalculateSignalLength2 (RXChannel_THR);
    1406:	83 e0       	ldi	r24, 0x03	; 3
    1408:	0e 94 c8 23 	call	0x4790	; 0x4790 <CalculateSignalLength2>
			RX2_LastValidSignal_timestamp = TCNT1_X;
    140c:	80 91 4e 06 	lds	r24, 0x064E
    1410:	90 91 4f 06 	lds	r25, 0x064F
    1414:	90 93 e6 07 	sts	0x07E6, r25
    1418:	80 93 e5 07 	sts	0x07E5, r24
			RX_Good = TX2_CONNECTED_ERR;  // CLR bit 5 ---  Status = OK
    141c:	80 91 c9 07 	lds	r24, 0x07C9
    1420:	8f 72       	andi	r24, 0x2F	; 47
    1422:	80 93 c9 07 	sts	0x07C9, r24
		}	
	}
	// if there is a signal change in YAW
	if ((Changes & RX2_YAW_PIN) !=0)
    1426:	01 ff       	sbrs	r16, 1
    1428:	0b c0       	rjmp	.+22     	; 0x1440 <__vector_6+0x108>
	{
		if (RX2_YAW)
    142a:	86 b1       	in	r24, 0x06	; 6
    142c:	81 ff       	sbrs	r24, 1
    142e:	05 c0       	rjmp	.+10     	; 0x143a <__vector_6+0x102>
		{
			RX_raw[1][RXChannel_RUD]=TCNT1_TEMP;
    1430:	d0 93 ff 07 	sts	0x07FF, r29
    1434:	c0 93 fe 07 	sts	0x07FE, r28
    1438:	03 c0       	rjmp	.+6      	; 0x1440 <__vector_6+0x108>
		}
		else
		{
			CalculateSignalLength2 (RXChannel_RUD);
    143a:	82 e0       	ldi	r24, 0x02	; 2
    143c:	0e 94 c8 23 	call	0x4790	; 0x4790 <CalculateSignalLength2>
			
		}	
	}
	
}
    1440:	ff 91       	pop	r31
    1442:	ef 91       	pop	r30
    1444:	df 91       	pop	r29
    1446:	cf 91       	pop	r28
    1448:	bf 91       	pop	r27
    144a:	af 91       	pop	r26
    144c:	9f 91       	pop	r25
    144e:	8f 91       	pop	r24
    1450:	7f 91       	pop	r23
    1452:	6f 91       	pop	r22
    1454:	5f 91       	pop	r21
    1456:	4f 91       	pop	r20
    1458:	3f 91       	pop	r19
    145a:	2f 91       	pop	r18
    145c:	1f 91       	pop	r17
    145e:	0f 91       	pop	r16
    1460:	0f 90       	pop	r0
    1462:	0f be       	out	0x3f, r0	; 63
    1464:	0f 90       	pop	r0
    1466:	1f 90       	pop	r1
    1468:	18 95       	reti

0000146a <__vector_2>:

#ifdef PRIMARY_INPUT_RX

__attribute__ ((section(".lowtext")))
ISR (RX1_COLL_vect)
{
    146a:	1f 92       	push	r1
    146c:	0f 92       	push	r0
    146e:	0f b6       	in	r0, 0x3f	; 63
    1470:	0f 92       	push	r0
    1472:	11 24       	eor	r1, r1
    1474:	2f 93       	push	r18
    1476:	3f 93       	push	r19
    1478:	4f 93       	push	r20
    147a:	5f 93       	push	r21
    147c:	6f 93       	push	r22
    147e:	7f 93       	push	r23
    1480:	8f 93       	push	r24
    1482:	9f 93       	push	r25
    1484:	af 93       	push	r26
    1486:	bf 93       	push	r27
    1488:	ef 93       	push	r30
    148a:	ff 93       	push	r31
	if (RX1_COLL)
    148c:	89 b1       	in	r24, 0x09	; 9
    148e:	83 ff       	sbrs	r24, 3
    1490:	09 c0       	rjmp	.+18     	; 0x14a4 <__vector_2+0x3a>
	{
		RX_raw[0][RXChannel_THR]=TCNT1;
    1492:	80 91 84 00 	lds	r24, 0x0084
    1496:	90 91 85 00 	lds	r25, 0x0085
    149a:	90 93 f7 07 	sts	0x07F7, r25
    149e:	80 93 f6 07 	sts	0x07F6, r24
    14a2:	10 c0       	rjmp	.+32     	; 0x14c4 <__vector_2+0x5a>

	}
	else
	{
		CalculateSignalLength1(RXChannel_THR);
    14a4:	83 e0       	ldi	r24, 0x03	; 3
    14a6:	0e 94 9f 23 	call	0x473e	; 0x473e <CalculateSignalLength1>
		
		RX1_LastValidSignal_timestamp = TCNT1_X;
    14aa:	80 91 4e 06 	lds	r24, 0x064E
    14ae:	90 91 4f 06 	lds	r25, 0x064F
    14b2:	90 93 e8 07 	sts	0x07E8, r25
    14b6:	80 93 e7 07 	sts	0x07E7, r24
		RX_Good = TX1_CONNECTED_ERR;		// CLR bit 0 ---  Status = OK
    14ba:	80 91 c9 07 	lds	r24, 0x07C9
    14be:	82 7f       	andi	r24, 0xF2	; 242
    14c0:	80 93 c9 07 	sts	0x07C9, r24
	}
	
}
    14c4:	ff 91       	pop	r31
    14c6:	ef 91       	pop	r30
    14c8:	bf 91       	pop	r27
    14ca:	af 91       	pop	r26
    14cc:	9f 91       	pop	r25
    14ce:	8f 91       	pop	r24
    14d0:	7f 91       	pop	r23
    14d2:	6f 91       	pop	r22
    14d4:	5f 91       	pop	r21
    14d6:	4f 91       	pop	r20
    14d8:	3f 91       	pop	r19
    14da:	2f 91       	pop	r18
    14dc:	0f 90       	pop	r0
    14de:	0f be       	out	0x3f, r0	; 63
    14e0:	0f 90       	pop	r0
    14e2:	1f 90       	pop	r1
    14e4:	18 95       	reti

000014e6 <__vector_1>:



__attribute__ ((section(".lowtext")))
ISR (RX1_ROLL_vect)
{
    14e6:	1f 92       	push	r1
    14e8:	0f 92       	push	r0
    14ea:	0f b6       	in	r0, 0x3f	; 63
    14ec:	0f 92       	push	r0
    14ee:	11 24       	eor	r1, r1
    14f0:	2f 93       	push	r18
    14f2:	3f 93       	push	r19
    14f4:	4f 93       	push	r20
    14f6:	5f 93       	push	r21
    14f8:	6f 93       	push	r22
    14fa:	7f 93       	push	r23
    14fc:	8f 93       	push	r24
    14fe:	9f 93       	push	r25
    1500:	af 93       	push	r26
    1502:	bf 93       	push	r27
    1504:	ef 93       	push	r30
    1506:	ff 93       	push	r31
	if (RX1_ROLL)
    1508:	89 b1       	in	r24, 0x09	; 9
    150a:	82 ff       	sbrs	r24, 2
    150c:	09 c0       	rjmp	.+18     	; 0x1520 <__vector_1+0x3a>
	{
		RX_raw[0][RXChannel_AIL]=TCNT1;
    150e:	80 91 84 00 	lds	r24, 0x0084
    1512:	90 91 85 00 	lds	r25, 0x0085
    1516:	90 93 f1 07 	sts	0x07F1, r25
    151a:	80 93 f0 07 	sts	0x07F0, r24
    151e:	10 c0       	rjmp	.+32     	; 0x1540 <__vector_1+0x5a>
	}
	else
	{
		CalculateSignalLength1(RXChannel_AIL);
    1520:	80 e0       	ldi	r24, 0x00	; 0
    1522:	0e 94 9f 23 	call	0x473e	; 0x473e <CalculateSignalLength1>
		
		RX1_LastValidSignal_timestampAux = TCNT1_X;
    1526:	80 91 4e 06 	lds	r24, 0x064E
    152a:	90 91 4f 06 	lds	r25, 0x064F
    152e:	90 93 ea 07 	sts	0x07EA, r25
    1532:	80 93 e9 07 	sts	0x07E9, r24
		RX_Good = TX1_FOUND_ERR;			// CLR bit 1 ---  Status = OK
    1536:	80 91 c9 07 	lds	r24, 0x07C9
    153a:	81 7f       	andi	r24, 0xF1	; 241
    153c:	80 93 c9 07 	sts	0x07C9, r24

		
	}
	
}
    1540:	ff 91       	pop	r31
    1542:	ef 91       	pop	r30
    1544:	bf 91       	pop	r27
    1546:	af 91       	pop	r26
    1548:	9f 91       	pop	r25
    154a:	8f 91       	pop	r24
    154c:	7f 91       	pop	r23
    154e:	6f 91       	pop	r22
    1550:	5f 91       	pop	r21
    1552:	4f 91       	pop	r20
    1554:	3f 91       	pop	r19
    1556:	2f 91       	pop	r18
    1558:	0f 90       	pop	r0
    155a:	0f be       	out	0x3f, r0	; 63
    155c:	0f 90       	pop	r0
    155e:	1f 90       	pop	r1
    1560:	18 95       	reti

00001562 <__vector_7>:


__attribute__ ((section(".lowtext")))
ISR (RX1_PITCH_vect)
{
    1562:	1f 92       	push	r1
    1564:	0f 92       	push	r0
    1566:	0f b6       	in	r0, 0x3f	; 63
    1568:	0f 92       	push	r0
    156a:	11 24       	eor	r1, r1
    156c:	2f 93       	push	r18
    156e:	3f 93       	push	r19
    1570:	4f 93       	push	r20
    1572:	5f 93       	push	r21
    1574:	6f 93       	push	r22
    1576:	7f 93       	push	r23
    1578:	8f 93       	push	r24
    157a:	9f 93       	push	r25
    157c:	af 93       	push	r26
    157e:	bf 93       	push	r27
    1580:	ef 93       	push	r30
    1582:	ff 93       	push	r31
	if (RX1_PITCH)
    1584:	89 b1       	in	r24, 0x09	; 9
    1586:	80 ff       	sbrs	r24, 0
    1588:	09 c0       	rjmp	.+18     	; 0x159c <__vector_7+0x3a>
	{
		RX_raw[0][RXChannel_ELE]=TCNT1;
    158a:	80 91 84 00 	lds	r24, 0x0084
    158e:	90 91 85 00 	lds	r25, 0x0085
    1592:	90 93 f3 07 	sts	0x07F3, r25
    1596:	80 93 f2 07 	sts	0x07F2, r24
    159a:	03 c0       	rjmp	.+6      	; 0x15a2 <__vector_7+0x40>
	}
	else
	{
		CalculateSignalLength1(RXChannel_ELE);
    159c:	81 e0       	ldi	r24, 0x01	; 1
    159e:	0e 94 9f 23 	call	0x473e	; 0x473e <CalculateSignalLength1>
	}
}
    15a2:	ff 91       	pop	r31
    15a4:	ef 91       	pop	r30
    15a6:	bf 91       	pop	r27
    15a8:	af 91       	pop	r26
    15aa:	9f 91       	pop	r25
    15ac:	8f 91       	pop	r24
    15ae:	7f 91       	pop	r23
    15b0:	6f 91       	pop	r22
    15b2:	5f 91       	pop	r21
    15b4:	4f 91       	pop	r20
    15b6:	3f 91       	pop	r19
    15b8:	2f 91       	pop	r18
    15ba:	0f 90       	pop	r0
    15bc:	0f be       	out	0x3f, r0	; 63
    15be:	0f 90       	pop	r0
    15c0:	1f 90       	pop	r1
    15c2:	18 95       	reti

000015c4 <__vector_3>:

volatile uint16_t LongTime;
volatile uint16_t ShortTime;
__attribute__ ((section(".lowtext")))
ISR (RX1_YAW_vect)
{   
    15c4:	1f 92       	push	r1
    15c6:	0f 92       	push	r0
    15c8:	0f b6       	in	r0, 0x3f	; 63
    15ca:	0f 92       	push	r0
    15cc:	11 24       	eor	r1, r1
    15ce:	2f 93       	push	r18
    15d0:	3f 93       	push	r19
    15d2:	4f 93       	push	r20
    15d4:	5f 93       	push	r21
    15d6:	6f 93       	push	r22
    15d8:	7f 93       	push	r23
    15da:	8f 93       	push	r24
    15dc:	9f 93       	push	r25
    15de:	af 93       	push	r26
    15e0:	bf 93       	push	r27
    15e2:	ef 93       	push	r30
    15e4:	ff 93       	push	r31
	// SONAR IS HERE IN UART MODE
	// SONAR RAW VALUE = RX_Length[0][RXChannel_RUD]
	if ((Config.RX_mode==RX_mode_UARTMode) && (IS_MISC_SENSOR_SONAR_ENABLED==true))
    15e6:	80 91 c7 06 	lds	r24, 0x06C7
    15ea:	8f 3f       	cpi	r24, 0xFF	; 255
    15ec:	f9 f4       	brne	.+62     	; 0x162c <__vector_3+0x68>
    15ee:	80 91 d2 06 	lds	r24, 0x06D2
    15f2:	80 ff       	sbrs	r24, 0
    15f4:	1b c0       	rjmp	.+54     	; 0x162c <__vector_3+0x68>
	{
		if (RX1_YAW)
    15f6:	83 b1       	in	r24, 0x03	; 3
    15f8:	82 ff       	sbrs	r24, 2
    15fa:	09 c0       	rjmp	.+18     	; 0x160e <__vector_3+0x4a>
		{
			//ShortTime = TCNT1;
			LongTime = TCNT0_X;
    15fc:	80 91 a6 05 	lds	r24, 0x05A6
    1600:	90 91 a7 05 	lds	r25, 0x05A7
    1604:	90 93 ef 07 	sts	0x07EF, r25
    1608:	80 93 ee 07 	sts	0x07EE, r24
    160c:	1e c0       	rjmp	.+60     	; 0x164a <__vector_3+0x86>
		}
		else
		{
			RX_Length[0][RXChannel_RUD] = (TCNT0_X - LongTime) ; // * SONAR_TO_cm_Convert_BIG + (TCNT1 - ShortTime) * SONAR_TO_cm_Convert;
    160e:	80 91 a6 05 	lds	r24, 0x05A6
    1612:	90 91 a7 05 	lds	r25, 0x05A7
    1616:	20 91 ee 07 	lds	r18, 0x07EE
    161a:	30 91 ef 07 	lds	r19, 0x07EF
    161e:	82 1b       	sub	r24, r18
    1620:	93 0b       	sbc	r25, r19
    1622:	90 93 bf 05 	sts	0x05BF, r25
    1626:	80 93 be 05 	sts	0x05BE, r24
    162a:	0f c0       	rjmp	.+30     	; 0x164a <__vector_3+0x86>

	}
	else
	{
		
		if (RX1_YAW)
    162c:	83 b1       	in	r24, 0x03	; 3
    162e:	82 ff       	sbrs	r24, 2
    1630:	09 c0       	rjmp	.+18     	; 0x1644 <__vector_3+0x80>
		{
			RX_raw[0][RXChannel_RUD]=TCNT1;
    1632:	80 91 84 00 	lds	r24, 0x0084
    1636:	90 91 85 00 	lds	r25, 0x0085
    163a:	90 93 f5 07 	sts	0x07F5, r25
    163e:	80 93 f4 07 	sts	0x07F4, r24
    1642:	03 c0       	rjmp	.+6      	; 0x164a <__vector_3+0x86>
		}
		else
		{
			CalculateSignalLength1(RXChannel_RUD);
    1644:	82 e0       	ldi	r24, 0x02	; 2
    1646:	0e 94 9f 23 	call	0x473e	; 0x473e <CalculateSignalLength1>
		}
	}	
}
    164a:	ff 91       	pop	r31
    164c:	ef 91       	pop	r30
    164e:	bf 91       	pop	r27
    1650:	af 91       	pop	r26
    1652:	9f 91       	pop	r25
    1654:	8f 91       	pop	r24
    1656:	7f 91       	pop	r23
    1658:	6f 91       	pop	r22
    165a:	5f 91       	pop	r21
    165c:	4f 91       	pop	r20
    165e:	3f 91       	pop	r19
    1660:	2f 91       	pop	r18
    1662:	0f 90       	pop	r0
    1664:	0f be       	out	0x3f, r0	; 63
    1666:	0f 90       	pop	r0
    1668:	1f 90       	pop	r1
    166a:	18 95       	reti

0000166c <__vector_5>:



__attribute__ ((section(".lowtext")))
ISR (RX_AUX_vect)
{
    166c:	1f 92       	push	r1
    166e:	0f 92       	push	r0
    1670:	0f b6       	in	r0, 0x3f	; 63
    1672:	0f 92       	push	r0
    1674:	11 24       	eor	r1, r1
    1676:	2f 93       	push	r18
    1678:	3f 93       	push	r19
    167a:	4f 93       	push	r20
    167c:	5f 93       	push	r21
    167e:	6f 93       	push	r22
    1680:	7f 93       	push	r23
    1682:	8f 93       	push	r24
    1684:	9f 93       	push	r25
    1686:	af 93       	push	r26
    1688:	bf 93       	push	r27
    168a:	ef 93       	push	r30
    168c:	ff 93       	push	r31
	// There is only ONE AUX PORT - usually assigned to Secondary RX 
	if (RX_AUX)
    168e:	83 b1       	in	r24, 0x03	; 3
    1690:	80 ff       	sbrs	r24, 0
    1692:	0c c0       	rjmp	.+24     	; 0x16ac <__vector_5+0x40>
	{
		RX_raw[1][RXChannel_AUX]=TCNT1;
    1694:	80 91 84 00 	lds	r24, 0x0084
    1698:	90 91 85 00 	lds	r25, 0x0085
    169c:	90 93 03 08 	sts	0x0803, r25
    16a0:	80 93 02 08 	sts	0x0802, r24
		UpdateServo=true;
    16a4:	81 e0       	ldi	r24, 0x01	; 1
    16a6:	80 93 c2 06 	sts	0x06C2, r24
    16aa:	0b c0       	rjmp	.+22     	; 0x16c2 <__vector_5+0x56>
	}
	else
	{
		CalculateSignalLength2(RXChannel_AUX);
    16ac:	84 e0       	ldi	r24, 0x04	; 4
    16ae:	0e 94 c8 23 	call	0x4790	; 0x4790 <CalculateSignalLength2>
		RX_Length[0][RXChannel_AUX]=RX_Length[1][RXChannel_AUX];
    16b2:	80 91 cc 05 	lds	r24, 0x05CC
    16b6:	90 91 cd 05 	lds	r25, 0x05CD
    16ba:	90 93 c3 05 	sts	0x05C3, r25
    16be:	80 93 c2 05 	sts	0x05C2, r24
	}

}
    16c2:	ff 91       	pop	r31
    16c4:	ef 91       	pop	r30
    16c6:	bf 91       	pop	r27
    16c8:	af 91       	pop	r26
    16ca:	9f 91       	pop	r25
    16cc:	8f 91       	pop	r24
    16ce:	7f 91       	pop	r23
    16d0:	6f 91       	pop	r22
    16d2:	5f 91       	pop	r21
    16d4:	4f 91       	pop	r20
    16d6:	3f 91       	pop	r19
    16d8:	2f 91       	pop	r18
    16da:	0f 90       	pop	r0
    16dc:	0f be       	out	0x3f, r0	; 63
    16de:	0f 90       	pop	r0
    16e0:	1f 90       	pop	r1
    16e2:	18 95       	reti

000016e4 <__ctors_end>:
    16e4:	11 24       	eor	r1, r1
    16e6:	1f be       	out	0x3f, r1	; 63
    16e8:	cf ef       	ldi	r28, 0xFF	; 255
    16ea:	d8 e0       	ldi	r29, 0x08	; 8
    16ec:	de bf       	out	0x3e, r29	; 62
    16ee:	cd bf       	out	0x3d, r28	; 61

000016f0 <__do_copy_data>:
    16f0:	11 e0       	ldi	r17, 0x01	; 1
    16f2:	a0 e0       	ldi	r26, 0x00	; 0
    16f4:	b1 e0       	ldi	r27, 0x01	; 1
    16f6:	e8 e6       	ldi	r30, 0x68	; 104
    16f8:	f6 e7       	ldi	r31, 0x76	; 118
    16fa:	02 c0       	rjmp	.+4      	; 0x1700 <__do_copy_data+0x10>
    16fc:	05 90       	lpm	r0, Z+
    16fe:	0d 92       	st	X+, r0
    1700:	a4 31       	cpi	r26, 0x14	; 20
    1702:	b1 07       	cpc	r27, r17
    1704:	d9 f7       	brne	.-10     	; 0x16fc <__do_copy_data+0xc>

00001706 <__do_clear_bss>:
    1706:	18 e0       	ldi	r17, 0x08	; 8
    1708:	a4 e1       	ldi	r26, 0x14	; 20
    170a:	b1 e0       	ldi	r27, 0x01	; 1
    170c:	01 c0       	rjmp	.+2      	; 0x1710 <.do_clear_bss_start>

0000170e <.do_clear_bss_loop>:
    170e:	1d 92       	st	X+, r1

00001710 <.do_clear_bss_start>:
    1710:	a5 31       	cpi	r26, 0x15	; 21
    1712:	b1 07       	cpc	r27, r17
    1714:	e1 f7       	brne	.-8      	; 0x170e <.do_clear_bss_loop>
    1716:	0e 94 93 18 	call	0x3126	; 0x3126 <main>
    171a:	0c 94 32 3b 	jmp	0x7664	; 0x7664 <_exit>

0000171e <__bad_interrupt>:
    171e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00001722 <Beeper_Beep>:
#include "../Include/Misc.h"
#include "../Include/IO_config.h"


void Beeper_Beep (uint16_t msDuration, uint8_t Times)
{
    1722:	ef 92       	push	r14
    1724:	ff 92       	push	r15
    1726:	0f 93       	push	r16
    1728:	1f 93       	push	r17
    172a:	cf 93       	push	r28
    172c:	df 93       	push	r29
    172e:	ec 01       	movw	r28, r24
	
	//bool CurrentBuzzer_Status = Buzzer;
	
	for (int i=0; i< Times; ++i)
    1730:	00 e0       	ldi	r16, 0x00	; 0
    1732:	10 e0       	ldi	r17, 0x00	; 0
    1734:	e6 2e       	mov	r14, r22
    1736:	ff 24       	eor	r15, r15
    1738:	0a c0       	rjmp	.+20     	; 0x174e <Beeper_Beep+0x2c>
	{
		Buzzer = ON;
    173a:	29 9a       	sbi	0x05, 1	; 5
		delay_ms(msDuration);
    173c:	ce 01       	movw	r24, r28
    173e:	0e 94 f5 0e 	call	0x1dea	; 0x1dea <delay_ms>
		Buzzer = OFF;
    1742:	29 98       	cbi	0x05, 1	; 5
		delay_ms(msDuration);		
    1744:	ce 01       	movw	r24, r28
    1746:	0e 94 f5 0e 	call	0x1dea	; 0x1dea <delay_ms>
void Beeper_Beep (uint16_t msDuration, uint8_t Times)
{
	
	//bool CurrentBuzzer_Status = Buzzer;
	
	for (int i=0; i< Times; ++i)
    174a:	0f 5f       	subi	r16, 0xFF	; 255
    174c:	1f 4f       	sbci	r17, 0xFF	; 255
    174e:	0e 15       	cp	r16, r14
    1750:	1f 05       	cpc	r17, r15
    1752:	9c f3       	brlt	.-26     	; 0x173a <Beeper_Beep+0x18>
		delay_ms(msDuration);		
	}
	
	//Buzzer = CurrentBuzzer_Status;
	
}
    1754:	df 91       	pop	r29
    1756:	cf 91       	pop	r28
    1758:	1f 91       	pop	r17
    175a:	0f 91       	pop	r16
    175c:	ff 90       	pop	r15
    175e:	ef 90       	pop	r14
    1760:	08 95       	ret

00001762 <KeyBoard_Init>:

void KeyBoard_Init (void)
{

	// key pins to input
	KEYBOARD_DDR |= ALLKEYS;
    1762:	84 b1       	in	r24, 0x04	; 4
    1764:	80 6f       	ori	r24, 0xF0	; 240
    1766:	84 b9       	out	0x04, r24	; 4

	
	// pull up resistors on
	KEYBOARD_PORT |= ALLKEYS;
    1768:	85 b1       	in	r24, 0x05	; 5
    176a:	80 6f       	ori	r24, 0xF0	; 240
    176c:	85 b9       	out	0x05, r24	; 5
	
}
    176e:	08 95       	ret

00001770 <Keyboard_Read>:

uint16_t TCNT_X_snapshot3=0;
uint8_t Keyboard_Read()
{
    1770:	0f 93       	push	r16
    1772:	1f 93       	push	r17
	uint8_t keys = ~KEYBOARD_PIN & ALLKEYS;
    1774:	13 b1       	in	r17, 0x03	; 3
    1776:	10 95       	com	r17
    1778:	10 7f       	andi	r17, 0xF0	; 240
	uint8_t newkeys = keys & ~lastKeys; // always equal to ZERO  for repeated buttons.
    177a:	00 91 ab 05 	lds	r16, 0x05AB
	_keyrepeat = KEYBOARD_NO_REPEAT;
    177e:	10 92 b9 05 	sts	0x05B9, r1
	if (keys !=0) // if any key pressed even repeated.
    1782:	11 23       	and	r17, r17
    1784:	21 f1       	breq	.+72     	; 0x17ce <Keyboard_Read+0x5e>
	{
		if (IsArmed==true) Disarm(); // this is for your own safety.
    1786:	80 91 96 07 	lds	r24, 0x0796
    178a:	81 30       	cpi	r24, 0x01	; 1
    178c:	11 f4       	brne	.+4      	; 0x1792 <Keyboard_Read+0x22>
    178e:	0e 94 12 0f 	call	0x1e24	; 0x1e24 <Disarm>
		
		if ((lastKeys!=keys))
    1792:	80 91 ab 05 	lds	r24, 0x05AB
    1796:	81 17       	cp	r24, r17
    1798:	59 f0       	breq	.+22     	; 0x17b0 <Keyboard_Read+0x40>
		{	// Reset Timer if not the same key.
			TCNT_X_snapshot3 = TCNT1_X+300;
    179a:	80 91 4e 06 	lds	r24, 0x064E
    179e:	90 91 4f 06 	lds	r25, 0x064F
    17a2:	84 5d       	subi	r24, 0xD4	; 212
    17a4:	9e 4f       	sbci	r25, 0xFE	; 254
    17a6:	90 93 15 01 	sts	0x0115, r25
    17aa:	80 93 14 01 	sts	0x0114, r24
    17ae:	0f c0       	rjmp	.+30     	; 0x17ce <Keyboard_Read+0x5e>
		}
		else
		{	// Count to measure the key press duration.
			if ((TCNT_X_snapshot3 < TCNT1_X)) // some racing condition might happen here but not a problem we  dont need an atomic read for UI btn click.
    17b0:	20 91 4e 06 	lds	r18, 0x064E
    17b4:	30 91 4f 06 	lds	r19, 0x064F
    17b8:	40 91 14 01 	lds	r20, 0x0114
    17bc:	50 91 15 01 	lds	r21, 0x0115
    17c0:	42 17       	cp	r20, r18
    17c2:	53 07       	cpc	r21, r19
    17c4:	20 f4       	brcc	.+8      	; 0x17ce <Keyboard_Read+0x5e>
			{
				_keyrepeat = KEYBOARD_REPEAT;
    17c6:	91 e0       	ldi	r25, 0x01	; 1
    17c8:	90 93 b9 05 	sts	0x05B9, r25
				return keys; // re-press keys and set the repeated flag for more GUI handling.
    17cc:	05 c0       	rjmp	.+10     	; 0x17d8 <Keyboard_Read+0x68>

uint16_t TCNT_X_snapshot3=0;
uint8_t Keyboard_Read()
{
	uint8_t keys = ~KEYBOARD_PIN & ALLKEYS;
	uint8_t newkeys = keys & ~lastKeys; // always equal to ZERO  for repeated buttons.
    17ce:	80 2f       	mov	r24, r16
    17d0:	80 95       	com	r24
				_keyrepeat = KEYBOARD_REPEAT;
				return keys; // re-press keys and set the repeated flag for more GUI handling.
			}
		}
	}	
	lastKeys = keys;
    17d2:	10 93 ab 05 	sts	0x05AB, r17
	return newkeys;
    17d6:	81 23       	and	r24, r17
}
    17d8:	1f 91       	pop	r17
    17da:	0f 91       	pop	r16
    17dc:	08 95       	ret

000017de <Keyboard_State>:


inline uint8_t Keyboard_State()
{
	return lastKeys;
}
    17de:	80 91 ab 05 	lds	r24, 0x05AB
    17e2:	08 95       	ret

000017e4 <sendData>:
	//LCD_CS = 1;
//}

static void sendData(uint8_t data, uint8_t CommandorData)
{
	LCD_CS = 0;
    17e4:	5d 98       	cbi	0x0b, 5	; 11
	LCD_A0 = CommandorData;
    17e6:	67 95       	ror	r22
    17e8:	66 27       	eor	r22, r22
    17ea:	67 95       	ror	r22
    17ec:	9b b1       	in	r25, 0x0b	; 11
    17ee:	9f 77       	andi	r25, 0x7F	; 127
    17f0:	96 2b       	or	r25, r22
    17f2:	9b b9       	out	0x0b, r25	; 11
    17f4:	98 e0       	ldi	r25, 0x08	; 8

static void sendByte(uint8_t byte)
{
	for (uint8_t i = 8; i; i--)
	{
		LCD_SCL = 0;
    17f6:	5c 98       	cbi	0x0b, 4	; 11
		
		if (byte & 0x80) // read MSB [& b10000000]
    17f8:	87 ff       	sbrs	r24, 7
    17fa:	02 c0       	rjmp	.+4      	; 0x1800 <sendData+0x1c>
			LCD_SDA = 1;
    17fc:	59 9a       	sbi	0x0b, 1	; 11
    17fe:	01 c0       	rjmp	.+2      	; 0x1802 <sendData+0x1e>
		else
			LCD_SDA = 0;
    1800:	59 98       	cbi	0x0b, 1	; 11
		
		LCD_SCL = 1;
    1802:	5c 9a       	sbi	0x0b, 4	; 11
    1804:	91 50       	subi	r25, 0x01	; 1
static uint8_t _curx, _cury;
static fontdescriptor_t _font;

static void sendByte(uint8_t byte)
{
	for (uint8_t i = 8; i; i--)
    1806:	11 f0       	breq	.+4      	; 0x180c <sendData+0x28>
			LCD_SDA = 1;
		else
			LCD_SDA = 0;
		
		LCD_SCL = 1;
		byte <<= 1;
    1808:	88 0f       	add	r24, r24
    180a:	f5 cf       	rjmp	.-22     	; 0x17f6 <sendData+0x12>
static void sendData(uint8_t data, uint8_t CommandorData)
{
	LCD_CS = 0;
	LCD_A0 = CommandorData;
	sendByte(data);
	LCD_CS = 1;
    180c:	5d 9a       	sbi	0x0b, 5	; 11
}
    180e:	08 95       	ret

00001810 <LCD_SetPos>:
	offset %= sizeof(_screen);
}

void LCD_SetPos(uint8_t line, uint8_t column)
{
	_curx = column % LCDWIDTH;
    1810:	6f 77       	andi	r22, 0x7F	; 127
    1812:	60 93 1c 01 	sts	0x011C, r22
	_cury = line * 8;
    1816:	88 0f       	add	r24, r24
    1818:	88 0f       	add	r24, r24
    181a:	88 0f       	add	r24, r24
    181c:	80 93 1b 01 	sts	0x011B, r24
}
    1820:	08 95       	ret

00001822 <lcdXY>:

void lcdXY(uint8_t x, uint8_t y)
{
	_curx = x;
    1822:	80 93 1c 01 	sts	0x011C, r24
	_cury = y;
    1826:	60 93 1b 01 	sts	0x011B, r22
}
    182a:	08 95       	ret

0000182c <lcdSetPixel>:

void lcdSetPixel(uint8_t x, uint8_t y, uint8_t on)
{
	static const prog_char masks[8] = {0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80};
	uint8_t *scr = _screen + x + (y / 8 * LCDWIDTH); 
    182c:	26 2f       	mov	r18, r22
    182e:	26 95       	lsr	r18
    1830:	26 95       	lsr	r18
    1832:	26 95       	lsr	r18
    1834:	30 e0       	ldi	r19, 0x00	; 0
    1836:	36 95       	lsr	r19
    1838:	32 2f       	mov	r19, r18
    183a:	22 27       	eor	r18, r18
    183c:	37 95       	ror	r19
    183e:	27 95       	ror	r18
    1840:	28 0f       	add	r18, r24
    1842:	31 1d       	adc	r19, r1
	uint8_t mask = pgm_read_byte(&masks[y % 8]);
    1844:	e6 2f       	mov	r30, r22
    1846:	f0 e0       	ldi	r31, 0x00	; 0
    1848:	e7 70       	andi	r30, 0x07	; 7
    184a:	f0 70       	andi	r31, 0x00	; 0
    184c:	e8 57       	subi	r30, 0x78	; 120
    184e:	ff 4f       	sbci	r31, 0xFF	; 255
    1850:	e4 91       	lpm	r30, Z+
	if ((_flags & REVERSED) ^ !on)
    1852:	91 e0       	ldi	r25, 0x01	; 1
    1854:	41 11       	cpse	r20, r1
    1856:	90 e0       	ldi	r25, 0x00	; 0
    1858:	80 91 1a 01 	lds	r24, 0x011A
    185c:	81 70       	andi	r24, 0x01	; 1
    185e:	d9 01       	movw	r26, r18
    1860:	a3 5e       	subi	r26, 0xE3	; 227
    1862:	be 4f       	sbci	r27, 0xFE	; 254
    1864:	89 17       	cp	r24, r25
    1866:	29 f0       	breq	.+10     	; 0x1872 <lcdSetPixel+0x46>
		*scr = *scr & ~mask;
    1868:	e0 95       	com	r30
    186a:	8c 91       	ld	r24, X
    186c:	e8 23       	and	r30, r24
    186e:	ec 93       	st	X, r30
    1870:	08 95       	ret
	else
		*scr = *scr | mask;
    1872:	8c 91       	ld	r24, X
    1874:	8e 2b       	or	r24, r30
    1876:	8c 93       	st	X, r24
    1878:	08 95       	ret

0000187a <LCD_Line>:
			////
		////e2 = 2 * err;
		////if (e2 > dy) { err += dy; x0 += sx; } /* e_xy + e_x > 0 */
		////if (e2 < dx) { err += dx; y0 += sy; } /* e_xy + e_y < 0 */
	////}
}
    187a:	08 95       	ret

0000187c <LCD_Rectangle>:
	//for (a = y0; a <= y1; a++)
	//{
		//lcdSetPixel(x0, a, color);
		//lcdSetPixel(x1, a, color);
	//}
}
    187c:	08 95       	ret

0000187e <LCD_FillRectangle>:
	//if (x0 > x1) { a = x0; x0 = x1; x1 = a;}
	//if (y0 > y1) { a = y0; y0 = y1; y1 = a;}
	//for (a = y0; a <= y1; a++)
		//for(uint8_t i = x0; i <= x1; i++)
			//lcdSetPixel(i, a, color);
}
    187e:	08 95       	ret

00001880 <LCD_Clear>:
 
void LCD_Clear()
{
	memset(_screen, 0, sizeof(_screen));
    1880:	80 e0       	ldi	r24, 0x00	; 0
    1882:	94 e0       	ldi	r25, 0x04	; 4
    1884:	ed e1       	ldi	r30, 0x1D	; 29
    1886:	f1 e0       	ldi	r31, 0x01	; 1
    1888:	df 01       	movw	r26, r30
    188a:	9c 01       	movw	r18, r24
    188c:	1d 92       	st	X+, r1
    188e:	21 50       	subi	r18, 0x01	; 1
    1890:	30 40       	sbci	r19, 0x00	; 0
    1892:	e1 f7       	brne	.-8      	; 0x188c <LCD_Clear+0xc>
	LCD_SetPos(0, 0);
    1894:	80 e0       	ldi	r24, 0x00	; 0
    1896:	60 e0       	ldi	r22, 0x00	; 0
    1898:	0e 94 08 0c 	call	0x1810	; 0x1810 <LCD_SetPos>
	_flags = 0;
    189c:	10 92 1a 01 	sts	0x011A, r1
}
    18a0:	08 95       	ret

000018a2 <lcdWriteSprite_P>:

void lcdWriteSprite_P(PGM_P sprite, uint8_t sizeX, uint8_t sizeY, uint8_t mode)
{
    18a2:	8f 92       	push	r8
    18a4:	9f 92       	push	r9
    18a6:	bf 92       	push	r11
    18a8:	cf 92       	push	r12
    18aa:	df 92       	push	r13
    18ac:	ef 92       	push	r14
    18ae:	ff 92       	push	r15
    18b0:	0f 93       	push	r16
    18b2:	1f 93       	push	r17
    18b4:	df 93       	push	r29
    18b6:	cf 93       	push	r28
    18b8:	0f 92       	push	r0
    18ba:	cd b7       	in	r28, 0x3d	; 61
    18bc:	de b7       	in	r29, 0x3e	; 62
    18be:	4c 01       	movw	r8, r24
    18c0:	e6 2e       	mov	r14, r22
    18c2:	f4 2e       	mov	r15, r20
    18c4:	c2 2e       	mov	r12, r18
	uint8_t b = 0;
	for (uint8_t i = 0; i < sizeX; i++)
    18c6:	dd 24       	eor	r13, r13
	_flags = 0;
}

void lcdWriteSprite_P(PGM_P sprite, uint8_t sizeX, uint8_t sizeY, uint8_t mode)
{
	uint8_t b = 0;
    18c8:	bb 24       	eor	r11, r11
			if (j % 8 == 0)
					b = pgm_read_byte(sprite++);
					
			if (mode == ROP_COPY)
			{
				if ((_cury % 8 == 0) && (sizeY - j >= 8))
    18ca:	04 2f       	mov	r16, r20
    18cc:	10 e0       	ldi	r17, 0x00	; 0
}

void lcdWriteSprite_P(PGM_P sprite, uint8_t sizeX, uint8_t sizeY, uint8_t mode)
{
	uint8_t b = 0;
	for (uint8_t i = 0; i < sizeX; i++)
    18ce:	4f c0       	rjmp	.+158    	; 0x196e <lcdWriteSprite_P+0xcc>
	{
		for (uint8_t j = 0; j < sizeY; j++)
		{
			if (j % 8 == 0)
    18d0:	83 2f       	mov	r24, r19
    18d2:	87 70       	andi	r24, 0x07	; 7
    18d4:	29 f4       	brne	.+10     	; 0x18e0 <lcdWriteSprite_P+0x3e>
					b = pgm_read_byte(sprite++);
    18d6:	f4 01       	movw	r30, r8
    18d8:	08 94       	sec
    18da:	81 1c       	adc	r8, r1
    18dc:	91 1c       	adc	r9, r1
    18de:	b4 90       	lpm	r11, Z+
					
			if (mode == ROP_COPY)
    18e0:	cc 20       	and	r12, r12
    18e2:	79 f5       	brne	.+94     	; 0x1942 <lcdWriteSprite_P+0xa0>
			{
				if ((_cury % 8 == 0) && (sizeY - j >= 8))
    18e4:	60 91 1b 01 	lds	r22, 0x011B
    18e8:	86 2f       	mov	r24, r22
    18ea:	87 70       	andi	r24, 0x07	; 7
    18ec:	19 f5       	brne	.+70     	; 0x1934 <lcdWriteSprite_P+0x92>
    18ee:	c8 01       	movw	r24, r16
    18f0:	83 1b       	sub	r24, r19
    18f2:	91 09       	sbc	r25, r1
    18f4:	88 30       	cpi	r24, 0x08	; 8
    18f6:	91 05       	cpc	r25, r1
    18f8:	ec f0       	brlt	.+58     	; 0x1934 <lcdWriteSprite_P+0x92>
				{
					lcdSetByte(_curx + i, _cury + j, b);
    18fa:	63 0f       	add	r22, r19
		*scr = *scr | mask;
}

static void lcdSetByte(uint8_t x, uint8_t y, uint8_t b)
{
	uint8_t *scr = _screen + x + (y / 8 * LCDWIDTH); 
    18fc:	66 95       	lsr	r22
    18fe:	66 95       	lsr	r22
    1900:	66 95       	lsr	r22
    1902:	a6 2f       	mov	r26, r22
    1904:	b0 e0       	ldi	r27, 0x00	; 0
    1906:	b6 95       	lsr	r27
    1908:	ba 2f       	mov	r27, r26
    190a:	aa 27       	eor	r26, r26
    190c:	b7 95       	ror	r27
    190e:	a7 95       	ror	r26
					
			if (mode == ROP_COPY)
			{
				if ((_cury % 8 == 0) && (sizeY - j >= 8))
				{
					lcdSetByte(_curx + i, _cury + j, b);
    1910:	80 91 1c 01 	lds	r24, 0x011C
    1914:	8d 0d       	add	r24, r13
		*scr = *scr | mask;
}

static void lcdSetByte(uint8_t x, uint8_t y, uint8_t b)
{
	uint8_t *scr = _screen + x + (y / 8 * LCDWIDTH); 
    1916:	a8 0f       	add	r26, r24
    1918:	b1 1d       	adc	r27, r1
	if (_flags & REVERSED)
    191a:	80 91 1a 01 	lds	r24, 0x011A
    191e:	a3 5e       	subi	r26, 0xE3	; 227
    1920:	be 4f       	sbci	r27, 0xFE	; 254
    1922:	80 ff       	sbrs	r24, 0
    1924:	04 c0       	rjmp	.+8      	; 0x192e <lcdWriteSprite_P+0x8c>
		*scr = ~b;
    1926:	8b 2d       	mov	r24, r11
    1928:	80 95       	com	r24
    192a:	8c 93       	st	X, r24
    192c:	01 c0       	rjmp	.+2      	; 0x1930 <lcdWriteSprite_P+0x8e>
	else
		*scr = b;
    192e:	bc 92       	st	X, r11
			if (mode == ROP_COPY)
			{
				if ((_cury % 8 == 0) && (sizeY - j >= 8))
				{
					lcdSetByte(_curx + i, _cury + j, b);
					j += 7; // just +7 b/c the loop increments anyway
    1930:	39 5f       	subi	r19, 0xF9	; 249
    1932:	17 c0       	rjmp	.+46     	; 0x1962 <lcdWriteSprite_P+0xc0>
				}
				else
					lcdSetPixel(_curx + i, _cury + j, b & 0x01);
    1934:	80 91 1c 01 	lds	r24, 0x011C
    1938:	63 0f       	add	r22, r19
    193a:	4b 2d       	mov	r20, r11
    193c:	41 70       	andi	r20, 0x01	; 1
    193e:	8d 0d       	add	r24, r13
    1940:	0c c0       	rjmp	.+24     	; 0x195a <lcdWriteSprite_P+0xb8>
			}				
			else if (mode == ROP_PAINT)
    1942:	8c 2d       	mov	r24, r12
    1944:	81 30       	cpi	r24, 0x01	; 1
    1946:	69 f4       	brne	.+26     	; 0x1962 <lcdWriteSprite_P+0xc0>
			{
				if (b & 0x01)
    1948:	b0 fe       	sbrs	r11, 0
    194a:	0b c0       	rjmp	.+22     	; 0x1962 <lcdWriteSprite_P+0xc0>
					lcdSetPixel(_curx + i, _cury + j, 1);
    194c:	80 91 1c 01 	lds	r24, 0x011C
    1950:	60 91 1b 01 	lds	r22, 0x011B
    1954:	63 0f       	add	r22, r19
    1956:	8d 0d       	add	r24, r13
    1958:	41 e0       	ldi	r20, 0x01	; 1
    195a:	39 83       	std	Y+1, r19	; 0x01
    195c:	0e 94 16 0c 	call	0x182c	; 0x182c <lcdSetPixel>
    1960:	39 81       	ldd	r19, Y+1	; 0x01
			}			
			b >>= 1;
    1962:	b6 94       	lsr	r11
void lcdWriteSprite_P(PGM_P sprite, uint8_t sizeX, uint8_t sizeY, uint8_t mode)
{
	uint8_t b = 0;
	for (uint8_t i = 0; i < sizeX; i++)
	{
		for (uint8_t j = 0; j < sizeY; j++)
    1964:	3f 5f       	subi	r19, 0xFF	; 255
    1966:	3f 15       	cp	r19, r15
    1968:	08 f4       	brcc	.+2      	; 0x196c <lcdWriteSprite_P+0xca>
    196a:	b2 cf       	rjmp	.-156    	; 0x18d0 <lcdWriteSprite_P+0x2e>
}

void lcdWriteSprite_P(PGM_P sprite, uint8_t sizeX, uint8_t sizeY, uint8_t mode)
{
	uint8_t b = 0;
	for (uint8_t i = 0; i < sizeX; i++)
    196c:	d3 94       	inc	r13
    196e:	de 14       	cp	r13, r14
    1970:	10 f4       	brcc	.+4      	; 0x1976 <lcdWriteSprite_P+0xd4>
    1972:	30 e0       	ldi	r19, 0x00	; 0
    1974:	f8 cf       	rjmp	.-16     	; 0x1966 <lcdWriteSprite_P+0xc4>
					lcdSetPixel(_curx + i, _cury + j, 1);
			}			
			b >>= 1;
		}
	}	
}
    1976:	0f 90       	pop	r0
    1978:	cf 91       	pop	r28
    197a:	df 91       	pop	r29
    197c:	1f 91       	pop	r17
    197e:	0f 91       	pop	r16
    1980:	ff 90       	pop	r15
    1982:	ef 90       	pop	r14
    1984:	df 90       	pop	r13
    1986:	cf 90       	pop	r12
    1988:	bf 90       	pop	r11
    198a:	9f 90       	pop	r9
    198c:	8f 90       	pop	r8
    198e:	08 95       	ret

00001990 <lcdWriteGlyph_P>:

void lcdWriteGlyph_P(const glyph_t *glyph, uint8_t mode)
{
    1990:	26 2f       	mov	r18, r22
	uint8_t sizeX = pgm_read_byte(&glyph->sizeX);
    1992:	fc 01       	movw	r30, r24
    1994:	64 91       	lpm	r22, Z+
	uint8_t sizeY = pgm_read_byte(&glyph->sizeY);
    1996:	31 96       	adiw	r30, 0x01	; 1
    1998:	44 91       	lpm	r20, Z+
	lcdWriteSprite_P((PGM_P)&glyph->glyph, sizeX, sizeY, mode);
    199a:	02 96       	adiw	r24, 0x02	; 2
    199c:	0e 94 51 0c 	call	0x18a2	; 0x18a2 <lcdWriteSprite_P>
}
    19a0:	08 95       	ret

000019a2 <lcdWriteChar>:

void lcdWriteChar(char c)
{
	if (c == '\n')
    19a2:	8a 30       	cpi	r24, 0x0A	; 10
    19a4:	51 f4       	brne	.+20     	; 0x19ba <lcdWriteChar+0x18>
	{
		_cury += _font.sizeY;
    19a6:	80 91 1b 01 	lds	r24, 0x011B
    19aa:	90 91 17 01 	lds	r25, 0x0117
    19ae:	89 0f       	add	r24, r25
    19b0:	80 93 1b 01 	sts	0x011B, r24
		_curx = 0;
    19b4:	10 92 1c 01 	sts	0x011C, r1
    19b8:	08 95       	ret
	}
	else
	{
		lcdWriteSprite_P(_font.selector(c), _font.sizeX, _font.sizeY, 0);
    19ba:	e0 91 18 01 	lds	r30, 0x0118
    19be:	f0 91 19 01 	lds	r31, 0x0119
    19c2:	09 95       	icall
    19c4:	60 91 16 01 	lds	r22, 0x0116
    19c8:	40 91 17 01 	lds	r20, 0x0117
    19cc:	20 e0       	ldi	r18, 0x00	; 0
    19ce:	0e 94 51 0c 	call	0x18a2	; 0x18a2 <lcdWriteSprite_P>
		_curx += _font.sizeX;
    19d2:	80 91 1c 01 	lds	r24, 0x011C
    19d6:	90 91 16 01 	lds	r25, 0x0116
    19da:	89 0f       	add	r24, r25
    19dc:	80 93 1c 01 	sts	0x011C, r24
    19e0:	08 95       	ret

000019e2 <LCD_WriteString>:
	}
}

void LCD_WriteString(char *s)
{
    19e2:	ef 92       	push	r14
    19e4:	ff 92       	push	r15
    19e6:	cf 93       	push	r28
    19e8:	df 93       	push	r29
    19ea:	e8 2e       	mov	r14, r24
    19ec:	e7 01       	movw	r28, r14
    19ee:	7e 01       	movw	r14, r28
    19f0:	f9 2e       	mov	r15, r25
    19f2:	e7 01       	movw	r28, r14
	while (*s)
    19f4:	02 c0       	rjmp	.+4      	; 0x19fa <LCD_WriteString+0x18>
	{
		lcdWriteChar(*s);
    19f6:	0e 94 d1 0c 	call	0x19a2	; 0x19a2 <lcdWriteChar>
	}
}

void LCD_WriteString(char *s)
{
	while (*s)
    19fa:	89 91       	ld	r24, Y+
    19fc:	88 23       	and	r24, r24
    19fe:	d9 f7       	brne	.-10     	; 0x19f6 <LCD_WriteString+0x14>
	{
		lcdWriteChar(*s);
		s++;
	}		
}
    1a00:	df 91       	pop	r29
    1a02:	cf 91       	pop	r28
    1a04:	ff 90       	pop	r15
    1a06:	ef 90       	pop	r14
    1a08:	08 95       	ret

00001a0a <LCD_WriteString_P>:
}



void LCD_WriteString_P(PGM_P s)
{
    1a0a:	cf 93       	push	r28
    1a0c:	df 93       	push	r29
    1a0e:	ec 01       	movw	r28, r24
	char c;
	while ((c = pgm_read_byte(s++)))
    1a10:	02 c0       	rjmp	.+4      	; 0x1a16 <LCD_WriteString_P+0xc>
		lcdWriteChar(c);
    1a12:	0e 94 d1 0c 	call	0x19a2	; 0x19a2 <lcdWriteChar>
    1a16:	fe 01       	movw	r30, r28


void LCD_WriteString_P(PGM_P s)
{
	char c;
	while ((c = pgm_read_byte(s++)))
    1a18:	21 96       	adiw	r28, 0x01	; 1
    1a1a:	84 91       	lpm	r24, Z+
    1a1c:	88 23       	and	r24, r24
    1a1e:	c9 f7       	brne	.-14     	; 0x1a12 <LCD_WriteString_P+0x8>
		lcdWriteChar(c);
}
    1a20:	df 91       	pop	r29
    1a22:	cf 91       	pop	r28
    1a24:	08 95       	ret

00001a26 <lcdReverse>:
	lcdReverse(0);
}


void lcdReverse(uint8_t reversed)
{
    1a26:	90 91 1a 01 	lds	r25, 0x011A
	if (reversed)
    1a2a:	88 23       	and	r24, r24
    1a2c:	11 f0       	breq	.+4      	; 0x1a32 <lcdReverse+0xc>
		_flags |= REVERSED;
    1a2e:	91 60       	ori	r25, 0x01	; 1
    1a30:	01 c0       	rjmp	.+2      	; 0x1a34 <lcdReverse+0xe>
	else
		_flags &= ~REVERSED;
    1a32:	9e 7f       	andi	r25, 0xFE	; 254
    1a34:	90 93 1a 01 	sts	0x011A, r25
    1a38:	08 95       	ret

00001a3a <LCD_WriteStringex>:
}



void LCD_WriteStringex(uint8_t x, uint8_t y, char *str, BOOL LCDReverse)
{
    1a3a:	ef 92       	push	r14
    1a3c:	ff 92       	push	r15
    1a3e:	0f 93       	push	r16
    1a40:	1f 93       	push	r17
    1a42:	df 93       	push	r29
    1a44:	cf 93       	push	r28
    1a46:	00 d0       	rcall	.+0      	; 0x1a48 <LCD_WriteStringex+0xe>
    1a48:	0f 92       	push	r0
    1a4a:	cd b7       	in	r28, 0x3d	; 61
    1a4c:	de b7       	in	r29, 0x3e	; 62
    1a4e:	18 2f       	mov	r17, r24
    1a50:	82 2f       	mov	r24, r18
	lcdReverse(LCDReverse);
    1a52:	4a 83       	std	Y+2, r20	; 0x02
    1a54:	5b 83       	std	Y+3, r21	; 0x03
    1a56:	69 83       	std	Y+1, r22	; 0x01
    1a58:	0e 94 13 0d 	call	0x1a26	; 0x1a26 <lcdReverse>
	LCD_SetPos(x, y);
    1a5c:	81 2f       	mov	r24, r17
    1a5e:	69 81       	ldd	r22, Y+1	; 0x01
    1a60:	0e 94 08 0c 	call	0x1810	; 0x1810 <LCD_SetPos>
    1a64:	4a 81       	ldd	r20, Y+2	; 0x02
    1a66:	5b 81       	ldd	r21, Y+3	; 0x03
    1a68:	8a 01       	movw	r16, r20
	while (*str)
    1a6a:	02 c0       	rjmp	.+4      	; 0x1a70 <LCD_WriteStringex+0x36>
	{
		lcdWriteChar(*str);
    1a6c:	0e 94 d1 0c 	call	0x19a2	; 0x19a2 <lcdWriteChar>

void LCD_WriteStringex(uint8_t x, uint8_t y, char *str, BOOL LCDReverse)
{
	lcdReverse(LCDReverse);
	LCD_SetPos(x, y);
	while (*str)
    1a70:	f8 01       	movw	r30, r16
    1a72:	81 91       	ld	r24, Z+
    1a74:	8f 01       	movw	r16, r30
    1a76:	88 23       	and	r24, r24
    1a78:	c9 f7       	brne	.-14     	; 0x1a6c <LCD_WriteStringex+0x32>
	{
		lcdWriteChar(*str);
		str++;
	}		
	lcdReverse(0);
    1a7a:	0e 94 13 0d 	call	0x1a26	; 0x1a26 <lcdReverse>
}
    1a7e:	0f 90       	pop	r0
    1a80:	0f 90       	pop	r0
    1a82:	0f 90       	pop	r0
    1a84:	cf 91       	pop	r28
    1a86:	df 91       	pop	r29
    1a88:	1f 91       	pop	r17
    1a8a:	0f 91       	pop	r16
    1a8c:	ff 90       	pop	r15
    1a8e:	ef 90       	pop	r14
    1a90:	08 95       	ret

00001a92 <LCD_WriteSpace>:
		_flags &= ~REVERSED;
}


void LCD_WriteSpace(uint8_t len)
{
    1a92:	0f 93       	push	r16
    1a94:	1f 93       	push	r17
    1a96:	08 2f       	mov	r16, r24
	for (uint8_t i = 0; i < len; i++)
    1a98:	10 e0       	ldi	r17, 0x00	; 0
    1a9a:	04 c0       	rjmp	.+8      	; 0x1aa4 <LCD_WriteSpace+0x12>
		lcdWriteChar(32);
    1a9c:	80 e2       	ldi	r24, 0x20	; 32
    1a9e:	0e 94 d1 0c 	call	0x19a2	; 0x19a2 <lcdWriteChar>
}


void LCD_WriteSpace(uint8_t len)
{
	for (uint8_t i = 0; i < len; i++)
    1aa2:	1f 5f       	subi	r17, 0xFF	; 255
    1aa4:	10 17       	cp	r17, r16
    1aa6:	d0 f3       	brcs	.-12     	; 0x1a9c <LCD_WriteSpace+0xa>
		lcdWriteChar(32);
}
    1aa8:	1f 91       	pop	r17
    1aaa:	0f 91       	pop	r16
    1aac:	08 95       	ret

00001aae <LCD_WritePadded>:

void LCD_WritePadded(char *s, uint8_t len)
{
    1aae:	0f 93       	push	r16
    1ab0:	1f 93       	push	r17
    1ab2:	df 93       	push	r29
    1ab4:	cf 93       	push	r28
    1ab6:	0f 92       	push	r0
    1ab8:	cd b7       	in	r28, 0x3d	; 61
    1aba:	de b7       	in	r29, 0x3e	; 62
    1abc:	8c 01       	movw	r16, r24
	LCD_WriteString(s);
    1abe:	69 83       	std	Y+1, r22	; 0x01
    1ac0:	0e 94 f1 0c 	call	0x19e2	; 0x19e2 <LCD_WriteString>
	LCD_WriteSpace(len - strlen(s));
    1ac4:	f8 01       	movw	r30, r16
    1ac6:	01 90       	ld	r0, Z+
    1ac8:	00 20       	and	r0, r0
    1aca:	e9 f7       	brne	.-6      	; 0x1ac6 <LCD_WritePadded+0x18>
    1acc:	31 97       	sbiw	r30, 0x01	; 1
    1ace:	e0 1b       	sub	r30, r16
    1ad0:	f1 0b       	sbc	r31, r17
    1ad2:	69 81       	ldd	r22, Y+1	; 0x01
    1ad4:	86 2f       	mov	r24, r22
    1ad6:	8e 1b       	sub	r24, r30
    1ad8:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_WriteSpace>
}
    1adc:	0f 90       	pop	r0
    1ade:	cf 91       	pop	r28
    1ae0:	df 91       	pop	r29
    1ae2:	1f 91       	pop	r17
    1ae4:	0f 91       	pop	r16
    1ae6:	08 95       	ret

00001ae8 <LCD_WritePadded_P>:


void LCD_WritePadded_P(const char *s, uint8_t len)
{
    1ae8:	0f 93       	push	r16
    1aea:	1f 93       	push	r17
    1aec:	df 93       	push	r29
    1aee:	cf 93       	push	r28
    1af0:	0f 92       	push	r0
    1af2:	cd b7       	in	r28, 0x3d	; 61
    1af4:	de b7       	in	r29, 0x3e	; 62
    1af6:	8c 01       	movw	r16, r24
	LCD_WriteString_P(s);
    1af8:	69 83       	std	Y+1, r22	; 0x01
    1afa:	0e 94 05 0d 	call	0x1a0a	; 0x1a0a <LCD_WriteString_P>
	LCD_WriteSpace(len - strlen_P(s));
    1afe:	c8 01       	movw	r24, r16
    1b00:	0e 94 42 38 	call	0x7084	; 0x7084 <strlen_P>
    1b04:	69 81       	ldd	r22, Y+1	; 0x01
    1b06:	68 1b       	sub	r22, r24
    1b08:	86 2f       	mov	r24, r22
    1b0a:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <LCD_WriteSpace>
}
    1b0e:	0f 90       	pop	r0
    1b10:	cf 91       	pop	r28
    1b12:	df 91       	pop	r29
    1b14:	1f 91       	pop	r17
    1b16:	0f 91       	pop	r16
    1b18:	08 95       	ret

00001b1a <LCD_WriteString_Pex>:
		lcdWriteChar(c);
}


void LCD_WriteString_Pex(uint8_t x, uint8_t y, PGM_P str, uint8_t len, BOOL LCDReverse)
{
    1b1a:	ef 92       	push	r14
    1b1c:	ff 92       	push	r15
    1b1e:	0f 93       	push	r16
    1b20:	1f 93       	push	r17
    1b22:	df 93       	push	r29
    1b24:	cf 93       	push	r28
    1b26:	00 d0       	rcall	.+0      	; 0x1b28 <LCD_WriteString_Pex+0xe>
    1b28:	cd b7       	in	r28, 0x3d	; 61
    1b2a:	de b7       	in	r29, 0x3e	; 62
    1b2c:	18 2f       	mov	r17, r24
    1b2e:	7a 01       	movw	r14, r20
    1b30:	80 2f       	mov	r24, r16
	lcdReverse(LCDReverse);
    1b32:	2a 83       	std	Y+2, r18	; 0x02
    1b34:	69 83       	std	Y+1, r22	; 0x01
    1b36:	0e 94 13 0d 	call	0x1a26	; 0x1a26 <lcdReverse>
	LCD_SetPos(x, y);
    1b3a:	81 2f       	mov	r24, r17
    1b3c:	69 81       	ldd	r22, Y+1	; 0x01
    1b3e:	0e 94 08 0c 	call	0x1810	; 0x1810 <LCD_SetPos>
	LCD_WritePadded_P(str, len);
    1b42:	c7 01       	movw	r24, r14
    1b44:	2a 81       	ldd	r18, Y+2	; 0x02
    1b46:	62 2f       	mov	r22, r18
    1b48:	0e 94 74 0d 	call	0x1ae8	; 0x1ae8 <LCD_WritePadded_P>
	lcdReverse(0);
    1b4c:	80 e0       	ldi	r24, 0x00	; 0
    1b4e:	0e 94 13 0d 	call	0x1a26	; 0x1a26 <lcdReverse>
}
    1b52:	0f 90       	pop	r0
    1b54:	0f 90       	pop	r0
    1b56:	cf 91       	pop	r28
    1b58:	df 91       	pop	r29
    1b5a:	1f 91       	pop	r17
    1b5c:	0f 91       	pop	r16
    1b5e:	ff 90       	pop	r15
    1b60:	ef 90       	pop	r14
    1b62:	08 95       	ret

00001b64 <LCD_WriteValue_double_ex>:
	LCD_WriteString_P(s);
	LCD_WriteSpace(len - strlen_P(s));
}

void LCD_WriteValue_double_ex(uint8_t x, uint8_t y, double value, int8_t len, BOOL LCDReverse)
{
    1b64:	bf 92       	push	r11
    1b66:	cf 92       	push	r12
    1b68:	df 92       	push	r13
    1b6a:	ef 92       	push	r14
    1b6c:	ff 92       	push	r15
    1b6e:	0f 93       	push	r16
    1b70:	1f 93       	push	r17
    1b72:	df 93       	push	r29
    1b74:	cf 93       	push	r28
    1b76:	cd b7       	in	r28, 0x3d	; 61
    1b78:	de b7       	in	r29, 0x3e	; 62
    1b7a:	62 97       	sbiw	r28, 0x12	; 18
    1b7c:	0f b6       	in	r0, 0x3f	; 63
    1b7e:	f8 94       	cli
    1b80:	de bf       	out	0x3e, r29	; 62
    1b82:	0f be       	out	0x3f, r0	; 63
    1b84:	cd bf       	out	0x3d, r28	; 61
    1b86:	f8 2e       	mov	r15, r24
    1b88:	b6 2e       	mov	r11, r22
    1b8a:	ca 01       	movw	r24, r20
    1b8c:	b9 01       	movw	r22, r18
    1b8e:	30 2f       	mov	r19, r16
	char s[17];
	dtostrf(value, len-2,2, s);
    1b90:	32 50       	subi	r19, 0x02	; 2
    1b92:	43 2f       	mov	r20, r19
    1b94:	22 e0       	ldi	r18, 0x02	; 2
    1b96:	6e 01       	movw	r12, r28
    1b98:	08 94       	sec
    1b9a:	c1 1c       	adc	r12, r1
    1b9c:	d1 1c       	adc	r13, r1
    1b9e:	86 01       	movw	r16, r12
    1ba0:	3a 8b       	std	Y+18, r19	; 0x12
    1ba2:	0e 94 10 38 	call	0x7020	; 0x7020 <dtostrf>
	//itoa(value, s, 10);
	lcdReverse(LCDReverse);
    1ba6:	8e 2d       	mov	r24, r14
    1ba8:	0e 94 13 0d 	call	0x1a26	; 0x1a26 <lcdReverse>
	LCD_SetPos(x, y);
    1bac:	8f 2d       	mov	r24, r15
    1bae:	6b 2d       	mov	r22, r11
    1bb0:	0e 94 08 0c 	call	0x1810	; 0x1810 <LCD_SetPos>
	LCD_WritePadded(s, len-2);
    1bb4:	c6 01       	movw	r24, r12
    1bb6:	3a 89       	ldd	r19, Y+18	; 0x12
    1bb8:	63 2f       	mov	r22, r19
    1bba:	0e 94 57 0d 	call	0x1aae	; 0x1aae <LCD_WritePadded>
	lcdReverse(0);
    1bbe:	80 e0       	ldi	r24, 0x00	; 0
    1bc0:	0e 94 13 0d 	call	0x1a26	; 0x1a26 <lcdReverse>

}
    1bc4:	62 96       	adiw	r28, 0x12	; 18
    1bc6:	0f b6       	in	r0, 0x3f	; 63
    1bc8:	f8 94       	cli
    1bca:	de bf       	out	0x3e, r29	; 62
    1bcc:	0f be       	out	0x3f, r0	; 63
    1bce:	cd bf       	out	0x3d, r28	; 61
    1bd0:	cf 91       	pop	r28
    1bd2:	df 91       	pop	r29
    1bd4:	1f 91       	pop	r17
    1bd6:	0f 91       	pop	r16
    1bd8:	ff 90       	pop	r15
    1bda:	ef 90       	pop	r14
    1bdc:	df 90       	pop	r13
    1bde:	cf 90       	pop	r12
    1be0:	bf 90       	pop	r11
    1be2:	08 95       	ret

00001be4 <LCD_WriteValue_double>:
void LCD_WriteValue_double(uint8_t x, uint8_t y, double value,  BOOL LCDReverse)
{
    1be4:	ef 92       	push	r14
    1be6:	0f 93       	push	r16
    1be8:	e0 2e       	mov	r14, r16
	LCD_WriteValue_double_ex(x,y,value,5,LCDReverse);
    1bea:	05 e0       	ldi	r16, 0x05	; 5
    1bec:	0e 94 b2 0d 	call	0x1b64	; 0x1b64 <LCD_WriteValue_double_ex>
}
    1bf0:	0f 91       	pop	r16
    1bf2:	ef 90       	pop	r14
    1bf4:	08 95       	ret

00001bf6 <LCD_WriteValue>:

void LCD_WriteValue(uint8_t x, uint8_t y, int16_t value, uint8_t len, BOOL LCDReverse)
{
    1bf6:	df 92       	push	r13
    1bf8:	ef 92       	push	r14
    1bfa:	ff 92       	push	r15
    1bfc:	0f 93       	push	r16
    1bfe:	1f 93       	push	r17
    1c00:	df 93       	push	r29
    1c02:	cf 93       	push	r28
    1c04:	cd b7       	in	r28, 0x3d	; 61
    1c06:	de b7       	in	r29, 0x3e	; 62
    1c08:	28 97       	sbiw	r28, 0x08	; 8
    1c0a:	0f b6       	in	r0, 0x3f	; 63
    1c0c:	f8 94       	cli
    1c0e:	de bf       	out	0x3e, r29	; 62
    1c10:	0f be       	out	0x3f, r0	; 63
    1c12:	cd bf       	out	0x3d, r28	; 61
    1c14:	d8 2e       	mov	r13, r24
    1c16:	16 2f       	mov	r17, r22
	char s[7];
	itoa(value, s, 10);
    1c18:	ca 01       	movw	r24, r20
    1c1a:	7e 01       	movw	r14, r28
    1c1c:	08 94       	sec
    1c1e:	e1 1c       	adc	r14, r1
    1c20:	f1 1c       	adc	r15, r1
    1c22:	b7 01       	movw	r22, r14
    1c24:	4a e0       	ldi	r20, 0x0A	; 10
    1c26:	50 e0       	ldi	r21, 0x00	; 0
    1c28:	28 87       	std	Y+8, r18	; 0x08
    1c2a:	0e 94 5f 38 	call	0x70be	; 0x70be <itoa>
	lcdReverse(LCDReverse);
    1c2e:	80 2f       	mov	r24, r16
    1c30:	0e 94 13 0d 	call	0x1a26	; 0x1a26 <lcdReverse>
	LCD_SetPos(x, y);
    1c34:	8d 2d       	mov	r24, r13
    1c36:	61 2f       	mov	r22, r17
    1c38:	0e 94 08 0c 	call	0x1810	; 0x1810 <LCD_SetPos>
	LCD_WritePadded(s, len);
    1c3c:	c7 01       	movw	r24, r14
    1c3e:	28 85       	ldd	r18, Y+8	; 0x08
    1c40:	62 2f       	mov	r22, r18
    1c42:	0e 94 57 0d 	call	0x1aae	; 0x1aae <LCD_WritePadded>
	lcdReverse(0);
    1c46:	80 e0       	ldi	r24, 0x00	; 0
    1c48:	0e 94 13 0d 	call	0x1a26	; 0x1a26 <lcdReverse>
}
    1c4c:	28 96       	adiw	r28, 0x08	; 8
    1c4e:	0f b6       	in	r0, 0x3f	; 63
    1c50:	f8 94       	cli
    1c52:	de bf       	out	0x3e, r29	; 62
    1c54:	0f be       	out	0x3f, r0	; 63
    1c56:	cd bf       	out	0x3d, r28	; 61
    1c58:	cf 91       	pop	r28
    1c5a:	df 91       	pop	r29
    1c5c:	1f 91       	pop	r17
    1c5e:	0f 91       	pop	r16
    1c60:	ff 90       	pop	r15
    1c62:	ef 90       	pop	r14
    1c64:	df 90       	pop	r13
    1c66:	08 95       	ret

00001c68 <LCD_Enable>:
}

void LCD_Enable()
{
	// reset timer0 to avoid re-entrant call of ISR b/c it is non blocking
	TCNT0 = 0;
    1c68:	16 bc       	out	0x26, r1	; 38
	TIFR0 = _BV(TOV0);
    1c6a:	81 e0       	ldi	r24, 0x01	; 1
    1c6c:	85 bb       	out	0x15, r24	; 21
	TIMSK0 |= _BV(TOIE0);	// enable interrupt on overflow
    1c6e:	ee e6       	ldi	r30, 0x6E	; 110
    1c70:	f0 e0       	ldi	r31, 0x00	; 0
    1c72:	80 81       	ld	r24, Z
    1c74:	81 60       	ori	r24, 0x01	; 1
    1c76:	80 83       	st	Z, r24
}
    1c78:	08 95       	ret

00001c7a <LCD_Disable>:

void LCD_Disable()
{
	TIMSK0 &= ~_BV(TOIE0);	// disable overflow interrupt
    1c7a:	ee e6       	ldi	r30, 0x6E	; 110
    1c7c:	f0 e0       	ldi	r31, 0x00	; 0
    1c7e:	80 81       	ld	r24, Z
    1c80:	8e 7f       	andi	r24, 0xFE	; 254
    1c82:	80 83       	st	Z, r24
}
    1c84:	08 95       	ret

00001c86 <lcdSetContrast>:
	LCD_WritePadded(s, len);
	lcdReverse(0);
}

void lcdSetContrast(uint8_t contrast)
{
    1c86:	0f 93       	push	r16
    1c88:	1f 93       	push	r17
    1c8a:	cf 93       	push	r28
    1c8c:	df 93       	push	r29
    1c8e:	08 2f       	mov	r16, r24
	uint8_t t = TIMSK0;
    1c90:	ce e6       	ldi	r28, 0x6E	; 110
    1c92:	d0 e0       	ldi	r29, 0x00	; 0
    1c94:	18 81       	ld	r17, Y
	LCD_Disable();
    1c96:	0e 94 3d 0e 	call	0x1c7a	; 0x1c7a <LCD_Disable>
	sendData(0x81, LCD_COMMAND);
    1c9a:	81 e8       	ldi	r24, 0x81	; 129
    1c9c:	60 e0       	ldi	r22, 0x00	; 0
    1c9e:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <sendData>
	sendData(contrast & 0x3F, LCD_COMMAND); 
    1ca2:	80 2f       	mov	r24, r16
    1ca4:	8f 73       	andi	r24, 0x3F	; 63
    1ca6:	60 e0       	ldi	r22, 0x00	; 0
    1ca8:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <sendData>
	TIMSK0 = t;
    1cac:	18 83       	st	Y, r17
}
    1cae:	df 91       	pop	r29
    1cb0:	cf 91       	pop	r28
    1cb2:	1f 91       	pop	r17
    1cb4:	0f 91       	pop	r16
    1cb6:	08 95       	ret

00001cb8 <LCD_SelectFont>:
{
	TIMSK0 &= ~_BV(TOIE0);	// disable overflow interrupt
}

void LCD_SelectFont(const fontdescriptor_t *font)
{
    1cb8:	bc 01       	movw	r22, r24
	if (font == NULL)
    1cba:	00 97       	sbiw	r24, 0x00	; 0
    1cbc:	11 f4       	brne	.+4      	; 0x1cc2 <LCD_SelectFont+0xa>
		font = &font6x8;
    1cbe:	6d e4       	ldi	r22, 0x4D	; 77
    1cc0:	77 e0       	ldi	r23, 0x07	; 7
	memcpy_P(&_font, font, sizeof(_font));
    1cc2:	86 e1       	ldi	r24, 0x16	; 22
    1cc4:	91 e0       	ldi	r25, 0x01	; 1
    1cc6:	44 e0       	ldi	r20, 0x04	; 4
    1cc8:	50 e0       	ldi	r21, 0x00	; 0
    1cca:	0e 94 32 38 	call	0x7064	; 0x7064 <memcpy_P>
}
    1cce:	08 95       	ret

00001cd0 <LCD_Init>:
	0xff // end of array
	*/
};

void LCD_Init()
{
    1cd0:	cf 93       	push	r28
    1cd2:	df 93       	push	r29
	// pins
	LCD_CS_DIR = OUTPUT;
    1cd4:	55 9a       	sbi	0x0a, 5	; 10
	LCD_RST_DIR = OUTPUT;
    1cd6:	56 9a       	sbi	0x0a, 6	; 10
	LCD_A0_DIR = OUTPUT;
    1cd8:	57 9a       	sbi	0x0a, 7	; 10
	LCD_SCL_DIR = OUTPUT;
    1cda:	54 9a       	sbi	0x0a, 4	; 10
	LCD_SDA_DIR = OUTPUT;
    1cdc:	51 9a       	sbi	0x0a, 1	; 10

	// init display
	LCD_RST = 0;
    1cde:	5e 98       	cbi	0x0b, 6	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1ce0:	89 ef       	ldi	r24, 0xF9	; 249
    1ce2:	90 e0       	ldi	r25, 0x00	; 0
    1ce4:	01 97       	sbiw	r24, 0x01	; 1
    1ce6:	f1 f7       	brne	.-4      	; 0x1ce4 <LCD_Init+0x14>
    1ce8:	00 c0       	rjmp	.+0      	; 0x1cea <LCD_Init+0x1a>
    1cea:	00 00       	nop
	_delay_ms(1);	// version 0.9.9
	LCD_RST = 1;
    1cec:	5e 9a       	sbi	0x0b, 6	; 11
    1cee:	89 ef       	ldi	r24, 0xF9	; 249
    1cf0:	90 e0       	ldi	r25, 0x00	; 0
    1cf2:	01 97       	sbiw	r24, 0x01	; 1
    1cf4:	f1 f7       	brne	.-4      	; 0x1cf2 <LCD_Init+0x22>
    1cf6:	00 c0       	rjmp	.+0      	; 0x1cf8 <LCD_Init+0x28>
    1cf8:	00 00       	nop
	_delay_ms(1); // version 0.9.9
	
	const unsigned char* ptr = _initSeq;
    1cfa:	cc e7       	ldi	r28, 0x7C	; 124
    1cfc:	d0 e0       	ldi	r29, 0x00	; 0
	uint8_t c;
	while ((c = pgm_read_byte(ptr++)))
    1cfe:	03 c0       	rjmp	.+6      	; 0x1d06 <LCD_Init+0x36>
	{
		sendData(c, LCD_COMMAND);
    1d00:	60 e0       	ldi	r22, 0x00	; 0
    1d02:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <sendData>
    1d06:	fe 01       	movw	r30, r28
	LCD_RST = 1;
	_delay_ms(1); // version 0.9.9
	
	const unsigned char* ptr = _initSeq;
	uint8_t c;
	while ((c = pgm_read_byte(ptr++)))
    1d08:	21 96       	adiw	r28, 0x01	; 1
    1d0a:	84 91       	lpm	r24, Z+
    1d0c:	88 23       	and	r24, r24
    1d0e:	c1 f7       	brne	.-16     	; 0x1d00 <LCD_Init+0x30>
	{
		sendData(c, LCD_COMMAND);
	}	
	LCD_SelectFont(NULL);		// select default font
    1d10:	80 e0       	ldi	r24, 0x00	; 0
    1d12:	90 e0       	ldi	r25, 0x00	; 0
    1d14:	0e 94 5c 0e 	call	0x1cb8	; 0x1cb8 <LCD_SelectFont>
	
	// use timer0 with clk/8 and overflow
	// at 256 as interrupt based output of data bytes
	// ie every 1024us one byte is send to display. whole screen takes about 105ms
	TCCR0B = _BV(CS01);		// clk/8
    1d18:	82 e0       	ldi	r24, 0x02	; 2
    1d1a:	85 bd       	out	0x25, r24	; 37
	LCD_Enable();
    1d1c:	0e 94 34 0e 	call	0x1c68	; 0x1c68 <LCD_Enable>
}
    1d20:	df 91       	pop	r29
    1d22:	cf 91       	pop	r28
    1d24:	08 95       	ret

00001d26 <LED_FlashOrangeLED>:
#include "../Include/Misc.h"
#include "../Include/IO_config.h"


void LED_FlashOrangeLED (uint16_t msDuration, uint8_t Times)
{
    1d26:	cf 92       	push	r12
    1d28:	df 92       	push	r13
    1d2a:	ef 92       	push	r14
    1d2c:	ff 92       	push	r15
    1d2e:	0f 93       	push	r16
    1d30:	1f 93       	push	r17
    1d32:	df 93       	push	r29
    1d34:	cf 93       	push	r28
    1d36:	0f 92       	push	r0
    1d38:	cd b7       	in	r28, 0x3d	; 61
    1d3a:	de b7       	in	r29, 0x3e	; 62
    1d3c:	6c 01       	movw	r12, r24
	bool CurrentLED_Status = LED_Orange;
    1d3e:	25 b1       	in	r18, 0x05	; 5
    1d40:	26 95       	lsr	r18
    1d42:	26 95       	lsr	r18
    1d44:	26 95       	lsr	r18
    1d46:	21 70       	andi	r18, 0x01	; 1
	
	for (int i=0; i< Times; ++i)
    1d48:	00 e0       	ldi	r16, 0x00	; 0
    1d4a:	10 e0       	ldi	r17, 0x00	; 0
    1d4c:	e6 2e       	mov	r14, r22
    1d4e:	ff 24       	eor	r15, r15
    1d50:	24 c0       	rjmp	.+72     	; 0x1d9a <LED_FlashOrangeLED+0x74>
	{
		LED_Orange = ~LED_Orange;
    1d52:	85 b1       	in	r24, 0x05	; 5
    1d54:	86 95       	lsr	r24
    1d56:	86 95       	lsr	r24
    1d58:	86 95       	lsr	r24
    1d5a:	80 95       	com	r24
    1d5c:	81 70       	andi	r24, 0x01	; 1
    1d5e:	88 0f       	add	r24, r24
    1d60:	88 0f       	add	r24, r24
    1d62:	88 0f       	add	r24, r24
    1d64:	95 b1       	in	r25, 0x05	; 5
    1d66:	97 7f       	andi	r25, 0xF7	; 247
    1d68:	98 2b       	or	r25, r24
    1d6a:	95 b9       	out	0x05, r25	; 5
		delay_ms(msDuration);
    1d6c:	c6 01       	movw	r24, r12
    1d6e:	29 83       	std	Y+1, r18	; 0x01
    1d70:	0e 94 f5 0e 	call	0x1dea	; 0x1dea <delay_ms>
		LED_Orange = ~LED_Orange;
    1d74:	85 b1       	in	r24, 0x05	; 5
    1d76:	86 95       	lsr	r24
    1d78:	86 95       	lsr	r24
    1d7a:	86 95       	lsr	r24
    1d7c:	80 95       	com	r24
    1d7e:	81 70       	andi	r24, 0x01	; 1
    1d80:	88 0f       	add	r24, r24
    1d82:	88 0f       	add	r24, r24
    1d84:	88 0f       	add	r24, r24
    1d86:	95 b1       	in	r25, 0x05	; 5
    1d88:	97 7f       	andi	r25, 0xF7	; 247
    1d8a:	98 2b       	or	r25, r24
    1d8c:	95 b9       	out	0x05, r25	; 5
		delay_ms(msDuration);		
    1d8e:	c6 01       	movw	r24, r12
    1d90:	0e 94 f5 0e 	call	0x1dea	; 0x1dea <delay_ms>

void LED_FlashOrangeLED (uint16_t msDuration, uint8_t Times)
{
	bool CurrentLED_Status = LED_Orange;
	
	for (int i=0; i< Times; ++i)
    1d94:	0f 5f       	subi	r16, 0xFF	; 255
    1d96:	1f 4f       	sbci	r17, 0xFF	; 255
    1d98:	29 81       	ldd	r18, Y+1	; 0x01
    1d9a:	0e 15       	cp	r16, r14
    1d9c:	1f 05       	cpc	r17, r15
    1d9e:	cc f2       	brlt	.-78     	; 0x1d52 <LED_FlashOrangeLED+0x2c>
		delay_ms(msDuration);
		LED_Orange = ~LED_Orange;
		delay_ms(msDuration);		
	}
	
	LED_Orange = CurrentLED_Status;
    1da0:	21 70       	andi	r18, 0x01	; 1
    1da2:	22 0f       	add	r18, r18
    1da4:	22 0f       	add	r18, r18
    1da6:	22 0f       	add	r18, r18
    1da8:	85 b1       	in	r24, 0x05	; 5
    1daa:	87 7f       	andi	r24, 0xF7	; 247
    1dac:	82 2b       	or	r24, r18
    1dae:	85 b9       	out	0x05, r24	; 5
	
    1db0:	0f 90       	pop	r0
    1db2:	cf 91       	pop	r28
    1db4:	df 91       	pop	r29
    1db6:	1f 91       	pop	r17
    1db8:	0f 91       	pop	r16
    1dba:	ff 90       	pop	r15
    1dbc:	ef 90       	pop	r14
    1dbe:	df 90       	pop	r13
    1dc0:	cf 90       	pop	r12
    1dc2:	08 95       	ret

00001dc4 <delay_us>:



void delay_us(uint16_t time)            /* time delay for us */
{ 
 while(time--)
    1dc4:	0f c0       	rjmp	.+30     	; 0x1de4 <delay_us+0x20>
	...
	asm volatile ("NOP"); asm volatile ("NOP"); 
	asm volatile ("NOP"); 
	asm volatile ("NOP"); asm volatile ("NOP"); 
	asm volatile ("NOP"); asm volatile ("NOP"); 
	asm volatile ("NOP"); asm volatile ("NOP"); 
	asm volatile ("NOP"); 
    1de2:	01 97       	sbiw	r24, 0x01	; 1



void delay_us(uint16_t time)            /* time delay for us */
{ 
 while(time--)
    1de4:	00 97       	sbiw	r24, 0x00	; 0
    1de6:	79 f7       	brne	.-34     	; 0x1dc6 <delay_us+0x2>
	asm volatile ("NOP"); asm volatile ("NOP"); 
	asm volatile ("NOP"); asm volatile ("NOP"); 
	asm volatile ("NOP"); asm volatile ("NOP"); 
	asm volatile ("NOP"); 
 }
}
    1de8:	08 95       	ret

00001dea <delay_ms>:

void delay_ms(uint16_t time)
{
    1dea:	1f 93       	push	r17
    1dec:	cf 93       	push	r28
    1dee:	df 93       	push	r29
    1df0:	ec 01       	movw	r28, r24
	uint8_t i;
	while(time--)
    1df2:	08 c0       	rjmp	.+16     	; 0x1e04 <delay_ms+0x1a>
    1df4:	1a e0       	ldi	r17, 0x0A	; 10
	{
		for(i=0;i<10;i++) delay_us(100);
    1df6:	84 e6       	ldi	r24, 0x64	; 100
    1df8:	90 e0       	ldi	r25, 0x00	; 0
    1dfa:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <delay_us>
    1dfe:	11 50       	subi	r17, 0x01	; 1
    1e00:	d1 f7       	brne	.-12     	; 0x1df6 <delay_ms+0xc>
    1e02:	21 97       	sbiw	r28, 0x01	; 1
}

void delay_ms(uint16_t time)
{
	uint8_t i;
	while(time--)
    1e04:	20 97       	sbiw	r28, 0x00	; 0
    1e06:	b1 f7       	brne	.-20     	; 0x1df4 <delay_ms+0xa>
	{
		for(i=0;i<10;i++) delay_us(100);
	}
}
    1e08:	df 91       	pop	r29
    1e0a:	cf 91       	pop	r28
    1e0c:	1f 91       	pop	r17
    1e0e:	08 95       	ret

00001e10 <Ultrasonic_Init>:
#include "..\Include\Ultrasonic.h"


void Ultrasonic_Init ()
{
	RX_SONAR_TRIGGER_DIR = OUTPUT;
    1e10:	50 9a       	sbi	0x0a, 0	; 10
	RX_SONAR_TRIGGER=HIGH;   // Active LOW
    1e12:	48 9a       	sbi	0x09, 0	; 9
	RX_SONAR_DIR = INPUT;
    1e14:	22 98       	cbi	0x04, 2	; 4
	
	// enable interrupts
	EICRA  = _BV(ISC20);	// any edge on INT2
    1e16:	80 e1       	ldi	r24, 0x10	; 16
    1e18:	80 93 69 00 	sts	0x0069, r24
	EIMSK  = _BV(INT2);	// enable interrupt for INT0, INT1 and INT2
    1e1c:	84 e0       	ldi	r24, 0x04	; 4
    1e1e:	8d bb       	out	0x1d, r24	; 29
	EIFR   = _BV(INTF2);	// clear interrupts
    1e20:	8c bb       	out	0x1c, r24	; 28
		
	
}
    1e22:	08 95       	ret

00001e24 <Disarm>:
#include "Include/Beeper.h"


void Disarm (void)
{
	IsArmed = false;
    1e24:	10 92 96 07 	sts	0x0796, r1
	//LED_FlashOrangeLED (LED_SHORT_TOGGLE,4);
	LED_Orange = OFF;
    1e28:	2b 98       	cbi	0x05, 3	; 5
	
	TCNT1_X_snapshot1 =0; // reset timer
    1e2a:	10 92 d5 05 	sts	0x05D5, r1
    1e2e:	10 92 d4 05 	sts	0x05D4, r1
	Beeper_Beep(BEEP_SHORT,2);				
    1e32:	86 e4       	ldi	r24, 0x46	; 70
    1e34:	90 e0       	ldi	r25, 0x00	; 0
    1e36:	62 e0       	ldi	r22, 0x02	; 2
    1e38:	0e 94 91 0b 	call	0x1722	; 0x1722 <Beeper_Beep>
	Menu_LoadPage (PAGE_HOME);
    1e3c:	80 e0       	ldi	r24, 0x00	; 0
    1e3e:	90 e0       	ldi	r25, 0x00	; 0
    1e40:	0e 94 59 2c 	call	0x58b2	; 0x58b2 <Menu_LoadPage>
}
    1e44:	08 95       	ret

00001e46 <Arm>:


void Arm (void)
{
	if ((Config.FrameType == FRAMETYPE_TRICOPTER) && (Config.BoardOrientationMode==QuadFlyingMode_X))
    1e46:	80 91 cc 06 	lds	r24, 0x06CC
    1e4a:	82 30       	cpi	r24, 0x02	; 2
    1e4c:	39 f4       	brne	.+14     	; 0x1e5c <Arm+0x16>
    1e4e:	80 91 cd 06 	lds	r24, 0x06CD
    1e52:	81 30       	cpi	r24, 0x01	; 1
    1e54:	19 f4       	brne	.+6      	; 0x1e5c <Arm+0x16>
	{ // NOT VALID CONFIGURATION
		Disarm();
    1e56:	0e 94 12 0f 	call	0x1e24	; 0x1e24 <Disarm>
		
		return;
    1e5a:	08 95       	ret
	}
	
			
	IsArmed = true;
    1e5c:	81 e0       	ldi	r24, 0x01	; 1
    1e5e:	80 93 96 07 	sts	0x0796, r24
	LED_FlashOrangeLED (LED_SHORT_TOGGLE,4);
    1e62:	8e e1       	ldi	r24, 0x1E	; 30
    1e64:	90 e0       	ldi	r25, 0x00	; 0
    1e66:	64 e0       	ldi	r22, 0x04	; 4
    1e68:	70 e0       	ldi	r23, 0x00	; 0
    1e6a:	0e 94 93 0e 	call	0x1d26	; 0x1d26 <LED_FlashOrangeLED>
	LED_Orange = ON;
    1e6e:	2b 9a       	sbi	0x05, 3	; 5
	Beeper_Beep(BEEP_LONG,1);				
    1e70:	8c eb       	ldi	r24, 0xBC	; 188
    1e72:	92 e0       	ldi	r25, 0x02	; 2
    1e74:	61 e0       	ldi	r22, 0x01	; 1
    1e76:	0e 94 91 0b 	call	0x1722	; 0x1722 <Beeper_Beep>
	
	TCNT1_X_snapshot1 =0; // reset timer
    1e7a:	10 92 d5 05 	sts	0x05D5, r1
    1e7e:	10 92 d4 05 	sts	0x05D4, r1
	TCNT_X_snapshotAutoDisarm=0;				
    1e82:	10 92 0a 06 	sts	0x060A, r1
    1e86:	10 92 09 06 	sts	0x0609, r1
	Menu_LoadPage (PAGE_HOME_ARMED);
    1e8a:	82 e0       	ldi	r24, 0x02	; 2
    1e8c:	90 e0       	ldi	r25, 0x00	; 0
    1e8e:	0e 94 59 2c 	call	0x58b2	; 0x58b2 <Menu_LoadPage>
	
	PID_GyroTerms[PITCH_INDEX].I=0;
    1e92:	80 e0       	ldi	r24, 0x00	; 0
    1e94:	90 e0       	ldi	r25, 0x00	; 0
    1e96:	dc 01       	movw	r26, r24
    1e98:	80 93 58 06 	sts	0x0658, r24
    1e9c:	90 93 59 06 	sts	0x0659, r25
    1ea0:	a0 93 5a 06 	sts	0x065A, r26
    1ea4:	b0 93 5b 06 	sts	0x065B, r27
	PID_GyroTerms[ROLL_INDEX].I=0;
    1ea8:	80 93 70 06 	sts	0x0670, r24
    1eac:	90 93 71 06 	sts	0x0671, r25
    1eb0:	a0 93 72 06 	sts	0x0672, r26
    1eb4:	b0 93 73 06 	sts	0x0673, r27
	PID_GyroTerms[YAW_INDEX].I=0;
    1eb8:	80 93 88 06 	sts	0x0688, r24
    1ebc:	90 93 89 06 	sts	0x0689, r25
    1ec0:	a0 93 8a 06 	sts	0x068A, r26
    1ec4:	b0 93 8b 06 	sts	0x068B, r27
	PID_AccTerms [PITCH_INDEX].I=0;
    1ec8:	80 93 40 05 	sts	0x0540, r24
    1ecc:	90 93 41 05 	sts	0x0541, r25
    1ed0:	a0 93 42 05 	sts	0x0542, r26
    1ed4:	b0 93 43 05 	sts	0x0543, r27
	PID_AccTerms [ROLL_INDEX].I=0;
    1ed8:	80 93 58 05 	sts	0x0558, r24
    1edc:	90 93 59 05 	sts	0x0559, r25
    1ee0:	a0 93 5a 05 	sts	0x055A, r26
    1ee4:	b0 93 5b 05 	sts	0x055B, r27
	PID_AccTerms [Z_INDEX].I=0;
    1ee8:	80 93 70 05 	sts	0x0570, r24
    1eec:	90 93 71 05 	sts	0x0571, r25
    1ef0:	a0 93 72 05 	sts	0x0572, r26
    1ef4:	b0 93 73 05 	sts	0x0573, r27
    1ef8:	08 95       	ret

00001efa <Set_EEPROM_Default_Config>:
	Save_Config_to_EEPROM();
}

void Set_EEPROM_Default_Config(void)
{
	memcpy_P ( &Config, &defaultConfig, sizeof(config_t));
    1efa:	85 ec       	ldi	r24, 0xC5	; 197
    1efc:	96 e0       	ldi	r25, 0x06	; 6
    1efe:	60 e9       	ldi	r22, 0x90	; 144
    1f00:	70 e0       	ldi	r23, 0x00	; 0
    1f02:	49 eb       	ldi	r20, 0xB9	; 185
    1f04:	50 e0       	ldi	r21, 0x00	; 0
    1f06:	0e 94 32 38 	call	0x7064	; 0x7064 <memcpy_P>
}
    1f0a:	08 95       	ret

00001f0c <eeprom_write_byte_changed>:
	}
}


void eeprom_write_byte_changed( uint8_t * addr, uint8_t value )
{ 
    1f0c:	0f 93       	push	r16
    1f0e:	1f 93       	push	r17
    1f10:	df 93       	push	r29
    1f12:	cf 93       	push	r28
    1f14:	0f 92       	push	r0
    1f16:	cd b7       	in	r28, 0x3d	; 61
    1f18:	de b7       	in	r29, 0x3e	; 62
    1f1a:	8c 01       	movw	r16, r24
	if(eeprom_read_byte(addr) != value)
    1f1c:	69 83       	std	Y+1, r22	; 0x01
    1f1e:	0e 94 a6 38 	call	0x714c	; 0x714c <__eerd_byte_m324pa>
    1f22:	69 81       	ldd	r22, Y+1	; 0x01
    1f24:	86 17       	cp	r24, r22
    1f26:	19 f0       	breq	.+6      	; 0x1f2e <eeprom_write_byte_changed+0x22>
	{
		eeprom_write_byte( addr, value );
    1f28:	c8 01       	movw	r24, r16
    1f2a:	0e 94 ae 38 	call	0x715c	; 0x715c <__eewr_byte_m324pa>
	}
}
    1f2e:	0f 90       	pop	r0
    1f30:	cf 91       	pop	r28
    1f32:	df 91       	pop	r29
    1f34:	1f 91       	pop	r17
    1f36:	0f 91       	pop	r16
    1f38:	08 95       	ret

00001f3a <eeprom_write_block_changes>:
	eeprom_write_block_changes( (const void*) &Config, (void*) EEPROM_DATA_START_POS, sizeof(config_t));	//current_config CONFIG_STRUCT
	
}

void eeprom_write_block_changes( const uint8_t * src, void * dest, size_t size )
{ 
    1f3a:	cf 92       	push	r12
    1f3c:	df 92       	push	r13
    1f3e:	ef 92       	push	r14
    1f40:	ff 92       	push	r15
    1f42:	0f 93       	push	r16
    1f44:	1f 93       	push	r17
    1f46:	cf 93       	push	r28
    1f48:	df 93       	push	r29
    1f4a:	ec 01       	movw	r28, r24
    1f4c:	7b 01       	movw	r14, r22
    1f4e:	6a 01       	movw	r12, r20
	size_t len;

	for(len=0;len<size;len++)
    1f50:	00 e0       	ldi	r16, 0x00	; 0
    1f52:	10 e0       	ldi	r17, 0x00	; 0
    1f54:	08 c0       	rjmp	.+16     	; 0x1f66 <eeprom_write_block_changes+0x2c>
	{
		eeprom_write_byte_changed( dest,  *src );
    1f56:	c7 01       	movw	r24, r14
    1f58:	80 0f       	add	r24, r16
    1f5a:	91 1f       	adc	r25, r17
    1f5c:	69 91       	ld	r22, Y+
    1f5e:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <eeprom_write_byte_changed>

void eeprom_write_block_changes( const uint8_t * src, void * dest, size_t size )
{ 
	size_t len;

	for(len=0;len<size;len++)
    1f62:	0f 5f       	subi	r16, 0xFF	; 255
    1f64:	1f 4f       	sbci	r17, 0xFF	; 255
    1f66:	0c 15       	cp	r16, r12
    1f68:	1d 05       	cpc	r17, r13
    1f6a:	a8 f3       	brcs	.-22     	; 0x1f56 <eeprom_write_block_changes+0x1c>
		eeprom_write_byte_changed( dest,  *src );

		src++;
		dest++;
	}
}
    1f6c:	df 91       	pop	r29
    1f6e:	cf 91       	pop	r28
    1f70:	1f 91       	pop	r17
    1f72:	0f 91       	pop	r16
    1f74:	ff 90       	pop	r15
    1f76:	ef 90       	pop	r14
    1f78:	df 90       	pop	r13
    1f7a:	cf 90       	pop	r12
    1f7c:	08 95       	ret

00001f7e <Load_Config_from_EEPROM>:

void Load_Config_from_EEPROM(void)
{
	// write to eeProm
	
	eeprom_write_block_changes( (const void*) &Config, (void*) EEPROM_DATA_START_POS, sizeof(config_t));	//current_config CONFIG_STRUCT
    1f7e:	85 ec       	ldi	r24, 0xC5	; 197
    1f80:	96 e0       	ldi	r25, 0x06	; 6
    1f82:	60 e0       	ldi	r22, 0x00	; 0
    1f84:	70 e0       	ldi	r23, 0x00	; 0
    1f86:	49 eb       	ldi	r20, 0xB9	; 185
    1f88:	50 e0       	ldi	r21, 0x00	; 0
    1f8a:	0e 94 9d 0f 	call	0x1f3a	; 0x1f3a <eeprom_write_block_changes>
	
}
    1f8e:	08 95       	ret

00001f90 <Save_Config_to_EEPROM>:
}

void Save_Config_to_EEPROM(void)
{
	// write to eeProm
	cli();
    1f90:	f8 94       	cli
	eeprom_write_block_changes( (const void*) &Config, (void*) EEPROM_DATA_START_POS, sizeof(config_t));	//current_config CONFIG_STRUCT
    1f92:	85 ec       	ldi	r24, 0xC5	; 197
    1f94:	96 e0       	ldi	r25, 0x06	; 6
    1f96:	60 e0       	ldi	r22, 0x00	; 0
    1f98:	70 e0       	ldi	r23, 0x00	; 0
    1f9a:	49 eb       	ldi	r20, 0xB9	; 185
    1f9c:	50 e0       	ldi	r21, 0x00	; 0
    1f9e:	0e 94 9d 0f 	call	0x1f3a	; 0x1f3a <eeprom_write_block_changes>
	sei();
    1fa2:	78 94       	sei
	
	Beeper_Beep(BEEP_LONG,1);	
    1fa4:	8c eb       	ldi	r24, 0xBC	; 188
    1fa6:	92 e0       	ldi	r25, 0x02	; 2
    1fa8:	61 e0       	ldi	r22, 0x01	; 1
    1faa:	0e 94 91 0b 	call	0x1722	; 0x1722 <Beeper_Beep>
}
    1fae:	08 95       	ret

00001fb0 <Save_Default_Config_to_EEPROM>:

void Save_Default_Config_to_EEPROM (void)
{
	
	// copy default config to config.
	Set_EEPROM_Default_Config();
    1fb0:	0e 94 7d 0f 	call	0x1efa	; 0x1efa <Set_EEPROM_Default_Config>
    1fb4:	e8 e3       	ldi	r30, 0x38	; 56
    1fb6:	f7 e0       	ldi	r31, 0x07	; 7
	
	
	// Init values.
	for (uint8_t i = 0; i < RXChannels; i++)
	{
		Config.RX_Mid[0][i] = PWM_MID;
    1fb8:	20 ef       	ldi	r18, 0xF0	; 240
    1fba:	35 e0       	ldi	r19, 0x05	; 5
		Config.RX_Min[0][i] = PWM_LOW;
    1fbc:	80 e6       	ldi	r24, 0x60	; 96
    1fbe:	94 e0       	ldi	r25, 0x04	; 4
	
	
	// Init values.
	for (uint8_t i = 0; i < RXChannels; i++)
	{
		Config.RX_Mid[0][i] = PWM_MID;
    1fc0:	21 93       	st	Z+, r18
    1fc2:	31 93       	st	Z+, r19
		Config.RX_Min[0][i] = PWM_LOW;
    1fc4:	93 8b       	std	Z+19, r25	; 0x13
    1fc6:	82 8b       	std	Z+18, r24	; 0x12
		Config.RX_Mid[1][i] = PWM_MID;
    1fc8:	31 87       	std	Z+9, r19	; 0x09
    1fca:	20 87       	std	Z+8, r18	; 0x08
		Config.RX_Min[1][i] = PWM_LOW;
    1fcc:	95 8f       	std	Z+29, r25	; 0x1d
    1fce:	84 8f       	std	Z+28, r24	; 0x1c
	// copy default config to config.
	Set_EEPROM_Default_Config();
	
	
	// Init values.
	for (uint8_t i = 0; i < RXChannels; i++)
    1fd0:	47 e0       	ldi	r20, 0x07	; 7
    1fd2:	e2 34       	cpi	r30, 0x42	; 66
    1fd4:	f4 07       	cpc	r31, r20
    1fd6:	a1 f7       	brne	.-24     	; 0x1fc0 <Save_Default_Config_to_EEPROM+0x10>
		Config.RX_Mid[1][i] = PWM_MID;
		Config.RX_Min[1][i] = PWM_LOW;
	}	
	
	// write to eeProm
	Save_Config_to_EEPROM();
    1fd8:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <Save_Config_to_EEPROM>
}
    1fdc:	08 95       	ret

00001fde <Initial_EEPROM_Config_Load>:


void Initial_EEPROM_Config_Load(void)
{
	// load up last settings from EEPROM
	if(eeprom_read_byte((uint8_t*) EEPROM_DATA_START_POS )!=HEFNYCOPTER2_SIGNATURE)
    1fde:	80 e0       	ldi	r24, 0x00	; 0
    1fe0:	90 e0       	ldi	r25, 0x00	; 0
    1fe2:	0e 94 a6 38 	call	0x714c	; 0x714c <__eerd_byte_m324pa>
    1fe6:	8e 3f       	cpi	r24, 0xFE	; 254
    1fe8:	19 f0       	breq	.+6      	; 0x1ff0 <Initial_EEPROM_Config_Load+0x12>
	{
		Save_Default_Config_to_EEPROM();
    1fea:	0e 94 d8 0f 	call	0x1fb0	; 0x1fb0 <Save_Default_Config_to_EEPROM>
    1fee:	08 95       	ret
		
	} else {
		// read eeprom
		eeprom_read_block(&Config, (void*) EEPROM_DATA_START_POS, sizeof(config_t)); 
    1ff0:	85 ec       	ldi	r24, 0xC5	; 197
    1ff2:	96 e0       	ldi	r25, 0x06	; 6
    1ff4:	60 e0       	ldi	r22, 0x00	; 0
    1ff6:	70 e0       	ldi	r23, 0x00	; 0
    1ff8:	49 eb       	ldi	r20, 0xB9	; 185
    1ffa:	50 e0       	ldi	r21, 0x00	; 0
    1ffc:	0e 94 96 38 	call	0x712c	; 0x712c <__eerd_block_m324pa>
    2000:	08 95       	ret

00002002 <__vector_15>:
*/

//volatile uint32_t x=0;

ISR(TIMER1_OVF_vect)
{
    2002:	1f 92       	push	r1
    2004:	0f 92       	push	r0
    2006:	0f b6       	in	r0, 0x3f	; 63
    2008:	0f 92       	push	r0
    200a:	11 24       	eor	r1, r1
    200c:	8f 93       	push	r24
    200e:	9f 93       	push	r25
	
	TCNT1_X++; // click every 0.0032768 sec [1 sec = 305.17578125 TCNT1_X] overflows every 214.7483648 sec = 3.579 min
    2010:	80 91 4e 06 	lds	r24, 0x064E
    2014:	90 91 4f 06 	lds	r25, 0x064F
    2018:	01 96       	adiw	r24, 0x01	; 1
    201a:	90 93 4f 06 	sts	0x064F, r25
    201e:	80 93 4e 06 	sts	0x064E, r24
	//TCNT1_X_GlobalTimer +=32;  // 0.0032768
}
    2022:	9f 91       	pop	r25
    2024:	8f 91       	pop	r24
    2026:	0f 90       	pop	r0
    2028:	0f be       	out	0x3f, r0	; 63
    202a:	0f 90       	pop	r0
    202c:	1f 90       	pop	r1
    202e:	18 95       	reti

00002030 <__vector_11>:


ISR(TIMER2_OVF_vect)
{
    2030:	1f 92       	push	r1
    2032:	0f 92       	push	r0
    2034:	0f b6       	in	r0, 0x3f	; 63
    2036:	0f 92       	push	r0
    2038:	11 24       	eor	r1, r1
    203a:	8f 93       	push	r24
    203c:	9f 93       	push	r25
	TCNT2_X++; 
    203e:	80 91 a9 05 	lds	r24, 0x05A9
    2042:	90 91 aa 05 	lds	r25, 0x05AA
    2046:	01 96       	adiw	r24, 0x01	; 1
    2048:	90 93 aa 05 	sts	0x05AA, r25
    204c:	80 93 a9 05 	sts	0x05A9, r24
}	
    2050:	9f 91       	pop	r25
    2052:	8f 91       	pop	r24
    2054:	0f 90       	pop	r0
    2056:	0f be       	out	0x3f, r0	; 63
    2058:	0f 90       	pop	r0
    205a:	1f 90       	pop	r1
    205c:	18 95       	reti

0000205e <Timer_Init>:
{
	
	//TIMER ZERO is RESERVED for LCD DISPLAY.	
	
	// Timer1 @20MHz with overflow interrupt
	TCCR1B = _BV(CS10);
    205e:	81 e0       	ldi	r24, 0x01	; 1
    2060:	80 93 81 00 	sts	0x0081, r24
	TIMSK1 = _BV(TOIE1);
    2064:	80 93 6f 00 	sts	0x006F, r24
	TCNT1_X =0;
    2068:	10 92 4f 06 	sts	0x064F, r1
    206c:	10 92 4e 06 	sts	0x064E, r1
			1 0 0		clkT2S/64 (From prescaler)
			1 0 1		clkT2S/128 (From prescaler)
			1 1 0		clkT2S/256 (From prescaler)
			1 1 1		clkT2S/1024 (From prescaler)
	*/
	TCCR2B  = (1 << CS21) | (1 << CS20);	//  div by 32	
    2070:	93 e0       	ldi	r25, 0x03	; 3
    2072:	90 93 b1 00 	sts	0x00B1, r25
	TIMSK2  = _BV(TOIE2); 
    2076:	80 93 70 00 	sts	0x0070, r24
	TIFR2   = 0;
    207a:	17 ba       	out	0x17, r1	; 23
	TCNT2	= 0;		// this overflows every  1.6us x 0xff = 409.6 us,  value tick 1.6us
    207c:	10 92 b2 00 	sts	0x00B2, r1
	TCNT2_X = 0;
    2080:	10 92 aa 05 	sts	0x05AA, r1
    2084:	10 92 a9 05 	sts	0x05A9, r1
	/* IMPORTANT TCNT2 is used completly by motor and is reset during ESC pulse generation so you cannot depend on it for other purpose
	unless it is not time critical and no accuracy is required such as UI delays*/
	// tick: 12.8u  ov:3.2768ms	: TCNT2_X OV:  214.7483648 sec

    2088:	08 95       	ret

0000208a <UART_Init>:
	
}

void UART_Init( unsigned int ubrr)
{
	if (Config.RX_mode==RX_mode_UARTMode)
    208a:	20 91 c7 06 	lds	r18, 0x06C7
    208e:	2f 3f       	cpi	r18, 0xFF	; 255
    2090:	61 f4       	brne	.+24     	; 0x20aa <UART_Init+0x20>
	{
		//memcpy(DisplayBuffer,"STR",3);
		RXIndex=0;
    2092:	10 92 1f 05 	sts	0x051F, r1
		/*Set baud rate */
		UBRR1H = (unsigned char)(ubrr>>8);	
    2096:	90 93 cd 00 	sts	0x00CD, r25
		UBRR1L = (unsigned char)ubrr;
    209a:	80 93 cc 00 	sts	0x00CC, r24
		
		//UCSR1A = (1 << U2X1); // doubling divisor rate;
		// Set frame format to 8 data bits, no parity, 1 stop bit
		UCSR1C = (0<<USBS1)|(1<<UCSZ11)|(1<<UCSZ10);
    209e:	86 e0       	ldi	r24, 0x06	; 6
    20a0:	80 93 ca 00 	sts	0x00CA, r24
		// Enable receiver and transmitter
		UCSR1B =  (1<<TXEN1)	// Enable USART TX
    20a4:	88 e9       	ldi	r24, 0x98	; 152
    20a6:	80 93 c9 00 	sts	0x00C9, r24
    20aa:	08 95       	ret

000020ac <send_byte>:

void send_byte(uint8_t u8Data)
{

	// Wait if a byte is being transmitted
	while((UCSR1A & (1<<UDRE1)) == 0);
    20ac:	90 91 c8 00 	lds	r25, 0x00C8
    20b0:	95 ff       	sbrs	r25, 5
    20b2:	fc cf       	rjmp	.-8      	; 0x20ac <send_byte>
	// Transmit data
	/////////delay_ms(10);
	UDR1 = u8Data;
    20b4:	80 93 ce 00 	sts	0x00CE, r24
}
    20b8:	08 95       	ret

000020ba <Send_Data>:


void Send_Data (void * msg, uint8_t len)
{
    20ba:	ef 92       	push	r14
    20bc:	ff 92       	push	r15
    20be:	0f 93       	push	r16
    20c0:	1f 93       	push	r17
    20c2:	cf 93       	push	r28
    20c4:	df 93       	push	r29
	
	for (int i=0; i<len;++i)
    20c6:	08 2f       	mov	r16, r24
    20c8:	19 2f       	mov	r17, r25
    20ca:	c0 e0       	ldi	r28, 0x00	; 0
    20cc:	d0 e0       	ldi	r29, 0x00	; 0
    20ce:	e6 2e       	mov	r14, r22
    20d0:	ff 24       	eor	r15, r15
    20d2:	06 c0       	rjmp	.+12     	; 0x20e0 <Send_Data+0x26>
	{
		send_byte (((uint8_t *)msg)[i]);
    20d4:	f8 01       	movw	r30, r16
    20d6:	81 91       	ld	r24, Z+
    20d8:	8f 01       	movw	r16, r30
    20da:	0e 94 56 10 	call	0x20ac	; 0x20ac <send_byte>


void Send_Data (void * msg, uint8_t len)
{
	
	for (int i=0; i<len;++i)
    20de:	21 96       	adiw	r28, 0x01	; 1
    20e0:	ce 15       	cp	r28, r14
    20e2:	df 05       	cpc	r29, r15
    20e4:	bc f3       	brlt	.-18     	; 0x20d4 <Send_Data+0x1a>
	{
		send_byte (((uint8_t *)msg)[i]);
	}
	
	
}
    20e6:	df 91       	pop	r29
    20e8:	cf 91       	pop	r28
    20ea:	1f 91       	pop	r17
    20ec:	0f 91       	pop	r16
    20ee:	ff 90       	pop	r15
    20f0:	ef 90       	pop	r14
    20f2:	08 95       	ret

000020f4 <ParseCommand>:
}


void ParseCommand ()
{
	if (IsArmed==true)
    20f4:	80 91 96 07 	lds	r24, 0x0796
    20f8:	81 30       	cpi	r24, 0x01	; 1
    20fa:	09 f4       	brne	.+2      	; 0x20fe <ParseCommand+0xa>
    20fc:	69 c0       	rjmp	.+210    	; 0x21d0 <ParseCommand+0xdc>
    20fe:	80 e0       	ldi	r24, 0x00	; 0
    2100:	90 e0       	ldi	r25, 0x00	; 0
    2102:	20 e0       	ldi	r18, 0x00	; 0
		return ;
	}		
	int8_t CRC=0;
	for (int i=0;i < SERIAL_BUFFERSIZE_1; ++i)
	{
		CRC +=RXBuffer[i];
    2104:	fc 01       	movw	r30, r24
    2106:	e9 55       	subi	r30, 0x59	; 89
    2108:	f8 4f       	sbci	r31, 0xF8	; 248
    210a:	30 81       	ld	r19, Z
    210c:	23 0f       	add	r18, r19
	{
		//Just ignore for safty reasons....some commands generate beeps or flash led that call delay function which will crash your quadcopter if called.
		return ;
	}		
	int8_t CRC=0;
	for (int i=0;i < SERIAL_BUFFERSIZE_1; ++i)
    210e:	01 96       	adiw	r24, 0x01	; 1
    2110:	88 30       	cpi	r24, 0x08	; 8
    2112:	91 05       	cpc	r25, r1
    2114:	b9 f7       	brne	.-18     	; 0x2104 <ParseCommand+0x10>
	{
		CRC +=RXBuffer[i];
	}
	if (CRC == (int8_t)RXBuffer[SERIAL_CRC_OFFSET])
    2116:	80 91 af 07 	lds	r24, 0x07AF
    211a:	28 17       	cp	r18, r24
    211c:	09 f0       	breq	.+2      	; 0x2120 <ParseCommand+0x2c>
    211e:	58 c0       	rjmp	.+176    	; 0x21d0 <ParseCommand+0xdc>
	{
		switch (RXBuffer[SERIAL_HEADER])
    2120:	80 91 a7 07 	lds	r24, 0x07A7
    2124:	83 34       	cpi	r24, 0x43	; 67
    2126:	21 f0       	breq	.+8      	; 0x2130 <ParseCommand+0x3c>
    2128:	86 35       	cpi	r24, 0x56	; 86
    212a:	09 f0       	breq	.+2      	; 0x212e <ParseCommand+0x3a>
    212c:	51 c0       	rjmp	.+162    	; 0x21d0 <ParseCommand+0xdc>
    212e:	37 c0       	rjmp	.+110    	; 0x219e <ParseCommand+0xaa>
		{
			case SERIAL_HEADER_DOCMD:
				switch (RXBuffer[SERIAL_CMD_ID])
    2130:	80 91 a8 07 	lds	r24, 0x07A8
    2134:	85 30       	cpi	r24, 0x05	; 5
    2136:	e9 f0       	breq	.+58     	; 0x2172 <ParseCommand+0x7e>
    2138:	86 30       	cpi	r24, 0x06	; 6
    213a:	30 f4       	brcc	.+12     	; 0x2148 <ParseCommand+0x54>
    213c:	81 30       	cpi	r24, 0x01	; 1
    213e:	51 f0       	breq	.+20     	; 0x2154 <ParseCommand+0x60>
    2140:	82 30       	cpi	r24, 0x02	; 2
    2142:	09 f0       	breq	.+2      	; 0x2146 <ParseCommand+0x52>
    2144:	45 c0       	rjmp	.+138    	; 0x21d0 <ParseCommand+0xdc>
    2146:	0c c0       	rjmp	.+24     	; 0x2160 <ParseCommand+0x6c>
    2148:	86 30       	cpi	r24, 0x06	; 6
    214a:	19 f1       	breq	.+70     	; 0x2192 <ParseCommand+0x9e>
    214c:	87 30       	cpi	r24, 0x07	; 7
    214e:	09 f0       	breq	.+2      	; 0x2152 <ParseCommand+0x5e>
    2150:	3f c0       	rjmp	.+126    	; 0x21d0 <ParseCommand+0xdc>
    2152:	22 c0       	rjmp	.+68     	; 0x2198 <ParseCommand+0xa4>
				{
					case SERIAL_CMD_LED_BLINK: // never  call while ARMED .... calling delay function will affect motor speed.
						LED_FlashOrangeLED (LED_SHORT_TOGGLE,4);
    2154:	8e e1       	ldi	r24, 0x1E	; 30
    2156:	90 e0       	ldi	r25, 0x00	; 0
    2158:	64 e0       	ldi	r22, 0x04	; 4
    215a:	0e 94 93 0e 	call	0x1d26	; 0x1d26 <LED_FlashOrangeLED>
					break;
    215e:	08 95       	ret
					case SERIAL_CMD_PID_CONFIG:
						Send_Data("C",1);
    2160:	80 e0       	ldi	r24, 0x00	; 0
    2162:	91 e0       	ldi	r25, 0x01	; 1
    2164:	61 e0       	ldi	r22, 0x01	; 1
    2166:	0e 94 5d 10 	call	0x20ba	; 0x20ba <Send_Data>
						Send_Data(&(Config.GyroParams),98);
    216a:	83 ed       	ldi	r24, 0xD3	; 211
    216c:	96 e0       	ldi	r25, 0x06	; 6
    216e:	62 e6       	ldi	r22, 0x62	; 98
    2170:	08 c0       	rjmp	.+16     	; 0x2182 <ParseCommand+0x8e>
						Send_Data("E",1);
					break;
					case SERIAL_CMD_READ_CONFIG: // BAD
						Send_Data("C",1);
    2172:	80 e0       	ldi	r24, 0x00	; 0
    2174:	91 e0       	ldi	r25, 0x01	; 1
    2176:	61 e0       	ldi	r22, 0x01	; 1
    2178:	0e 94 5d 10 	call	0x20ba	; 0x20ba <Send_Data>
						Send_Data(&Config,86);
    217c:	85 ec       	ldi	r24, 0xC5	; 197
    217e:	96 e0       	ldi	r25, 0x06	; 6
    2180:	66 e5       	ldi	r22, 0x56	; 86
    2182:	0e 94 5d 10 	call	0x20ba	; 0x20ba <Send_Data>
						Send_Data("E",1);
    2186:	82 e0       	ldi	r24, 0x02	; 2
    2188:	91 e0       	ldi	r25, 0x01	; 1
    218a:	61 e0       	ldi	r22, 0x01	; 1
    218c:	0e 94 5d 10 	call	0x20ba	; 0x20ba <Send_Data>
					break;
    2190:	08 95       	ret
					case SERIAL_CMD_SAVE_CONFIG:
						Save_Config_to_EEPROM();
    2192:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <Save_Config_to_EEPROM>
					break;
    2196:	08 95       	ret
					case SERIAL_CMD_CALIBRATE_ACC:
						Sensors_Calibrate();								
    2198:	0e 94 b3 26 	call	0x4d66	; 0x4d66 <Sensors_Calibrate>
					break;
    219c:	08 95       	ret
				}
			break;
			case SERIAL_HEADER_SETVALUE:
				//LED_FlashOrangeLED (LED_SHORT_TOGGLE,4);
				memcpy ((void *)&Config + RXBuffer[SERIAL_DATA_OFFSET] + (RXBuffer[SERIAL_DATA_OFFSET+1] * 0xff),(void *) &RXBuffer[SERIAL_DATA_VALUE], (int8_t) RXBuffer[SERIAL_DATA_LENGHT]);
    219e:	80 91 a8 07 	lds	r24, 0x07A8
    21a2:	60 91 a9 07 	lds	r22, 0x07A9
    21a6:	40 91 aa 07 	lds	r20, 0x07AA
    21aa:	9f ef       	ldi	r25, 0xFF	; 255
    21ac:	69 9f       	mul	r22, r25
    21ae:	b0 01       	movw	r22, r0
    21b0:	11 24       	eor	r1, r1
    21b2:	68 0f       	add	r22, r24
    21b4:	71 1d       	adc	r23, r1
    21b6:	6b 53       	subi	r22, 0x3B	; 59
    21b8:	79 4f       	sbci	r23, 0xF9	; 249
    21ba:	24 2f       	mov	r18, r20
    21bc:	33 27       	eor	r19, r19
    21be:	27 fd       	sbrc	r18, 7
    21c0:	30 95       	com	r19
    21c2:	eb ea       	ldi	r30, 0xAB	; 171
    21c4:	f7 e0       	ldi	r31, 0x07	; 7
    21c6:	cb 01       	movw	r24, r22
    21c8:	bf 01       	movw	r22, r30
    21ca:	53 2f       	mov	r21, r19
    21cc:	0e 94 4b 38 	call	0x7096	; 0x7096 <memcpy>
    21d0:	08 95       	ret

000021d2 <__vector_28>:
  
  
void ParseCommand();

ISR (USART1_RX_vect)
{
    21d2:	1f 92       	push	r1
    21d4:	0f 92       	push	r0
    21d6:	0f b6       	in	r0, 0x3f	; 63
    21d8:	0f 92       	push	r0
    21da:	11 24       	eor	r1, r1
    21dc:	2f 93       	push	r18
    21de:	3f 93       	push	r19
    21e0:	4f 93       	push	r20
    21e2:	5f 93       	push	r21
    21e4:	6f 93       	push	r22
    21e6:	7f 93       	push	r23
    21e8:	8f 93       	push	r24
    21ea:	9f 93       	push	r25
    21ec:	af 93       	push	r26
    21ee:	bf 93       	push	r27
    21f0:	ef 93       	push	r30
    21f2:	ff 93       	push	r31
	 while ( !(UCSR1A & (1<<RXC1))); 
    21f4:	80 91 c8 00 	lds	r24, 0x00C8
    21f8:	87 ff       	sbrs	r24, 7
    21fa:	fc cf       	rjmp	.-8      	; 0x21f4 <__vector_28+0x22>
	 RXChar = UDR1;
    21fc:	80 91 ce 00 	lds	r24, 0x00CE
    2200:	80 93 a2 07 	sts	0x07A2, r24
	 
	  if ((c_state!=IDLE) && (TCNT1_X - LastRXTime) > 20) 
    2204:	80 91 20 05 	lds	r24, 0x0520
    2208:	88 23       	and	r24, r24
    220a:	99 f0       	breq	.+38     	; 0x2232 <__vector_28+0x60>
    220c:	80 91 4e 06 	lds	r24, 0x064E
    2210:	90 91 4f 06 	lds	r25, 0x064F
    2214:	20 91 a3 07 	lds	r18, 0x07A3
    2218:	30 91 a4 07 	lds	r19, 0x07A4
    221c:	82 1b       	sub	r24, r18
    221e:	93 0b       	sbc	r25, r19
    2220:	85 31       	cpi	r24, 0x15	; 21
    2222:	91 05       	cpc	r25, r1
    2224:	30 f0       	brcs	.+12     	; 0x2232 <__vector_28+0x60>
	   {
		   // timeout ..
		   c_state = IDLE;
    2226:	10 92 20 05 	sts	0x0520, r1
		   RXIndex =0;
    222a:	10 92 1f 05 	sts	0x051F, r1
		   DisplayBuffer[4]=0;
    222e:	10 92 9c 07 	sts	0x079C, r1
		   //memcpy(DisplayBuffer,"OUT",3);
		   //return ;
	   }
	   RXBuffer[RXIndex]=RXChar;
    2232:	e0 91 1f 05 	lds	r30, 0x051F
    2236:	f0 e0       	ldi	r31, 0x00	; 0
    2238:	80 91 a2 07 	lds	r24, 0x07A2
    223c:	e9 55       	subi	r30, 0x59	; 89
    223e:	f8 4f       	sbci	r31, 0xF8	; 248
    2240:	80 83       	st	Z, r24
	   switch (c_state)
    2242:	80 91 20 05 	lds	r24, 0x0520
    2246:	88 23       	and	r24, r24
    2248:	19 f0       	breq	.+6      	; 0x2250 <__vector_28+0x7e>
    224a:	81 30       	cpi	r24, 0x01	; 1
    224c:	c1 f4       	brne	.+48     	; 0x227e <__vector_28+0xac>
    224e:	06 c0       	rjmp	.+12     	; 0x225c <__vector_28+0x8a>
	   {
		   case IDLE:
		   // Waiting for new command
			   RXIndex=0;
    2250:	10 92 1f 05 	sts	0x051F, r1
			   
			   
			   c_state = HEADER_RX;
    2254:	81 e0       	ldi	r24, 0x01	; 1
    2256:	80 93 20 05 	sts	0x0520, r24
    225a:	07 c0       	rjmp	.+14     	; 0x226a <__vector_28+0x98>
		   break;
		   
		   case HEADER_RX:
		   // Copy Data
				
			    if (RXIndex==SERIAL_BUFFERSIZE_1)
    225c:	80 91 1f 05 	lds	r24, 0x051F
    2260:	88 30       	cpi	r24, 0x08	; 8
    2262:	19 f4       	brne	.+6      	; 0x226a <__vector_28+0x98>
				{
					ParseCommand();
    2264:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <ParseCommand>
    2268:	0a c0       	rjmp	.+20     	; 0x227e <__vector_28+0xac>
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    226a:	f8 94       	cli
				}
				else
				{
					ATOMIC_BLOCK(ATOMIC_FORCEON)
				   {
					 LastRXTime = TCNT1_X;
    226c:	80 91 4e 06 	lds	r24, 0x064E
    2270:	90 91 4f 06 	lds	r25, 0x064F
    2274:	90 93 a4 07 	sts	0x07A4, r25
    2278:	80 93 a3 07 	sts	0x07A3, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    227c:	78 94       	sei
				   }
				}								
		   break;
	   }
	
	 RXIndex+=1;
    227e:	80 91 1f 05 	lds	r24, 0x051F
    2282:	8f 5f       	subi	r24, 0xFF	; 255
    2284:	80 93 1f 05 	sts	0x051F, r24
	 if (RXIndex==SERIAL_BUFFERSIZE) 
    2288:	80 91 1f 05 	lds	r24, 0x051F
    228c:	89 30       	cpi	r24, 0x09	; 9
    228e:	21 f4       	brne	.+8      	; 0x2298 <__vector_28+0xc6>
	 {
		RXIndex=0;
    2290:	10 92 1f 05 	sts	0x051F, r1
		c_state = IDLE;
    2294:	10 92 20 05 	sts	0x0520, r1
	 }		
}
    2298:	ff 91       	pop	r31
    229a:	ef 91       	pop	r30
    229c:	bf 91       	pop	r27
    229e:	af 91       	pop	r26
    22a0:	9f 91       	pop	r25
    22a2:	8f 91       	pop	r24
    22a4:	7f 91       	pop	r23
    22a6:	6f 91       	pop	r22
    22a8:	5f 91       	pop	r21
    22aa:	4f 91       	pop	r20
    22ac:	3f 91       	pop	r19
    22ae:	2f 91       	pop	r18
    22b0:	0f 90       	pop	r0
    22b2:	0f be       	out	0x3f, r0	; 63
    22b4:	0f 90       	pop	r0
    22b6:	1f 90       	pop	r1
    22b8:	18 95       	reti

000022ba <Send_Data_TEST>:
	
	
}

void Send_Data_TEST (void * msg, uint8_t len)
{
    22ba:	ef 92       	push	r14
    22bc:	ff 92       	push	r15
    22be:	0f 93       	push	r16
    22c0:	1f 93       	push	r17
    22c2:	cf 93       	push	r28
    22c4:	df 93       	push	r29
	for (int i=0; i<len;++i)
    22c6:	08 2f       	mov	r16, r24
    22c8:	19 2f       	mov	r17, r25
    22ca:	c0 e0       	ldi	r28, 0x00	; 0
    22cc:	d0 e0       	ldi	r29, 0x00	; 0
    22ce:	e6 2e       	mov	r14, r22
    22d0:	ff 24       	eor	r15, r15
    22d2:	06 c0       	rjmp	.+12     	; 0x22e0 <Send_Data_TEST+0x26>
	{
		send_byte (((uint8_t *)msg)[i]);
    22d4:	f8 01       	movw	r30, r16
    22d6:	81 91       	ld	r24, Z+
    22d8:	8f 01       	movw	r16, r30
    22da:	0e 94 56 10 	call	0x20ac	; 0x20ac <send_byte>
	
}

void Send_Data_TEST (void * msg, uint8_t len)
{
	for (int i=0; i<len;++i)
    22de:	21 96       	adiw	r28, 0x01	; 1
    22e0:	ce 15       	cp	r28, r14
    22e2:	df 05       	cpc	r29, r15
    22e4:	bc f3       	brlt	.-18     	; 0x22d4 <Send_Data_TEST+0x1a>
	{
		send_byte (((uint8_t *)msg)[i]);
	}
	
    22e6:	df 91       	pop	r29
    22e8:	cf 91       	pop	r28
    22ea:	1f 91       	pop	r17
    22ec:	0f 91       	pop	r16
    22ee:	ff 90       	pop	r15
    22f0:	ef 90       	pop	r14
    22f2:	08 95       	ret

000022f4 <_font12x16selector>:
	*/
};

static PGM_P _font12x16selector(unsigned char c)
{
	return (PGM_P) _font12x16map + (c - 0x20) * BYTESPERCHAR;
    22f4:	90 e0       	ldi	r25, 0x00	; 0
    22f6:	80 97       	sbiw	r24, 0x20	; 32
    22f8:	9c 01       	movw	r18, r24
    22fa:	22 0f       	add	r18, r18
    22fc:	33 1f       	adc	r19, r19
    22fe:	28 0f       	add	r18, r24
    2300:	39 1f       	adc	r19, r25
    2302:	83 e0       	ldi	r24, 0x03	; 3
    2304:	22 0f       	add	r18, r18
    2306:	33 1f       	adc	r19, r19
    2308:	8a 95       	dec	r24
    230a:	e1 f7       	brne	.-8      	; 0x2304 <_font12x16selector+0x10>
    230c:	23 5b       	subi	r18, 0xB3	; 179
    230e:	3e 4f       	sbci	r19, 0xFE	; 254
}
    2310:	c9 01       	movw	r24, r18
    2312:	08 95       	ret

00002314 <_font6x8selector>:
	*/
};

static PGM_P _font6x8selector(unsigned char c)
{
	return (PGM_P) _font6x8map + (c - 0x20) * BYTESPERCHAR;
    2314:	90 e0       	ldi	r25, 0x00	; 0
    2316:	80 97       	sbiw	r24, 0x20	; 32
    2318:	9c 01       	movw	r18, r24
    231a:	22 0f       	add	r18, r18
    231c:	33 1f       	adc	r19, r19
    231e:	28 0f       	add	r18, r24
    2320:	39 1f       	adc	r19, r25
    2322:	22 0f       	add	r18, r18
    2324:	33 1f       	adc	r19, r19
    2326:	2f 5a       	subi	r18, 0xAF	; 175
    2328:	38 4f       	sbci	r19, 0xF8	; 248
}
    232a:	c9 01       	movw	r24, r18
    232c:	08 95       	ret

0000232e <Setup>:
static uint8_t FlyingModesToggle;

void Setup (void)
{
	
	Menu_EnableAllItems();
    232e:	0e 94 ba 35 	call	0x6b74	; 0x6b74 <Menu_EnableAllItems>
	
	Initial_EEPROM_Config_Load();
    2332:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <Initial_EEPROM_Config_Load>
	
	//Config.QuadFlyingMode = QuadFlyingMode_PLUS;
	
	RX_Init();
    2336:	0e 94 ed 23 	call	0x47da	; 0x47da <RX_Init>
	if ((Config.RX_mode==RX_mode_UARTMode) && (IS_MISC_SENSOR_SONAR_ENABLED==true))
    233a:	80 91 c7 06 	lds	r24, 0x06C7
    233e:	8f 3f       	cpi	r24, 0xFF	; 255
    2340:	31 f4       	brne	.+12     	; 0x234e <Setup+0x20>
    2342:	80 91 d2 06 	lds	r24, 0x06D2
    2346:	80 ff       	sbrs	r24, 0
    2348:	02 c0       	rjmp	.+4      	; 0x234e <Setup+0x20>
	{
		Ultrasonic_Init();
    234a:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <Ultrasonic_Init>
	}		
	// Motors
	M1_DIR = OUTPUT;
    234e:	3e 9a       	sbi	0x07, 6	; 7
	M2_DIR = OUTPUT;
    2350:	3c 9a       	sbi	0x07, 4	; 7
	M3_DIR = OUTPUT;
    2352:	3a 9a       	sbi	0x07, 2	; 7
	M4_DIR = OUTPUT;
    2354:	3b 9a       	sbi	0x07, 3	; 7
	M1 = 0;
    2356:	46 98       	cbi	0x08, 6	; 8
	M2 = 0;
    2358:	44 98       	cbi	0x08, 4	; 8
	M3 = 0;
    235a:	42 98       	cbi	0x08, 2	; 8
	M4 = 0;
    235c:	43 98       	cbi	0x08, 3	; 8
	
	Buzzer_DIR = OUTPUT;
    235e:	21 9a       	sbi	0x04, 1	; 4
	LED_Orange_DIR = OUTPUT;
    2360:	23 9a       	sbi	0x04, 3	; 4
	
	
	// Sensors
	V_BAT  = INPUT;
    2362:	13 98       	cbi	0x02, 3	; 2
	
	
	
	// Timers
	TCCR1A = 0;	//Set timer 1 to run at 2.5MHz
    2364:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;
    2368:	10 92 81 00 	sts	0x0081, r1
	TCCR1C = 0;
    236c:	10 92 82 00 	sts	0x0082, r1
	

if (Config.RX_mode==RX_mode_UARTMode)
    2370:	80 91 c7 06 	lds	r24, 0x06C7
    2374:	8f 3f       	cpi	r24, 0xFF	; 255
    2376:	21 f4       	brne	.+8      	; 0x2380 <Setup+0x52>
{
	UART_Init(SERIAL_BAUD_RATE); //57600 = 20   115200=10
    2378:	8a e0       	ldi	r24, 0x0A	; 10
    237a:	90 e0       	ldi	r25, 0x00	; 0
    237c:	0e 94 45 10 	call	0x208a	; 0x208a <UART_Init>
}	



	ADCPort_Init();
    2380:	0e 94 1c 28 	call	0x5038	; 0x5038 <ADCPort_Init>
	Sensors_Init();
    2384:	0e 94 74 26 	call	0x4ce8	; 0x4ce8 <Sensors_Init>
	KeyBoard_Init();
    2388:	0e 94 b1 0b 	call	0x1762	; 0x1762 <KeyBoard_Init>
	Timer_Init();
    238c:	0e 94 2f 10 	call	0x205e	; 0x205e <Timer_Init>
	
	LCD_Init();
    2390:	0e 94 68 0e 	call	0x1cd0	; 0x1cd0 <LCD_Init>
	LCD_Clear();
    2394:	0e 94 40 0c 	call	0x1880	; 0x1880 <LCD_Clear>
	
	Menu_MenuInit();
    2398:	0e 94 b2 35 	call	0x6b64	; 0x6b64 <Menu_MenuInit>
	
		
	
	
	sei();
    239c:	78 94       	sei
	
	delay_ms(30);
    239e:	8e e1       	ldi	r24, 0x1E	; 30
    23a0:	90 e0       	ldi	r25, 0x00	; 0
    23a2:	0e 94 f5 0e 	call	0x1dea	; 0x1dea <delay_ms>
    
}
    23a6:	08 95       	ret

000023a8 <Loop>:
	We are in this loop because the system is not calibrated.
	This is the minimum functionality.
*/
void Loop(void)
{
	RX_CopyLatestReceiverValues(); // update RX_Latest also IS_TXn_GOOD
    23a8:	0e 94 24 25 	call	0x4a48	; 0x4a48 <RX_CopyLatestReceiverValues>
	
	if (TCNT_X_snapshot2==0) TCNT_X_snapshot2 = TCNT2_X;
    23ac:	80 91 d6 05 	lds	r24, 0x05D6
    23b0:	90 91 d7 05 	lds	r25, 0x05D7
    23b4:	00 97       	sbiw	r24, 0x00	; 0
    23b6:	41 f4       	brne	.+16     	; 0x23c8 <Loop+0x20>
    23b8:	80 91 a9 05 	lds	r24, 0x05A9
    23bc:	90 91 aa 05 	lds	r25, 0x05AA
    23c0:	90 93 d7 05 	sts	0x05D7, r25
    23c4:	80 93 d6 05 	sts	0x05D6, r24
	if ( (TCNT2_X- TCNT_X_snapshot2) > LCD_RefreashRate )  
    23c8:	80 91 a9 05 	lds	r24, 0x05A9
    23cc:	90 91 aa 05 	lds	r25, 0x05AA
    23d0:	20 91 d6 05 	lds	r18, 0x05D6
    23d4:	30 91 d7 05 	lds	r19, 0x05D7
    23d8:	82 1b       	sub	r24, r18
    23da:	93 0b       	sbc	r25, r19
    23dc:	8b 30       	cpi	r24, 0x0B	; 11
    23de:	91 05       	cpc	r25, r1
    23e0:	30 f0       	brcs	.+12     	; 0x23ee <Loop+0x46>
	{
		Menu_MenuShow();	
    23e2:	0e 94 6f 35 	call	0x6ade	; 0x6ade <Menu_MenuShow>
		TCNT_X_snapshot2=0;
    23e6:	10 92 d7 05 	sts	0x05D7, r1
    23ea:	10 92 d6 05 	sts	0x05D6, r1
    23ee:	08 95       	ret

000023f0 <LoopESCCalibration>:
}

void LoopESCCalibration (void)
{
	
	Menu_LoadPage(PAGE_HOME_ESC_CALIBRATION);
    23f0:	83 e0       	ldi	r24, 0x03	; 3
    23f2:	0e 94 59 2c 	call	0x58b2	; 0x58b2 <Menu_LoadPage>
	while (1)
	{
		Loop();
    23f6:	0e 94 d4 11 	call	0x23a8	; 0x23a8 <Loop>
    23fa:	fd cf       	rjmp	.-6      	; 0x23f6 <LoopESCCalibration+0x6>

000023fc <LoopCalibration>:
// Never go to MainLoop "fly loop" unless Sensors & RX is calibrated.
// This loop to protect against any bug that might make the quad start or KB stick click
// as in this case crash is a must.
void LoopCalibration (void)
{
	menuEnabled[PAGE_STABILIZATION] =0;
    23fc:	10 92 b5 07 	sts	0x07B5, r1
	menuEnabled[PAGE_SELF_LEVELING] =0;
    2400:	10 92 b6 07 	sts	0x07B6, r1
	menuEnabled[PAGE_ALT_HOLD]		=0;
    2404:	10 92 b7 07 	sts	0x07B7, r1
	menuEnabled[PAGE_MISC_SETTING]  =0;
    2408:	10 92 b9 07 	sts	0x07B9, r1
	menuEnabled[PAGE_ESC_CALIBRATION]=0; // u cannot make ESC Calibration as sticks are not ready for testing.
    240c:	10 92 be 07 	sts	0x07BE, r1
		
	while (!(Config.IsCalibrated & CALIBRATED_SENSOR) || !(Config.IsCalibrated & CALIBRATED_Stick_SECONDARY))
    2410:	02 c0       	rjmp	.+4      	; 0x2416 <LoopCalibration+0x1a>
	{	
		Loop();
    2412:	0e 94 d4 11 	call	0x23a8	; 0x23a8 <Loop>
	menuEnabled[PAGE_SELF_LEVELING] =0;
	menuEnabled[PAGE_ALT_HOLD]		=0;
	menuEnabled[PAGE_MISC_SETTING]  =0;
	menuEnabled[PAGE_ESC_CALIBRATION]=0; // u cannot make ESC Calibration as sticks are not ready for testing.
		
	while (!(Config.IsCalibrated & CALIBRATED_SENSOR) || !(Config.IsCalibrated & CALIBRATED_Stick_SECONDARY))
    2416:	80 91 c6 06 	lds	r24, 0x06C6
    241a:	82 ff       	sbrs	r24, 2
    241c:	fa cf       	rjmp	.-12     	; 0x2412 <LoopCalibration+0x16>
    241e:	81 ff       	sbrs	r24, 1
    2420:	f8 cf       	rjmp	.-16     	; 0x2412 <LoopCalibration+0x16>
	{	
		Loop();
	}
}
    2422:	08 95       	ret

00002424 <HandleSticksForArming>:
// This function is never called if there is a calibration issue.
// called in true section of if (RX_Snapshot[RXChannel_THR] < STICKThrottle_ARMING) 
void HandleSticksForArming (void)
{
	
	if ((UIEnableStickCommands==false) || (ActiveRXIndex!=1) || (!IS_TX2_GOOD)) return ; // you cannot use Primary to Arm and Disarm
    2424:	80 91 d3 05 	lds	r24, 0x05D3
    2428:	88 23       	and	r24, r24
    242a:	09 f4       	brne	.+2      	; 0x242e <HandleSticksForArming+0xa>
    242c:	6c c1       	rjmp	.+728    	; 0x2706 <HandleSticksForArming+0x2e2>
    242e:	80 91 b8 05 	lds	r24, 0x05B8
    2432:	81 30       	cpi	r24, 0x01	; 1
    2434:	09 f0       	breq	.+2      	; 0x2438 <HandleSticksForArming+0x14>
    2436:	67 c1       	rjmp	.+718    	; 0x2706 <HandleSticksForArming+0x2e2>
    2438:	80 91 c9 07 	lds	r24, 0x07C9
    243c:	80 7f       	andi	r24, 0xF0	; 240
    243e:	09 f0       	breq	.+2      	; 0x2442 <HandleSticksForArming+0x1e>
    2440:	62 c1       	rjmp	.+708    	; 0x2706 <HandleSticksForArming+0x2e2>
	SystemErrorType = CLR_SYS_ERR_SIGNAL;
    2442:	80 91 b5 06 	lds	r24, 0x06B5
    2446:	8e 7f       	andi	r24, 0xFE	; 254
    2448:	80 93 b5 06 	sts	0x06B5, r24
	
	if (TCNT1_X_snapshot1==0)  TCNT1_X_snapshot1 = CurrentTCNT1_X; // start counting
    244c:	80 91 d4 05 	lds	r24, 0x05D4
    2450:	90 91 d5 05 	lds	r25, 0x05D5
    2454:	00 97       	sbiw	r24, 0x00	; 0
    2456:	41 f4       	brne	.+16     	; 0x2468 <HandleSticksForArming+0x44>
    2458:	80 91 48 06 	lds	r24, 0x0648
    245c:	90 91 49 06 	lds	r25, 0x0649
    2460:	90 93 d5 05 	sts	0x05D5, r25
    2464:	80 93 d4 05 	sts	0x05D4, r24
		
		// DisArm Check
		if (IsArmed == true) 
    2468:	80 91 96 07 	lds	r24, 0x0796
    246c:	81 30       	cpi	r24, 0x01	; 1
    246e:	09 f0       	breq	.+2      	; 0x2472 <HandleSticksForArming+0x4e>
    2470:	54 c0       	rjmp	.+168    	; 0x251a <HandleSticksForArming+0xf6>
		{
			if (RX_Latest[ActiveRXIndex][RXChannel_RUD] > STICK_LEFT)
    2472:	20 91 b8 05 	lds	r18, 0x05B8
    2476:	82 2f       	mov	r24, r18
    2478:	90 e0       	ldi	r25, 0x00	; 0
    247a:	fc 01       	movw	r30, r24
    247c:	ee 0f       	add	r30, r30
    247e:	ff 1f       	adc	r31, r31
    2480:	43 e0       	ldi	r20, 0x03	; 3
    2482:	88 0f       	add	r24, r24
    2484:	99 1f       	adc	r25, r25
    2486:	4a 95       	dec	r20
    2488:	e1 f7       	brne	.-8      	; 0x2482 <HandleSticksForArming+0x5e>
    248a:	e8 0f       	add	r30, r24
    248c:	f9 1f       	adc	r31, r25
    248e:	e0 51       	subi	r30, 0x10	; 16
    2490:	fa 4f       	sbci	r31, 0xFA	; 250
    2492:	84 81       	ldd	r24, Z+4	; 0x04
    2494:	95 81       	ldd	r25, Z+5	; 0x05
    2496:	21 e0       	ldi	r18, 0x01	; 1
    2498:	81 39       	cpi	r24, 0x91	; 145
    249a:	92 07       	cpc	r25, r18
    249c:	84 f0       	brlt	.+32     	; 0x24be <HandleSticksForArming+0x9a>
			{ // Check DisArming manually.
				bResetTCNR1_X  = false;
    249e:	10 92 43 06 	sts	0x0643, r1
				if ( (CurrentTCNT1_X - TCNT1_X_snapshot1) > STICKPOSITION_LONG_TIME )
    24a2:	80 91 48 06 	lds	r24, 0x0648
    24a6:	90 91 49 06 	lds	r25, 0x0649
    24aa:	20 91 d4 05 	lds	r18, 0x05D4
    24ae:	30 91 d5 05 	lds	r19, 0x05D5
    24b2:	82 1b       	sub	r24, r18
    24b4:	93 0b       	sbc	r25, r19
    24b6:	21 e0       	ldi	r18, 0x01	; 1
    24b8:	82 33       	cpi	r24, 0x32	; 50
    24ba:	92 07       	cpc	r25, r18
    24bc:	58 f5       	brcc	.+86     	; 0x2514 <HandleSticksForArming+0xf0>
					Disarm();
					return ;
				}
			}
			
			if (Config.AutoDisarm!=0)
    24be:	60 91 ca 06 	lds	r22, 0x06CA
    24c2:	66 23       	and	r22, r22
    24c4:	09 f4       	brne	.+2      	; 0x24c8 <HandleSticksForArming+0xa4>
    24c6:	1f c1       	rjmp	.+574    	; 0x2706 <HandleSticksForArming+0x2e2>
			{ // check auto disArm
				if (TCNT_X_snapshotAutoDisarm==0) TCNT_X_snapshotAutoDisarm = CurrentTCNT1_X;
    24c8:	80 91 09 06 	lds	r24, 0x0609
    24cc:	90 91 0a 06 	lds	r25, 0x060A
    24d0:	00 97       	sbiw	r24, 0x00	; 0
    24d2:	41 f4       	brne	.+16     	; 0x24e4 <HandleSticksForArming+0xc0>
    24d4:	80 91 48 06 	lds	r24, 0x0648
    24d8:	90 91 49 06 	lds	r25, 0x0649
    24dc:	90 93 0a 06 	sts	0x060A, r25
    24e0:	80 93 09 06 	sts	0x0609, r24
				if ((CurrentTCNT1_X - TCNT_X_snapshotAutoDisarm) > (DISARM_TIME * Config.AutoDisarm))
    24e4:	80 91 48 06 	lds	r24, 0x0648
    24e8:	90 91 49 06 	lds	r25, 0x0649
    24ec:	20 91 09 06 	lds	r18, 0x0609
    24f0:	30 91 0a 06 	lds	r19, 0x060A
    24f4:	82 1b       	sub	r24, r18
    24f6:	93 0b       	sbc	r25, r19
    24f8:	70 e0       	ldi	r23, 0x00	; 0
    24fa:	48 ee       	ldi	r20, 0xE8	; 232
    24fc:	53 e0       	ldi	r21, 0x03	; 3
    24fe:	64 9f       	mul	r22, r20
    2500:	90 01       	movw	r18, r0
    2502:	65 9f       	mul	r22, r21
    2504:	30 0d       	add	r19, r0
    2506:	74 9f       	mul	r23, r20
    2508:	30 0d       	add	r19, r0
    250a:	11 24       	eor	r1, r1
    250c:	28 17       	cp	r18, r24
    250e:	39 07       	cpc	r19, r25
    2510:	08 f0       	brcs	.+2      	; 0x2514 <HandleSticksForArming+0xf0>
    2512:	f9 c0       	rjmp	.+498    	; 0x2706 <HandleSticksForArming+0x2e2>
				{
					Disarm();
    2514:	0e 94 12 0f 	call	0x1e24	; 0x1e24 <Disarm>
					return ;
    2518:	08 95       	ret
				}
			}
			
		}			
		
		if (IsArmed == false) 
    251a:	88 23       	and	r24, r24
    251c:	09 f0       	breq	.+2      	; 0x2520 <HandleSticksForArming+0xfc>
    251e:	f3 c0       	rjmp	.+486    	; 0x2706 <HandleSticksForArming+0x2e2>
		{
			//int16_t Stick = (Config.RX_Mid[ActiveRXIndex][RXChannel_RUD] + RX_Latest[ActiveRXIndex][RXChannel_RUD] * RX_Div_Factor);
			if (RX_Latest[ActiveRXIndex][RXChannel_RUD]  < STICK_RIGHT)
    2520:	20 91 b8 05 	lds	r18, 0x05B8
    2524:	82 2f       	mov	r24, r18
    2526:	90 e0       	ldi	r25, 0x00	; 0
    2528:	fc 01       	movw	r30, r24
    252a:	ee 0f       	add	r30, r30
    252c:	ff 1f       	adc	r31, r31
    252e:	23 e0       	ldi	r18, 0x03	; 3
    2530:	88 0f       	add	r24, r24
    2532:	99 1f       	adc	r25, r25
    2534:	2a 95       	dec	r18
    2536:	e1 f7       	brne	.-8      	; 0x2530 <HandleSticksForArming+0x10c>
    2538:	e8 0f       	add	r30, r24
    253a:	f9 1f       	adc	r31, r25
    253c:	e0 51       	subi	r30, 0x10	; 16
    253e:	fa 4f       	sbci	r31, 0xFA	; 250
    2540:	84 81       	ldd	r24, Z+4	; 0x04
    2542:	95 81       	ldd	r25, Z+5	; 0x05
    2544:	2e ef       	ldi	r18, 0xFE	; 254
    2546:	80 37       	cpi	r24, 0x70	; 112
    2548:	92 07       	cpc	r25, r18
    254a:	fc f4       	brge	.+62     	; 0x258a <HandleSticksForArming+0x166>
			{	// Armin Check
				bResetTCNR1_X = false;
    254c:	10 92 43 06 	sts	0x0643, r1
				if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_LONG_TIME )
    2550:	80 91 48 06 	lds	r24, 0x0648
    2554:	90 91 49 06 	lds	r25, 0x0649
    2558:	20 91 d4 05 	lds	r18, 0x05D4
    255c:	30 91 d5 05 	lds	r19, 0x05D5
    2560:	82 1b       	sub	r24, r18
    2562:	93 0b       	sbc	r25, r19
    2564:	21 e0       	ldi	r18, 0x01	; 1
    2566:	82 33       	cpi	r24, 0x32	; 50
    2568:	92 07       	cpc	r25, r18
    256a:	78 f0       	brcs	.+30     	; 0x258a <HandleSticksForArming+0x166>
				{
					if ((Config.RX_mode==RX_mode_BuddyMode) && (!IS_TX1_GOOD)) return; 
    256c:	80 91 c7 06 	lds	r24, 0x06C7
    2570:	88 23       	and	r24, r24
    2572:	41 f4       	brne	.+16     	; 0x2584 <HandleSticksForArming+0x160>
    2574:	80 91 c9 07 	lds	r24, 0x07C9
    2578:	90 e0       	ldi	r25, 0x00	; 0
    257a:	8f 70       	andi	r24, 0x0F	; 15
    257c:	90 70       	andi	r25, 0x00	; 0
    257e:	00 97       	sbiw	r24, 0x00	; 0
    2580:	09 f0       	breq	.+2      	; 0x2584 <HandleSticksForArming+0x160>
    2582:	c1 c0       	rjmp	.+386    	; 0x2706 <HandleSticksForArming+0x2e2>
					// in Buddy mode you cannot arm is there is no signal from TX1
					
					Arm();
    2584:	0e 94 23 0f 	call	0x1e46	; 0x1e46 <Arm>
					return ;
    2588:	08 95       	ret
				}
			}					
		
			//set modes Quad , X-Quad
		
			if (RX_Latest[ActiveRXIndex][RXChannel_AIL]  > STICK_LEFT)
    258a:	20 91 b8 05 	lds	r18, 0x05B8
    258e:	82 2f       	mov	r24, r18
    2590:	90 e0       	ldi	r25, 0x00	; 0
    2592:	fc 01       	movw	r30, r24
    2594:	ee 0f       	add	r30, r30
    2596:	ff 1f       	adc	r31, r31
    2598:	a3 e0       	ldi	r26, 0x03	; 3
    259a:	88 0f       	add	r24, r24
    259c:	99 1f       	adc	r25, r25
    259e:	aa 95       	dec	r26
    25a0:	e1 f7       	brne	.-8      	; 0x259a <HandleSticksForArming+0x176>
    25a2:	e8 0f       	add	r30, r24
    25a4:	f9 1f       	adc	r31, r25
    25a6:	e0 51       	subi	r30, 0x10	; 16
    25a8:	fa 4f       	sbci	r31, 0xFA	; 250
    25aa:	80 81       	ld	r24, Z
    25ac:	91 81       	ldd	r25, Z+1	; 0x01
    25ae:	21 e0       	ldi	r18, 0x01	; 1
    25b0:	81 39       	cpi	r24, 0x91	; 145
    25b2:	92 07       	cpc	r25, r18
    25b4:	ac f0       	brlt	.+42     	; 0x25e0 <HandleSticksForArming+0x1bc>
			{// X-QUAD MODE
				bResetTCNR1_X = false;
    25b6:	10 92 43 06 	sts	0x0643, r1
				if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_LONG_TIME )
    25ba:	80 91 48 06 	lds	r24, 0x0648
    25be:	90 91 49 06 	lds	r25, 0x0649
    25c2:	20 91 d4 05 	lds	r18, 0x05D4
    25c6:	30 91 d5 05 	lds	r19, 0x05D5
    25ca:	82 1b       	sub	r24, r18
    25cc:	93 0b       	sbc	r25, r19
    25ce:	21 e0       	ldi	r18, 0x01	; 1
    25d0:	82 33       	cpi	r24, 0x32	; 50
    25d2:	92 07       	cpc	r25, r18
    25d4:	08 f4       	brcc	.+2      	; 0x25d8 <HandleSticksForArming+0x1b4>
    25d6:	97 c0       	rjmp	.+302    	; 0x2706 <HandleSticksForArming+0x2e2>
				{
					Config.QuadFlyingMode=QuadFlyingMode_X;
    25d8:	81 e0       	ldi	r24, 0x01	; 1
    25da:	80 93 ce 06 	sts	0x06CE, r24
    25de:	57 c0       	rjmp	.+174    	; 0x268e <HandleSticksForArming+0x26a>
					LED_FlashOrangeLED (LED_LONG_TOGGLE,8);
					TCNT1_X_snapshot1 =0; // reset timer
				}
			}			
			else if ((RX_Latest[ActiveRXIndex][RXChannel_AIL]  < STICK_RIGHT))
    25e0:	20 91 b8 05 	lds	r18, 0x05B8
    25e4:	82 2f       	mov	r24, r18
    25e6:	90 e0       	ldi	r25, 0x00	; 0
    25e8:	fc 01       	movw	r30, r24
    25ea:	ee 0f       	add	r30, r30
    25ec:	ff 1f       	adc	r31, r31
    25ee:	63 e0       	ldi	r22, 0x03	; 3
    25f0:	88 0f       	add	r24, r24
    25f2:	99 1f       	adc	r25, r25
    25f4:	6a 95       	dec	r22
    25f6:	e1 f7       	brne	.-8      	; 0x25f0 <HandleSticksForArming+0x1cc>
    25f8:	e8 0f       	add	r30, r24
    25fa:	f9 1f       	adc	r31, r25
    25fc:	e0 51       	subi	r30, 0x10	; 16
    25fe:	fa 4f       	sbci	r31, 0xFA	; 250
    2600:	80 81       	ld	r24, Z
    2602:	91 81       	ldd	r25, Z+1	; 0x01
    2604:	2e ef       	ldi	r18, 0xFE	; 254
    2606:	80 37       	cpi	r24, 0x70	; 112
    2608:	92 07       	cpc	r25, r18
    260a:	bc f4       	brge	.+46     	; 0x263a <HandleSticksForArming+0x216>
				{	// QUAD COPTER MODE
					bResetTCNR1_X = false;
    260c:	10 92 43 06 	sts	0x0643, r1
					if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_LONG_TIME )
    2610:	80 91 48 06 	lds	r24, 0x0648
    2614:	90 91 49 06 	lds	r25, 0x0649
    2618:	20 91 d4 05 	lds	r18, 0x05D4
    261c:	30 91 d5 05 	lds	r19, 0x05D5
    2620:	82 1b       	sub	r24, r18
    2622:	93 0b       	sbc	r25, r19
    2624:	21 e0       	ldi	r18, 0x01	; 1
    2626:	82 33       	cpi	r24, 0x32	; 50
    2628:	92 07       	cpc	r25, r18
    262a:	08 f4       	brcc	.+2      	; 0x262e <HandleSticksForArming+0x20a>
    262c:	6c c0       	rjmp	.+216    	; 0x2706 <HandleSticksForArming+0x2e2>
					{
						Config.QuadFlyingMode=QuadFlyingMode_PLUS;
    262e:	10 92 ce 06 	sts	0x06CE, r1
						LED_FlashOrangeLED (LED_LONG_TOGGLE,4);
    2632:	80 e5       	ldi	r24, 0x50	; 80
    2634:	90 e0       	ldi	r25, 0x00	; 0
    2636:	64 e0       	ldi	r22, 0x04	; 4
    2638:	2d c0       	rjmp	.+90     	; 0x2694 <HandleSticksForArming+0x270>
					}		
			
				} 
				
			// set mode ACRO , Leveling
			else if ((RX_Latest[ActiveRXIndex][RXChannel_ELE]  < STICK_RIGHT))
    263a:	20 91 b8 05 	lds	r18, 0x05B8
    263e:	82 2f       	mov	r24, r18
    2640:	90 e0       	ldi	r25, 0x00	; 0
    2642:	fc 01       	movw	r30, r24
    2644:	ee 0f       	add	r30, r30
    2646:	ff 1f       	adc	r31, r31
    2648:	43 e0       	ldi	r20, 0x03	; 3
    264a:	88 0f       	add	r24, r24
    264c:	99 1f       	adc	r25, r25
    264e:	4a 95       	dec	r20
    2650:	e1 f7       	brne	.-8      	; 0x264a <HandleSticksForArming+0x226>
    2652:	e8 0f       	add	r30, r24
    2654:	f9 1f       	adc	r31, r25
    2656:	e0 51       	subi	r30, 0x10	; 16
    2658:	fa 4f       	sbci	r31, 0xFA	; 250
    265a:	82 81       	ldd	r24, Z+2	; 0x02
    265c:	93 81       	ldd	r25, Z+3	; 0x03
    265e:	2e ef       	ldi	r18, 0xFE	; 254
    2660:	80 37       	cpi	r24, 0x70	; 112
    2662:	92 07       	cpc	r25, r18
    2664:	f4 f4       	brge	.+60     	; 0x26a2 <HandleSticksForArming+0x27e>
				{	//nFlyingModes = FLYINGMODE_LEVEL;
					bResetTCNR1_X = false;
    2666:	10 92 43 06 	sts	0x0643, r1
					if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_LONG_TIME )
    266a:	80 91 48 06 	lds	r24, 0x0648
    266e:	90 91 49 06 	lds	r25, 0x0649
    2672:	20 91 d4 05 	lds	r18, 0x05D4
    2676:	30 91 d5 05 	lds	r19, 0x05D5
    267a:	82 1b       	sub	r24, r18
    267c:	93 0b       	sbc	r25, r19
    267e:	21 e0       	ldi	r18, 0x01	; 1
    2680:	82 33       	cpi	r24, 0x32	; 50
    2682:	92 07       	cpc	r25, r18
    2684:	08 f4       	brcc	.+2      	; 0x2688 <HandleSticksForArming+0x264>
    2686:	3f c0       	rjmp	.+126    	; 0x2706 <HandleSticksForArming+0x2e2>
					{
						nFlyingModes = FLYINGMODE_LEVEL;
    2688:	82 e0       	ldi	r24, 0x02	; 2
    268a:	80 93 08 06 	sts	0x0608, r24
						LED_FlashOrangeLED (LED_LONG_TOGGLE,8);
    268e:	80 e5       	ldi	r24, 0x50	; 80
    2690:	90 e0       	ldi	r25, 0x00	; 0
    2692:	68 e0       	ldi	r22, 0x08	; 8
    2694:	0e 94 93 0e 	call	0x1d26	; 0x1d26 <LED_FlashOrangeLED>
						TCNT1_X_snapshot1 =0; // reset timer
    2698:	10 92 d5 05 	sts	0x05D5, r1
    269c:	10 92 d4 05 	sts	0x05D4, r1
    26a0:	08 95       	ret
					}		
			
				} 
			else if ((RX_Latest[ActiveRXIndex][RXChannel_ELE]  > STICK_LEFT))
    26a2:	20 91 b8 05 	lds	r18, 0x05B8
    26a6:	82 2f       	mov	r24, r18
    26a8:	90 e0       	ldi	r25, 0x00	; 0
    26aa:	fc 01       	movw	r30, r24
    26ac:	ee 0f       	add	r30, r30
    26ae:	ff 1f       	adc	r31, r31
    26b0:	23 e0       	ldi	r18, 0x03	; 3
    26b2:	88 0f       	add	r24, r24
    26b4:	99 1f       	adc	r25, r25
    26b6:	2a 95       	dec	r18
    26b8:	e1 f7       	brne	.-8      	; 0x26b2 <HandleSticksForArming+0x28e>
    26ba:	e8 0f       	add	r30, r24
    26bc:	f9 1f       	adc	r31, r25
    26be:	e0 51       	subi	r30, 0x10	; 16
    26c0:	fa 4f       	sbci	r31, 0xFA	; 250
    26c2:	82 81       	ldd	r24, Z+2	; 0x02
    26c4:	93 81       	ldd	r25, Z+3	; 0x03
    26c6:	21 e0       	ldi	r18, 0x01	; 1
    26c8:	81 39       	cpi	r24, 0x91	; 145
    26ca:	92 07       	cpc	r25, r18
    26cc:	e4 f0       	brlt	.+56     	; 0x2706 <HandleSticksForArming+0x2e2>
				{	//nFlyingModes = FLYINGMODE_ACRO;
					bResetTCNR1_X = false;
    26ce:	10 92 43 06 	sts	0x0643, r1
					if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_LONG_TIME )
    26d2:	80 91 48 06 	lds	r24, 0x0648
    26d6:	90 91 49 06 	lds	r25, 0x0649
    26da:	20 91 d4 05 	lds	r18, 0x05D4
    26de:	30 91 d5 05 	lds	r19, 0x05D5
    26e2:	82 1b       	sub	r24, r18
    26e4:	93 0b       	sbc	r25, r19
    26e6:	21 e0       	ldi	r18, 0x01	; 1
    26e8:	82 33       	cpi	r24, 0x32	; 50
    26ea:	92 07       	cpc	r25, r18
    26ec:	60 f0       	brcs	.+24     	; 0x2706 <HandleSticksForArming+0x2e2>
					{
						nFlyingModes = FLYINGMODE_ACRO;
    26ee:	81 e0       	ldi	r24, 0x01	; 1
    26f0:	80 93 08 06 	sts	0x0608, r24
						LED_FlashOrangeLED (LED_LONG_TOGGLE,4);
    26f4:	80 e5       	ldi	r24, 0x50	; 80
    26f6:	90 e0       	ldi	r25, 0x00	; 0
    26f8:	64 e0       	ldi	r22, 0x04	; 4
    26fa:	0e 94 93 0e 	call	0x1d26	; 0x1d26 <LED_FlashOrangeLED>
						TCNT1_X_snapshot1 =0; // reset timer
    26fe:	10 92 d5 05 	sts	0x05D5, r1
    2702:	10 92 d4 05 	sts	0x05D4, r1
    2706:	08 95       	ret

00002708 <HandleSticksAsKeys>:

// This function is never called if there is a calibration issue.
// called in FALSE section of if (RX_Snapshot[RXChannel_THR] < STICKThrottle_ARMING) 
void HandleSticksAsKeys (void)
{
		if ((UIEnableStickCommands==false) || (!IS_TX2_GOOD))  return ; // you cannot use Primary as keys
    2708:	80 91 d3 05 	lds	r24, 0x05D3
    270c:	88 23       	and	r24, r24
    270e:	09 f4       	brne	.+2      	; 0x2712 <HandleSticksAsKeys+0xa>
    2710:	87 c0       	rjmp	.+270    	; 0x2820 <HandleSticksAsKeys+0x118>
    2712:	80 91 c9 07 	lds	r24, 0x07C9
    2716:	80 7f       	andi	r24, 0xF0	; 240
    2718:	09 f0       	breq	.+2      	; 0x271c <HandleSticksAsKeys+0x14>
    271a:	82 c0       	rjmp	.+260    	; 0x2820 <HandleSticksAsKeys+0x118>

		// if Throttle is high and stick are calibrated
		
		if (TCNT1_X_snapshot1==0)  TCNT1_X_snapshot1 = CurrentTCNT1_X; // start counting
    271c:	80 91 d4 05 	lds	r24, 0x05D4
    2720:	90 91 d5 05 	lds	r25, 0x05D5
    2724:	00 97       	sbiw	r24, 0x00	; 0
    2726:	41 f4       	brne	.+16     	; 0x2738 <HandleSticksAsKeys+0x30>
    2728:	80 91 48 06 	lds	r24, 0x0648
    272c:	90 91 49 06 	lds	r25, 0x0649
    2730:	90 93 d5 05 	sts	0x05D5, r25
    2734:	80 93 d4 05 	sts	0x05D4, r24
				
	 	if ((RX_Latest[RX_MAIN][RXChannel_ELE]) > STICK_LEFT) 
    2738:	80 91 fc 05 	lds	r24, 0x05FC
    273c:	90 91 fd 05 	lds	r25, 0x05FD
    2740:	21 e0       	ldi	r18, 0x01	; 1
    2742:	81 39       	cpi	r24, 0x91	; 145
    2744:	92 07       	cpc	r25, r18
    2746:	8c f0       	brlt	.+34     	; 0x276a <HandleSticksAsKeys+0x62>
		{
			bResetTCNR1_X = false;
    2748:	10 92 43 06 	sts	0x0643, r1
			if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_SHORT_TIME )
    274c:	80 91 48 06 	lds	r24, 0x0648
    2750:	90 91 49 06 	lds	r25, 0x0649
    2754:	20 91 d4 05 	lds	r18, 0x05D4
    2758:	30 91 d5 05 	lds	r19, 0x05D5
    275c:	82 1b       	sub	r24, r18
    275e:	93 0b       	sbc	r25, r19
    2760:	81 35       	cpi	r24, 0x51	; 81
    2762:	91 05       	cpc	r25, r1
    2764:	00 f1       	brcs	.+64     	; 0x27a6 <HandleSticksAsKeys+0x9e>
			{
				_TXKeys = KEY_3;
    2766:	80 e2       	ldi	r24, 0x20	; 32
    2768:	18 c0       	rjmp	.+48     	; 0x279a <HandleSticksAsKeys+0x92>
				TCNT1_X_snapshot1 =0; // reset timer
			}		
		
		}
		else if ((RX_Latest[RX_MAIN][RXChannel_ELE]) < STICK_RIGHT) 
    276a:	80 91 fc 05 	lds	r24, 0x05FC
    276e:	90 91 fd 05 	lds	r25, 0x05FD
    2772:	2e ef       	ldi	r18, 0xFE	; 254
    2774:	80 37       	cpi	r24, 0x70	; 112
    2776:	92 07       	cpc	r25, r18
    2778:	b4 f4       	brge	.+44     	; 0x27a6 <HandleSticksAsKeys+0x9e>
		{
			bResetTCNR1_X = false;
    277a:	10 92 43 06 	sts	0x0643, r1
			if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_SHORT_TIME )
    277e:	80 91 48 06 	lds	r24, 0x0648
    2782:	90 91 49 06 	lds	r25, 0x0649
    2786:	20 91 d4 05 	lds	r18, 0x05D4
    278a:	30 91 d5 05 	lds	r19, 0x05D5
    278e:	82 1b       	sub	r24, r18
    2790:	93 0b       	sbc	r25, r19
    2792:	81 35       	cpi	r24, 0x51	; 81
    2794:	91 05       	cpc	r25, r1
    2796:	38 f0       	brcs	.+14     	; 0x27a6 <HandleSticksAsKeys+0x9e>
			{
				_TXKeys = KEY_2;
    2798:	80 e4       	ldi	r24, 0x40	; 64
    279a:	80 93 b4 06 	sts	0x06B4, r24
				TCNT1_X_snapshot1 =0; // reset timer
    279e:	10 92 d5 05 	sts	0x05D5, r1
    27a2:	10 92 d4 05 	sts	0x05D4, r1
			}		
		
		}		 	 
		
		if ((RX_Latest[RX_MAIN][RXChannel_AIL]) > STICK_LEFT) 
    27a6:	80 91 fa 05 	lds	r24, 0x05FA
    27aa:	90 91 fb 05 	lds	r25, 0x05FB
    27ae:	21 e0       	ldi	r18, 0x01	; 1
    27b0:	81 39       	cpi	r24, 0x91	; 145
    27b2:	92 07       	cpc	r25, r18
    27b4:	bc f0       	brlt	.+46     	; 0x27e4 <HandleSticksAsKeys+0xdc>
		{
			bResetTCNR1_X = false;
    27b6:	10 92 43 06 	sts	0x0643, r1
			if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_SHORT_TIME )
    27ba:	80 91 48 06 	lds	r24, 0x0648
    27be:	90 91 49 06 	lds	r25, 0x0649
    27c2:	20 91 d4 05 	lds	r18, 0x05D4
    27c6:	30 91 d5 05 	lds	r19, 0x05D5
    27ca:	82 1b       	sub	r24, r18
    27cc:	93 0b       	sbc	r25, r19
    27ce:	81 35       	cpi	r24, 0x51	; 81
    27d0:	91 05       	cpc	r25, r1
    27d2:	30 f1       	brcs	.+76     	; 0x2820 <HandleSticksAsKeys+0x118>
			{
				_TXKeys = KEY_4;
    27d4:	80 e1       	ldi	r24, 0x10	; 16
    27d6:	80 93 b4 06 	sts	0x06B4, r24
				TCNT1_X_snapshot1 =0; // reset timer
    27da:	10 92 d5 05 	sts	0x05D5, r1
    27de:	10 92 d4 05 	sts	0x05D4, r1
    27e2:	08 95       	ret
			}		
		
		}
		else if ((RX_Latest[RX_MAIN][RXChannel_AIL]) < STICK_RIGHT) 
    27e4:	80 91 fa 05 	lds	r24, 0x05FA
    27e8:	90 91 fb 05 	lds	r25, 0x05FB
    27ec:	2e ef       	ldi	r18, 0xFE	; 254
    27ee:	80 37       	cpi	r24, 0x70	; 112
    27f0:	92 07       	cpc	r25, r18
    27f2:	b4 f4       	brge	.+44     	; 0x2820 <HandleSticksAsKeys+0x118>
		{
			bResetTCNR1_X = false;
    27f4:	10 92 43 06 	sts	0x0643, r1
			if ( (CurrentTCNT1_X- TCNT1_X_snapshot1) > STICKPOSITION_SHORT_TIME )
    27f8:	80 91 48 06 	lds	r24, 0x0648
    27fc:	90 91 49 06 	lds	r25, 0x0649
    2800:	20 91 d4 05 	lds	r18, 0x05D4
    2804:	30 91 d5 05 	lds	r19, 0x05D5
    2808:	82 1b       	sub	r24, r18
    280a:	93 0b       	sbc	r25, r19
    280c:	81 35       	cpi	r24, 0x51	; 81
    280e:	91 05       	cpc	r25, r1
    2810:	38 f0       	brcs	.+14     	; 0x2820 <HandleSticksAsKeys+0x118>
			{
				_TXKeys = KEY_1;
    2812:	80 e8       	ldi	r24, 0x80	; 128
    2814:	80 93 b4 06 	sts	0x06B4, r24
				TCNT1_X_snapshot1 =0; // reset timer
    2818:	10 92 d5 05 	sts	0x05D5, r1
    281c:	10 92 d4 05 	sts	0x05D4, r1
    2820:	08 95       	ret

00002822 <ZEROMotors>:
/*
// STOPS MOTORS IMMEDIATLY
*/
void ZEROMotors()
{
	MotorOut[0] = 0;
    2822:	10 92 85 05 	sts	0x0585, r1
    2826:	10 92 84 05 	sts	0x0584, r1
	MotorOut[1] = 0;
    282a:	10 92 87 05 	sts	0x0587, r1
    282e:	10 92 86 05 	sts	0x0586, r1
	MotorOut[2] = 0;
    2832:	10 92 89 05 	sts	0x0589, r1
    2836:	10 92 88 05 	sts	0x0588, r1
	if (Config.FrameType == FRAMETYPE_TRICOPTER)
    283a:	80 91 cc 06 	lds	r24, 0x06CC
    283e:	82 30       	cpi	r24, 0x02	; 2
    2840:	39 f4       	brne	.+14     	; 0x2850 <ZEROMotors+0x2e>
	{
		MotorOut[3] = SERVO_IN_MIDDLE;
    2842:	86 e2       	ldi	r24, 0x26	; 38
    2844:	92 e0       	ldi	r25, 0x02	; 2
    2846:	90 93 8b 05 	sts	0x058B, r25
    284a:	80 93 8a 05 	sts	0x058A, r24
    284e:	04 c0       	rjmp	.+8      	; 0x2858 <ZEROMotors+0x36>
	}	
	else
	{
		MotorOut[3] = 0;
    2850:	10 92 8b 05 	sts	0x058B, r1
    2854:	10 92 8a 05 	sts	0x058A, r1
	}		
		
	Motor_GenerateOutputSignal();
    2858:	0e 94 76 22 	call	0x44ec	; 0x44ec <Motor_GenerateOutputSignal>
    285c:	08 95       	ret

0000285e <MainLoop>:
	This is the main loop of the application.
*/

static uint16_t LowpassOutYaw;
void MainLoop(void)
{
    285e:	8f 92       	push	r8
    2860:	9f 92       	push	r9
    2862:	af 92       	push	r10
    2864:	bf 92       	push	r11
    2866:	cf 92       	push	r12
    2868:	df 92       	push	r13
    286a:	ef 92       	push	r14
    286c:	ff 92       	push	r15
    286e:	0f 93       	push	r16
    2870:	1f 93       	push	r17
    2872:	cf 93       	push	r28
    2874:	df 93       	push	r29
	
	RX_CopyLatestReceiverValues();
    2876:	0e 94 24 25 	call	0x4a48	; 0x4a48 <RX_CopyLatestReceiverValues>
	//RX_Snapshot_1 [RXChannel_THR]= RX_Snapshot[RXChannel_THR];
	RX_Snapshot   [RXChannel_THR]= RX_Latest[ActiveRXIndex][RXChannel_THR];
    287a:	20 91 b8 05 	lds	r18, 0x05B8
    287e:	82 2f       	mov	r24, r18
    2880:	90 e0       	ldi	r25, 0x00	; 0
    2882:	fc 01       	movw	r30, r24
    2884:	ee 0f       	add	r30, r30
    2886:	ff 1f       	adc	r31, r31
    2888:	23 e0       	ldi	r18, 0x03	; 3
    288a:	88 0f       	add	r24, r24
    288c:	99 1f       	adc	r25, r25
    288e:	2a 95       	dec	r18
    2890:	e1 f7       	brne	.-8      	; 0x288a <MainLoop+0x2c>
    2892:	e8 0f       	add	r30, r24
    2894:	f9 1f       	adc	r31, r25
    2896:	e0 51       	subi	r30, 0x10	; 16
    2898:	fa 4f       	sbci	r31, 0xFA	; 250
    289a:	86 81       	ldd	r24, Z+6	; 0x06
    289c:	97 81       	ldd	r25, Z+7	; 0x07
    289e:	90 93 b3 05 	sts	0x05B3, r25
    28a2:	80 93 b2 05 	sts	0x05B2, r24
	Sensors_ReadAll();	
    28a6:	0e 94 94 27 	call	0x4f28	; 0x4f28 <Sensors_ReadAll>
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    28aa:	f8 94       	cli
	
	
	
	ATOMIC_BLOCK(ATOMIC_FORCEON)
    {
      CurrentTCNT1_X = TCNT1_X;
    28ac:	80 91 4e 06 	lds	r24, 0x064E
    28b0:	90 91 4f 06 	lds	r25, 0x064F
    28b4:	90 93 49 06 	sts	0x0649, r25
    28b8:	80 93 48 06 	sts	0x0648, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    28bc:	78 94       	sei
    }

	IMU();
    28be:	0e 94 88 1c 	call	0x3910	; 0x3910 <IMU>
 
	bResetTCNR1_X = true;
    28c2:	21 e0       	ldi	r18, 0x01	; 1
    28c4:	20 93 43 06 	sts	0x0643, r18
	
	
	if (Config.RX_mode==RX_mode_BuddyMode)
    28c8:	80 91 c7 06 	lds	r24, 0x06C7
    28cc:	88 23       	and	r24, r24
    28ce:	89 f4       	brne	.+34     	; 0x28f2 <MainLoop+0x94>
	{   // in Buddy mode AUX channel is used for instance switching.
		if (IS_TX2_GOOD)
    28d0:	80 91 c9 07 	lds	r24, 0x07C9
    28d4:	80 7f       	andi	r24, 0xF0	; 240
    28d6:	69 f4       	brne	.+26     	; 0x28f2 <MainLoop+0x94>
		{
			if (RX_Latest[RX_MAIN][RXChannel_AUX] < STICK_RIGHT)
    28d8:	80 91 02 06 	lds	r24, 0x0602
    28dc:	90 91 03 06 	lds	r25, 0x0603
    28e0:	3e ef       	ldi	r19, 0xFE	; 254
    28e2:	80 37       	cpi	r24, 0x70	; 112
    28e4:	93 07       	cpc	r25, r19
    28e6:	1c f4       	brge	.+6      	; 0x28ee <MainLoop+0x90>
			{
				ActiveRXIndex = 0;		// use Primary RX
    28e8:	10 92 b8 05 	sts	0x05B8, r1
    28ec:	02 c0       	rjmp	.+4      	; 0x28f2 <MainLoop+0x94>
			}
			else
			{
				ActiveRXIndex = 1;		// use Secondary RX
    28ee:	20 93 b8 05 	sts	0x05B8, r18
	
		
	////////// Slow Actions inside
	// HINT: you can try to skip this if flying to save time for more useful tasks as user cannot access menu when flying
	
	if (TCNT_X_snapshot2==0) TCNT_X_snapshot2 = CurrentTCNT1_X;
    28f2:	80 91 d6 05 	lds	r24, 0x05D6
    28f6:	90 91 d7 05 	lds	r25, 0x05D7
    28fa:	20 91 48 06 	lds	r18, 0x0648
    28fe:	30 91 49 06 	lds	r19, 0x0649
    2902:	00 97       	sbiw	r24, 0x00	; 0
    2904:	29 f4       	brne	.+10     	; 0x2910 <MainLoop+0xb2>
    2906:	30 93 d7 05 	sts	0x05D7, r19
    290a:	20 93 d6 05 	sts	0x05D6, r18
    290e:	6a c0       	rjmp	.+212    	; 0x29e4 <MainLoop+0x186>
	else if ( ((CurrentTCNT1_X- TCNT_X_snapshot2) > 4) )  // TCNT1_X ticks in 32.768us
    2910:	28 1b       	sub	r18, r24
    2912:	39 0b       	sbc	r19, r25
    2914:	25 30       	cpi	r18, 0x05	; 5
    2916:	31 05       	cpc	r19, r1
    2918:	08 f4       	brcc	.+2      	; 0x291c <MainLoop+0xbe>
    291a:	64 c0       	rjmp	.+200    	; 0x29e4 <MainLoop+0x186>
	{
		Menu_MenuShow();
    291c:	0e 94 6f 35 	call	0x6ade	; 0x6ade <Menu_MenuShow>
		
		if (Config.VoltageAlarm > 0)
    2920:	80 91 35 07 	lds	r24, 0x0735
    2924:	88 23       	and	r24, r24
    2926:	79 f0       	breq	.+30     	; 0x2946 <MainLoop+0xe8>
		{
			//Sensor_GetBattery();
			if (Sensors_Latest[V_BAT_Index] < Config.VoltageAlarm)
    2928:	20 91 35 06 	lds	r18, 0x0635
    292c:	30 91 36 06 	lds	r19, 0x0636
    2930:	90 e0       	ldi	r25, 0x00	; 0
    2932:	40 91 b5 06 	lds	r20, 0x06B5
    2936:	28 17       	cp	r18, r24
    2938:	39 07       	cpc	r19, r25
    293a:	14 f4       	brge	.+4      	; 0x2940 <MainLoop+0xe2>
			{
				
				SystemErrorType = SET_SYS_ERR_VOLTAGE;
    293c:	42 60       	ori	r20, 0x02	; 2
    293e:	01 c0       	rjmp	.+2      	; 0x2942 <MainLoop+0xe4>
			}
			else
			{
				SystemErrorType = CLR_SYS_ERR_VOLTAGE;
    2940:	4d 7f       	andi	r20, 0xFD	; 253
    2942:	40 93 b5 06 	sts	0x06B5, r20
				
			}
		}	
		if (SystemErrorType != SYS_ERR_NON)
    2946:	80 91 b5 06 	lds	r24, 0x06B5
    294a:	88 23       	and	r24, r24
    294c:	51 f0       	breq	.+20     	; 0x2962 <MainLoop+0x104>
		{
			Buzzer =~Buzzer ;	
    294e:	85 b1       	in	r24, 0x05	; 5
    2950:	86 95       	lsr	r24
    2952:	80 95       	com	r24
    2954:	81 70       	andi	r24, 0x01	; 1
    2956:	88 0f       	add	r24, r24
    2958:	95 b1       	in	r25, 0x05	; 5
    295a:	9d 7f       	andi	r25, 0xFD	; 253
    295c:	98 2b       	or	r25, r24
    295e:	95 b9       	out	0x05, r25	; 5
    2960:	01 c0       	rjmp	.+2      	; 0x2964 <MainLoop+0x106>
		}
		else
		{
			Buzzer = OFF;
    2962:	29 98       	cbi	0x05, 1	; 5
		}
		
		if (Config.RX_mode==RX_mode_UARTMode)
    2964:	80 91 c7 06 	lds	r24, 0x06C7
    2968:	8f 3f       	cpi	r24, 0xFF	; 255
    296a:	c1 f5       	brne	.+112    	; 0x29dc <MainLoop+0x17e>
		{
				if ((FlyingModesToggle != LOW) && ( RX_Latest[RX_MAIN][RXChannel_AUX] < STICK_RIGHT ))
    296c:	20 91 21 05 	lds	r18, 0x0521
    2970:	22 23       	and	r18, r18
    2972:	81 f0       	breq	.+32     	; 0x2994 <MainLoop+0x136>
    2974:	80 91 02 06 	lds	r24, 0x0602
    2978:	90 91 03 06 	lds	r25, 0x0603
    297c:	4e ef       	ldi	r20, 0xFE	; 254
    297e:	80 37       	cpi	r24, 0x70	; 112
    2980:	94 07       	cpc	r25, r20
    2982:	34 f4       	brge	.+12     	; 0x2990 <MainLoop+0x132>
				{
					nFlyingModes = FLYINGMODE_ALTHOLD;
    2984:	84 e0       	ldi	r24, 0x04	; 4
    2986:	80 93 08 06 	sts	0x0608, r24
					FlyingModesToggle = LOW;
    298a:	10 92 21 05 	sts	0x0521, r1
    298e:	26 c0       	rjmp	.+76     	; 0x29dc <MainLoop+0x17e>
				} else
				if ((FlyingModesToggle != HIGH) && (RX_Latest[RX_MAIN][RXChannel_AUX] > STICK_LEFT ))
    2990:	21 30       	cpi	r18, 0x01	; 1
    2992:	71 f0       	breq	.+28     	; 0x29b0 <MainLoop+0x152>
    2994:	80 91 02 06 	lds	r24, 0x0602
    2998:	90 91 03 06 	lds	r25, 0x0603
    299c:	51 e0       	ldi	r21, 0x01	; 1
    299e:	81 39       	cpi	r24, 0x91	; 145
    29a0:	95 07       	cpc	r25, r21
    29a2:	24 f0       	brlt	.+8      	; 0x29ac <MainLoop+0x14e>
				{
					//LED_Orange=ON;
					nFlyingModes = FLYINGMODE_ACRO;
    29a4:	81 e0       	ldi	r24, 0x01	; 1
    29a6:	80 93 08 06 	sts	0x0608, r24
    29aa:	16 c0       	rjmp	.+44     	; 0x29d8 <MainLoop+0x17a>
					FlyingModesToggle = HIGH;
				} else
				if ((FlyingModesToggle != MID) && (RX_Latest[RX_MAIN][RXChannel_AUX]< STICK_LEFT) && ( RX_Latest[RX_MAIN][RXChannel_AUX] > STICK_RIGHT ))
    29ac:	2b 30       	cpi	r18, 0x0B	; 11
    29ae:	b1 f0       	breq	.+44     	; 0x29dc <MainLoop+0x17e>
    29b0:	80 91 02 06 	lds	r24, 0x0602
    29b4:	90 91 03 06 	lds	r25, 0x0603
    29b8:	21 e0       	ldi	r18, 0x01	; 1
    29ba:	80 39       	cpi	r24, 0x90	; 144
    29bc:	92 07       	cpc	r25, r18
    29be:	74 f4       	brge	.+28     	; 0x29dc <MainLoop+0x17e>
    29c0:	80 91 02 06 	lds	r24, 0x0602
    29c4:	90 91 03 06 	lds	r25, 0x0603
    29c8:	3e ef       	ldi	r19, 0xFE	; 254
    29ca:	81 37       	cpi	r24, 0x71	; 113
    29cc:	93 07       	cpc	r25, r19
    29ce:	34 f0       	brlt	.+12     	; 0x29dc <MainLoop+0x17e>
				{
					nFlyingModes = FLYINGMODE_LEVEL;
    29d0:	82 e0       	ldi	r24, 0x02	; 2
    29d2:	80 93 08 06 	sts	0x0608, r24
					FlyingModesToggle = MID;
    29d6:	8b e0       	ldi	r24, 0x0B	; 11
    29d8:	80 93 21 05 	sts	0x0521, r24
		}		
		//if ((IsArmed == true) && (RX_Snapshot[RXChannel_THR] < STICKThrottle_ARMING+160))
		//{ // calibrate when start flying
			//DynamicCalibration();
		//}			
		TCNT_X_snapshot2=0;
    29dc:	10 92 d7 05 	sts	0x05D7, r1
    29e0:	10 92 d6 05 	sts	0x05D6, r1
	}		
	
	//////////////// EOF Slow Loop
	
	if (RX_Snapshot[RXChannel_THR] < STICKThrottle_ARMING) 
    29e4:	c0 91 b2 05 	lds	r28, 0x05B2
    29e8:	d0 91 b3 05 	lds	r29, 0x05B3
    29ec:	c2 33       	cpi	r28, 0x32	; 50
    29ee:	d1 05       	cpc	r29, r1
    29f0:	2c f4       	brge	.+10     	; 0x29fc <MainLoop+0x19e>
	{	
		
		// Throttle is LOW
		// Here you can add code without caring about delays. As there quad is already off and on land.
		// here we test different positions of sticks to enable arm/disarm, Quad/X-Quad
		HandleSticksForArming();
    29f2:	0e 94 12 12 	call	0x2424	; 0x2424 <HandleSticksForArming>
		
		// Stop motors if Throttle Stick is less than minimum.
		ZEROMotors();
    29f6:	0e 94 11 14 	call	0x2822	; 0x2822 <ZEROMotors>
    29fa:	6b c3       	rjmp	.+1750   	; 0x30d2 <MainLoop+0x874>
		// DEBUG ONLY //IMU_Reset(); // reset angles for gyro [STABLE MODE]
	}
	else
	{	// Throttle stick is NOT Down .... TAKE CARE
		
		if (IsArmed==false)
    29fc:	80 91 96 07 	lds	r24, 0x0796
    2a00:	88 23       	and	r24, r24
    2a02:	29 f4       	brne	.+10     	; 0x2a0e <MainLoop+0x1b0>
		{  // However we are still DisArmed
			ZEROMotors();
    2a04:	0e 94 11 14 	call	0x2822	; 0x2822 <ZEROMotors>
			
			// Sticks as Keyboard --- we are already disarmed to reach here.
			HandleSticksAsKeys();
    2a08:	0e 94 84 13 	call	0x2708	; 0x2708 <HandleSticksAsKeys>
    2a0c:	62 c3       	rjmp	.+1732   	; 0x30d2 <MainLoop+0x874>
		}
		else
		{	// MOTORS ARE ON HERE .... DANGEROUS
			
			
			TCNT_X_snapshotAutoDisarm = 0; // ZERO [user may disarm then fly slowly..in this case the qud will disarm once he turned off the stick...because the counter counts once the quad is armed..e.g. if it takes n sec to disarm automatically..user took n-1 sec keeping the stick low after arming then it will take 1 sec to disarm again after lowing the stick under STICKThrottle_ARMING
    2a0e:	10 92 0a 06 	sts	0x060A, r1
    2a12:	10 92 09 06 	sts	0x0609, r1
			
			// Armed & Throttle Stick > MIN . . . We should Fly now.
			//RX_Snapshot_1 [RXChannel_AIL]= RX_Snapshot[RXChannel_AIL];
			//RX_Snapshot_1 [RXChannel_ELE]= RX_Snapshot[RXChannel_ELE];
			//RX_Snapshot_1 [RXChannel_RUD]= RX_Snapshot[RXChannel_RUD];
			RX_Snapshot	  [RXChannel_AIL] = (RX_Latest[ActiveRXIndex][RXChannel_AIL] * Config.StickScaling * 0.05 );
    2a16:	20 91 b8 05 	lds	r18, 0x05B8
    2a1a:	82 2f       	mov	r24, r18
    2a1c:	90 e0       	ldi	r25, 0x00	; 0
    2a1e:	fc 01       	movw	r30, r24
    2a20:	ee 0f       	add	r30, r30
    2a22:	ff 1f       	adc	r31, r31
    2a24:	13 e0       	ldi	r17, 0x03	; 3
    2a26:	88 0f       	add	r24, r24
    2a28:	99 1f       	adc	r25, r25
    2a2a:	1a 95       	dec	r17
    2a2c:	e1 f7       	brne	.-8      	; 0x2a26 <MainLoop+0x1c8>
    2a2e:	e8 0f       	add	r30, r24
    2a30:	f9 1f       	adc	r31, r25
    2a32:	e0 51       	subi	r30, 0x10	; 16
    2a34:	fa 4f       	sbci	r31, 0xFA	; 250
    2a36:	80 81       	ld	r24, Z
    2a38:	91 81       	ldd	r25, Z+1	; 0x01
    2a3a:	e0 90 d1 06 	lds	r14, 0x06D1
    2a3e:	ff 24       	eor	r15, r15
    2a40:	e8 9e       	mul	r14, r24
    2a42:	b0 01       	movw	r22, r0
    2a44:	e9 9e       	mul	r14, r25
    2a46:	70 0d       	add	r23, r0
    2a48:	f8 9e       	mul	r15, r24
    2a4a:	70 0d       	add	r23, r0
    2a4c:	11 24       	eor	r1, r1
    2a4e:	88 27       	eor	r24, r24
    2a50:	77 fd       	sbrc	r23, 7
    2a52:	80 95       	com	r24
    2a54:	98 2f       	mov	r25, r24
    2a56:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    2a5a:	2d ec       	ldi	r18, 0xCD	; 205
    2a5c:	3c ec       	ldi	r19, 0xCC	; 204
    2a5e:	4c e4       	ldi	r20, 0x4C	; 76
    2a60:	5d e3       	ldi	r21, 0x3D	; 61
    2a62:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    2a66:	0e 94 96 36 	call	0x6d2c	; 0x6d2c <__fixsfsi>
    2a6a:	70 93 ad 05 	sts	0x05AD, r23
    2a6e:	60 93 ac 05 	sts	0x05AC, r22
			RX_Snapshot   [RXChannel_ELE] = (RX_Latest[ActiveRXIndex][RXChannel_ELE] * Config.StickScaling * 0.05 ); 
    2a72:	20 91 b8 05 	lds	r18, 0x05B8
    2a76:	82 2f       	mov	r24, r18
    2a78:	90 e0       	ldi	r25, 0x00	; 0
    2a7a:	fc 01       	movw	r30, r24
    2a7c:	ee 0f       	add	r30, r30
    2a7e:	ff 1f       	adc	r31, r31
    2a80:	a3 e0       	ldi	r26, 0x03	; 3
    2a82:	88 0f       	add	r24, r24
    2a84:	99 1f       	adc	r25, r25
    2a86:	aa 95       	dec	r26
    2a88:	e1 f7       	brne	.-8      	; 0x2a82 <MainLoop+0x224>
    2a8a:	e8 0f       	add	r30, r24
    2a8c:	f9 1f       	adc	r31, r25
    2a8e:	e0 51       	subi	r30, 0x10	; 16
    2a90:	fa 4f       	sbci	r31, 0xFA	; 250
    2a92:	82 81       	ldd	r24, Z+2	; 0x02
    2a94:	93 81       	ldd	r25, Z+3	; 0x03
    2a96:	e8 9e       	mul	r14, r24
    2a98:	b0 01       	movw	r22, r0
    2a9a:	e9 9e       	mul	r14, r25
    2a9c:	70 0d       	add	r23, r0
    2a9e:	f8 9e       	mul	r15, r24
    2aa0:	70 0d       	add	r23, r0
    2aa2:	11 24       	eor	r1, r1
    2aa4:	88 27       	eor	r24, r24
    2aa6:	77 fd       	sbrc	r23, 7
    2aa8:	80 95       	com	r24
    2aaa:	98 2f       	mov	r25, r24
    2aac:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    2ab0:	2d ec       	ldi	r18, 0xCD	; 205
    2ab2:	3c ec       	ldi	r19, 0xCC	; 204
    2ab4:	4c e4       	ldi	r20, 0x4C	; 76
    2ab6:	5d e3       	ldi	r21, 0x3D	; 61
    2ab8:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    2abc:	0e 94 96 36 	call	0x6d2c	; 0x6d2c <__fixsfsi>
    2ac0:	70 93 af 05 	sts	0x05AF, r23
    2ac4:	60 93 ae 05 	sts	0x05AE, r22
			RX_Snapshot   [RXChannel_RUD] = (RX_Latest[ActiveRXIndex][RXChannel_RUD] * Config.StickScaling * 0.05 ); // version 0.9.9 
    2ac8:	20 91 b8 05 	lds	r18, 0x05B8
    2acc:	82 2f       	mov	r24, r18
    2ace:	90 e0       	ldi	r25, 0x00	; 0
    2ad0:	fc 01       	movw	r30, r24
    2ad2:	ee 0f       	add	r30, r30
    2ad4:	ff 1f       	adc	r31, r31
    2ad6:	63 e0       	ldi	r22, 0x03	; 3
    2ad8:	88 0f       	add	r24, r24
    2ada:	99 1f       	adc	r25, r25
    2adc:	6a 95       	dec	r22
    2ade:	e1 f7       	brne	.-8      	; 0x2ad8 <MainLoop+0x27a>
    2ae0:	e8 0f       	add	r30, r24
    2ae2:	f9 1f       	adc	r31, r25
    2ae4:	e0 51       	subi	r30, 0x10	; 16
    2ae6:	fa 4f       	sbci	r31, 0xFA	; 250
    2ae8:	84 81       	ldd	r24, Z+4	; 0x04
    2aea:	95 81       	ldd	r25, Z+5	; 0x05
    2aec:	e8 9e       	mul	r14, r24
    2aee:	b0 01       	movw	r22, r0
    2af0:	e9 9e       	mul	r14, r25
    2af2:	70 0d       	add	r23, r0
    2af4:	f8 9e       	mul	r15, r24
    2af6:	70 0d       	add	r23, r0
    2af8:	11 24       	eor	r1, r1
    2afa:	88 27       	eor	r24, r24
    2afc:	77 fd       	sbrc	r23, 7
    2afe:	80 95       	com	r24
    2b00:	98 2f       	mov	r25, r24
    2b02:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    2b06:	2d ec       	ldi	r18, 0xCD	; 205
    2b08:	3c ec       	ldi	r19, 0xCC	; 204
    2b0a:	4c e4       	ldi	r20, 0x4C	; 76
    2b0c:	5d e3       	ldi	r21, 0x3D	; 61
    2b0e:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    2b12:	0e 94 96 36 	call	0x6d2c	; 0x6d2c <__fixsfsi>
    2b16:	70 93 b1 05 	sts	0x05B1, r23
    2b1a:	60 93 b0 05 	sts	0x05B0, r22
		
			
			// Add Throttle to Motors
			MotorOut[0] = RX_Snapshot[RXChannel_THR];
			MotorOut[1] = RX_Snapshot[RXChannel_THR];
			if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    2b1e:	80 91 cc 06 	lds	r24, 0x06CC
    2b22:	81 30       	cpi	r24, 0x01	; 1
    2b24:	71 f4       	brne	.+28     	; 0x2b42 <MainLoop+0x2e4>
				* The logic below depends on board orientation i.e. sensor orientation compared to motor directions.
				* the IMU in ACHRO mode is totally independent from user sticks ... so it does not matter how the user
				* flies his quad i.e. in X or PLUS .... it does not matter because it is handled in another code lines not here.
				* here we handle board orientation only.
				*/
				if (Config.BoardOrientationMode==QuadFlyingMode_X)
    2b26:	40 91 cd 06 	lds	r20, 0x06CD
    2b2a:	80 91 23 06 	lds	r24, 0x0623
    2b2e:	90 91 24 06 	lds	r25, 0x0624
    2b32:	20 91 a4 05 	lds	r18, 0x05A4
    2b36:	30 91 a5 05 	lds	r19, 0x05A5
    2b3a:	41 30       	cpi	r20, 0x01	; 1
    2b3c:	09 f0       	breq	.+2      	; 0x2b40 <MainLoop+0x2e2>
    2b3e:	57 c0       	rjmp	.+174    	; 0x2bee <MainLoop+0x390>
    2b40:	34 c0       	rjmp	.+104    	; 0x2baa <MainLoop+0x34c>
			}
			else
			{	// Balance Tri-Copter
				// NOT VALID if Board Orientation is X
					
				MotorOut[2] += gyroPitch; // * 1.0;
    2b42:	60 91 23 06 	lds	r22, 0x0623
    2b46:	70 91 24 06 	lds	r23, 0x0624
    2b4a:	cb 01       	movw	r24, r22
    2b4c:	8c 0f       	add	r24, r28
    2b4e:	9d 1f       	adc	r25, r29
    2b50:	90 93 89 05 	sts	0x0589, r25
    2b54:	80 93 88 05 	sts	0x0588, r24
					
				gyroPitch    = gyroPitch * 0.5; // distribute pitch on two front motors .... half the effect. 
    2b58:	88 27       	eor	r24, r24
    2b5a:	77 fd       	sbrc	r23, 7
    2b5c:	80 95       	com	r24
    2b5e:	98 2f       	mov	r25, r24
    2b60:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    2b64:	20 e0       	ldi	r18, 0x00	; 0
    2b66:	30 e0       	ldi	r19, 0x00	; 0
    2b68:	40 e0       	ldi	r20, 0x00	; 0
    2b6a:	5f e3       	ldi	r21, 0x3F	; 63
    2b6c:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    2b70:	0e 94 96 36 	call	0x6d2c	; 0x6d2c <__fixsfsi>
    2b74:	9b 01       	movw	r18, r22
    2b76:	70 93 24 06 	sts	0x0624, r23
    2b7a:	60 93 23 06 	sts	0x0623, r22
				MotorOut[0] -= gyroPitch  ;
				MotorOut[1] -= gyroPitch  ;
					
				gyroRoll = gyroRoll; // * 0.85;
    2b7e:	40 91 a4 05 	lds	r20, 0x05A4
    2b82:	50 91 a5 05 	lds	r21, 0x05A5
				// NOT VALID if Board Orientation is X
					
				MotorOut[2] += gyroPitch; // * 1.0;
					
				gyroPitch    = gyroPitch * 0.5; // distribute pitch on two front motors .... half the effect. 
				MotorOut[0] -= gyroPitch  ;
    2b86:	ce 01       	movw	r24, r28
    2b88:	82 1b       	sub	r24, r18
    2b8a:	93 0b       	sbc	r25, r19
				MotorOut[1] -= gyroPitch  ;
					
				gyroRoll = gyroRoll; // * 0.85;
				MotorOut[0] -= gyroRoll  ;
    2b8c:	84 1b       	sub	r24, r20
    2b8e:	95 0b       	sbc	r25, r21
    2b90:	90 93 85 05 	sts	0x0585, r25
    2b94:	80 93 84 05 	sts	0x0584, r24
					
				MotorOut[2] += gyroPitch; // * 1.0;
					
				gyroPitch    = gyroPitch * 0.5; // distribute pitch on two front motors .... half the effect. 
				MotorOut[0] -= gyroPitch  ;
				MotorOut[1] -= gyroPitch  ;
    2b98:	c4 0f       	add	r28, r20
    2b9a:	d5 1f       	adc	r29, r21
					
				gyroRoll = gyroRoll; // * 0.85;
				MotorOut[0] -= gyroRoll  ;
				MotorOut[1] += gyroRoll  ;
    2b9c:	c2 1b       	sub	r28, r18
    2b9e:	d3 0b       	sbc	r29, r19
    2ba0:	d0 93 87 05 	sts	0x0587, r29
    2ba4:	c0 93 86 05 	sts	0x0586, r28
    2ba8:	3d c0       	rjmp	.+122    	; 0x2c24 <MainLoop+0x3c6>
				if (Config.BoardOrientationMode==QuadFlyingMode_X)
				{	// Board Orientation in X-Mode
					// {-1,1,1,-1} QUAD_ROL_X
					MotorOut[0] -= gyroRoll ;
					MotorOut[3] -= gyroRoll ;
					MotorOut[1] += gyroRoll ;
    2baa:	b9 01       	movw	r22, r18
    2bac:	6c 0f       	add	r22, r28
    2bae:	7d 1f       	adc	r23, r29
				* here we handle board orientation only.
				*/
				if (Config.BoardOrientationMode==QuadFlyingMode_X)
				{	// Board Orientation in X-Mode
					// {-1,1,1,-1} QUAD_ROL_X
					MotorOut[0] -= gyroRoll ;
    2bb0:	ae 01       	movw	r20, r28
    2bb2:	42 1b       	sub	r20, r18
    2bb4:	53 0b       	sbc	r21, r19
					MotorOut[3] -= gyroRoll ;
					MotorOut[1] += gyroRoll ;
					MotorOut[2] += gyroRoll ;
					
					// {-1,-1,1,1} QUAD_AIL_X
					MotorOut[0] -= gyroPitch;
    2bb6:	48 1b       	sub	r20, r24
    2bb8:	59 0b       	sbc	r21, r25
    2bba:	50 93 85 05 	sts	0x0585, r21
    2bbe:	40 93 84 05 	sts	0x0584, r20
					MotorOut[1] -= gyroPitch;
    2bc2:	ab 01       	movw	r20, r22
    2bc4:	48 1b       	sub	r20, r24
    2bc6:	59 0b       	sbc	r21, r25
    2bc8:	50 93 87 05 	sts	0x0587, r21
    2bcc:	40 93 86 05 	sts	0x0586, r20
					MotorOut[2] += gyroPitch;
    2bd0:	68 0f       	add	r22, r24
    2bd2:	79 1f       	adc	r23, r25
    2bd4:	70 93 89 05 	sts	0x0589, r23
    2bd8:	60 93 88 05 	sts	0x0588, r22
				*/
				if (Config.BoardOrientationMode==QuadFlyingMode_X)
				{	// Board Orientation in X-Mode
					// {-1,1,1,-1} QUAD_ROL_X
					MotorOut[0] -= gyroRoll ;
					MotorOut[3] -= gyroRoll ;
    2bdc:	c8 0f       	add	r28, r24
    2bde:	d9 1f       	adc	r29, r25
					
					// {-1,-1,1,1} QUAD_AIL_X
					MotorOut[0] -= gyroPitch;
					MotorOut[1] -= gyroPitch;
					MotorOut[2] += gyroPitch;
					MotorOut[3] += gyroPitch;
    2be0:	c2 1b       	sub	r28, r18
    2be2:	d3 0b       	sbc	r29, r19
    2be4:	d0 93 8b 05 	sts	0x058B, r29
    2be8:	c0 93 8a 05 	sts	0x058A, r28
    2bec:	1b c0       	rjmp	.+54     	; 0x2c24 <MainLoop+0x3c6>
					
				}
				else
				{	// Board Orientation in Plus-Mode
					// {0,1,0,-1} QUAD_ROL_PLUS
					MotorOut[1] += gyroRoll  ;
    2bee:	a9 01       	movw	r20, r18
    2bf0:	4c 0f       	add	r20, r28
    2bf2:	5d 1f       	adc	r21, r29
    2bf4:	50 93 87 05 	sts	0x0587, r21
    2bf8:	40 93 86 05 	sts	0x0586, r20
					MotorOut[3] -= gyroRoll  ;
    2bfc:	ae 01       	movw	r20, r28
    2bfe:	42 1b       	sub	r20, r18
    2c00:	53 0b       	sbc	r21, r19
    2c02:	50 93 8b 05 	sts	0x058B, r21
    2c06:	40 93 8a 05 	sts	0x058A, r20
				
					// {-1,0,1,0} QUAD_AIL_PLUS
					MotorOut[0] -= gyroPitch ;
    2c0a:	9e 01       	movw	r18, r28
    2c0c:	28 1b       	sub	r18, r24
    2c0e:	39 0b       	sbc	r19, r25
    2c10:	30 93 85 05 	sts	0x0585, r19
    2c14:	20 93 84 05 	sts	0x0584, r18
					MotorOut[2] += gyroPitch ; 
    2c18:	c8 0f       	add	r28, r24
    2c1a:	d9 1f       	adc	r29, r25
    2c1c:	d0 93 89 05 	sts	0x0589, r29
    2c20:	c0 93 88 05 	sts	0x0588, r28
			*
			*	Pilot Control Logic.
			*	Handles signals from remote control in ACRO mode.
			*	in stabilization mode controls are added in IMU logic as angles.
			*/
			if (nFlyingModes == FLYINGMODE_ACRO)
    2c24:	80 91 08 06 	lds	r24, 0x0608
    2c28:	81 30       	cpi	r24, 0x01	; 1
    2c2a:	09 f0       	breq	.+2      	; 0x2c2e <MainLoop+0x3d0>
    2c2c:	2e c1       	rjmp	.+604    	; 0x2e8a <MainLoop+0x62c>
			{
				if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    2c2e:	90 91 cc 06 	lds	r25, 0x06CC
    2c32:	80 91 ce 06 	lds	r24, 0x06CE
    2c36:	91 30       	cpi	r25, 0x01	; 1
    2c38:	09 f0       	breq	.+2      	; 0x2c3c <MainLoop+0x3de>
    2c3a:	a3 c0       	rjmp	.+326    	; 0x2d82 <MainLoop+0x524>
    2c3c:	60 91 ac 05 	lds	r22, 0x05AC
    2c40:	70 91 ad 05 	lds	r23, 0x05AD
    2c44:	e0 90 ae 05 	lds	r14, 0x05AE
    2c48:	f0 90 af 05 	lds	r15, 0x05AF
    2c4c:	80 90 8a 05 	lds	r8, 0x058A
    2c50:	90 90 8b 05 	lds	r9, 0x058B
    2c54:	a0 90 86 05 	lds	r10, 0x0586
    2c58:	b0 90 87 05 	lds	r11, 0x0587
    2c5c:	c0 90 88 05 	lds	r12, 0x0588
    2c60:	d0 90 89 05 	lds	r13, 0x0589
    2c64:	00 91 84 05 	lds	r16, 0x0584
    2c68:	10 91 85 05 	lds	r17, 0x0585
				{
				
					if (Config.QuadFlyingMode==QuadFlyingMode_X)
    2c6c:	81 30       	cpi	r24, 0x01	; 1
    2c6e:	09 f0       	breq	.+2      	; 0x2c72 <MainLoop+0x414>
    2c70:	49 c0       	rjmp	.+146    	; 0x2d04 <MainLoop+0x4a6>
					{
						RX_Snapshot[RXChannel_AIL] = RX_Snapshot[RXChannel_AIL] * 0.63;		// because we fly X
    2c72:	88 27       	eor	r24, r24
    2c74:	77 fd       	sbrc	r23, 7
    2c76:	80 95       	com	r24
    2c78:	98 2f       	mov	r25, r24
    2c7a:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    2c7e:	2e ea       	ldi	r18, 0xAE	; 174
    2c80:	37 e4       	ldi	r19, 0x47	; 71
    2c82:	41 e2       	ldi	r20, 0x21	; 33
    2c84:	5f e3       	ldi	r21, 0x3F	; 63
    2c86:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    2c8a:	0e 94 96 36 	call	0x6d2c	; 0x6d2c <__fixsfsi>
    2c8e:	eb 01       	movw	r28, r22
    2c90:	70 93 ad 05 	sts	0x05AD, r23
    2c94:	60 93 ac 05 	sts	0x05AC, r22
						RX_Snapshot[RXChannel_ELE] = RX_Snapshot[RXChannel_ELE] * 0.63;
    2c98:	b7 01       	movw	r22, r14
    2c9a:	88 27       	eor	r24, r24
    2c9c:	77 fd       	sbrc	r23, 7
    2c9e:	80 95       	com	r24
    2ca0:	98 2f       	mov	r25, r24
    2ca2:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    2ca6:	2e ea       	ldi	r18, 0xAE	; 174
    2ca8:	37 e4       	ldi	r19, 0x47	; 71
    2caa:	41 e2       	ldi	r20, 0x21	; 33
    2cac:	5f e3       	ldi	r21, 0x3F	; 63
    2cae:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    2cb2:	0e 94 96 36 	call	0x6d2c	; 0x6d2c <__fixsfsi>
    2cb6:	9b 01       	movw	r18, r22
    2cb8:	70 93 af 05 	sts	0x05AF, r23
    2cbc:	60 93 ae 05 	sts	0x05AE, r22
					
						// {0.63,-0.63,-0.63,0.63} QUAD_AIL_X
						MotorOut[0] += RX_Snapshot[RXChannel_AIL] ;
						MotorOut[3] += RX_Snapshot[RXChannel_AIL] ;
    2cc0:	8c 0e       	add	r8, r28
    2cc2:	9d 1e       	adc	r9, r29
						MotorOut[1] -= RX_Snapshot[RXChannel_AIL] ;
						MotorOut[2] -= RX_Snapshot[RXChannel_AIL] ;
    2cc4:	cc 1a       	sub	r12, r28
    2cc6:	dd 0a       	sbc	r13, r29
					{
						RX_Snapshot[RXChannel_AIL] = RX_Snapshot[RXChannel_AIL] * 0.63;		// because we fly X
						RX_Snapshot[RXChannel_ELE] = RX_Snapshot[RXChannel_ELE] * 0.63;
					
						// {0.63,-0.63,-0.63,0.63} QUAD_AIL_X
						MotorOut[0] += RX_Snapshot[RXChannel_AIL] ;
    2cc8:	ce 01       	movw	r24, r28
    2cca:	82 0f       	add	r24, r18
    2ccc:	93 1f       	adc	r25, r19
						MotorOut[3] += RX_Snapshot[RXChannel_AIL] ;
						MotorOut[1] -= RX_Snapshot[RXChannel_AIL] ;
						MotorOut[2] -= RX_Snapshot[RXChannel_AIL] ;
				
						// {0.63,0.63,-0.63,-0.63} QUAD_ELE_X
						MotorOut[0] += RX_Snapshot[RXChannel_ELE];
    2cce:	80 0f       	add	r24, r16
    2cd0:	91 1f       	adc	r25, r17
    2cd2:	90 93 85 05 	sts	0x0585, r25
    2cd6:	80 93 84 05 	sts	0x0584, r24
						RX_Snapshot[RXChannel_ELE] = RX_Snapshot[RXChannel_ELE] * 0.63;
					
						// {0.63,-0.63,-0.63,0.63} QUAD_AIL_X
						MotorOut[0] += RX_Snapshot[RXChannel_AIL] ;
						MotorOut[3] += RX_Snapshot[RXChannel_AIL] ;
						MotorOut[1] -= RX_Snapshot[RXChannel_AIL] ;
    2cda:	a2 0e       	add	r10, r18
    2cdc:	b3 1e       	adc	r11, r19
						MotorOut[2] -= RX_Snapshot[RXChannel_AIL] ;
				
						// {0.63,0.63,-0.63,-0.63} QUAD_ELE_X
						MotorOut[0] += RX_Snapshot[RXChannel_ELE];
						MotorOut[1] += RX_Snapshot[RXChannel_ELE];
    2cde:	ac 1a       	sub	r10, r28
    2ce0:	bd 0a       	sbc	r11, r29
    2ce2:	b0 92 87 05 	sts	0x0587, r11
    2ce6:	a0 92 86 05 	sts	0x0586, r10
						MotorOut[2] -= RX_Snapshot[RXChannel_ELE];
    2cea:	c2 1a       	sub	r12, r18
    2cec:	d3 0a       	sbc	r13, r19
    2cee:	d0 92 89 05 	sts	0x0589, r13
    2cf2:	c0 92 88 05 	sts	0x0588, r12
						MotorOut[3] -= RX_Snapshot[RXChannel_ELE];
    2cf6:	82 1a       	sub	r8, r18
    2cf8:	93 0a       	sbc	r9, r19
    2cfa:	90 92 8b 05 	sts	0x058B, r9
    2cfe:	80 92 8a 05 	sts	0x058A, r8
    2d02:	2e c1       	rjmp	.+604    	; 0x2f60 <MainLoop+0x702>
					
					}
					else
					{
				
						RX_Snapshot[RXChannel_AIL] = RX_Snapshot[RXChannel_AIL] * 0.9;		// 0.9: to reduce sensitivity more than STABLE mode
    2d04:	88 27       	eor	r24, r24
    2d06:	77 fd       	sbrc	r23, 7
    2d08:	80 95       	com	r24
    2d0a:	98 2f       	mov	r25, r24
    2d0c:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    2d10:	26 e6       	ldi	r18, 0x66	; 102
    2d12:	36 e6       	ldi	r19, 0x66	; 102
    2d14:	46 e6       	ldi	r20, 0x66	; 102
    2d16:	5f e3       	ldi	r21, 0x3F	; 63
    2d18:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    2d1c:	0e 94 96 36 	call	0x6d2c	; 0x6d2c <__fixsfsi>
    2d20:	eb 01       	movw	r28, r22
    2d22:	70 93 ad 05 	sts	0x05AD, r23
    2d26:	60 93 ac 05 	sts	0x05AC, r22
						RX_Snapshot[RXChannel_ELE] = RX_Snapshot[RXChannel_ELE] * 0.9;
    2d2a:	b7 01       	movw	r22, r14
    2d2c:	88 27       	eor	r24, r24
    2d2e:	77 fd       	sbrc	r23, 7
    2d30:	80 95       	com	r24
    2d32:	98 2f       	mov	r25, r24
    2d34:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    2d38:	26 e6       	ldi	r18, 0x66	; 102
    2d3a:	36 e6       	ldi	r19, 0x66	; 102
    2d3c:	46 e6       	ldi	r20, 0x66	; 102
    2d3e:	5f e3       	ldi	r21, 0x3F	; 63
    2d40:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    2d44:	0e 94 96 36 	call	0x6d2c	; 0x6d2c <__fixsfsi>
    2d48:	70 93 af 05 	sts	0x05AF, r23
    2d4c:	60 93 ae 05 	sts	0x05AE, r22
						// {0.9,0,-0.9,0} QUAD_ELE_PLUS
						MotorOut[0] += RX_Snapshot[RXChannel_ELE] ; 
    2d50:	06 0f       	add	r16, r22
    2d52:	17 1f       	adc	r17, r23
    2d54:	10 93 85 05 	sts	0x0585, r17
    2d58:	00 93 84 05 	sts	0x0584, r16
						MotorOut[2] -= RX_Snapshot[RXChannel_ELE] ; 
    2d5c:	c6 1a       	sub	r12, r22
    2d5e:	d7 0a       	sbc	r13, r23
    2d60:	d0 92 89 05 	sts	0x0589, r13
    2d64:	c0 92 88 05 	sts	0x0588, r12
						// {0,-0.9,0,0.9} QUAD_AIL_PLUS	
						MotorOut[1] -= RX_Snapshot[RXChannel_AIL] ; 
    2d68:	ac 1a       	sub	r10, r28
    2d6a:	bd 0a       	sbc	r11, r29
    2d6c:	b0 92 87 05 	sts	0x0587, r11
    2d70:	a0 92 86 05 	sts	0x0586, r10
						MotorOut[3] += RX_Snapshot[RXChannel_AIL] ;  
    2d74:	c8 0d       	add	r28, r8
    2d76:	d9 1d       	adc	r29, r9
    2d78:	d0 93 8b 05 	sts	0x058B, r29
    2d7c:	c0 93 8a 05 	sts	0x058A, r28
    2d80:	ef c0       	rjmp	.+478    	; 0x2f60 <MainLoop+0x702>
				}
				else
				{ // TRICopter
					
						int8_t inv=1; // Flying in Y mode
						if (Config.QuadFlyingMode==QuadFlyingMode_X)
    2d82:	81 30       	cpi	r24, 0x01	; 1
    2d84:	11 f0       	breq	.+4      	; 0x2d8a <MainLoop+0x52c>
					}
				}
				else
				{ // TRICopter
					
						int8_t inv=1; // Flying in Y mode
    2d86:	01 e0       	ldi	r16, 0x01	; 1
    2d88:	01 c0       	rjmp	.+2      	; 0x2d8c <MainLoop+0x52e>
						if (Config.QuadFlyingMode==QuadFlyingMode_X)
						{ // Flying in A mode
							inv = -1;
    2d8a:	0f ef       	ldi	r16, 0xFF	; 255
						}							
							// {0.5,0.5,1.1,X} TRI_ELE_FRONT
							MotorOut[2] -= inv * (RX_Snapshot[RXChannel_ELE] * 1.1); 
    2d8c:	c0 91 ae 05 	lds	r28, 0x05AE
    2d90:	d0 91 af 05 	lds	r29, 0x05AF
    2d94:	60 91 88 05 	lds	r22, 0x0588
    2d98:	70 91 89 05 	lds	r23, 0x0589
    2d9c:	88 27       	eor	r24, r24
    2d9e:	77 fd       	sbrc	r23, 7
    2da0:	80 95       	com	r24
    2da2:	98 2f       	mov	r25, r24
    2da4:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    2da8:	4b 01       	movw	r8, r22
    2daa:	5c 01       	movw	r10, r24
    2dac:	60 2f       	mov	r22, r16
    2dae:	77 27       	eor	r23, r23
    2db0:	67 fd       	sbrc	r22, 7
    2db2:	70 95       	com	r23
    2db4:	87 2f       	mov	r24, r23
    2db6:	97 2f       	mov	r25, r23
    2db8:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    2dbc:	6b 01       	movw	r12, r22
    2dbe:	7c 01       	movw	r14, r24
    2dc0:	be 01       	movw	r22, r28
    2dc2:	88 27       	eor	r24, r24
    2dc4:	77 fd       	sbrc	r23, 7
    2dc6:	80 95       	com	r24
    2dc8:	98 2f       	mov	r25, r24
    2dca:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    2dce:	2d ec       	ldi	r18, 0xCD	; 205
    2dd0:	3c ec       	ldi	r19, 0xCC	; 204
    2dd2:	4c e8       	ldi	r20, 0x8C	; 140
    2dd4:	5f e3       	ldi	r21, 0x3F	; 63
    2dd6:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    2dda:	9b 01       	movw	r18, r22
    2ddc:	ac 01       	movw	r20, r24
    2dde:	c7 01       	movw	r24, r14
    2de0:	b6 01       	movw	r22, r12
    2de2:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    2de6:	9b 01       	movw	r18, r22
    2de8:	ac 01       	movw	r20, r24
    2dea:	c5 01       	movw	r24, r10
    2dec:	b4 01       	movw	r22, r8
    2dee:	0e 94 c5 35 	call	0x6b8a	; 0x6b8a <__subsf3>
    2df2:	0e 94 96 36 	call	0x6d2c	; 0x6d2c <__fixsfsi>
    2df6:	70 93 89 05 	sts	0x0589, r23
    2dfa:	60 93 88 05 	sts	0x0588, r22
							RX_Snapshot[RXChannel_ELE] = inv * RX_Snapshot[RXChannel_ELE] * 0.5;
    2dfe:	e0 2e       	mov	r14, r16
    2e00:	ff 24       	eor	r15, r15
    2e02:	e7 fc       	sbrc	r14, 7
    2e04:	f0 94       	com	r15
    2e06:	ec 9e       	mul	r14, r28
    2e08:	b0 01       	movw	r22, r0
    2e0a:	ed 9e       	mul	r14, r29
    2e0c:	70 0d       	add	r23, r0
    2e0e:	fc 9e       	mul	r15, r28
    2e10:	70 0d       	add	r23, r0
    2e12:	11 24       	eor	r1, r1
    2e14:	88 27       	eor	r24, r24
    2e16:	77 fd       	sbrc	r23, 7
    2e18:	80 95       	com	r24
    2e1a:	98 2f       	mov	r25, r24
    2e1c:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    2e20:	20 e0       	ldi	r18, 0x00	; 0
    2e22:	30 e0       	ldi	r19, 0x00	; 0
    2e24:	40 e0       	ldi	r20, 0x00	; 0
    2e26:	5f e3       	ldi	r21, 0x3F	; 63
    2e28:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    2e2c:	0e 94 96 36 	call	0x6d2c	; 0x6d2c <__fixsfsi>
    2e30:	fb 01       	movw	r30, r22
    2e32:	70 93 af 05 	sts	0x05AF, r23
    2e36:	60 93 ae 05 	sts	0x05AE, r22
							MotorOut[0] += RX_Snapshot[RXChannel_ELE] ; 
    2e3a:	20 91 84 05 	lds	r18, 0x0584
    2e3e:	30 91 85 05 	lds	r19, 0x0585
							MotorOut[1] += RX_Snapshot[RXChannel_ELE] ; 
    2e42:	80 91 86 05 	lds	r24, 0x0586
    2e46:	90 91 87 05 	lds	r25, 0x0587
						
							// {1,-1,0,X} TRI_AIL_FRONT
							RX_Snapshot[RXChannel_AIL] = inv * RX_Snapshot[RXChannel_AIL];
    2e4a:	60 91 ac 05 	lds	r22, 0x05AC
    2e4e:	70 91 ad 05 	lds	r23, 0x05AD
    2e52:	e6 9e       	mul	r14, r22
    2e54:	a0 01       	movw	r20, r0
    2e56:	e7 9e       	mul	r14, r23
    2e58:	50 0d       	add	r21, r0
    2e5a:	f6 9e       	mul	r15, r22
    2e5c:	50 0d       	add	r21, r0
    2e5e:	11 24       	eor	r1, r1
    2e60:	50 93 ad 05 	sts	0x05AD, r21
    2e64:	40 93 ac 05 	sts	0x05AC, r20
							inv = -1;
						}							
							// {0.5,0.5,1.1,X} TRI_ELE_FRONT
							MotorOut[2] -= inv * (RX_Snapshot[RXChannel_ELE] * 1.1); 
							RX_Snapshot[RXChannel_ELE] = inv * RX_Snapshot[RXChannel_ELE] * 0.5;
							MotorOut[0] += RX_Snapshot[RXChannel_ELE] ; 
    2e68:	24 0f       	add	r18, r20
    2e6a:	35 1f       	adc	r19, r21
							MotorOut[1] += RX_Snapshot[RXChannel_ELE] ; 
						
							// {1,-1,0,X} TRI_AIL_FRONT
							RX_Snapshot[RXChannel_AIL] = inv * RX_Snapshot[RXChannel_AIL];
							MotorOut[0] += RX_Snapshot[RXChannel_AIL] ; 
    2e6c:	2e 0f       	add	r18, r30
    2e6e:	3f 1f       	adc	r19, r31
    2e70:	30 93 85 05 	sts	0x0585, r19
    2e74:	20 93 84 05 	sts	0x0584, r18
						}							
							// {0.5,0.5,1.1,X} TRI_ELE_FRONT
							MotorOut[2] -= inv * (RX_Snapshot[RXChannel_ELE] * 1.1); 
							RX_Snapshot[RXChannel_ELE] = inv * RX_Snapshot[RXChannel_ELE] * 0.5;
							MotorOut[0] += RX_Snapshot[RXChannel_ELE] ; 
							MotorOut[1] += RX_Snapshot[RXChannel_ELE] ; 
    2e78:	84 1b       	sub	r24, r20
    2e7a:	95 0b       	sbc	r25, r21
						
							// {1,-1,0,X} TRI_AIL_FRONT
							RX_Snapshot[RXChannel_AIL] = inv * RX_Snapshot[RXChannel_AIL];
							MotorOut[0] += RX_Snapshot[RXChannel_AIL] ; 
							MotorOut[1] -= RX_Snapshot[RXChannel_AIL] ;  
    2e7c:	8e 0f       	add	r24, r30
    2e7e:	9f 1f       	adc	r25, r31
    2e80:	90 93 87 05 	sts	0x0587, r25
    2e84:	80 93 86 05 	sts	0x0586, r24
    2e88:	6b c0       	rjmp	.+214    	; 0x2f60 <MainLoop+0x702>
			{
				// in stabilization mode ... activate Acc-Z & Sonar if enabled.
				
				double Landing;
				
				Landing = IMU_HeightKeeping();
    2e8a:	0e 94 3d 1f 	call	0x3e7a	; 0x3e7a <IMU_HeightKeeping>
    2e8e:	7b 01       	movw	r14, r22
    2e90:	8c 01       	movw	r16, r24
				MotorOut[0] += Landing;
    2e92:	60 91 84 05 	lds	r22, 0x0584
    2e96:	70 91 85 05 	lds	r23, 0x0585
    2e9a:	88 27       	eor	r24, r24
    2e9c:	77 fd       	sbrc	r23, 7
    2e9e:	80 95       	com	r24
    2ea0:	98 2f       	mov	r25, r24
    2ea2:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    2ea6:	a8 01       	movw	r20, r16
    2ea8:	97 01       	movw	r18, r14
    2eaa:	0e 94 c6 35 	call	0x6b8c	; 0x6b8c <__addsf3>
    2eae:	0e 94 96 36 	call	0x6d2c	; 0x6d2c <__fixsfsi>
    2eb2:	70 93 85 05 	sts	0x0585, r23
    2eb6:	60 93 84 05 	sts	0x0584, r22
				MotorOut[1] += Landing;
    2eba:	60 91 86 05 	lds	r22, 0x0586
    2ebe:	70 91 87 05 	lds	r23, 0x0587
    2ec2:	88 27       	eor	r24, r24
    2ec4:	77 fd       	sbrc	r23, 7
    2ec6:	80 95       	com	r24
    2ec8:	98 2f       	mov	r25, r24
    2eca:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    2ece:	a8 01       	movw	r20, r16
    2ed0:	97 01       	movw	r18, r14
    2ed2:	0e 94 c6 35 	call	0x6b8c	; 0x6b8c <__addsf3>
    2ed6:	0e 94 96 36 	call	0x6d2c	; 0x6d2c <__fixsfsi>
    2eda:	70 93 87 05 	sts	0x0587, r23
    2ede:	60 93 86 05 	sts	0x0586, r22
				if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    2ee2:	80 91 cc 06 	lds	r24, 0x06CC
    2ee6:	c0 90 88 05 	lds	r12, 0x0588
    2eea:	d0 90 89 05 	lds	r13, 0x0589
    2eee:	81 30       	cpi	r24, 0x01	; 1
    2ef0:	31 f5       	brne	.+76     	; 0x2f3e <MainLoop+0x6e0>
				{
					
					MotorOut[2] += Landing;
    2ef2:	b6 01       	movw	r22, r12
    2ef4:	88 27       	eor	r24, r24
    2ef6:	77 fd       	sbrc	r23, 7
    2ef8:	80 95       	com	r24
    2efa:	98 2f       	mov	r25, r24
    2efc:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    2f00:	a8 01       	movw	r20, r16
    2f02:	97 01       	movw	r18, r14
    2f04:	0e 94 c6 35 	call	0x6b8c	; 0x6b8c <__addsf3>
    2f08:	0e 94 96 36 	call	0x6d2c	; 0x6d2c <__fixsfsi>
    2f0c:	70 93 89 05 	sts	0x0589, r23
    2f10:	60 93 88 05 	sts	0x0588, r22
					MotorOut[3] += Landing;		
    2f14:	60 91 8a 05 	lds	r22, 0x058A
    2f18:	70 91 8b 05 	lds	r23, 0x058B
    2f1c:	88 27       	eor	r24, r24
    2f1e:	77 fd       	sbrc	r23, 7
    2f20:	80 95       	com	r24
    2f22:	98 2f       	mov	r25, r24
    2f24:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    2f28:	a8 01       	movw	r20, r16
    2f2a:	97 01       	movw	r18, r14
    2f2c:	0e 94 c6 35 	call	0x6b8c	; 0x6b8c <__addsf3>
    2f30:	0e 94 96 36 	call	0x6d2c	; 0x6d2c <__fixsfsi>
    2f34:	70 93 8b 05 	sts	0x058B, r23
    2f38:	60 93 8a 05 	sts	0x058A, r22
    2f3c:	11 c0       	rjmp	.+34     	; 0x2f60 <MainLoop+0x702>
				}
				else
				{
					MotorOut[2] += Landing;
    2f3e:	b6 01       	movw	r22, r12
    2f40:	88 27       	eor	r24, r24
    2f42:	77 fd       	sbrc	r23, 7
    2f44:	80 95       	com	r24
    2f46:	98 2f       	mov	r25, r24
    2f48:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    2f4c:	a8 01       	movw	r20, r16
    2f4e:	97 01       	movw	r18, r14
    2f50:	0e 94 c6 35 	call	0x6b8c	; 0x6b8c <__addsf3>
    2f54:	0e 94 96 36 	call	0x6d2c	; 0x6d2c <__fixsfsi>
    2f58:	70 93 89 05 	sts	0x0589, r23
    2f5c:	60 93 88 05 	sts	0x0588, r22
													
										
			}
			
									
			if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    2f60:	00 91 cc 06 	lds	r16, 0x06CC
    2f64:	80 91 c3 06 	lds	r24, 0x06C3
    2f68:	90 91 c4 06 	lds	r25, 0x06C4
    2f6c:	01 30       	cpi	r16, 0x01	; 1
    2f6e:	49 f5       	brne	.+82     	; 0x2fc2 <MainLoop+0x764>
			{
				MotorOut[0] -= gyroYaw;
    2f70:	20 91 84 05 	lds	r18, 0x0584
    2f74:	30 91 85 05 	lds	r19, 0x0585
    2f78:	28 1b       	sub	r18, r24
    2f7a:	39 0b       	sbc	r19, r25
    2f7c:	30 93 85 05 	sts	0x0585, r19
    2f80:	20 93 84 05 	sts	0x0584, r18
				MotorOut[2] -= gyroYaw;
    2f84:	20 91 88 05 	lds	r18, 0x0588
    2f88:	30 91 89 05 	lds	r19, 0x0589
    2f8c:	28 1b       	sub	r18, r24
    2f8e:	39 0b       	sbc	r19, r25
    2f90:	30 93 89 05 	sts	0x0589, r19
    2f94:	20 93 88 05 	sts	0x0588, r18
				MotorOut[1] += gyroYaw;
    2f98:	20 91 86 05 	lds	r18, 0x0586
    2f9c:	30 91 87 05 	lds	r19, 0x0587
    2fa0:	28 0f       	add	r18, r24
    2fa2:	39 1f       	adc	r19, r25
    2fa4:	30 93 87 05 	sts	0x0587, r19
    2fa8:	20 93 86 05 	sts	0x0586, r18
				MotorOut[3] += gyroYaw;
    2fac:	20 91 8a 05 	lds	r18, 0x058A
    2fb0:	30 91 8b 05 	lds	r19, 0x058B
    2fb4:	28 0f       	add	r18, r24
    2fb6:	39 1f       	adc	r19, r25
    2fb8:	30 93 8b 05 	sts	0x058B, r19
    2fbc:	20 93 8a 05 	sts	0x058A, r18
    2fc0:	3a c0       	rjmp	.+116    	; 0x3036 <MainLoop+0x7d8>
			}
			else
			{
			
				MotorOut[3]  = (Config.ReverseYAW * gyroYaw) + SERVO_IN_MIDDLE; 
    2fc2:	20 91 7c 07 	lds	r18, 0x077C
    2fc6:	c2 2f       	mov	r28, r18
    2fc8:	dd 27       	eor	r29, r29
    2fca:	c7 fd       	sbrc	r28, 7
    2fcc:	d0 95       	com	r29
    2fce:	c8 9f       	mul	r28, r24
    2fd0:	b0 01       	movw	r22, r0
    2fd2:	c9 9f       	mul	r28, r25
    2fd4:	70 0d       	add	r23, r0
    2fd6:	d8 9f       	mul	r29, r24
    2fd8:	70 0d       	add	r23, r0
    2fda:	11 24       	eor	r1, r1
    2fdc:	6a 5d       	subi	r22, 0xDA	; 218
    2fde:	7d 4f       	sbci	r23, 0xFD	; 253
				MotorOut[3]  = MotorOut[3] - (Config.ReverseYAW * RX_Snapshot[RXChannel_RUD] * 0.2);
    2fe0:	88 27       	eor	r24, r24
    2fe2:	77 fd       	sbrc	r23, 7
    2fe4:	80 95       	com	r24
    2fe6:	98 2f       	mov	r25, r24
    2fe8:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    2fec:	6b 01       	movw	r12, r22
    2fee:	7c 01       	movw	r14, r24
    2ff0:	80 91 b0 05 	lds	r24, 0x05B0
    2ff4:	90 91 b1 05 	lds	r25, 0x05B1
    2ff8:	c8 9f       	mul	r28, r24
    2ffa:	b0 01       	movw	r22, r0
    2ffc:	c9 9f       	mul	r28, r25
    2ffe:	70 0d       	add	r23, r0
    3000:	d8 9f       	mul	r29, r24
    3002:	70 0d       	add	r23, r0
    3004:	11 24       	eor	r1, r1
    3006:	88 27       	eor	r24, r24
    3008:	77 fd       	sbrc	r23, 7
    300a:	80 95       	com	r24
    300c:	98 2f       	mov	r25, r24
    300e:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    3012:	2d ec       	ldi	r18, 0xCD	; 205
    3014:	3c ec       	ldi	r19, 0xCC	; 204
    3016:	4c e4       	ldi	r20, 0x4C	; 76
    3018:	5e e3       	ldi	r21, 0x3E	; 62
    301a:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    301e:	9b 01       	movw	r18, r22
    3020:	ac 01       	movw	r20, r24
    3022:	c7 01       	movw	r24, r14
    3024:	b6 01       	movw	r22, r12
    3026:	0e 94 c5 35 	call	0x6b8a	; 0x6b8a <__subsf3>
    302a:	0e 94 96 36 	call	0x6d2c	; 0x6d2c <__fixsfsi>
    302e:	70 93 8b 05 	sts	0x058B, r23
    3032:	60 93 8a 05 	sts	0x058A, r22
			}						
			
			// Save motors from turning-off
            if (MotorOut[0]<MOTORS_IDLE_VALUE) MotorOut[0]=MOTORS_IDLE_VALUE;
    3036:	80 91 84 05 	lds	r24, 0x0584
    303a:	90 91 85 05 	lds	r25, 0x0585
    303e:	84 36       	cpi	r24, 0x64	; 100
    3040:	91 05       	cpc	r25, r1
    3042:	34 f4       	brge	.+12     	; 0x3050 <MainLoop+0x7f2>
    3044:	84 e6       	ldi	r24, 0x64	; 100
    3046:	90 e0       	ldi	r25, 0x00	; 0
    3048:	90 93 85 05 	sts	0x0585, r25
    304c:	80 93 84 05 	sts	0x0584, r24
            if (MotorOut[1]<MOTORS_IDLE_VALUE) MotorOut[1]=MOTORS_IDLE_VALUE;
    3050:	80 91 86 05 	lds	r24, 0x0586
    3054:	90 91 87 05 	lds	r25, 0x0587
    3058:	84 36       	cpi	r24, 0x64	; 100
    305a:	91 05       	cpc	r25, r1
    305c:	34 f4       	brge	.+12     	; 0x306a <MainLoop+0x80c>
    305e:	84 e6       	ldi	r24, 0x64	; 100
    3060:	90 e0       	ldi	r25, 0x00	; 0
    3062:	90 93 87 05 	sts	0x0587, r25
    3066:	80 93 86 05 	sts	0x0586, r24
            if (MotorOut[2]<MOTORS_IDLE_VALUE) MotorOut[2]=MOTORS_IDLE_VALUE;
    306a:	80 91 88 05 	lds	r24, 0x0588
    306e:	90 91 89 05 	lds	r25, 0x0589
    3072:	84 36       	cpi	r24, 0x64	; 100
    3074:	91 05       	cpc	r25, r1
    3076:	34 f4       	brge	.+12     	; 0x3084 <MainLoop+0x826>
    3078:	84 e6       	ldi	r24, 0x64	; 100
    307a:	90 e0       	ldi	r25, 0x00	; 0
    307c:	90 93 89 05 	sts	0x0589, r25
    3080:	80 93 88 05 	sts	0x0588, r24
            
									
			if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    3084:	01 30       	cpi	r16, 0x01	; 1
    3086:	69 f4       	brne	.+26     	; 0x30a2 <MainLoop+0x844>
			{
				if (MotorOut[3]<MOTORS_IDLE_VALUE) MotorOut[3]=MOTORS_IDLE_VALUE;
    3088:	80 91 8a 05 	lds	r24, 0x058A
    308c:	90 91 8b 05 	lds	r25, 0x058B
    3090:	84 36       	cpi	r24, 0x64	; 100
    3092:	91 05       	cpc	r25, r1
    3094:	34 f4       	brge	.+12     	; 0x30a2 <MainLoop+0x844>
    3096:	84 e6       	ldi	r24, 0x64	; 100
    3098:	90 e0       	ldi	r25, 0x00	; 0
    309a:	90 93 8b 05 	sts	0x058B, r25
    309e:	80 93 8a 05 	sts	0x058A, r24
			}
			
		
			// Sending Sensors & Motor Data 
			if (Config.RX_mode==RX_mode_UARTMode)
    30a2:	80 91 c7 06 	lds	r24, 0x06C7
    30a6:	8f 3f       	cpi	r24, 0xFF	; 255
    30a8:	a1 f4       	brne	.+40     	; 0x30d2 <MainLoop+0x874>
			{
				//LED_Orange=~LED_Orange;
				Send_Data("S",1);
    30aa:	84 e0       	ldi	r24, 0x04	; 4
    30ac:	91 e0       	ldi	r25, 0x01	; 1
    30ae:	61 e0       	ldi	r22, 0x01	; 1
    30b0:	0e 94 5d 10 	call	0x20ba	; 0x20ba <Send_Data>
				Send_Data(Sensors_Latest,12);
    30b4:	89 e2       	ldi	r24, 0x29	; 41
    30b6:	96 e0       	ldi	r25, 0x06	; 6
    30b8:	6c e0       	ldi	r22, 0x0C	; 12
    30ba:	0e 94 5d 10 	call	0x20ba	; 0x20ba <Send_Data>
				Send_Data(MotorOut,8);
    30be:	84 e8       	ldi	r24, 0x84	; 132
    30c0:	95 e0       	ldi	r25, 0x05	; 5
    30c2:	68 e0       	ldi	r22, 0x08	; 8
    30c4:	0e 94 5d 10 	call	0x20ba	; 0x20ba <Send_Data>
				Send_Data("E",1);
    30c8:	86 e0       	ldi	r24, 0x06	; 6
    30ca:	91 e0       	ldi	r25, 0x01	; 1
    30cc:	61 e0       	ldi	r22, 0x01	; 1
    30ce:	0e 94 5d 10 	call	0x20ba	; 0x20ba <Send_Data>
		} // End of ARMED & Throttle > Minimum
				
			
	}  // End of Throttle stick is NOT Down [Armed Could be True or not]
	
	if ((!IS_TX2_GOOD)) // if no signal and there is no AutoLandingMode.
    30d2:	80 91 c9 07 	lds	r24, 0x07C9
    30d6:	80 7f       	andi	r24, 0xF0	; 240
    30d8:	79 f0       	breq	.+30     	; 0x30f8 <MainLoop+0x89a>
	{
		ZEROMotors();
    30da:	0e 94 11 14 	call	0x2822	; 0x2822 <ZEROMotors>
		if (IsArmed==true)
    30de:	80 91 96 07 	lds	r24, 0x0796
    30e2:	81 30       	cpi	r24, 0x01	; 1
    30e4:	49 f4       	brne	.+18     	; 0x30f8 <MainLoop+0x89a>
		{
			Motor_GenerateOutputSignal();	
    30e6:	0e 94 76 22 	call	0x44ec	; 0x44ec <Motor_GenerateOutputSignal>
			Disarm();	
    30ea:	0e 94 12 0f 	call	0x1e24	; 0x1e24 <Disarm>
			SystemErrorType = SET_SYS_ERR_SIGNAL; // only error if signal lost while arming
    30ee:	80 91 b5 06 	lds	r24, 0x06B5
    30f2:	81 60       	ori	r24, 0x01	; 1
    30f4:	80 93 b5 06 	sts	0x06B5, r24
		
		
		//return ; // Do nothing all below depends on TX.
	}
	
	Motor_GenerateOutputSignal();	
    30f8:	0e 94 76 22 	call	0x44ec	; 0x44ec <Motor_GenerateOutputSignal>
	
	if (bResetTCNR1_X==true)
    30fc:	80 91 43 06 	lds	r24, 0x0643
    3100:	81 30       	cpi	r24, 0x01	; 1
    3102:	21 f4       	brne	.+8      	; 0x310c <MainLoop+0x8ae>
	{
		TCNT1_X_snapshot1= 0; // reset timeout
    3104:	10 92 d5 05 	sts	0x05D5, r1
    3108:	10 92 d4 05 	sts	0x05D4, r1
	}
	
	
}	
    310c:	df 91       	pop	r29
    310e:	cf 91       	pop	r28
    3110:	1f 91       	pop	r17
    3112:	0f 91       	pop	r16
    3114:	ff 90       	pop	r15
    3116:	ef 90       	pop	r14
    3118:	df 90       	pop	r13
    311a:	cf 90       	pop	r12
    311c:	bf 90       	pop	r11
    311e:	af 90       	pop	r10
    3120:	9f 90       	pop	r9
    3122:	8f 90       	pop	r8
    3124:	08 95       	ret

00003126 <main>:

int main(void)
{
	// Stick Commands are only available for Secondary Receiver and when Stick is calibrated.
	
	UIEnableStickCommands=false;  
    3126:	10 92 d3 05 	sts	0x05D3, r1
	Setup();
    312a:	0e 94 97 11 	call	0x232e	; 0x232e <Setup>
	SystemActions = SYS_ACT_NON;
    312e:	10 92 3b 05 	sts	0x053B, r1
    SystemErrorType = SYS_ERR_NON;
    3132:	10 92 b5 06 	sts	0x06B5, r1
	nFlyingModes = FLYINGMODE_ACRO;
    3136:	81 e0       	ldi	r24, 0x01	; 1
    3138:	80 93 08 06 	sts	0x0608, r24
	FlyingModesToggle = HIGH;
    313c:	80 93 21 05 	sts	0x0521, r24
	
	DataPtr = (uint8_t *) (&Sensors_Latest);
    3140:	89 e2       	ldi	r24, 0x29	; 41
    3142:	96 e0       	ldi	r25, 0x06	; 6
    3144:	90 93 a6 07 	sts	0x07A6, r25
    3148:	80 93 a5 07 	sts	0x07A5, r24
	DataCounter=0;
    314c:	10 92 97 07 	sts	0x0797, r1
	
	
	TCNT1H_OLD = TCNT1H;
    3150:	80 91 85 00 	lds	r24, 0x0085
    3154:	90 e0       	ldi	r25, 0x00	; 0
    3156:	90 93 bb 06 	sts	0x06BB, r25
    315a:	80 93 ba 06 	sts	0x06BA, r24
	// Never go to MainLoop "fly loop" unless Sensors & RX is calibrated.
	// This loop to protect against any bug that might make the quad start or KB stick click
	// as in this case crash is a must.
	LoopCalibration ();
    315e:	0e 94 fe 11 	call	0x23fc	; 0x23fc <LoopCalibration>

	
	
	// This loop better be under the sensor/stick loop to avoid entering this mode is sticks are not calibrated.
	// This is no longer a condition after adding menuEnabled[PAGE_ESC_CALIBRATION]=0
	if (Config.IsESCCalibration==ESCCalibration_ON)		
    3162:	80 91 cb 06 	lds	r24, 0x06CB
    3166:	81 30       	cpi	r24, 0x01	; 1
    3168:	11 f4       	brne	.+4      	; 0x316e <main+0x48>
	{
		LoopESCCalibration ();
    316a:	0e 94 f8 11 	call	0x23f0	; 0x23f0 <LoopESCCalibration>
	Mixer[Mixer_Quad_PLUS].Roll[4]  = {0,-1.0,0,1.0};
//#define Mixer_Quad_X		1
//#define Mixer_TRI			2
*/

	Menu_EnableAllItems();
    316e:	0e 94 ba 35 	call	0x6b74	; 0x6b74 <Menu_EnableAllItems>
	
				
	while(1)
    {
		//LoopESCCalibration();
    	MainLoop();
    3172:	0e 94 2f 14 	call	0x285e	; 0x285e <MainLoop>
    3176:	fd cf       	rjmp	.-6      	; 0x3172 <main+0x4c>

00003178 <PID_Calculate_ACC>:




float PID_Calculate_ACC (const pid_param_t PID_Params, pid_terms_t *PID_Term, const double  Value)
{
    3178:	6f 92       	push	r6
    317a:	7f 92       	push	r7
    317c:	8f 92       	push	r8
    317e:	9f 92       	push	r9
    3180:	af 92       	push	r10
    3182:	bf 92       	push	r11
    3184:	cf 92       	push	r12
    3186:	df 92       	push	r13
    3188:	ef 92       	push	r14
    318a:	ff 92       	push	r15
    318c:	0f 93       	push	r16
    318e:	1f 93       	push	r17
    3190:	df 93       	push	r29
    3192:	cf 93       	push	r28
    3194:	cd b7       	in	r28, 0x3d	; 61
    3196:	de b7       	in	r29, 0x3e	; 62
    3198:	2e 97       	sbiw	r28, 0x0e	; 14
    319a:	0f b6       	in	r0, 0x3f	; 63
    319c:	f8 94       	cli
    319e:	de bf       	out	0x3e, r29	; 62
    31a0:	0f be       	out	0x3f, r0	; 63
    31a2:	cd bf       	out	0x3d, r28	; 61
    31a4:	c9 82       	std	Y+1, r12	; 0x01
    31a6:	da 82       	std	Y+2, r13	; 0x02
    31a8:	eb 82       	std	Y+3, r14	; 0x03
    31aa:	fc 82       	std	Y+4, r15	; 0x04
    31ac:	0d 83       	std	Y+5, r16	; 0x05
    31ae:	1e 83       	std	Y+6, r17	; 0x06
    31b0:	2f 83       	std	Y+7, r18	; 0x07
    31b2:	38 87       	std	Y+8, r19	; 0x08
    31b4:	49 87       	std	Y+9, r20	; 0x09
    31b6:	5a 87       	std	Y+10, r21	; 0x0a
    31b8:	6b 87       	std	Y+11, r22	; 0x0b
    31ba:	7c 87       	std	Y+12, r23	; 0x0c
    31bc:	8d 87       	std	Y+13, r24	; 0x0d
    31be:	9e 87       	std	Y+14, r25	; 0x0e
    31c0:	ef 8c       	ldd	r14, Y+31	; 0x1f
    31c2:	f8 a0       	ldd	r15, Y+32	; 0x20
    31c4:	09 a1       	ldd	r16, Y+33	; 0x21
    31c6:	1a a1       	ldd	r17, Y+34	; 0x22
    31c8:	6d 80       	ldd	r6, Y+5	; 0x05
    31ca:	7e 80       	ldd	r7, Y+6	; 0x06
	#define ACC_I_MIN	4
		
	float Output;
		
		double AbsValue = abs (Value);
    31cc:	c8 01       	movw	r24, r16
    31ce:	b7 01       	movw	r22, r14
    31d0:	0e 94 07 38 	call	0x700e	; 0x700e <abs>
    31d4:	9c 01       	movw	r18, r24
    31d6:	b9 01       	movw	r22, r18
    31d8:	88 27       	eor	r24, r24
    31da:	77 fd       	sbrc	r23, 7
    31dc:	80 95       	com	r24
    31de:	98 2f       	mov	r25, r24
    31e0:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
		// Calculate Terms 
		if (AbsValue > 1)
    31e4:	20 e0       	ldi	r18, 0x00	; 0
    31e6:	30 e0       	ldi	r19, 0x00	; 0
    31e8:	40 e8       	ldi	r20, 0x80	; 128
    31ea:	5f e3       	ldi	r21, 0x3F	; 63
    31ec:	0e 94 79 37 	call	0x6ef2	; 0x6ef2 <__gesf2>
    31f0:	18 16       	cp	r1, r24
    31f2:	cc f4       	brge	.+50     	; 0x3226 <PID_Calculate_ACC+0xae>
	    PID_Term->P  = ((float)(Value * PID_Params._P) / 10.0f);						
    31f4:	69 81       	ldd	r22, Y+1	; 0x01
    31f6:	7a 81       	ldd	r23, Y+2	; 0x02
    31f8:	88 27       	eor	r24, r24
    31fa:	77 fd       	sbrc	r23, 7
    31fc:	80 95       	com	r24
    31fe:	98 2f       	mov	r25, r24
    3200:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    3204:	9b 01       	movw	r18, r22
    3206:	ac 01       	movw	r20, r24
    3208:	c8 01       	movw	r24, r16
    320a:	b7 01       	movw	r22, r14
    320c:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    3210:	20 e0       	ldi	r18, 0x00	; 0
    3212:	30 e0       	ldi	r19, 0x00	; 0
    3214:	40 e2       	ldi	r20, 0x20	; 32
    3216:	51 e4       	ldi	r21, 0x41	; 65
    3218:	0e 94 2e 36 	call	0x6c5c	; 0x6c5c <__divsf3>
    321c:	f5 01       	movw	r30, r10
    321e:	60 83       	st	Z, r22
    3220:	71 83       	std	Z+1, r23	; 0x01
    3222:	82 83       	std	Z+2, r24	; 0x02
    3224:	93 83       	std	Z+3, r25	; 0x03
		//if ((abs(Value - PID_Term->Error) > AbsValue ) || (Value ==0))
		//{  // Zero I if different signs.
			//PID_Term->I =0; ..... removed because it nakes whobbles.S
		//}
		//else 
		int16_t DeltaError = (Value - PID_Term->Error);
    3226:	c8 01       	movw	r24, r16
    3228:	b7 01       	movw	r22, r14
    322a:	f5 01       	movw	r30, r10
    322c:	24 85       	ldd	r18, Z+12	; 0x0c
    322e:	35 85       	ldd	r19, Z+13	; 0x0d
    3230:	46 85       	ldd	r20, Z+14	; 0x0e
    3232:	57 85       	ldd	r21, Z+15	; 0x0f
    3234:	0e 94 c5 35 	call	0x6b8a	; 0x6b8a <__subsf3>
    3238:	0e 94 96 36 	call	0x6d2c	; 0x6d2c <__fixsfsi>
    323c:	6b 01       	movw	r12, r22
		if (Value > ACC_I_MIN)
    323e:	c8 01       	movw	r24, r16
    3240:	b7 01       	movw	r22, r14
    3242:	20 e0       	ldi	r18, 0x00	; 0
    3244:	30 e0       	ldi	r19, 0x00	; 0
    3246:	40 e8       	ldi	r20, 0x80	; 128
    3248:	50 e4       	ldi	r21, 0x40	; 64
    324a:	0e 94 79 37 	call	0x6ef2	; 0x6ef2 <__gesf2>
    324e:	18 16       	cp	r1, r24
    3250:	bc f4       	brge	.+46     	; 0x3280 <PID_Calculate_ACC+0x108>
		{
			PID_Term->I += (float)(PID_Params._I / 100.0f);						    		
    3252:	b3 01       	movw	r22, r6
    3254:	88 27       	eor	r24, r24
    3256:	77 fd       	sbrc	r23, 7
    3258:	80 95       	com	r24
    325a:	98 2f       	mov	r25, r24
    325c:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    3260:	20 e0       	ldi	r18, 0x00	; 0
    3262:	30 e0       	ldi	r19, 0x00	; 0
    3264:	48 ec       	ldi	r20, 0xC8	; 200
    3266:	52 e4       	ldi	r21, 0x42	; 66
    3268:	0e 94 2e 36 	call	0x6c5c	; 0x6c5c <__divsf3>
    326c:	9b 01       	movw	r18, r22
    326e:	ac 01       	movw	r20, r24
    3270:	f5 01       	movw	r30, r10
    3272:	64 81       	ldd	r22, Z+4	; 0x04
    3274:	75 81       	ldd	r23, Z+5	; 0x05
    3276:	86 81       	ldd	r24, Z+6	; 0x06
    3278:	97 81       	ldd	r25, Z+7	; 0x07
    327a:	0e 94 c6 35 	call	0x6b8c	; 0x6b8c <__addsf3>
    327e:	32 c0       	rjmp	.+100    	; 0x32e4 <PID_Calculate_ACC+0x16c>
		}
		else if (Value < -ACC_I_MIN)
    3280:	c8 01       	movw	r24, r16
    3282:	b7 01       	movw	r22, r14
    3284:	20 e0       	ldi	r18, 0x00	; 0
    3286:	30 e0       	ldi	r19, 0x00	; 0
    3288:	40 e8       	ldi	r20, 0x80	; 128
    328a:	50 ec       	ldi	r21, 0xC0	; 192
    328c:	0e 94 2a 36 	call	0x6c54	; 0x6c54 <__cmpsf2>
    3290:	87 ff       	sbrs	r24, 7
    3292:	15 c0       	rjmp	.+42     	; 0x32be <PID_Calculate_ACC+0x146>
		{	
			PID_Term->I -= (float)(PID_Params._I / 100.0f );						    		
    3294:	b3 01       	movw	r22, r6
    3296:	88 27       	eor	r24, r24
    3298:	77 fd       	sbrc	r23, 7
    329a:	80 95       	com	r24
    329c:	98 2f       	mov	r25, r24
    329e:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    32a2:	20 e0       	ldi	r18, 0x00	; 0
    32a4:	30 e0       	ldi	r19, 0x00	; 0
    32a6:	48 ec       	ldi	r20, 0xC8	; 200
    32a8:	52 e4       	ldi	r21, 0x42	; 66
    32aa:	0e 94 2e 36 	call	0x6c5c	; 0x6c5c <__divsf3>
    32ae:	9b 01       	movw	r18, r22
    32b0:	ac 01       	movw	r20, r24
    32b2:	f5 01       	movw	r30, r10
    32b4:	64 81       	ldd	r22, Z+4	; 0x04
    32b6:	75 81       	ldd	r23, Z+5	; 0x05
    32b8:	86 81       	ldd	r24, Z+6	; 0x06
    32ba:	97 81       	ldd	r25, Z+7	; 0x07
    32bc:	11 c0       	rjmp	.+34     	; 0x32e0 <PID_Calculate_ACC+0x168>
		}
		else
		{
			PID_Term->I -= (float)(PID_Term->I * PID_I_LEAK_RATE);
    32be:	f5 01       	movw	r30, r10
    32c0:	64 80       	ldd	r6, Z+4	; 0x04
    32c2:	75 80       	ldd	r7, Z+5	; 0x05
    32c4:	86 80       	ldd	r8, Z+6	; 0x06
    32c6:	97 80       	ldd	r9, Z+7	; 0x07
    32c8:	c4 01       	movw	r24, r8
    32ca:	b3 01       	movw	r22, r6
    32cc:	2a e0       	ldi	r18, 0x0A	; 10
    32ce:	37 ed       	ldi	r19, 0xD7	; 215
    32d0:	43 e2       	ldi	r20, 0x23	; 35
    32d2:	5c e3       	ldi	r21, 0x3C	; 60
    32d4:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    32d8:	9b 01       	movw	r18, r22
    32da:	ac 01       	movw	r20, r24
    32dc:	c4 01       	movw	r24, r8
    32de:	b3 01       	movw	r22, r6
    32e0:	0e 94 c5 35 	call	0x6b8a	; 0x6b8a <__subsf3>
    32e4:	f5 01       	movw	r30, r10
    32e6:	64 83       	std	Z+4, r22	; 0x04
    32e8:	75 83       	std	Z+5, r23	; 0x05
    32ea:	86 83       	std	Z+6, r24	; 0x06
    32ec:	97 83       	std	Z+7, r25	; 0x07
		}			
				
		
		PID_Term->D= (float)((float)(DeltaError) * (float)PID_Params._D) / 20.0f ;
    32ee:	b6 01       	movw	r22, r12
    32f0:	88 27       	eor	r24, r24
    32f2:	77 fd       	sbrc	r23, 7
    32f4:	80 95       	com	r24
    32f6:	98 2f       	mov	r25, r24
    32f8:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    32fc:	3b 01       	movw	r6, r22
    32fe:	4c 01       	movw	r8, r24
    3300:	69 85       	ldd	r22, Y+9	; 0x09
    3302:	7a 85       	ldd	r23, Y+10	; 0x0a
    3304:	88 27       	eor	r24, r24
    3306:	77 fd       	sbrc	r23, 7
    3308:	80 95       	com	r24
    330a:	98 2f       	mov	r25, r24
    330c:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    3310:	9b 01       	movw	r18, r22
    3312:	ac 01       	movw	r20, r24
    3314:	c4 01       	movw	r24, r8
    3316:	b3 01       	movw	r22, r6
    3318:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    331c:	20 e0       	ldi	r18, 0x00	; 0
    331e:	30 e0       	ldi	r19, 0x00	; 0
    3320:	40 ea       	ldi	r20, 0xA0	; 160
    3322:	51 e4       	ldi	r21, 0x41	; 65
    3324:	0e 94 2e 36 	call	0x6c5c	; 0x6c5c <__divsf3>
    3328:	f5 01       	movw	r30, r10
    332a:	60 87       	std	Z+8, r22	; 0x08
    332c:	71 87       	std	Z+9, r23	; 0x09
    332e:	82 87       	std	Z+10, r24	; 0x0a
    3330:	93 87       	std	Z+11, r25	; 0x0b
		PID_Term->Error = Value;	
    3332:	e4 86       	std	Z+12, r14	; 0x0c
    3334:	f5 86       	std	Z+13, r15	; 0x0d
    3336:	06 87       	std	Z+14, r16	; 0x0e
    3338:	17 87       	std	Z+15, r17	; 0x0f
		
				
		// Limit boundaries to custom values defined by user.
		PID_Term->I= Limiterf(PID_Term->I, PID_Params._ILimit);
    333a:	e4 80       	ldd	r14, Z+4	; 0x04
    333c:	f5 80       	ldd	r15, Z+5	; 0x05
    333e:	06 81       	ldd	r16, Z+6	; 0x06
    3340:	17 81       	ldd	r17, Z+7	; 0x07
    3342:	6f 81       	ldd	r22, Y+7	; 0x07
    3344:	78 85       	ldd	r23, Y+8	; 0x08
    3346:	88 27       	eor	r24, r24
    3348:	77 fd       	sbrc	r23, 7
    334a:	80 95       	com	r24
    334c:	98 2f       	mov	r25, r24
    334e:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    3352:	9b 01       	movw	r18, r22
    3354:	ac 01       	movw	r20, r24
    3356:	c8 01       	movw	r24, r16
    3358:	b7 01       	movw	r22, r14
    335a:	0e 94 33 21 	call	0x4266	; 0x4266 <Limiterf>
    335e:	f5 01       	movw	r30, r10
    3360:	64 83       	std	Z+4, r22	; 0x04
    3362:	75 83       	std	Z+5, r23	; 0x05
    3364:	86 83       	std	Z+6, r24	; 0x06
    3366:	97 83       	std	Z+7, r25	; 0x07
		PID_Term->P= Limiterf(PID_Term->P, PID_Params._PLimit);
    3368:	e0 80       	ld	r14, Z
    336a:	f1 80       	ldd	r15, Z+1	; 0x01
    336c:	02 81       	ldd	r16, Z+2	; 0x02
    336e:	13 81       	ldd	r17, Z+3	; 0x03
    3370:	6b 81       	ldd	r22, Y+3	; 0x03
    3372:	7c 81       	ldd	r23, Y+4	; 0x04
    3374:	88 27       	eor	r24, r24
    3376:	77 fd       	sbrc	r23, 7
    3378:	80 95       	com	r24
    337a:	98 2f       	mov	r25, r24
    337c:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    3380:	9b 01       	movw	r18, r22
    3382:	ac 01       	movw	r20, r24
    3384:	c8 01       	movw	r24, r16
    3386:	b7 01       	movw	r22, r14
    3388:	0e 94 33 21 	call	0x4266	; 0x4266 <Limiterf>
    338c:	f5 01       	movw	r30, r10
    338e:	60 83       	st	Z, r22
    3390:	71 83       	std	Z+1, r23	; 0x01
    3392:	82 83       	std	Z+2, r24	; 0x02
    3394:	93 83       	std	Z+3, r25	; 0x03
	    PID_Term->D= Limiterf(PID_Term->D, PID_Params._DLimit);
    3396:	e0 84       	ldd	r14, Z+8	; 0x08
    3398:	f1 84       	ldd	r15, Z+9	; 0x09
    339a:	02 85       	ldd	r16, Z+10	; 0x0a
    339c:	13 85       	ldd	r17, Z+11	; 0x0b
    339e:	6b 85       	ldd	r22, Y+11	; 0x0b
    33a0:	7c 85       	ldd	r23, Y+12	; 0x0c
    33a2:	88 27       	eor	r24, r24
    33a4:	77 fd       	sbrc	r23, 7
    33a6:	80 95       	com	r24
    33a8:	98 2f       	mov	r25, r24
    33aa:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    33ae:	9b 01       	movw	r18, r22
    33b0:	ac 01       	movw	r20, r24
    33b2:	c8 01       	movw	r24, r16
    33b4:	b7 01       	movw	r22, r14
    33b6:	0e 94 33 21 	call	0x4266	; 0x4266 <Limiterf>
    33ba:	7b 01       	movw	r14, r22
    33bc:	8c 01       	movw	r16, r24
    33be:	f5 01       	movw	r30, r10
    33c0:	60 87       	std	Z+8, r22	; 0x08
    33c2:	71 87       	std	Z+9, r23	; 0x09
    33c4:	82 87       	std	Z+10, r24	; 0x0a
    33c6:	93 87       	std	Z+11, r25	; 0x0b
	
		Output = (PID_Term->P + PID_Term->I + PID_Term->D);	// P + I + D
    33c8:	60 81       	ld	r22, Z
    33ca:	71 81       	ldd	r23, Z+1	; 0x01
    33cc:	82 81       	ldd	r24, Z+2	; 0x02
    33ce:	93 81       	ldd	r25, Z+3	; 0x03
    33d0:	24 81       	ldd	r18, Z+4	; 0x04
    33d2:	35 81       	ldd	r19, Z+5	; 0x05
    33d4:	46 81       	ldd	r20, Z+6	; 0x06
    33d6:	57 81       	ldd	r21, Z+7	; 0x07
    33d8:	0e 94 c6 35 	call	0x6b8c	; 0x6b8c <__addsf3>
    33dc:	a8 01       	movw	r20, r16
    33de:	97 01       	movw	r18, r14
    33e0:	0e 94 c6 35 	call	0x6b8c	; 0x6b8c <__addsf3>
		return  Output; 
}
    33e4:	2e 96       	adiw	r28, 0x0e	; 14
    33e6:	0f b6       	in	r0, 0x3f	; 63
    33e8:	f8 94       	cli
    33ea:	de bf       	out	0x3e, r29	; 62
    33ec:	0f be       	out	0x3f, r0	; 63
    33ee:	cd bf       	out	0x3d, r28	; 61
    33f0:	cf 91       	pop	r28
    33f2:	df 91       	pop	r29
    33f4:	1f 91       	pop	r17
    33f6:	0f 91       	pop	r16
    33f8:	ff 90       	pop	r15
    33fa:	ef 90       	pop	r14
    33fc:	df 90       	pop	r13
    33fe:	cf 90       	pop	r12
    3400:	bf 90       	pop	r11
    3402:	af 90       	pop	r10
    3404:	9f 90       	pop	r9
    3406:	8f 90       	pop	r8
    3408:	7f 90       	pop	r7
    340a:	6f 90       	pop	r6
    340c:	08 95       	ret

0000340e <PID_Calculate>:

float PID_Calculate (const pid_param_t PID_Params, pid_terms_t *PID_Term, const double  Value)
{
    340e:	af 92       	push	r10
    3410:	bf 92       	push	r11
    3412:	cf 92       	push	r12
    3414:	df 92       	push	r13
    3416:	ef 92       	push	r14
    3418:	ff 92       	push	r15
    341a:	0f 93       	push	r16
    341c:	1f 93       	push	r17
    341e:	df 93       	push	r29
    3420:	cf 93       	push	r28
    3422:	cd b7       	in	r28, 0x3d	; 61
    3424:	de b7       	in	r29, 0x3e	; 62
    3426:	2e 97       	sbiw	r28, 0x0e	; 14
    3428:	0f b6       	in	r0, 0x3f	; 63
    342a:	f8 94       	cli
    342c:	de bf       	out	0x3e, r29	; 62
    342e:	0f be       	out	0x3f, r0	; 63
    3430:	cd bf       	out	0x3d, r28	; 61
    3432:	c9 82       	std	Y+1, r12	; 0x01
    3434:	da 82       	std	Y+2, r13	; 0x02
    3436:	eb 82       	std	Y+3, r14	; 0x03
    3438:	fc 82       	std	Y+4, r15	; 0x04
    343a:	0d 83       	std	Y+5, r16	; 0x05
    343c:	1e 83       	std	Y+6, r17	; 0x06
    343e:	2f 83       	std	Y+7, r18	; 0x07
    3440:	38 87       	std	Y+8, r19	; 0x08
    3442:	49 87       	std	Y+9, r20	; 0x09
    3444:	5a 87       	std	Y+10, r21	; 0x0a
    3446:	6b 87       	std	Y+11, r22	; 0x0b
    3448:	7c 87       	std	Y+12, r23	; 0x0c
    344a:	8d 87       	std	Y+13, r24	; 0x0d
    344c:	9e 87       	std	Y+14, r25	; 0x0e
    344e:	eb 8c       	ldd	r14, Y+27	; 0x1b
    3450:	fc 8c       	ldd	r15, Y+28	; 0x1c
    3452:	0d 8d       	ldd	r16, Y+29	; 0x1d
    3454:	1e 8d       	ldd	r17, Y+30	; 0x1e
		float Output;
		
		// Calculate Terms 
	    PID_Term->P  = ((float)(Value * PID_Params._P) / 20.0f);						
    3456:	69 81       	ldd	r22, Y+1	; 0x01
    3458:	7a 81       	ldd	r23, Y+2	; 0x02
    345a:	88 27       	eor	r24, r24
    345c:	77 fd       	sbrc	r23, 7
    345e:	80 95       	com	r24
    3460:	98 2f       	mov	r25, r24
    3462:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    3466:	9b 01       	movw	r18, r22
    3468:	ac 01       	movw	r20, r24
    346a:	c8 01       	movw	r24, r16
    346c:	b7 01       	movw	r22, r14
    346e:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    3472:	20 e0       	ldi	r18, 0x00	; 0
    3474:	30 e0       	ldi	r19, 0x00	; 0
    3476:	40 ea       	ldi	r20, 0xA0	; 160
    3478:	51 e4       	ldi	r21, 0x41	; 65
    347a:	0e 94 2e 36 	call	0x6c5c	; 0x6c5c <__divsf3>
    347e:	f5 01       	movw	r30, r10
    3480:	60 83       	st	Z, r22
    3482:	71 83       	std	Z+1, r23	; 0x01
    3484:	82 83       	std	Z+2, r24	; 0x02
    3486:	93 83       	std	Z+3, r25	; 0x03
		
		
		
		int16_t DeltaError = (Value - PID_Term->Error);
    3488:	c8 01       	movw	r24, r16
    348a:	b7 01       	movw	r22, r14
    348c:	24 85       	ldd	r18, Z+12	; 0x0c
    348e:	35 85       	ldd	r19, Z+13	; 0x0d
    3490:	46 85       	ldd	r20, Z+14	; 0x0e
    3492:	57 85       	ldd	r21, Z+15	; 0x0f
    3494:	0e 94 c5 35 	call	0x6b8a	; 0x6b8a <__subsf3>
    3498:	0e 94 96 36 	call	0x6d2c	; 0x6d2c <__fixsfsi>
    349c:	6b 01       	movw	r12, r22
		/*
		// I Logic here:
		// DEAD band = 2
		// Increment or Decrement by Value * PID_Params._I 
		*/
		if ((Value > 1) || (Value < -1))
    349e:	c8 01       	movw	r24, r16
    34a0:	b7 01       	movw	r22, r14
    34a2:	20 e0       	ldi	r18, 0x00	; 0
    34a4:	30 e0       	ldi	r19, 0x00	; 0
    34a6:	40 e8       	ldi	r20, 0x80	; 128
    34a8:	5f e3       	ldi	r21, 0x3F	; 63
    34aa:	0e 94 79 37 	call	0x6ef2	; 0x6ef2 <__gesf2>
    34ae:	18 16       	cp	r1, r24
    34b0:	54 f0       	brlt	.+20     	; 0x34c6 <PID_Calculate+0xb8>
    34b2:	c8 01       	movw	r24, r16
    34b4:	b7 01       	movw	r22, r14
    34b6:	20 e0       	ldi	r18, 0x00	; 0
    34b8:	30 e0       	ldi	r19, 0x00	; 0
    34ba:	40 e8       	ldi	r20, 0x80	; 128
    34bc:	5f eb       	ldi	r21, 0xBF	; 191
    34be:	0e 94 2a 36 	call	0x6c54	; 0x6c54 <__cmpsf2>
    34c2:	87 ff       	sbrs	r24, 7
    34c4:	22 c0       	rjmp	.+68     	; 0x350a <PID_Calculate+0xfc>
		{	// only increment I when the Value is increasing compared to the old one, also use [-2,2] as deadband.
			PID_Term->I += (float)((float)(Value * PID_Params._I) / 200.0f) ;	// try to replace Value with DeltaError
    34c6:	6d 81       	ldd	r22, Y+5	; 0x05
    34c8:	7e 81       	ldd	r23, Y+6	; 0x06
    34ca:	88 27       	eor	r24, r24
    34cc:	77 fd       	sbrc	r23, 7
    34ce:	80 95       	com	r24
    34d0:	98 2f       	mov	r25, r24
    34d2:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    34d6:	9b 01       	movw	r18, r22
    34d8:	ac 01       	movw	r20, r24
    34da:	c8 01       	movw	r24, r16
    34dc:	b7 01       	movw	r22, r14
    34de:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    34e2:	20 e0       	ldi	r18, 0x00	; 0
    34e4:	30 e0       	ldi	r19, 0x00	; 0
    34e6:	48 e4       	ldi	r20, 0x48	; 72
    34e8:	53 e4       	ldi	r21, 0x43	; 67
    34ea:	0e 94 2e 36 	call	0x6c5c	; 0x6c5c <__divsf3>
    34ee:	9b 01       	movw	r18, r22
    34f0:	ac 01       	movw	r20, r24
    34f2:	f5 01       	movw	r30, r10
    34f4:	64 81       	ldd	r22, Z+4	; 0x04
    34f6:	75 81       	ldd	r23, Z+5	; 0x05
    34f8:	86 81       	ldd	r24, Z+6	; 0x06
    34fa:	97 81       	ldd	r25, Z+7	; 0x07
    34fc:	0e 94 c6 35 	call	0x6b8c	; 0x6b8c <__addsf3>
    3500:	f5 01       	movw	r30, r10
    3502:	64 83       	std	Z+4, r22	; 0x04
    3504:	75 83       	std	Z+5, r23	; 0x05
    3506:	86 83       	std	Z+6, r24	; 0x06
    3508:	97 83       	std	Z+7, r25	; 0x07
			//PID_Term->I -= (float)(PID_Term->I * PID_I_LEAK_RATE);
		//}	
		
		
		
		PID_Term->D= (float)(DeltaError * PID_Params._D) / 20.0f ;
    350a:	89 85       	ldd	r24, Y+9	; 0x09
    350c:	9a 85       	ldd	r25, Y+10	; 0x0a
    350e:	c8 9e       	mul	r12, r24
    3510:	b0 01       	movw	r22, r0
    3512:	c9 9e       	mul	r12, r25
    3514:	70 0d       	add	r23, r0
    3516:	d8 9e       	mul	r13, r24
    3518:	70 0d       	add	r23, r0
    351a:	11 24       	eor	r1, r1
    351c:	88 27       	eor	r24, r24
    351e:	77 fd       	sbrc	r23, 7
    3520:	80 95       	com	r24
    3522:	98 2f       	mov	r25, r24
    3524:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    3528:	20 e0       	ldi	r18, 0x00	; 0
    352a:	30 e0       	ldi	r19, 0x00	; 0
    352c:	40 ea       	ldi	r20, 0xA0	; 160
    352e:	51 e4       	ldi	r21, 0x41	; 65
    3530:	0e 94 2e 36 	call	0x6c5c	; 0x6c5c <__divsf3>
    3534:	f5 01       	movw	r30, r10
    3536:	60 87       	std	Z+8, r22	; 0x08
    3538:	71 87       	std	Z+9, r23	; 0x09
    353a:	82 87       	std	Z+10, r24	; 0x0a
    353c:	93 87       	std	Z+11, r25	; 0x0b
		PID_Term->Error = Value;	
    353e:	e4 86       	std	Z+12, r14	; 0x0c
    3540:	f5 86       	std	Z+13, r15	; 0x0d
    3542:	06 87       	std	Z+14, r16	; 0x0e
    3544:	17 87       	std	Z+15, r17	; 0x0f
		
				
		// Limit boundaries to custom values defined by user.
		PID_Term->I= Limiterf(PID_Term->I, PID_Params._ILimit);
    3546:	e4 80       	ldd	r14, Z+4	; 0x04
    3548:	f5 80       	ldd	r15, Z+5	; 0x05
    354a:	06 81       	ldd	r16, Z+6	; 0x06
    354c:	17 81       	ldd	r17, Z+7	; 0x07
    354e:	6f 81       	ldd	r22, Y+7	; 0x07
    3550:	78 85       	ldd	r23, Y+8	; 0x08
    3552:	88 27       	eor	r24, r24
    3554:	77 fd       	sbrc	r23, 7
    3556:	80 95       	com	r24
    3558:	98 2f       	mov	r25, r24
    355a:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    355e:	9b 01       	movw	r18, r22
    3560:	ac 01       	movw	r20, r24
    3562:	c8 01       	movw	r24, r16
    3564:	b7 01       	movw	r22, r14
    3566:	0e 94 33 21 	call	0x4266	; 0x4266 <Limiterf>
    356a:	f5 01       	movw	r30, r10
    356c:	64 83       	std	Z+4, r22	; 0x04
    356e:	75 83       	std	Z+5, r23	; 0x05
    3570:	86 83       	std	Z+6, r24	; 0x06
    3572:	97 83       	std	Z+7, r25	; 0x07
		PID_Term->P= Limiterf(PID_Term->P, PID_Params._PLimit);
    3574:	e0 80       	ld	r14, Z
    3576:	f1 80       	ldd	r15, Z+1	; 0x01
    3578:	02 81       	ldd	r16, Z+2	; 0x02
    357a:	13 81       	ldd	r17, Z+3	; 0x03
    357c:	6b 81       	ldd	r22, Y+3	; 0x03
    357e:	7c 81       	ldd	r23, Y+4	; 0x04
    3580:	88 27       	eor	r24, r24
    3582:	77 fd       	sbrc	r23, 7
    3584:	80 95       	com	r24
    3586:	98 2f       	mov	r25, r24
    3588:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    358c:	9b 01       	movw	r18, r22
    358e:	ac 01       	movw	r20, r24
    3590:	c8 01       	movw	r24, r16
    3592:	b7 01       	movw	r22, r14
    3594:	0e 94 33 21 	call	0x4266	; 0x4266 <Limiterf>
    3598:	f5 01       	movw	r30, r10
    359a:	60 83       	st	Z, r22
    359c:	71 83       	std	Z+1, r23	; 0x01
    359e:	82 83       	std	Z+2, r24	; 0x02
    35a0:	93 83       	std	Z+3, r25	; 0x03
	    PID_Term->D= Limiterf(PID_Term->D, PID_Params._DLimit);
    35a2:	e0 84       	ldd	r14, Z+8	; 0x08
    35a4:	f1 84       	ldd	r15, Z+9	; 0x09
    35a6:	02 85       	ldd	r16, Z+10	; 0x0a
    35a8:	13 85       	ldd	r17, Z+11	; 0x0b
    35aa:	6b 85       	ldd	r22, Y+11	; 0x0b
    35ac:	7c 85       	ldd	r23, Y+12	; 0x0c
    35ae:	88 27       	eor	r24, r24
    35b0:	77 fd       	sbrc	r23, 7
    35b2:	80 95       	com	r24
    35b4:	98 2f       	mov	r25, r24
    35b6:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    35ba:	9b 01       	movw	r18, r22
    35bc:	ac 01       	movw	r20, r24
    35be:	c8 01       	movw	r24, r16
    35c0:	b7 01       	movw	r22, r14
    35c2:	0e 94 33 21 	call	0x4266	; 0x4266 <Limiterf>
    35c6:	7b 01       	movw	r14, r22
    35c8:	8c 01       	movw	r16, r24
    35ca:	f5 01       	movw	r30, r10
    35cc:	60 87       	std	Z+8, r22	; 0x08
    35ce:	71 87       	std	Z+9, r23	; 0x09
    35d0:	82 87       	std	Z+10, r24	; 0x0a
    35d2:	93 87       	std	Z+11, r25	; 0x0b
	
		Output = (PID_Term->P + PID_Term->I + PID_Term->D);	// P + I + D
    35d4:	60 81       	ld	r22, Z
    35d6:	71 81       	ldd	r23, Z+1	; 0x01
    35d8:	82 81       	ldd	r24, Z+2	; 0x02
    35da:	93 81       	ldd	r25, Z+3	; 0x03
    35dc:	24 81       	ldd	r18, Z+4	; 0x04
    35de:	35 81       	ldd	r19, Z+5	; 0x05
    35e0:	46 81       	ldd	r20, Z+6	; 0x06
    35e2:	57 81       	ldd	r21, Z+7	; 0x07
    35e4:	0e 94 c6 35 	call	0x6b8c	; 0x6b8c <__addsf3>
    35e8:	a8 01       	movw	r20, r16
    35ea:	97 01       	movw	r18, r14
    35ec:	0e 94 c6 35 	call	0x6b8c	; 0x6b8c <__addsf3>
		//Output = Output / 10;
		return  Output; //Limiter(Output,(int16_t)300);
}		
    35f0:	2e 96       	adiw	r28, 0x0e	; 14
    35f2:	0f b6       	in	r0, 0x3f	; 63
    35f4:	f8 94       	cli
    35f6:	de bf       	out	0x3e, r29	; 62
    35f8:	0f be       	out	0x3f, r0	; 63
    35fa:	cd bf       	out	0x3d, r28	; 61
    35fc:	cf 91       	pop	r28
    35fe:	df 91       	pop	r29
    3600:	1f 91       	pop	r17
    3602:	0f 91       	pop	r16
    3604:	ff 90       	pop	r15
    3606:	ef 90       	pop	r14
    3608:	df 90       	pop	r13
    360a:	cf 90       	pop	r12
    360c:	bf 90       	pop	r11
    360e:	af 90       	pop	r10
    3610:	08 95       	ret

00003612 <ZERO_Is>:

void ZERO_Is()
{
	PID_GyroTerms[PITCH_INDEX].I=0;
    3612:	80 e0       	ldi	r24, 0x00	; 0
    3614:	90 e0       	ldi	r25, 0x00	; 0
    3616:	dc 01       	movw	r26, r24
    3618:	80 93 58 06 	sts	0x0658, r24
    361c:	90 93 59 06 	sts	0x0659, r25
    3620:	a0 93 5a 06 	sts	0x065A, r26
    3624:	b0 93 5b 06 	sts	0x065B, r27
	PID_GyroTerms[ROLL_INDEX].I=0;
    3628:	80 93 70 06 	sts	0x0670, r24
    362c:	90 93 71 06 	sts	0x0671, r25
    3630:	a0 93 72 06 	sts	0x0672, r26
    3634:	b0 93 73 06 	sts	0x0673, r27
	PID_GyroTerms[YAW_INDEX].I=0;
    3638:	80 93 88 06 	sts	0x0688, r24
    363c:	90 93 89 06 	sts	0x0689, r25
    3640:	a0 93 8a 06 	sts	0x068A, r26
    3644:	b0 93 8b 06 	sts	0x068B, r27
	PID_AccTerms[PITCH_INDEX].I=0;
    3648:	80 93 40 05 	sts	0x0540, r24
    364c:	90 93 41 05 	sts	0x0541, r25
    3650:	a0 93 42 05 	sts	0x0542, r26
    3654:	b0 93 43 05 	sts	0x0543, r27
	PID_AccTerms[ROLL_INDEX].I=0;
    3658:	80 93 58 05 	sts	0x0558, r24
    365c:	90 93 59 05 	sts	0x0559, r25
    3660:	a0 93 5a 05 	sts	0x055A, r26
    3664:	b0 93 5b 05 	sts	0x055B, r27
	PID_AccTerms[Z_INDEX].I=0;
    3668:	80 93 70 05 	sts	0x0570, r24
    366c:	90 93 71 05 	sts	0x0571, r25
    3670:	a0 93 72 05 	sts	0x0572, r26
    3674:	b0 93 73 05 	sts	0x0573, r27

	PID_SonarTerms[0].I=0;
    3678:	80 93 82 07 	sts	0x0782, r24
    367c:	90 93 83 07 	sts	0x0783, r25
    3680:	a0 93 84 07 	sts	0x0784, r26
    3684:	b0 93 85 07 	sts	0x0785, r27
}
    3688:	08 95       	ret

0000368a <RotateV>:
//#include "../Include/DCM.h"


// Rotate Estimated vector(s) with small angle approximation, according to the gyro data
void RotateV() 
{
    368a:	2f 92       	push	r2
    368c:	3f 92       	push	r3
    368e:	4f 92       	push	r4
    3690:	5f 92       	push	r5
    3692:	6f 92       	push	r6
    3694:	7f 92       	push	r7
    3696:	8f 92       	push	r8
    3698:	9f 92       	push	r9
    369a:	af 92       	push	r10
    369c:	bf 92       	push	r11
    369e:	cf 92       	push	r12
    36a0:	df 92       	push	r13
    36a2:	ef 92       	push	r14
    36a4:	ff 92       	push	r15
    36a6:	0f 93       	push	r16
    36a8:	1f 93       	push	r17
    36aa:	df 93       	push	r29
    36ac:	cf 93       	push	r28
    36ae:	cd b7       	in	r28, 0x3d	; 61
    36b0:	de b7       	in	r29, 0x3e	; 62
    36b2:	28 97       	sbiw	r28, 0x08	; 8
    36b4:	0f b6       	in	r0, 0x3f	; 63
    36b6:	f8 94       	cli
    36b8:	de bf       	out	0x3e, r29	; 62
    36ba:	0f be       	out	0x3f, r0	; 63
    36bc:	cd bf       	out	0x3d, r28	; 61
	  //fp_vector v_tmp = *v;
	  //v->Z -= delta[ROLL]  * v_tmp.X + delta[PITCH] * v_tmp.Y;
	  //v->X += delta[ROLL]  * v_tmp.Z - delta[YAW]   * v_tmp.Y;
	  //v->Y += delta[PITCH] * v_tmp.Z + delta[YAW]   * v_tmp.X; 
	//*/
	double oAnglePitch = AnglePitch;
    36be:	60 90 04 06 	lds	r6, 0x0604
    36c2:	70 90 05 06 	lds	r7, 0x0605
    36c6:	80 90 06 06 	lds	r8, 0x0606
    36ca:	90 90 07 06 	lds	r9, 0x0607
	double oAngleRoll = AngleRoll;
    36ce:	80 91 bc 06 	lds	r24, 0x06BC
    36d2:	90 91 bd 06 	lds	r25, 0x06BD
    36d6:	a0 91 be 06 	lds	r26, 0x06BE
    36da:	b0 91 bf 06 	lds	r27, 0x06BF
    36de:	89 83       	std	Y+1, r24	; 0x01
    36e0:	9a 83       	std	Y+2, r25	; 0x02
    36e2:	ab 83       	std	Y+3, r26	; 0x03
    36e4:	bc 83       	std	Y+4, r27	; 0x04
	double oAngleZ     = AngleZ     ;
    36e6:	80 91 4a 06 	lds	r24, 0x064A
    36ea:	90 91 4b 06 	lds	r25, 0x064B
    36ee:	a0 91 4c 06 	lds	r26, 0x064C
    36f2:	b0 91 4d 06 	lds	r27, 0x064D
	AngleZ     -= (CompGyroRoll  * oAngleRoll )  * GYRO_RATE + ( CompGyroPitch * oAnglePitch) * GYRO_RATE;
    36f6:	20 90 4a 06 	lds	r2, 0x064A
    36fa:	30 90 4b 06 	lds	r3, 0x064B
    36fe:	40 90 4c 06 	lds	r4, 0x064C
    3702:	50 90 4d 06 	lds	r5, 0x064D
    3706:	e0 90 50 06 	lds	r14, 0x0650
    370a:	f0 90 51 06 	lds	r15, 0x0651
    370e:	00 91 52 06 	lds	r16, 0x0652
    3712:	10 91 53 06 	lds	r17, 0x0653
    3716:	80 91 ce 05 	lds	r24, 0x05CE
    371a:	90 91 cf 05 	lds	r25, 0x05CF
    371e:	a0 91 d0 05 	lds	r26, 0x05D0
    3722:	b0 91 d1 05 	lds	r27, 0x05D1
    3726:	8d 83       	std	Y+5, r24	; 0x05
    3728:	9e 83       	std	Y+6, r25	; 0x06
    372a:	af 83       	std	Y+7, r26	; 0x07
    372c:	b8 87       	std	Y+8, r27	; 0x08
    372e:	c8 01       	movw	r24, r16
    3730:	b7 01       	movw	r22, r14
    3732:	29 81       	ldd	r18, Y+1	; 0x01
    3734:	3a 81       	ldd	r19, Y+2	; 0x02
    3736:	4b 81       	ldd	r20, Y+3	; 0x03
    3738:	5c 81       	ldd	r21, Y+4	; 0x04
    373a:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    373e:	23 ed       	ldi	r18, 0xD3	; 211
    3740:	39 ed       	ldi	r19, 0xD9	; 217
    3742:	49 e4       	ldi	r20, 0x49	; 73
    3744:	5a e3       	ldi	r21, 0x3A	; 58
    3746:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    374a:	5b 01       	movw	r10, r22
    374c:	6c 01       	movw	r12, r24
    374e:	6d 81       	ldd	r22, Y+5	; 0x05
    3750:	7e 81       	ldd	r23, Y+6	; 0x06
    3752:	8f 81       	ldd	r24, Y+7	; 0x07
    3754:	98 85       	ldd	r25, Y+8	; 0x08
    3756:	a4 01       	movw	r20, r8
    3758:	93 01       	movw	r18, r6
    375a:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    375e:	23 ed       	ldi	r18, 0xD3	; 211
    3760:	39 ed       	ldi	r19, 0xD9	; 217
    3762:	49 e4       	ldi	r20, 0x49	; 73
    3764:	5a e3       	ldi	r21, 0x3A	; 58
    3766:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    376a:	9b 01       	movw	r18, r22
    376c:	ac 01       	movw	r20, r24
    376e:	c6 01       	movw	r24, r12
    3770:	b5 01       	movw	r22, r10
    3772:	0e 94 c6 35 	call	0x6b8c	; 0x6b8c <__addsf3>
    3776:	9b 01       	movw	r18, r22
    3778:	ac 01       	movw	r20, r24
    377a:	c2 01       	movw	r24, r4
    377c:	b1 01       	movw	r22, r2
    377e:	0e 94 c5 35 	call	0x6b8a	; 0x6b8a <__subsf3>
    3782:	9b 01       	movw	r18, r22
    3784:	ac 01       	movw	r20, r24
    3786:	20 93 4a 06 	sts	0x064A, r18
    378a:	30 93 4b 06 	sts	0x064B, r19
    378e:	40 93 4c 06 	sts	0x064C, r20
    3792:	50 93 4d 06 	sts	0x064D, r21
	AngleRoll  += (CompGyroRoll  * AngleZ )     * GYRO_RATE - ( CompGyroZ     * oAnglePitch) * GYRO_RATE;
    3796:	20 90 bc 06 	lds	r2, 0x06BC
    379a:	30 90 bd 06 	lds	r3, 0x06BD
    379e:	40 90 be 06 	lds	r4, 0x06BE
    37a2:	50 90 bf 06 	lds	r5, 0x06BF
    37a6:	20 91 4a 06 	lds	r18, 0x064A
    37aa:	30 91 4b 06 	lds	r19, 0x064B
    37ae:	40 91 4c 06 	lds	r20, 0x064C
    37b2:	50 91 4d 06 	lds	r21, 0x064D
    37b6:	a0 90 0b 06 	lds	r10, 0x060B
    37ba:	b0 90 0c 06 	lds	r11, 0x060C
    37be:	c0 90 0d 06 	lds	r12, 0x060D
    37c2:	d0 90 0e 06 	lds	r13, 0x060E
    37c6:	c8 01       	movw	r24, r16
    37c8:	b7 01       	movw	r22, r14
    37ca:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    37ce:	23 ed       	ldi	r18, 0xD3	; 211
    37d0:	39 ed       	ldi	r19, 0xD9	; 217
    37d2:	49 e4       	ldi	r20, 0x49	; 73
    37d4:	5a e3       	ldi	r21, 0x3A	; 58
    37d6:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    37da:	7b 01       	movw	r14, r22
    37dc:	8c 01       	movw	r16, r24
    37de:	c6 01       	movw	r24, r12
    37e0:	b5 01       	movw	r22, r10
    37e2:	a4 01       	movw	r20, r8
    37e4:	93 01       	movw	r18, r6
    37e6:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    37ea:	23 ed       	ldi	r18, 0xD3	; 211
    37ec:	39 ed       	ldi	r19, 0xD9	; 217
    37ee:	49 e4       	ldi	r20, 0x49	; 73
    37f0:	5a e3       	ldi	r21, 0x3A	; 58
    37f2:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    37f6:	9b 01       	movw	r18, r22
    37f8:	ac 01       	movw	r20, r24
    37fa:	c8 01       	movw	r24, r16
    37fc:	b7 01       	movw	r22, r14
    37fe:	0e 94 c5 35 	call	0x6b8a	; 0x6b8a <__subsf3>
    3802:	9b 01       	movw	r18, r22
    3804:	ac 01       	movw	r20, r24
    3806:	c2 01       	movw	r24, r4
    3808:	b1 01       	movw	r22, r2
    380a:	0e 94 c6 35 	call	0x6b8c	; 0x6b8c <__addsf3>
    380e:	9b 01       	movw	r18, r22
    3810:	ac 01       	movw	r20, r24
    3812:	20 93 bc 06 	sts	0x06BC, r18
    3816:	30 93 bd 06 	sts	0x06BD, r19
    381a:	40 93 be 06 	sts	0x06BE, r20
    381e:	50 93 bf 06 	sts	0x06BF, r21
	AnglePitch += (CompGyroPitch * AngleZ )		* GYRO_RATE + ( CompGyroZ     * oAngleRoll ) * GYRO_RATE;
    3822:	60 90 04 06 	lds	r6, 0x0604
    3826:	70 90 05 06 	lds	r7, 0x0605
    382a:	80 90 06 06 	lds	r8, 0x0606
    382e:	90 90 07 06 	lds	r9, 0x0607
    3832:	20 91 4a 06 	lds	r18, 0x064A
    3836:	30 91 4b 06 	lds	r19, 0x064B
    383a:	40 91 4c 06 	lds	r20, 0x064C
    383e:	50 91 4d 06 	lds	r21, 0x064D
    3842:	6d 81       	ldd	r22, Y+5	; 0x05
    3844:	7e 81       	ldd	r23, Y+6	; 0x06
    3846:	8f 81       	ldd	r24, Y+7	; 0x07
    3848:	98 85       	ldd	r25, Y+8	; 0x08
    384a:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    384e:	23 ed       	ldi	r18, 0xD3	; 211
    3850:	39 ed       	ldi	r19, 0xD9	; 217
    3852:	49 e4       	ldi	r20, 0x49	; 73
    3854:	5a e3       	ldi	r21, 0x3A	; 58
    3856:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    385a:	7b 01       	movw	r14, r22
    385c:	8c 01       	movw	r16, r24
    385e:	c6 01       	movw	r24, r12
    3860:	b5 01       	movw	r22, r10
    3862:	29 81       	ldd	r18, Y+1	; 0x01
    3864:	3a 81       	ldd	r19, Y+2	; 0x02
    3866:	4b 81       	ldd	r20, Y+3	; 0x03
    3868:	5c 81       	ldd	r21, Y+4	; 0x04
    386a:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    386e:	23 ed       	ldi	r18, 0xD3	; 211
    3870:	39 ed       	ldi	r19, 0xD9	; 217
    3872:	49 e4       	ldi	r20, 0x49	; 73
    3874:	5a e3       	ldi	r21, 0x3A	; 58
    3876:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    387a:	9b 01       	movw	r18, r22
    387c:	ac 01       	movw	r20, r24
    387e:	c8 01       	movw	r24, r16
    3880:	b7 01       	movw	r22, r14
    3882:	0e 94 c6 35 	call	0x6b8c	; 0x6b8c <__addsf3>
    3886:	9b 01       	movw	r18, r22
    3888:	ac 01       	movw	r20, r24
    388a:	c4 01       	movw	r24, r8
    388c:	b3 01       	movw	r22, r6
    388e:	0e 94 c6 35 	call	0x6b8c	; 0x6b8c <__addsf3>
    3892:	9b 01       	movw	r18, r22
    3894:	ac 01       	movw	r20, r24
    3896:	20 93 04 06 	sts	0x0604, r18
    389a:	30 93 05 06 	sts	0x0605, r19
    389e:	40 93 06 06 	sts	0x0606, r20
    38a2:	50 93 07 06 	sts	0x0607, r21

}
    38a6:	28 96       	adiw	r28, 0x08	; 8
    38a8:	0f b6       	in	r0, 0x3f	; 63
    38aa:	f8 94       	cli
    38ac:	de bf       	out	0x3e, r29	; 62
    38ae:	0f be       	out	0x3f, r0	; 63
    38b0:	cd bf       	out	0x3d, r28	; 61
    38b2:	cf 91       	pop	r28
    38b4:	df 91       	pop	r29
    38b6:	1f 91       	pop	r17
    38b8:	0f 91       	pop	r16
    38ba:	ff 90       	pop	r15
    38bc:	ef 90       	pop	r14
    38be:	df 90       	pop	r13
    38c0:	cf 90       	pop	r12
    38c2:	bf 90       	pop	r11
    38c4:	af 90       	pop	r10
    38c6:	9f 90       	pop	r9
    38c8:	8f 90       	pop	r8
    38ca:	7f 90       	pop	r7
    38cc:	6f 90       	pop	r6
    38ce:	5f 90       	pop	r5
    38d0:	4f 90       	pop	r4
    38d2:	3f 90       	pop	r3
    38d4:	2f 90       	pop	r2
    38d6:	08 95       	ret

000038d8 <IMU_Reset>:


void IMU_Reset()
{
	
	AnglePitch=0;
    38d8:	80 e0       	ldi	r24, 0x00	; 0
    38da:	90 e0       	ldi	r25, 0x00	; 0
    38dc:	dc 01       	movw	r26, r24
    38de:	80 93 04 06 	sts	0x0604, r24
    38e2:	90 93 05 06 	sts	0x0605, r25
    38e6:	a0 93 06 06 	sts	0x0606, r26
    38ea:	b0 93 07 06 	sts	0x0607, r27
	AngleRoll=0;
    38ee:	80 93 bc 06 	sts	0x06BC, r24
    38f2:	90 93 bd 06 	sts	0x06BD, r25
    38f6:	a0 93 be 06 	sts	0x06BE, r26
    38fa:	b0 93 bf 06 	sts	0x06BF, r27
	AngleZ=0;
    38fe:	80 93 4a 06 	sts	0x064A, r24
    3902:	90 93 4b 06 	sts	0x064B, r25
    3906:	a0 93 4c 06 	sts	0x064C, r26
    390a:	b0 93 4d 06 	sts	0x064D, r27
	
}
    390e:	08 95       	ret

00003910 <IMU>:
//////////////////////////////////////////////////////////////////////////
// inspired by link: http://scolton.blogspot.com/2012/09/a-bit-more-kk20-modding.html
// Although I implement PID and super position in http://hefnycopter.net/index.php/developing-source-code/22-quadcopter-control-function-layers.html
void IMU (void)
{
    3910:	6f 92       	push	r6
    3912:	7f 92       	push	r7
    3914:	8f 92       	push	r8
    3916:	9f 92       	push	r9
    3918:	af 92       	push	r10
    391a:	bf 92       	push	r11
    391c:	cf 92       	push	r12
    391e:	df 92       	push	r13
    3920:	ef 92       	push	r14
    3922:	ff 92       	push	r15
    3924:	0f 93       	push	r16
    3926:	1f 93       	push	r17
    3928:	cf 93       	push	r28
    392a:	df 93       	push	r29
	
		double Alpha;	
		double Beta;
	
	    // calculate ACC-Z
		Alpha = Config.AccParams[Z_INDEX].ComplementaryFilterAlpha / 1000.0;
    392c:	60 91 25 07 	lds	r22, 0x0725
    3930:	70 91 26 07 	lds	r23, 0x0726
    3934:	88 27       	eor	r24, r24
    3936:	77 fd       	sbrc	r23, 7
    3938:	80 95       	com	r24
    393a:	98 2f       	mov	r25, r24
    393c:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    3940:	20 e0       	ldi	r18, 0x00	; 0
    3942:	30 e0       	ldi	r19, 0x00	; 0
    3944:	4a e7       	ldi	r20, 0x7A	; 122
    3946:	54 e4       	ldi	r21, 0x44	; 68
    3948:	0e 94 2e 36 	call	0x6c5c	; 0x6c5c <__divsf3>
    394c:	7b 01       	movw	r14, r22
    394e:	8c 01       	movw	r16, r24
		Beta = 1- Alpha; // complementary filter to remove noise
		CompAccZ = (double) (Alpha * CompAccZ) + (double) (Beta * Sensors_Latest[ACC_Z_Index]);
    3950:	c0 91 33 06 	lds	r28, 0x0633
    3954:	d0 91 34 06 	lds	r29, 0x0634
    3958:	7f 2d       	mov	r23, r15
    395a:	91 2f       	mov	r25, r17
    395c:	20 91 25 06 	lds	r18, 0x0625
    3960:	30 91 26 06 	lds	r19, 0x0626
    3964:	40 91 27 06 	lds	r20, 0x0627
    3968:	50 91 28 06 	lds	r21, 0x0628
    396c:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    3970:	5b 01       	movw	r10, r22
    3972:	6c 01       	movw	r12, r24
		double Alpha;	
		double Beta;
	
	    // calculate ACC-Z
		Alpha = Config.AccParams[Z_INDEX].ComplementaryFilterAlpha / 1000.0;
		Beta = 1- Alpha; // complementary filter to remove noise
    3974:	60 e0       	ldi	r22, 0x00	; 0
    3976:	70 e0       	ldi	r23, 0x00	; 0
    3978:	80 e8       	ldi	r24, 0x80	; 128
    397a:	9f e3       	ldi	r25, 0x3F	; 63
    397c:	2e 2d       	mov	r18, r14
    397e:	3f 2d       	mov	r19, r15
    3980:	40 2f       	mov	r20, r16
    3982:	51 2f       	mov	r21, r17
    3984:	0e 94 c5 35 	call	0x6b8a	; 0x6b8a <__subsf3>
    3988:	7b 01       	movw	r14, r22
    398a:	8c 01       	movw	r16, r24
		CompAccZ = (double) (Alpha * CompAccZ) + (double) (Beta * Sensors_Latest[ACC_Z_Index]);
    398c:	be 01       	movw	r22, r28
    398e:	88 27       	eor	r24, r24
    3990:	77 fd       	sbrc	r23, 7
    3992:	80 95       	com	r24
    3994:	98 2f       	mov	r25, r24
    3996:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    399a:	9b 01       	movw	r18, r22
    399c:	ac 01       	movw	r20, r24
    399e:	c8 01       	movw	r24, r16
    39a0:	b7 01       	movw	r22, r14
    39a2:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    39a6:	9b 01       	movw	r18, r22
    39a8:	ac 01       	movw	r20, r24
    39aa:	c6 01       	movw	r24, r12
    39ac:	b5 01       	movw	r22, r10
    39ae:	0e 94 c6 35 	call	0x6b8c	; 0x6b8c <__addsf3>
    39b2:	60 93 25 06 	sts	0x0625, r22
    39b6:	70 93 26 06 	sts	0x0626, r23
    39ba:	80 93 27 06 	sts	0x0627, r24
    39be:	90 93 28 06 	sts	0x0628, r25
		
		// calculate YAW
		Alpha = Config.GyroParams[YAW_INDEX].ComplementaryFilterAlpha / 1000.0;
    39c2:	60 91 fb 06 	lds	r22, 0x06FB
    39c6:	70 91 fc 06 	lds	r23, 0x06FC
    39ca:	88 27       	eor	r24, r24
    39cc:	77 fd       	sbrc	r23, 7
    39ce:	80 95       	com	r24
    39d0:	98 2f       	mov	r25, r24
    39d2:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    39d6:	20 e0       	ldi	r18, 0x00	; 0
    39d8:	30 e0       	ldi	r19, 0x00	; 0
    39da:	4a e7       	ldi	r20, 0x7A	; 122
    39dc:	54 e4       	ldi	r21, 0x44	; 68
    39de:	0e 94 2e 36 	call	0x6c5c	; 0x6c5c <__divsf3>
    39e2:	7b 01       	movw	r14, r22
    39e4:	8c 01       	movw	r16, r24
		Beta = 1- Alpha; // complementary filter to remove noise
		CompGyroZ = (double) (Alpha * CompGyroZ) + (double) (Beta * Sensors_Latest[GYRO_Z_Index]);
    39e6:	c0 91 2d 06 	lds	r28, 0x062D
    39ea:	d0 91 2e 06 	lds	r29, 0x062E
    39ee:	7f 2d       	mov	r23, r15
    39f0:	91 2f       	mov	r25, r17
    39f2:	20 91 0b 06 	lds	r18, 0x060B
    39f6:	30 91 0c 06 	lds	r19, 0x060C
    39fa:	40 91 0d 06 	lds	r20, 0x060D
    39fe:	50 91 0e 06 	lds	r21, 0x060E
    3a02:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    3a06:	5b 01       	movw	r10, r22
    3a08:	6c 01       	movw	r12, r24
		Beta = 1- Alpha; // complementary filter to remove noise
		CompAccZ = (double) (Alpha * CompAccZ) + (double) (Beta * Sensors_Latest[ACC_Z_Index]);
		
		// calculate YAW
		Alpha = Config.GyroParams[YAW_INDEX].ComplementaryFilterAlpha / 1000.0;
		Beta = 1- Alpha; // complementary filter to remove noise
    3a0a:	60 e0       	ldi	r22, 0x00	; 0
    3a0c:	70 e0       	ldi	r23, 0x00	; 0
    3a0e:	80 e8       	ldi	r24, 0x80	; 128
    3a10:	9f e3       	ldi	r25, 0x3F	; 63
    3a12:	2e 2d       	mov	r18, r14
    3a14:	3f 2d       	mov	r19, r15
    3a16:	40 2f       	mov	r20, r16
    3a18:	51 2f       	mov	r21, r17
    3a1a:	0e 94 c5 35 	call	0x6b8a	; 0x6b8a <__subsf3>
    3a1e:	7b 01       	movw	r14, r22
    3a20:	8c 01       	movw	r16, r24
		CompGyroZ = (double) (Alpha * CompGyroZ) + (double) (Beta * Sensors_Latest[GYRO_Z_Index]);
    3a22:	be 01       	movw	r22, r28
    3a24:	88 27       	eor	r24, r24
    3a26:	77 fd       	sbrc	r23, 7
    3a28:	80 95       	com	r24
    3a2a:	98 2f       	mov	r25, r24
    3a2c:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    3a30:	9b 01       	movw	r18, r22
    3a32:	ac 01       	movw	r20, r24
    3a34:	c8 01       	movw	r24, r16
    3a36:	b7 01       	movw	r22, r14
    3a38:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    3a3c:	9b 01       	movw	r18, r22
    3a3e:	ac 01       	movw	r20, r24
    3a40:	c6 01       	movw	r24, r12
    3a42:	b5 01       	movw	r22, r10
    3a44:	0e 94 c6 35 	call	0x6b8c	; 0x6b8c <__addsf3>
    3a48:	60 93 0b 06 	sts	0x060B, r22
    3a4c:	70 93 0c 06 	sts	0x060C, r23
    3a50:	80 93 0d 06 	sts	0x060D, r24
    3a54:	90 93 0e 06 	sts	0x060E, r25
		
		Alpha = Config.GyroParams[PITCH_INDEX].ComplementaryFilterAlpha / 1000.0;
    3a58:	60 91 df 06 	lds	r22, 0x06DF
    3a5c:	70 91 e0 06 	lds	r23, 0x06E0
    3a60:	88 27       	eor	r24, r24
    3a62:	77 fd       	sbrc	r23, 7
    3a64:	80 95       	com	r24
    3a66:	98 2f       	mov	r25, r24
    3a68:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    3a6c:	20 e0       	ldi	r18, 0x00	; 0
    3a6e:	30 e0       	ldi	r19, 0x00	; 0
    3a70:	4a e7       	ldi	r20, 0x7A	; 122
    3a72:	54 e4       	ldi	r21, 0x44	; 68
    3a74:	0e 94 2e 36 	call	0x6c5c	; 0x6c5c <__divsf3>
    3a78:	7b 01       	movw	r14, r22
    3a7a:	8c 01       	movw	r16, r24
		Beta = 1- Alpha; // complementary filter to remove noise
		CompGyroPitch = (double) (Alpha * CompGyroPitch) + (double) (Beta * Sensors_Latest[GYRO_PITCH_Index]);
    3a7c:	c0 91 2b 06 	lds	r28, 0x062B
    3a80:	d0 91 2c 06 	lds	r29, 0x062C
    3a84:	7f 2d       	mov	r23, r15
    3a86:	91 2f       	mov	r25, r17
    3a88:	20 91 ce 05 	lds	r18, 0x05CE
    3a8c:	30 91 cf 05 	lds	r19, 0x05CF
    3a90:	40 91 d0 05 	lds	r20, 0x05D0
    3a94:	50 91 d1 05 	lds	r21, 0x05D1
    3a98:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    3a9c:	5b 01       	movw	r10, r22
    3a9e:	6c 01       	movw	r12, r24
		Alpha = Config.GyroParams[YAW_INDEX].ComplementaryFilterAlpha / 1000.0;
		Beta = 1- Alpha; // complementary filter to remove noise
		CompGyroZ = (double) (Alpha * CompGyroZ) + (double) (Beta * Sensors_Latest[GYRO_Z_Index]);
		
		Alpha = Config.GyroParams[PITCH_INDEX].ComplementaryFilterAlpha / 1000.0;
		Beta = 1- Alpha; // complementary filter to remove noise
    3aa0:	60 e0       	ldi	r22, 0x00	; 0
    3aa2:	70 e0       	ldi	r23, 0x00	; 0
    3aa4:	80 e8       	ldi	r24, 0x80	; 128
    3aa6:	9f e3       	ldi	r25, 0x3F	; 63
    3aa8:	2e 2d       	mov	r18, r14
    3aaa:	3f 2d       	mov	r19, r15
    3aac:	40 2f       	mov	r20, r16
    3aae:	51 2f       	mov	r21, r17
    3ab0:	0e 94 c5 35 	call	0x6b8a	; 0x6b8a <__subsf3>
    3ab4:	7b 01       	movw	r14, r22
    3ab6:	8c 01       	movw	r16, r24
		CompGyroPitch = (double) (Alpha * CompGyroPitch) + (double) (Beta * Sensors_Latest[GYRO_PITCH_Index]);
    3ab8:	be 01       	movw	r22, r28
    3aba:	88 27       	eor	r24, r24
    3abc:	77 fd       	sbrc	r23, 7
    3abe:	80 95       	com	r24
    3ac0:	98 2f       	mov	r25, r24
    3ac2:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    3ac6:	9b 01       	movw	r18, r22
    3ac8:	ac 01       	movw	r20, r24
    3aca:	c8 01       	movw	r24, r16
    3acc:	b7 01       	movw	r22, r14
    3ace:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    3ad2:	9b 01       	movw	r18, r22
    3ad4:	ac 01       	movw	r20, r24
    3ad6:	c6 01       	movw	r24, r12
    3ad8:	b5 01       	movw	r22, r10
    3ada:	0e 94 c6 35 	call	0x6b8c	; 0x6b8c <__addsf3>
    3ade:	d6 2e       	mov	r13, r22
    3ae0:	c7 2e       	mov	r12, r23
    3ae2:	b8 2e       	mov	r11, r24
    3ae4:	a9 2e       	mov	r10, r25
    3ae6:	a6 01       	movw	r20, r12
    3ae8:	95 01       	movw	r18, r10
    3aea:	85 2f       	mov	r24, r21
    3aec:	94 2f       	mov	r25, r20
    3aee:	a3 2f       	mov	r26, r19
    3af0:	b2 2f       	mov	r27, r18
    3af2:	80 93 ce 05 	sts	0x05CE, r24
    3af6:	90 93 cf 05 	sts	0x05CF, r25
    3afa:	a0 93 d0 05 	sts	0x05D0, r26
    3afe:	b0 93 d1 05 	sts	0x05D1, r27
		Alpha = Config.GyroParams[ROLL_INDEX].ComplementaryFilterAlpha / 1000.0;
    3b02:	60 91 ed 06 	lds	r22, 0x06ED
    3b06:	70 91 ee 06 	lds	r23, 0x06EE
    3b0a:	88 27       	eor	r24, r24
    3b0c:	77 fd       	sbrc	r23, 7
    3b0e:	80 95       	com	r24
    3b10:	98 2f       	mov	r25, r24
    3b12:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    3b16:	20 e0       	ldi	r18, 0x00	; 0
    3b18:	30 e0       	ldi	r19, 0x00	; 0
    3b1a:	4a e7       	ldi	r20, 0x7A	; 122
    3b1c:	54 e4       	ldi	r21, 0x44	; 68
    3b1e:	0e 94 2e 36 	call	0x6c5c	; 0x6c5c <__divsf3>
    3b22:	f6 2e       	mov	r15, r22
    3b24:	07 2f       	mov	r16, r23
    3b26:	18 2f       	mov	r17, r24
    3b28:	e9 2e       	mov	r14, r25
		Beta = 1- Alpha; // complementary filter to remove noise
		CompGyroRoll  = (double) (Alpha * CompGyroRoll)  + (double) (Beta * Sensors_Latest[GYRO_ROLL_Index]);
    3b2a:	c0 91 29 06 	lds	r28, 0x0629
    3b2e:	d0 91 2a 06 	lds	r29, 0x062A
    3b32:	20 91 50 06 	lds	r18, 0x0650
    3b36:	30 91 51 06 	lds	r19, 0x0651
    3b3a:	40 91 52 06 	lds	r20, 0x0652
    3b3e:	50 91 53 06 	lds	r21, 0x0653
    3b42:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    3b46:	3b 01       	movw	r6, r22
    3b48:	4c 01       	movw	r8, r24
		
		Alpha = Config.GyroParams[PITCH_INDEX].ComplementaryFilterAlpha / 1000.0;
		Beta = 1- Alpha; // complementary filter to remove noise
		CompGyroPitch = (double) (Alpha * CompGyroPitch) + (double) (Beta * Sensors_Latest[GYRO_PITCH_Index]);
		Alpha = Config.GyroParams[ROLL_INDEX].ComplementaryFilterAlpha / 1000.0;
		Beta = 1- Alpha; // complementary filter to remove noise
    3b4a:	60 e0       	ldi	r22, 0x00	; 0
    3b4c:	70 e0       	ldi	r23, 0x00	; 0
    3b4e:	80 e8       	ldi	r24, 0x80	; 128
    3b50:	9f e3       	ldi	r25, 0x3F	; 63
    3b52:	2f 2d       	mov	r18, r15
    3b54:	30 2f       	mov	r19, r16
    3b56:	41 2f       	mov	r20, r17
    3b58:	5e 2d       	mov	r21, r14
    3b5a:	0e 94 c5 35 	call	0x6b8a	; 0x6b8a <__subsf3>
    3b5e:	7b 01       	movw	r14, r22
    3b60:	8c 01       	movw	r16, r24
		CompGyroRoll  = (double) (Alpha * CompGyroRoll)  + (double) (Beta * Sensors_Latest[GYRO_ROLL_Index]);
    3b62:	be 01       	movw	r22, r28
    3b64:	88 27       	eor	r24, r24
    3b66:	77 fd       	sbrc	r23, 7
    3b68:	80 95       	com	r24
    3b6a:	98 2f       	mov	r25, r24
    3b6c:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    3b70:	9b 01       	movw	r18, r22
    3b72:	ac 01       	movw	r20, r24
    3b74:	c8 01       	movw	r24, r16
    3b76:	b7 01       	movw	r22, r14
    3b78:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    3b7c:	9b 01       	movw	r18, r22
    3b7e:	ac 01       	movw	r20, r24
    3b80:	c4 01       	movw	r24, r8
    3b82:	b3 01       	movw	r22, r6
    3b84:	0e 94 c6 35 	call	0x6b8c	; 0x6b8c <__addsf3>
    3b88:	60 93 50 06 	sts	0x0650, r22
    3b8c:	70 93 51 06 	sts	0x0651, r23
    3b90:	80 93 52 06 	sts	0x0652, r24
    3b94:	90 93 53 06 	sts	0x0653, r25
		
					
		// GYRO Always calculated.
		gyroPitch =	PID_Calculate (Config.GyroParams[PITCH_INDEX],	&PID_GyroTerms[PITCH_INDEX],CompGyroPitch);	
    3b98:	00 d0       	rcall	.+0      	; 0x3b9a <IMU+0x28a>
    3b9a:	00 d0       	rcall	.+0      	; 0x3b9c <IMU+0x28c>
    3b9c:	a6 01       	movw	r20, r12
    3b9e:	95 01       	movw	r18, r10
    3ba0:	85 2f       	mov	r24, r21
    3ba2:	94 2f       	mov	r25, r20
    3ba4:	a3 2f       	mov	r26, r19
    3ba6:	b2 2f       	mov	r27, r18
    3ba8:	ed b7       	in	r30, 0x3d	; 61
    3baa:	fe b7       	in	r31, 0x3e	; 62
    3bac:	81 83       	std	Z+1, r24	; 0x01
    3bae:	92 83       	std	Z+2, r25	; 0x02
    3bb0:	a3 83       	std	Z+3, r26	; 0x03
    3bb2:	b4 83       	std	Z+4, r27	; 0x04
    3bb4:	c0 90 d3 06 	lds	r12, 0x06D3
    3bb8:	d0 90 d4 06 	lds	r13, 0x06D4
    3bbc:	e0 90 d5 06 	lds	r14, 0x06D5
    3bc0:	f0 90 d6 06 	lds	r15, 0x06D6
    3bc4:	00 91 d7 06 	lds	r16, 0x06D7
    3bc8:	10 91 d8 06 	lds	r17, 0x06D8
    3bcc:	20 91 d9 06 	lds	r18, 0x06D9
    3bd0:	30 91 da 06 	lds	r19, 0x06DA
    3bd4:	40 91 db 06 	lds	r20, 0x06DB
    3bd8:	50 91 dc 06 	lds	r21, 0x06DC
    3bdc:	60 91 dd 06 	lds	r22, 0x06DD
    3be0:	70 91 de 06 	lds	r23, 0x06DE
    3be4:	80 91 df 06 	lds	r24, 0x06DF
    3be8:	90 91 e0 06 	lds	r25, 0x06E0
    3bec:	a4 e5       	ldi	r26, 0x54	; 84
    3bee:	aa 2e       	mov	r10, r26
    3bf0:	a6 e0       	ldi	r26, 0x06	; 6
    3bf2:	ba 2e       	mov	r11, r26
    3bf4:	0e 94 07 1a 	call	0x340e	; 0x340e <PID_Calculate>
    3bf8:	0e 94 96 36 	call	0x6d2c	; 0x6d2c <__fixsfsi>
    3bfc:	70 93 24 06 	sts	0x0624, r23
    3c00:	60 93 23 06 	sts	0x0623, r22
		gyroRoll  = PID_Calculate (Config.GyroParams[ROLL_INDEX],	&PID_GyroTerms[ROLL_INDEX],CompGyroRoll); 
    3c04:	80 91 50 06 	lds	r24, 0x0650
    3c08:	90 91 51 06 	lds	r25, 0x0651
    3c0c:	a0 91 52 06 	lds	r26, 0x0652
    3c10:	b0 91 53 06 	lds	r27, 0x0653
    3c14:	ed b7       	in	r30, 0x3d	; 61
    3c16:	fe b7       	in	r31, 0x3e	; 62
    3c18:	81 83       	std	Z+1, r24	; 0x01
    3c1a:	92 83       	std	Z+2, r25	; 0x02
    3c1c:	a3 83       	std	Z+3, r26	; 0x03
    3c1e:	b4 83       	std	Z+4, r27	; 0x04
    3c20:	c0 90 e1 06 	lds	r12, 0x06E1
    3c24:	d0 90 e2 06 	lds	r13, 0x06E2
    3c28:	e0 90 e3 06 	lds	r14, 0x06E3
    3c2c:	f0 90 e4 06 	lds	r15, 0x06E4
    3c30:	00 91 e5 06 	lds	r16, 0x06E5
    3c34:	10 91 e6 06 	lds	r17, 0x06E6
    3c38:	20 91 e7 06 	lds	r18, 0x06E7
    3c3c:	30 91 e8 06 	lds	r19, 0x06E8
    3c40:	40 91 e9 06 	lds	r20, 0x06E9
    3c44:	50 91 ea 06 	lds	r21, 0x06EA
    3c48:	60 91 eb 06 	lds	r22, 0x06EB
    3c4c:	70 91 ec 06 	lds	r23, 0x06EC
    3c50:	80 91 ed 06 	lds	r24, 0x06ED
    3c54:	90 91 ee 06 	lds	r25, 0x06EE
    3c58:	fc e6       	ldi	r31, 0x6C	; 108
    3c5a:	af 2e       	mov	r10, r31
    3c5c:	f6 e0       	ldi	r31, 0x06	; 6
    3c5e:	bf 2e       	mov	r11, r31
    3c60:	0e 94 07 1a 	call	0x340e	; 0x340e <PID_Calculate>
    3c64:	0e 94 96 36 	call	0x6d2c	; 0x6d2c <__fixsfsi>
    3c68:	70 93 a5 05 	sts	0x05A5, r23
    3c6c:	60 93 a4 05 	sts	0x05A4, r22
		gyroYaw   = PID_Calculate (Config.GyroParams[YAW_INDEX],	&PID_GyroTerms[YAW_INDEX],CompGyroZ -((double)((float)RX_Snapshot[RXChannel_RUD]  * 0.5f))); 
    3c70:	cd b7       	in	r28, 0x3d	; 61
    3c72:	de b7       	in	r29, 0x3e	; 62
    3c74:	21 96       	adiw	r28, 0x01	; 1
    3c76:	60 91 b0 05 	lds	r22, 0x05B0
    3c7a:	70 91 b1 05 	lds	r23, 0x05B1
    3c7e:	88 27       	eor	r24, r24
    3c80:	77 fd       	sbrc	r23, 7
    3c82:	80 95       	com	r24
    3c84:	98 2f       	mov	r25, r24
    3c86:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    3c8a:	20 e0       	ldi	r18, 0x00	; 0
    3c8c:	30 e0       	ldi	r19, 0x00	; 0
    3c8e:	40 e0       	ldi	r20, 0x00	; 0
    3c90:	5f e3       	ldi	r21, 0x3F	; 63
    3c92:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    3c96:	9b 01       	movw	r18, r22
    3c98:	ac 01       	movw	r20, r24
    3c9a:	60 91 0b 06 	lds	r22, 0x060B
    3c9e:	70 91 0c 06 	lds	r23, 0x060C
    3ca2:	80 91 0d 06 	lds	r24, 0x060D
    3ca6:	90 91 0e 06 	lds	r25, 0x060E
    3caa:	0e 94 c5 35 	call	0x6b8a	; 0x6b8a <__subsf3>
    3cae:	68 83       	st	Y, r22
    3cb0:	79 83       	std	Y+1, r23	; 0x01
    3cb2:	8a 83       	std	Y+2, r24	; 0x02
    3cb4:	9b 83       	std	Y+3, r25	; 0x03
    3cb6:	c0 90 ef 06 	lds	r12, 0x06EF
    3cba:	d0 90 f0 06 	lds	r13, 0x06F0
    3cbe:	e0 90 f1 06 	lds	r14, 0x06F1
    3cc2:	f0 90 f2 06 	lds	r15, 0x06F2
    3cc6:	00 91 f3 06 	lds	r16, 0x06F3
    3cca:	10 91 f4 06 	lds	r17, 0x06F4
    3cce:	20 91 f5 06 	lds	r18, 0x06F5
    3cd2:	30 91 f6 06 	lds	r19, 0x06F6
    3cd6:	40 91 f7 06 	lds	r20, 0x06F7
    3cda:	50 91 f8 06 	lds	r21, 0x06F8
    3cde:	60 91 f9 06 	lds	r22, 0x06F9
    3ce2:	70 91 fa 06 	lds	r23, 0x06FA
    3ce6:	80 91 fb 06 	lds	r24, 0x06FB
    3cea:	90 91 fc 06 	lds	r25, 0x06FC
    3cee:	e4 e8       	ldi	r30, 0x84	; 132
    3cf0:	ae 2e       	mov	r10, r30
    3cf2:	e6 e0       	ldi	r30, 0x06	; 6
    3cf4:	be 2e       	mov	r11, r30
    3cf6:	0e 94 07 1a 	call	0x340e	; 0x340e <PID_Calculate>
    3cfa:	0e 94 96 36 	call	0x6d2c	; 0x6d2c <__fixsfsi>
    3cfe:	70 93 c4 06 	sts	0x06C4, r23
    3d02:	60 93 c3 06 	sts	0x06C3, r22
	
			
		// Read ACC and Trims
		// ACC directions are same as GYRO direction [we added "-" for this purpose] 
		double APitch = - Sensors_Latest[ACC_PITCH_Index] - Config.Acc_Pitch_Trim;
    3d06:	80 91 2f 06 	lds	r24, 0x062F
    3d0a:	90 91 30 06 	lds	r25, 0x0630
		double ARoll  = - Sensors_Latest[ACC_ROLL_Index]  - Config.Acc_Roll_Trim;
    3d0e:	80 91 31 06 	lds	r24, 0x0631
    3d12:	90 91 32 06 	lds	r25, 0x0632
		double DT_YAW =  (double)Sensors_Latest[GYRO_Z_Index] * GYRO_RATE; 
    3d16:	80 91 2d 06 	lds	r24, 0x062D
    3d1a:	90 91 2e 06 	lds	r25, 0x062E
		
		if ( TCNT1H > TCNT1H_OLD) 
    3d1e:	20 91 85 00 	lds	r18, 0x0085
    3d22:	80 91 ba 06 	lds	r24, 0x06BA
    3d26:	90 91 bb 06 	lds	r25, 0x06BB
    3d2a:	30 e0       	ldi	r19, 0x00	; 0
    3d2c:	0f 90       	pop	r0
    3d2e:	0f 90       	pop	r0
    3d30:	0f 90       	pop	r0
    3d32:	0f 90       	pop	r0
    3d34:	82 17       	cp	r24, r18
    3d36:	93 07       	cpc	r25, r19
    3d38:	50 f4       	brcc	.+20     	; 0x3d4e <IMU+0x43e>
		{
			TimeDef = TCNT1H - TCNT1H_OLD;
    3d3a:	80 91 85 00 	lds	r24, 0x0085
    3d3e:	20 91 ba 06 	lds	r18, 0x06BA
    3d42:	30 91 bb 06 	lds	r19, 0x06BB
    3d46:	90 e0       	ldi	r25, 0x00	; 0
    3d48:	82 1b       	sub	r24, r18
    3d4a:	93 0b       	sbc	r25, r19
    3d4c:	0a c0       	rjmp	.+20     	; 0x3d62 <IMU+0x452>
		}
		else
		{
			TimeDef = 0xffff - TCNT1H_OLD + TCNT1H ;
    3d4e:	80 91 ba 06 	lds	r24, 0x06BA
    3d52:	90 91 bb 06 	lds	r25, 0x06BB
    3d56:	20 91 85 00 	lds	r18, 0x0085
    3d5a:	80 95       	com	r24
    3d5c:	90 95       	com	r25
    3d5e:	82 0f       	add	r24, r18
    3d60:	91 1d       	adc	r25, r1
    3d62:	90 93 c1 06 	sts	0x06C1, r25
    3d66:	80 93 c0 06 	sts	0x06C0, r24
		}
		TCNT1H_OLD += TimeDef;
    3d6a:	80 91 ba 06 	lds	r24, 0x06BA
    3d6e:	90 91 bb 06 	lds	r25, 0x06BB
    3d72:	60 91 c0 06 	lds	r22, 0x06C0
    3d76:	70 91 c1 06 	lds	r23, 0x06C1
    3d7a:	86 0f       	add	r24, r22
    3d7c:	97 1f       	adc	r25, r23
    3d7e:	90 93 bb 06 	sts	0x06BB, r25
    3d82:	80 93 ba 06 	sts	0x06BA, r24
		
		//// Do the Magic of IMU LEVELING here
		//// check also : http://scolton.blogspot.com/2012/09/fun-with-complementary-filter-multiwii.html
		AnglePitch = AnglePitch
				   + (double)Sensors_Latest[GYRO_PITCH_Index] * GYRO_RATE * TimeDef * 0.001;
    3d86:	a0 90 04 06 	lds	r10, 0x0604
    3d8a:	b0 90 05 06 	lds	r11, 0x0605
    3d8e:	c0 90 06 06 	lds	r12, 0x0606
    3d92:	d0 90 07 06 	lds	r13, 0x0607
    3d96:	c0 91 2b 06 	lds	r28, 0x062B
    3d9a:	d0 91 2c 06 	lds	r29, 0x062C
    3d9e:	80 e0       	ldi	r24, 0x00	; 0
    3da0:	90 e0       	ldi	r25, 0x00	; 0
    3da2:	0e 94 c7 36 	call	0x6d8e	; 0x6d8e <__floatunsisf>
    3da6:	7b 01       	movw	r14, r22
    3da8:	8c 01       	movw	r16, r24
    3daa:	be 01       	movw	r22, r28
    3dac:	88 27       	eor	r24, r24
    3dae:	77 fd       	sbrc	r23, 7
    3db0:	80 95       	com	r24
    3db2:	98 2f       	mov	r25, r24
    3db4:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    3db8:	23 ed       	ldi	r18, 0xD3	; 211
    3dba:	39 ed       	ldi	r19, 0xD9	; 217
    3dbc:	49 e4       	ldi	r20, 0x49	; 73
    3dbe:	5a e3       	ldi	r21, 0x3A	; 58
    3dc0:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    3dc4:	a8 01       	movw	r20, r16
    3dc6:	97 01       	movw	r18, r14
    3dc8:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    3dcc:	2f e6       	ldi	r18, 0x6F	; 111
    3dce:	32 e1       	ldi	r19, 0x12	; 18
    3dd0:	43 e8       	ldi	r20, 0x83	; 131
    3dd2:	5a e3       	ldi	r21, 0x3A	; 58
    3dd4:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    3dd8:	9b 01       	movw	r18, r22
    3dda:	ac 01       	movw	r20, r24
    3ddc:	c6 01       	movw	r24, r12
    3dde:	b5 01       	movw	r22, r10
    3de0:	0e 94 c6 35 	call	0x6b8c	; 0x6b8c <__addsf3>
    3de4:	9b 01       	movw	r18, r22
    3de6:	ac 01       	movw	r20, r24
		}
		TCNT1H_OLD += TimeDef;
		
		//// Do the Magic of IMU LEVELING here
		//// check also : http://scolton.blogspot.com/2012/09/fun-with-complementary-filter-multiwii.html
		AnglePitch = AnglePitch
    3de8:	20 93 04 06 	sts	0x0604, r18
    3dec:	30 93 05 06 	sts	0x0605, r19
    3df0:	40 93 06 06 	sts	0x0606, r20
    3df4:	50 93 07 06 	sts	0x0607, r21
				   + (double)Sensors_Latest[GYRO_PITCH_Index] * GYRO_RATE * TimeDef * 0.001;
					  //// + (sin(AngleRoll * DEG_TO_RAD) * DT_YAW)  // integrate component of yaw rate into pitch angle
						;
		AngleRoll = AngleRoll  
				  + (double)Sensors_Latest[GYRO_ROLL_Index]  * GYRO_RATE * TimeDef * 0.001;
    3df8:	a0 90 bc 06 	lds	r10, 0x06BC
    3dfc:	b0 90 bd 06 	lds	r11, 0x06BD
    3e00:	c0 90 be 06 	lds	r12, 0x06BE
    3e04:	d0 90 bf 06 	lds	r13, 0x06BF
    3e08:	60 91 29 06 	lds	r22, 0x0629
    3e0c:	70 91 2a 06 	lds	r23, 0x062A
    3e10:	88 27       	eor	r24, r24
    3e12:	77 fd       	sbrc	r23, 7
    3e14:	80 95       	com	r24
    3e16:	98 2f       	mov	r25, r24
    3e18:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    3e1c:	23 ed       	ldi	r18, 0xD3	; 211
    3e1e:	39 ed       	ldi	r19, 0xD9	; 217
    3e20:	49 e4       	ldi	r20, 0x49	; 73
    3e22:	5a e3       	ldi	r21, 0x3A	; 58
    3e24:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    3e28:	a8 01       	movw	r20, r16
    3e2a:	97 01       	movw	r18, r14
    3e2c:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    3e30:	2f e6       	ldi	r18, 0x6F	; 111
    3e32:	32 e1       	ldi	r19, 0x12	; 18
    3e34:	43 e8       	ldi	r20, 0x83	; 131
    3e36:	5a e3       	ldi	r21, 0x3A	; 58
    3e38:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    3e3c:	9b 01       	movw	r18, r22
    3e3e:	ac 01       	movw	r20, r24
    3e40:	c6 01       	movw	r24, r12
    3e42:	b5 01       	movw	r22, r10
    3e44:	0e 94 c6 35 	call	0x6b8c	; 0x6b8c <__addsf3>
    3e48:	9b 01       	movw	r18, r22
    3e4a:	ac 01       	movw	r20, r24
		//// check also : http://scolton.blogspot.com/2012/09/fun-with-complementary-filter-multiwii.html
		AnglePitch = AnglePitch
				   + (double)Sensors_Latest[GYRO_PITCH_Index] * GYRO_RATE * TimeDef * 0.001;
					  //// + (sin(AngleRoll * DEG_TO_RAD) * DT_YAW)  // integrate component of yaw rate into pitch angle
						;
		AngleRoll = AngleRoll  
    3e4c:	20 93 bc 06 	sts	0x06BC, r18
    3e50:	30 93 bd 06 	sts	0x06BD, r19
    3e54:	40 93 be 06 	sts	0x06BE, r20
    3e58:	50 93 bf 06 	sts	0x06BF, r21
			gyroRoll += PID_Calculate_ACC (Config.AccParams[ROLL_INDEX], &PID_AccTerms[ROLL_INDEX],NavX); //AngleRoll); 
		 
		}
		
	
}
    3e5c:	df 91       	pop	r29
    3e5e:	cf 91       	pop	r28
    3e60:	1f 91       	pop	r17
    3e62:	0f 91       	pop	r16
    3e64:	ff 90       	pop	r15
    3e66:	ef 90       	pop	r14
    3e68:	df 90       	pop	r13
    3e6a:	cf 90       	pop	r12
    3e6c:	bf 90       	pop	r11
    3e6e:	af 90       	pop	r10
    3e70:	9f 90       	pop	r9
    3e72:	8f 90       	pop	r8
    3e74:	7f 90       	pop	r7
    3e76:	6f 90       	pop	r6
    3e78:	08 95       	ret

00003e7a <IMU_HeightKeeping>:

	

	
double IMU_HeightKeeping ()
{
    3e7a:	af 92       	push	r10
    3e7c:	bf 92       	push	r11
    3e7e:	cf 92       	push	r12
    3e80:	df 92       	push	r13
    3e82:	ef 92       	push	r14
    3e84:	ff 92       	push	r15
    3e86:	0f 93       	push	r16
    3e88:	1f 93       	push	r17
	double Temp;
//	ThrottleTemp = RX_Snapshot[RXChannel_THR];
	
	// calculate damping
	
	Landing = PID_Calculate (Config.AccParams[Z_INDEX], &PID_AccTerms[Z_INDEX],-CompAccZ) ;
    3e8a:	00 d0       	rcall	.+0      	; 0x3e8c <IMU_HeightKeeping+0x12>
    3e8c:	00 d0       	rcall	.+0      	; 0x3e8e <IMU_HeightKeeping+0x14>
    3e8e:	80 91 25 06 	lds	r24, 0x0625
    3e92:	90 91 26 06 	lds	r25, 0x0626
    3e96:	a0 91 27 06 	lds	r26, 0x0627
    3e9a:	b0 91 28 06 	lds	r27, 0x0628
    3e9e:	b0 58       	subi	r27, 0x80	; 128
    3ea0:	ed b7       	in	r30, 0x3d	; 61
    3ea2:	fe b7       	in	r31, 0x3e	; 62
    3ea4:	81 83       	std	Z+1, r24	; 0x01
    3ea6:	92 83       	std	Z+2, r25	; 0x02
    3ea8:	a3 83       	std	Z+3, r26	; 0x03
    3eaa:	b4 83       	std	Z+4, r27	; 0x04
    3eac:	c0 90 19 07 	lds	r12, 0x0719
    3eb0:	d0 90 1a 07 	lds	r13, 0x071A
    3eb4:	e0 90 1b 07 	lds	r14, 0x071B
    3eb8:	f0 90 1c 07 	lds	r15, 0x071C
    3ebc:	00 91 1d 07 	lds	r16, 0x071D
    3ec0:	10 91 1e 07 	lds	r17, 0x071E
    3ec4:	20 91 1f 07 	lds	r18, 0x071F
    3ec8:	30 91 20 07 	lds	r19, 0x0720
    3ecc:	40 91 21 07 	lds	r20, 0x0721
    3ed0:	50 91 22 07 	lds	r21, 0x0722
    3ed4:	60 91 23 07 	lds	r22, 0x0723
    3ed8:	70 91 24 07 	lds	r23, 0x0724
    3edc:	80 91 25 07 	lds	r24, 0x0725
    3ee0:	90 91 26 07 	lds	r25, 0x0726
    3ee4:	ec e6       	ldi	r30, 0x6C	; 108
    3ee6:	ae 2e       	mov	r10, r30
    3ee8:	e5 e0       	ldi	r30, 0x05	; 5
    3eea:	be 2e       	mov	r11, r30
    3eec:	0e 94 07 1a 	call	0x340e	; 0x340e <PID_Calculate>
    3ef0:	60 93 44 06 	sts	0x0644, r22
    3ef4:	70 93 45 06 	sts	0x0645, r23
    3ef8:	80 93 46 06 	sts	0x0646, r24
    3efc:	90 93 47 06 	sts	0x0647, r25
			
			
	// Calculate Altitude Hold
	if ((Config.RX_mode==RX_mode_UARTMode) && (IS_MISC_SENSOR_SONAR_ENABLED==true) && (nFlyingModes == FLYINGMODE_ALTHOLD))
    3f00:	0f 90       	pop	r0
    3f02:	0f 90       	pop	r0
    3f04:	0f 90       	pop	r0
    3f06:	0f 90       	pop	r0
    3f08:	80 91 c7 06 	lds	r24, 0x06C7
    3f0c:	8f 3f       	cpi	r24, 0xFF	; 255
    3f0e:	09 f0       	breq	.+2      	; 0x3f12 <IMU_HeightKeeping+0x98>
    3f10:	f4 c0       	rjmp	.+488    	; 0x40fa <IMU_HeightKeeping+0x280>
    3f12:	80 91 d2 06 	lds	r24, 0x06D2
    3f16:	80 ff       	sbrs	r24, 0
    3f18:	f0 c0       	rjmp	.+480    	; 0x40fa <IMU_HeightKeeping+0x280>
    3f1a:	80 91 08 06 	lds	r24, 0x0608
    3f1e:	84 30       	cpi	r24, 0x04	; 4
    3f20:	09 f0       	breq	.+2      	; 0x3f24 <IMU_HeightKeeping+0xaa>
    3f22:	eb c0       	rjmp	.+470    	; 0x40fa <IMU_HeightKeeping+0x280>
	{
		RX_SONAR_TRIGGER = HIGH;
    3f24:	48 9a       	sbi	0x09, 0	; 9
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    3f26:	f8 94       	cli
		ATOMIC_BLOCK(ATOMIC_FORCEON)
		{	
			Temp = RX_SONAR_RAW; 
    3f28:	60 91 be 05 	lds	r22, 0x05BE
    3f2c:	70 91 bf 05 	lds	r23, 0x05BF
    3f30:	80 e0       	ldi	r24, 0x00	; 0
    3f32:	90 e0       	ldi	r25, 0x00	; 0
    3f34:	0e 94 c7 36 	call	0x6d8e	; 0x6d8e <__floatunsisf>
    3f38:	7b 01       	movw	r14, r22
    3f3a:	8c 01       	movw	r16, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    3f3c:	78 94       	sei
		}
	
		if (Temp < 550) // if SONAR Reading is VALID - not BEYOND maximum range
    3f3e:	7f 2d       	mov	r23, r15
    3f40:	91 2f       	mov	r25, r17
    3f42:	20 e0       	ldi	r18, 0x00	; 0
    3f44:	30 e8       	ldi	r19, 0x80	; 128
    3f46:	49 e0       	ldi	r20, 0x09	; 9
    3f48:	54 e4       	ldi	r21, 0x44	; 68
    3f4a:	0e 94 2a 36 	call	0x6c54	; 0x6c54 <__cmpsf2>
    3f4e:	87 ff       	sbrs	r24, 7
    3f50:	b4 c0       	rjmp	.+360    	; 0x40ba <IMU_HeightKeeping+0x240>
		{
			
			if ((bALTHOLD == false))
    3f52:	80 91 27 05 	lds	r24, 0x0527
    3f56:	88 23       	and	r24, r24
    3f58:	29 f5       	brne	.+74     	; 0x3fa4 <IMU_HeightKeeping+0x12a>
			{   
				if (ThrottleTemp<3)
    3f5a:	80 91 25 05 	lds	r24, 0x0525
    3f5e:	90 91 26 05 	lds	r25, 0x0526
    3f62:	83 30       	cpi	r24, 0x03	; 3
    3f64:	91 05       	cpc	r25, r1
    3f66:	34 f4       	brge	.+12     	; 0x3f74 <IMU_HeightKeeping+0xfa>
				{ // current altitude is the old one so skip readings till update.
					ThrottleTemp+=1;
    3f68:	01 96       	adiw	r24, 0x01	; 1
    3f6a:	90 93 26 05 	sts	0x0526, r25
    3f6e:	80 93 25 05 	sts	0x0525, r24
    3f72:	c9 c0       	rjmp	.+402    	; 0x4106 <IMU_HeightKeeping+0x28c>
					return Landing ;
				}
				// first time to switch to ALTHOLD
				LastAltitudeHold = Temp; // measure Altitude
    3f74:	6e 2d       	mov	r22, r14
    3f76:	7f 2d       	mov	r23, r15
    3f78:	80 2f       	mov	r24, r16
    3f7a:	91 2f       	mov	r25, r17
    3f7c:	0e 94 9b 36 	call	0x6d36	; 0x6d36 <__fixunssfsi>
    3f80:	70 93 b9 06 	sts	0x06B9, r23
    3f84:	60 93 b8 06 	sts	0x06B8, r22
				PID_SonarTerms[0].I=0;   // ZERO I
    3f88:	80 e0       	ldi	r24, 0x00	; 0
    3f8a:	90 e0       	ldi	r25, 0x00	; 0
    3f8c:	dc 01       	movw	r26, r24
    3f8e:	80 93 82 07 	sts	0x0782, r24
    3f92:	90 93 83 07 	sts	0x0783, r25
    3f96:	a0 93 84 07 	sts	0x0784, r26
    3f9a:	b0 93 85 07 	sts	0x0785, r27
				bALTHOLD = true;
    3f9e:	81 e0       	ldi	r24, 0x01	; 1
    3fa0:	80 93 27 05 	sts	0x0527, r24
			}
			
			AltDiff = LastAltitudeHold - Temp;
    3fa4:	60 91 b8 06 	lds	r22, 0x06B8
    3fa8:	70 91 b9 06 	lds	r23, 0x06B9
    3fac:	80 e0       	ldi	r24, 0x00	; 0
    3fae:	90 e0       	ldi	r25, 0x00	; 0
    3fb0:	0e 94 c7 36 	call	0x6d8e	; 0x6d8e <__floatunsisf>
    3fb4:	2e 2d       	mov	r18, r14
    3fb6:	3f 2d       	mov	r19, r15
    3fb8:	40 2f       	mov	r20, r16
    3fba:	51 2f       	mov	r21, r17
    3fbc:	0e 94 c5 35 	call	0x6b8a	; 0x6b8a <__subsf3>
    3fc0:	f6 2e       	mov	r15, r22
    3fc2:	07 2f       	mov	r16, r23
    3fc4:	18 2f       	mov	r17, r24
    3fc6:	e9 2e       	mov	r14, r25
    3fc8:	86 2f       	mov	r24, r22
    3fca:	90 2f       	mov	r25, r16
    3fcc:	a1 2f       	mov	r26, r17
    3fce:	be 2d       	mov	r27, r14
    3fd0:	80 93 9c 06 	sts	0x069C, r24
    3fd4:	90 93 9d 06 	sts	0x069D, r25
    3fd8:	a0 93 9e 06 	sts	0x069E, r26
    3fdc:	b0 93 9f 06 	sts	0x069F, r27
			if ((AltDiff<50) && (AltDiff>-50)) // no sudden change or false read
    3fe0:	6f 2d       	mov	r22, r15
    3fe2:	70 2f       	mov	r23, r16
    3fe4:	81 2f       	mov	r24, r17
    3fe6:	9e 2d       	mov	r25, r14
    3fe8:	20 e0       	ldi	r18, 0x00	; 0
    3fea:	30 e0       	ldi	r19, 0x00	; 0
    3fec:	48 e4       	ldi	r20, 0x48	; 72
    3fee:	52 e4       	ldi	r21, 0x42	; 66
    3ff0:	0e 94 2a 36 	call	0x6c54	; 0x6c54 <__cmpsf2>
    3ff4:	87 ff       	sbrs	r24, 7
    3ff6:	5c c0       	rjmp	.+184    	; 0x40b0 <IMU_HeightKeeping+0x236>
    3ff8:	6f 2d       	mov	r22, r15
    3ffa:	70 2f       	mov	r23, r16
    3ffc:	81 2f       	mov	r24, r17
    3ffe:	9e 2d       	mov	r25, r14
    4000:	20 e0       	ldi	r18, 0x00	; 0
    4002:	30 e0       	ldi	r19, 0x00	; 0
    4004:	48 e4       	ldi	r20, 0x48	; 72
    4006:	52 ec       	ldi	r21, 0xC2	; 194
    4008:	0e 94 79 37 	call	0x6ef2	; 0x6ef2 <__gesf2>
    400c:	18 16       	cp	r1, r24
    400e:	0c f0       	brlt	.+2      	; 0x4012 <IMU_HeightKeeping+0x198>
    4010:	4f c0       	rjmp	.+158    	; 0x40b0 <IMU_HeightKeeping+0x236>
			{
				IgnoreTimeOut=0;
    4012:	10 92 22 05 	sts	0x0522, r1
				ThrottleTemp = PID_Calculate (Config.SonarParams[0], &PID_SonarTerms[0],AltDiff) ;	
    4016:	00 d0       	rcall	.+0      	; 0x4018 <IMU_HeightKeeping+0x19e>
    4018:	00 d0       	rcall	.+0      	; 0x401a <IMU_HeightKeeping+0x1a0>
    401a:	8f 2d       	mov	r24, r15
    401c:	90 2f       	mov	r25, r16
    401e:	a1 2f       	mov	r26, r17
    4020:	be 2d       	mov	r27, r14
    4022:	ed b7       	in	r30, 0x3d	; 61
    4024:	fe b7       	in	r31, 0x3e	; 62
    4026:	81 83       	std	Z+1, r24	; 0x01
    4028:	92 83       	std	Z+2, r25	; 0x02
    402a:	a3 83       	std	Z+3, r26	; 0x03
    402c:	b4 83       	std	Z+4, r27	; 0x04
    402e:	c0 90 27 07 	lds	r12, 0x0727
    4032:	d0 90 28 07 	lds	r13, 0x0728
    4036:	e0 90 29 07 	lds	r14, 0x0729
    403a:	f0 90 2a 07 	lds	r15, 0x072A
    403e:	00 91 2b 07 	lds	r16, 0x072B
    4042:	10 91 2c 07 	lds	r17, 0x072C
    4046:	20 91 2d 07 	lds	r18, 0x072D
    404a:	30 91 2e 07 	lds	r19, 0x072E
    404e:	40 91 2f 07 	lds	r20, 0x072F
    4052:	50 91 30 07 	lds	r21, 0x0730
    4056:	60 91 31 07 	lds	r22, 0x0731
    405a:	70 91 32 07 	lds	r23, 0x0732
    405e:	80 91 33 07 	lds	r24, 0x0733
    4062:	90 91 34 07 	lds	r25, 0x0734
    4066:	be e7       	ldi	r27, 0x7E	; 126
    4068:	ab 2e       	mov	r10, r27
    406a:	b7 e0       	ldi	r27, 0x07	; 7
    406c:	bb 2e       	mov	r11, r27
    406e:	0e 94 07 1a 	call	0x340e	; 0x340e <PID_Calculate>
    4072:	0e 94 96 36 	call	0x6d2c	; 0x6d2c <__fixsfsi>
    4076:	7b 01       	movw	r14, r22
    4078:	8c 01       	movw	r16, r24
    407a:	70 93 26 05 	sts	0x0526, r23
    407e:	60 93 25 05 	sts	0x0525, r22
				if (AltDiff==0) 
    4082:	0f 90       	pop	r0
    4084:	0f 90       	pop	r0
    4086:	0f 90       	pop	r0
    4088:	0f 90       	pop	r0
    408a:	60 91 9c 06 	lds	r22, 0x069C
    408e:	70 91 9d 06 	lds	r23, 0x069D
    4092:	80 91 9e 06 	lds	r24, 0x069E
    4096:	90 91 9f 06 	lds	r25, 0x069F
    409a:	20 e0       	ldi	r18, 0x00	; 0
    409c:	30 e0       	ldi	r19, 0x00	; 0
    409e:	a9 01       	movw	r20, r18
    40a0:	0e 94 2a 36 	call	0x6c54	; 0x6c54 <__cmpsf2>
    40a4:	88 23       	and	r24, r24
    40a6:	21 f4       	brne	.+8      	; 0x40b0 <IMU_HeightKeeping+0x236>
				{
					ThrottleZERO = ThrottleTemp;
    40a8:	f0 92 24 05 	sts	0x0524, r15
    40ac:	e0 92 23 05 	sts	0x0523, r14
						
				}
			}
										
			Landing += ThrottleTemp;
    40b0:	60 91 25 05 	lds	r22, 0x0525
    40b4:	70 91 26 05 	lds	r23, 0x0526
    40b8:	04 c0       	rjmp	.+8      	; 0x40c2 <IMU_HeightKeeping+0x248>
		}
		else
		{
			Landing += ThrottleZERO;
    40ba:	60 91 23 05 	lds	r22, 0x0523
    40be:	70 91 24 05 	lds	r23, 0x0524
    40c2:	88 27       	eor	r24, r24
    40c4:	77 fd       	sbrc	r23, 7
    40c6:	80 95       	com	r24
    40c8:	98 2f       	mov	r25, r24
    40ca:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    40ce:	9b 01       	movw	r18, r22
    40d0:	ac 01       	movw	r20, r24
    40d2:	60 91 44 06 	lds	r22, 0x0644
    40d6:	70 91 45 06 	lds	r23, 0x0645
    40da:	80 91 46 06 	lds	r24, 0x0646
    40de:	90 91 47 06 	lds	r25, 0x0647
    40e2:	0e 94 c6 35 	call	0x6b8c	; 0x6b8c <__addsf3>
    40e6:	60 93 44 06 	sts	0x0644, r22
    40ea:	70 93 45 06 	sts	0x0645, r23
    40ee:	80 93 46 06 	sts	0x0646, r24
    40f2:	90 93 47 06 	sts	0x0647, r25
		}
		
		RX_SONAR_TRIGGER = LOW;
    40f6:	48 98       	cbi	0x09, 0	; 9
    40f8:	06 c0       	rjmp	.+12     	; 0x4106 <IMU_HeightKeeping+0x28c>
	}
	else
	{
			ThrottleTemp=0;
    40fa:	10 92 26 05 	sts	0x0526, r1
    40fe:	10 92 25 05 	sts	0x0525, r1
			bALTHOLD=false;
    4102:	10 92 27 05 	sts	0x0527, r1
	}
	
	
	return Landing;
    4106:	70 91 44 06 	lds	r23, 0x0644
    410a:	60 91 45 06 	lds	r22, 0x0645
    410e:	90 91 46 06 	lds	r25, 0x0646
    4112:	80 91 47 06 	lds	r24, 0x0647
    4116:	ab 01       	movw	r20, r22
    4118:	9c 01       	movw	r18, r24
    411a:	65 2f       	mov	r22, r21
    411c:	74 2f       	mov	r23, r20
    411e:	83 2f       	mov	r24, r19
    4120:	92 2f       	mov	r25, r18
    4122:	1f 91       	pop	r17
    4124:	0f 91       	pop	r16
    4126:	ff 90       	pop	r15
    4128:	ef 90       	pop	r14
    412a:	df 90       	pop	r13
    412c:	cf 90       	pop	r12
    412e:	bf 90       	pop	r11
    4130:	af 90       	pop	r10
    4132:	08 95       	ret

00004134 <arctan2>:
  //}
  //z *= (180.0f / PI * 10); 
  //return z;
//}

int arctan2(int y, int x) {                                    // http://www.dspguru.com/comp.dsp/tricks/alg/fxdatan2.htm
    4134:	6f 92       	push	r6
    4136:	7f 92       	push	r7
    4138:	8f 92       	push	r8
    413a:	9f 92       	push	r9
    413c:	af 92       	push	r10
    413e:	bf 92       	push	r11
    4140:	cf 92       	push	r12
    4142:	df 92       	push	r13
    4144:	ef 92       	push	r14
    4146:	ff 92       	push	r15
    4148:	0f 93       	push	r16
    414a:	1f 93       	push	r17
    414c:	cf 93       	push	r28
    414e:	df 93       	push	r29
    4150:	ec 01       	movw	r28, r24
    4152:	6b 01       	movw	r12, r22
   int coeff_1 = 128;                                          // angle in Quids (1024 Quids=360) <<<<<<<<<<<<<<
   int coeff_2 = 3*coeff_1;
   float abs_y = abs(y)+1e-10;
    4154:	bc 01       	movw	r22, r24
    4156:	97 ff       	sbrs	r25, 7
    4158:	04 c0       	rjmp	.+8      	; 0x4162 <arctan2+0x2e>
    415a:	66 27       	eor	r22, r22
    415c:	77 27       	eor	r23, r23
    415e:	68 1b       	sub	r22, r24
    4160:	79 0b       	sbc	r23, r25
    4162:	88 27       	eor	r24, r24
    4164:	77 fd       	sbrc	r23, 7
    4166:	80 95       	com	r24
    4168:	98 2f       	mov	r25, r24
    416a:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    416e:	2f ef       	ldi	r18, 0xFF	; 255
    4170:	36 ee       	ldi	r19, 0xE6	; 230
    4172:	4b ed       	ldi	r20, 0xDB	; 219
    4174:	5e e2       	ldi	r21, 0x2E	; 46
    4176:	0e 94 c6 35 	call	0x6b8c	; 0x6b8c <__addsf3>
    417a:	16 2f       	mov	r17, r22
    417c:	07 2f       	mov	r16, r23
    417e:	f8 2e       	mov	r15, r24
    4180:	e9 2e       	mov	r14, r25
    4182:	b6 01       	movw	r22, r12
    4184:	88 27       	eor	r24, r24
    4186:	77 fd       	sbrc	r23, 7
    4188:	80 95       	com	r24
    418a:	98 2f       	mov	r25, r24
   float r, angle;

   if (x >= 0) {
    418c:	d7 fc       	sbrc	r13, 7
    418e:	2b c0       	rjmp	.+86     	; 0x41e6 <arctan2+0xb2>
     r = (x - abs_y) / (x + abs_y);
    4190:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    4194:	5b 01       	movw	r10, r22
    4196:	6c 01       	movw	r12, r24
    4198:	d8 01       	movw	r26, r16
    419a:	f7 01       	movw	r30, r14
    419c:	2b 2f       	mov	r18, r27
    419e:	3a 2f       	mov	r19, r26
    41a0:	4f 2f       	mov	r20, r31
    41a2:	5e 2f       	mov	r21, r30
    41a4:	0e 94 c5 35 	call	0x6b8a	; 0x6b8a <__subsf3>
    41a8:	3b 01       	movw	r6, r22
    41aa:	4c 01       	movw	r8, r24
    41ac:	c6 01       	movw	r24, r12
    41ae:	b5 01       	movw	r22, r10
    41b0:	d8 01       	movw	r26, r16
    41b2:	f7 01       	movw	r30, r14
    41b4:	2b 2f       	mov	r18, r27
    41b6:	3a 2f       	mov	r19, r26
    41b8:	4f 2f       	mov	r20, r31
    41ba:	5e 2f       	mov	r21, r30
    41bc:	0e 94 c6 35 	call	0x6b8c	; 0x6b8c <__addsf3>
    41c0:	9b 01       	movw	r18, r22
    41c2:	ac 01       	movw	r20, r24
    41c4:	c4 01       	movw	r24, r8
    41c6:	b3 01       	movw	r22, r6
    41c8:	0e 94 2e 36 	call	0x6c5c	; 0x6c5c <__divsf3>
     angle = coeff_1 - coeff_1 * r;
    41cc:	20 e0       	ldi	r18, 0x00	; 0
    41ce:	30 e0       	ldi	r19, 0x00	; 0
    41d0:	40 e0       	ldi	r20, 0x00	; 0
    41d2:	53 e4       	ldi	r21, 0x43	; 67
    41d4:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    41d8:	9b 01       	movw	r18, r22
    41da:	ac 01       	movw	r20, r24
    41dc:	60 e0       	ldi	r22, 0x00	; 0
    41de:	70 e0       	ldi	r23, 0x00	; 0
    41e0:	80 e0       	ldi	r24, 0x00	; 0
    41e2:	93 e4       	ldi	r25, 0x43	; 67
    41e4:	2a c0       	rjmp	.+84     	; 0x423a <arctan2+0x106>
   }  else {
     r = (x + abs_y) / (abs_y - x);
    41e6:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    41ea:	5b 01       	movw	r10, r22
    41ec:	6c 01       	movw	r12, r24
    41ee:	d8 01       	movw	r26, r16
    41f0:	f7 01       	movw	r30, r14
    41f2:	2b 2f       	mov	r18, r27
    41f4:	3a 2f       	mov	r19, r26
    41f6:	4f 2f       	mov	r20, r31
    41f8:	5e 2f       	mov	r21, r30
    41fa:	0e 94 c6 35 	call	0x6b8c	; 0x6b8c <__addsf3>
    41fe:	3b 01       	movw	r6, r22
    4200:	4c 01       	movw	r8, r24
    4202:	a8 01       	movw	r20, r16
    4204:	97 01       	movw	r18, r14
    4206:	65 2f       	mov	r22, r21
    4208:	74 2f       	mov	r23, r20
    420a:	83 2f       	mov	r24, r19
    420c:	92 2f       	mov	r25, r18
    420e:	a6 01       	movw	r20, r12
    4210:	95 01       	movw	r18, r10
    4212:	0e 94 c5 35 	call	0x6b8a	; 0x6b8a <__subsf3>
    4216:	9b 01       	movw	r18, r22
    4218:	ac 01       	movw	r20, r24
    421a:	c4 01       	movw	r24, r8
    421c:	b3 01       	movw	r22, r6
    421e:	0e 94 2e 36 	call	0x6c5c	; 0x6c5c <__divsf3>
     angle = coeff_2 - coeff_1 * r;
    4222:	20 e0       	ldi	r18, 0x00	; 0
    4224:	30 e0       	ldi	r19, 0x00	; 0
    4226:	40 e0       	ldi	r20, 0x00	; 0
    4228:	53 e4       	ldi	r21, 0x43	; 67
    422a:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    422e:	9b 01       	movw	r18, r22
    4230:	ac 01       	movw	r20, r24
    4232:	60 e0       	ldi	r22, 0x00	; 0
    4234:	70 e0       	ldi	r23, 0x00	; 0
    4236:	80 ec       	ldi	r24, 0xC0	; 192
    4238:	93 e4       	ldi	r25, 0x43	; 67
    423a:	0e 94 c5 35 	call	0x6b8a	; 0x6b8a <__subsf3>
   }
   if (y < 0)      return (int)(-angle);
    423e:	d7 fd       	sbrc	r29, 7
    4240:	90 58       	subi	r25, 0x80	; 128
   else            return (int)(angle);
    4242:	0e 94 96 36 	call	0x6d2c	; 0x6d2c <__fixsfsi>
}
    4246:	cb 01       	movw	r24, r22
    4248:	df 91       	pop	r29
    424a:	cf 91       	pop	r28
    424c:	1f 91       	pop	r17
    424e:	0f 91       	pop	r16
    4250:	ff 90       	pop	r15
    4252:	ef 90       	pop	r14
    4254:	df 90       	pop	r13
    4256:	cf 90       	pop	r12
    4258:	bf 90       	pop	r11
    425a:	af 90       	pop	r10
    425c:	9f 90       	pop	r9
    425e:	8f 90       	pop	r8
    4260:	7f 90       	pop	r7
    4262:	6f 90       	pop	r6
    4264:	08 95       	ret

00004266 <Limiterf>:


float Limiterf (float Value, float Limit)
{
    4266:	af 92       	push	r10
    4268:	bf 92       	push	r11
    426a:	cf 92       	push	r12
    426c:	df 92       	push	r13
    426e:	ef 92       	push	r14
    4270:	ff 92       	push	r15
    4272:	0f 93       	push	r16
    4274:	1f 93       	push	r17
    4276:	d6 2e       	mov	r13, r22
    4278:	c7 2e       	mov	r12, r23
    427a:	b8 2e       	mov	r11, r24
    427c:	a9 2e       	mov	r10, r25
    427e:	79 01       	movw	r14, r18
    4280:	8a 01       	movw	r16, r20
	if (Value > Limit) return   Limit;
    4282:	a6 01       	movw	r20, r12
    4284:	95 01       	movw	r18, r10
    4286:	65 2f       	mov	r22, r21
    4288:	74 2f       	mov	r23, r20
    428a:	83 2f       	mov	r24, r19
    428c:	92 2f       	mov	r25, r18
    428e:	a8 01       	movw	r20, r16
    4290:	97 01       	movw	r18, r14
    4292:	0e 94 79 37 	call	0x6ef2	; 0x6ef2 <__gesf2>
    4296:	18 16       	cp	r1, r24
    4298:	b4 f0       	brlt	.+44     	; 0x42c6 <Limiterf+0x60>
	if (Value < -Limit) return -Limit;
    429a:	17 fb       	bst	r17, 7
    429c:	10 95       	com	r17
    429e:	17 f9       	bld	r17, 7
    42a0:	10 95       	com	r17
    42a2:	a6 01       	movw	r20, r12
    42a4:	95 01       	movw	r18, r10
    42a6:	65 2f       	mov	r22, r21
    42a8:	74 2f       	mov	r23, r20
    42aa:	83 2f       	mov	r24, r19
    42ac:	92 2f       	mov	r25, r18
    42ae:	a8 01       	movw	r20, r16
    42b0:	97 01       	movw	r18, r14
    42b2:	0e 94 2a 36 	call	0x6c54	; 0x6c54 <__cmpsf2>
    42b6:	87 fd       	sbrc	r24, 7
    42b8:	06 c0       	rjmp	.+12     	; 0x42c6 <Limiterf+0x60>
	
	return Value;
    42ba:	96 01       	movw	r18, r12
    42bc:	c5 01       	movw	r24, r10
    42be:	e3 2e       	mov	r14, r19
    42c0:	f2 2e       	mov	r15, r18
    42c2:	09 2f       	mov	r16, r25
    42c4:	18 2f       	mov	r17, r24
}
    42c6:	6e 2d       	mov	r22, r14
    42c8:	7f 2d       	mov	r23, r15
    42ca:	80 2f       	mov	r24, r16
    42cc:	91 2f       	mov	r25, r17
    42ce:	1f 91       	pop	r17
    42d0:	0f 91       	pop	r16
    42d2:	ff 90       	pop	r15
    42d4:	ef 90       	pop	r14
    42d6:	df 90       	pop	r13
    42d8:	cf 90       	pop	r12
    42da:	bf 90       	pop	r11
    42dc:	af 90       	pop	r10
    42de:	08 95       	ret

000042e0 <Limiter>:

int16_t Limiter (int16_t Value, int16_t Limit)
{
	if (Value > Limit) return   Limit;
    42e0:	68 17       	cp	r22, r24
    42e2:	79 07       	cpc	r23, r25
    42e4:	3c f0       	brlt	.+14     	; 0x42f4 <Limiter+0x14>
	if (Value < -Limit) return -Limit;
    42e6:	70 95       	com	r23
    42e8:	61 95       	neg	r22
    42ea:	7f 4f       	sbci	r23, 0xFF	; 255
    42ec:	68 17       	cp	r22, r24
    42ee:	79 07       	cpc	r23, r25
    42f0:	0c f4       	brge	.+2      	; 0x42f4 <Limiter+0x14>
    42f2:	bc 01       	movw	r22, r24
	
	return Value;
}
    42f4:	cb 01       	movw	r24, r22
    42f6:	08 95       	ret

000042f8 <ScaleSensor>:
			 return (int16_t) y;
		}
	   }	
		*/
	return 0;	
}
    42f8:	80 e0       	ldi	r24, 0x00	; 0
    42fa:	90 e0       	ldi	r25, 0x00	; 0
    42fc:	08 95       	ret

000042fe <_atan2>:



int16_t _atan2(int32_t y, int32_t x)
{
    42fe:	2f 92       	push	r2
    4300:	3f 92       	push	r3
    4302:	4f 92       	push	r4
    4304:	5f 92       	push	r5
    4306:	6f 92       	push	r6
    4308:	7f 92       	push	r7
    430a:	8f 92       	push	r8
    430c:	9f 92       	push	r9
    430e:	af 92       	push	r10
    4310:	bf 92       	push	r11
    4312:	cf 92       	push	r12
    4314:	df 92       	push	r13
    4316:	ef 92       	push	r14
    4318:	ff 92       	push	r15
    431a:	0f 93       	push	r16
    431c:	1f 93       	push	r17
    431e:	5b 01       	movw	r10, r22
    4320:	6c 01       	movw	r12, r24
    4322:	39 01       	movw	r6, r18
    4324:	4a 01       	movw	r8, r20
	float z = (float)y / x;
    4326:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    432a:	7b 01       	movw	r14, r22
    432c:	8c 01       	movw	r16, r24
    432e:	c4 01       	movw	r24, r8
    4330:	b3 01       	movw	r22, r6
    4332:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    4336:	9b 01       	movw	r18, r22
    4338:	ac 01       	movw	r20, r24
    433a:	c8 01       	movw	r24, r16
    433c:	b7 01       	movw	r22, r14
    433e:	0e 94 2e 36 	call	0x6c5c	; 0x6c5c <__divsf3>
    4342:	f6 2e       	mov	r15, r22
    4344:	07 2f       	mov	r16, r23
    4346:	18 2f       	mov	r17, r24
    4348:	e9 2e       	mov	r14, r25
	int16_t a;
	if ( abs(y) < abs(x) ){
    434a:	95 01       	movw	r18, r10
    434c:	b7 fe       	sbrs	r11, 7
    434e:	03 c0       	rjmp	.+6      	; 0x4356 <_atan2+0x58>
    4350:	30 95       	com	r19
    4352:	21 95       	neg	r18
    4354:	3f 4f       	sbci	r19, 0xFF	; 255
    4356:	c3 01       	movw	r24, r6
    4358:	77 fe       	sbrs	r7, 7
    435a:	03 c0       	rjmp	.+6      	; 0x4362 <_atan2+0x64>
    435c:	90 95       	com	r25
    435e:	81 95       	neg	r24
    4360:	9f 4f       	sbci	r25, 0xFF	; 255
    4362:	28 17       	cp	r18, r24
    4364:	39 07       	cpc	r19, r25
    4366:	8c f5       	brge	.+98     	; 0x43ca <_atan2+0xcc>
		a = 573 * z / (1.0f + 0.28f * z * z);
    4368:	6f 2d       	mov	r22, r15
    436a:	70 2f       	mov	r23, r16
    436c:	81 2f       	mov	r24, r17
    436e:	9e 2d       	mov	r25, r14
    4370:	20 e0       	ldi	r18, 0x00	; 0
    4372:	30 e4       	ldi	r19, 0x40	; 64
    4374:	4f e0       	ldi	r20, 0x0F	; 15
    4376:	54 e4       	ldi	r21, 0x44	; 68
    4378:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    437c:	1b 01       	movw	r2, r22
    437e:	2c 01       	movw	r4, r24
    4380:	6f 2d       	mov	r22, r15
    4382:	70 2f       	mov	r23, r16
    4384:	81 2f       	mov	r24, r17
    4386:	9e 2d       	mov	r25, r14
    4388:	29 e2       	ldi	r18, 0x29	; 41
    438a:	3c e5       	ldi	r19, 0x5C	; 92
    438c:	4f e8       	ldi	r20, 0x8F	; 143
    438e:	5e e3       	ldi	r21, 0x3E	; 62
    4390:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    4394:	2f 2d       	mov	r18, r15
    4396:	30 2f       	mov	r19, r16
    4398:	41 2f       	mov	r20, r17
    439a:	5e 2d       	mov	r21, r14
    439c:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    43a0:	20 e0       	ldi	r18, 0x00	; 0
    43a2:	30 e0       	ldi	r19, 0x00	; 0
    43a4:	40 e8       	ldi	r20, 0x80	; 128
    43a6:	5f e3       	ldi	r21, 0x3F	; 63
    43a8:	0e 94 c6 35 	call	0x6b8c	; 0x6b8c <__addsf3>
    43ac:	9b 01       	movw	r18, r22
    43ae:	ac 01       	movw	r20, r24
    43b0:	c2 01       	movw	r24, r4
    43b2:	b1 01       	movw	r22, r2
    43b4:	0e 94 2e 36 	call	0x6c5c	; 0x6c5c <__divsf3>
    43b8:	0e 94 96 36 	call	0x6d2c	; 0x6d2c <__fixsfsi>
		if (x<0) {
    43bc:	97 fe       	sbrs	r9, 7
    43be:	35 c0       	rjmp	.+106    	; 0x442a <_atan2+0x12c>
			if (y<0) a -= 1800;
    43c0:	d7 fc       	sbrc	r13, 7
    43c2:	31 c0       	rjmp	.+98     	; 0x4426 <_atan2+0x128>
			else a += 1800;
    43c4:	68 5f       	subi	r22, 0xF8	; 248
    43c6:	78 4f       	sbci	r23, 0xF8	; 248
    43c8:	30 c0       	rjmp	.+96     	; 0x442a <_atan2+0x12c>
		}
	} else {
		a = 900 - 573 * z / (z * z + 0.28f);
    43ca:	6f 2d       	mov	r22, r15
    43cc:	70 2f       	mov	r23, r16
    43ce:	81 2f       	mov	r24, r17
    43d0:	9e 2d       	mov	r25, r14
    43d2:	20 e0       	ldi	r18, 0x00	; 0
    43d4:	30 e4       	ldi	r19, 0x40	; 64
    43d6:	4f e0       	ldi	r20, 0x0F	; 15
    43d8:	54 e4       	ldi	r21, 0x44	; 68
    43da:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    43de:	3b 01       	movw	r6, r22
    43e0:	4c 01       	movw	r8, r24
    43e2:	6f 2d       	mov	r22, r15
    43e4:	70 2f       	mov	r23, r16
    43e6:	81 2f       	mov	r24, r17
    43e8:	9e 2d       	mov	r25, r14
    43ea:	2f 2d       	mov	r18, r15
    43ec:	30 2f       	mov	r19, r16
    43ee:	41 2f       	mov	r20, r17
    43f0:	5e 2d       	mov	r21, r14
    43f2:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    43f6:	29 e2       	ldi	r18, 0x29	; 41
    43f8:	3c e5       	ldi	r19, 0x5C	; 92
    43fa:	4f e8       	ldi	r20, 0x8F	; 143
    43fc:	5e e3       	ldi	r21, 0x3E	; 62
    43fe:	0e 94 c6 35 	call	0x6b8c	; 0x6b8c <__addsf3>
    4402:	9b 01       	movw	r18, r22
    4404:	ac 01       	movw	r20, r24
    4406:	c4 01       	movw	r24, r8
    4408:	b3 01       	movw	r22, r6
    440a:	0e 94 2e 36 	call	0x6c5c	; 0x6c5c <__divsf3>
    440e:	9b 01       	movw	r18, r22
    4410:	ac 01       	movw	r20, r24
    4412:	60 e0       	ldi	r22, 0x00	; 0
    4414:	70 e0       	ldi	r23, 0x00	; 0
    4416:	81 e6       	ldi	r24, 0x61	; 97
    4418:	94 e4       	ldi	r25, 0x44	; 68
    441a:	0e 94 c5 35 	call	0x6b8a	; 0x6b8a <__subsf3>
    441e:	0e 94 96 36 	call	0x6d2c	; 0x6d2c <__fixsfsi>
		if (y<0) a -= 1800;
    4422:	d7 fe       	sbrs	r13, 7
    4424:	02 c0       	rjmp	.+4      	; 0x442a <_atan2+0x12c>
    4426:	68 50       	subi	r22, 0x08	; 8
    4428:	77 40       	sbci	r23, 0x07	; 7
	}
	return a;
}
    442a:	cb 01       	movw	r24, r22
    442c:	1f 91       	pop	r17
    442e:	0f 91       	pop	r16
    4430:	ff 90       	pop	r15
    4432:	ef 90       	pop	r14
    4434:	df 90       	pop	r13
    4436:	cf 90       	pop	r12
    4438:	bf 90       	pop	r11
    443a:	af 90       	pop	r10
    443c:	9f 90       	pop	r9
    443e:	8f 90       	pop	r8
    4440:	7f 90       	pop	r7
    4442:	6f 90       	pop	r6
    4444:	5f 90       	pop	r5
    4446:	4f 90       	pop	r4
    4448:	3f 90       	pop	r3
    444a:	2f 90       	pop	r2
    444c:	08 95       	ret

0000444e <InvSqrt>:

float InvSqrt (float x)
{
    444e:	6f 92       	push	r6
    4450:	7f 92       	push	r7
    4452:	8f 92       	push	r8
    4454:	9f 92       	push	r9
    4456:	af 92       	push	r10
    4458:	bf 92       	push	r11
    445a:	cf 92       	push	r12
    445c:	df 92       	push	r13
    445e:	ef 92       	push	r14
    4460:	ff 92       	push	r15
    4462:	0f 93       	push	r16
    4464:	1f 93       	push	r17
    4466:	5b 01       	movw	r10, r22
    4468:	6c 01       	movw	r12, r24
	union{
		int32_t i;
		float   f;
	} conv;
	conv.f = x;
	conv.i = 0x5f3759df - (conv.i >> 1);
    446a:	dc 01       	movw	r26, r24
    446c:	cb 01       	movw	r24, r22
    446e:	b5 95       	asr	r27
    4470:	a7 95       	ror	r26
    4472:	97 95       	ror	r25
    4474:	87 95       	ror	r24
    4476:	2f ed       	ldi	r18, 0xDF	; 223
    4478:	e2 2e       	mov	r14, r18
    447a:	29 e5       	ldi	r18, 0x59	; 89
    447c:	f2 2e       	mov	r15, r18
    447e:	27 e3       	ldi	r18, 0x37	; 55
    4480:	02 2f       	mov	r16, r18
    4482:	2f e5       	ldi	r18, 0x5F	; 95
    4484:	12 2f       	mov	r17, r18
    4486:	e8 1a       	sub	r14, r24
    4488:	f9 0a       	sbc	r15, r25
    448a:	0a 0b       	sbc	r16, r26
    448c:	1b 0b       	sbc	r17, r27
	return 0.5f * conv.f * (3.0f - x * conv.f * conv.f);
    448e:	c8 01       	movw	r24, r16
    4490:	b7 01       	movw	r22, r14
    4492:	20 e0       	ldi	r18, 0x00	; 0
    4494:	30 e0       	ldi	r19, 0x00	; 0
    4496:	40 e0       	ldi	r20, 0x00	; 0
    4498:	5f e3       	ldi	r21, 0x3F	; 63
    449a:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    449e:	3b 01       	movw	r6, r22
    44a0:	4c 01       	movw	r8, r24
    44a2:	c6 01       	movw	r24, r12
    44a4:	b5 01       	movw	r22, r10
    44a6:	a8 01       	movw	r20, r16
    44a8:	97 01       	movw	r18, r14
    44aa:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    44ae:	a8 01       	movw	r20, r16
    44b0:	97 01       	movw	r18, r14
    44b2:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
    44b6:	9b 01       	movw	r18, r22
    44b8:	ac 01       	movw	r20, r24
    44ba:	60 e0       	ldi	r22, 0x00	; 0
    44bc:	70 e0       	ldi	r23, 0x00	; 0
    44be:	80 e4       	ldi	r24, 0x40	; 64
    44c0:	90 e4       	ldi	r25, 0x40	; 64
    44c2:	0e 94 c5 35 	call	0x6b8a	; 0x6b8a <__subsf3>
    44c6:	9b 01       	movw	r18, r22
    44c8:	ac 01       	movw	r20, r24
    44ca:	c4 01       	movw	r24, r8
    44cc:	b3 01       	movw	r22, r6
    44ce:	0e 94 7d 37 	call	0x6efa	; 0x6efa <__mulsf3>
}
    44d2:	1f 91       	pop	r17
    44d4:	0f 91       	pop	r16
    44d6:	ff 90       	pop	r15
    44d8:	ef 90       	pop	r14
    44da:	df 90       	pop	r13
    44dc:	cf 90       	pop	r12
    44de:	bf 90       	pop	r11
    44e0:	af 90       	pop	r10
    44e2:	9f 90       	pop	r9
    44e4:	8f 90       	pop	r8
    44e6:	7f 90       	pop	r7
    44e8:	6f 90       	pop	r6
    44ea:	08 95       	ret

000044ec <Motor_GenerateOutputSignal>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    44ec:	f8 94       	cli
	
	// Make sure we have spent enough time between pulses
	// Also, handle the odd case where the TCNT2_X rolls over and TCNT2_X < ElapsedTCNT2
	ATOMIC_BLOCK(ATOMIC_FORCEON)
   {
      CurrentTCNT2 = TCNT2_X;
    44ee:	80 91 a9 05 	lds	r24, 0x05A9
    44f2:	90 91 aa 05 	lds	r25, 0x05AA
    44f6:	90 93 e0 07 	sts	0x07E0, r25
    44fa:	80 93 df 07 	sts	0x07DF, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    44fe:	78 94       	sei
   }

   if (CurrentTCNT2 >= MotorStartTCNT) 
    4500:	20 91 df 07 	lds	r18, 0x07DF
    4504:	30 91 e0 07 	lds	r19, 0x07E0
    4508:	80 91 d2 07 	lds	r24, 0x07D2
    450c:	90 91 d3 07 	lds	r25, 0x07D3
    4510:	28 17       	cp	r18, r24
    4512:	39 07       	cpc	r19, r25
    4514:	38 f0       	brcs	.+14     	; 0x4524 <Motor_GenerateOutputSignal+0x38>
   {
		ElapsedTCNT2 = CurrentTCNT2 - MotorStartTCNT;
    4516:	28 1b       	sub	r18, r24
    4518:	39 0b       	sbc	r19, r25
    451a:	30 93 cd 07 	sts	0x07CD, r19
    451e:	20 93 cc 07 	sts	0x07CC, r18
    4522:	08 c0       	rjmp	.+16     	; 0x4534 <Motor_GenerateOutputSignal+0x48>
   }
   else 
   {
		ElapsedTCNT2 = (0xffff - MotorStartTCNT) + CurrentTCNT2;
    4524:	80 95       	com	r24
    4526:	90 95       	com	r25
    4528:	82 0f       	add	r24, r18
    452a:	93 1f       	adc	r25, r19
    452c:	90 93 cd 07 	sts	0x07CD, r25
    4530:	80 93 cc 07 	sts	0x07CC, r24
	
	// If period less than 1/ESC_RATE, pad it out.
	// check Timer.c for timing table
	
	//interval in us
	PMW_Pulse_Interval = (PWM_LOW_PULSE_INTERVAL - ( ElapsedTCNT2 * 409)); // 409 = OV time of TCNT2
    4534:	40 91 cc 07 	lds	r20, 0x07CC
    4538:	50 91 cd 07 	lds	r21, 0x07CD
    453c:	89 e9       	ldi	r24, 0x99	; 153
    453e:	91 e0       	ldi	r25, 0x01	; 1
    4540:	48 9f       	mul	r20, r24
    4542:	90 01       	movw	r18, r0
    4544:	49 9f       	mul	r20, r25
    4546:	30 0d       	add	r19, r0
    4548:	58 9f       	mul	r21, r24
    454a:	30 0d       	add	r19, r0
    454c:	11 24       	eor	r1, r1
    454e:	80 ea       	ldi	r24, 0xA0	; 160
    4550:	9f e0       	ldi	r25, 0x0F	; 15
    4552:	82 1b       	sub	r24, r18
    4554:	93 0b       	sbc	r25, r19
    4556:	0d c0       	rjmp	.+26     	; 0x4572 <Motor_GenerateOutputSignal+0x86>
	while (PMW_Pulse_Interval > 0)
	{
		//LED_Orange=~LED_Orange;
			TCNT2 =0;
    4558:	10 92 b2 00 	sts	0x00B2, r1
			if (PMW_Pulse_Interval>100)
    455c:	85 36       	cpi	r24, 0x65	; 101
    455e:	91 05       	cpc	r25, r1
    4560:	3c f0       	brlt	.+14     	; 0x4570 <Motor_GenerateOutputSignal+0x84>
			{   // make big jumps if PWM_Low_Pulse_Interval is high
				// [more accurate to decrease the % between the while loop and the PWM_Low_Pulse_Interval -=80 execution time.]
				while (TCNT2 < 40); //=8us 1.50
    4562:	20 91 b2 00 	lds	r18, 0x00B2
    4566:	28 32       	cpi	r18, 0x28	; 40
    4568:	e0 f3       	brcs	.-8      	; 0x4562 <Motor_GenerateOutputSignal+0x76>
				PMW_Pulse_Interval -=80;	
    456a:	80 55       	subi	r24, 0x50	; 80
    456c:	90 40       	sbci	r25, 0x00	; 0
    456e:	01 c0       	rjmp	.+2      	; 0x4572 <Motor_GenerateOutputSignal+0x86>
			}
			else
			{   //
				///////////while (TCNT2 < 5); //=8us
				PMW_Pulse_Interval -=1;
    4570:	01 97       	sbiw	r24, 0x01	; 1
    4572:	90 93 d8 07 	sts	0x07D8, r25
    4576:	80 93 d7 07 	sts	0x07D7, r24
	// If period less than 1/ESC_RATE, pad it out.
	// check Timer.c for timing table
	
	//interval in us
	PMW_Pulse_Interval = (PWM_LOW_PULSE_INTERVAL - ( ElapsedTCNT2 * 409)); // 409 = OV time of TCNT2
	while (PMW_Pulse_Interval > 0)
    457a:	80 91 d7 07 	lds	r24, 0x07D7
    457e:	90 91 d8 07 	lds	r25, 0x07D8
    4582:	18 16       	cp	r1, r24
    4584:	19 06       	cpc	r1, r25
    4586:	44 f3       	brlt	.-48     	; 0x4558 <Motor_GenerateOutputSignal+0x6c>
				PMW_Pulse_Interval -=1;
			}
			
	}
	
	times+=1;
    4588:	80 91 28 05 	lds	r24, 0x0528
    458c:	8f 5f       	subi	r24, 0xFF	; 255
    458e:	80 93 28 05 	sts	0x0528, r24
	
	// Set motor limits (0 -> MOTORS_HIGH_VALUE)
	if ( MotorOut[0] < 0 ) m1 = 0;
    4592:	80 91 84 05 	lds	r24, 0x0584
    4596:	90 91 85 05 	lds	r25, 0x0585
    459a:	97 ff       	sbrs	r25, 7
    459c:	05 c0       	rjmp	.+10     	; 0x45a8 <Motor_GenerateOutputSignal+0xbc>
    459e:	10 92 da 07 	sts	0x07DA, r1
    45a2:	10 92 d9 07 	sts	0x07D9, r1
    45a6:	0a c0       	rjmp	.+20     	; 0x45bc <Motor_GenerateOutputSignal+0xd0>
	else if ( MotorOut[0] > MOTORS_HIGH_VALUE ) m1 = MOTORS_HIGH_VALUE;
    45a8:	24 e0       	ldi	r18, 0x04	; 4
    45aa:	8f 37       	cpi	r24, 0x7F	; 127
    45ac:	92 07       	cpc	r25, r18
    45ae:	14 f0       	brlt	.+4      	; 0x45b4 <Motor_GenerateOutputSignal+0xc8>
    45b0:	8e e7       	ldi	r24, 0x7E	; 126
    45b2:	94 e0       	ldi	r25, 0x04	; 4
	else m1 = MotorOut[0];
    45b4:	90 93 da 07 	sts	0x07DA, r25
    45b8:	80 93 d9 07 	sts	0x07D9, r24
	
	if ( MotorOut[1] < 0 ) m2 = 0;
    45bc:	80 91 86 05 	lds	r24, 0x0586
    45c0:	90 91 87 05 	lds	r25, 0x0587
    45c4:	97 ff       	sbrs	r25, 7
    45c6:	05 c0       	rjmp	.+10     	; 0x45d2 <Motor_GenerateOutputSignal+0xe6>
    45c8:	10 92 d1 07 	sts	0x07D1, r1
    45cc:	10 92 d0 07 	sts	0x07D0, r1
    45d0:	0a c0       	rjmp	.+20     	; 0x45e6 <Motor_GenerateOutputSignal+0xfa>
	else if ( MotorOut[1] > MOTORS_HIGH_VALUE ) m2 = MOTORS_HIGH_VALUE;
    45d2:	24 e0       	ldi	r18, 0x04	; 4
    45d4:	8f 37       	cpi	r24, 0x7F	; 127
    45d6:	92 07       	cpc	r25, r18
    45d8:	14 f0       	brlt	.+4      	; 0x45de <Motor_GenerateOutputSignal+0xf2>
    45da:	8e e7       	ldi	r24, 0x7E	; 126
    45dc:	94 e0       	ldi	r25, 0x04	; 4
	else m2 = MotorOut[1];
    45de:	90 93 d1 07 	sts	0x07D1, r25
    45e2:	80 93 d0 07 	sts	0x07D0, r24

	if ( MotorOut[2] < 0 ) m3 = 0;
    45e6:	80 91 88 05 	lds	r24, 0x0588
    45ea:	90 91 89 05 	lds	r25, 0x0589
    45ee:	97 ff       	sbrs	r25, 7
    45f0:	05 c0       	rjmp	.+10     	; 0x45fc <Motor_GenerateOutputSignal+0x110>
    45f2:	10 92 de 07 	sts	0x07DE, r1
    45f6:	10 92 dd 07 	sts	0x07DD, r1
    45fa:	0a c0       	rjmp	.+20     	; 0x4610 <Motor_GenerateOutputSignal+0x124>
	else if ( MotorOut[2] > MOTORS_HIGH_VALUE ) m3 = MOTORS_HIGH_VALUE;
    45fc:	24 e0       	ldi	r18, 0x04	; 4
    45fe:	8f 37       	cpi	r24, 0x7F	; 127
    4600:	92 07       	cpc	r25, r18
    4602:	14 f0       	brlt	.+4      	; 0x4608 <Motor_GenerateOutputSignal+0x11c>
    4604:	8e e7       	ldi	r24, 0x7E	; 126
    4606:	94 e0       	ldi	r25, 0x04	; 4
	else m3 = MotorOut[2];
    4608:	90 93 de 07 	sts	0x07DE, r25
    460c:	80 93 dd 07 	sts	0x07DD, r24

	if ( MotorOut[3] < 0 ) m4 = 0;
    4610:	80 91 8a 05 	lds	r24, 0x058A
    4614:	90 91 8b 05 	lds	r25, 0x058B
    4618:	97 ff       	sbrs	r25, 7
    461a:	05 c0       	rjmp	.+10     	; 0x4626 <Motor_GenerateOutputSignal+0x13a>
    461c:	10 92 cf 07 	sts	0x07CF, r1
    4620:	10 92 ce 07 	sts	0x07CE, r1
    4624:	0a c0       	rjmp	.+20     	; 0x463a <Motor_GenerateOutputSignal+0x14e>
	else if ( MotorOut[3] > MOTORS_HIGH_VALUE ) m4 = MOTORS_HIGH_VALUE;
    4626:	24 e0       	ldi	r18, 0x04	; 4
    4628:	8f 37       	cpi	r24, 0x7F	; 127
    462a:	92 07       	cpc	r25, r18
    462c:	14 f0       	brlt	.+4      	; 0x4632 <Motor_GenerateOutputSignal+0x146>
    462e:	8e e7       	ldi	r24, 0x7E	; 126
    4630:	94 e0       	ldi	r25, 0x04	; 4
	else m4 = MotorOut[3];
    4632:	90 93 cf 07 	sts	0x07CF, r25
    4636:	80 93 ce 07 	sts	0x07CE, r24
	
	
	// Minimum pulse we want to make is 1ms, max is 2ms
	// So to start, let's make the 1ms base pulse.
	// First, we switch on the motor outputs
	M1 = 1;
    463a:	46 9a       	sbi	0x08, 6	; 8
	M2 = 1;
    463c:	44 9a       	sbi	0x08, 4	; 8
	M3 = 1;
    463e:	42 9a       	sbi	0x08, 2	; 8
	if (Config.FrameType== FRAMETYPE_QUADCOPTER) 
    4640:	80 91 cc 06 	lds	r24, 0x06CC
    4644:	81 30       	cpi	r24, 0x01	; 1
    4646:	11 f4       	brne	.+4      	; 0x464c <Motor_GenerateOutputSignal+0x160>
	{
		M4 =1;
    4648:	43 9a       	sbi	0x08, 3	; 8
    464a:	09 c0       	rjmp	.+18     	; 0x465e <Motor_GenerateOutputSignal+0x172>
	}
	else if (Config.FrameType== FRAMETYPE_TRICOPTER)
    464c:	82 30       	cpi	r24, 0x02	; 2
    464e:	39 f4       	brne	.+14     	; 0x465e <Motor_GenerateOutputSignal+0x172>
	{
		if (times==5)
    4650:	80 91 28 05 	lds	r24, 0x0528
    4654:	85 30       	cpi	r24, 0x05	; 5
    4656:	19 f4       	brne	.+6      	; 0x465e <Motor_GenerateOutputSignal+0x172>
		{
			M4 = 1;		// time to update servo
    4658:	43 9a       	sbi	0x08, 3	; 8
			//UpdateServo = FALSE;
			times=0;	// reset time divider
    465a:	10 92 28 05 	sts	0x0528, r1
		} // else keep it zero.			
	} 
	
	
	// Minimum pulse width we want to make is 1ms, max is 2ms
	PMW_Pulse_Interval = BASE_PULSE + Config.ThrottleMin;
    465e:	80 91 d0 06 	lds	r24, 0x06D0
    4662:	90 e0       	ldi	r25, 0x00	; 0
    4664:	80 5e       	subi	r24, 0xE0	; 224
    4666:	9c 4f       	sbci	r25, 0xFC	; 252
    4668:	0d c0       	rjmp	.+26     	; 0x4684 <Motor_GenerateOutputSignal+0x198>
	while (PMW_Pulse_Interval > 0)
	{
			TCNT2 =0;
    466a:	10 92 b2 00 	sts	0x00B2, r1
			if (PMW_Pulse_Interval>100)
    466e:	85 36       	cpi	r24, 0x65	; 101
    4670:	91 05       	cpc	r25, r1
    4672:	3c f0       	brlt	.+14     	; 0x4682 <Motor_GenerateOutputSignal+0x196>
			{   // make big jumps if PWM_Low_Pulse_Interval is high
				// [more accurate to decrease the % between the while loop and the PWM_Low_Pulse_Interval -=80 execution time.]
				while (TCNT2 < 45); //=8us //1. 50
    4674:	20 91 b2 00 	lds	r18, 0x00B2
    4678:	2d 32       	cpi	r18, 0x2D	; 45
    467a:	e0 f3       	brcs	.-8      	; 0x4674 <Motor_GenerateOutputSignal+0x188>
				PMW_Pulse_Interval -=80;	
    467c:	80 55       	subi	r24, 0x50	; 80
    467e:	90 40       	sbci	r25, 0x00	; 0
    4680:	01 c0       	rjmp	.+2      	; 0x4684 <Motor_GenerateOutputSignal+0x198>
			}
			else
			{   //
				//////while (TCNT2 < 5); //=8us
				PMW_Pulse_Interval -=1;
    4682:	01 97       	sbiw	r24, 0x01	; 1
    4684:	90 93 d8 07 	sts	0x07D8, r25
    4688:	80 93 d7 07 	sts	0x07D7, r24
	} 
	
	
	// Minimum pulse width we want to make is 1ms, max is 2ms
	PMW_Pulse_Interval = BASE_PULSE + Config.ThrottleMin;
	while (PMW_Pulse_Interval > 0)
    468c:	80 91 d7 07 	lds	r24, 0x07D7
    4690:	90 91 d8 07 	lds	r25, 0x07D8
    4694:	18 16       	cp	r1, r24
    4696:	19 06       	cpc	r1, r25
    4698:	44 f3       	brlt	.-48     	; 0x466a <Motor_GenerateOutputSignal+0x17e>
				PMW_Pulse_Interval -=1;
			}
	}
		
	
	for (i=0;i<MOTORS_HIGH_VALUE+4;i+=4)			// 1000 gives a max of 2200us 
    469a:	10 92 d6 07 	sts	0x07D6, r1
    469e:	10 92 d5 07 	sts	0x07D5, r1
    46a2:	39 c0       	rjmp	.+114    	; 0x4716 <Motor_GenerateOutputSignal+0x22a>
		/*
		MOTORS_HIGH_VALUE+4
		in order to guarantee that all Ms are zeros when getting out of this loop.
		*/
		
		if (i>=m1) M1 = 0;
    46a4:	20 91 d5 07 	lds	r18, 0x07D5
    46a8:	30 91 d6 07 	lds	r19, 0x07D6
    46ac:	80 91 d9 07 	lds	r24, 0x07D9
    46b0:	90 91 da 07 	lds	r25, 0x07DA
    46b4:	28 17       	cp	r18, r24
    46b6:	39 07       	cpc	r19, r25
    46b8:	08 f0       	brcs	.+2      	; 0x46bc <Motor_GenerateOutputSignal+0x1d0>
    46ba:	46 98       	cbi	0x08, 6	; 8
		if (i>=m2) M2 = 0;
    46bc:	20 91 d5 07 	lds	r18, 0x07D5
    46c0:	30 91 d6 07 	lds	r19, 0x07D6
    46c4:	80 91 d0 07 	lds	r24, 0x07D0
    46c8:	90 91 d1 07 	lds	r25, 0x07D1
    46cc:	28 17       	cp	r18, r24
    46ce:	39 07       	cpc	r19, r25
    46d0:	08 f0       	brcs	.+2      	; 0x46d4 <Motor_GenerateOutputSignal+0x1e8>
    46d2:	44 98       	cbi	0x08, 4	; 8
		if (i>=m3) M3 = 0;
    46d4:	20 91 d5 07 	lds	r18, 0x07D5
    46d8:	30 91 d6 07 	lds	r19, 0x07D6
    46dc:	80 91 dd 07 	lds	r24, 0x07DD
    46e0:	90 91 de 07 	lds	r25, 0x07DE
    46e4:	28 17       	cp	r18, r24
    46e6:	39 07       	cpc	r19, r25
    46e8:	08 f0       	brcs	.+2      	; 0x46ec <Motor_GenerateOutputSignal+0x200>
    46ea:	42 98       	cbi	0x08, 2	; 8
		if (i>=m4) M4 = 0;
    46ec:	20 91 d5 07 	lds	r18, 0x07D5
    46f0:	30 91 d6 07 	lds	r19, 0x07D6
    46f4:	80 91 ce 07 	lds	r24, 0x07CE
    46f8:	90 91 cf 07 	lds	r25, 0x07CF
    46fc:	28 17       	cp	r18, r24
    46fe:	39 07       	cpc	r19, r25
    4700:	08 f0       	brcs	.+2      	; 0x4704 <Motor_GenerateOutputSignal+0x218>
    4702:	43 98       	cbi	0x08, 3	; 8
				PMW_Pulse_Interval -=1;
			}
	}
		
	
	for (i=0;i<MOTORS_HIGH_VALUE+4;i+=4)			// 1000 gives a max of 2200us 
    4704:	80 91 d5 07 	lds	r24, 0x07D5
    4708:	90 91 d6 07 	lds	r25, 0x07D6
    470c:	04 96       	adiw	r24, 0x04	; 4
    470e:	90 93 d6 07 	sts	0x07D6, r25
    4712:	80 93 d5 07 	sts	0x07D5, r24
    4716:	80 91 d5 07 	lds	r24, 0x07D5
    471a:	90 91 d6 07 	lds	r25, 0x07D6
    471e:	24 e0       	ldi	r18, 0x04	; 4
    4720:	82 38       	cpi	r24, 0x82	; 130
    4722:	92 07       	cpc	r25, r18
    4724:	08 f4       	brcc	.+2      	; 0x4728 <Motor_GenerateOutputSignal+0x23c>
    4726:	be cf       	rjmp	.-132    	; 0x46a4 <Motor_GenerateOutputSignal+0x1b8>
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    4728:	f8 94       	cli
		if (i>=m4) M4 = 0;
	}
	// Measure period of ESC rate from here
    ATOMIC_BLOCK(ATOMIC_FORCEON)
    {
      MotorStartTCNT = TCNT2_X;
    472a:	80 91 a9 05 	lds	r24, 0x05A9
    472e:	90 91 aa 05 	lds	r25, 0x05AA
    4732:	90 93 d3 07 	sts	0x07D3, r25
    4736:	80 93 d2 07 	sts	0x07D2, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    473a:	78 94       	sei
    }
	
	
 }
    473c:	08 95       	ret

0000473e <CalculateSignalLength1>:



void CalculateSignalLength1(uint8_t ChannelIndex)
{
	if (TCNT1 > RX_raw[0][ChannelIndex] )
    473e:	20 91 84 00 	lds	r18, 0x0084
    4742:	30 91 85 00 	lds	r19, 0x0085
    4746:	90 e0       	ldi	r25, 0x00	; 0
    4748:	88 0f       	add	r24, r24
    474a:	99 1f       	adc	r25, r25
    474c:	fc 01       	movw	r30, r24
    474e:	e0 51       	subi	r30, 0x10	; 16
    4750:	f8 4f       	sbci	r31, 0xF8	; 248
    4752:	40 81       	ld	r20, Z
    4754:	51 81       	ldd	r21, Z+1	; 0x01
    4756:	dc 01       	movw	r26, r24
    4758:	a6 54       	subi	r26, 0x46	; 70
    475a:	ba 4f       	sbci	r27, 0xFA	; 250
    475c:	42 17       	cp	r20, r18
    475e:	53 07       	cpc	r21, r19
    4760:	48 f4       	brcc	.+18     	; 0x4774 <CalculateSignalLength1+0x36>
	{
		RX_Length[0][ChannelIndex] = TCNT1 - RX_raw[0][ChannelIndex] ;	
    4762:	20 91 84 00 	lds	r18, 0x0084
    4766:	30 91 85 00 	lds	r19, 0x0085
    476a:	80 81       	ld	r24, Z
    476c:	91 81       	ldd	r25, Z+1	; 0x01
    476e:	28 1b       	sub	r18, r24
    4770:	39 0b       	sbc	r19, r25
    4772:	0a c0       	rjmp	.+20     	; 0x4788 <CalculateSignalLength1+0x4a>
	}
	else
	{
		RX_Length[0][ChannelIndex] = (0xffff - RX_raw[0][ChannelIndex] + TCNT1 );	
    4774:	20 81       	ld	r18, Z
    4776:	31 81       	ldd	r19, Z+1	; 0x01
    4778:	80 91 84 00 	lds	r24, 0x0084
    477c:	90 91 85 00 	lds	r25, 0x0085
    4780:	20 95       	com	r18
    4782:	30 95       	com	r19
    4784:	28 0f       	add	r18, r24
    4786:	39 1f       	adc	r19, r25
    4788:	11 96       	adiw	r26, 0x01	; 1
    478a:	3c 93       	st	X, r19
    478c:	2e 93       	st	-X, r18
    478e:	08 95       	ret

00004790 <CalculateSignalLength2>:
	}
	
}
void CalculateSignalLength2(uint8_t ChannelIndex)
{
	uint16_t TCNT1_TEMP = TCNT1;
    4790:	20 91 84 00 	lds	r18, 0x0084
    4794:	30 91 85 00 	lds	r19, 0x0085
	if (TCNT1_TEMP > RX_raw[1][ChannelIndex] )
    4798:	90 e0       	ldi	r25, 0x00	; 0
    479a:	05 96       	adiw	r24, 0x05	; 5
    479c:	88 0f       	add	r24, r24
    479e:	99 1f       	adc	r25, r25
    47a0:	fc 01       	movw	r30, r24
    47a2:	e0 51       	subi	r30, 0x10	; 16
    47a4:	f8 4f       	sbci	r31, 0xF8	; 248
    47a6:	40 81       	ld	r20, Z
    47a8:	51 81       	ldd	r21, Z+1	; 0x01
    47aa:	dc 01       	movw	r26, r24
    47ac:	a6 54       	subi	r26, 0x46	; 70
    47ae:	ba 4f       	sbci	r27, 0xFA	; 250
    47b0:	42 17       	cp	r20, r18
    47b2:	53 07       	cpc	r21, r19
    47b4:	40 f4       	brcc	.+16     	; 0x47c6 <CalculateSignalLength2+0x36>
	{
		RX_Length[1][ChannelIndex] = TCNT1_TEMP - RX_raw[1][ChannelIndex] ;	
    47b6:	80 81       	ld	r24, Z
    47b8:	91 81       	ldd	r25, Z+1	; 0x01
    47ba:	28 1b       	sub	r18, r24
    47bc:	39 0b       	sbc	r19, r25
    47be:	11 96       	adiw	r26, 0x01	; 1
    47c0:	3c 93       	st	X, r19
    47c2:	2e 93       	st	-X, r18
    47c4:	08 95       	ret
	}
	else
	{
		RX_Length[1][ChannelIndex] = (0xffff - RX_raw[1][ChannelIndex] + TCNT1_TEMP);	
    47c6:	40 81       	ld	r20, Z
    47c8:	51 81       	ldd	r21, Z+1	; 0x01
    47ca:	40 95       	com	r20
    47cc:	50 95       	com	r21
    47ce:	42 0f       	add	r20, r18
    47d0:	53 1f       	adc	r21, r19
    47d2:	11 96       	adiw	r26, 0x01	; 1
    47d4:	5c 93       	st	X, r21
    47d6:	4e 93       	st	-X, r20
    47d8:	08 95       	ret

000047da <RX_Init>:


void RX_Init(void)
{
	
	RX_AUX_DIR   	 	= INPUT;
    47da:	20 98       	cbi	0x04, 0	; 4

#ifdef PRIMARY_INPUT_RX

	if (Config.RX_mode==RX_mode_BuddyMode)
    47dc:	80 91 c7 06 	lds	r24, 0x06C7
    47e0:	88 23       	and	r24, r24
    47e2:	f1 f4       	brne	.+60     	; 0x4820 <RX_Init+0x46>
	{
	
		ActiveRXIndex=0;
    47e4:	10 92 b8 05 	sts	0x05B8, r1
		RX1_ROLL_DIR 		= INPUT;
    47e8:	52 98       	cbi	0x0a, 2	; 10
		RX1_PITCH_DIR 		= INPUT;
    47ea:	50 98       	cbi	0x0a, 0	; 10
		RX1_COLL_DIR   		= INPUT;
    47ec:	53 98       	cbi	0x0a, 3	; 10
		RX1_YAW_DIR   	 	= INPUT;
    47ee:	22 98       	cbi	0x04, 2	; 4

		// enable interrupts
		EICRA  = _BV(ISC00) | _BV(ISC10) | _BV(ISC20);	// any edge on INT0, INT1 and INT2
    47f0:	85 e1       	ldi	r24, 0x15	; 21
    47f2:	80 93 69 00 	sts	0x0069, r24
		EIMSK  = _BV(INT0)  | _BV(INT1)  | _BV(INT2);	// enable interrupt for INT0, INT1 and INT2
    47f6:	87 e0       	ldi	r24, 0x07	; 7
    47f8:	8d bb       	out	0x1d, r24	; 29
		EIFR   = _BV(INTF0) | _BV(INTF1) | _BV(INTF2);	// clear interrupts
    47fa:	8c bb       	out	0x1c, r24	; 28
		
		PCICR  |= _BV(PCIE1) | _BV(PCIE3);				// enable PCI1 and PCI3
    47fc:	80 91 68 00 	lds	r24, 0x0068
    4800:	8a 60       	ori	r24, 0x0A	; 10
    4802:	80 93 68 00 	sts	0x0068, r24
		PCMSK1 |= _BV(PCINT8);							// enable PCINT8 (AUX) -> PCI1
    4806:	80 91 6c 00 	lds	r24, 0x006C
    480a:	81 60       	ori	r24, 0x01	; 1
    480c:	80 93 6c 00 	sts	0x006C, r24
		PCMSK3 |= _BV(PCINT24);							// enable PCINT24 (THR) -> PCI3
    4810:	80 91 73 00 	lds	r24, 0x0073
    4814:	81 60       	ori	r24, 0x01	; 1
    4816:	80 93 73 00 	sts	0x0073, r24
		PCIFR  |= _BV(PCIF1) | _BV(PCIF3);
    481a:	8b b3       	in	r24, 0x1b	; 27
    481c:	8a 60       	ori	r24, 0x0A	; 10
    481e:	8b bb       	out	0x1b, r24	; 27
#endif

	
#ifdef SECONDARY_INPUT_RX

	ActiveRXIndex=1;
    4820:	81 e0       	ldi	r24, 0x01	; 1
    4822:	80 93 b8 05 	sts	0x05B8, r24
	RX2_ROLL_DIR 		= INPUT;
    4826:	3d 98       	cbi	0x07, 5	; 7
	RX2_PITCH_DIR 		= INPUT;
    4828:	38 98       	cbi	0x07, 0	; 7
	RX2_COLL_DIR   		= INPUT;
    482a:	3f 98       	cbi	0x07, 7	; 7
	RX2_YAW_DIR   	 	= INPUT;
    482c:	39 98       	cbi	0x07, 1	; 7
	PCINT16 - PC0 - OUTPUT 6
	PCINT17 - PC1 - OUTPUT 5 
	PCINT21 - PC5 - OUTPUT 7
	PCINT23 - PC7 - OUTPUT 8 
	*/
	PCICR  |= _BV(PCIE1)   | _BV(PCIE2);														// enable PCI1 and PCI2
    482e:	80 91 68 00 	lds	r24, 0x0068
    4832:	86 60       	ori	r24, 0x06	; 6
    4834:	80 93 68 00 	sts	0x0068, r24
	PCMSK1 |= _BV(PCINT8);																		// enable PCINT8 (AUX) -> PCI1
    4838:	80 91 6c 00 	lds	r24, 0x006C
    483c:	81 60       	ori	r24, 0x01	; 1
    483e:	80 93 6c 00 	sts	0x006C, r24
	PCMSK2 |= _BV(PCINT16) | _BV(PCINT17) | _BV(PCINT21) |_BV(PCINT23);							// enable PCINT24 (THR) -> PCI3
    4842:	80 91 6d 00 	lds	r24, 0x006D
    4846:	83 6a       	ori	r24, 0xA3	; 163
    4848:	80 93 6d 00 	sts	0x006D, r24
	PCIFR  |= _BV(PCIF1)   | _BV(PCIF2);														// clear interrupts
    484c:	8b b3       	in	r24, 0x1b	; 27
    484e:	86 60       	ori	r24, 0x06	; 6
    4850:	8b bb       	out	0x1b, r24	; 27
#endif
	

		
	
	RX_Good =TX1_NOT_FOUND;
    4852:	80 91 c9 07 	lds	r24, 0x07C9
    4856:	81 60       	ori	r24, 0x01	; 1
    4858:	80 93 c9 07 	sts	0x07C9, r24
	RX_Good =TX2_NOT_FOUND;
    485c:	80 91 c9 07 	lds	r24, 0x07C9
    4860:	80 61       	ori	r24, 0x10	; 16
    4862:	80 93 c9 07 	sts	0x07C9, r24
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    4866:	f8 94       	cli
	
	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		RX1_LastValidSignal_timestamp= TCNT1_X;
    4868:	80 91 4e 06 	lds	r24, 0x064E
    486c:	90 91 4f 06 	lds	r25, 0x064F
    4870:	90 93 e8 07 	sts	0x07E8, r25
    4874:	80 93 e7 07 	sts	0x07E7, r24
		RX1_LastValidSignal_timestampAux= TCNT1_X;
    4878:	80 91 4e 06 	lds	r24, 0x064E
    487c:	90 91 4f 06 	lds	r25, 0x064F
    4880:	90 93 ea 07 	sts	0x07EA, r25
    4884:	80 93 e9 07 	sts	0x07E9, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    4888:	78 94       	sei
	}	
	
	RX2_LastValidSignal_timestamp= RX2_LastValidSignal_timestamp;
    488a:	80 91 e5 07 	lds	r24, 0x07E5
    488e:	90 91 e6 07 	lds	r25, 0x07E6
    4892:	90 93 e6 07 	sts	0x07E6, r25
    4896:	80 93 e5 07 	sts	0x07E5, r24
	RX2_LastValidSignal_timestampAux= RX2_LastValidSignal_timestampAux;	
    489a:	80 91 e1 07 	lds	r24, 0x07E1
    489e:	90 91 e2 07 	lds	r25, 0x07E2
    48a2:	90 93 e2 07 	sts	0x07E2, r25
    48a6:	80 93 e1 07 	sts	0x07E1, r24
}
    48aa:	08 95       	ret

000048ac <RX_raw_GetReceiverValues>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    48ac:	f8 94       	cli
  uint16_t RX_raw_GetReceiverValues (uint8_t RXIndex, uint8_t Channel)
{
	uint16_t _t;
	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		_t = RX_Length[RXIndex][Channel];
    48ae:	90 e0       	ldi	r25, 0x00	; 0
    48b0:	fc 01       	movw	r30, r24
    48b2:	ee 0f       	add	r30, r30
    48b4:	ff 1f       	adc	r31, r31
    48b6:	ee 0f       	add	r30, r30
    48b8:	ff 1f       	adc	r31, r31
    48ba:	e8 0f       	add	r30, r24
    48bc:	f9 1f       	adc	r31, r25
    48be:	e6 0f       	add	r30, r22
    48c0:	f1 1d       	adc	r31, r1
    48c2:	ee 0f       	add	r30, r30
    48c4:	ff 1f       	adc	r31, r31
    48c6:	e6 54       	subi	r30, 0x46	; 70
    48c8:	fa 4f       	sbci	r31, 0xFA	; 250
    48ca:	20 81       	ld	r18, Z
    48cc:	31 81       	ldd	r19, Z+1	; 0x01
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    48ce:	78 94       	sei
	}		
	return _t;
}
    48d0:	c9 01       	movw	r24, r18
    48d2:	08 95       	ret

000048d4 <RX_GetReceiverValues>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    48d4:	f8 94       	cli
{
	int16_t _t;
	//////if (RX_Good != TX_GOOD) return 0;
	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		_t = ((int)(RX_Length[RXIndex][Channel]));
    48d6:	90 e0       	ldi	r25, 0x00	; 0
    48d8:	70 e0       	ldi	r23, 0x00	; 0
    48da:	9c 01       	movw	r18, r24
    48dc:	22 0f       	add	r18, r18
    48de:	33 1f       	adc	r19, r19
    48e0:	22 0f       	add	r18, r18
    48e2:	33 1f       	adc	r19, r19
    48e4:	28 0f       	add	r18, r24
    48e6:	39 1f       	adc	r19, r25
    48e8:	a9 01       	movw	r20, r18
    48ea:	46 0f       	add	r20, r22
    48ec:	57 1f       	adc	r21, r23
    48ee:	44 0f       	add	r20, r20
    48f0:	55 1f       	adc	r21, r21
    48f2:	fa 01       	movw	r30, r20
    48f4:	e6 54       	subi	r30, 0x46	; 70
    48f6:	fa 4f       	sbci	r31, 0xFA	; 250
    48f8:	80 81       	ld	r24, Z
    48fa:	91 81       	ldd	r25, Z+1	; 0x01
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    48fc:	78 94       	sei
	}		
	_t -= Config.RX_Mid[RXIndex][Channel];
    48fe:	48 5c       	subi	r20, 0xC8	; 200
    4900:	58 4f       	sbci	r21, 0xF8	; 248
    4902:	fa 01       	movw	r30, r20
    4904:	40 81       	ld	r20, Z
    4906:	51 81       	ldd	r21, Z+1	; 0x01
    4908:	84 1b       	sub	r24, r20
    490a:	95 0b       	sbc	r25, r21
	_t /=Config.RX_DiV_Value[RXIndex][Channel]; //RX_Div_Factor;
    490c:	26 0f       	add	r18, r22
    490e:	37 1f       	adc	r19, r23
    4910:	2e 58       	subi	r18, 0x8E	; 142
    4912:	38 4f       	sbci	r19, 0xF8	; 248
    4914:	f9 01       	movw	r30, r18
    4916:	60 81       	ld	r22, Z
    4918:	77 27       	eor	r23, r23
    491a:	67 fd       	sbrc	r22, 7
    491c:	70 95       	com	r23
    491e:	0e 94 f4 37 	call	0x6fe8	; 0x6fe8 <__divmodhi4>
	return _t;
}
    4922:	cb 01       	movw	r24, r22
    4924:	08 95       	ret

00004926 <RX_GetReceiverThrottleValue>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    4926:	f8 94       	cli
	
	///if (RX_Good != TX_GOOD) return 0;
	
	ATOMIC_BLOCK(ATOMIC_FORCEON)
	{
		if (RXIndex==0)
    4928:	88 23       	and	r24, r24
    492a:	11 f5       	brne	.+68     	; 0x4970 <RX_GetReceiverThrottleValue+0x4a>
		{
			if ( (TCNT1_X - RX1_LastValidSignal_timestamp) > RX_SIGNAL_LOST_DURATION)
    492c:	40 91 4e 06 	lds	r20, 0x064E
    4930:	50 91 4f 06 	lds	r21, 0x064F
    4934:	60 91 e7 07 	lds	r22, 0x07E7
    4938:	70 91 e8 07 	lds	r23, 0x07E8
    493c:	46 1b       	sub	r20, r22
    493e:	57 0b       	sbc	r21, r23
    4940:	45 31       	cpi	r20, 0x15	; 21
    4942:	51 05       	cpc	r21, r1
    4944:	20 f0       	brcs	.+8      	; 0x494e <RX_GetReceiverThrottleValue+0x28>
			{
				RX_Good =TX1_NOT_FOUND;
    4946:	80 91 c9 07 	lds	r24, 0x07C9
    494a:	81 60       	ori	r24, 0x01	; 1
    494c:	34 c0       	rjmp	.+104    	; 0x49b6 <RX_GetReceiverThrottleValue+0x90>
				return 0;
			}	
		
			if ( (TCNT1_X - RX1_LastValidSignal_timestampAux) > RX_SIGNAL_LOST_DURATION)
    494e:	40 91 4e 06 	lds	r20, 0x064E
    4952:	50 91 4f 06 	lds	r21, 0x064F
    4956:	60 91 e9 07 	lds	r22, 0x07E9
    495a:	70 91 ea 07 	lds	r23, 0x07EA
    495e:	46 1b       	sub	r20, r22
    4960:	57 0b       	sbc	r21, r23
    4962:	45 31       	cpi	r20, 0x15	; 21
    4964:	51 05       	cpc	r21, r1
    4966:	68 f1       	brcs	.+90     	; 0x49c2 <RX_GetReceiverThrottleValue+0x9c>
			{
				RX_Good =TX1_DISCONNECTED;
    4968:	80 91 c9 07 	lds	r24, 0x07C9
    496c:	82 60       	ori	r24, 0x02	; 2
    496e:	23 c0       	rjmp	.+70     	; 0x49b6 <RX_GetReceiverThrottleValue+0x90>
				return 0;
			}
		}	
		if (RXIndex==1)
    4970:	81 30       	cpi	r24, 0x01	; 1
    4972:	39 f5       	brne	.+78     	; 0x49c2 <RX_GetReceiverThrottleValue+0x9c>
		{
			if ( (TCNT1_X - RX2_LastValidSignal_timestamp) > RX_SIGNAL_LOST_DURATION)
    4974:	40 91 4e 06 	lds	r20, 0x064E
    4978:	50 91 4f 06 	lds	r21, 0x064F
    497c:	60 91 e5 07 	lds	r22, 0x07E5
    4980:	70 91 e6 07 	lds	r23, 0x07E6
    4984:	46 1b       	sub	r20, r22
    4986:	57 0b       	sbc	r21, r23
    4988:	45 31       	cpi	r20, 0x15	; 21
    498a:	51 05       	cpc	r21, r1
    498c:	20 f0       	brcs	.+8      	; 0x4996 <RX_GetReceiverThrottleValue+0x70>
			{
				RX_Good =TX2_NOT_FOUND;
    498e:	80 91 c9 07 	lds	r24, 0x07C9
    4992:	80 61       	ori	r24, 0x10	; 16
    4994:	10 c0       	rjmp	.+32     	; 0x49b6 <RX_GetReceiverThrottleValue+0x90>
				return 0;
			}	
		
			if ( (TCNT1_X - RX2_LastValidSignal_timestampAux) > RX_SIGNAL_LOST_DURATION)
    4996:	40 91 4e 06 	lds	r20, 0x064E
    499a:	50 91 4f 06 	lds	r21, 0x064F
    499e:	60 91 e1 07 	lds	r22, 0x07E1
    49a2:	70 91 e2 07 	lds	r23, 0x07E2
    49a6:	46 1b       	sub	r20, r22
    49a8:	57 0b       	sbc	r21, r23
    49aa:	45 31       	cpi	r20, 0x15	; 21
    49ac:	51 05       	cpc	r21, r1
    49ae:	48 f0       	brcs	.+18     	; 0x49c2 <RX_GetReceiverThrottleValue+0x9c>
			{
				RX_Good =TX2_DISCONNECTED;
    49b0:	80 91 c9 07 	lds	r24, 0x07C9
    49b4:	80 62       	ori	r24, 0x20	; 32
    49b6:	80 93 c9 07 	sts	0x07C9, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    49ba:	78 94       	sei
    __asm__ volatile ("" ::: "memory");
    49bc:	20 e0       	ldi	r18, 0x00	; 0
    49be:	30 e0       	ldi	r19, 0x00	; 0
    49c0:	41 c0       	rjmp	.+130    	; 0x4a44 <RX_GetReceiverThrottleValue+0x11e>
				return 0;
			}
		}			
		
		
		iTemp16 = ((int)(RX_Length[RXIndex][RXChannel_THR]));
    49c2:	28 2f       	mov	r18, r24
    49c4:	30 e0       	ldi	r19, 0x00	; 0
    49c6:	c9 01       	movw	r24, r18
    49c8:	88 0f       	add	r24, r24
    49ca:	99 1f       	adc	r25, r25
    49cc:	a9 01       	movw	r20, r18
    49ce:	b3 e0       	ldi	r27, 0x03	; 3
    49d0:	44 0f       	add	r20, r20
    49d2:	55 1f       	adc	r21, r21
    49d4:	ba 95       	dec	r27
    49d6:	e1 f7       	brne	.-8      	; 0x49d0 <RX_GetReceiverThrottleValue+0xaa>
    49d8:	84 0f       	add	r24, r20
    49da:	95 1f       	adc	r25, r21
    49dc:	fc 01       	movw	r30, r24
    49de:	e6 54       	subi	r30, 0x46	; 70
    49e0:	fa 4f       	sbci	r31, 0xFA	; 250
    49e2:	46 81       	ldd	r20, Z+6	; 0x06
    49e4:	57 81       	ldd	r21, Z+7	; 0x07
    49e6:	50 93 ec 07 	sts	0x07EC, r21
    49ea:	40 93 eb 07 	sts	0x07EB, r20
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    49ee:	78 94       	sei
	}		
	
	iTemp16 -= Config.RX_Min[RXIndex][RXChannel_THR];
    49f0:	40 91 eb 07 	lds	r20, 0x07EB
    49f4:	50 91 ec 07 	lds	r21, 0x07EC
    49f8:	8e 5a       	subi	r24, 0xAE	; 174
    49fa:	98 4f       	sbci	r25, 0xF8	; 248
    49fc:	fc 01       	movw	r30, r24
    49fe:	80 81       	ld	r24, Z
    4a00:	91 81       	ldd	r25, Z+1	; 0x01
    4a02:	48 1b       	sub	r20, r24
    4a04:	59 0b       	sbc	r21, r25
    4a06:	50 93 ec 07 	sts	0x07EC, r21
    4a0a:	40 93 eb 07 	sts	0x07EB, r20
	iTemp16 /= Config.RX_DiV_Value[RXIndex][RXChannel_THR]; //RX_Div_Factor;
    4a0e:	80 91 eb 07 	lds	r24, 0x07EB
    4a12:	90 91 ec 07 	lds	r25, 0x07EC
    4a16:	f9 01       	movw	r30, r18
    4a18:	ee 0f       	add	r30, r30
    4a1a:	ff 1f       	adc	r31, r31
    4a1c:	ee 0f       	add	r30, r30
    4a1e:	ff 1f       	adc	r31, r31
    4a20:	e2 0f       	add	r30, r18
    4a22:	f3 1f       	adc	r31, r19
    4a24:	eb 58       	subi	r30, 0x8B	; 139
    4a26:	f8 4f       	sbci	r31, 0xF8	; 248
    4a28:	60 81       	ld	r22, Z
    4a2a:	77 27       	eor	r23, r23
    4a2c:	67 fd       	sbrc	r22, 7
    4a2e:	70 95       	com	r23
    4a30:	0e 94 f4 37 	call	0x6fe8	; 0x6fe8 <__divmodhi4>
    4a34:	70 93 ec 07 	sts	0x07EC, r23
    4a38:	60 93 eb 07 	sts	0x07EB, r22
	 
	return iTemp16;
    4a3c:	20 91 eb 07 	lds	r18, 0x07EB
    4a40:	30 91 ec 07 	lds	r19, 0x07EC
}
    4a44:	c9 01       	movw	r24, r18
    4a46:	08 95       	ret

00004a48 <RX_CopyLatestReceiverValues>:
 
void RX_CopyLatestReceiverValues (void)
{
    4a48:	cf 92       	push	r12
    4a4a:	df 92       	push	r13
    4a4c:	ef 92       	push	r14
    4a4e:	ff 92       	push	r15
    4a50:	0f 93       	push	r16
    4a52:	1f 93       	push	r17
    4a54:	cf 93       	push	r28
    4a56:	df 93       	push	r29
	for (int ch=0;ch<2;++ch)
    4a58:	c0 e0       	ldi	r28, 0x00	; 0
    4a5a:	d0 e0       	ldi	r29, 0x00	; 0
    4a5c:	2d c0       	rjmp	.+90     	; 0x4ab8 <RX_CopyLatestReceiverValues+0x70>
	{
		for (int i=0;i<RXChannels;++i)
		{
			if (i == RXChannel_THR)
    4a5e:	03 30       	cpi	r16, 0x03	; 3
    4a60:	11 05       	cpc	r17, r1
    4a62:	39 f4       	brne	.+14     	; 0x4a72 <RX_CopyLatestReceiverValues+0x2a>
			{
				RX_Latest[ch][i]= RX_GetReceiverThrottleValue(ch);	 
    4a64:	8c 2f       	mov	r24, r28
    4a66:	0e 94 93 24 	call	0x4926	; 0x4926 <RX_GetReceiverThrottleValue>
    4a6a:	f7 01       	movw	r30, r14
    4a6c:	91 83       	std	Z+1, r25	; 0x01
    4a6e:	80 83       	st	Z, r24
    4a70:	1a c0       	rjmp	.+52     	; 0x4aa6 <RX_CopyLatestReceiverValues+0x5e>
			}
			else
			{
				RX_Latest[ch][i]= RX_GetReceiverValues(ch,i);	 
    4a72:	8c 2f       	mov	r24, r28
    4a74:	60 2f       	mov	r22, r16
    4a76:	0e 94 6a 24 	call	0x48d4	; 0x48d4 <RX_GetReceiverValues>
    4a7a:	f6 01       	movw	r30, r12
    4a7c:	e0 0f       	add	r30, r16
    4a7e:	f1 1f       	adc	r31, r17
    4a80:	ee 0f       	add	r30, r30
    4a82:	ff 1f       	adc	r31, r31
    4a84:	e0 51       	subi	r30, 0x10	; 16
    4a86:	fa 4f       	sbci	r31, 0xFA	; 250
    4a88:	91 83       	std	Z+1, r25	; 0x01
    4a8a:	80 83       	st	Z, r24
				if ((RX_Latest[ch][i]<STICK_DEADBAND) && (RX_Latest[ch][i]>-STICK_DEADBAND)) RX_Latest[ch][i]=0;
    4a8c:	80 81       	ld	r24, Z
    4a8e:	91 81       	ldd	r25, Z+1	; 0x01
    4a90:	8f 30       	cpi	r24, 0x0F	; 15
    4a92:	91 05       	cpc	r25, r1
    4a94:	44 f4       	brge	.+16     	; 0x4aa6 <RX_CopyLatestReceiverValues+0x5e>
    4a96:	80 81       	ld	r24, Z
    4a98:	91 81       	ldd	r25, Z+1	; 0x01
    4a9a:	3f ef       	ldi	r19, 0xFF	; 255
    4a9c:	82 3f       	cpi	r24, 0xF2	; 242
    4a9e:	93 07       	cpc	r25, r19
    4aa0:	14 f0       	brlt	.+4      	; 0x4aa6 <RX_CopyLatestReceiverValues+0x5e>
    4aa2:	11 82       	std	Z+1, r1	; 0x01
    4aa4:	10 82       	st	Z, r1
 
void RX_CopyLatestReceiverValues (void)
{
	for (int ch=0;ch<2;++ch)
	{
		for (int i=0;i<RXChannels;++i)
    4aa6:	0f 5f       	subi	r16, 0xFF	; 255
    4aa8:	1f 4f       	sbci	r17, 0xFF	; 255
    4aaa:	05 30       	cpi	r16, 0x05	; 5
    4aac:	11 05       	cpc	r17, r1
    4aae:	b9 f6       	brne	.-82     	; 0x4a5e <RX_CopyLatestReceiverValues+0x16>
	return iTemp16;
}
 
void RX_CopyLatestReceiverValues (void)
{
	for (int ch=0;ch<2;++ch)
    4ab0:	21 96       	adiw	r28, 0x01	; 1
    4ab2:	c2 30       	cpi	r28, 0x02	; 2
    4ab4:	d1 05       	cpc	r29, r1
    4ab6:	c9 f0       	breq	.+50     	; 0x4aea <RX_CopyLatestReceiverValues+0xa2>
	 
	return iTemp16;
}
 
void RX_CopyLatestReceiverValues (void)
{
    4ab8:	00 e0       	ldi	r16, 0x00	; 0
    4aba:	10 e0       	ldi	r17, 0x00	; 0
			{
				RX_Latest[ch][i]= RX_GetReceiverThrottleValue(ch);	 
			}
			else
			{
				RX_Latest[ch][i]= RX_GetReceiverValues(ch,i);	 
    4abc:	6e 01       	movw	r12, r28
    4abe:	cc 0c       	add	r12, r12
    4ac0:	dd 1c       	adc	r13, r13
    4ac2:	cc 0c       	add	r12, r12
    4ac4:	dd 1c       	adc	r13, r13
    4ac6:	cc 0e       	add	r12, r28
    4ac8:	dd 1e       	adc	r13, r29
	{
		for (int i=0;i<RXChannels;++i)
		{
			if (i == RXChannel_THR)
			{
				RX_Latest[ch][i]= RX_GetReceiverThrottleValue(ch);	 
    4aca:	7e 01       	movw	r14, r28
    4acc:	ee 0c       	add	r14, r14
    4ace:	ff 1c       	adc	r15, r15
    4ad0:	ce 01       	movw	r24, r28
    4ad2:	53 e0       	ldi	r21, 0x03	; 3
    4ad4:	88 0f       	add	r24, r24
    4ad6:	99 1f       	adc	r25, r25
    4ad8:	5a 95       	dec	r21
    4ada:	e1 f7       	brne	.-8      	; 0x4ad4 <RX_CopyLatestReceiverValues+0x8c>
    4adc:	e8 0e       	add	r14, r24
    4ade:	f9 1e       	adc	r15, r25
    4ae0:	86 ef       	ldi	r24, 0xF6	; 246
    4ae2:	95 e0       	ldi	r25, 0x05	; 5
    4ae4:	e8 0e       	add	r14, r24
    4ae6:	f9 1e       	adc	r15, r25
    4ae8:	ba cf       	rjmp	.-140    	; 0x4a5e <RX_CopyLatestReceiverValues+0x16>
				if ((RX_Latest[ch][i]<STICK_DEADBAND) && (RX_Latest[ch][i]>-STICK_DEADBAND)) RX_Latest[ch][i]=0;
			}
		}	
	}
				
}
    4aea:	df 91       	pop	r29
    4aec:	cf 91       	pop	r28
    4aee:	1f 91       	pop	r17
    4af0:	0f 91       	pop	r16
    4af2:	ff 90       	pop	r15
    4af4:	ef 90       	pop	r14
    4af6:	df 90       	pop	r13
    4af8:	cf 90       	pop	r12
    4afa:	08 95       	ret

00004afc <RX_StickCenterCalibrationInit>:

void RX_StickCenterCalibrationInit(uint8_t RXIndex)
{
	for (int i=0; i<RXChannels; ++i)
	{
		RX_MAX_raw[RXIndex][i]=0;
    4afc:	6f e0       	ldi	r22, 0x0F	; 15
    4afe:	76 e0       	ldi	r23, 0x06	; 6
    4b00:	28 2f       	mov	r18, r24
    4b02:	30 e0       	ldi	r19, 0x00	; 0
    4b04:	f9 01       	movw	r30, r18
    4b06:	ee 0f       	add	r30, r30
    4b08:	ff 1f       	adc	r31, r31
    4b0a:	93 e0       	ldi	r25, 0x03	; 3
    4b0c:	22 0f       	add	r18, r18
    4b0e:	33 1f       	adc	r19, r19
    4b10:	9a 95       	dec	r25
    4b12:	e1 f7       	brne	.-8      	; 0x4b0c <RX_StickCenterCalibrationInit+0x10>
    4b14:	e2 0f       	add	r30, r18
    4b16:	f3 1f       	adc	r31, r19
    4b18:	e6 0f       	add	r30, r22
    4b1a:	f7 1f       	adc	r31, r23
    4b1c:	11 82       	std	Z+1, r1	; 0x01
    4b1e:	10 82       	st	Z, r1
		RX_MIN_raw[RXIndex][i]=0xfffe;
    4b20:	40 ea       	ldi	r20, 0xA0	; 160
    4b22:	56 e0       	ldi	r21, 0x06	; 6
    4b24:	28 2f       	mov	r18, r24
    4b26:	30 e0       	ldi	r19, 0x00	; 0
    4b28:	f9 01       	movw	r30, r18
    4b2a:	ee 0f       	add	r30, r30
    4b2c:	ff 1f       	adc	r31, r31
    4b2e:	a3 e0       	ldi	r26, 0x03	; 3
    4b30:	22 0f       	add	r18, r18
    4b32:	33 1f       	adc	r19, r19
    4b34:	aa 95       	dec	r26
    4b36:	e1 f7       	brne	.-8      	; 0x4b30 <RX_StickCenterCalibrationInit+0x34>
    4b38:	e2 0f       	add	r30, r18
    4b3a:	f3 1f       	adc	r31, r19
    4b3c:	e4 0f       	add	r30, r20
    4b3e:	f5 1f       	adc	r31, r21
    4b40:	2e ef       	ldi	r18, 0xFE	; 254
    4b42:	3f ef       	ldi	r19, 0xFF	; 255
    4b44:	31 83       	std	Z+1, r19	; 0x01
    4b46:	20 83       	st	Z, r18

void RX_StickCenterCalibrationInit(uint8_t RXIndex)
{
	for (int i=0; i<RXChannels; ++i)
	{
		RX_MAX_raw[RXIndex][i]=0;
    4b48:	a8 2f       	mov	r26, r24
    4b4a:	b0 e0       	ldi	r27, 0x00	; 0
    4b4c:	fd 01       	movw	r30, r26
    4b4e:	ee 0f       	add	r30, r30
    4b50:	ff 1f       	adc	r31, r31
    4b52:	93 e0       	ldi	r25, 0x03	; 3
    4b54:	aa 0f       	add	r26, r26
    4b56:	bb 1f       	adc	r27, r27
    4b58:	9a 95       	dec	r25
    4b5a:	e1 f7       	brne	.-8      	; 0x4b54 <RX_StickCenterCalibrationInit+0x58>
    4b5c:	ea 0f       	add	r30, r26
    4b5e:	fb 1f       	adc	r31, r27
    4b60:	e6 0f       	add	r30, r22
    4b62:	f7 1f       	adc	r31, r23
    4b64:	13 82       	std	Z+3, r1	; 0x03
    4b66:	12 82       	std	Z+2, r1	; 0x02
		RX_MIN_raw[RXIndex][i]=0xfffe;
    4b68:	a8 2f       	mov	r26, r24
    4b6a:	b0 e0       	ldi	r27, 0x00	; 0
    4b6c:	fd 01       	movw	r30, r26
    4b6e:	ee 0f       	add	r30, r30
    4b70:	ff 1f       	adc	r31, r31
    4b72:	93 e0       	ldi	r25, 0x03	; 3
    4b74:	aa 0f       	add	r26, r26
    4b76:	bb 1f       	adc	r27, r27
    4b78:	9a 95       	dec	r25
    4b7a:	e1 f7       	brne	.-8      	; 0x4b74 <RX_StickCenterCalibrationInit+0x78>
    4b7c:	ea 0f       	add	r30, r26
    4b7e:	fb 1f       	adc	r31, r27
    4b80:	e4 0f       	add	r30, r20
    4b82:	f5 1f       	adc	r31, r21
    4b84:	33 83       	std	Z+3, r19	; 0x03
    4b86:	22 83       	std	Z+2, r18	; 0x02

void RX_StickCenterCalibrationInit(uint8_t RXIndex)
{
	for (int i=0; i<RXChannels; ++i)
	{
		RX_MAX_raw[RXIndex][i]=0;
    4b88:	a8 2f       	mov	r26, r24
    4b8a:	b0 e0       	ldi	r27, 0x00	; 0
    4b8c:	fd 01       	movw	r30, r26
    4b8e:	ee 0f       	add	r30, r30
    4b90:	ff 1f       	adc	r31, r31
    4b92:	93 e0       	ldi	r25, 0x03	; 3
    4b94:	aa 0f       	add	r26, r26
    4b96:	bb 1f       	adc	r27, r27
    4b98:	9a 95       	dec	r25
    4b9a:	e1 f7       	brne	.-8      	; 0x4b94 <RX_StickCenterCalibrationInit+0x98>
    4b9c:	ea 0f       	add	r30, r26
    4b9e:	fb 1f       	adc	r31, r27
    4ba0:	e6 0f       	add	r30, r22
    4ba2:	f7 1f       	adc	r31, r23
    4ba4:	15 82       	std	Z+5, r1	; 0x05
    4ba6:	14 82       	std	Z+4, r1	; 0x04
		RX_MIN_raw[RXIndex][i]=0xfffe;
    4ba8:	a8 2f       	mov	r26, r24
    4baa:	b0 e0       	ldi	r27, 0x00	; 0
    4bac:	fd 01       	movw	r30, r26
    4bae:	ee 0f       	add	r30, r30
    4bb0:	ff 1f       	adc	r31, r31
    4bb2:	93 e0       	ldi	r25, 0x03	; 3
    4bb4:	aa 0f       	add	r26, r26
    4bb6:	bb 1f       	adc	r27, r27
    4bb8:	9a 95       	dec	r25
    4bba:	e1 f7       	brne	.-8      	; 0x4bb4 <RX_StickCenterCalibrationInit+0xb8>
    4bbc:	ea 0f       	add	r30, r26
    4bbe:	fb 1f       	adc	r31, r27
    4bc0:	e4 0f       	add	r30, r20
    4bc2:	f5 1f       	adc	r31, r21
    4bc4:	35 83       	std	Z+5, r19	; 0x05
    4bc6:	24 83       	std	Z+4, r18	; 0x04

void RX_StickCenterCalibrationInit(uint8_t RXIndex)
{
	for (int i=0; i<RXChannels; ++i)
	{
		RX_MAX_raw[RXIndex][i]=0;
    4bc8:	a8 2f       	mov	r26, r24
    4bca:	b0 e0       	ldi	r27, 0x00	; 0
    4bcc:	fd 01       	movw	r30, r26
    4bce:	ee 0f       	add	r30, r30
    4bd0:	ff 1f       	adc	r31, r31
    4bd2:	93 e0       	ldi	r25, 0x03	; 3
    4bd4:	aa 0f       	add	r26, r26
    4bd6:	bb 1f       	adc	r27, r27
    4bd8:	9a 95       	dec	r25
    4bda:	e1 f7       	brne	.-8      	; 0x4bd4 <RX_StickCenterCalibrationInit+0xd8>
    4bdc:	ea 0f       	add	r30, r26
    4bde:	fb 1f       	adc	r31, r27
    4be0:	e6 0f       	add	r30, r22
    4be2:	f7 1f       	adc	r31, r23
    4be4:	17 82       	std	Z+7, r1	; 0x07
    4be6:	16 82       	std	Z+6, r1	; 0x06
		RX_MIN_raw[RXIndex][i]=0xfffe;
    4be8:	a8 2f       	mov	r26, r24
    4bea:	b0 e0       	ldi	r27, 0x00	; 0
    4bec:	fd 01       	movw	r30, r26
    4bee:	ee 0f       	add	r30, r30
    4bf0:	ff 1f       	adc	r31, r31
    4bf2:	93 e0       	ldi	r25, 0x03	; 3
    4bf4:	aa 0f       	add	r26, r26
    4bf6:	bb 1f       	adc	r27, r27
    4bf8:	9a 95       	dec	r25
    4bfa:	e1 f7       	brne	.-8      	; 0x4bf4 <RX_StickCenterCalibrationInit+0xf8>
    4bfc:	ea 0f       	add	r30, r26
    4bfe:	fb 1f       	adc	r31, r27
    4c00:	e4 0f       	add	r30, r20
    4c02:	f5 1f       	adc	r31, r21
    4c04:	37 83       	std	Z+7, r19	; 0x07
    4c06:	26 83       	std	Z+6, r18	; 0x06

void RX_StickCenterCalibrationInit(uint8_t RXIndex)
{
	for (int i=0; i<RXChannels; ++i)
	{
		RX_MAX_raw[RXIndex][i]=0;
    4c08:	a8 2f       	mov	r26, r24
    4c0a:	b0 e0       	ldi	r27, 0x00	; 0
    4c0c:	fd 01       	movw	r30, r26
    4c0e:	ee 0f       	add	r30, r30
    4c10:	ff 1f       	adc	r31, r31
    4c12:	93 e0       	ldi	r25, 0x03	; 3
    4c14:	aa 0f       	add	r26, r26
    4c16:	bb 1f       	adc	r27, r27
    4c18:	9a 95       	dec	r25
    4c1a:	e1 f7       	brne	.-8      	; 0x4c14 <RX_StickCenterCalibrationInit+0x118>
    4c1c:	ea 0f       	add	r30, r26
    4c1e:	fb 1f       	adc	r31, r27
    4c20:	e6 0f       	add	r30, r22
    4c22:	f7 1f       	adc	r31, r23
    4c24:	11 86       	std	Z+9, r1	; 0x09
    4c26:	10 86       	std	Z+8, r1	; 0x08
		RX_MIN_raw[RXIndex][i]=0xfffe;
    4c28:	68 2f       	mov	r22, r24
    4c2a:	70 e0       	ldi	r23, 0x00	; 0
    4c2c:	fb 01       	movw	r30, r22
    4c2e:	ee 0f       	add	r30, r30
    4c30:	ff 1f       	adc	r31, r31
    4c32:	b3 e0       	ldi	r27, 0x03	; 3
    4c34:	66 0f       	add	r22, r22
    4c36:	77 1f       	adc	r23, r23
    4c38:	ba 95       	dec	r27
    4c3a:	e1 f7       	brne	.-8      	; 0x4c34 <RX_StickCenterCalibrationInit+0x138>
    4c3c:	e6 0f       	add	r30, r22
    4c3e:	f7 1f       	adc	r31, r23
    4c40:	e4 0f       	add	r30, r20
    4c42:	f5 1f       	adc	r31, r21
    4c44:	31 87       	std	Z+9, r19	; 0x09
    4c46:	20 87       	std	Z+8, r18	; 0x08
	}
}
    4c48:	08 95       	ret

00004c4a <RX_StickCenterCalibration>:


void RX_StickCenterCalibration (uint8_t RXIndex)
{
    4c4a:	df 92       	push	r13
    4c4c:	ef 92       	push	r14
    4c4e:	ff 92       	push	r15
    4c50:	0f 93       	push	r16
    4c52:	1f 93       	push	r17
    4c54:	cf 93       	push	r28
    4c56:	df 93       	push	r29
    4c58:	d8 2e       	mov	r13, r24
		RX_MIN_raw[RXIndex][i]=0xfffe;
	}
}


void RX_StickCenterCalibration (uint8_t RXIndex)
    4c5a:	28 2f       	mov	r18, r24
    4c5c:	30 e0       	ldi	r19, 0x00	; 0
    4c5e:	89 01       	movw	r16, r18
    4c60:	00 0f       	add	r16, r16
    4c62:	11 1f       	adc	r17, r17
    4c64:	73 e0       	ldi	r23, 0x03	; 3
    4c66:	22 0f       	add	r18, r18
    4c68:	33 1f       	adc	r19, r19
    4c6a:	7a 95       	dec	r23
    4c6c:	e1 f7       	brne	.-8      	; 0x4c66 <RX_StickCenterCalibration+0x1c>
    4c6e:	02 0f       	add	r16, r18
    4c70:	13 1f       	adc	r17, r19
    4c72:	01 5f       	subi	r16, 0xF1	; 241
    4c74:	19 4f       	sbci	r17, 0xF9	; 249
    4c76:	28 2f       	mov	r18, r24
    4c78:	30 e0       	ldi	r19, 0x00	; 0
    4c7a:	e9 01       	movw	r28, r18
    4c7c:	cc 0f       	add	r28, r28
    4c7e:	dd 1f       	adc	r29, r29
    4c80:	53 e0       	ldi	r21, 0x03	; 3
    4c82:	22 0f       	add	r18, r18
    4c84:	33 1f       	adc	r19, r19
    4c86:	5a 95       	dec	r21
    4c88:	e1 f7       	brne	.-8      	; 0x4c82 <RX_StickCenterCalibration+0x38>
    4c8a:	c2 0f       	add	r28, r18
    4c8c:	d3 1f       	adc	r29, r19
    4c8e:	c0 56       	subi	r28, 0x60	; 96
    4c90:	d9 4f       	sbci	r29, 0xF9	; 249
{
	
	uint16_t tempRX;
	for (int i=0;i<RXChannels;++i)
    4c92:	ee 24       	eor	r14, r14
    4c94:	ff 24       	eor	r15, r15
	{
		tempRX = RX_raw_GetReceiverValues(RXIndex,i);
    4c96:	8d 2d       	mov	r24, r13
    4c98:	6e 2d       	mov	r22, r14
    4c9a:	0e 94 56 24 	call	0x48ac	; 0x48ac <RX_raw_GetReceiverValues>
    4c9e:	9c 01       	movw	r18, r24
		if (tempRX!=0)
    4ca0:	00 97       	sbiw	r24, 0x00	; 0
    4ca2:	81 f0       	breq	.+32     	; 0x4cc4 <RX_StickCenterCalibration+0x7a>
		{
			
			if ( tempRX > RX_MAX_raw[RXIndex][i]) 
    4ca4:	f8 01       	movw	r30, r16
    4ca6:	80 81       	ld	r24, Z
    4ca8:	91 81       	ldd	r25, Z+1	; 0x01
    4caa:	82 17       	cp	r24, r18
    4cac:	93 07       	cpc	r25, r19
    4cae:	18 f4       	brcc	.+6      	; 0x4cb6 <RX_StickCenterCalibration+0x6c>
			{
				RX_MAX_raw[RXIndex][i] = tempRX;
    4cb0:	31 83       	std	Z+1, r19	; 0x01
    4cb2:	20 83       	st	Z, r18
    4cb4:	07 c0       	rjmp	.+14     	; 0x4cc4 <RX_StickCenterCalibration+0x7a>
			}
			else if (tempRX < RX_MIN_raw[RXIndex][i]) 
    4cb6:	88 81       	ld	r24, Y
    4cb8:	99 81       	ldd	r25, Y+1	; 0x01
    4cba:	28 17       	cp	r18, r24
    4cbc:	39 07       	cpc	r19, r25
    4cbe:	10 f4       	brcc	.+4      	; 0x4cc4 <RX_StickCenterCalibration+0x7a>
			{
				RX_MIN_raw[RXIndex][i] = tempRX;
    4cc0:	39 83       	std	Y+1, r19	; 0x01
    4cc2:	28 83       	st	Y, r18

void RX_StickCenterCalibration (uint8_t RXIndex)
{
	
	uint16_t tempRX;
	for (int i=0;i<RXChannels;++i)
    4cc4:	08 94       	sec
    4cc6:	e1 1c       	adc	r14, r1
    4cc8:	f1 1c       	adc	r15, r1
    4cca:	0e 5f       	subi	r16, 0xFE	; 254
    4ccc:	1f 4f       	sbci	r17, 0xFF	; 255
    4cce:	22 96       	adiw	r28, 0x02	; 2
    4cd0:	f5 e0       	ldi	r31, 0x05	; 5
    4cd2:	ef 16       	cp	r14, r31
    4cd4:	f1 04       	cpc	r15, r1
    4cd6:	f9 f6       	brne	.-66     	; 0x4c96 <RX_StickCenterCalibration+0x4c>
			{
				RX_MIN_raw[RXIndex][i] = tempRX;
			}
		}
	}				
    4cd8:	df 91       	pop	r29
    4cda:	cf 91       	pop	r28
    4cdc:	1f 91       	pop	r17
    4cde:	0f 91       	pop	r16
    4ce0:	ff 90       	pop	r15
    4ce2:	ef 90       	pop	r14
    4ce4:	df 90       	pop	r13
    4ce6:	08 95       	ret

00004ce8 <Sensors_Init>:
	


void Sensors_Init(void)
{
	ACC_PITCH  = INPUT;
    4ce8:	15 98       	cbi	0x02, 5	; 2
	ACC_ROLL  = INPUT;
    4cea:	16 98       	cbi	0x02, 6	; 2
	ACC_Z  = INPUT;
    4cec:	17 98       	cbi	0x02, 7	; 2
	
	GYRO_ROLL = INPUT;
    4cee:	11 98       	cbi	0x02, 1	; 2
	GYRO_PITCH = INPUT;
    4cf0:	14 98       	cbi	0x02, 4	; 2
	GYRO_Z = INPUT;
    4cf2:	12 98       	cbi	0x02, 2	; 2
	//{
		//
		//StabilityMatrix_GX[i]=0;
		//StabilityMatrix_GY[i]=0;
	//}
}
    4cf4:	08 95       	ret

00004cf6 <Sensors_Test>:

/*
// This function Test if sensors are working OK or not.
*/
char *Sensors_Test(uint8_t channel, uint16_t LowLimit ,uint16_t HighLimit)
{
    4cf6:	ef 92       	push	r14
    4cf8:	ff 92       	push	r15
    4cfa:	0f 93       	push	r16
    4cfc:	1f 93       	push	r17
    4cfe:	cf 93       	push	r28
    4d00:	df 93       	push	r29
    4d02:	8b 01       	movw	r16, r22
    4d04:	7a 01       	movw	r14, r20
	
	nResult[channel] = ADCPort_Get(channel);
    4d06:	c8 2f       	mov	r28, r24
    4d08:	d0 e0       	ldi	r29, 0x00	; 0
    4d0a:	0e 94 25 28 	call	0x504a	; 0x504a <ADCPort_Get>
    4d0e:	cc 0f       	add	r28, r28
    4d10:	dd 1f       	adc	r29, r29
    4d12:	c4 57       	subi	r28, 0x74	; 116
    4d14:	da 4f       	sbci	r29, 0xFA	; 250
    4d16:	99 83       	std	Y+1, r25	; 0x01
    4d18:	88 83       	st	Y, r24
	  
	utoa (nResult[channel],Result,10);
    4d1a:	88 81       	ld	r24, Y
    4d1c:	99 81       	ldd	r25, Y+1	; 0x01
    4d1e:	6c e9       	ldi	r22, 0x9C	; 156
    4d20:	75 e0       	ldi	r23, 0x05	; 5
    4d22:	4a e0       	ldi	r20, 0x0A	; 10
    4d24:	50 e0       	ldi	r21, 0x00	; 0
    4d26:	0e 94 80 38 	call	0x7100	; 0x7100 <utoa>
	
	if ((nResult[channel]  >= LowLimit)  
    4d2a:	88 81       	ld	r24, Y
    4d2c:	99 81       	ldd	r25, Y+1	; 0x01
    4d2e:	80 17       	cp	r24, r16
    4d30:	91 07       	cpc	r25, r17
    4d32:	50 f0       	brcs	.+20     	; 0x4d48 <Sensors_Test+0x52>
	 && (nResult[channel]  <= HighLimit))
    4d34:	88 81       	ld	r24, Y
    4d36:	99 81       	ldd	r25, Y+1	; 0x01
    4d38:	e8 16       	cp	r14, r24
    4d3a:	f9 06       	cpc	r15, r25
    4d3c:	28 f0       	brcs	.+10     	; 0x4d48 <Sensors_Test+0x52>
	{
		strcat (Result, ("  "));  
    4d3e:	8c e9       	ldi	r24, 0x9C	; 156
    4d40:	95 e0       	ldi	r25, 0x05	; 5
    4d42:	68 e0       	ldi	r22, 0x08	; 8
    4d44:	71 e0       	ldi	r23, 0x01	; 1
    4d46:	04 c0       	rjmp	.+8      	; 0x4d50 <Sensors_Test+0x5a>
	}
	else
	{
		strcat (Result, (" X"));  
    4d48:	8c e9       	ldi	r24, 0x9C	; 156
    4d4a:	95 e0       	ldi	r25, 0x05	; 5
    4d4c:	6b e0       	ldi	r22, 0x0B	; 11
    4d4e:	71 e0       	ldi	r23, 0x01	; 1
    4d50:	0e 94 54 38 	call	0x70a8	; 0x70a8 <strcat>
	}
	  
	return Result;
}
    4d54:	8c e9       	ldi	r24, 0x9C	; 156
    4d56:	95 e0       	ldi	r25, 0x05	; 5
    4d58:	df 91       	pop	r29
    4d5a:	cf 91       	pop	r28
    4d5c:	1f 91       	pop	r17
    4d5e:	0f 91       	pop	r16
    4d60:	ff 90       	pop	r15
    4d62:	ef 90       	pop	r14
    4d64:	08 95       	ret

00004d66 <Sensors_Calibrate>:

/*
// Calibrate Sensors and return result in nResult global variable.
*/
void Sensors_Calibrate (void)
{
    4d66:	ef 92       	push	r14
    4d68:	ff 92       	push	r15
    4d6a:	0f 93       	push	r16
    4d6c:	1f 93       	push	r17
    4d6e:	df 93       	push	r29
    4d70:	cf 93       	push	r28
    4d72:	0f 92       	push	r0
    4d74:	cd b7       	in	r28, 0x3d	; 61
    4d76:	de b7       	in	r29, 0x3e	; 62
	BOOL LEDOLD = LED_Orange;
    4d78:	25 b1       	in	r18, 0x05	; 5
    4d7a:	26 95       	lsr	r18
    4d7c:	26 95       	lsr	r18
    4d7e:	26 95       	lsr	r18
    4d80:	21 70       	andi	r18, 0x01	; 1
	int i;
	for (i=0;i<6;++i)
	{
		nResult [i]=0;
    4d82:	10 92 8d 05 	sts	0x058D, r1
    4d86:	10 92 8c 05 	sts	0x058C, r1
    4d8a:	10 92 8f 05 	sts	0x058F, r1
    4d8e:	10 92 8e 05 	sts	0x058E, r1
    4d92:	10 92 91 05 	sts	0x0591, r1
    4d96:	10 92 90 05 	sts	0x0590, r1
    4d9a:	10 92 93 05 	sts	0x0593, r1
    4d9e:	10 92 92 05 	sts	0x0592, r1
    4da2:	10 92 95 05 	sts	0x0595, r1
    4da6:	10 92 94 05 	sts	0x0594, r1
    4daa:	10 92 97 05 	sts	0x0597, r1
    4dae:	10 92 96 05 	sts	0x0596, r1
    4db2:	59 e1       	ldi	r21, 0x19	; 25
    4db4:	e5 2e       	mov	r14, r21
    4db6:	f1 2c       	mov	r15, r1
	}
	
	// check: http://www.x-firm.com/?page_id=191
	for (int i=0;i<25;++i)
	{
		nResult[ACC_PITCH_Index] += ADCPort_Get(ACC_PITCH_PNUM);
    4db8:	00 91 92 05 	lds	r16, 0x0592
    4dbc:	10 91 93 05 	lds	r17, 0x0593
    4dc0:	85 e0       	ldi	r24, 0x05	; 5
    4dc2:	29 83       	std	Y+1, r18	; 0x01
    4dc4:	0e 94 25 28 	call	0x504a	; 0x504a <ADCPort_Get>
    4dc8:	08 0f       	add	r16, r24
    4dca:	19 1f       	adc	r17, r25
    4dcc:	10 93 93 05 	sts	0x0593, r17
    4dd0:	00 93 92 05 	sts	0x0592, r16
		nResult[ACC_ROLL_Index] += ADCPort_Get(ACC_ROLL_PNUM);
    4dd4:	00 91 94 05 	lds	r16, 0x0594
    4dd8:	10 91 95 05 	lds	r17, 0x0595
    4ddc:	86 e0       	ldi	r24, 0x06	; 6
    4dde:	0e 94 25 28 	call	0x504a	; 0x504a <ADCPort_Get>
    4de2:	08 0f       	add	r16, r24
    4de4:	19 1f       	adc	r17, r25
    4de6:	10 93 95 05 	sts	0x0595, r17
    4dea:	00 93 94 05 	sts	0x0594, r16
		nResult[ACC_Z_Index] += ADCPort_Get(ACC_Z_PNUM);
    4dee:	00 91 96 05 	lds	r16, 0x0596
    4df2:	10 91 97 05 	lds	r17, 0x0597
    4df6:	87 e0       	ldi	r24, 0x07	; 7
    4df8:	0e 94 25 28 	call	0x504a	; 0x504a <ADCPort_Get>
    4dfc:	08 0f       	add	r16, r24
    4dfe:	19 1f       	adc	r17, r25
    4e00:	10 93 97 05 	sts	0x0597, r17
    4e04:	00 93 96 05 	sts	0x0596, r16
		
		nResult[GYRO_ROLL_Index] += ADCPort_Get(GYRO_ROLL_PNUM);
    4e08:	00 91 8c 05 	lds	r16, 0x058C
    4e0c:	10 91 8d 05 	lds	r17, 0x058D
    4e10:	81 e0       	ldi	r24, 0x01	; 1
    4e12:	0e 94 25 28 	call	0x504a	; 0x504a <ADCPort_Get>
    4e16:	08 0f       	add	r16, r24
    4e18:	19 1f       	adc	r17, r25
    4e1a:	10 93 8d 05 	sts	0x058D, r17
    4e1e:	00 93 8c 05 	sts	0x058C, r16
		nResult[GYRO_PITCH_Index] += ADCPort_Get(GYRO_PITCH_PNUM);
    4e22:	00 91 8e 05 	lds	r16, 0x058E
    4e26:	10 91 8f 05 	lds	r17, 0x058F
    4e2a:	84 e0       	ldi	r24, 0x04	; 4
    4e2c:	0e 94 25 28 	call	0x504a	; 0x504a <ADCPort_Get>
    4e30:	08 0f       	add	r16, r24
    4e32:	19 1f       	adc	r17, r25
    4e34:	10 93 8f 05 	sts	0x058F, r17
    4e38:	00 93 8e 05 	sts	0x058E, r16
		nResult[GYRO_Z_Index] += ADCPort_Get(GYRO_Z_PNUM); 
    4e3c:	00 91 90 05 	lds	r16, 0x0590
    4e40:	10 91 91 05 	lds	r17, 0x0591
    4e44:	82 e0       	ldi	r24, 0x02	; 2
    4e46:	0e 94 25 28 	call	0x504a	; 0x504a <ADCPort_Get>
    4e4a:	08 0f       	add	r16, r24
    4e4c:	19 1f       	adc	r17, r25
    4e4e:	10 93 91 05 	sts	0x0591, r17
    4e52:	00 93 90 05 	sts	0x0590, r16
    4e56:	8f e0       	ldi	r24, 0x0F	; 15
    4e58:	97 e2       	ldi	r25, 0x27	; 39
    4e5a:	01 97       	sbiw	r24, 0x01	; 1
    4e5c:	f1 f7       	brne	.-4      	; 0x4e5a <Sensors_Calibrate+0xf4>
    4e5e:	00 c0       	rjmp	.+0      	; 0x4e60 <Sensors_Calibrate+0xfa>
    4e60:	00 00       	nop
		_delay_ms(40);
		LED_Orange =~LED_Orange;
    4e62:	85 b1       	in	r24, 0x05	; 5
    4e64:	86 95       	lsr	r24
    4e66:	86 95       	lsr	r24
    4e68:	86 95       	lsr	r24
    4e6a:	80 95       	com	r24
    4e6c:	81 70       	andi	r24, 0x01	; 1
    4e6e:	88 0f       	add	r24, r24
    4e70:	88 0f       	add	r24, r24
    4e72:	88 0f       	add	r24, r24
    4e74:	95 b1       	in	r25, 0x05	; 5
    4e76:	97 7f       	andi	r25, 0xF7	; 247
    4e78:	98 2b       	or	r25, r24
    4e7a:	95 b9       	out	0x05, r25	; 5
    4e7c:	08 94       	sec
    4e7e:	e1 08       	sbc	r14, r1
    4e80:	f1 08       	sbc	r15, r1
	{
		nResult [i]=0;
	}
	
	// check: http://www.x-firm.com/?page_id=191
	for (int i=0;i<25;++i)
    4e82:	29 81       	ldd	r18, Y+1	; 0x01
    4e84:	e1 14       	cp	r14, r1
    4e86:	f1 04       	cpc	r15, r1
    4e88:	09 f0       	breq	.+2      	; 0x4e8c <Sensors_Calibrate+0x126>
    4e8a:	96 cf       	rjmp	.-212    	; 0x4db8 <Sensors_Calibrate+0x52>
		nResult[GYRO_Z_Index] += ADCPort_Get(GYRO_Z_PNUM); 
		_delay_ms(40);
		LED_Orange =~LED_Orange;
	}
	
	LED_Orange = LEDOLD;
    4e8c:	21 70       	andi	r18, 0x01	; 1
    4e8e:	22 0f       	add	r18, r18
    4e90:	22 0f       	add	r18, r18
    4e92:	22 0f       	add	r18, r18
    4e94:	85 b1       	in	r24, 0x05	; 5
    4e96:	87 7f       	andi	r24, 0xF7	; 247
    4e98:	82 2b       	or	r24, r18
    4e9a:	85 b9       	out	0x05, r24	; 5
	
	for (i=0;i<6;++i)
    4e9c:	20 e0       	ldi	r18, 0x00	; 0
    4e9e:	30 e0       	ldi	r19, 0x00	; 0
	{
		nResult[i] /=25;
    4ea0:	09 e1       	ldi	r16, 0x19	; 25
    4ea2:	10 e0       	ldi	r17, 0x00	; 0
    4ea4:	f9 01       	movw	r30, r18
    4ea6:	ee 0f       	add	r30, r30
    4ea8:	ff 1f       	adc	r31, r31
    4eaa:	e4 57       	subi	r30, 0x74	; 116
    4eac:	fa 4f       	sbci	r31, 0xFA	; 250
    4eae:	80 81       	ld	r24, Z
    4eb0:	91 81       	ldd	r25, Z+1	; 0x01
    4eb2:	b8 01       	movw	r22, r16
    4eb4:	0e 94 e0 37 	call	0x6fc0	; 0x6fc0 <__udivmodhi4>
    4eb8:	71 83       	std	Z+1, r23	; 0x01
    4eba:	60 83       	st	Z, r22
		LED_Orange =~LED_Orange;
	}
	
	LED_Orange = LEDOLD;
	
	for (i=0;i<6;++i)
    4ebc:	2f 5f       	subi	r18, 0xFF	; 255
    4ebe:	3f 4f       	sbci	r19, 0xFF	; 255
    4ec0:	26 30       	cpi	r18, 0x06	; 6
    4ec2:	31 05       	cpc	r19, r1
    4ec4:	79 f7       	brne	.-34     	; 0x4ea4 <Sensors_Calibrate+0x13e>
	{
		nResult[i] /=25;
	}	
	
	Config.IsCalibrated = (Config.IsCalibrated | CALIBRATED_SENSOR);
    4ec6:	80 91 c6 06 	lds	r24, 0x06C6
    4eca:	84 60       	ori	r24, 0x04	; 4
    4ecc:	80 93 c6 06 	sts	0x06C6, r24
    4ed0:	a4 e6       	ldi	r26, 0x64	; 100
    4ed2:	b7 e0       	ldi	r27, 0x07	; 7
	for (i=0;i<6;++i)
    4ed4:	80 e0       	ldi	r24, 0x00	; 0
    4ed6:	90 e0       	ldi	r25, 0x00	; 0
	Config.Sensor_zero[i] = nResult[i];
    4ed8:	fc 01       	movw	r30, r24
    4eda:	ee 0f       	add	r30, r30
    4edc:	ff 1f       	adc	r31, r31
    4ede:	e4 57       	subi	r30, 0x74	; 116
    4ee0:	fa 4f       	sbci	r31, 0xFA	; 250
    4ee2:	20 81       	ld	r18, Z
    4ee4:	31 81       	ldd	r19, Z+1	; 0x01
    4ee6:	2d 93       	st	X+, r18
    4ee8:	3d 93       	st	X+, r19
	{
		nResult[i] /=25;
	}	
	
	Config.IsCalibrated = (Config.IsCalibrated | CALIBRATED_SENSOR);
	for (i=0;i<6;++i)
    4eea:	01 96       	adiw	r24, 0x01	; 1
    4eec:	86 30       	cpi	r24, 0x06	; 6
    4eee:	91 05       	cpc	r25, r1
    4ef0:	99 f7       	brne	.-26     	; 0x4ed8 <Sensors_Calibrate+0x172>
	Config.Sensor_zero[i] = nResult[i];
		
	
	//nResult[ACC_Z_Index]-=100; // Sensor: horizontal, upward ... the caller of this function is responsible for updating Config.Sensor_zero[i] = nResult[i];
		
}
    4ef2:	0f 90       	pop	r0
    4ef4:	cf 91       	pop	r28
    4ef6:	df 91       	pop	r29
    4ef8:	1f 91       	pop	r17
    4efa:	0f 91       	pop	r16
    4efc:	ff 90       	pop	r15
    4efe:	ef 90       	pop	r14
    4f00:	08 95       	ret

00004f02 <Sensor_GetBattery>:
}*/

int16_t  Sensor_GetBattery(void)
{
	 // because the V_BAT is connected to a voltage divider R1 & R2
	return (ADCPort_Get(V_BAT_PNUM) *  BAT_VOLT_RATIO);
    4f02:	83 e0       	ldi	r24, 0x03	; 3
    4f04:	0e 94 25 28 	call	0x504a	; 0x504a <ADCPort_Get>
    4f08:	24 e6       	ldi	r18, 0x64	; 100
    4f0a:	30 e0       	ldi	r19, 0x00	; 0
    4f0c:	ac 01       	movw	r20, r24
    4f0e:	42 9f       	mul	r20, r18
    4f10:	c0 01       	movw	r24, r0
    4f12:	43 9f       	mul	r20, r19
    4f14:	90 0d       	add	r25, r0
    4f16:	52 9f       	mul	r21, r18
    4f18:	90 0d       	add	r25, r0
    4f1a:	11 24       	eor	r1, r1
    4f1c:	64 e7       	ldi	r22, 0x74	; 116
    4f1e:	71 e0       	ldi	r23, 0x01	; 1
    4f20:	0e 94 e0 37 	call	0x6fc0	; 0x6fc0 <__udivmodhi4>
} 
    4f24:	cb 01       	movw	r24, r22
    4f26:	08 95       	ret

00004f28 <Sensors_ReadAll>:

#define DEAD_BAND_GYRO	0
//uint32_t LastLoopTime[2];
//uint16_t TX,TX1,TX2;
void Sensors_ReadAll (void)
{
    4f28:	cf 93       	push	r28
    4f2a:	df 93       	push	r29
   //{
		//TX1= TCNT1;
		//TX= TCNT1_X;
   //}   
	//
	Sensors_Latest[ACC_PITCH_Index] = ADCPort_Get(ACC_PITCH_PNUM)-Config.Sensor_zero[ACC_PITCH_Index]; 
    4f2c:	85 e0       	ldi	r24, 0x05	; 5
    4f2e:	0e 94 25 28 	call	0x504a	; 0x504a <ADCPort_Get>
    4f32:	20 91 6a 07 	lds	r18, 0x076A
    4f36:	30 91 6b 07 	lds	r19, 0x076B
    4f3a:	82 1b       	sub	r24, r18
    4f3c:	93 0b       	sbc	r25, r19
    4f3e:	90 93 30 06 	sts	0x0630, r25
    4f42:	80 93 2f 06 	sts	0x062F, r24
	Sensors_Latest[ACC_ROLL_Index] = ADCPort_Get(ACC_ROLL_PNUM)-Config.Sensor_zero[ACC_ROLL_Index];
    4f46:	86 e0       	ldi	r24, 0x06	; 6
    4f48:	0e 94 25 28 	call	0x504a	; 0x504a <ADCPort_Get>
    4f4c:	20 91 6c 07 	lds	r18, 0x076C
    4f50:	30 91 6d 07 	lds	r19, 0x076D
    4f54:	82 1b       	sub	r24, r18
    4f56:	93 0b       	sbc	r25, r19
    4f58:	90 93 32 06 	sts	0x0632, r25
    4f5c:	80 93 31 06 	sts	0x0631, r24
	Sensors_Latest[ACC_Z_Index] = ADCPort_Get(ACC_Z_PNUM)-Config.Sensor_zero[ACC_Z_Index];
    4f60:	87 e0       	ldi	r24, 0x07	; 7
    4f62:	0e 94 25 28 	call	0x504a	; 0x504a <ADCPort_Get>
    4f66:	20 91 6e 07 	lds	r18, 0x076E
    4f6a:	30 91 6f 07 	lds	r19, 0x076F
    4f6e:	82 1b       	sub	r24, r18
    4f70:	93 0b       	sbc	r25, r19
    4f72:	90 93 34 06 	sts	0x0634, r25
    4f76:	80 93 33 06 	sts	0x0633, r24
		
	Sensors_Latest[GYRO_ROLL_Index] = ADCPort_Get(GYRO_ROLL_PNUM)-Config.Sensor_zero[GYRO_ROLL_Index];
    4f7a:	81 e0       	ldi	r24, 0x01	; 1
    4f7c:	0e 94 25 28 	call	0x504a	; 0x504a <ADCPort_Get>
    4f80:	20 91 64 07 	lds	r18, 0x0764
    4f84:	30 91 65 07 	lds	r19, 0x0765
    4f88:	82 1b       	sub	r24, r18
    4f8a:	93 0b       	sbc	r25, r19
    4f8c:	c9 e2       	ldi	r28, 0x29	; 41
    4f8e:	d6 e0       	ldi	r29, 0x06	; 6
    4f90:	99 83       	std	Y+1, r25	; 0x01
    4f92:	88 83       	st	Y, r24
	if (abs(Sensors_Latest[GYRO_ROLL_Index])< DEAD_BAND_GYRO) Sensors_Latest[GYRO_ROLL_Index] = 0;
    4f94:	88 81       	ld	r24, Y
    4f96:	99 81       	ldd	r25, Y+1	; 0x01
	Sensors_Latest[GYRO_PITCH_Index] = ADCPort_Get(GYRO_PITCH_PNUM)-Config.Sensor_zero[GYRO_PITCH_Index];
    4f98:	84 e0       	ldi	r24, 0x04	; 4
    4f9a:	0e 94 25 28 	call	0x504a	; 0x504a <ADCPort_Get>
    4f9e:	20 91 66 07 	lds	r18, 0x0766
    4fa2:	30 91 67 07 	lds	r19, 0x0767
    4fa6:	82 1b       	sub	r24, r18
    4fa8:	93 0b       	sbc	r25, r19
    4faa:	9b 83       	std	Y+3, r25	; 0x03
    4fac:	8a 83       	std	Y+2, r24	; 0x02
	if (abs(Sensors_Latest[GYRO_PITCH_Index])< DEAD_BAND_GYRO) Sensors_Latest[GYRO_PITCH_Index] = 0;
    4fae:	8a 81       	ldd	r24, Y+2	; 0x02
    4fb0:	9b 81       	ldd	r25, Y+3	; 0x03
	Sensors_Latest[GYRO_Z_Index] = ADCPort_Get(GYRO_Z_PNUM)-Config.Sensor_zero[GYRO_Z_Index];
    4fb2:	82 e0       	ldi	r24, 0x02	; 2
    4fb4:	0e 94 25 28 	call	0x504a	; 0x504a <ADCPort_Get>
    4fb8:	20 91 68 07 	lds	r18, 0x0768
    4fbc:	30 91 69 07 	lds	r19, 0x0769
    4fc0:	82 1b       	sub	r24, r18
    4fc2:	93 0b       	sbc	r25, r19
    4fc4:	9d 83       	std	Y+5, r25	; 0x05
    4fc6:	8c 83       	std	Y+4, r24	; 0x04
	if (abs(Sensors_Latest[GYRO_Z_Index])< DEAD_BAND_GYRO) Sensors_Latest[GYRO_Z_Index] = 0;
    4fc8:	8c 81       	ldd	r24, Y+4	; 0x04
    4fca:	9d 81       	ldd	r25, Y+5	; 0x05
	
	Sensors_Latest[V_BAT_Index] = Sensor_GetBattery(); 
    4fcc:	0e 94 81 27 	call	0x4f02	; 0x4f02 <Sensor_GetBattery>
    4fd0:	9d 87       	std	Y+13, r25	; 0x0d
    4fd2:	8c 87       	std	Y+12, r24	; 0x0c
	//else
	//{
		//Sensors_dt = TX1 - TX2;
	//}
	//TX2=TX1;
}
    4fd4:	df 91       	pop	r29
    4fd6:	cf 91       	pop	r28
    4fd8:	08 95       	ret

00004fda <__vector_24>:
 * 
 *  8.913kHz on mega128 16MHz 1kHz/channel ??
 ***** I used 20 MHz 13 - 260 us conv average = (260-13)/2 + 13 = 136.5 us = 7.326 KHz
*/
ISR(ADC_vect, ISR_NOBLOCK)
{
    4fda:	78 94       	sei
    4fdc:	1f 92       	push	r1
    4fde:	0f 92       	push	r0
    4fe0:	0f b6       	in	r0, 0x3f	; 63
    4fe2:	0f 92       	push	r0
    4fe4:	11 24       	eor	r1, r1
    4fe6:	2f 93       	push	r18
    4fe8:	8f 93       	push	r24
    4fea:	9f 93       	push	r25
    4fec:	ef 93       	push	r30
    4fee:	ff 93       	push	r31
	static uint8_t _index;
	ADCValues[_index] = ADC;
    4ff0:	20 91 29 05 	lds	r18, 0x0529
    4ff4:	e2 2f       	mov	r30, r18
    4ff6:	f0 e0       	ldi	r31, 0x00	; 0
    4ff8:	80 91 78 00 	lds	r24, 0x0078
    4ffc:	90 91 79 00 	lds	r25, 0x0079
    5000:	ee 0f       	add	r30, r30
    5002:	ff 1f       	adc	r31, r31
    5004:	ec 5f       	subi	r30, 0xFC	; 252
    5006:	f7 4f       	sbci	r31, 0xF7	; 247
    5008:	91 83       	std	Z+1, r25	; 0x01
    500a:	80 83       	st	Z, r24
	_index = (_index + 1) % 8U;
    500c:	82 2f       	mov	r24, r18
    500e:	8f 5f       	subi	r24, 0xFF	; 255
    5010:	87 70       	andi	r24, 0x07	; 7
    5012:	80 93 29 05 	sts	0x0529, r24
	ADMUX = _index;
    5016:	80 93 7c 00 	sts	0x007C, r24
	ADCSRA |= _BV(ADSC);
    501a:	ea e7       	ldi	r30, 0x7A	; 122
    501c:	f0 e0       	ldi	r31, 0x00	; 0
    501e:	80 81       	ld	r24, Z
    5020:	80 64       	ori	r24, 0x40	; 64
    5022:	80 83       	st	Z, r24
	
	
}
    5024:	ff 91       	pop	r31
    5026:	ef 91       	pop	r30
    5028:	9f 91       	pop	r25
    502a:	8f 91       	pop	r24
    502c:	2f 91       	pop	r18
    502e:	0f 90       	pop	r0
    5030:	0f be       	out	0x3f, r0	; 63
    5032:	0f 90       	pop	r0
    5034:	1f 90       	pop	r1
    5036:	18 95       	reti

00005038 <ADCPort_Init>:

void ADCPort_Init ()
{
	DIDR0 = 0xFF;	// disable all digital inputs on Port A
    5038:	8f ef       	ldi	r24, 0xFF	; 255
    503a:	80 93 7e 00 	sts	0x007E, r24
	ADMUX = 0;
    503e:	10 92 7c 00 	sts	0x007C, r1
	ADCSRA = 0b11011111;	// ADEN, ADSC, ADIE, 
    5042:	8f ed       	ldi	r24, 0xDF	; 223
    5044:	80 93 7a 00 	sts	0x007A, r24
		
}
    5048:	08 95       	ret

0000504a <ADCPort_Get>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    504a:	f8 94       	cli
*/
inline uint16_t ADCPort_Get(uint8_t channel)
{
	uint16_t _t;
	ATOMIC_BLOCK(ATOMIC_FORCEON)
		_t = ADCValues[channel];
    504c:	e8 2f       	mov	r30, r24
    504e:	f0 e0       	ldi	r31, 0x00	; 0
    5050:	ee 0f       	add	r30, r30
    5052:	ff 1f       	adc	r31, r31
    5054:	ec 5f       	subi	r30, 0xFC	; 252
    5056:	f7 4f       	sbci	r31, 0xF7	; 247
    5058:	20 81       	ld	r18, Z
    505a:	31 81       	ldd	r19, Z+1	; 0x01
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    505c:	78 94       	sei
	return _t;
    505e:	c9 01       	movw	r24, r18
    5060:	08 95       	ret

00005062 <_hHomeRestart>:
}


void _hHomeRestart (void)
{
	NOKEYRETURN
    5062:	80 91 a8 05 	lds	r24, 0x05A8
    5066:	88 23       	and	r24, r24
    5068:	11 f0       	breq	.+4      	; 0x506e <_hHomeRestart+0xc>
	
	if (KEY4)
    506a:	84 fd       	sbrc	r24, 4
    506c:	ff cf       	rjmp	.-2      	; 0x506c <_hHomeRestart+0xa>
    506e:	08 95       	ret

00005070 <tsmMain>:
	Menu_LoadPage(PAGE_HOME);
}

PGM_P tsmMain(uint8_t index)
{
	return (PGM_P)pgm_read_word(&lstMenu[index]);
    5070:	90 e0       	ldi	r25, 0x00	; 0
    5072:	88 0f       	add	r24, r24
    5074:	99 1f       	adc	r25, r25
    5076:	8b 52       	subi	r24, 0x2B	; 43
    5078:	94 4f       	sbci	r25, 0xF4	; 244
    507a:	fc 01       	movw	r30, r24
    507c:	25 91       	lpm	r18, Z+
    507e:	34 91       	lpm	r19, Z+
}
    5080:	c9 01       	movw	r24, r18
    5082:	08 95       	ret

00005084 <writeSoftkeys>:
		//LCD_WriteString_P(e.text);
	//}
//}

static void writeSoftkeys(const char* sk)
{
    5084:	cf 93       	push	r28
    5086:	df 93       	push	r29
    5088:	ec 01       	movw	r28, r24
	if (!sk)
    508a:	00 97       	sbiw	r24, 0x00	; 0
    508c:	31 f4       	brne	.+12     	; 0x509a <writeSoftkeys+0x16>
		sk = currentPage.softkeys;
    508e:	c0 91 30 05 	lds	r28, 0x0530
    5092:	d0 91 31 05 	lds	r29, 0x0531
	if (sk)
    5096:	20 97       	sbiw	r28, 0x00	; 0
    5098:	39 f0       	breq	.+14     	; 0x50a8 <writeSoftkeys+0x24>
	{
		LCD_SetPos(7, 0);
    509a:	87 e0       	ldi	r24, 0x07	; 7
    509c:	60 e0       	ldi	r22, 0x00	; 0
    509e:	0e 94 08 0c 	call	0x1810	; 0x1810 <LCD_SetPos>
		LCD_WriteString_P(sk);
    50a2:	ce 01       	movw	r24, r28
    50a4:	0e 94 05 0d 	call	0x1a0a	; 0x1a0a <LCD_WriteString_P>
	}
}
    50a8:	df 91       	pop	r29
    50aa:	cf 91       	pop	r28
    50ac:	08 95       	ret

000050ae <_hDebug>:

	static double YAWAngle;
static double OldAngle;
	static double YAWAngle2;
void _hDebug()
{
    50ae:	ef 92       	push	r14
    50b0:	0f 93       	push	r16

	if (IS_INIT)
    50b2:	80 91 a8 05 	lds	r24, 0x05A8
    50b6:	80 fd       	sbrc	r24, 0
    50b8:	6a c0       	rjmp	.+212    	; 0x518e <_hDebug+0xe0>
			//send_byte(0x01);
			//send_byte(0x01);send_byte(0x00);send_byte(0x00);send_byte(0x00);
			//send_byte(98);
	
		}
		if (KEY3)
    50ba:	85 ff       	sbrs	r24, 5
    50bc:	1b c0       	rjmp	.+54     	; 0x50f4 <_hDebug+0x46>
		{
			//gyroZangle=0;
			//gyroYangle=0;
			//gyroXangle=0;
			AnglePitch=0;
    50be:	80 e0       	ldi	r24, 0x00	; 0
    50c0:	90 e0       	ldi	r25, 0x00	; 0
    50c2:	dc 01       	movw	r26, r24
    50c4:	80 93 04 06 	sts	0x0604, r24
    50c8:	90 93 05 06 	sts	0x0605, r25
    50cc:	a0 93 06 06 	sts	0x0606, r26
    50d0:	b0 93 07 06 	sts	0x0607, r27
			AngleRoll=0;
    50d4:	80 93 bc 06 	sts	0x06BC, r24
    50d8:	90 93 bd 06 	sts	0x06BD, r25
    50dc:	a0 93 be 06 	sts	0x06BE, r26
    50e0:	b0 93 bf 06 	sts	0x06BF, r27
			AngleZ =0;
    50e4:	80 93 4a 06 	sts	0x064A, r24
    50e8:	90 93 4b 06 	sts	0x064B, r25
    50ec:	a0 93 4c 06 	sts	0x064C, r26
    50f0:	b0 93 4d 06 	sts	0x064D, r27
		}	
		LCD_SetPos(0, 18);
    50f4:	80 e0       	ldi	r24, 0x00	; 0
    50f6:	62 e1       	ldi	r22, 0x12	; 18
    50f8:	0e 94 08 0c 	call	0x1810	; 0x1810 <LCD_SetPos>
		LCD_WriteString_P(PSTR("Meas"));
    50fc:	8b ef       	ldi	r24, 0xFB	; 251
    50fe:	9b e0       	ldi	r25, 0x0B	; 11
    5100:	0e 94 05 0d 	call	0x1a0a	; 0x1a0a <LCD_WriteString_P>
		LCD_WriteValue_double_ex(1,48, AnglePitch,9,false);
    5104:	20 91 04 06 	lds	r18, 0x0604
    5108:	30 91 05 06 	lds	r19, 0x0605
    510c:	40 91 06 06 	lds	r20, 0x0606
    5110:	50 91 07 06 	lds	r21, 0x0607
    5114:	81 e0       	ldi	r24, 0x01	; 1
    5116:	60 e3       	ldi	r22, 0x30	; 48
    5118:	09 e0       	ldi	r16, 0x09	; 9
    511a:	ee 24       	eor	r14, r14
    511c:	0e 94 b2 0d 	call	0x1b64	; 0x1b64 <LCD_WriteValue_double_ex>
		LCD_WriteValue_double_ex(2,48, AngleRoll,9,false);
    5120:	20 91 bc 06 	lds	r18, 0x06BC
    5124:	30 91 bd 06 	lds	r19, 0x06BD
    5128:	40 91 be 06 	lds	r20, 0x06BE
    512c:	50 91 bf 06 	lds	r21, 0x06BF
    5130:	82 e0       	ldi	r24, 0x02	; 2
    5132:	60 e3       	ldi	r22, 0x30	; 48
    5134:	0e 94 b2 0d 	call	0x1b64	; 0x1b64 <LCD_WriteValue_double_ex>
		LCD_WriteValue_double_ex(3,48, AngleZ,9,false);
    5138:	20 91 4a 06 	lds	r18, 0x064A
    513c:	30 91 4b 06 	lds	r19, 0x064B
    5140:	40 91 4c 06 	lds	r20, 0x064C
    5144:	50 91 4d 06 	lds	r21, 0x064D
    5148:	83 e0       	ldi	r24, 0x03	; 3
    514a:	60 e3       	ldi	r22, 0x30	; 48
    514c:	0e 94 b2 0d 	call	0x1b64	; 0x1b64 <LCD_WriteValue_double_ex>
		LCD_WriteValue_double_ex(4,48, NavX,9,false);
    5150:	20 91 36 05 	lds	r18, 0x0536
    5154:	30 91 37 05 	lds	r19, 0x0537
    5158:	40 91 38 05 	lds	r20, 0x0538
    515c:	50 91 39 05 	lds	r21, 0x0539
    5160:	84 e0       	ldi	r24, 0x04	; 4
    5162:	60 e3       	ldi	r22, 0x30	; 48
    5164:	0e 94 b2 0d 	call	0x1b64	; 0x1b64 <LCD_WriteValue_double_ex>
		LCD_WriteValue(5,48,Sensors_Latest[GYRO_PITCH_Index],4,true);
    5168:	40 91 2b 06 	lds	r20, 0x062B
    516c:	50 91 2c 06 	lds	r21, 0x062C
    5170:	85 e0       	ldi	r24, 0x05	; 5
    5172:	60 e3       	ldi	r22, 0x30	; 48
    5174:	24 e0       	ldi	r18, 0x04	; 4
    5176:	01 e0       	ldi	r16, 0x01	; 1
    5178:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <LCD_WriteValue>
		LCD_WriteValue(6,48,TimeDef,4,true);
    517c:	40 91 c0 06 	lds	r20, 0x06C0
    5180:	50 91 c1 06 	lds	r21, 0x06C1
    5184:	86 e0       	ldi	r24, 0x06	; 6
    5186:	60 e3       	ldi	r22, 0x30	; 48
    5188:	24 e0       	ldi	r18, 0x04	; 4
    518a:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <LCD_WriteValue>
		
		//LCD_WriteValue(4,48, MotorOut[3],9,false);
	}
}
    518e:	0f 91       	pop	r16
    5190:	ef 90       	pop	r14
    5192:	08 95       	ret

00005194 <_hSensorCalibration>:

	_helper_DisplayRXStatus(6);
}

void _hSensorCalibration()
{
    5194:	0f 93       	push	r16
    5196:	1f 93       	push	r17
    5198:	cf 93       	push	r28
    519a:	df 93       	push	r29
	NOKEYRETURN;
    519c:	80 91 a8 05 	lds	r24, 0x05A8
    51a0:	88 23       	and	r24, r24
    51a2:	69 f1       	breq	.+90     	; 0x51fe <_hSensorCalibration+0x6a>
	uint8_t i;
		
	if (KEY4)
    51a4:	84 ff       	sbrs	r24, 4
    51a6:	19 c0       	rjmp	.+50     	; 0x51da <_hSensorCalibration+0x46>
    51a8:	15 e0       	ldi	r17, 0x05	; 5
	{
		// Delay to allow not touching the board.		
		for (i=0; i<5;++i)
		{
			LED_FlashOrangeLED (200,2);
    51aa:	88 ec       	ldi	r24, 0xC8	; 200
    51ac:	90 e0       	ldi	r25, 0x00	; 0
    51ae:	62 e0       	ldi	r22, 0x02	; 2
    51b0:	0e 94 93 0e 	call	0x1d26	; 0x1d26 <LED_FlashOrangeLED>
			Beeper_Beep(BEEP_SHORT,1);
    51b4:	86 e4       	ldi	r24, 0x46	; 70
    51b6:	90 e0       	ldi	r25, 0x00	; 0
    51b8:	61 e0       	ldi	r22, 0x01	; 1
    51ba:	0e 94 91 0b 	call	0x1722	; 0x1722 <Beeper_Beep>
    51be:	11 50       	subi	r17, 0x01	; 1
	uint8_t i;
		
	if (KEY4)
	{
		// Delay to allow not touching the board.		
		for (i=0; i<5;++i)
    51c0:	a1 f7       	brne	.-24     	; 0x51aa <_hSensorCalibration+0x16>
		{
			LED_FlashOrangeLED (200,2);
			Beeper_Beep(BEEP_SHORT,1);
		}
	
		Sensors_Calibrate ();
    51c2:	0e 94 b3 26 	call	0x4d66	; 0x4d66 <Sensors_Calibrate>
		
		Save_Config_to_EEPROM();
    51c6:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <Save_Config_to_EEPROM>
		currentPage.softkeys = _skBACK;
    51ca:	8c ed       	ldi	r24, 0xDC	; 220
    51cc:	9c e0       	ldi	r25, 0x0C	; 12
    51ce:	90 93 31 05 	sts	0x0531, r25
    51d2:	80 93 30 05 	sts	0x0530, r24
		writeSoftkeys(currentPage.softkeys);
    51d6:	0e 94 42 28 	call	0x5084	; 0x5084 <writeSoftkeys>
    51da:	c4 e6       	ldi	r28, 0x64	; 100
    51dc:	d7 e0       	ldi	r29, 0x07	; 7
void _hSensorCalibration()
{
	NOKEYRETURN;
	uint8_t i;
		
	if (KEY4)
    51de:	10 e0       	ldi	r17, 0x00	; 0
	}
	
	
	for (i=0; i<6;++i)
	{ // order is aligned with ACC_PITCH_Index & GYRO_ROLL_Index
		LCD_SetPos(i, 48);
    51e0:	81 2f       	mov	r24, r17
    51e2:	60 e3       	ldi	r22, 0x30	; 48
    51e4:	0e 94 08 0c 	call	0x1810	; 0x1810 <LCD_SetPos>
		LCD_WriteValue(i,48,Config.Sensor_zero[i],5,false);
    51e8:	49 91       	ld	r20, Y+
    51ea:	59 91       	ld	r21, Y+
    51ec:	81 2f       	mov	r24, r17
    51ee:	60 e3       	ldi	r22, 0x30	; 48
    51f0:	25 e0       	ldi	r18, 0x05	; 5
    51f2:	00 e0       	ldi	r16, 0x00	; 0
    51f4:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <LCD_WriteValue>
		currentPage.softkeys = _skBACK;
		writeSoftkeys(currentPage.softkeys);
	}
	
	
	for (i=0; i<6;++i)
    51f8:	1f 5f       	subi	r17, 0xFF	; 255
    51fa:	16 30       	cpi	r17, 0x06	; 6
    51fc:	89 f7       	brne	.-30     	; 0x51e0 <_hSensorCalibration+0x4c>
	{ // order is aligned with ACC_PITCH_Index & GYRO_ROLL_Index
		LCD_SetPos(i, 48);
		LCD_WriteValue(i,48,Config.Sensor_zero[i],5,false);
	}	
	
}
    51fe:	df 91       	pop	r29
    5200:	cf 91       	pop	r28
    5202:	1f 91       	pop	r17
    5204:	0f 91       	pop	r16
    5206:	08 95       	ret

00005208 <_hSensorTest>:
	}
}


void _hSensorTest()
{
    5208:	0f 93       	push	r16
	#define AccHighLimit		850
	#define GyroLowLimit		500		
	#define GyroHighLimit		630

	
	LCD_SetPos(0, 48);
    520a:	80 e0       	ldi	r24, 0x00	; 0
    520c:	60 e3       	ldi	r22, 0x30	; 48
    520e:	0e 94 08 0c 	call	0x1810	; 0x1810 <LCD_SetPos>
	LCD_WriteString(Sensors_Test(GYRO_ROLL_PNUM,GyroLowLimit,GyroHighLimit));
    5212:	81 e0       	ldi	r24, 0x01	; 1
    5214:	64 ef       	ldi	r22, 0xF4	; 244
    5216:	71 e0       	ldi	r23, 0x01	; 1
    5218:	46 e7       	ldi	r20, 0x76	; 118
    521a:	52 e0       	ldi	r21, 0x02	; 2
    521c:	0e 94 7b 26 	call	0x4cf6	; 0x4cf6 <Sensors_Test>
    5220:	0e 94 f1 0c 	call	0x19e2	; 0x19e2 <LCD_WriteString>
	LCD_SetPos(1, 48);
    5224:	81 e0       	ldi	r24, 0x01	; 1
    5226:	60 e3       	ldi	r22, 0x30	; 48
    5228:	0e 94 08 0c 	call	0x1810	; 0x1810 <LCD_SetPos>
	LCD_WriteString(Sensors_Test(GYRO_PITCH_PNUM,GyroLowLimit,GyroHighLimit));
    522c:	84 e0       	ldi	r24, 0x04	; 4
    522e:	64 ef       	ldi	r22, 0xF4	; 244
    5230:	71 e0       	ldi	r23, 0x01	; 1
    5232:	46 e7       	ldi	r20, 0x76	; 118
    5234:	52 e0       	ldi	r21, 0x02	; 2
    5236:	0e 94 7b 26 	call	0x4cf6	; 0x4cf6 <Sensors_Test>
    523a:	0e 94 f1 0c 	call	0x19e2	; 0x19e2 <LCD_WriteString>
	LCD_SetPos(2, 48);
    523e:	82 e0       	ldi	r24, 0x02	; 2
    5240:	60 e3       	ldi	r22, 0x30	; 48
    5242:	0e 94 08 0c 	call	0x1810	; 0x1810 <LCD_SetPos>
	LCD_WriteString(Sensors_Test(GYRO_Z_PNUM,GyroLowLimit,GyroHighLimit));
    5246:	82 e0       	ldi	r24, 0x02	; 2
    5248:	64 ef       	ldi	r22, 0xF4	; 244
    524a:	71 e0       	ldi	r23, 0x01	; 1
    524c:	46 e7       	ldi	r20, 0x76	; 118
    524e:	52 e0       	ldi	r21, 0x02	; 2
    5250:	0e 94 7b 26 	call	0x4cf6	; 0x4cf6 <Sensors_Test>
    5254:	0e 94 f1 0c 	call	0x19e2	; 0x19e2 <LCD_WriteString>
	
	LCD_SetPos(3, 48);
    5258:	83 e0       	ldi	r24, 0x03	; 3
    525a:	60 e3       	ldi	r22, 0x30	; 48
    525c:	0e 94 08 0c 	call	0x1810	; 0x1810 <LCD_SetPos>
	LCD_WriteString(Sensors_Test(ACC_PITCH_PNUM,AccLowLimit,AccHighLimit));
    5260:	85 e0       	ldi	r24, 0x05	; 5
    5262:	62 ec       	ldi	r22, 0xC2	; 194
    5264:	71 e0       	ldi	r23, 0x01	; 1
    5266:	42 e5       	ldi	r20, 0x52	; 82
    5268:	53 e0       	ldi	r21, 0x03	; 3
    526a:	0e 94 7b 26 	call	0x4cf6	; 0x4cf6 <Sensors_Test>
    526e:	0e 94 f1 0c 	call	0x19e2	; 0x19e2 <LCD_WriteString>
	LCD_SetPos(4, 48);
    5272:	84 e0       	ldi	r24, 0x04	; 4
    5274:	60 e3       	ldi	r22, 0x30	; 48
    5276:	0e 94 08 0c 	call	0x1810	; 0x1810 <LCD_SetPos>
	LCD_WriteString(Sensors_Test(ACC_ROLL_PNUM,AccLowLimit,AccHighLimit));
    527a:	86 e0       	ldi	r24, 0x06	; 6
    527c:	62 ec       	ldi	r22, 0xC2	; 194
    527e:	71 e0       	ldi	r23, 0x01	; 1
    5280:	42 e5       	ldi	r20, 0x52	; 82
    5282:	53 e0       	ldi	r21, 0x03	; 3
    5284:	0e 94 7b 26 	call	0x4cf6	; 0x4cf6 <Sensors_Test>
    5288:	0e 94 f1 0c 	call	0x19e2	; 0x19e2 <LCD_WriteString>
	LCD_SetPos(5, 48);
    528c:	85 e0       	ldi	r24, 0x05	; 5
    528e:	60 e3       	ldi	r22, 0x30	; 48
    5290:	0e 94 08 0c 	call	0x1810	; 0x1810 <LCD_SetPos>
	LCD_WriteString(Sensors_Test(ACC_Z_PNUM,AccLowLimit,AccHighLimit));
    5294:	87 e0       	ldi	r24, 0x07	; 7
    5296:	62 ec       	ldi	r22, 0xC2	; 194
    5298:	71 e0       	ldi	r23, 0x01	; 1
    529a:	42 e5       	ldi	r20, 0x52	; 82
    529c:	53 e0       	ldi	r21, 0x03	; 3
    529e:	0e 94 7b 26 	call	0x4cf6	; 0x4cf6 <Sensors_Test>
    52a2:	0e 94 f1 0c 	call	0x19e2	; 0x19e2 <LCD_WriteString>
	LCD_SetPos(6, 48);
    52a6:	86 e0       	ldi	r24, 0x06	; 6
    52a8:	60 e3       	ldi	r22, 0x30	; 48
    52aa:	0e 94 08 0c 	call	0x1810	; 0x1810 <LCD_SetPos>
	LCD_WriteValue_double(6,48,Sensor_GetBattery(),false);
    52ae:	0e 94 81 27 	call	0x4f02	; 0x4f02 <Sensor_GetBattery>
    52b2:	9c 01       	movw	r18, r24
    52b4:	b9 01       	movw	r22, r18
    52b6:	88 27       	eor	r24, r24
    52b8:	77 fd       	sbrc	r23, 7
    52ba:	80 95       	com	r24
    52bc:	98 2f       	mov	r25, r24
    52be:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    52c2:	9b 01       	movw	r18, r22
    52c4:	ac 01       	movw	r20, r24
    52c6:	86 e0       	ldi	r24, 0x06	; 6
    52c8:	60 e3       	ldi	r22, 0x30	; 48
    52ca:	00 e0       	ldi	r16, 0x00	; 0
    52cc:	0e 94 f2 0d 	call	0x1be4	; 0x1be4 <LCD_WriteValue_double>
}
    52d0:	0f 91       	pop	r16
    52d2:	08 95       	ret

000052d4 <_hHomeArmedESC>:


void _hHomeArmedESC (void)
{
	
	if (IS_INIT)	
    52d4:	80 91 a8 05 	lds	r24, 0x05A8
    52d8:	80 ff       	sbrs	r24, 0
    52da:	10 c0       	rjmp	.+32     	; 0x52fc <_hHomeArmedESC+0x28>
	{
		LCD_SelectFont (&font12x16);
    52dc:	89 e4       	ldi	r24, 0x49	; 73
    52de:	91 e0       	ldi	r25, 0x01	; 1
    52e0:	0e 94 5c 0e 	call	0x1cb8	; 0x1cb8 <LCD_SelectFont>
		LCD_SetPos(0,0);
    52e4:	80 e0       	ldi	r24, 0x00	; 0
    52e6:	60 e0       	ldi	r22, 0x00	; 0
    52e8:	0e 94 08 0c 	call	0x1810	; 0x1810 <LCD_SetPos>
		LCD_WriteString_P(strARMED);
    52ec:	80 e0       	ldi	r24, 0x00	; 0
    52ee:	9d e0       	ldi	r25, 0x0D	; 13
    52f0:	0e 94 05 0d 	call	0x1a0a	; 0x1a0a <LCD_WriteString_P>
		LCD_SelectFont (NULL);
    52f4:	80 e0       	ldi	r24, 0x00	; 0
    52f6:	90 e0       	ldi	r25, 0x00	; 0
    52f8:	0e 94 5c 0e 	call	0x1cb8	; 0x1cb8 <LCD_SelectFont>
	}
	
	if (KEY4)
    52fc:	80 91 a8 05 	lds	r24, 0x05A8
    5300:	84 ff       	sbrs	r24, 4
    5302:	04 c0       	rjmp	.+8      	; 0x530c <_hHomeArmedESC+0x38>
	{
		//reset ESC Calibration mode.
		Config.IsESCCalibration=ESCCalibration_OFF;
    5304:	10 92 cb 06 	sts	0x06CB, r1
		Save_Config_to_EEPROM();
    5308:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <Save_Config_to_EEPROM>
	}
	
	LCD_SetPos(3,18);
    530c:	83 e0       	ldi	r24, 0x03	; 3
    530e:	62 e1       	ldi	r22, 0x12	; 18
    5310:	0e 94 08 0c 	call	0x1810	; 0x1810 <LCD_SetPos>
	itoa(MotorOut[0],sXDeg,10);
    5314:	80 91 84 05 	lds	r24, 0x0584
    5318:	90 91 85 05 	lds	r25, 0x0585
    531c:	68 ed       	ldi	r22, 0xD8	; 216
    531e:	75 e0       	ldi	r23, 0x05	; 5
    5320:	4a e0       	ldi	r20, 0x0A	; 10
    5322:	50 e0       	ldi	r21, 0x00	; 0
    5324:	0e 94 5f 38 	call	0x70be	; 0x70be <itoa>
	LCD_WritePadded(sXDeg,5);
    5328:	88 ed       	ldi	r24, 0xD8	; 216
    532a:	95 e0       	ldi	r25, 0x05	; 5
    532c:	65 e0       	ldi	r22, 0x05	; 5
    532e:	0e 94 57 0d 	call	0x1aae	; 0x1aae <LCD_WritePadded>
	
	LCD_SetPos(3,78);
    5332:	83 e0       	ldi	r24, 0x03	; 3
    5334:	6e e4       	ldi	r22, 0x4E	; 78
    5336:	0e 94 08 0c 	call	0x1810	; 0x1810 <LCD_SetPos>
	itoa(MotorOut[3],sXDeg,10);
    533a:	80 91 8a 05 	lds	r24, 0x058A
    533e:	90 91 8b 05 	lds	r25, 0x058B
    5342:	68 ed       	ldi	r22, 0xD8	; 216
    5344:	75 e0       	ldi	r23, 0x05	; 5
    5346:	4a e0       	ldi	r20, 0x0A	; 10
    5348:	50 e0       	ldi	r21, 0x00	; 0
    534a:	0e 94 5f 38 	call	0x70be	; 0x70be <itoa>
	LCD_WritePadded(sXDeg,5);
    534e:	88 ed       	ldi	r24, 0xD8	; 216
    5350:	95 e0       	ldi	r25, 0x05	; 5
    5352:	65 e0       	ldi	r22, 0x05	; 5
    5354:	0e 94 57 0d 	call	0x1aae	; 0x1aae <LCD_WritePadded>
	
	LCD_SetPos(4,18);
    5358:	84 e0       	ldi	r24, 0x04	; 4
    535a:	62 e1       	ldi	r22, 0x12	; 18
    535c:	0e 94 08 0c 	call	0x1810	; 0x1810 <LCD_SetPos>
	itoa(MotorOut[1],sXDeg,10);
    5360:	80 91 86 05 	lds	r24, 0x0586
    5364:	90 91 87 05 	lds	r25, 0x0587
    5368:	68 ed       	ldi	r22, 0xD8	; 216
    536a:	75 e0       	ldi	r23, 0x05	; 5
    536c:	4a e0       	ldi	r20, 0x0A	; 10
    536e:	50 e0       	ldi	r21, 0x00	; 0
    5370:	0e 94 5f 38 	call	0x70be	; 0x70be <itoa>
	LCD_WritePadded(sXDeg,5);
    5374:	88 ed       	ldi	r24, 0xD8	; 216
    5376:	95 e0       	ldi	r25, 0x05	; 5
    5378:	65 e0       	ldi	r22, 0x05	; 5
    537a:	0e 94 57 0d 	call	0x1aae	; 0x1aae <LCD_WritePadded>
	
	LCD_SetPos(4,78);
    537e:	84 e0       	ldi	r24, 0x04	; 4
    5380:	6e e4       	ldi	r22, 0x4E	; 78
    5382:	0e 94 08 0c 	call	0x1810	; 0x1810 <LCD_SetPos>
	itoa(MotorOut[2],sXDeg,10);
    5386:	80 91 88 05 	lds	r24, 0x0588
    538a:	90 91 89 05 	lds	r25, 0x0589
    538e:	68 ed       	ldi	r22, 0xD8	; 216
    5390:	75 e0       	ldi	r23, 0x05	; 5
    5392:	4a e0       	ldi	r20, 0x0A	; 10
    5394:	50 e0       	ldi	r21, 0x00	; 0
    5396:	0e 94 5f 38 	call	0x70be	; 0x70be <itoa>
	LCD_WritePadded(sXDeg,5);
    539a:	88 ed       	ldi	r24, 0xD8	; 216
    539c:	95 e0       	ldi	r25, 0x05	; 5
    539e:	65 e0       	ldi	r22, 0x05	; 5
    53a0:	0e 94 57 0d 	call	0x1aae	; 0x1aae <LCD_WritePadded>
	
}
    53a4:	08 95       	ret

000053a6 <_helper_DisplayPitchRollYaw>:
	};
//////////////////////////////////////////////////////////////////////////

void _helper_DisplayPitchRollYaw (const uint8_t subindex)
{
	switch (subindex)
    53a6:	81 30       	cpi	r24, 0x01	; 1
    53a8:	99 f0       	breq	.+38     	; 0x53d0 <_helper_DisplayPitchRollYaw+0x2a>
    53aa:	81 30       	cpi	r24, 0x01	; 1
    53ac:	18 f0       	brcs	.+6      	; 0x53b4 <_helper_DisplayPitchRollYaw+0xe>
    53ae:	82 30       	cpi	r24, 0x02	; 2
    53b0:	e1 f4       	brne	.+56     	; 0x53ea <_helper_DisplayPitchRollYaw+0x44>
    53b2:	15 c0       	rjmp	.+42     	; 0x53de <_helper_DisplayPitchRollYaw+0x38>
	{
		case 0:	
			if (Config.PitchRollLinked==0)
    53b4:	80 91 7d 07 	lds	r24, 0x077D
    53b8:	88 23       	and	r24, r24
    53ba:	29 f4       	brne	.+10     	; 0x53c6 <_helper_DisplayPitchRollYaw+0x20>
			{				   
				strcpy_P(sXDeg,PSTR("Pitch        "));
    53bc:	88 ed       	ldi	r24, 0xD8	; 216
    53be:	95 e0       	ldi	r25, 0x05	; 5
    53c0:	6b ee       	ldi	r22, 0xEB	; 235
    53c2:	7d e0       	ldi	r23, 0x0D	; 13
    53c4:	09 c0       	rjmp	.+18     	; 0x53d8 <_helper_DisplayPitchRollYaw+0x32>
			}
			else
			{
				strcpy_P(sXDeg,PSTR("Pitch & Roll "));
    53c6:	88 ed       	ldi	r24, 0xD8	; 216
    53c8:	95 e0       	ldi	r25, 0x05	; 5
    53ca:	6d ed       	ldi	r22, 0xDD	; 221
    53cc:	7d e0       	ldi	r23, 0x0D	; 13
    53ce:	04 c0       	rjmp	.+8      	; 0x53d8 <_helper_DisplayPitchRollYaw+0x32>
			}
			break;
		case 1:	
				strcpy_P(sXDeg,PSTR("Roll         "));
    53d0:	88 ed       	ldi	r24, 0xD8	; 216
    53d2:	95 e0       	ldi	r25, 0x05	; 5
    53d4:	6f ec       	ldi	r22, 0xCF	; 207
    53d6:	7d e0       	ldi	r23, 0x0D	; 13
    53d8:	0e 94 3b 38 	call	0x7076	; 0x7076 <strcpy_P>
			break;
    53dc:	08 95       	ret
		case 2:	
				strcpy_P(sXDeg,PSTR("YAW          "));
    53de:	88 ed       	ldi	r24, 0xD8	; 216
    53e0:	95 e0       	ldi	r25, 0x05	; 5
    53e2:	61 ec       	ldi	r22, 0xC1	; 193
    53e4:	7d e0       	ldi	r23, 0x0D	; 13
    53e6:	0e 94 3b 38 	call	0x7076	; 0x7076 <strcpy_P>
    53ea:	08 95       	ret

000053ec <_helper_SwitchPitchRollYaw>:
			break;
	}
}

void _helper_SwitchPitchRollYaw (uint8_t *subindex)
{
    53ec:	fc 01       	movw	r30, r24
	switch (subindex[0])
    53ee:	80 81       	ld	r24, Z
    53f0:	81 30       	cpi	r24, 0x01	; 1
    53f2:	59 f0       	breq	.+22     	; 0x540a <_helper_SwitchPitchRollYaw+0x1e>
    53f4:	81 30       	cpi	r24, 0x01	; 1
    53f6:	18 f0       	brcs	.+6      	; 0x53fe <_helper_SwitchPitchRollYaw+0x12>
    53f8:	82 30       	cpi	r24, 0x02	; 2
    53fa:	59 f4       	brne	.+22     	; 0x5412 <_helper_SwitchPitchRollYaw+0x26>
    53fc:	09 c0       	rjmp	.+18     	; 0x5410 <_helper_SwitchPitchRollYaw+0x24>
	{
		case 0:	if (Config.PitchRollLinked==0) subindex[0]=1; else subindex[0]=2;
    53fe:	80 91 7d 07 	lds	r24, 0x077D
    5402:	88 23       	and	r24, r24
    5404:	11 f4       	brne	.+4      	; 0x540a <_helper_SwitchPitchRollYaw+0x1e>
    5406:	81 e0       	ldi	r24, 0x01	; 1
    5408:	01 c0       	rjmp	.+2      	; 0x540c <_helper_SwitchPitchRollYaw+0x20>
		break;
		case 1:	subindex[0] +=1;
    540a:	82 e0       	ldi	r24, 0x02	; 2
    540c:	80 83       	st	Z, r24
		break;
    540e:	08 95       	ret
		case 2: subindex[0]=0;
    5410:	10 82       	st	Z, r1
    5412:	08 95       	ret

00005414 <_helper_DisplayBiStateText>:

	return;	
}	

void _helper_DisplayBiStateText(const uint8_t Row, const uint8_t Col, PGM_P strTrue, PGM_P strFalse, const bool Condition, const BOOL LCDReverse )
{
    5414:	af 92       	push	r10
    5416:	bf 92       	push	r11
    5418:	cf 92       	push	r12
    541a:	df 92       	push	r13
    541c:	ef 92       	push	r14
    541e:	0f 93       	push	r16
    5420:	1f 93       	push	r17
    5422:	df 93       	push	r29
    5424:	cf 93       	push	r28
    5426:	0f 92       	push	r0
    5428:	cd b7       	in	r28, 0x3d	; 61
    542a:	de b7       	in	r29, 0x3e	; 62
    542c:	18 2f       	mov	r17, r24
    542e:	6a 01       	movw	r12, r20
    5430:	59 01       	movw	r10, r18
    5432:	8e 2d       	mov	r24, r14
		lcdReverse(LCDReverse);
    5434:	69 83       	std	Y+1, r22	; 0x01
    5436:	0e 94 13 0d 	call	0x1a26	; 0x1a26 <lcdReverse>
		LCD_SetPos(Row, Col);
    543a:	81 2f       	mov	r24, r17
    543c:	69 81       	ldd	r22, Y+1	; 0x01
    543e:	0e 94 08 0c 	call	0x1810	; 0x1810 <LCD_SetPos>
		if (Condition==true) 
    5442:	00 23       	and	r16, r16
    5444:	11 f0       	breq	.+4      	; 0x544a <_helper_DisplayBiStateText+0x36>
		{
			LCD_WriteString_P(strTrue);
    5446:	c6 01       	movw	r24, r12
    5448:	01 c0       	rjmp	.+2      	; 0x544c <_helper_DisplayBiStateText+0x38>
		}
		else
		{
			LCD_WriteString_P(strFalse);
    544a:	c5 01       	movw	r24, r10
    544c:	0e 94 05 0d 	call	0x1a0a	; 0x1a0a <LCD_WriteString_P>
		}	
		lcdReverse(false);
    5450:	80 e0       	ldi	r24, 0x00	; 0
    5452:	0e 94 13 0d 	call	0x1a26	; 0x1a26 <lcdReverse>
}
    5456:	0f 90       	pop	r0
    5458:	cf 91       	pop	r28
    545a:	df 91       	pop	r29
    545c:	1f 91       	pop	r17
    545e:	0f 91       	pop	r16
    5460:	ef 90       	pop	r14
    5462:	df 90       	pop	r13
    5464:	cf 90       	pop	r12
    5466:	bf 90       	pop	r11
    5468:	af 90       	pop	r10
    546a:	08 95       	ret

0000546c <_helper_SaveinEEPROM_ifChanged>:


void _helper_SaveinEEPROM_ifChanged()
{
	if (bValueChanged==true)
    546c:	80 91 2a 05 	lds	r24, 0x052A
    5470:	81 30       	cpi	r24, 0x01	; 1
    5472:	21 f4       	brne	.+8      	; 0x547c <_helper_SaveinEEPROM_ifChanged+0x10>
		{
			Save_Config_to_EEPROM();
    5474:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <Save_Config_to_EEPROM>
			bValueChanged = false;
    5478:	10 92 2a 05 	sts	0x052A, r1
    547c:	08 95       	ret

0000547e <_helper_DisplayRXStatus>:
			return ;
	}
}

void _helper_DisplayRXStatus(const uint8_t Row)
{
    547e:	ef 92       	push	r14
    5480:	0f 93       	push	r16
    5482:	1f 93       	push	r17
    5484:	18 2f       	mov	r17, r24
	// Write RX Status
	// FIX: highlighted is the selected one.
	_helper_DisplayBiStateText(Row,18,str1,strX,IS_TX1_GOOD,(ActiveRXIndex!=1));
    5486:	20 91 c9 07 	lds	r18, 0x07C9
    548a:	80 91 b8 05 	lds	r24, 0x05B8
    548e:	30 e0       	ldi	r19, 0x00	; 0
    5490:	2f 70       	andi	r18, 0x0F	; 15
    5492:	30 70       	andi	r19, 0x00	; 0
    5494:	01 e0       	ldi	r16, 0x01	; 1
    5496:	21 15       	cp	r18, r1
    5498:	31 05       	cpc	r19, r1
    549a:	09 f0       	breq	.+2      	; 0x549e <_helper_DisplayRXStatus+0x20>
    549c:	00 e0       	ldi	r16, 0x00	; 0
    549e:	91 e0       	ldi	r25, 0x01	; 1
    54a0:	81 30       	cpi	r24, 0x01	; 1
    54a2:	09 f4       	brne	.+2      	; 0x54a6 <_helper_DisplayRXStatus+0x28>
    54a4:	90 e0       	ldi	r25, 0x00	; 0
    54a6:	81 2f       	mov	r24, r17
    54a8:	62 e1       	ldi	r22, 0x12	; 18
    54aa:	4e e1       	ldi	r20, 0x1E	; 30
    54ac:	5d e0       	ldi	r21, 0x0D	; 13
    54ae:	20 e2       	ldi	r18, 0x20	; 32
    54b0:	3d e0       	ldi	r19, 0x0D	; 13
    54b2:	e9 2e       	mov	r14, r25
    54b4:	0e 94 0a 2a 	call	0x5414	; 0x5414 <_helper_DisplayBiStateText>
	
	_helper_DisplayBiStateText(Row,30,str2,strX,IS_TX2_GOOD,(ActiveRXIndex!=0));
    54b8:	80 91 c9 07 	lds	r24, 0x07C9
    54bc:	20 91 b8 05 	lds	r18, 0x05B8
    54c0:	80 7f       	andi	r24, 0xF0	; 240
    54c2:	01 e0       	ldi	r16, 0x01	; 1
    54c4:	09 f0       	breq	.+2      	; 0x54c8 <_helper_DisplayRXStatus+0x4a>
    54c6:	00 e0       	ldi	r16, 0x00	; 0
    54c8:	91 e0       	ldi	r25, 0x01	; 1
    54ca:	22 23       	and	r18, r18
    54cc:	09 f4       	brne	.+2      	; 0x54d0 <_helper_DisplayRXStatus+0x52>
    54ce:	90 e0       	ldi	r25, 0x00	; 0
    54d0:	81 2f       	mov	r24, r17
    54d2:	6e e1       	ldi	r22, 0x1E	; 30
    54d4:	42 e2       	ldi	r20, 0x22	; 34
    54d6:	5d e0       	ldi	r21, 0x0D	; 13
    54d8:	20 e2       	ldi	r18, 0x20	; 32
    54da:	3d e0       	ldi	r19, 0x0D	; 13
    54dc:	e9 2e       	mov	r14, r25
    54de:	0e 94 0a 2a 	call	0x5414	; 0x5414 <_helper_DisplayBiStateText>
	
	lcdReverse(false);
    54e2:	80 e0       	ldi	r24, 0x00	; 0
    54e4:	0e 94 13 0d 	call	0x1a26	; 0x1a26 <lcdReverse>
	
}
    54e8:	1f 91       	pop	r17
    54ea:	0f 91       	pop	r16
    54ec:	ef 90       	pop	r14
    54ee:	08 95       	ret

000054f0 <_hStickCentering>:



BOOL bError; 
void _hStickCentering()
{
    54f0:	0f 93       	push	r16
    54f2:	1f 93       	push	r17
    54f4:	cf 93       	push	r28
    54f6:	df 93       	push	r29
	uint8_t i ;
	UIEnableStickCommands=false; // you cannot use sticks here. for arming or as buttons.
    54f8:	10 92 d3 05 	sts	0x05D3, r1
	
	if (IS_INIT)
    54fc:	80 91 a8 05 	lds	r24, 0x05A8
    5500:	80 ff       	sbrs	r24, 0
    5502:	0c c0       	rjmp	.+24     	; 0x551c <_hStickCentering+0x2c>
	{
		RX_StickCenterCalibrationInit(ActiveRXIndex);
    5504:	80 91 b8 05 	lds	r24, 0x05B8
    5508:	0e 94 7e 25 	call	0x4afc	; 0x4afc <RX_StickCenterCalibrationInit>
		LCD_WriteString_Pex(0,0,strSPC1,18,false); // clear the header
    550c:	80 e0       	ldi	r24, 0x00	; 0
    550e:	60 e0       	ldi	r22, 0x00	; 0
    5510:	42 ef       	ldi	r20, 0xF2	; 242
    5512:	5c e0       	ldi	r21, 0x0C	; 12
    5514:	22 e1       	ldi	r18, 0x12	; 18
    5516:	00 e0       	ldi	r16, 0x00	; 0
    5518:	0e 94 8d 0d 	call	0x1b1a	; 0x1b1a <LCD_WriteString_Pex>
	}
	
	if (KEY4)
    551c:	80 91 a8 05 	lds	r24, 0x05A8
    5520:	84 ff       	sbrs	r24, 4
    5522:	bf c0       	rjmp	.+382    	; 0x56a2 <_hStickCentering+0x1b2>
	{
		if (!bError)
    5524:	80 91 14 08 	lds	r24, 0x0814
    5528:	88 23       	and	r24, r24
    552a:	09 f0       	breq	.+2      	; 0x552e <_hStickCentering+0x3e>
    552c:	b5 c0       	rjmp	.+362    	; 0x5698 <_hStickCentering+0x1a8>
    552e:	20 e0       	ldi	r18, 0x00	; 0
    5530:	30 e0       	ldi	r19, 0x00	; 0
			// Save config
			for (i = 0; i < RXChannels; i++)
			{
				Config.RX_Mid[ActiveRXIndex][i] = (RX_MAX_raw[ActiveRXIndex][i]+RX_MIN_raw[ActiveRXIndex][i])/2;
				Config.RX_Min[ActiveRXIndex][i] = RX_MIN_raw[ActiveRXIndex][i];
				Config.RX_DiV_Value[ActiveRXIndex][i] = ((RX_MAX_raw[ActiveRXIndex][i] - RX_MIN_raw[ActiveRXIndex][i]) / 1000);
    5532:	08 ee       	ldi	r16, 0xE8	; 232
    5534:	13 e0       	ldi	r17, 0x03	; 3
		if (!bError)
		{
			// Save config
			for (i = 0; i < RXChannels; i++)
			{
				Config.RX_Mid[ActiveRXIndex][i] = (RX_MAX_raw[ActiveRXIndex][i]+RX_MIN_raw[ActiveRXIndex][i])/2;
    5536:	80 91 b8 05 	lds	r24, 0x05B8
    553a:	40 91 b8 05 	lds	r20, 0x05B8
    553e:	60 91 b8 05 	lds	r22, 0x05B8
    5542:	90 e0       	ldi	r25, 0x00	; 0
    5544:	fc 01       	movw	r30, r24
    5546:	ee 0f       	add	r30, r30
    5548:	ff 1f       	adc	r31, r31
    554a:	ee 0f       	add	r30, r30
    554c:	ff 1f       	adc	r31, r31
    554e:	e8 0f       	add	r30, r24
    5550:	f9 1f       	adc	r31, r25
    5552:	e2 0f       	add	r30, r18
    5554:	f3 1f       	adc	r31, r19
    5556:	ee 0f       	add	r30, r30
    5558:	ff 1f       	adc	r31, r31
    555a:	e8 5c       	subi	r30, 0xC8	; 200
    555c:	f8 4f       	sbci	r31, 0xF8	; 248
    555e:	70 e0       	ldi	r23, 0x00	; 0
    5560:	cb 01       	movw	r24, r22
    5562:	88 0f       	add	r24, r24
    5564:	99 1f       	adc	r25, r25
    5566:	88 0f       	add	r24, r24
    5568:	99 1f       	adc	r25, r25
    556a:	86 0f       	add	r24, r22
    556c:	97 1f       	adc	r25, r23
    556e:	82 0f       	add	r24, r18
    5570:	93 1f       	adc	r25, r19
    5572:	88 0f       	add	r24, r24
    5574:	99 1f       	adc	r25, r25
    5576:	80 56       	subi	r24, 0x60	; 96
    5578:	99 4f       	sbci	r25, 0xF9	; 249
    557a:	50 e0       	ldi	r21, 0x00	; 0
    557c:	da 01       	movw	r26, r20
    557e:	aa 0f       	add	r26, r26
    5580:	bb 1f       	adc	r27, r27
    5582:	aa 0f       	add	r26, r26
    5584:	bb 1f       	adc	r27, r27
    5586:	a4 0f       	add	r26, r20
    5588:	b5 1f       	adc	r27, r21
    558a:	a2 0f       	add	r26, r18
    558c:	b3 1f       	adc	r27, r19
    558e:	aa 0f       	add	r26, r26
    5590:	bb 1f       	adc	r27, r27
    5592:	a1 5f       	subi	r26, 0xF1	; 241
    5594:	b9 4f       	sbci	r27, 0xF9	; 249
    5596:	ec 01       	movw	r28, r24
    5598:	88 81       	ld	r24, Y
    559a:	99 81       	ldd	r25, Y+1	; 0x01
    559c:	4d 91       	ld	r20, X+
    559e:	5c 91       	ld	r21, X
    55a0:	84 0f       	add	r24, r20
    55a2:	95 1f       	adc	r25, r21
    55a4:	96 95       	lsr	r25
    55a6:	87 95       	ror	r24
    55a8:	91 83       	std	Z+1, r25	; 0x01
    55aa:	80 83       	st	Z, r24
				Config.RX_Min[ActiveRXIndex][i] = RX_MIN_raw[ActiveRXIndex][i];
    55ac:	40 91 b8 05 	lds	r20, 0x05B8
    55b0:	80 91 b8 05 	lds	r24, 0x05B8
    55b4:	50 e0       	ldi	r21, 0x00	; 0
    55b6:	fa 01       	movw	r30, r20
    55b8:	ee 0f       	add	r30, r30
    55ba:	ff 1f       	adc	r31, r31
    55bc:	ee 0f       	add	r30, r30
    55be:	ff 1f       	adc	r31, r31
    55c0:	e4 0f       	add	r30, r20
    55c2:	f5 1f       	adc	r31, r21
    55c4:	e2 0f       	add	r30, r18
    55c6:	f3 1f       	adc	r31, r19
    55c8:	ee 0f       	add	r30, r30
    55ca:	ff 1f       	adc	r31, r31
    55cc:	e4 5b       	subi	r30, 0xB4	; 180
    55ce:	f8 4f       	sbci	r31, 0xF8	; 248
    55d0:	90 e0       	ldi	r25, 0x00	; 0
    55d2:	dc 01       	movw	r26, r24
    55d4:	aa 0f       	add	r26, r26
    55d6:	bb 1f       	adc	r27, r27
    55d8:	aa 0f       	add	r26, r26
    55da:	bb 1f       	adc	r27, r27
    55dc:	a8 0f       	add	r26, r24
    55de:	b9 1f       	adc	r27, r25
    55e0:	a2 0f       	add	r26, r18
    55e2:	b3 1f       	adc	r27, r19
    55e4:	aa 0f       	add	r26, r26
    55e6:	bb 1f       	adc	r27, r27
    55e8:	a0 56       	subi	r26, 0x60	; 96
    55ea:	b9 4f       	sbci	r27, 0xF9	; 249
    55ec:	8d 91       	ld	r24, X+
    55ee:	9c 91       	ld	r25, X
    55f0:	91 83       	std	Z+1, r25	; 0x01
    55f2:	80 83       	st	Z, r24
				Config.RX_DiV_Value[ActiveRXIndex][i] = ((RX_MAX_raw[ActiveRXIndex][i] - RX_MIN_raw[ActiveRXIndex][i]) / 1000);
    55f4:	80 91 b8 05 	lds	r24, 0x05B8
    55f8:	60 91 b8 05 	lds	r22, 0x05B8
    55fc:	40 91 b8 05 	lds	r20, 0x05B8
    5600:	90 e0       	ldi	r25, 0x00	; 0
    5602:	fc 01       	movw	r30, r24
    5604:	ee 0f       	add	r30, r30
    5606:	ff 1f       	adc	r31, r31
    5608:	ee 0f       	add	r30, r30
    560a:	ff 1f       	adc	r31, r31
    560c:	e8 0f       	add	r30, r24
    560e:	f9 1f       	adc	r31, r25
    5610:	e2 0f       	add	r30, r18
    5612:	f3 1f       	adc	r31, r19
    5614:	ee 58       	subi	r30, 0x8E	; 142
    5616:	f8 4f       	sbci	r31, 0xF8	; 248
    5618:	70 e0       	ldi	r23, 0x00	; 0
    561a:	cb 01       	movw	r24, r22
    561c:	88 0f       	add	r24, r24
    561e:	99 1f       	adc	r25, r25
    5620:	88 0f       	add	r24, r24
    5622:	99 1f       	adc	r25, r25
    5624:	86 0f       	add	r24, r22
    5626:	97 1f       	adc	r25, r23
    5628:	82 0f       	add	r24, r18
    562a:	93 1f       	adc	r25, r19
    562c:	88 0f       	add	r24, r24
    562e:	99 1f       	adc	r25, r25
    5630:	81 5f       	subi	r24, 0xF1	; 241
    5632:	99 4f       	sbci	r25, 0xF9	; 249
    5634:	50 e0       	ldi	r21, 0x00	; 0
    5636:	da 01       	movw	r26, r20
    5638:	aa 0f       	add	r26, r26
    563a:	bb 1f       	adc	r27, r27
    563c:	aa 0f       	add	r26, r26
    563e:	bb 1f       	adc	r27, r27
    5640:	a4 0f       	add	r26, r20
    5642:	b5 1f       	adc	r27, r21
    5644:	a2 0f       	add	r26, r18
    5646:	b3 1f       	adc	r27, r19
    5648:	aa 0f       	add	r26, r26
    564a:	bb 1f       	adc	r27, r27
    564c:	a0 56       	subi	r26, 0x60	; 96
    564e:	b9 4f       	sbci	r27, 0xF9	; 249
    5650:	ec 01       	movw	r28, r24
    5652:	88 81       	ld	r24, Y
    5654:	99 81       	ldd	r25, Y+1	; 0x01
    5656:	4d 91       	ld	r20, X+
    5658:	5c 91       	ld	r21, X
    565a:	11 97       	sbiw	r26, 0x01	; 1
    565c:	84 1b       	sub	r24, r20
    565e:	95 0b       	sbc	r25, r21
    5660:	b8 01       	movw	r22, r16
    5662:	0e 94 e0 37 	call	0x6fc0	; 0x6fc0 <__udivmodhi4>
    5666:	60 83       	st	Z, r22
    5668:	2f 5f       	subi	r18, 0xFF	; 255
    566a:	3f 4f       	sbci	r19, 0xFF	; 255
	if (KEY4)
	{
		if (!bError)
		{
			// Save config
			for (i = 0; i < RXChannels; i++)
    566c:	25 30       	cpi	r18, 0x05	; 5
    566e:	31 05       	cpc	r19, r1
    5670:	09 f0       	breq	.+2      	; 0x5674 <_hStickCentering+0x184>
    5672:	61 cf       	rjmp	.-318    	; 0x5536 <_hStickCentering+0x46>
				Config.RX_Min[ActiveRXIndex][i] = RX_MIN_raw[ActiveRXIndex][i];
				Config.RX_DiV_Value[ActiveRXIndex][i] = ((RX_MAX_raw[ActiveRXIndex][i] - RX_MIN_raw[ActiveRXIndex][i]) / 1000);
				
			}		
			
			Config.IsCalibrated= (Config.IsCalibrated | (1 << ActiveRXIndex));	// either 0b00000001 or 0b00000010
    5674:	20 91 b8 05 	lds	r18, 0x05B8
    5678:	81 e0       	ldi	r24, 0x01	; 1
    567a:	90 e0       	ldi	r25, 0x00	; 0
    567c:	02 c0       	rjmp	.+4      	; 0x5682 <_hStickCentering+0x192>
    567e:	88 0f       	add	r24, r24
    5680:	99 1f       	adc	r25, r25
    5682:	2a 95       	dec	r18
    5684:	e2 f7       	brpl	.-8      	; 0x567e <_hStickCentering+0x18e>
    5686:	20 91 c6 06 	lds	r18, 0x06C6
    568a:	28 2b       	or	r18, r24
    568c:	e5 ec       	ldi	r30, 0xC5	; 197
    568e:	f6 e0       	ldi	r31, 0x06	; 6
    5690:	21 83       	std	Z+1, r18	; 0x01
			Save_Config_to_EEPROM();
    5692:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <Save_Config_to_EEPROM>
    5696:	05 c0       	rjmp	.+10     	; 0x56a2 <_hStickCentering+0x1b2>
		}
		else
		{
			Beeper_Beep(BEEP_ERROR,3);	
    5698:	88 ec       	ldi	r24, 0xC8	; 200
    569a:	90 e0       	ldi	r25, 0x00	; 0
    569c:	63 e0       	ldi	r22, 0x03	; 3
    569e:	0e 94 91 0b 	call	0x1722	; 0x1722 <Beeper_Beep>
		}
		
	}
	
	if (KEY2)
    56a2:	80 91 a8 05 	lds	r24, 0x05A8
    56a6:	86 ff       	sbrs	r24, 6
    56a8:	04 c0       	rjmp	.+8      	; 0x56b2 <_hStickCentering+0x1c2>
	{
		RX_StickCenterCalibrationInit(ActiveRXIndex);				
    56aa:	80 91 b8 05 	lds	r24, 0x05B8
    56ae:	0e 94 7e 25 	call	0x4afc	; 0x4afc <RX_StickCenterCalibrationInit>
	}
	
	bError = false;
    56b2:	10 92 14 08 	sts	0x0814, r1
	RX_StickCenterCalibration(ActiveRXIndex);
    56b6:	80 91 b8 05 	lds	r24, 0x05B8
    56ba:	0e 94 25 26 	call	0x4c4a	; 0x4c4a <RX_StickCenterCalibration>
    56be:	c0 e0       	ldi	r28, 0x00	; 0
    56c0:	d0 e0       	ldi	r29, 0x00	; 0
		else
		{
			if ((RX_MAX_raw[ActiveRXIndex][i]< RX_MIN_raw[ActiveRXIndex][i]) || (RX_MIN_raw[ActiveRXIndex][i]==0))  // RX_MIN_raw[i]=0 if the Remote is OFF when entering the test
			{
				LCD_WriteString_P(strErr);	
				bError = TRUE;
    56c2:	11 e0       	ldi	r17, 0x01	; 1
}



BOOL bError; 
void _hStickCentering()
    56c4:	ce 01       	movw	r24, r28
	
	bError = false;
	RX_StickCenterCalibration(ActiveRXIndex);
	for (uint8_t i = 0; i < RXChannels; i++)
	{
		LCD_SetPos(i+1, 30);
    56c6:	8f 5f       	subi	r24, 0xFF	; 255
    56c8:	6e e1       	ldi	r22, 0x1E	; 30
    56ca:	0e 94 08 0c 	call	0x1810	; 0x1810 <LCD_SetPos>
		utoa(RX_MAX_raw[ActiveRXIndex][i], sXDeg, 10);
    56ce:	80 91 b8 05 	lds	r24, 0x05B8
    56d2:	90 e0       	ldi	r25, 0x00	; 0
    56d4:	fc 01       	movw	r30, r24
    56d6:	ee 0f       	add	r30, r30
    56d8:	ff 1f       	adc	r31, r31
    56da:	ee 0f       	add	r30, r30
    56dc:	ff 1f       	adc	r31, r31
    56de:	e8 0f       	add	r30, r24
    56e0:	f9 1f       	adc	r31, r25
    56e2:	ec 0f       	add	r30, r28
    56e4:	fd 1f       	adc	r31, r29
    56e6:	ee 0f       	add	r30, r30
    56e8:	ff 1f       	adc	r31, r31
    56ea:	e1 5f       	subi	r30, 0xF1	; 241
    56ec:	f9 4f       	sbci	r31, 0xF9	; 249
    56ee:	80 81       	ld	r24, Z
    56f0:	91 81       	ldd	r25, Z+1	; 0x01
    56f2:	68 ed       	ldi	r22, 0xD8	; 216
    56f4:	75 e0       	ldi	r23, 0x05	; 5
    56f6:	4a e0       	ldi	r20, 0x0A	; 10
    56f8:	50 e0       	ldi	r21, 0x00	; 0
    56fa:	0e 94 80 38 	call	0x7100	; 0x7100 <utoa>
		LCD_WriteString(sXDeg);
    56fe:	88 ed       	ldi	r24, 0xD8	; 216
    5700:	95 e0       	ldi	r25, 0x05	; 5
    5702:	0e 94 f1 0c 	call	0x19e2	; 0x19e2 <LCD_WriteString>
		LCD_WriteString_P(strSPC1);
    5706:	82 ef       	ldi	r24, 0xF2	; 242
    5708:	9c e0       	ldi	r25, 0x0C	; 12
    570a:	0e 94 05 0d 	call	0x1a0a	; 0x1a0a <LCD_WriteString_P>
		utoa(RX_MIN_raw[ActiveRXIndex][i], sXDeg, 10);
    570e:	80 91 b8 05 	lds	r24, 0x05B8
    5712:	90 e0       	ldi	r25, 0x00	; 0
    5714:	fc 01       	movw	r30, r24
    5716:	ee 0f       	add	r30, r30
    5718:	ff 1f       	adc	r31, r31
    571a:	ee 0f       	add	r30, r30
    571c:	ff 1f       	adc	r31, r31
    571e:	e8 0f       	add	r30, r24
    5720:	f9 1f       	adc	r31, r25
    5722:	ec 0f       	add	r30, r28
    5724:	fd 1f       	adc	r31, r29
    5726:	ee 0f       	add	r30, r30
    5728:	ff 1f       	adc	r31, r31
    572a:	e0 56       	subi	r30, 0x60	; 96
    572c:	f9 4f       	sbci	r31, 0xF9	; 249
    572e:	80 81       	ld	r24, Z
    5730:	91 81       	ldd	r25, Z+1	; 0x01
    5732:	68 ed       	ldi	r22, 0xD8	; 216
    5734:	75 e0       	ldi	r23, 0x05	; 5
    5736:	4a e0       	ldi	r20, 0x0A	; 10
    5738:	50 e0       	ldi	r21, 0x00	; 0
    573a:	0e 94 80 38 	call	0x7100	; 0x7100 <utoa>
		LCD_WriteString(sXDeg);
    573e:	88 ed       	ldi	r24, 0xD8	; 216
    5740:	95 e0       	ldi	r25, 0x05	; 5
    5742:	0e 94 f1 0c 	call	0x19e2	; 0x19e2 <LCD_WriteString>
		if ((ActiveRXIndex==0) && (i == RXChannel_AUX))
    5746:	80 91 b8 05 	lds	r24, 0x05B8
    574a:	88 23       	and	r24, r24
    574c:	29 f4       	brne	.+10     	; 0x5758 <_hStickCentering+0x268>
    574e:	c4 30       	cpi	r28, 0x04	; 4
    5750:	19 f4       	brne	.+6      	; 0x5758 <_hStickCentering+0x268>
		{
			LCD_WriteString_P(PSTR("NA"));
    5752:	8d ef       	ldi	r24, 0xFD	; 253
    5754:	9c e0       	ldi	r25, 0x0C	; 12
    5756:	45 c0       	rjmp	.+138    	; 0x57e2 <_hStickCentering+0x2f2>
		}
		else
		{
			if ((RX_MAX_raw[ActiveRXIndex][i]< RX_MIN_raw[ActiveRXIndex][i]) || (RX_MIN_raw[ActiveRXIndex][i]==0))  // RX_MIN_raw[i]=0 if the Remote is OFF when entering the test
    5758:	20 91 b8 05 	lds	r18, 0x05B8
    575c:	80 91 b8 05 	lds	r24, 0x05B8
    5760:	30 e0       	ldi	r19, 0x00	; 0
    5762:	d9 01       	movw	r26, r18
    5764:	aa 0f       	add	r26, r26
    5766:	bb 1f       	adc	r27, r27
    5768:	aa 0f       	add	r26, r26
    576a:	bb 1f       	adc	r27, r27
    576c:	a2 0f       	add	r26, r18
    576e:	b3 1f       	adc	r27, r19
    5770:	ac 0f       	add	r26, r28
    5772:	bd 1f       	adc	r27, r29
    5774:	aa 0f       	add	r26, r26
    5776:	bb 1f       	adc	r27, r27
    5778:	a1 5f       	subi	r26, 0xF1	; 241
    577a:	b9 4f       	sbci	r27, 0xF9	; 249
    577c:	90 e0       	ldi	r25, 0x00	; 0
    577e:	fc 01       	movw	r30, r24
    5780:	ee 0f       	add	r30, r30
    5782:	ff 1f       	adc	r31, r31
    5784:	ee 0f       	add	r30, r30
    5786:	ff 1f       	adc	r31, r31
    5788:	e8 0f       	add	r30, r24
    578a:	f9 1f       	adc	r31, r25
    578c:	ec 0f       	add	r30, r28
    578e:	fd 1f       	adc	r31, r29
    5790:	ee 0f       	add	r30, r30
    5792:	ff 1f       	adc	r31, r31
    5794:	e0 56       	subi	r30, 0x60	; 96
    5796:	f9 4f       	sbci	r31, 0xF9	; 249
    5798:	2d 91       	ld	r18, X+
    579a:	3c 91       	ld	r19, X
    579c:	11 97       	sbiw	r26, 0x01	; 1
    579e:	80 81       	ld	r24, Z
    57a0:	91 81       	ldd	r25, Z+1	; 0x01
    57a2:	28 17       	cp	r18, r24
    57a4:	39 07       	cpc	r19, r25
    57a6:	a0 f0       	brcs	.+40     	; 0x57d0 <_hStickCentering+0x2e0>
    57a8:	80 91 b8 05 	lds	r24, 0x05B8
    57ac:	90 e0       	ldi	r25, 0x00	; 0
    57ae:	fc 01       	movw	r30, r24
    57b0:	ee 0f       	add	r30, r30
    57b2:	ff 1f       	adc	r31, r31
    57b4:	ee 0f       	add	r30, r30
    57b6:	ff 1f       	adc	r31, r31
    57b8:	e8 0f       	add	r30, r24
    57ba:	f9 1f       	adc	r31, r25
    57bc:	ec 0f       	add	r30, r28
    57be:	fd 1f       	adc	r31, r29
    57c0:	ee 0f       	add	r30, r30
    57c2:	ff 1f       	adc	r31, r31
    57c4:	e0 56       	subi	r30, 0x60	; 96
    57c6:	f9 4f       	sbci	r31, 0xF9	; 249
    57c8:	80 81       	ld	r24, Z
    57ca:	91 81       	ldd	r25, Z+1	; 0x01
    57cc:	00 97       	sbiw	r24, 0x00	; 0
    57ce:	39 f4       	brne	.+14     	; 0x57de <_hStickCentering+0x2ee>
			{
				LCD_WriteString_P(strErr);	
    57d0:	84 ef       	ldi	r24, 0xF4	; 244
    57d2:	9c e0       	ldi	r25, 0x0C	; 12
    57d4:	0e 94 05 0d 	call	0x1a0a	; 0x1a0a <LCD_WriteString_P>
				bError = TRUE;
    57d8:	10 93 14 08 	sts	0x0814, r17
    57dc:	04 c0       	rjmp	.+8      	; 0x57e6 <_hStickCentering+0x2f6>
			}
			else
			{
				LCD_WriteString_P(strSPC4);	
    57de:	88 ef       	ldi	r24, 0xF8	; 248
    57e0:	9c e0       	ldi	r25, 0x0C	; 12
    57e2:	0e 94 05 0d 	call	0x1a0a	; 0x1a0a <LCD_WriteString_P>
    57e6:	21 96       	adiw	r28, 0x01	; 1
		RX_StickCenterCalibrationInit(ActiveRXIndex);				
	}
	
	bError = false;
	RX_StickCenterCalibration(ActiveRXIndex);
	for (uint8_t i = 0; i < RXChannels; i++)
    57e8:	c5 30       	cpi	r28, 0x05	; 5
    57ea:	d1 05       	cpc	r29, r1
    57ec:	09 f0       	breq	.+2      	; 0x57f0 <_hStickCentering+0x300>
    57ee:	6a cf       	rjmp	.-300    	; 0x56c4 <_hStickCentering+0x1d4>
			}
		}	
	}
	

	_helper_DisplayRXStatus(6);
    57f0:	86 e0       	ldi	r24, 0x06	; 6
    57f2:	0e 94 3f 2a 	call	0x547e	; 0x547e <_helper_DisplayRXStatus>
}
    57f6:	df 91       	pop	r29
    57f8:	cf 91       	pop	r28
    57fa:	1f 91       	pop	r17
    57fc:	0f 91       	pop	r16
    57fe:	08 95       	ret

00005800 <_hReceiverTest>:
	LCD_SetPos(6, 48);
	LCD_WriteValue_double(6,48,Sensor_GetBattery(),false);
}

void _hReceiverTest()
{
    5800:	0f 93       	push	r16
    5802:	1f 93       	push	r17
    5804:	cf 93       	push	r28
    5806:	df 93       	push	r29
	UIEnableStickCommands=false; // you cannot use sticks here. for arming or as buttons.
    5808:	10 92 d3 05 	sts	0x05D3, r1
	
	RX_CopyLatestReceiverValues();
    580c:	0e 94 24 25 	call	0x4a48	; 0x4a48 <RX_CopyLatestReceiverValues>
    5810:	c0 e0       	ldi	r28, 0x00	; 0
    5812:	d0 e0       	ldi	r29, 0x00	; 0
    5814:	ce 01       	movw	r24, r28
    5816:	8f 5f       	subi	r24, 0xFF	; 255
    5818:	18 2f       	mov	r17, r24
		
		
	for (uint8_t i = 0; i < RXChannels; i++)
	{
		LCD_SetPos(i+1, 24);
    581a:	68 e1       	ldi	r22, 0x18	; 24
    581c:	0e 94 08 0c 	call	0x1810	; 0x1810 <LCD_SetPos>
			
		//itoa(RX_Latest[ActiveRXIndex][i], sXDeg, 10);
		LCD_WriteValue(i+1,36,RX_Latest[0][i],5,(!IS_TX1_GOOD));
    5820:	fe 01       	movw	r30, r28
    5822:	ee 0f       	add	r30, r30
    5824:	ff 1f       	adc	r31, r31
    5826:	e0 51       	subi	r30, 0x10	; 16
    5828:	fa 4f       	sbci	r31, 0xFA	; 250
    582a:	40 81       	ld	r20, Z
    582c:	51 81       	ldd	r21, Z+1	; 0x01
    582e:	80 91 c9 07 	lds	r24, 0x07C9
    5832:	90 e0       	ldi	r25, 0x00	; 0
    5834:	8f 70       	andi	r24, 0x0F	; 15
    5836:	90 70       	andi	r25, 0x00	; 0
    5838:	01 e0       	ldi	r16, 0x01	; 1
    583a:	00 97       	sbiw	r24, 0x00	; 0
    583c:	09 f4       	brne	.+2      	; 0x5840 <_hReceiverTest+0x40>
    583e:	00 e0       	ldi	r16, 0x00	; 0
    5840:	81 2f       	mov	r24, r17
    5842:	64 e2       	ldi	r22, 0x24	; 36
    5844:	25 e0       	ldi	r18, 0x05	; 5
    5846:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <LCD_WriteValue>
		LCD_WriteValue(i+1,84,RX_Latest[1][i],5,(!IS_TX2_GOOD));
    584a:	fe 01       	movw	r30, r28
    584c:	ee 0f       	add	r30, r30
    584e:	ff 1f       	adc	r31, r31
    5850:	e6 50       	subi	r30, 0x06	; 6
    5852:	fa 4f       	sbci	r31, 0xFA	; 250
    5854:	40 81       	ld	r20, Z
    5856:	51 81       	ldd	r21, Z+1	; 0x01
    5858:	80 91 c9 07 	lds	r24, 0x07C9
    585c:	80 7f       	andi	r24, 0xF0	; 240
    585e:	01 e0       	ldi	r16, 0x01	; 1
    5860:	09 f4       	brne	.+2      	; 0x5864 <_hReceiverTest+0x64>
    5862:	00 e0       	ldi	r16, 0x00	; 0
    5864:	81 2f       	mov	r24, r17
    5866:	64 e5       	ldi	r22, 0x54	; 84
    5868:	25 e0       	ldi	r18, 0x05	; 5
    586a:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <LCD_WriteValue>
    586e:	21 96       	adiw	r28, 0x01	; 1
	UIEnableStickCommands=false; // you cannot use sticks here. for arming or as buttons.
	
	RX_CopyLatestReceiverValues();
		
		
	for (uint8_t i = 0; i < RXChannels; i++)
    5870:	c5 30       	cpi	r28, 0x05	; 5
    5872:	d1 05       	cpc	r29, r1
    5874:	79 f6       	brne	.-98     	; 0x5814 <_hReceiverTest+0x14>
		LCD_WriteValue(i+1,84,RX_Latest[1][i],5,(!IS_TX2_GOOD));
		
	}			
	
	
	_helper_DisplayRXStatus(6);
    5876:	86 e0       	ldi	r24, 0x06	; 6
    5878:	0e 94 3f 2a 	call	0x547e	; 0x547e <_helper_DisplayRXStatus>
	
}
    587c:	df 91       	pop	r29
    587e:	cf 91       	pop	r28
    5880:	1f 91       	pop	r17
    5882:	0f 91       	pop	r16
    5884:	08 95       	ret

00005886 <_helper_Words>:
	
}


void _helper_Words (const int8_t row, const int8_t col,  const BOOL LCDReverse, const bool Condition, PGM_P TrueString, PGM_P FalseString, int8_t Len)
{
    5886:	cf 92       	push	r12
    5888:	ef 92       	push	r14
    588a:	ff 92       	push	r15
    588c:	0f 93       	push	r16
    588e:	1f 93       	push	r17
    5890:	94 2f       	mov	r25, r20
    5892:	32 2f       	mov	r19, r18
    5894:	2c 2d       	mov	r18, r12
	if (Condition== TRUE)
    5896:	33 23       	and	r19, r19
    5898:	11 f0       	breq	.+4      	; 0x589e <_helper_Words+0x18>
	{
		LCD_WriteString_Pex(row,col,TrueString,Len,LCDReverse);
    589a:	a8 01       	movw	r20, r16
    589c:	01 c0       	rjmp	.+2      	; 0x58a0 <_helper_Words+0x1a>
	}
	else
	{
		LCD_WriteString_Pex(row,col,FalseString,Len,LCDReverse);
    589e:	a7 01       	movw	r20, r14
    58a0:	09 2f       	mov	r16, r25
    58a2:	0e 94 8d 0d 	call	0x1b1a	; 0x1b1a <LCD_WriteString_Pex>
	}
}
    58a6:	1f 91       	pop	r17
    58a8:	0f 91       	pop	r16
    58aa:	ff 90       	pop	r15
    58ac:	ef 90       	pop	r14
    58ae:	cf 90       	pop	r12
    58b0:	08 95       	ret

000058b2 <Menu_LoadPage>:

/*
//	Put screen into CurrentPage ==> MemoryScreen
*/
void Menu_LoadPage(const uint8_t pageIndex)
{
    58b2:	1f 93       	push	r17
    58b4:	18 2f       	mov	r17, r24
	memcpy_P(&currentPage, &pages[pageIndex], sizeof(currentPage));
    58b6:	66 e0       	ldi	r22, 0x06	; 6
    58b8:	86 9f       	mul	r24, r22
    58ba:	b0 01       	movw	r22, r0
    58bc:	11 24       	eor	r1, r1
    58be:	65 5a       	subi	r22, 0xA5	; 165
    58c0:	72 4f       	sbci	r23, 0xF2	; 242
    58c2:	80 e3       	ldi	r24, 0x30	; 48
    58c4:	95 e0       	ldi	r25, 0x05	; 5
    58c6:	46 e0       	ldi	r20, 0x06	; 6
    58c8:	50 e0       	ldi	r21, 0x00	; 0
    58ca:	0e 94 32 38 	call	0x7064	; 0x7064 <memcpy_P>
	page = pageIndex;
    58ce:	10 93 2d 05 	sts	0x052D, r17
}
    58d2:	1f 91       	pop	r17
    58d4:	08 95       	ret

000058d6 <_hFactoryReset>:
		//LCD_WriteValue(4,48, MotorOut[3],9,false);
	}
}
void _hFactoryReset()
{
	if (IS_INIT)
    58d6:	80 91 a8 05 	lds	r24, 0x05A8
    58da:	80 ff       	sbrs	r24, 0
    58dc:	05 c0       	rjmp	.+10     	; 0x58e8 <_hFactoryReset+0x12>
	{
		;
		LCD_WriteString_P(strAreYouSure);
    58de:	8d ee       	ldi	r24, 0xED	; 237
    58e0:	9b e0       	ldi	r25, 0x0B	; 11
    58e2:	0e 94 05 0d 	call	0x1a0a	; 0x1a0a <LCD_WriteString_P>
    58e6:	08 95       	ret
	}
	else if (KEY4)	// Yes
    58e8:	84 ff       	sbrs	r24, 4
    58ea:	05 c0       	rjmp	.+10     	; 0x58f6 <_hFactoryReset+0x20>
	{
		Save_Default_Config_to_EEPROM();
    58ec:	0e 94 d8 0f 	call	0x1fb0	; 0x1fb0 <Save_Default_Config_to_EEPROM>
		//RST_CTRL
		Menu_LoadPage(PAGE_RESTART);
    58f0:	84 e0       	ldi	r24, 0x04	; 4
    58f2:	0e 94 59 2c 	call	0x58b2	; 0x58b2 <Menu_LoadPage>
    58f6:	08 95       	ret

000058f8 <_hESCCalibration>:
	
}

void _hESCCalibration()
{
	NOKEYRETURN
    58f8:	80 91 a8 05 	lds	r24, 0x05A8
    58fc:	88 23       	and	r24, r24
    58fe:	c1 f0       	breq	.+48     	; 0x5930 <_hESCCalibration+0x38>
	
	if (KEY4)
    5900:	84 ff       	sbrs	r24, 4
    5902:	16 c0       	rjmp	.+44     	; 0x5930 <_hESCCalibration+0x38>
	{
		if ((Config.IsCalibrated & CALIBRATED_SENSOR) && ((Config.IsCalibrated & CALIBRATED_Stick_SECONDARY)==CALIBRATED_Stick_SECONDARY))
    5904:	80 91 c6 06 	lds	r24, 0x06C6
		LCD_WriteValue(i,48,Config.Sensor_zero[i],5,false);
	}	
	
}

void _hESCCalibration()
    5908:	86 70       	andi	r24, 0x06	; 6
{
	NOKEYRETURN
	
	if (KEY4)
	{
		if ((Config.IsCalibrated & CALIBRATED_SENSOR) && ((Config.IsCalibrated & CALIBRATED_Stick_SECONDARY)==CALIBRATED_Stick_SECONDARY))
    590a:	86 30       	cpi	r24, 0x06	; 6
    590c:	61 f4       	brne	.+24     	; 0x5926 <_hESCCalibration+0x2e>
		{
			SystemActions = SYS_ACT_DISARM;
    590e:	82 e0       	ldi	r24, 0x02	; 2
    5910:	80 93 3b 05 	sts	0x053B, r24
			Config.IsESCCalibration=ESCCalibration_ON;
    5914:	81 e0       	ldi	r24, 0x01	; 1
    5916:	80 93 cb 06 	sts	0x06CB, r24
			Save_Config_to_EEPROM();
    591a:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <Save_Config_to_EEPROM>
			Menu_LoadPage(PAGE_RESTART);
    591e:	84 e0       	ldi	r24, 0x04	; 4
    5920:	0e 94 59 2c 	call	0x58b2	; 0x58b2 <Menu_LoadPage>
			return;
    5924:	08 95       	ret
		}
		else
		{ //...flash as error
			LED_FlashOrangeLED(LED_SHORT_TOGGLE,2);
    5926:	8e e1       	ldi	r24, 0x1E	; 30
    5928:	90 e0       	ldi	r25, 0x00	; 0
    592a:	62 e0       	ldi	r22, 0x02	; 2
    592c:	0e 94 93 0e 	call	0x1d26	; 0x1d26 <LED_FlashOrangeLED>
    5930:	08 95       	ret

00005932 <_hHomeArmed>:
}

void _hHomeArmed()
{
	
	if (IS_INIT)	
    5932:	80 91 a8 05 	lds	r24, 0x05A8
    5936:	80 ff       	sbrs	r24, 0
    5938:	10 c0       	rjmp	.+32     	; 0x595a <_hHomeArmed+0x28>
	{
		LCD_SelectFont (&font12x16);
    593a:	89 e4       	ldi	r24, 0x49	; 73
    593c:	91 e0       	ldi	r25, 0x01	; 1
    593e:	0e 94 5c 0e 	call	0x1cb8	; 0x1cb8 <LCD_SelectFont>
		LCD_SetPos(0,0);
    5942:	80 e0       	ldi	r24, 0x00	; 0
    5944:	60 e0       	ldi	r22, 0x00	; 0
    5946:	0e 94 08 0c 	call	0x1810	; 0x1810 <LCD_SetPos>
		LCD_WriteString_P(strARMED);
    594a:	80 e0       	ldi	r24, 0x00	; 0
    594c:	9d e0       	ldi	r25, 0x0D	; 13
    594e:	0e 94 05 0d 	call	0x1a0a	; 0x1a0a <LCD_WriteString_P>
		LCD_SelectFont (NULL);
    5952:	80 e0       	ldi	r24, 0x00	; 0
    5954:	90 e0       	ldi	r25, 0x00	; 0
    5956:	0e 94 5c 0e 	call	0x1cb8	; 0x1cb8 <LCD_SelectFont>
	}
	
	
	if (KEY4)	// MENU
    595a:	80 91 a8 05 	lds	r24, 0x05A8
    595e:	84 ff       	sbrs	r24, 4
    5960:	03 c0       	rjmp	.+6      	; 0x5968 <_hHomeArmed+0x36>
	{
		Menu_LoadPage(PAGE_MENU);
    5962:	81 e0       	ldi	r24, 0x01	; 1
    5964:	0e 94 59 2c 	call	0x58b2	; 0x58b2 <Menu_LoadPage>
    5968:	08 95       	ret

0000596a <_hHomePage>:
}



void _hHomePage()
{
    596a:	cf 92       	push	r12
    596c:	ef 92       	push	r14
    596e:	ff 92       	push	r15
    5970:	0f 93       	push	r16
    5972:	1f 93       	push	r17
	
	if (IS_INIT)
    5974:	80 91 a8 05 	lds	r24, 0x05A8
    5978:	80 ff       	sbrs	r24, 0
    597a:	31 c0       	rjmp	.+98     	; 0x59de <_hHomePage+0x74>
	{
		// Version
		LCD_SetPos(0,0);
    597c:	80 e0       	ldi	r24, 0x00	; 0
    597e:	60 e0       	ldi	r22, 0x00	; 0
    5980:	0e 94 08 0c 	call	0x1810	; 0x1810 <LCD_SetPos>
		LCD_WriteString_P(strVersionInfo);
    5984:	86 e0       	ldi	r24, 0x06	; 6
    5986:	9d e0       	ldi	r25, 0x0D	; 13
    5988:	0e 94 05 0d 	call	0x1a0a	; 0x1a0a <LCD_WriteString_P>
		// Sensors
		_helper_DisplayBiStateText(5, 60, strOK, strErr, (Config.IsCalibrated & CALIBRATED_SENSOR),false);
    598c:	80 91 c6 06 	lds	r24, 0x06C6
    5990:	01 e0       	ldi	r16, 0x01	; 1
    5992:	82 ff       	sbrs	r24, 2
    5994:	00 e0       	ldi	r16, 0x00	; 0
    5996:	85 e0       	ldi	r24, 0x05	; 5
    5998:	6c e3       	ldi	r22, 0x3C	; 60
    599a:	4a e1       	ldi	r20, 0x1A	; 26
    599c:	5d e0       	ldi	r21, 0x0D	; 13
    599e:	24 ef       	ldi	r18, 0xF4	; 244
    59a0:	3c e0       	ldi	r19, 0x0C	; 12
    59a2:	ee 24       	eor	r14, r14
    59a4:	0e 94 0a 2a 	call	0x5414	; 0x5414 <_helper_DisplayBiStateText>
		
		//Stick Centering & Calibration
		_helper_DisplayBiStateText(5, 102, str1, strX, (Config.IsCalibrated & CALIBRATED_Stick_PRIMARY),false);
    59a8:	00 91 c6 06 	lds	r16, 0x06C6
    59ac:	10 e0       	ldi	r17, 0x00	; 0
    59ae:	01 70       	andi	r16, 0x01	; 1
    59b0:	10 70       	andi	r17, 0x00	; 0
    59b2:	85 e0       	ldi	r24, 0x05	; 5
    59b4:	66 e6       	ldi	r22, 0x66	; 102
    59b6:	4e e1       	ldi	r20, 0x1E	; 30
    59b8:	5d e0       	ldi	r21, 0x0D	; 13
    59ba:	20 e2       	ldi	r18, 0x20	; 32
    59bc:	3d e0       	ldi	r19, 0x0D	; 13
    59be:	0e 94 0a 2a 	call	0x5414	; 0x5414 <_helper_DisplayBiStateText>
		
		_helper_DisplayBiStateText(5, 114, str2, strX, (Config.IsCalibrated & CALIBRATED_Stick_SECONDARY),false);
    59c2:	80 91 c6 06 	lds	r24, 0x06C6
    59c6:	01 e0       	ldi	r16, 0x01	; 1
    59c8:	81 ff       	sbrs	r24, 1
    59ca:	00 e0       	ldi	r16, 0x00	; 0
    59cc:	85 e0       	ldi	r24, 0x05	; 5
    59ce:	62 e7       	ldi	r22, 0x72	; 114
    59d0:	42 e2       	ldi	r20, 0x22	; 34
    59d2:	5d e0       	ldi	r21, 0x0D	; 13
    59d4:	20 e2       	ldi	r18, 0x20	; 32
    59d6:	3d e0       	ldi	r19, 0x0D	; 13
    59d8:	ee 24       	eor	r14, r14
    59da:	0e 94 0a 2a 	call	0x5414	; 0x5414 <_helper_DisplayBiStateText>
		
		
	}
	
	if (KEY4)	// MENU
    59de:	80 91 a8 05 	lds	r24, 0x05A8
    59e2:	84 ff       	sbrs	r24, 4
    59e4:	04 c0       	rjmp	.+8      	; 0x59ee <_hHomePage+0x84>
	{
		Menu_LoadPage(PAGE_MENU);
    59e6:	81 e0       	ldi	r24, 0x01	; 1
    59e8:	0e 94 59 2c 	call	0x58b2	; 0x58b2 <Menu_LoadPage>
		return;
    59ec:	94 c0       	rjmp	.+296    	; 0x5b16 <_hHomePage+0x1ac>
	}
	
	// Write Voltage
	//LCD_SetPos(2, 30);
	double volt = (double)(Sensor_GetBattery()/10.0f);
    59ee:	0e 94 81 27 	call	0x4f02	; 0x4f02 <Sensor_GetBattery>
    59f2:	9c 01       	movw	r18, r24
    59f4:	b9 01       	movw	r22, r18
    59f6:	88 27       	eor	r24, r24
    59f8:	77 fd       	sbrc	r23, 7
    59fa:	80 95       	com	r24
    59fc:	98 2f       	mov	r25, r24
    59fe:	0e 94 c9 36 	call	0x6d92	; 0x6d92 <__floatsisf>
    5a02:	20 e0       	ldi	r18, 0x00	; 0
    5a04:	30 e0       	ldi	r19, 0x00	; 0
    5a06:	40 e2       	ldi	r20, 0x20	; 32
    5a08:	51 e4       	ldi	r21, 0x41	; 65
    5a0a:	0e 94 2e 36 	call	0x6c5c	; 0x6c5c <__divsf3>
    5a0e:	9b 01       	movw	r18, r22
    5a10:	ac 01       	movw	r20, r24
	LCD_WriteValue_double_ex(2,36,volt,8,IS_SYS_ERR_VOLTAGE); // FIX: 8 to display 2 digits volt besides floating point
    5a12:	90 91 b5 06 	lds	r25, 0x06B5
    5a16:	92 70       	andi	r25, 0x02	; 2
    5a18:	82 e0       	ldi	r24, 0x02	; 2
    5a1a:	64 e2       	ldi	r22, 0x24	; 36
    5a1c:	08 e0       	ldi	r16, 0x08	; 8
    5a1e:	e9 2e       	mov	r14, r25
    5a20:	0e 94 b2 0d 	call	0x1b64	; 0x1b64 <LCD_WriteValue_double_ex>
	//LCD_WriteValue(2,36,Sensor_GetBattery(),4,IS_SYS_ERR_VOLTAGE);
	LCD_SetPos (3,6);
    5a24:	83 e0       	ldi	r24, 0x03	; 3
    5a26:	66 e0       	ldi	r22, 0x06	; 6
    5a28:	0e 94 08 0c 	call	0x1810	; 0x1810 <LCD_SetPos>
	if (nFlyingModes == FLYINGMODE_ACRO)
    5a2c:	80 91 08 06 	lds	r24, 0x0608
    5a30:	81 30       	cpi	r24, 0x01	; 1
    5a32:	19 f4       	brne	.+6      	; 0x5a3a <_hHomePage+0xd0>
	{
		LCD_WriteString_P(PSTR("ACRO  "));
    5a34:	84 e5       	ldi	r24, 0x54	; 84
    5a36:	9d e0       	ldi	r25, 0x0D	; 13
    5a38:	09 c0       	rjmp	.+18     	; 0x5a4c <_hHomePage+0xe2>
	}
	else if (nFlyingModes == FLYINGMODE_LEVEL)
    5a3a:	82 30       	cpi	r24, 0x02	; 2
    5a3c:	19 f4       	brne	.+6      	; 0x5a44 <_hHomePage+0xda>
	{
		LCD_WriteString_P(PSTR("STABLE"));
    5a3e:	8d e4       	ldi	r24, 0x4D	; 77
    5a40:	9d e0       	ldi	r25, 0x0D	; 13
    5a42:	04 c0       	rjmp	.+8      	; 0x5a4c <_hHomePage+0xe2>
	}
	else if (nFlyingModes == FLYINGMODE_ALTHOLD)
    5a44:	84 30       	cpi	r24, 0x04	; 4
    5a46:	21 f4       	brne	.+8      	; 0x5a50 <_hHomePage+0xe6>
	{
		LCD_WriteString_P(PSTR("ALTHLD"));
    5a48:	86 e4       	ldi	r24, 0x46	; 70
    5a4a:	9d e0       	ldi	r25, 0x0D	; 13
    5a4c:	0e 94 05 0d 	call	0x1a0a	; 0x1a0a <LCD_WriteString_P>
	}
	
	_helper_Words (3,48,  0,(Config.FrameType== FRAMETYPE_QUADCOPTER),PSTR("Quad"),PSTR("TRI "),5);
    5a50:	21 e0       	ldi	r18, 0x01	; 1
    5a52:	80 91 cc 06 	lds	r24, 0x06CC
    5a56:	81 30       	cpi	r24, 0x01	; 1
    5a58:	09 f0       	breq	.+2      	; 0x5a5c <_hHomePage+0xf2>
    5a5a:	20 e0       	ldi	r18, 0x00	; 0
    5a5c:	83 e0       	ldi	r24, 0x03	; 3
    5a5e:	60 e3       	ldi	r22, 0x30	; 48
    5a60:	40 e0       	ldi	r20, 0x00	; 0
    5a62:	01 e4       	ldi	r16, 0x41	; 65
    5a64:	1d e0       	ldi	r17, 0x0D	; 13
    5a66:	bc e3       	ldi	r27, 0x3C	; 60
    5a68:	eb 2e       	mov	r14, r27
    5a6a:	bd e0       	ldi	r27, 0x0D	; 13
    5a6c:	fb 2e       	mov	r15, r27
    5a6e:	a5 e0       	ldi	r26, 0x05	; 5
    5a70:	ca 2e       	mov	r12, r26
    5a72:	0e 94 43 2c 	call	0x5886	; 0x5886 <_helper_Words>
	_helper_Words (3,84,0,(Config.RX_mode == RX_mode_BuddyMode),PSTR("Buddy"),PSTR("UART "),5);
    5a76:	21 e0       	ldi	r18, 0x01	; 1
    5a78:	80 91 c7 06 	lds	r24, 0x06C7
    5a7c:	81 11       	cpse	r24, r1
    5a7e:	20 e0       	ldi	r18, 0x00	; 0
    5a80:	83 e0       	ldi	r24, 0x03	; 3
    5a82:	64 e5       	ldi	r22, 0x54	; 84
    5a84:	40 e0       	ldi	r20, 0x00	; 0
    5a86:	06 e3       	ldi	r16, 0x36	; 54
    5a88:	1d e0       	ldi	r17, 0x0D	; 13
    5a8a:	f0 e3       	ldi	r31, 0x30	; 48
    5a8c:	ef 2e       	mov	r14, r31
    5a8e:	fd e0       	ldi	r31, 0x0D	; 13
    5a90:	ff 2e       	mov	r15, r31
    5a92:	e5 e0       	ldi	r30, 0x05	; 5
    5a94:	ce 2e       	mov	r12, r30
    5a96:	0e 94 43 2c 	call	0x5886	; 0x5886 <_helper_Words>
	
	_helper_DisplayRXStatus(5);
    5a9a:	85 e0       	ldi	r24, 0x05	; 5
    5a9c:	0e 94 3f 2a 	call	0x547e	; 0x547e <_helper_DisplayRXStatus>
	
		
	///////// Flying Mode
	LCD_SetPos (6,24);
    5aa0:	86 e0       	ldi	r24, 0x06	; 6
    5aa2:	68 e1       	ldi	r22, 0x18	; 24
    5aa4:	0e 94 08 0c 	call	0x1810	; 0x1810 <LCD_SetPos>
	LCD_SelectFont (&font12x16);
    5aa8:	89 e4       	ldi	r24, 0x49	; 73
    5aaa:	91 e0       	ldi	r25, 0x01	; 1
    5aac:	0e 94 5c 0e 	call	0x1cb8	; 0x1cb8 <LCD_SelectFont>
	
	if (Config.QuadFlyingMode==QuadFlyingMode_X)
    5ab0:	80 91 ce 06 	lds	r24, 0x06CE
    5ab4:	81 30       	cpi	r24, 0x01	; 1
    5ab6:	51 f4       	brne	.+20     	; 0x5acc <_hHomePage+0x162>
	{
		if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    5ab8:	80 91 cc 06 	lds	r24, 0x06CC
    5abc:	81 30       	cpi	r24, 0x01	; 1
    5abe:	19 f4       	brne	.+6      	; 0x5ac6 <_hHomePage+0x15c>
		{
			LCD_WriteString_P(PSTR ("X"));
    5ac0:	8e e2       	ldi	r24, 0x2E	; 46
    5ac2:	9d e0       	ldi	r25, 0x0D	; 13
    5ac4:	0c c0       	rjmp	.+24     	; 0x5ade <_hHomePage+0x174>
		}
		else
		{
			LCD_WriteString_P(PSTR ("A"));
    5ac6:	8c e2       	ldi	r24, 0x2C	; 44
    5ac8:	9d e0       	ldi	r25, 0x0D	; 13
    5aca:	09 c0       	rjmp	.+18     	; 0x5ade <_hHomePage+0x174>
		}			
	}
	else
	{
		if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    5acc:	80 91 cc 06 	lds	r24, 0x06CC
    5ad0:	81 30       	cpi	r24, 0x01	; 1
    5ad2:	19 f4       	brne	.+6      	; 0x5ada <_hHomePage+0x170>
		{
			LCD_WriteString_P(PSTR ("+"));
    5ad4:	8a e2       	ldi	r24, 0x2A	; 42
    5ad6:	9d e0       	ldi	r25, 0x0D	; 13
    5ad8:	02 c0       	rjmp	.+4      	; 0x5ade <_hHomePage+0x174>
		}
		else
		{
			LCD_WriteString_P(PSTR ("Y"));
    5ada:	88 e2       	ldi	r24, 0x28	; 40
    5adc:	9d e0       	ldi	r25, 0x0D	; 13
    5ade:	0e 94 05 0d 	call	0x1a0a	; 0x1a0a <LCD_WriteString_P>
		}			
	}
	
	LCD_SetPos (6,80);
    5ae2:	86 e0       	ldi	r24, 0x06	; 6
    5ae4:	60 e5       	ldi	r22, 0x50	; 80
    5ae6:	0e 94 08 0c 	call	0x1810	; 0x1810 <LCD_SetPos>
	LCD_SelectFont (&font12x16);
    5aea:	89 e4       	ldi	r24, 0x49	; 73
    5aec:	91 e0       	ldi	r25, 0x01	; 1
    5aee:	0e 94 5c 0e 	call	0x1cb8	; 0x1cb8 <LCD_SelectFont>
	if (Config.BoardOrientationMode==QuadFlyingMode_X)
    5af2:	80 91 cd 06 	lds	r24, 0x06CD
    5af6:	81 30       	cpi	r24, 0x01	; 1
    5af8:	19 f4       	brne	.+6      	; 0x5b00 <_hHomePage+0x196>
	{
		LCD_WriteString_P(PSTR ("X"));
    5afa:	86 e2       	ldi	r24, 0x26	; 38
    5afc:	9d e0       	ldi	r25, 0x0D	; 13
    5afe:	02 c0       	rjmp	.+4      	; 0x5b04 <_hHomePage+0x19a>
	}
	else
	{
		LCD_WriteString_P(PSTR ("+"));
    5b00:	84 e2       	ldi	r24, 0x24	; 36
    5b02:	9d e0       	ldi	r25, 0x0D	; 13
    5b04:	0e 94 05 0d 	call	0x1a0a	; 0x1a0a <LCD_WriteString_P>
	}
	LCD_SelectFont (NULL);
    5b08:	80 e0       	ldi	r24, 0x00	; 0
    5b0a:	90 e0       	ldi	r25, 0x00	; 0
    5b0c:	0e 94 5c 0e 	call	0x1cb8	; 0x1cb8 <LCD_SelectFont>
	///////
	UIEnableStickCommands=true;
    5b10:	81 e0       	ldi	r24, 0x01	; 1
    5b12:	80 93 d3 05 	sts	0x05D3, r24
	
}
    5b16:	1f 91       	pop	r17
    5b18:	0f 91       	pop	r16
    5b1a:	ff 90       	pop	r15
    5b1c:	ef 90       	pop	r14
    5b1e:	cf 90       	pop	r12
    5b20:	08 95       	ret

00005b22 <defaultHandler>:


void defaultHandler()
{
	
	if (editMode==true)
    5b22:	80 91 c6 07 	lds	r24, 0x07C6
    5b26:	81 30       	cpi	r24, 0x01	; 1
    5b28:	19 f4       	brne	.+6      	; 0x5b30 <defaultHandler+0xe>
	{		// edit mode?
		editModeHandler();
    5b2a:	0e 94 b7 2d 	call	0x5b6e	; 0x5b6e <editModeHandler>
    5b2e:	08 95       	ret
	}
	else
	{
		if (IS_INIT | IS_KEYREFRESH) 
    5b30:	80 91 a8 05 	lds	r24, 0x05A8
    5b34:	90 e0       	ldi	r25, 0x00	; 0
    5b36:	83 70       	andi	r24, 0x03	; 3
    5b38:	90 70       	andi	r25, 0x00	; 0
    5b3a:	00 97       	sbiw	r24, 0x00	; 0
    5b3c:	81 f0       	breq	.+32     	; 0x5b5e <defaultHandler+0x3c>
		{
			LCD_Clear();
    5b3e:	0e 94 40 0c 	call	0x1880	; 0x1880 <LCD_Clear>
			// 1- display screen content
			if (currentPage.screen)
    5b42:	80 91 34 05 	lds	r24, 0x0534
    5b46:	90 91 35 05 	lds	r25, 0x0535
    5b4a:	00 97       	sbiw	r24, 0x00	; 0
    5b4c:	11 f0       	breq	.+4      	; 0x5b52 <defaultHandler+0x30>
				LCD_WriteString_P(currentPage.screen);
    5b4e:	0e 94 05 0d 	call	0x1a0a	; 0x1a0a <LCD_WriteString_P>
			// 2- Display control buttons... always be last to overwrite any graphics on it.
			writeSoftkeys(currentPage.softkeys);
    5b52:	80 91 30 05 	lds	r24, 0x0530
    5b56:	90 91 31 05 	lds	r25, 0x0531
    5b5a:	0e 94 42 28 	call	0x5084	; 0x5084 <writeSoftkeys>
			//LCD_SetPos(0, 0);
		}
		
		if (currentPage.handler)
    5b5e:	e0 91 32 05 	lds	r30, 0x0532
    5b62:	f0 91 33 05 	lds	r31, 0x0533
    5b66:	30 97       	sbiw	r30, 0x00	; 0
    5b68:	09 f0       	breq	.+2      	; 0x5b6c <defaultHandler+0x4a>
		{
			currentPage.handler();
    5b6a:	09 95       	icall
    5b6c:	08 95       	ret

00005b6e <editModeHandler>:
		subpage = (subpage + 1) % num;
}


void editModeHandler()
{
    5b6e:	0f 93       	push	r16
	if (KEY4)	// DONE;
    5b70:	80 91 a8 05 	lds	r24, 0x05A8
    5b74:	84 ff       	sbrs	r24, 4
    5b76:	23 c0       	rjmp	.+70     	; 0x5bbe <editModeHandler+0x50>
	{
		editMode = false;
    5b78:	10 92 c6 07 	sts	0x07C6, r1
		_mykey = KEY_REFRESH;
    5b7c:	82 e0       	ldi	r24, 0x02	; 2
    5b7e:	80 93 a8 05 	sts	0x05A8, r24
		
		if (editValueType == TYPE_UINT8)
    5b82:	80 91 c5 07 	lds	r24, 0x07C5
    5b86:	82 30       	cpi	r24, 0x02	; 2
    5b88:	11 f0       	breq	.+4      	; 0x5b8e <editModeHandler+0x20>
			*((uint8_t*)editValuePtr) = (uint8_t) editValue;
		else if (editValueType == TYPE_INT8)
    5b8a:	81 30       	cpi	r24, 0x01	; 1
    5b8c:	41 f4       	brne	.+16     	; 0x5b9e <editModeHandler+0x30>
			*((int8_t*)editValuePtr) = (int8_t) editValue;
    5b8e:	e0 91 c3 07 	lds	r30, 0x07C3
    5b92:	f0 91 c4 07 	lds	r31, 0x07C4
    5b96:	80 91 ca 07 	lds	r24, 0x07CA
    5b9a:	80 83       	st	Z, r24
    5b9c:	58 c0       	rjmp	.+176    	; 0x5c4e <editModeHandler+0xe0>
		else if (editValueType == TYPE_INT16)
    5b9e:	83 30       	cpi	r24, 0x03	; 3
    5ba0:	19 f0       	breq	.+6      	; 0x5ba8 <editModeHandler+0x3a>
			*(int16_t*)editValuePtr = (int16_t) editValue;
		else if (editValueType == TYPE_UINT16)
    5ba2:	84 30       	cpi	r24, 0x04	; 4
    5ba4:	09 f0       	breq	.+2      	; 0x5ba8 <editModeHandler+0x3a>
    5ba6:	53 c0       	rjmp	.+166    	; 0x5c4e <editModeHandler+0xe0>
			*(uint16_t*)editValuePtr =(uint16_t) editValue;
    5ba8:	e0 91 c3 07 	lds	r30, 0x07C3
    5bac:	f0 91 c4 07 	lds	r31, 0x07C4
    5bb0:	80 91 ca 07 	lds	r24, 0x07CA
    5bb4:	90 91 cb 07 	lds	r25, 0x07CB
    5bb8:	91 83       	std	Z+1, r25	; 0x01
    5bba:	80 83       	st	Z, r24
    5bbc:	48 c0       	rjmp	.+144    	; 0x5c4e <editModeHandler+0xe0>
		
		LCD_SelectFont(NULL);
		defaultHandler();
		return;
	}
	if (ANYKEY)
    5bbe:	88 23       	and	r24, r24
    5bc0:	09 f4       	brne	.+2      	; 0x5bc4 <editModeHandler+0x56>
    5bc2:	56 c0       	rjmp	.+172    	; 0x5c70 <editModeHandler+0x102>
	{
		if (KEY2)	// DOWN?
    5bc4:	86 ff       	sbrs	r24, 6
    5bc6:	1b c0       	rjmp	.+54     	; 0x5bfe <editModeHandler+0x90>
		{
			
				if (_keyrepeat == KEYBOARD_REPEAT)
    5bc8:	20 91 b9 05 	lds	r18, 0x05B9
    5bcc:	80 91 ca 07 	lds	r24, 0x07CA
    5bd0:	90 91 cb 07 	lds	r25, 0x07CB
    5bd4:	21 30       	cpi	r18, 0x01	; 1
    5bd6:	11 f4       	brne	.+4      	; 0x5bdc <editModeHandler+0x6e>
				{
					editValue-=10;
    5bd8:	0a 97       	sbiw	r24, 0x0a	; 10
    5bda:	01 c0       	rjmp	.+2      	; 0x5bde <editModeHandler+0x70>
				}
				else
				{
					editValue--;	
    5bdc:	01 97       	sbiw	r24, 0x01	; 1
    5bde:	90 93 cb 07 	sts	0x07CB, r25
    5be2:	80 93 ca 07 	sts	0x07CA, r24
				}
				
				if (editValue < editLoLimit)				
    5be6:	80 91 c7 07 	lds	r24, 0x07C7
    5bea:	90 91 c8 07 	lds	r25, 0x07C8
    5bee:	20 91 ca 07 	lds	r18, 0x07CA
    5bf2:	30 91 cb 07 	lds	r19, 0x07CB
    5bf6:	28 17       	cp	r18, r24
    5bf8:	39 07       	cpc	r19, r25
    5bfa:	84 f5       	brge	.+96     	; 0x5c5c <editModeHandler+0xee>
    5bfc:	1c c0       	rjmp	.+56     	; 0x5c36 <editModeHandler+0xc8>
				{
					editValue = editLoLimit;
				}
		}
		else if (KEY3)	// UP?
    5bfe:	85 ff       	sbrs	r24, 5
    5c00:	1f c0       	rjmp	.+62     	; 0x5c40 <editModeHandler+0xd2>
		{
				if (_keyrepeat == KEYBOARD_REPEAT)
    5c02:	20 91 b9 05 	lds	r18, 0x05B9
    5c06:	80 91 ca 07 	lds	r24, 0x07CA
    5c0a:	90 91 cb 07 	lds	r25, 0x07CB
    5c0e:	21 30       	cpi	r18, 0x01	; 1
    5c10:	11 f4       	brne	.+4      	; 0x5c16 <editModeHandler+0xa8>
				{
					editValue+=10;
    5c12:	0a 96       	adiw	r24, 0x0a	; 10
    5c14:	01 c0       	rjmp	.+2      	; 0x5c18 <editModeHandler+0xaa>
				}
				else
				{
					editValue++;	
    5c16:	01 96       	adiw	r24, 0x01	; 1
    5c18:	90 93 cb 07 	sts	0x07CB, r25
    5c1c:	80 93 ca 07 	sts	0x07CA, r24
				}
				
				if (editValue > editHiLimit)
    5c20:	80 91 c1 07 	lds	r24, 0x07C1
    5c24:	90 91 c2 07 	lds	r25, 0x07C2
    5c28:	20 91 ca 07 	lds	r18, 0x07CA
    5c2c:	30 91 cb 07 	lds	r19, 0x07CB
    5c30:	82 17       	cp	r24, r18
    5c32:	93 07       	cpc	r25, r19
    5c34:	9c f4       	brge	.+38     	; 0x5c5c <editModeHandler+0xee>
				{
					editValue=editHiLimit;
    5c36:	90 93 cb 07 	sts	0x07CB, r25
    5c3a:	80 93 ca 07 	sts	0x07CA, r24
    5c3e:	0e c0       	rjmp	.+28     	; 0x5c5c <editModeHandler+0xee>
				}					
		}
		else if (KEY1)	// CLR?
    5c40:	87 ff       	sbrs	r24, 7
    5c42:	0c c0       	rjmp	.+24     	; 0x5c5c <editModeHandler+0xee>
		{
			editMode = false;
    5c44:	10 92 c6 07 	sts	0x07C6, r1
			_mykey = KEY_REFRESH;
    5c48:	82 e0       	ldi	r24, 0x02	; 2
    5c4a:	80 93 a8 05 	sts	0x05A8, r24
	
			LCD_SelectFont(NULL);
    5c4e:	80 e0       	ldi	r24, 0x00	; 0
    5c50:	90 e0       	ldi	r25, 0x00	; 0
    5c52:	0e 94 5c 0e 	call	0x1cb8	; 0x1cb8 <LCD_SelectFont>
			defaultHandler();
    5c56:	0e 94 91 2d 	call	0x5b22	; 0x5b22 <defaultHandler>
			return;	
    5c5a:	0a c0       	rjmp	.+20     	; 0x5c70 <editModeHandler+0x102>
		}
			
		LCD_WriteValue(2, 34, editValue, 5, -1);
    5c5c:	40 91 ca 07 	lds	r20, 0x07CA
    5c60:	50 91 cb 07 	lds	r21, 0x07CB
    5c64:	82 e0       	ldi	r24, 0x02	; 2
    5c66:	62 e2       	ldi	r22, 0x22	; 34
    5c68:	25 e0       	ldi	r18, 0x05	; 5
    5c6a:	0f ef       	ldi	r16, 0xFF	; 255
    5c6c:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <LCD_WriteValue>
	}
}
    5c70:	0f 91       	pop	r16
    5c72:	08 95       	ret

00005c74 <startEditMode>:

static void startEditMode(void* valuePtr, int16_t loLimit, int16_t hiLimit, uint8_t valueType)
{
    5c74:	0f 93       	push	r16
    5c76:	fc 01       	movw	r30, r24
	editMode = true;
    5c78:	81 e0       	ldi	r24, 0x01	; 1
    5c7a:	80 93 c6 07 	sts	0x07C6, r24
	_mykey = KEY_INIT;
    5c7e:	80 93 a8 05 	sts	0x05A8, r24
	editValuePtr = valuePtr;
    5c82:	f0 93 c4 07 	sts	0x07C4, r31
    5c86:	e0 93 c3 07 	sts	0x07C3, r30
	editValueType = valueType;
    5c8a:	20 93 c5 07 	sts	0x07C5, r18
	
	if (valueType == TYPE_UINT8)
    5c8e:	22 30       	cpi	r18, 0x02	; 2
    5c90:	31 f4       	brne	.+12     	; 0x5c9e <startEditMode+0x2a>
		editValue = *(uint8_t*)valuePtr;
    5c92:	80 81       	ld	r24, Z
    5c94:	80 93 ca 07 	sts	0x07CA, r24
    5c98:	10 92 cb 07 	sts	0x07CB, r1
    5c9c:	11 c0       	rjmp	.+34     	; 0x5cc0 <startEditMode+0x4c>
	else if (valueType == TYPE_INT8)
    5c9e:	21 30       	cpi	r18, 0x01	; 1
    5ca0:	29 f4       	brne	.+10     	; 0x5cac <startEditMode+0x38>
		editValue = *(int8_t*)valuePtr;
    5ca2:	80 81       	ld	r24, Z
    5ca4:	99 27       	eor	r25, r25
    5ca6:	87 fd       	sbrc	r24, 7
    5ca8:	90 95       	com	r25
    5caa:	06 c0       	rjmp	.+12     	; 0x5cb8 <startEditMode+0x44>
	else if (valueType == TYPE_INT16)
    5cac:	23 30       	cpi	r18, 0x03	; 3
    5cae:	11 f0       	breq	.+4      	; 0x5cb4 <startEditMode+0x40>
 		editValue = *(int16_t*)valuePtr;
	else if (valueType == TYPE_UINT16)
    5cb0:	24 30       	cpi	r18, 0x04	; 4
    5cb2:	31 f4       	brne	.+12     	; 0x5cc0 <startEditMode+0x4c>
 		editValue = *(uint16_t*)valuePtr;
    5cb4:	80 81       	ld	r24, Z
    5cb6:	91 81       	ldd	r25, Z+1	; 0x01
    5cb8:	90 93 cb 07 	sts	0x07CB, r25
    5cbc:	80 93 ca 07 	sts	0x07CA, r24
	
	editLoLimit = loLimit;
    5cc0:	70 93 c8 07 	sts	0x07C8, r23
    5cc4:	60 93 c7 07 	sts	0x07C7, r22
	editHiLimit = hiLimit;
    5cc8:	50 93 c2 07 	sts	0x07C2, r21
    5ccc:	40 93 c1 07 	sts	0x07C1, r20
	
	LCD_FillRectangle(30, 11, 98, 34, 0);
    5cd0:	8e e1       	ldi	r24, 0x1E	; 30
    5cd2:	6b e0       	ldi	r22, 0x0B	; 11
    5cd4:	42 e6       	ldi	r20, 0x62	; 98
    5cd6:	22 e2       	ldi	r18, 0x22	; 34
    5cd8:	00 e0       	ldi	r16, 0x00	; 0
    5cda:	0e 94 3f 0c 	call	0x187e	; 0x187e <LCD_FillRectangle>
	LCD_Rectangle(30, 11, 98, 34, 1);
    5cde:	8e e1       	ldi	r24, 0x1E	; 30
    5ce0:	6b e0       	ldi	r22, 0x0B	; 11
    5ce2:	42 e6       	ldi	r20, 0x62	; 98
    5ce4:	22 e2       	ldi	r18, 0x22	; 34
    5ce6:	01 e0       	ldi	r16, 0x01	; 1
    5ce8:	0e 94 3e 0c 	call	0x187c	; 0x187c <LCD_Rectangle>
	LCD_Rectangle(31, 12, 97, 33, 1);
    5cec:	8f e1       	ldi	r24, 0x1F	; 31
    5cee:	6c e0       	ldi	r22, 0x0C	; 12
    5cf0:	41 e6       	ldi	r20, 0x61	; 97
    5cf2:	21 e2       	ldi	r18, 0x21	; 33
    5cf4:	0e 94 3e 0c 	call	0x187c	; 0x187c <LCD_Rectangle>
	writeSoftkeys(_skEDIT);
    5cf8:	87 e2       	ldi	r24, 0x27	; 39
    5cfa:	9c e0       	ldi	r25, 0x0C	; 12
    5cfc:	0e 94 42 28 	call	0x5084	; 0x5084 <writeSoftkeys>
	LCD_SelectFont(&font12x16);
    5d00:	89 e4       	ldi	r24, 0x49	; 73
    5d02:	91 e0       	ldi	r25, 0x01	; 1
    5d04:	0e 94 5c 0e 	call	0x1cb8	; 0x1cb8 <LCD_SelectFont>
	editModeHandler();
    5d08:	0e 94 b7 2d 	call	0x5b6e	; 0x5b6e <editModeHandler>
}
    5d0c:	0f 91       	pop	r16
    5d0e:	08 95       	ret

00005d10 <PageKey>:
}


void PageKey(const uint8_t num)
{
	if (KEY2)	// PREV
    5d10:	90 91 a8 05 	lds	r25, 0x05A8
    5d14:	96 ff       	sbrs	r25, 6
    5d16:	08 c0       	rjmp	.+16     	; 0x5d28 <PageKey+0x18>
		subpage = subpage == 0 ? num - 1 : subpage - 1;
    5d18:	60 91 2e 05 	lds	r22, 0x052E
    5d1c:	61 11       	cpse	r22, r1
    5d1e:	86 2f       	mov	r24, r22
    5d20:	81 50       	subi	r24, 0x01	; 1
    5d22:	80 93 2e 05 	sts	0x052E, r24
    5d26:	08 95       	ret
	else if (KEY3) // NEXT
    5d28:	95 ff       	sbrs	r25, 5
    5d2a:	0c c0       	rjmp	.+24     	; 0x5d44 <PageKey+0x34>
		subpage = (subpage + 1) % num;
    5d2c:	20 91 2e 05 	lds	r18, 0x052E
    5d30:	30 e0       	ldi	r19, 0x00	; 0
    5d32:	2f 5f       	subi	r18, 0xFF	; 255
    5d34:	3f 4f       	sbci	r19, 0xFF	; 255
    5d36:	68 2f       	mov	r22, r24
    5d38:	c9 01       	movw	r24, r18
    5d3a:	70 e0       	ldi	r23, 0x00	; 0
    5d3c:	0e 94 f4 37 	call	0x6fe8	; 0x6fe8 <__divmodhi4>
    5d40:	80 93 2e 05 	sts	0x052E, r24
    5d44:	08 95       	ret

00005d46 <_hAltitudeHold>:




void _hAltitudeHold()
{
    5d46:	0f 93       	push	r16
	
	NOKEYRETURN;
    5d48:	80 91 a8 05 	lds	r24, 0x05A8
    5d4c:	88 23       	and	r24, r24
    5d4e:	09 f4       	brne	.+2      	; 0x5d52 <_hAltitudeHold+0xc>
    5d50:	a2 c0       	rjmp	.+324    	; 0x5e96 <_hAltitudeHold+0x150>
	PageKey(6);
    5d52:	86 e0       	ldi	r24, 0x06	; 6
    5d54:	0e 94 88 2e 	call	0x5d10	; 0x5d10 <PageKey>
	
	
	if (KEY4)
    5d58:	20 91 a8 05 	lds	r18, 0x05A8
    5d5c:	24 ff       	sbrs	r18, 4
    5d5e:	36 c0       	rjmp	.+108    	; 0x5dcc <_hAltitudeHold+0x86>
	{
		bValueChanged = true;
    5d60:	81 e0       	ldi	r24, 0x01	; 1
    5d62:	80 93 2a 05 	sts	0x052A, r24
		currentPage.softkeys = _skMENUSAVE;
    5d66:	80 e0       	ldi	r24, 0x00	; 0
    5d68:	9c e0       	ldi	r25, 0x0C	; 12
    5d6a:	90 93 31 05 	sts	0x0531, r25
    5d6e:	80 93 30 05 	sts	0x0530, r24
		switch (subpage)
    5d72:	80 91 2e 05 	lds	r24, 0x052E
    5d76:	82 30       	cpi	r24, 0x02	; 2
    5d78:	a1 f0       	breq	.+40     	; 0x5da2 <_hAltitudeHold+0x5c>
    5d7a:	83 30       	cpi	r24, 0x03	; 3
    5d7c:	28 f4       	brcc	.+10     	; 0x5d88 <_hAltitudeHold+0x42>
    5d7e:	88 23       	and	r24, r24
    5d80:	51 f0       	breq	.+20     	; 0x5d96 <_hAltitudeHold+0x50>
    5d82:	81 30       	cpi	r24, 0x01	; 1
    5d84:	19 f5       	brne	.+70     	; 0x5dcc <_hAltitudeHold+0x86>
    5d86:	0a c0       	rjmp	.+20     	; 0x5d9c <_hAltitudeHold+0x56>
    5d88:	84 30       	cpi	r24, 0x04	; 4
    5d8a:	89 f0       	breq	.+34     	; 0x5dae <_hAltitudeHold+0x68>
    5d8c:	84 30       	cpi	r24, 0x04	; 4
    5d8e:	60 f0       	brcs	.+24     	; 0x5da8 <_hAltitudeHold+0x62>
    5d90:	85 30       	cpi	r24, 0x05	; 5
    5d92:	e1 f4       	brne	.+56     	; 0x5dcc <_hAltitudeHold+0x86>
    5d94:	11 c0       	rjmp	.+34     	; 0x5db8 <_hAltitudeHold+0x72>
		{
			case 0: startEditMode(&(Config.SonarParams[0]._P),-500,500,TYPE_INT16); return ;
    5d96:	87 e2       	ldi	r24, 0x27	; 39
    5d98:	97 e0       	ldi	r25, 0x07	; 7
    5d9a:	0b c0       	rjmp	.+22     	; 0x5db2 <_hAltitudeHold+0x6c>
			case 1: startEditMode(&(Config.SonarParams[0]._PLimit),0,500,TYPE_INT16); return ;
    5d9c:	89 e2       	ldi	r24, 0x29	; 41
    5d9e:	97 e0       	ldi	r25, 0x07	; 7
    5da0:	0d c0       	rjmp	.+26     	; 0x5dbc <_hAltitudeHold+0x76>
			case 2: startEditMode(&(Config.SonarParams[0]._I),-500,500,TYPE_INT16);  return ;
    5da2:	8b e2       	ldi	r24, 0x2B	; 43
    5da4:	97 e0       	ldi	r25, 0x07	; 7
    5da6:	05 c0       	rjmp	.+10     	; 0x5db2 <_hAltitudeHold+0x6c>
			case 3: startEditMode(&(Config.SonarParams[0]._ILimit),0,500,TYPE_INT16); return ;
    5da8:	8d e2       	ldi	r24, 0x2D	; 45
    5daa:	97 e0       	ldi	r25, 0x07	; 7
    5dac:	07 c0       	rjmp	.+14     	; 0x5dbc <_hAltitudeHold+0x76>
			case 4: startEditMode(&(Config.SonarParams[0]._D),-500,500,TYPE_INT16);  return ; // negative D
    5dae:	8f e2       	ldi	r24, 0x2F	; 47
    5db0:	97 e0       	ldi	r25, 0x07	; 7
    5db2:	6c e0       	ldi	r22, 0x0C	; 12
    5db4:	7e ef       	ldi	r23, 0xFE	; 254
    5db6:	04 c0       	rjmp	.+8      	; 0x5dc0 <_hAltitudeHold+0x7a>
			case 5: startEditMode(&(Config.SonarParams[0]._DLimit),0,500,TYPE_INT16); return ;
    5db8:	81 e3       	ldi	r24, 0x31	; 49
    5dba:	97 e0       	ldi	r25, 0x07	; 7
    5dbc:	60 e0       	ldi	r22, 0x00	; 0
    5dbe:	70 e0       	ldi	r23, 0x00	; 0
    5dc0:	44 ef       	ldi	r20, 0xF4	; 244
    5dc2:	51 e0       	ldi	r21, 0x01	; 1
    5dc4:	23 e0       	ldi	r18, 0x03	; 3
    5dc6:	0e 94 3a 2e 	call	0x5c74	; 0x5c74 <startEditMode>
    5dca:	65 c0       	rjmp	.+202    	; 0x5e96 <_hAltitudeHold+0x150>
		}
	}
	
	if (KEY1)
    5dcc:	27 ff       	sbrs	r18, 7
    5dce:	02 c0       	rjmp	.+4      	; 0x5dd4 <_hAltitudeHold+0x8e>
	{
		_helper_SaveinEEPROM_ifChanged();
    5dd0:	0e 94 36 2a 	call	0x546c	; 0x546c <_helper_SaveinEEPROM_ifChanged>
	}
	
	LCD_WriteValue(1,30,Config.SonarParams[0]._P,3,0==subpage);
    5dd4:	40 91 27 07 	lds	r20, 0x0727
    5dd8:	50 91 28 07 	lds	r21, 0x0728
    5ddc:	01 e0       	ldi	r16, 0x01	; 1
    5dde:	80 91 2e 05 	lds	r24, 0x052E
    5de2:	81 11       	cpse	r24, r1
    5de4:	00 e0       	ldi	r16, 0x00	; 0
    5de6:	81 e0       	ldi	r24, 0x01	; 1
    5de8:	6e e1       	ldi	r22, 0x1E	; 30
    5dea:	23 e0       	ldi	r18, 0x03	; 3
    5dec:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <LCD_WriteValue>
	LCD_WriteValue(1,84,Config.SonarParams[0]._PLimit,3,1==subpage);
    5df0:	40 91 29 07 	lds	r20, 0x0729
    5df4:	50 91 2a 07 	lds	r21, 0x072A
    5df8:	01 e0       	ldi	r16, 0x01	; 1
    5dfa:	80 91 2e 05 	lds	r24, 0x052E
    5dfe:	81 30       	cpi	r24, 0x01	; 1
    5e00:	09 f0       	breq	.+2      	; 0x5e04 <_hAltitudeHold+0xbe>
    5e02:	00 e0       	ldi	r16, 0x00	; 0
    5e04:	81 e0       	ldi	r24, 0x01	; 1
    5e06:	64 e5       	ldi	r22, 0x54	; 84
    5e08:	23 e0       	ldi	r18, 0x03	; 3
    5e0a:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <LCD_WriteValue>
	LCD_WriteValue(2,30,Config.SonarParams[0]._I,3,2==subpage);
    5e0e:	40 91 2b 07 	lds	r20, 0x072B
    5e12:	50 91 2c 07 	lds	r21, 0x072C
    5e16:	01 e0       	ldi	r16, 0x01	; 1
    5e18:	80 91 2e 05 	lds	r24, 0x052E
    5e1c:	82 30       	cpi	r24, 0x02	; 2
    5e1e:	09 f0       	breq	.+2      	; 0x5e22 <_hAltitudeHold+0xdc>
    5e20:	00 e0       	ldi	r16, 0x00	; 0
    5e22:	82 e0       	ldi	r24, 0x02	; 2
    5e24:	6e e1       	ldi	r22, 0x1E	; 30
    5e26:	23 e0       	ldi	r18, 0x03	; 3
    5e28:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <LCD_WriteValue>
	LCD_WriteValue(2,84,Config.SonarParams[0]._ILimit,3,3==subpage);
    5e2c:	40 91 2d 07 	lds	r20, 0x072D
    5e30:	50 91 2e 07 	lds	r21, 0x072E
    5e34:	01 e0       	ldi	r16, 0x01	; 1
    5e36:	80 91 2e 05 	lds	r24, 0x052E
    5e3a:	83 30       	cpi	r24, 0x03	; 3
    5e3c:	09 f0       	breq	.+2      	; 0x5e40 <_hAltitudeHold+0xfa>
    5e3e:	00 e0       	ldi	r16, 0x00	; 0
    5e40:	82 e0       	ldi	r24, 0x02	; 2
    5e42:	64 e5       	ldi	r22, 0x54	; 84
    5e44:	23 e0       	ldi	r18, 0x03	; 3
    5e46:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <LCD_WriteValue>
	LCD_WriteValue(3,30,Config.SonarParams[0]._D,3,4==subpage);
    5e4a:	40 91 2f 07 	lds	r20, 0x072F
    5e4e:	50 91 30 07 	lds	r21, 0x0730
    5e52:	01 e0       	ldi	r16, 0x01	; 1
    5e54:	80 91 2e 05 	lds	r24, 0x052E
    5e58:	84 30       	cpi	r24, 0x04	; 4
    5e5a:	09 f0       	breq	.+2      	; 0x5e5e <_hAltitudeHold+0x118>
    5e5c:	00 e0       	ldi	r16, 0x00	; 0
    5e5e:	83 e0       	ldi	r24, 0x03	; 3
    5e60:	6e e1       	ldi	r22, 0x1E	; 30
    5e62:	23 e0       	ldi	r18, 0x03	; 3
    5e64:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <LCD_WriteValue>
	LCD_WriteValue(3,84,Config.SonarParams[0]._DLimit,3,5==subpage);
    5e68:	40 91 31 07 	lds	r20, 0x0731
    5e6c:	50 91 32 07 	lds	r21, 0x0732
    5e70:	01 e0       	ldi	r16, 0x01	; 1
    5e72:	80 91 2e 05 	lds	r24, 0x052E
    5e76:	85 30       	cpi	r24, 0x05	; 5
    5e78:	09 f0       	breq	.+2      	; 0x5e7c <_hAltitudeHold+0x136>
    5e7a:	00 e0       	ldi	r16, 0x00	; 0
    5e7c:	83 e0       	ldi	r24, 0x03	; 3
    5e7e:	64 e5       	ldi	r22, 0x54	; 84
    5e80:	23 e0       	ldi	r18, 0x03	; 3
    5e82:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <LCD_WriteValue>
	LCD_WriteString_Pex(5,0,PSTR("                "),16,false);    
    5e86:	85 e0       	ldi	r24, 0x05	; 5
    5e88:	60 e0       	ldi	r22, 0x00	; 0
    5e8a:	46 e1       	ldi	r20, 0x16	; 22
    5e8c:	5c e0       	ldi	r21, 0x0C	; 12
    5e8e:	20 e1       	ldi	r18, 0x10	; 16
    5e90:	00 e0       	ldi	r16, 0x00	; 0
    5e92:	0e 94 8d 0d 	call	0x1b1a	; 0x1b1a <LCD_WriteString_Pex>
				
}
    5e96:	0f 91       	pop	r16
    5e98:	08 95       	ret

00005e9a <_hSelfLeveling>:
}



void _hSelfLeveling()
{
    5e9a:	0f 93       	push	r16
	NOKEYRETURN;
    5e9c:	80 91 a8 05 	lds	r24, 0x05A8
    5ea0:	88 23       	and	r24, r24
    5ea2:	09 f4       	brne	.+2      	; 0x5ea6 <_hSelfLeveling+0xc>
    5ea4:	ff c1       	rjmp	.+1022   	; 0x62a4 <_hSelfLeveling+0x40a>
	PageKey(10);
    5ea6:	8a e0       	ldi	r24, 0x0A	; 10
    5ea8:	0e 94 88 2e 	call	0x5d10	; 0x5d10 <PageKey>
	
	if ((subindex==2) && (subpage>7)) subpage=0;
    5eac:	80 91 2f 05 	lds	r24, 0x052F
    5eb0:	82 30       	cpi	r24, 0x02	; 2
    5eb2:	31 f4       	brne	.+12     	; 0x5ec0 <_hSelfLeveling+0x26>
    5eb4:	80 91 2e 05 	lds	r24, 0x052E
    5eb8:	88 30       	cpi	r24, 0x08	; 8
    5eba:	10 f0       	brcs	.+4      	; 0x5ec0 <_hSelfLeveling+0x26>
    5ebc:	10 92 2e 05 	sts	0x052E, r1
		
	
	
	if (KEY4)
    5ec0:	80 91 a8 05 	lds	r24, 0x05A8
    5ec4:	84 ff       	sbrs	r24, 4
    5ec6:	d6 c0       	rjmp	.+428    	; 0x6074 <_hSelfLeveling+0x1da>
	{
		if (subpage!=0) bValueChanged = true;
    5ec8:	20 91 2e 05 	lds	r18, 0x052E
    5ecc:	22 23       	and	r18, r18
    5ece:	19 f0       	breq	.+6      	; 0x5ed6 <_hSelfLeveling+0x3c>
    5ed0:	81 e0       	ldi	r24, 0x01	; 1
    5ed2:	80 93 2a 05 	sts	0x052A, r24
		currentPage.softkeys = _skMENUSAVE;
    5ed6:	80 e0       	ldi	r24, 0x00	; 0
    5ed8:	9c e0       	ldi	r25, 0x0C	; 12
    5eda:	90 93 31 05 	sts	0x0531, r25
    5ede:	80 93 30 05 	sts	0x0530, r24
		
		switch (subpage)
    5ee2:	24 30       	cpi	r18, 0x04	; 4
    5ee4:	09 f4       	brne	.+2      	; 0x5ee8 <_hSelfLeveling+0x4e>
    5ee6:	6e c0       	rjmp	.+220    	; 0x5fc4 <_hSelfLeveling+0x12a>
    5ee8:	25 30       	cpi	r18, 0x05	; 5
    5eea:	58 f4       	brcc	.+22     	; 0x5f02 <_hSelfLeveling+0x68>
    5eec:	21 30       	cpi	r18, 0x01	; 1
    5eee:	99 f1       	breq	.+102    	; 0x5f56 <_hSelfLeveling+0xbc>
    5ef0:	21 30       	cpi	r18, 0x01	; 1
    5ef2:	d0 f0       	brcs	.+52     	; 0x5f28 <_hSelfLeveling+0x8e>
    5ef4:	22 30       	cpi	r18, 0x02	; 2
    5ef6:	09 f4       	brne	.+2      	; 0x5efa <_hSelfLeveling+0x60>
    5ef8:	3f c0       	rjmp	.+126    	; 0x5f78 <_hSelfLeveling+0xde>
    5efa:	23 30       	cpi	r18, 0x03	; 3
    5efc:	09 f0       	breq	.+2      	; 0x5f00 <_hSelfLeveling+0x66>
    5efe:	ba c0       	rjmp	.+372    	; 0x6074 <_hSelfLeveling+0x1da>
    5f00:	50 c0       	rjmp	.+160    	; 0x5fa2 <_hSelfLeveling+0x108>
    5f02:	27 30       	cpi	r18, 0x07	; 7
    5f04:	09 f4       	brne	.+2      	; 0x5f08 <_hSelfLeveling+0x6e>
    5f06:	93 c0       	rjmp	.+294    	; 0x602e <_hSelfLeveling+0x194>
    5f08:	28 30       	cpi	r18, 0x08	; 8
    5f0a:	38 f4       	brcc	.+14     	; 0x5f1a <_hSelfLeveling+0x80>
    5f0c:	25 30       	cpi	r18, 0x05	; 5
    5f0e:	09 f4       	brne	.+2      	; 0x5f12 <_hSelfLeveling+0x78>
    5f10:	6a c0       	rjmp	.+212    	; 0x5fe6 <_hSelfLeveling+0x14c>
    5f12:	26 30       	cpi	r18, 0x06	; 6
    5f14:	09 f0       	breq	.+2      	; 0x5f18 <_hSelfLeveling+0x7e>
    5f16:	ae c0       	rjmp	.+348    	; 0x6074 <_hSelfLeveling+0x1da>
    5f18:	79 c0       	rjmp	.+242    	; 0x600c <_hSelfLeveling+0x172>
    5f1a:	28 30       	cpi	r18, 0x08	; 8
    5f1c:	09 f4       	brne	.+2      	; 0x5f20 <_hSelfLeveling+0x86>
    5f1e:	9d c0       	rjmp	.+314    	; 0x605a <_hSelfLeveling+0x1c0>
    5f20:	29 30       	cpi	r18, 0x09	; 9
    5f22:	09 f0       	breq	.+2      	; 0x5f26 <_hSelfLeveling+0x8c>
    5f24:	a7 c0       	rjmp	.+334    	; 0x6074 <_hSelfLeveling+0x1da>
    5f26:	9c c0       	rjmp	.+312    	; 0x6060 <_hSelfLeveling+0x1c6>
		{
			case 0: _helper_SwitchPitchRollYaw(&subindex); 
    5f28:	8f e2       	ldi	r24, 0x2F	; 47
    5f2a:	95 e0       	ldi	r25, 0x05	; 5
    5f2c:	0e 94 f6 29 	call	0x53ec	; 0x53ec <_helper_SwitchPitchRollYaw>
					if (subindex==2) 
    5f30:	80 91 2f 05 	lds	r24, 0x052F
    5f34:	82 30       	cpi	r24, 0x02	; 2
    5f36:	31 f4       	brne	.+12     	; 0x5f44 <_hSelfLeveling+0xaa>
					{
						LCD_WriteString_Pex(5,0,PSTR("                "),16,false);    
    5f38:	85 e0       	ldi	r24, 0x05	; 5
    5f3a:	60 e0       	ldi	r22, 0x00	; 0
    5f3c:	49 e5       	ldi	r20, 0x59	; 89
    5f3e:	5c e0       	ldi	r21, 0x0C	; 12
    5f40:	20 e1       	ldi	r18, 0x10	; 16
    5f42:	05 c0       	rjmp	.+10     	; 0x5f4e <_hSelfLeveling+0xb4>
					}
					else
					{
						LCD_WriteString_Pex(5,0,PSTR("Trim P:    R:"),13,false);
    5f44:	85 e0       	ldi	r24, 0x05	; 5
    5f46:	60 e0       	ldi	r22, 0x00	; 0
    5f48:	4b e4       	ldi	r20, 0x4B	; 75
    5f4a:	5c e0       	ldi	r21, 0x0C	; 12
    5f4c:	2d e0       	ldi	r18, 0x0D	; 13
    5f4e:	00 e0       	ldi	r16, 0x00	; 0
    5f50:	0e 94 8d 0d 	call	0x1b1a	; 0x1b1a <LCD_WriteString_Pex>
    5f54:	8f c0       	rjmp	.+286    	; 0x6074 <_hSelfLeveling+0x1da>
					}				
					break;		
			case 1: startEditMode(&(Config.AccParams[subindex]._P),-500,500,TYPE_INT16); return ;
    5f56:	80 91 2f 05 	lds	r24, 0x052F
    5f5a:	90 e0       	ldi	r25, 0x00	; 0
    5f5c:	9c 01       	movw	r18, r24
    5f5e:	22 0f       	add	r18, r18
    5f60:	33 1f       	adc	r19, r19
    5f62:	c9 01       	movw	r24, r18
    5f64:	e3 e0       	ldi	r30, 0x03	; 3
    5f66:	88 0f       	add	r24, r24
    5f68:	99 1f       	adc	r25, r25
    5f6a:	ea 95       	dec	r30
    5f6c:	e1 f7       	brne	.-8      	; 0x5f66 <_hSelfLeveling+0xcc>
    5f6e:	82 1b       	sub	r24, r18
    5f70:	93 0b       	sbc	r25, r19
    5f72:	83 50       	subi	r24, 0x03	; 3
    5f74:	99 4f       	sbci	r25, 0xF9	; 249
    5f76:	47 c0       	rjmp	.+142    	; 0x6006 <_hSelfLeveling+0x16c>
			case 2: startEditMode(&(Config.AccParams[subindex]._PLimit),0,500,TYPE_INT16); return ;
    5f78:	80 91 2f 05 	lds	r24, 0x052F
    5f7c:	90 e0       	ldi	r25, 0x00	; 0
    5f7e:	9c 01       	movw	r18, r24
    5f80:	22 0f       	add	r18, r18
    5f82:	33 1f       	adc	r19, r19
    5f84:	c9 01       	movw	r24, r18
    5f86:	63 e0       	ldi	r22, 0x03	; 3
    5f88:	88 0f       	add	r24, r24
    5f8a:	99 1f       	adc	r25, r25
    5f8c:	6a 95       	dec	r22
    5f8e:	e1 f7       	brne	.-8      	; 0x5f88 <_hSelfLeveling+0xee>
    5f90:	82 1b       	sub	r24, r18
    5f92:	93 0b       	sbc	r25, r19
    5f94:	81 50       	subi	r24, 0x01	; 1
    5f96:	99 4f       	sbci	r25, 0xF9	; 249
    5f98:	60 e0       	ldi	r22, 0x00	; 0
    5f9a:	70 e0       	ldi	r23, 0x00	; 0
    5f9c:	44 ef       	ldi	r20, 0xF4	; 244
    5f9e:	51 e0       	ldi	r21, 0x01	; 1
    5fa0:	5a c0       	rjmp	.+180    	; 0x6056 <_hSelfLeveling+0x1bc>
			case 3: startEditMode(&(Config.AccParams[subindex]._I),-500,500,TYPE_INT16);  return ;
    5fa2:	80 91 2f 05 	lds	r24, 0x052F
    5fa6:	90 e0       	ldi	r25, 0x00	; 0
    5fa8:	9c 01       	movw	r18, r24
    5faa:	22 0f       	add	r18, r18
    5fac:	33 1f       	adc	r19, r19
    5fae:	c9 01       	movw	r24, r18
    5fb0:	43 e0       	ldi	r20, 0x03	; 3
    5fb2:	88 0f       	add	r24, r24
    5fb4:	99 1f       	adc	r25, r25
    5fb6:	4a 95       	dec	r20
    5fb8:	e1 f7       	brne	.-8      	; 0x5fb2 <_hSelfLeveling+0x118>
    5fba:	82 1b       	sub	r24, r18
    5fbc:	93 0b       	sbc	r25, r19
    5fbe:	8f 5f       	subi	r24, 0xFF	; 255
    5fc0:	98 4f       	sbci	r25, 0xF8	; 248
    5fc2:	21 c0       	rjmp	.+66     	; 0x6006 <_hSelfLeveling+0x16c>
			case 4: startEditMode(&(Config.AccParams[subindex]._ILimit),0,500,TYPE_INT16); return ;
    5fc4:	80 91 2f 05 	lds	r24, 0x052F
    5fc8:	90 e0       	ldi	r25, 0x00	; 0
    5fca:	9c 01       	movw	r18, r24
    5fcc:	22 0f       	add	r18, r18
    5fce:	33 1f       	adc	r19, r19
    5fd0:	c9 01       	movw	r24, r18
    5fd2:	b3 e0       	ldi	r27, 0x03	; 3
    5fd4:	88 0f       	add	r24, r24
    5fd6:	99 1f       	adc	r25, r25
    5fd8:	ba 95       	dec	r27
    5fda:	e1 f7       	brne	.-8      	; 0x5fd4 <_hSelfLeveling+0x13a>
    5fdc:	82 1b       	sub	r24, r18
    5fde:	93 0b       	sbc	r25, r19
    5fe0:	8d 5f       	subi	r24, 0xFD	; 253
    5fe2:	98 4f       	sbci	r25, 0xF8	; 248
    5fe4:	d9 cf       	rjmp	.-78     	; 0x5f98 <_hSelfLeveling+0xfe>
			case 5: startEditMode(&(Config.AccParams[subindex]._D),-500,500,TYPE_INT16);  return ; // negative D
    5fe6:	80 91 2f 05 	lds	r24, 0x052F
    5fea:	90 e0       	ldi	r25, 0x00	; 0
    5fec:	9c 01       	movw	r18, r24
    5fee:	22 0f       	add	r18, r18
    5ff0:	33 1f       	adc	r19, r19
    5ff2:	c9 01       	movw	r24, r18
    5ff4:	f3 e0       	ldi	r31, 0x03	; 3
    5ff6:	88 0f       	add	r24, r24
    5ff8:	99 1f       	adc	r25, r25
    5ffa:	fa 95       	dec	r31
    5ffc:	e1 f7       	brne	.-8      	; 0x5ff6 <_hSelfLeveling+0x15c>
    5ffe:	82 1b       	sub	r24, r18
    6000:	93 0b       	sbc	r25, r19
    6002:	8b 5f       	subi	r24, 0xFB	; 251
    6004:	98 4f       	sbci	r25, 0xF8	; 248
    6006:	6c e0       	ldi	r22, 0x0C	; 12
    6008:	7e ef       	ldi	r23, 0xFE	; 254
    600a:	c8 cf       	rjmp	.-112    	; 0x5f9c <_hSelfLeveling+0x102>
			case 6: startEditMode(&(Config.AccParams[subindex]._DLimit),0,500,TYPE_INT16); return ;
    600c:	80 91 2f 05 	lds	r24, 0x052F
    6010:	90 e0       	ldi	r25, 0x00	; 0
    6012:	9c 01       	movw	r18, r24
    6014:	22 0f       	add	r18, r18
    6016:	33 1f       	adc	r19, r19
    6018:	c9 01       	movw	r24, r18
    601a:	73 e0       	ldi	r23, 0x03	; 3
    601c:	88 0f       	add	r24, r24
    601e:	99 1f       	adc	r25, r25
    6020:	7a 95       	dec	r23
    6022:	e1 f7       	brne	.-8      	; 0x601c <_hSelfLeveling+0x182>
    6024:	82 1b       	sub	r24, r18
    6026:	93 0b       	sbc	r25, r19
    6028:	89 5f       	subi	r24, 0xF9	; 249
    602a:	98 4f       	sbci	r25, 0xF8	; 248
    602c:	b5 cf       	rjmp	.-150    	; 0x5f98 <_hSelfLeveling+0xfe>
			case 7: startEditMode(&(Config.AccParams[subindex].ComplementaryFilterAlpha),0,999,TYPE_INT16); return ;
    602e:	80 91 2f 05 	lds	r24, 0x052F
    6032:	90 e0       	ldi	r25, 0x00	; 0
    6034:	9c 01       	movw	r18, r24
    6036:	22 0f       	add	r18, r18
    6038:	33 1f       	adc	r19, r19
    603a:	c9 01       	movw	r24, r18
    603c:	53 e0       	ldi	r21, 0x03	; 3
    603e:	88 0f       	add	r24, r24
    6040:	99 1f       	adc	r25, r25
    6042:	5a 95       	dec	r21
    6044:	e1 f7       	brne	.-8      	; 0x603e <_hSelfLeveling+0x1a4>
    6046:	82 1b       	sub	r24, r18
    6048:	93 0b       	sbc	r25, r19
    604a:	87 5f       	subi	r24, 0xF7	; 247
    604c:	98 4f       	sbci	r25, 0xF8	; 248
    604e:	60 e0       	ldi	r22, 0x00	; 0
    6050:	70 e0       	ldi	r23, 0x00	; 0
    6052:	47 ee       	ldi	r20, 0xE7	; 231
    6054:	53 e0       	ldi	r21, 0x03	; 3
    6056:	23 e0       	ldi	r18, 0x03	; 3
    6058:	0a c0       	rjmp	.+20     	; 0x606e <_hSelfLeveling+0x1d4>
			case 8: startEditMode(&(Config.Acc_Pitch_Trim),-25,25,TYPE_INT8);  return ; 
    605a:	86 e3       	ldi	r24, 0x36	; 54
    605c:	97 e0       	ldi	r25, 0x07	; 7
    605e:	02 c0       	rjmp	.+4      	; 0x6064 <_hSelfLeveling+0x1ca>
			case 9: startEditMode(&(Config.Acc_Roll_Trim),-25,25,TYPE_INT8); return ;
    6060:	87 e3       	ldi	r24, 0x37	; 55
    6062:	97 e0       	ldi	r25, 0x07	; 7
    6064:	67 ee       	ldi	r22, 0xE7	; 231
    6066:	7f ef       	ldi	r23, 0xFF	; 255
    6068:	49 e1       	ldi	r20, 0x19	; 25
    606a:	50 e0       	ldi	r21, 0x00	; 0
    606c:	21 e0       	ldi	r18, 0x01	; 1
    606e:	0e 94 3a 2e 	call	0x5c74	; 0x5c74 <startEditMode>
    6072:	18 c1       	rjmp	.+560    	; 0x62a4 <_hSelfLeveling+0x40a>
		}
	}
	
	if (KEY1)
    6074:	80 91 a8 05 	lds	r24, 0x05A8
    6078:	87 ff       	sbrs	r24, 7
    607a:	0f c0       	rjmp	.+30     	; 0x609a <_hSelfLeveling+0x200>
	{
		if (Config.PitchRollLinked==1)
    607c:	80 91 7d 07 	lds	r24, 0x077D
    6080:	81 30       	cpi	r24, 0x01	; 1
    6082:	49 f4       	brne	.+18     	; 0x6096 <_hSelfLeveling+0x1fc>
		{ 
			memcpy(&(Config.AccParams[ROLL_INDEX]),&(Config.AccParams[PITCH_INDEX]), sizeof(pid_param_t));
    6084:	eb e0       	ldi	r30, 0x0B	; 11
    6086:	f7 e0       	ldi	r31, 0x07	; 7
    6088:	df 01       	movw	r26, r30
    608a:	1e 97       	sbiw	r26, 0x0e	; 14
    608c:	8e e0       	ldi	r24, 0x0E	; 14
    608e:	0d 90       	ld	r0, X+
    6090:	01 92       	st	Z+, r0
    6092:	81 50       	subi	r24, 0x01	; 1
    6094:	e1 f7       	brne	.-8      	; 0x608e <_hSelfLeveling+0x1f4>
		}
		
		_helper_SaveinEEPROM_ifChanged();
    6096:	0e 94 36 2a 	call	0x546c	; 0x546c <_helper_SaveinEEPROM_ifChanged>
	}
	
	lcdReverse(subpage == 0);
    609a:	81 e0       	ldi	r24, 0x01	; 1
    609c:	90 91 2e 05 	lds	r25, 0x052E
    60a0:	91 11       	cpse	r25, r1
    60a2:	80 e0       	ldi	r24, 0x00	; 0
    60a4:	0e 94 13 0d 	call	0x1a26	; 0x1a26 <lcdReverse>
	_helper_DisplayPitchRollYaw(subindex);
    60a8:	80 91 2f 05 	lds	r24, 0x052F
    60ac:	0e 94 d3 29 	call	0x53a6	; 0x53a6 <_helper_DisplayPitchRollYaw>
	if (subindex<2)
    60b0:	80 91 2f 05 	lds	r24, 0x052F
    60b4:	82 30       	cpi	r24, 0x02	; 2
    60b6:	08 f5       	brcc	.+66     	; 0x60fa <_hSelfLeveling+0x260>
	{
		LCD_WriteValue(5,42,Config.Acc_Pitch_Trim,3,8==subpage);
    60b8:	40 91 36 07 	lds	r20, 0x0736
    60bc:	55 27       	eor	r21, r21
    60be:	47 fd       	sbrc	r20, 7
    60c0:	50 95       	com	r21
    60c2:	01 e0       	ldi	r16, 0x01	; 1
    60c4:	80 91 2e 05 	lds	r24, 0x052E
    60c8:	88 30       	cpi	r24, 0x08	; 8
    60ca:	09 f0       	breq	.+2      	; 0x60ce <_hSelfLeveling+0x234>
    60cc:	00 e0       	ldi	r16, 0x00	; 0
    60ce:	85 e0       	ldi	r24, 0x05	; 5
    60d0:	6a e2       	ldi	r22, 0x2A	; 42
    60d2:	23 e0       	ldi	r18, 0x03	; 3
    60d4:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <LCD_WriteValue>
		LCD_WriteValue(5,78,Config.Acc_Roll_Trim,3,9==subpage);
    60d8:	40 91 37 07 	lds	r20, 0x0737
    60dc:	55 27       	eor	r21, r21
    60de:	47 fd       	sbrc	r20, 7
    60e0:	50 95       	com	r21
    60e2:	01 e0       	ldi	r16, 0x01	; 1
    60e4:	80 91 2e 05 	lds	r24, 0x052E
    60e8:	89 30       	cpi	r24, 0x09	; 9
    60ea:	09 f0       	breq	.+2      	; 0x60ee <_hSelfLeveling+0x254>
    60ec:	00 e0       	ldi	r16, 0x00	; 0
    60ee:	85 e0       	ldi	r24, 0x05	; 5
    60f0:	6e e4       	ldi	r22, 0x4E	; 78
    60f2:	23 e0       	ldi	r18, 0x03	; 3
    60f4:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <LCD_WriteValue>
    60f8:	06 c0       	rjmp	.+12     	; 0x6106 <_hSelfLeveling+0x26c>
	}
	else
	{
		strcpy_P(sXDeg,PSTR("ACC-Z damping"));
    60fa:	88 ed       	ldi	r24, 0xD8	; 216
    60fc:	95 e0       	ldi	r25, 0x05	; 5
    60fe:	6d e3       	ldi	r22, 0x3D	; 61
    6100:	7c e0       	ldi	r23, 0x0C	; 12
    6102:	0e 94 3b 38 	call	0x7076	; 0x7076 <strcpy_P>
	}
	
	LCD_WriteStringex (0,0,sXDeg,0==subpage);
    6106:	21 e0       	ldi	r18, 0x01	; 1
    6108:	80 91 2e 05 	lds	r24, 0x052E
    610c:	81 11       	cpse	r24, r1
    610e:	20 e0       	ldi	r18, 0x00	; 0
    6110:	80 e0       	ldi	r24, 0x00	; 0
    6112:	60 e0       	ldi	r22, 0x00	; 0
    6114:	48 ed       	ldi	r20, 0xD8	; 216
    6116:	55 e0       	ldi	r21, 0x05	; 5
    6118:	0e 94 1d 0d 	call	0x1a3a	; 0x1a3a <LCD_WriteStringex>
	LCD_WriteValue(1,30,Config.AccParams[subindex]._P,3,1==subpage);
    611c:	80 91 2f 05 	lds	r24, 0x052F
    6120:	90 e0       	ldi	r25, 0x00	; 0
    6122:	88 0f       	add	r24, r24
    6124:	99 1f       	adc	r25, r25
    6126:	fc 01       	movw	r30, r24
    6128:	33 e0       	ldi	r19, 0x03	; 3
    612a:	ee 0f       	add	r30, r30
    612c:	ff 1f       	adc	r31, r31
    612e:	3a 95       	dec	r19
    6130:	e1 f7       	brne	.-8      	; 0x612a <_hSelfLeveling+0x290>
    6132:	e8 1b       	sub	r30, r24
    6134:	f9 0b       	sbc	r31, r25
    6136:	eb 53       	subi	r30, 0x3B	; 59
    6138:	f9 4f       	sbci	r31, 0xF9	; 249
    613a:	40 ad       	ldd	r20, Z+56	; 0x38
    613c:	51 ad       	ldd	r21, Z+57	; 0x39
    613e:	01 e0       	ldi	r16, 0x01	; 1
    6140:	80 91 2e 05 	lds	r24, 0x052E
    6144:	81 30       	cpi	r24, 0x01	; 1
    6146:	09 f0       	breq	.+2      	; 0x614a <_hSelfLeveling+0x2b0>
    6148:	00 e0       	ldi	r16, 0x00	; 0
    614a:	81 e0       	ldi	r24, 0x01	; 1
    614c:	6e e1       	ldi	r22, 0x1E	; 30
    614e:	23 e0       	ldi	r18, 0x03	; 3
    6150:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <LCD_WriteValue>
	LCD_WriteValue(1,84,Config.AccParams[subindex]._PLimit,3,2==subpage);
    6154:	80 91 2f 05 	lds	r24, 0x052F
    6158:	90 e0       	ldi	r25, 0x00	; 0
    615a:	88 0f       	add	r24, r24
    615c:	99 1f       	adc	r25, r25
    615e:	fc 01       	movw	r30, r24
    6160:	03 e0       	ldi	r16, 0x03	; 3
    6162:	ee 0f       	add	r30, r30
    6164:	ff 1f       	adc	r31, r31
    6166:	0a 95       	dec	r16
    6168:	e1 f7       	brne	.-8      	; 0x6162 <_hSelfLeveling+0x2c8>
    616a:	e8 1b       	sub	r30, r24
    616c:	f9 0b       	sbc	r31, r25
    616e:	eb 53       	subi	r30, 0x3B	; 59
    6170:	f9 4f       	sbci	r31, 0xF9	; 249
    6172:	42 ad       	ldd	r20, Z+58	; 0x3a
    6174:	53 ad       	ldd	r21, Z+59	; 0x3b
    6176:	01 e0       	ldi	r16, 0x01	; 1
    6178:	80 91 2e 05 	lds	r24, 0x052E
    617c:	82 30       	cpi	r24, 0x02	; 2
    617e:	09 f0       	breq	.+2      	; 0x6182 <_hSelfLeveling+0x2e8>
    6180:	00 e0       	ldi	r16, 0x00	; 0
    6182:	81 e0       	ldi	r24, 0x01	; 1
    6184:	64 e5       	ldi	r22, 0x54	; 84
    6186:	23 e0       	ldi	r18, 0x03	; 3
    6188:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <LCD_WriteValue>
	LCD_WriteValue(2,30,Config.AccParams[subindex]._I,3,3==subpage);
    618c:	80 91 2f 05 	lds	r24, 0x052F
    6190:	90 e0       	ldi	r25, 0x00	; 0
    6192:	88 0f       	add	r24, r24
    6194:	99 1f       	adc	r25, r25
    6196:	fc 01       	movw	r30, r24
    6198:	a3 e0       	ldi	r26, 0x03	; 3
    619a:	ee 0f       	add	r30, r30
    619c:	ff 1f       	adc	r31, r31
    619e:	aa 95       	dec	r26
    61a0:	e1 f7       	brne	.-8      	; 0x619a <_hSelfLeveling+0x300>
    61a2:	e8 1b       	sub	r30, r24
    61a4:	f9 0b       	sbc	r31, r25
    61a6:	eb 53       	subi	r30, 0x3B	; 59
    61a8:	f9 4f       	sbci	r31, 0xF9	; 249
    61aa:	44 ad       	ldd	r20, Z+60	; 0x3c
    61ac:	55 ad       	ldd	r21, Z+61	; 0x3d
    61ae:	01 e0       	ldi	r16, 0x01	; 1
    61b0:	80 91 2e 05 	lds	r24, 0x052E
    61b4:	83 30       	cpi	r24, 0x03	; 3
    61b6:	09 f0       	breq	.+2      	; 0x61ba <_hSelfLeveling+0x320>
    61b8:	00 e0       	ldi	r16, 0x00	; 0
    61ba:	82 e0       	ldi	r24, 0x02	; 2
    61bc:	6e e1       	ldi	r22, 0x1E	; 30
    61be:	23 e0       	ldi	r18, 0x03	; 3
    61c0:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <LCD_WriteValue>
	LCD_WriteValue(2,84,Config.AccParams[subindex]._ILimit,3,4==subpage);
    61c4:	80 91 2f 05 	lds	r24, 0x052F
    61c8:	90 e0       	ldi	r25, 0x00	; 0
    61ca:	88 0f       	add	r24, r24
    61cc:	99 1f       	adc	r25, r25
    61ce:	fc 01       	movw	r30, r24
    61d0:	73 e0       	ldi	r23, 0x03	; 3
    61d2:	ee 0f       	add	r30, r30
    61d4:	ff 1f       	adc	r31, r31
    61d6:	7a 95       	dec	r23
    61d8:	e1 f7       	brne	.-8      	; 0x61d2 <_hSelfLeveling+0x338>
    61da:	e8 1b       	sub	r30, r24
    61dc:	f9 0b       	sbc	r31, r25
    61de:	ed 5f       	subi	r30, 0xFD	; 253
    61e0:	f8 4f       	sbci	r31, 0xF8	; 248
    61e2:	40 81       	ld	r20, Z
    61e4:	51 81       	ldd	r21, Z+1	; 0x01
    61e6:	01 e0       	ldi	r16, 0x01	; 1
    61e8:	80 91 2e 05 	lds	r24, 0x052E
    61ec:	84 30       	cpi	r24, 0x04	; 4
    61ee:	09 f0       	breq	.+2      	; 0x61f2 <_hSelfLeveling+0x358>
    61f0:	00 e0       	ldi	r16, 0x00	; 0
    61f2:	82 e0       	ldi	r24, 0x02	; 2
    61f4:	64 e5       	ldi	r22, 0x54	; 84
    61f6:	23 e0       	ldi	r18, 0x03	; 3
    61f8:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <LCD_WriteValue>
	LCD_WriteValue(3,30,Config.AccParams[subindex]._D,3,5==subpage);
    61fc:	80 91 2f 05 	lds	r24, 0x052F
    6200:	90 e0       	ldi	r25, 0x00	; 0
    6202:	88 0f       	add	r24, r24
    6204:	99 1f       	adc	r25, r25
    6206:	fc 01       	movw	r30, r24
    6208:	53 e0       	ldi	r21, 0x03	; 3
    620a:	ee 0f       	add	r30, r30
    620c:	ff 1f       	adc	r31, r31
    620e:	5a 95       	dec	r21
    6210:	e1 f7       	brne	.-8      	; 0x620a <_hSelfLeveling+0x370>
    6212:	e8 1b       	sub	r30, r24
    6214:	f9 0b       	sbc	r31, r25
    6216:	eb 5f       	subi	r30, 0xFB	; 251
    6218:	f8 4f       	sbci	r31, 0xF8	; 248
    621a:	40 81       	ld	r20, Z
    621c:	51 81       	ldd	r21, Z+1	; 0x01
    621e:	01 e0       	ldi	r16, 0x01	; 1
    6220:	80 91 2e 05 	lds	r24, 0x052E
    6224:	85 30       	cpi	r24, 0x05	; 5
    6226:	09 f0       	breq	.+2      	; 0x622a <_hSelfLeveling+0x390>
    6228:	00 e0       	ldi	r16, 0x00	; 0
    622a:	83 e0       	ldi	r24, 0x03	; 3
    622c:	6e e1       	ldi	r22, 0x1E	; 30
    622e:	23 e0       	ldi	r18, 0x03	; 3
    6230:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <LCD_WriteValue>
	LCD_WriteValue(3,84,Config.AccParams[subindex]._DLimit,3,6==subpage);
    6234:	80 91 2f 05 	lds	r24, 0x052F
    6238:	90 e0       	ldi	r25, 0x00	; 0
    623a:	88 0f       	add	r24, r24
    623c:	99 1f       	adc	r25, r25
    623e:	fc 01       	movw	r30, r24
    6240:	33 e0       	ldi	r19, 0x03	; 3
    6242:	ee 0f       	add	r30, r30
    6244:	ff 1f       	adc	r31, r31
    6246:	3a 95       	dec	r19
    6248:	e1 f7       	brne	.-8      	; 0x6242 <_hSelfLeveling+0x3a8>
    624a:	e8 1b       	sub	r30, r24
    624c:	f9 0b       	sbc	r31, r25
    624e:	e9 5f       	subi	r30, 0xF9	; 249
    6250:	f8 4f       	sbci	r31, 0xF8	; 248
    6252:	40 81       	ld	r20, Z
    6254:	51 81       	ldd	r21, Z+1	; 0x01
    6256:	01 e0       	ldi	r16, 0x01	; 1
    6258:	80 91 2e 05 	lds	r24, 0x052E
    625c:	86 30       	cpi	r24, 0x06	; 6
    625e:	09 f0       	breq	.+2      	; 0x6262 <_hSelfLeveling+0x3c8>
    6260:	00 e0       	ldi	r16, 0x00	; 0
    6262:	83 e0       	ldi	r24, 0x03	; 3
    6264:	64 e5       	ldi	r22, 0x54	; 84
    6266:	23 e0       	ldi	r18, 0x03	; 3
    6268:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <LCD_WriteValue>
	LCD_WriteValue(4,84,Config.AccParams[subindex].ComplementaryFilterAlpha,3,7==subpage);
    626c:	80 91 2f 05 	lds	r24, 0x052F
    6270:	90 e0       	ldi	r25, 0x00	; 0
    6272:	88 0f       	add	r24, r24
    6274:	99 1f       	adc	r25, r25
    6276:	fc 01       	movw	r30, r24
    6278:	03 e0       	ldi	r16, 0x03	; 3
    627a:	ee 0f       	add	r30, r30
    627c:	ff 1f       	adc	r31, r31
    627e:	0a 95       	dec	r16
    6280:	e1 f7       	brne	.-8      	; 0x627a <_hSelfLeveling+0x3e0>
    6282:	e8 1b       	sub	r30, r24
    6284:	f9 0b       	sbc	r31, r25
    6286:	e7 5f       	subi	r30, 0xF7	; 247
    6288:	f8 4f       	sbci	r31, 0xF8	; 248
    628a:	40 81       	ld	r20, Z
    628c:	51 81       	ldd	r21, Z+1	; 0x01
    628e:	01 e0       	ldi	r16, 0x01	; 1
    6290:	80 91 2e 05 	lds	r24, 0x052E
    6294:	87 30       	cpi	r24, 0x07	; 7
    6296:	09 f0       	breq	.+2      	; 0x629a <_hSelfLeveling+0x400>
    6298:	00 e0       	ldi	r16, 0x00	; 0
    629a:	84 e0       	ldi	r24, 0x04	; 4
    629c:	64 e5       	ldi	r22, 0x54	; 84
    629e:	23 e0       	ldi	r18, 0x03	; 3
    62a0:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <LCD_WriteValue>
	
}
    62a4:	0f 91       	pop	r16
    62a6:	08 95       	ret

000062a8 <_hStabilization>:

/*
* check : http://code.google.com/p/ardupirates/wiki/PID_Setting_SuperStable_Code
*/ 
void _hStabilization()
{
    62a8:	ef 92       	push	r14
    62aa:	0f 93       	push	r16
	NOKEYRETURN;
    62ac:	80 91 a8 05 	lds	r24, 0x05A8
    62b0:	88 23       	and	r24, r24
    62b2:	09 f4       	brne	.+2      	; 0x62b6 <_hStabilization+0xe>
    62b4:	dd c1       	rjmp	.+954    	; 0x6670 <_hStabilization+0x3c8>
	PageKey(9);
    62b6:	89 e0       	ldi	r24, 0x09	; 9
    62b8:	0e 94 88 2e 	call	0x5d10	; 0x5d10 <PageKey>
	
	if (KEY4)
    62bc:	80 91 a8 05 	lds	r24, 0x05A8
    62c0:	84 ff       	sbrs	r24, 4
    62c2:	bc c0       	rjmp	.+376    	; 0x643c <_hStabilization+0x194>
	{
		if (subpage!=0) bValueChanged = true;
    62c4:	20 91 2e 05 	lds	r18, 0x052E
    62c8:	22 23       	and	r18, r18
    62ca:	19 f0       	breq	.+6      	; 0x62d2 <_hStabilization+0x2a>
    62cc:	81 e0       	ldi	r24, 0x01	; 1
    62ce:	80 93 2a 05 	sts	0x052A, r24
		currentPage.softkeys = _skMENUSAVE;
    62d2:	80 e0       	ldi	r24, 0x00	; 0
    62d4:	9c e0       	ldi	r25, 0x0C	; 12
    62d6:	90 93 31 05 	sts	0x0531, r25
    62da:	80 93 30 05 	sts	0x0530, r24
		
		switch (subpage)
    62de:	24 30       	cpi	r18, 0x04	; 4
    62e0:	09 f4       	brne	.+2      	; 0x62e4 <_hStabilization+0x3c>
    62e2:	54 c0       	rjmp	.+168    	; 0x638c <_hStabilization+0xe4>
    62e4:	25 30       	cpi	r18, 0x05	; 5
    62e6:	50 f4       	brcc	.+20     	; 0x62fc <_hStabilization+0x54>
    62e8:	21 30       	cpi	r18, 0x01	; 1
    62ea:	d1 f0       	breq	.+52     	; 0x6320 <_hStabilization+0x78>
    62ec:	21 30       	cpi	r18, 0x01	; 1
    62ee:	98 f0       	brcs	.+38     	; 0x6316 <_hStabilization+0x6e>
    62f0:	22 30       	cpi	r18, 0x02	; 2
    62f2:	41 f1       	breq	.+80     	; 0x6344 <_hStabilization+0x9c>
    62f4:	23 30       	cpi	r18, 0x03	; 3
    62f6:	09 f0       	breq	.+2      	; 0x62fa <_hStabilization+0x52>
    62f8:	a1 c0       	rjmp	.+322    	; 0x643c <_hStabilization+0x194>
    62fa:	35 c0       	rjmp	.+106    	; 0x6366 <_hStabilization+0xbe>
    62fc:	26 30       	cpi	r18, 0x06	; 6
    62fe:	09 f4       	brne	.+2      	; 0x6302 <_hStabilization+0x5a>
    6300:	67 c0       	rjmp	.+206    	; 0x63d0 <_hStabilization+0x128>
    6302:	26 30       	cpi	r18, 0x06	; 6
    6304:	08 f4       	brcc	.+2      	; 0x6308 <_hStabilization+0x60>
    6306:	53 c0       	rjmp	.+166    	; 0x63ae <_hStabilization+0x106>
    6308:	27 30       	cpi	r18, 0x07	; 7
    630a:	09 f4       	brne	.+2      	; 0x630e <_hStabilization+0x66>
    630c:	76 c0       	rjmp	.+236    	; 0x63fa <_hStabilization+0x152>
    630e:	28 30       	cpi	r18, 0x08	; 8
    6310:	09 f0       	breq	.+2      	; 0x6314 <_hStabilization+0x6c>
    6312:	94 c0       	rjmp	.+296    	; 0x643c <_hStabilization+0x194>
    6314:	8a c0       	rjmp	.+276    	; 0x642a <_hStabilization+0x182>
		{
			case 0: _helper_SwitchPitchRollYaw(&subindex); break;
    6316:	8f e2       	ldi	r24, 0x2F	; 47
    6318:	95 e0       	ldi	r25, 0x05	; 5
    631a:	0e 94 f6 29 	call	0x53ec	; 0x53ec <_helper_SwitchPitchRollYaw>
    631e:	8e c0       	rjmp	.+284    	; 0x643c <_hStabilization+0x194>
			case 1: startEditMode(&(Config.GyroParams[subindex]._P),-500,500,TYPE_INT16); return ;
    6320:	20 91 2f 05 	lds	r18, 0x052F
    6324:	30 e0       	ldi	r19, 0x00	; 0
    6326:	2f 5f       	subi	r18, 0xFF	; 255
    6328:	3f 4f       	sbci	r19, 0xFF	; 255
    632a:	22 0f       	add	r18, r18
    632c:	33 1f       	adc	r19, r19
    632e:	c9 01       	movw	r24, r18
    6330:	63 e0       	ldi	r22, 0x03	; 3
    6332:	88 0f       	add	r24, r24
    6334:	99 1f       	adc	r25, r25
    6336:	6a 95       	dec	r22
    6338:	e1 f7       	brne	.-8      	; 0x6332 <_hStabilization+0x8a>
    633a:	82 1b       	sub	r24, r18
    633c:	93 0b       	sbc	r25, r19
    633e:	8b 53       	subi	r24, 0x3B	; 59
    6340:	99 4f       	sbci	r25, 0xF9	; 249
    6342:	21 c0       	rjmp	.+66     	; 0x6386 <_hStabilization+0xde>
			case 2: startEditMode(&(Config.GyroParams[subindex]._PLimit),0,500,TYPE_INT16); return ;
    6344:	80 91 2f 05 	lds	r24, 0x052F
    6348:	90 e0       	ldi	r25, 0x00	; 0
    634a:	9c 01       	movw	r18, r24
    634c:	22 0f       	add	r18, r18
    634e:	33 1f       	adc	r19, r19
    6350:	c9 01       	movw	r24, r18
    6352:	43 e0       	ldi	r20, 0x03	; 3
    6354:	88 0f       	add	r24, r24
    6356:	99 1f       	adc	r25, r25
    6358:	4a 95       	dec	r20
    635a:	e1 f7       	brne	.-8      	; 0x6354 <_hStabilization+0xac>
    635c:	82 1b       	sub	r24, r18
    635e:	93 0b       	sbc	r25, r19
    6360:	8b 52       	subi	r24, 0x2B	; 43
    6362:	99 4f       	sbci	r25, 0xF9	; 249
    6364:	45 c0       	rjmp	.+138    	; 0x63f0 <_hStabilization+0x148>
			case 3: startEditMode(&(Config.GyroParams[subindex]._I),-500,500,TYPE_INT16);  return ;
    6366:	80 91 2f 05 	lds	r24, 0x052F
    636a:	90 e0       	ldi	r25, 0x00	; 0
    636c:	9c 01       	movw	r18, r24
    636e:	22 0f       	add	r18, r18
    6370:	33 1f       	adc	r19, r19
    6372:	c9 01       	movw	r24, r18
    6374:	03 e0       	ldi	r16, 0x03	; 3
    6376:	88 0f       	add	r24, r24
    6378:	99 1f       	adc	r25, r25
    637a:	0a 95       	dec	r16
    637c:	e1 f7       	brne	.-8      	; 0x6376 <_hStabilization+0xce>
    637e:	82 1b       	sub	r24, r18
    6380:	93 0b       	sbc	r25, r19
    6382:	89 52       	subi	r24, 0x29	; 41
    6384:	99 4f       	sbci	r25, 0xF9	; 249
    6386:	6c e0       	ldi	r22, 0x0C	; 12
    6388:	7e ef       	ldi	r23, 0xFE	; 254
    638a:	34 c0       	rjmp	.+104    	; 0x63f4 <_hStabilization+0x14c>
			case 4: startEditMode(&(Config.GyroParams[subindex]._ILimit),0,500,TYPE_INT16); return ;
    638c:	80 91 2f 05 	lds	r24, 0x052F
    6390:	90 e0       	ldi	r25, 0x00	; 0
    6392:	9c 01       	movw	r18, r24
    6394:	22 0f       	add	r18, r18
    6396:	33 1f       	adc	r19, r19
    6398:	c9 01       	movw	r24, r18
    639a:	a3 e0       	ldi	r26, 0x03	; 3
    639c:	88 0f       	add	r24, r24
    639e:	99 1f       	adc	r25, r25
    63a0:	aa 95       	dec	r26
    63a2:	e1 f7       	brne	.-8      	; 0x639c <_hStabilization+0xf4>
    63a4:	82 1b       	sub	r24, r18
    63a6:	93 0b       	sbc	r25, r19
    63a8:	87 52       	subi	r24, 0x27	; 39
    63aa:	99 4f       	sbci	r25, 0xF9	; 249
    63ac:	21 c0       	rjmp	.+66     	; 0x63f0 <_hStabilization+0x148>
			case 5: startEditMode(&(Config.GyroParams[subindex]._D),-500,500,TYPE_INT16);  return ; 
    63ae:	80 91 2f 05 	lds	r24, 0x052F
    63b2:	90 e0       	ldi	r25, 0x00	; 0
    63b4:	9c 01       	movw	r18, r24
    63b6:	22 0f       	add	r18, r18
    63b8:	33 1f       	adc	r19, r19
    63ba:	c9 01       	movw	r24, r18
    63bc:	e3 e0       	ldi	r30, 0x03	; 3
    63be:	88 0f       	add	r24, r24
    63c0:	99 1f       	adc	r25, r25
    63c2:	ea 95       	dec	r30
    63c4:	e1 f7       	brne	.-8      	; 0x63be <_hStabilization+0x116>
    63c6:	82 1b       	sub	r24, r18
    63c8:	93 0b       	sbc	r25, r19
    63ca:	85 52       	subi	r24, 0x25	; 37
    63cc:	99 4f       	sbci	r25, 0xF9	; 249
    63ce:	db cf       	rjmp	.-74     	; 0x6386 <_hStabilization+0xde>
			case 6: startEditMode(&(Config.GyroParams[subindex]._DLimit),0,500,TYPE_INT16); return ;
    63d0:	80 91 2f 05 	lds	r24, 0x052F
    63d4:	90 e0       	ldi	r25, 0x00	; 0
    63d6:	9c 01       	movw	r18, r24
    63d8:	22 0f       	add	r18, r18
    63da:	33 1f       	adc	r19, r19
    63dc:	c9 01       	movw	r24, r18
    63de:	63 e0       	ldi	r22, 0x03	; 3
    63e0:	88 0f       	add	r24, r24
    63e2:	99 1f       	adc	r25, r25
    63e4:	6a 95       	dec	r22
    63e6:	e1 f7       	brne	.-8      	; 0x63e0 <_hStabilization+0x138>
    63e8:	82 1b       	sub	r24, r18
    63ea:	93 0b       	sbc	r25, r19
    63ec:	83 52       	subi	r24, 0x23	; 35
    63ee:	99 4f       	sbci	r25, 0xF9	; 249
    63f0:	60 e0       	ldi	r22, 0x00	; 0
    63f2:	70 e0       	ldi	r23, 0x00	; 0
    63f4:	44 ef       	ldi	r20, 0xF4	; 244
    63f6:	51 e0       	ldi	r21, 0x01	; 1
    63f8:	14 c0       	rjmp	.+40     	; 0x6422 <_hStabilization+0x17a>
			case 7: startEditMode(&(Config.GyroParams[subindex].ComplementaryFilterAlpha),0,999,TYPE_INT16); return ;
    63fa:	80 91 2f 05 	lds	r24, 0x052F
    63fe:	90 e0       	ldi	r25, 0x00	; 0
    6400:	9c 01       	movw	r18, r24
    6402:	22 0f       	add	r18, r18
    6404:	33 1f       	adc	r19, r19
    6406:	c9 01       	movw	r24, r18
    6408:	43 e0       	ldi	r20, 0x03	; 3
    640a:	88 0f       	add	r24, r24
    640c:	99 1f       	adc	r25, r25
    640e:	4a 95       	dec	r20
    6410:	e1 f7       	brne	.-8      	; 0x640a <_hStabilization+0x162>
    6412:	82 1b       	sub	r24, r18
    6414:	93 0b       	sbc	r25, r19
    6416:	81 52       	subi	r24, 0x21	; 33
    6418:	99 4f       	sbci	r25, 0xF9	; 249
    641a:	60 e0       	ldi	r22, 0x00	; 0
    641c:	70 e0       	ldi	r23, 0x00	; 0
    641e:	47 ee       	ldi	r20, 0xE7	; 231
    6420:	53 e0       	ldi	r21, 0x03	; 3
    6422:	23 e0       	ldi	r18, 0x03	; 3
    6424:	0e 94 3a 2e 	call	0x5c74	; 0x5c74 <startEditMode>
    6428:	23 c1       	rjmp	.+582    	; 0x6670 <_hStabilization+0x3c8>
			case 8: if (Config.ReverseYAW==GYRO_NORMAL) Config.ReverseYAW =GYRO_REVERSE; else Config.ReverseYAW = GYRO_NORMAL; break; // update the UI
    642a:	80 91 7c 07 	lds	r24, 0x077C
    642e:	81 30       	cpi	r24, 0x01	; 1
    6430:	11 f4       	brne	.+4      	; 0x6436 <_hStabilization+0x18e>
    6432:	8f ef       	ldi	r24, 0xFF	; 255
    6434:	01 c0       	rjmp	.+2      	; 0x6438 <_hStabilization+0x190>
    6436:	81 e0       	ldi	r24, 0x01	; 1
    6438:	80 93 7c 07 	sts	0x077C, r24
		}
		
		
	}
	
	if (KEY1)
    643c:	80 91 a8 05 	lds	r24, 0x05A8
    6440:	87 ff       	sbrs	r24, 7
    6442:	0f c0       	rjmp	.+30     	; 0x6462 <_hStabilization+0x1ba>
	{
		if (Config.PitchRollLinked==1)
    6444:	80 91 7d 07 	lds	r24, 0x077D
    6448:	81 30       	cpi	r24, 0x01	; 1
    644a:	49 f4       	brne	.+18     	; 0x645e <_hStabilization+0x1b6>
		{
			memcpy(&(Config.GyroParams[ROLL_INDEX]),&(Config.GyroParams[PITCH_INDEX]), sizeof(pid_param_t));
    644c:	e1 ee       	ldi	r30, 0xE1	; 225
    644e:	f6 e0       	ldi	r31, 0x06	; 6
    6450:	df 01       	movw	r26, r30
    6452:	1e 97       	sbiw	r26, 0x0e	; 14
    6454:	8e e0       	ldi	r24, 0x0E	; 14
    6456:	0d 90       	ld	r0, X+
    6458:	01 92       	st	Z+, r0
    645a:	81 50       	subi	r24, 0x01	; 1
    645c:	e1 f7       	brne	.-8      	; 0x6456 <_hStabilization+0x1ae>
		}
		
		_helper_SaveinEEPROM_ifChanged();
    645e:	0e 94 36 2a 	call	0x546c	; 0x546c <_helper_SaveinEEPROM_ifChanged>
	}
	
	lcdReverse(subpage == 0);
    6462:	81 e0       	ldi	r24, 0x01	; 1
    6464:	90 91 2e 05 	lds	r25, 0x052E
    6468:	91 11       	cpse	r25, r1
    646a:	80 e0       	ldi	r24, 0x00	; 0
    646c:	0e 94 13 0d 	call	0x1a26	; 0x1a26 <lcdReverse>
	_helper_DisplayPitchRollYaw(subindex);
    6470:	80 91 2f 05 	lds	r24, 0x052F
    6474:	0e 94 d3 29 	call	0x53a6	; 0x53a6 <_helper_DisplayPitchRollYaw>
	LCD_WriteString_Pex(5,0,PSTR("                "),16,false);    
    6478:	85 e0       	ldi	r24, 0x05	; 5
    647a:	60 e0       	ldi	r22, 0x00	; 0
    647c:	4b e7       	ldi	r20, 0x7B	; 123
    647e:	5c e0       	ldi	r21, 0x0C	; 12
    6480:	20 e1       	ldi	r18, 0x10	; 16
    6482:	00 e0       	ldi	r16, 0x00	; 0
    6484:	0e 94 8d 0d 	call	0x1b1a	; 0x1b1a <LCD_WriteString_Pex>
	
	if ((subindex==2) && (Config.FrameType == FRAMETYPE_TRICOPTER))
    6488:	80 91 2f 05 	lds	r24, 0x052F
    648c:	82 30       	cpi	r24, 0x02	; 2
    648e:	01 f5       	brne	.+64     	; 0x64d0 <_hStabilization+0x228>
    6490:	80 91 cc 06 	lds	r24, 0x06CC
    6494:	82 30       	cpi	r24, 0x02	; 2
    6496:	e1 f4       	brne	.+56     	; 0x64d0 <_hStabilization+0x228>
	{
		LCD_WriteString_Pex(5,0,PSTR("Reverse GYRO"),12,false);    
    6498:	85 e0       	ldi	r24, 0x05	; 5
    649a:	60 e0       	ldi	r22, 0x00	; 0
    649c:	4e e6       	ldi	r20, 0x6E	; 110
    649e:	5c e0       	ldi	r21, 0x0C	; 12
    64a0:	2c e0       	ldi	r18, 0x0C	; 12
    64a2:	0e 94 8d 0d 	call	0x1b1a	; 0x1b1a <LCD_WriteString_Pex>
		_helper_DisplayBiStateText(5,84 ,PSTR("N"), PSTR("R"), Config.ReverseYAW==GYRO_NORMAL, 8==subpage);
    64a6:	01 e0       	ldi	r16, 0x01	; 1
    64a8:	80 91 7c 07 	lds	r24, 0x077C
    64ac:	81 30       	cpi	r24, 0x01	; 1
    64ae:	09 f0       	breq	.+2      	; 0x64b2 <_hStabilization+0x20a>
    64b0:	00 e0       	ldi	r16, 0x00	; 0
    64b2:	91 e0       	ldi	r25, 0x01	; 1
    64b4:	80 91 2e 05 	lds	r24, 0x052E
    64b8:	88 30       	cpi	r24, 0x08	; 8
    64ba:	09 f0       	breq	.+2      	; 0x64be <_hStabilization+0x216>
    64bc:	90 e0       	ldi	r25, 0x00	; 0
    64be:	85 e0       	ldi	r24, 0x05	; 5
    64c0:	64 e5       	ldi	r22, 0x54	; 84
    64c2:	4c e6       	ldi	r20, 0x6C	; 108
    64c4:	5c e0       	ldi	r21, 0x0C	; 12
    64c6:	2a e6       	ldi	r18, 0x6A	; 106
    64c8:	3c e0       	ldi	r19, 0x0C	; 12
    64ca:	e9 2e       	mov	r14, r25
    64cc:	0e 94 0a 2a 	call	0x5414	; 0x5414 <_helper_DisplayBiStateText>
	}		

	
	LCD_WriteStringex (0,0,sXDeg,0==subpage);
    64d0:	21 e0       	ldi	r18, 0x01	; 1
    64d2:	80 91 2e 05 	lds	r24, 0x052E
    64d6:	81 11       	cpse	r24, r1
    64d8:	20 e0       	ldi	r18, 0x00	; 0
    64da:	80 e0       	ldi	r24, 0x00	; 0
    64dc:	60 e0       	ldi	r22, 0x00	; 0
    64de:	48 ed       	ldi	r20, 0xD8	; 216
    64e0:	55 e0       	ldi	r21, 0x05	; 5
    64e2:	0e 94 1d 0d 	call	0x1a3a	; 0x1a3a <LCD_WriteStringex>
	LCD_WriteValue(1,30,Config.GyroParams[subindex]._P,3,1==subpage);
    64e6:	80 91 2f 05 	lds	r24, 0x052F
    64ea:	90 e0       	ldi	r25, 0x00	; 0
    64ec:	01 96       	adiw	r24, 0x01	; 1
    64ee:	88 0f       	add	r24, r24
    64f0:	99 1f       	adc	r25, r25
    64f2:	fc 01       	movw	r30, r24
    64f4:	03 e0       	ldi	r16, 0x03	; 3
    64f6:	ee 0f       	add	r30, r30
    64f8:	ff 1f       	adc	r31, r31
    64fa:	0a 95       	dec	r16
    64fc:	e1 f7       	brne	.-8      	; 0x64f6 <_hStabilization+0x24e>
    64fe:	e8 1b       	sub	r30, r24
    6500:	f9 0b       	sbc	r31, r25
    6502:	eb 53       	subi	r30, 0x3B	; 59
    6504:	f9 4f       	sbci	r31, 0xF9	; 249
    6506:	40 81       	ld	r20, Z
    6508:	51 81       	ldd	r21, Z+1	; 0x01
    650a:	01 e0       	ldi	r16, 0x01	; 1
    650c:	80 91 2e 05 	lds	r24, 0x052E
    6510:	81 30       	cpi	r24, 0x01	; 1
    6512:	09 f0       	breq	.+2      	; 0x6516 <_hStabilization+0x26e>
    6514:	00 e0       	ldi	r16, 0x00	; 0
    6516:	81 e0       	ldi	r24, 0x01	; 1
    6518:	6e e1       	ldi	r22, 0x1E	; 30
    651a:	23 e0       	ldi	r18, 0x03	; 3
    651c:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <LCD_WriteValue>
	LCD_WriteValue(1,84,Config.GyroParams[subindex]._PLimit,3,2==subpage);
    6520:	80 91 2f 05 	lds	r24, 0x052F
    6524:	90 e0       	ldi	r25, 0x00	; 0
    6526:	88 0f       	add	r24, r24
    6528:	99 1f       	adc	r25, r25
    652a:	fc 01       	movw	r30, r24
    652c:	a3 e0       	ldi	r26, 0x03	; 3
    652e:	ee 0f       	add	r30, r30
    6530:	ff 1f       	adc	r31, r31
    6532:	aa 95       	dec	r26
    6534:	e1 f7       	brne	.-8      	; 0x652e <_hStabilization+0x286>
    6536:	e8 1b       	sub	r30, r24
    6538:	f9 0b       	sbc	r31, r25
    653a:	eb 53       	subi	r30, 0x3B	; 59
    653c:	f9 4f       	sbci	r31, 0xF9	; 249
    653e:	40 89       	ldd	r20, Z+16	; 0x10
    6540:	51 89       	ldd	r21, Z+17	; 0x11
    6542:	01 e0       	ldi	r16, 0x01	; 1
    6544:	80 91 2e 05 	lds	r24, 0x052E
    6548:	82 30       	cpi	r24, 0x02	; 2
    654a:	09 f0       	breq	.+2      	; 0x654e <_hStabilization+0x2a6>
    654c:	00 e0       	ldi	r16, 0x00	; 0
    654e:	81 e0       	ldi	r24, 0x01	; 1
    6550:	64 e5       	ldi	r22, 0x54	; 84
    6552:	23 e0       	ldi	r18, 0x03	; 3
    6554:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <LCD_WriteValue>
	LCD_WriteValue(2,30,Config.GyroParams[subindex]._I,3,3==subpage);
    6558:	80 91 2f 05 	lds	r24, 0x052F
    655c:	90 e0       	ldi	r25, 0x00	; 0
    655e:	88 0f       	add	r24, r24
    6560:	99 1f       	adc	r25, r25
    6562:	fc 01       	movw	r30, r24
    6564:	73 e0       	ldi	r23, 0x03	; 3
    6566:	ee 0f       	add	r30, r30
    6568:	ff 1f       	adc	r31, r31
    656a:	7a 95       	dec	r23
    656c:	e1 f7       	brne	.-8      	; 0x6566 <_hStabilization+0x2be>
    656e:	e8 1b       	sub	r30, r24
    6570:	f9 0b       	sbc	r31, r25
    6572:	eb 53       	subi	r30, 0x3B	; 59
    6574:	f9 4f       	sbci	r31, 0xF9	; 249
    6576:	42 89       	ldd	r20, Z+18	; 0x12
    6578:	53 89       	ldd	r21, Z+19	; 0x13
    657a:	01 e0       	ldi	r16, 0x01	; 1
    657c:	80 91 2e 05 	lds	r24, 0x052E
    6580:	83 30       	cpi	r24, 0x03	; 3
    6582:	09 f0       	breq	.+2      	; 0x6586 <_hStabilization+0x2de>
    6584:	00 e0       	ldi	r16, 0x00	; 0
    6586:	82 e0       	ldi	r24, 0x02	; 2
    6588:	6e e1       	ldi	r22, 0x1E	; 30
    658a:	23 e0       	ldi	r18, 0x03	; 3
    658c:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <LCD_WriteValue>
	LCD_WriteValue(2,84,Config.GyroParams[subindex]._ILimit,3,4==subpage);
    6590:	80 91 2f 05 	lds	r24, 0x052F
    6594:	90 e0       	ldi	r25, 0x00	; 0
    6596:	88 0f       	add	r24, r24
    6598:	99 1f       	adc	r25, r25
    659a:	fc 01       	movw	r30, r24
    659c:	53 e0       	ldi	r21, 0x03	; 3
    659e:	ee 0f       	add	r30, r30
    65a0:	ff 1f       	adc	r31, r31
    65a2:	5a 95       	dec	r21
    65a4:	e1 f7       	brne	.-8      	; 0x659e <_hStabilization+0x2f6>
    65a6:	e8 1b       	sub	r30, r24
    65a8:	f9 0b       	sbc	r31, r25
    65aa:	eb 53       	subi	r30, 0x3B	; 59
    65ac:	f9 4f       	sbci	r31, 0xF9	; 249
    65ae:	44 89       	ldd	r20, Z+20	; 0x14
    65b0:	55 89       	ldd	r21, Z+21	; 0x15
    65b2:	01 e0       	ldi	r16, 0x01	; 1
    65b4:	80 91 2e 05 	lds	r24, 0x052E
    65b8:	84 30       	cpi	r24, 0x04	; 4
    65ba:	09 f0       	breq	.+2      	; 0x65be <_hStabilization+0x316>
    65bc:	00 e0       	ldi	r16, 0x00	; 0
    65be:	82 e0       	ldi	r24, 0x02	; 2
    65c0:	64 e5       	ldi	r22, 0x54	; 84
    65c2:	23 e0       	ldi	r18, 0x03	; 3
    65c4:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <LCD_WriteValue>
	LCD_WriteValue(3,30,Config.GyroParams[subindex]._D,3,5==subpage);
    65c8:	80 91 2f 05 	lds	r24, 0x052F
    65cc:	90 e0       	ldi	r25, 0x00	; 0
    65ce:	88 0f       	add	r24, r24
    65d0:	99 1f       	adc	r25, r25
    65d2:	fc 01       	movw	r30, r24
    65d4:	33 e0       	ldi	r19, 0x03	; 3
    65d6:	ee 0f       	add	r30, r30
    65d8:	ff 1f       	adc	r31, r31
    65da:	3a 95       	dec	r19
    65dc:	e1 f7       	brne	.-8      	; 0x65d6 <_hStabilization+0x32e>
    65de:	e8 1b       	sub	r30, r24
    65e0:	f9 0b       	sbc	r31, r25
    65e2:	eb 53       	subi	r30, 0x3B	; 59
    65e4:	f9 4f       	sbci	r31, 0xF9	; 249
    65e6:	46 89       	ldd	r20, Z+22	; 0x16
    65e8:	57 89       	ldd	r21, Z+23	; 0x17
    65ea:	01 e0       	ldi	r16, 0x01	; 1
    65ec:	80 91 2e 05 	lds	r24, 0x052E
    65f0:	85 30       	cpi	r24, 0x05	; 5
    65f2:	09 f0       	breq	.+2      	; 0x65f6 <_hStabilization+0x34e>
    65f4:	00 e0       	ldi	r16, 0x00	; 0
    65f6:	83 e0       	ldi	r24, 0x03	; 3
    65f8:	6e e1       	ldi	r22, 0x1E	; 30
    65fa:	23 e0       	ldi	r18, 0x03	; 3
    65fc:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <LCD_WriteValue>
	LCD_WriteValue(3,84,Config.GyroParams[subindex]._DLimit,3,6==subpage);
    6600:	80 91 2f 05 	lds	r24, 0x052F
    6604:	90 e0       	ldi	r25, 0x00	; 0
    6606:	88 0f       	add	r24, r24
    6608:	99 1f       	adc	r25, r25
    660a:	fc 01       	movw	r30, r24
    660c:	03 e0       	ldi	r16, 0x03	; 3
    660e:	ee 0f       	add	r30, r30
    6610:	ff 1f       	adc	r31, r31
    6612:	0a 95       	dec	r16
    6614:	e1 f7       	brne	.-8      	; 0x660e <_hStabilization+0x366>
    6616:	e8 1b       	sub	r30, r24
    6618:	f9 0b       	sbc	r31, r25
    661a:	eb 53       	subi	r30, 0x3B	; 59
    661c:	f9 4f       	sbci	r31, 0xF9	; 249
    661e:	40 8d       	ldd	r20, Z+24	; 0x18
    6620:	51 8d       	ldd	r21, Z+25	; 0x19
    6622:	01 e0       	ldi	r16, 0x01	; 1
    6624:	80 91 2e 05 	lds	r24, 0x052E
    6628:	86 30       	cpi	r24, 0x06	; 6
    662a:	09 f0       	breq	.+2      	; 0x662e <_hStabilization+0x386>
    662c:	00 e0       	ldi	r16, 0x00	; 0
    662e:	83 e0       	ldi	r24, 0x03	; 3
    6630:	64 e5       	ldi	r22, 0x54	; 84
    6632:	23 e0       	ldi	r18, 0x03	; 3
    6634:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <LCD_WriteValue>
	LCD_WriteValue(4,84,Config.GyroParams[subindex].ComplementaryFilterAlpha,3,7==subpage);
    6638:	80 91 2f 05 	lds	r24, 0x052F
    663c:	90 e0       	ldi	r25, 0x00	; 0
    663e:	88 0f       	add	r24, r24
    6640:	99 1f       	adc	r25, r25
    6642:	fc 01       	movw	r30, r24
    6644:	a3 e0       	ldi	r26, 0x03	; 3
    6646:	ee 0f       	add	r30, r30
    6648:	ff 1f       	adc	r31, r31
    664a:	aa 95       	dec	r26
    664c:	e1 f7       	brne	.-8      	; 0x6646 <_hStabilization+0x39e>
    664e:	e8 1b       	sub	r30, r24
    6650:	f9 0b       	sbc	r31, r25
    6652:	eb 53       	subi	r30, 0x3B	; 59
    6654:	f9 4f       	sbci	r31, 0xF9	; 249
    6656:	42 8d       	ldd	r20, Z+26	; 0x1a
    6658:	53 8d       	ldd	r21, Z+27	; 0x1b
    665a:	01 e0       	ldi	r16, 0x01	; 1
    665c:	80 91 2e 05 	lds	r24, 0x052E
    6660:	87 30       	cpi	r24, 0x07	; 7
    6662:	09 f0       	breq	.+2      	; 0x6666 <_hStabilization+0x3be>
    6664:	00 e0       	ldi	r16, 0x00	; 0
    6666:	84 e0       	ldi	r24, 0x04	; 4
    6668:	64 e5       	ldi	r22, 0x54	; 84
    666a:	23 e0       	ldi	r18, 0x03	; 3
    666c:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <LCD_WriteValue>
	
	
}
    6670:	0f 91       	pop	r16
    6672:	ef 90       	pop	r14
    6674:	08 95       	ret

00006676 <_hMiscSettings>:
	_helper_DisplayBiStateText(4,84, strYes, strNo, (IS_MISC_SENSOR_SONAR_ENABLED ==true),(subpage==4));
}


void _hMiscSettings()
{
    6676:	cf 92       	push	r12
    6678:	ef 92       	push	r14
    667a:	ff 92       	push	r15
    667c:	0f 93       	push	r16
    667e:	1f 93       	push	r17
	NOKEYRETURN;
    6680:	80 91 a8 05 	lds	r24, 0x05A8
    6684:	88 23       	and	r24, r24
    6686:	09 f4       	brne	.+2      	; 0x668a <_hMiscSettings+0x14>
    6688:	99 c0       	rjmp	.+306    	; 0x67bc <_hMiscSettings+0x146>
	PageKey(5);
    668a:	85 e0       	ldi	r24, 0x05	; 5
    668c:	0e 94 88 2e 	call	0x5d10	; 0x5d10 <PageKey>
	
		
	if (KEY4)
    6690:	20 91 a8 05 	lds	r18, 0x05A8
    6694:	24 ff       	sbrs	r18, 4
    6696:	3f c0       	rjmp	.+126    	; 0x6716 <_hMiscSettings+0xa0>
	{
		bValueChanged = true;
    6698:	81 e0       	ldi	r24, 0x01	; 1
    669a:	80 93 2a 05 	sts	0x052A, r24
		currentPage.softkeys = _skMENUSAVE;
    669e:	80 e0       	ldi	r24, 0x00	; 0
    66a0:	9c e0       	ldi	r25, 0x0C	; 12
    66a2:	90 93 31 05 	sts	0x0531, r25
    66a6:	80 93 30 05 	sts	0x0530, r24
		
		switch (subpage)
    66aa:	80 91 2e 05 	lds	r24, 0x052E
    66ae:	82 30       	cpi	r24, 0x02	; 2
    66b0:	d1 f0       	breq	.+52     	; 0x66e6 <_hMiscSettings+0x70>
    66b2:	83 30       	cpi	r24, 0x03	; 3
    66b4:	28 f4       	brcc	.+10     	; 0x66c0 <_hMiscSettings+0x4a>
    66b6:	88 23       	and	r24, r24
    66b8:	41 f0       	breq	.+16     	; 0x66ca <_hMiscSettings+0x54>
    66ba:	81 30       	cpi	r24, 0x01	; 1
    66bc:	61 f5       	brne	.+88     	; 0x6716 <_hMiscSettings+0xa0>
    66be:	0c c0       	rjmp	.+24     	; 0x66d8 <_hMiscSettings+0x62>
    66c0:	83 30       	cpi	r24, 0x03	; 3
    66c2:	c1 f0       	breq	.+48     	; 0x66f4 <_hMiscSettings+0x7e>
    66c4:	84 30       	cpi	r24, 0x04	; 4
    66c6:	39 f5       	brne	.+78     	; 0x6716 <_hMiscSettings+0xa0>
    66c8:	1f c0       	rjmp	.+62     	; 0x6708 <_hMiscSettings+0x92>
		{
			case 0: startEditMode(&(Config.AutoDisarm),0,10,TYPE_UINT8); return ;
    66ca:	8a ec       	ldi	r24, 0xCA	; 202
    66cc:	96 e0       	ldi	r25, 0x06	; 6
    66ce:	60 e0       	ldi	r22, 0x00	; 0
    66d0:	70 e0       	ldi	r23, 0x00	; 0
    66d2:	4a e0       	ldi	r20, 0x0A	; 10
    66d4:	50 e0       	ldi	r21, 0x00	; 0
    66d6:	14 c0       	rjmp	.+40     	; 0x6700 <_hMiscSettings+0x8a>
			case 1: startEditMode(&(Config.VoltageAlarm),0,100,TYPE_UINT8);  return ;
    66d8:	85 e3       	ldi	r24, 0x35	; 53
    66da:	97 e0       	ldi	r25, 0x07	; 7
    66dc:	60 e0       	ldi	r22, 0x00	; 0
    66de:	70 e0       	ldi	r23, 0x00	; 0
    66e0:	44 e6       	ldi	r20, 0x64	; 100
    66e2:	50 e0       	ldi	r21, 0x00	; 0
    66e4:	0d c0       	rjmp	.+26     	; 0x6700 <_hMiscSettings+0x8a>
			case 2: startEditMode(&(Config.ThrottleMin),0,255,TYPE_UINT8);  return ;
    66e6:	80 ed       	ldi	r24, 0xD0	; 208
    66e8:	96 e0       	ldi	r25, 0x06	; 6
    66ea:	60 e0       	ldi	r22, 0x00	; 0
    66ec:	70 e0       	ldi	r23, 0x00	; 0
    66ee:	4f ef       	ldi	r20, 0xFF	; 255
    66f0:	50 e0       	ldi	r21, 0x00	; 0
    66f2:	06 c0       	rjmp	.+12     	; 0x6700 <_hMiscSettings+0x8a>
			case 3: startEditMode(&(Config.StickScaling),1,20,TYPE_UINT8);  return ;
    66f4:	81 ed       	ldi	r24, 0xD1	; 209
    66f6:	96 e0       	ldi	r25, 0x06	; 6
    66f8:	61 e0       	ldi	r22, 0x01	; 1
    66fa:	70 e0       	ldi	r23, 0x00	; 0
    66fc:	44 e1       	ldi	r20, 0x14	; 20
    66fe:	50 e0       	ldi	r21, 0x00	; 0
    6700:	22 e0       	ldi	r18, 0x02	; 2
    6702:	0e 94 3a 2e 	call	0x5c74	; 0x5c74 <startEditMode>
    6706:	5a c0       	rjmp	.+180    	; 0x67bc <_hMiscSettings+0x146>
			case 4:	Config.PitchRollLinked=  ((~Config.PitchRollLinked) & 0x01); break; 
    6708:	90 91 7d 07 	lds	r25, 0x077D
    670c:	81 e0       	ldi	r24, 0x01	; 1
    670e:	90 fd       	sbrc	r25, 0
    6710:	80 e0       	ldi	r24, 0x00	; 0
    6712:	80 93 7d 07 	sts	0x077D, r24
		}
		
	}
	
	if (KEY1)
    6716:	27 ff       	sbrs	r18, 7
    6718:	02 c0       	rjmp	.+4      	; 0x671e <_hMiscSettings+0xa8>
	{
		_helper_SaveinEEPROM_ifChanged();
    671a:	0e 94 36 2a 	call	0x546c	; 0x546c <_helper_SaveinEEPROM_ifChanged>
	}
	
	LCD_WriteValue(0,84,Config.AutoDisarm,3,0==subpage);
    671e:	40 91 ca 06 	lds	r20, 0x06CA
    6722:	01 e0       	ldi	r16, 0x01	; 1
    6724:	80 91 2e 05 	lds	r24, 0x052E
    6728:	81 11       	cpse	r24, r1
    672a:	00 e0       	ldi	r16, 0x00	; 0
    672c:	80 e0       	ldi	r24, 0x00	; 0
    672e:	64 e5       	ldi	r22, 0x54	; 84
    6730:	50 e0       	ldi	r21, 0x00	; 0
    6732:	23 e0       	ldi	r18, 0x03	; 3
    6734:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <LCD_WriteValue>
	LCD_WriteValue(1,84,Config.VoltageAlarm,3,1==subpage);
    6738:	40 91 35 07 	lds	r20, 0x0735
    673c:	01 e0       	ldi	r16, 0x01	; 1
    673e:	80 91 2e 05 	lds	r24, 0x052E
    6742:	81 30       	cpi	r24, 0x01	; 1
    6744:	09 f0       	breq	.+2      	; 0x6748 <_hMiscSettings+0xd2>
    6746:	00 e0       	ldi	r16, 0x00	; 0
    6748:	81 e0       	ldi	r24, 0x01	; 1
    674a:	64 e5       	ldi	r22, 0x54	; 84
    674c:	50 e0       	ldi	r21, 0x00	; 0
    674e:	23 e0       	ldi	r18, 0x03	; 3
    6750:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <LCD_WriteValue>
	LCD_WriteValue(2,84,Config.ThrottleMin,3,2==subpage);
    6754:	40 91 d0 06 	lds	r20, 0x06D0
    6758:	01 e0       	ldi	r16, 0x01	; 1
    675a:	80 91 2e 05 	lds	r24, 0x052E
    675e:	82 30       	cpi	r24, 0x02	; 2
    6760:	09 f0       	breq	.+2      	; 0x6764 <_hMiscSettings+0xee>
    6762:	00 e0       	ldi	r16, 0x00	; 0
    6764:	82 e0       	ldi	r24, 0x02	; 2
    6766:	64 e5       	ldi	r22, 0x54	; 84
    6768:	50 e0       	ldi	r21, 0x00	; 0
    676a:	23 e0       	ldi	r18, 0x03	; 3
    676c:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <LCD_WriteValue>
	LCD_WriteValue(3,84,Config.StickScaling,3,3==subpage);
    6770:	40 91 d1 06 	lds	r20, 0x06D1
    6774:	01 e0       	ldi	r16, 0x01	; 1
    6776:	80 91 2e 05 	lds	r24, 0x052E
    677a:	83 30       	cpi	r24, 0x03	; 3
    677c:	09 f0       	breq	.+2      	; 0x6780 <_hMiscSettings+0x10a>
    677e:	00 e0       	ldi	r16, 0x00	; 0
    6780:	83 e0       	ldi	r24, 0x03	; 3
    6782:	64 e5       	ldi	r22, 0x54	; 84
    6784:	50 e0       	ldi	r21, 0x00	; 0
    6786:	23 e0       	ldi	r18, 0x03	; 3
    6788:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <LCD_WriteValue>
	_helper_Words (4,84,(4==subpage),(Config.PitchRollLinked),PSTR("yes"),PSTR("no "),5);
    678c:	41 e0       	ldi	r20, 0x01	; 1
    678e:	80 91 2e 05 	lds	r24, 0x052E
    6792:	84 30       	cpi	r24, 0x04	; 4
    6794:	09 f0       	breq	.+2      	; 0x6798 <_hMiscSettings+0x122>
    6796:	40 e0       	ldi	r20, 0x00	; 0
    6798:	21 e0       	ldi	r18, 0x01	; 1
    679a:	80 91 7d 07 	lds	r24, 0x077D
    679e:	88 23       	and	r24, r24
    67a0:	09 f4       	brne	.+2      	; 0x67a4 <_hMiscSettings+0x12e>
    67a2:	20 e0       	ldi	r18, 0x00	; 0
    67a4:	84 e0       	ldi	r24, 0x04	; 4
    67a6:	64 e5       	ldi	r22, 0x54	; 84
    67a8:	00 e9       	ldi	r16, 0x90	; 144
    67aa:	1c e0       	ldi	r17, 0x0C	; 12
    67ac:	fc e8       	ldi	r31, 0x8C	; 140
    67ae:	ef 2e       	mov	r14, r31
    67b0:	fc e0       	ldi	r31, 0x0C	; 12
    67b2:	ff 2e       	mov	r15, r31
    67b4:	e5 e0       	ldi	r30, 0x05	; 5
    67b6:	ce 2e       	mov	r12, r30
    67b8:	0e 94 43 2c 	call	0x5886	; 0x5886 <_helper_Words>
	
		
}
    67bc:	1f 91       	pop	r17
    67be:	0f 91       	pop	r16
    67c0:	ff 90       	pop	r15
    67c2:	ef 90       	pop	r14
    67c4:	cf 90       	pop	r12
    67c6:	08 95       	ret

000067c8 <_hModeSettings>:
	
}

bool bNeedRestart=false;
void _hModeSettings ()
{
    67c8:	cf 92       	push	r12
    67ca:	ef 92       	push	r14
    67cc:	ff 92       	push	r15
    67ce:	0f 93       	push	r16
    67d0:	1f 93       	push	r17
	NOKEYRETURN;
    67d2:	80 91 a8 05 	lds	r24, 0x05A8
    67d6:	88 23       	and	r24, r24
    67d8:	09 f4       	brne	.+2      	; 0x67dc <_hModeSettings+0x14>
    67da:	db c0       	rjmp	.+438    	; 0x6992 <_hModeSettings+0x1ca>
	PageKey(5);
    67dc:	85 e0       	ldi	r24, 0x05	; 5
    67de:	0e 94 88 2e 	call	0x5d10	; 0x5d10 <PageKey>
	
	if ((KEY1) && (bValueChanged==true))
    67e2:	80 91 a8 05 	lds	r24, 0x05A8
    67e6:	87 ff       	sbrs	r24, 7
    67e8:	0f c0       	rjmp	.+30     	; 0x6808 <_hModeSettings+0x40>
    67ea:	90 91 2a 05 	lds	r25, 0x052A
    67ee:	91 30       	cpi	r25, 0x01	; 1
    67f0:	59 f4       	brne	.+22     	; 0x6808 <_hModeSettings+0x40>
	{
		_helper_SaveinEEPROM_ifChanged();
    67f2:	0e 94 36 2a 	call	0x546c	; 0x546c <_helper_SaveinEEPROM_ifChanged>
		if (bNeedRestart==true) Menu_LoadPage(PAGE_RESTART);
    67f6:	80 91 2b 05 	lds	r24, 0x052B
    67fa:	88 23       	and	r24, r24
    67fc:	09 f4       	brne	.+2      	; 0x6800 <_hModeSettings+0x38>
    67fe:	c9 c0       	rjmp	.+402    	; 0x6992 <_hModeSettings+0x1ca>
    6800:	84 e0       	ldi	r24, 0x04	; 4
    6802:	0e 94 59 2c 	call	0x58b2	; 0x58b2 <Menu_LoadPage>
    6806:	c5 c0       	rjmp	.+394    	; 0x6992 <_hModeSettings+0x1ca>
		return;
	}
	
	if (KEY4)
    6808:	84 ff       	sbrs	r24, 4
    680a:	3d c0       	rjmp	.+122    	; 0x6886 <_hModeSettings+0xbe>
	{
		bValueChanged = true;
    680c:	91 e0       	ldi	r25, 0x01	; 1
    680e:	90 93 2a 05 	sts	0x052A, r25
		//currentPage.softkeys = _skMENUSAVE;
		switch (subpage)
    6812:	80 91 2e 05 	lds	r24, 0x052E
    6816:	82 30       	cpi	r24, 0x02	; 2
    6818:	f9 f0       	breq	.+62     	; 0x6858 <_hModeSettings+0x90>
    681a:	83 30       	cpi	r24, 0x03	; 3
    681c:	28 f4       	brcc	.+10     	; 0x6828 <_hModeSettings+0x60>
    681e:	88 23       	and	r24, r24
    6820:	41 f0       	breq	.+16     	; 0x6832 <_hModeSettings+0x6a>
    6822:	81 30       	cpi	r24, 0x01	; 1
    6824:	81 f5       	brne	.+96     	; 0x6886 <_hModeSettings+0xbe>
    6826:	10 c0       	rjmp	.+32     	; 0x6848 <_hModeSettings+0x80>
    6828:	83 30       	cpi	r24, 0x03	; 3
    682a:	f1 f0       	breq	.+60     	; 0x6868 <_hModeSettings+0xa0>
    682c:	84 30       	cpi	r24, 0x04	; 4
    682e:	59 f5       	brne	.+86     	; 0x6886 <_hModeSettings+0xbe>
    6830:	23 c0       	rjmp	.+70     	; 0x6878 <_hModeSettings+0xb0>
		{
			case 0: if (Config.FrameType==FRAMETYPE_QUADCOPTER) Config.FrameType=FRAMETYPE_TRICOPTER; else Config.FrameType=FRAMETYPE_QUADCOPTER; break;
    6832:	80 91 cc 06 	lds	r24, 0x06CC
    6836:	81 30       	cpi	r24, 0x01	; 1
    6838:	21 f4       	brne	.+8      	; 0x6842 <_hModeSettings+0x7a>
    683a:	82 e0       	ldi	r24, 0x02	; 2
    683c:	80 93 cc 06 	sts	0x06CC, r24
    6840:	22 c0       	rjmp	.+68     	; 0x6886 <_hModeSettings+0xbe>
    6842:	90 93 cc 06 	sts	0x06CC, r25
    6846:	1f c0       	rjmp	.+62     	; 0x6886 <_hModeSettings+0xbe>
			case 1: Config.RX_mode=~Config.RX_mode; bNeedRestart = true; break;
    6848:	90 91 c7 06 	lds	r25, 0x06C7
    684c:	90 95       	com	r25
    684e:	90 93 c7 06 	sts	0x06C7, r25
    6852:	80 93 2b 05 	sts	0x052B, r24
    6856:	17 c0       	rjmp	.+46     	; 0x6886 <_hModeSettings+0xbe>
			case 2: Config.BoardOrientationMode=((~Config.BoardOrientationMode) & 0x01); /* value either 0 or 1*/break;
    6858:	90 91 cd 06 	lds	r25, 0x06CD
    685c:	81 e0       	ldi	r24, 0x01	; 1
    685e:	90 fd       	sbrc	r25, 0
    6860:	80 e0       	ldi	r24, 0x00	; 0
    6862:	80 93 cd 06 	sts	0x06CD, r24
    6866:	0f c0       	rjmp	.+30     	; 0x6886 <_hModeSettings+0xbe>
			case 3: Config.QuadFlyingMode = ((~Config.QuadFlyingMode) & 0x01); /* value either 0 or 1*/break;
    6868:	90 91 ce 06 	lds	r25, 0x06CE
    686c:	81 e0       	ldi	r24, 0x01	; 1
    686e:	90 fd       	sbrc	r25, 0
    6870:	80 e0       	ldi	r24, 0x00	; 0
    6872:	80 93 ce 06 	sts	0x06CE, r24
    6876:	07 c0       	rjmp	.+14     	; 0x6886 <_hModeSettings+0xbe>
			case 4: Config.MiscSensors =  ((~Config.MiscSensors) & 0x01); break; // this condition should be rewritten if another sensor is added.
    6878:	90 91 d2 06 	lds	r25, 0x06D2
    687c:	81 e0       	ldi	r24, 0x01	; 1
    687e:	90 fd       	sbrc	r25, 0
    6880:	80 e0       	ldi	r24, 0x00	; 0
    6882:	80 93 d2 06 	sts	0x06D2, r24
		}
	}
	
	_helper_Words  (0,84,(subpage==0),(Config.FrameType== FRAMETYPE_QUADCOPTER),PSTR("Quad"),PSTR("TRI "),5);
    6886:	41 e0       	ldi	r20, 0x01	; 1
    6888:	80 91 2e 05 	lds	r24, 0x052E
    688c:	81 11       	cpse	r24, r1
    688e:	40 e0       	ldi	r20, 0x00	; 0
    6890:	21 e0       	ldi	r18, 0x01	; 1
    6892:	80 91 cc 06 	lds	r24, 0x06CC
    6896:	81 30       	cpi	r24, 0x01	; 1
    6898:	09 f0       	breq	.+2      	; 0x689c <_hModeSettings+0xd4>
    689a:	20 e0       	ldi	r18, 0x00	; 0
    689c:	80 e0       	ldi	r24, 0x00	; 0
    689e:	64 e5       	ldi	r22, 0x54	; 84
    68a0:	07 ed       	ldi	r16, 0xD7	; 215
    68a2:	1c e0       	ldi	r17, 0x0C	; 12
    68a4:	a2 ed       	ldi	r26, 0xD2	; 210
    68a6:	ea 2e       	mov	r14, r26
    68a8:	ac e0       	ldi	r26, 0x0C	; 12
    68aa:	fa 2e       	mov	r15, r26
    68ac:	f5 e0       	ldi	r31, 0x05	; 5
    68ae:	cf 2e       	mov	r12, r31
    68b0:	0e 94 43 2c 	call	0x5886	; 0x5886 <_helper_Words>
	_helper_Words  (1,84,(subpage==1),(Config.RX_mode== RX_mode_BuddyMode),PSTR("Buddy"),PSTR("UART "),5);
    68b4:	41 e0       	ldi	r20, 0x01	; 1
    68b6:	80 91 2e 05 	lds	r24, 0x052E
    68ba:	81 30       	cpi	r24, 0x01	; 1
    68bc:	09 f0       	breq	.+2      	; 0x68c0 <_hModeSettings+0xf8>
    68be:	40 e0       	ldi	r20, 0x00	; 0
    68c0:	21 e0       	ldi	r18, 0x01	; 1
    68c2:	80 91 c7 06 	lds	r24, 0x06C7
    68c6:	81 11       	cpse	r24, r1
    68c8:	20 e0       	ldi	r18, 0x00	; 0
    68ca:	81 e0       	ldi	r24, 0x01	; 1
    68cc:	64 e5       	ldi	r22, 0x54	; 84
    68ce:	0c ec       	ldi	r16, 0xCC	; 204
    68d0:	1c e0       	ldi	r17, 0x0C	; 12
    68d2:	e6 ec       	ldi	r30, 0xC6	; 198
    68d4:	ee 2e       	mov	r14, r30
    68d6:	ec e0       	ldi	r30, 0x0C	; 12
    68d8:	fe 2e       	mov	r15, r30
    68da:	75 e0       	ldi	r23, 0x05	; 5
    68dc:	c7 2e       	mov	r12, r23
    68de:	0e 94 43 2c 	call	0x5886	; 0x5886 <_helper_Words>
	_helper_Words (2,84,(subpage==2),(Config.BoardOrientationMode == QuadFlyingMode_PLUS),PSTR("+ Quad"),PSTR("X Quad"),6);
    68e2:	41 e0       	ldi	r20, 0x01	; 1
    68e4:	80 91 2e 05 	lds	r24, 0x052E
    68e8:	82 30       	cpi	r24, 0x02	; 2
    68ea:	09 f0       	breq	.+2      	; 0x68ee <_hModeSettings+0x126>
    68ec:	40 e0       	ldi	r20, 0x00	; 0
    68ee:	21 e0       	ldi	r18, 0x01	; 1
    68f0:	80 91 cd 06 	lds	r24, 0x06CD
    68f4:	81 11       	cpse	r24, r1
    68f6:	20 e0       	ldi	r18, 0x00	; 0
    68f8:	82 e0       	ldi	r24, 0x02	; 2
    68fa:	64 e5       	ldi	r22, 0x54	; 84
    68fc:	0f eb       	ldi	r16, 0xBF	; 191
    68fe:	1c e0       	ldi	r17, 0x0C	; 12
    6900:	58 eb       	ldi	r21, 0xB8	; 184
    6902:	e5 2e       	mov	r14, r21
    6904:	5c e0       	ldi	r21, 0x0C	; 12
    6906:	f5 2e       	mov	r15, r21
    6908:	36 e0       	ldi	r19, 0x06	; 6
    690a:	c3 2e       	mov	r12, r19
    690c:	0e 94 43 2c 	call	0x5886	; 0x5886 <_helper_Words>
	if (Config.FrameType == FRAMETYPE_QUADCOPTER)
    6910:	90 91 cc 06 	lds	r25, 0x06CC
    6914:	80 91 2e 05 	lds	r24, 0x052E
    6918:	91 30       	cpi	r25, 0x01	; 1
    691a:	91 f4       	brne	.+36     	; 0x6940 <_hModeSettings+0x178>
	{
		_helper_Words (3,84,(subpage==3),(Config.QuadFlyingMode == QuadFlyingMode_PLUS),PSTR("+ Quad"),PSTR("X Quad"),6);
    691c:	41 e0       	ldi	r20, 0x01	; 1
    691e:	83 30       	cpi	r24, 0x03	; 3
    6920:	09 f0       	breq	.+2      	; 0x6924 <_hModeSettings+0x15c>
    6922:	40 e0       	ldi	r20, 0x00	; 0
    6924:	21 e0       	ldi	r18, 0x01	; 1
    6926:	80 91 ce 06 	lds	r24, 0x06CE
    692a:	81 11       	cpse	r24, r1
    692c:	20 e0       	ldi	r18, 0x00	; 0
    692e:	83 e0       	ldi	r24, 0x03	; 3
    6930:	64 e5       	ldi	r22, 0x54	; 84
    6932:	01 eb       	ldi	r16, 0xB1	; 177
    6934:	1c e0       	ldi	r17, 0x0C	; 12
    6936:	9a ea       	ldi	r25, 0xAA	; 170
    6938:	e9 2e       	mov	r14, r25
    693a:	9c e0       	ldi	r25, 0x0C	; 12
    693c:	f9 2e       	mov	r15, r25
    693e:	11 c0       	rjmp	.+34     	; 0x6962 <_hModeSettings+0x19a>
	}
	else
	{
		_helper_Words (3,84,(subpage==3),(Config.QuadFlyingMode == QuadFlyingMode_PLUS),PSTR("Y Tri "),PSTR("A Tri "),6);
    6940:	41 e0       	ldi	r20, 0x01	; 1
    6942:	83 30       	cpi	r24, 0x03	; 3
    6944:	09 f0       	breq	.+2      	; 0x6948 <_hModeSettings+0x180>
    6946:	40 e0       	ldi	r20, 0x00	; 0
    6948:	21 e0       	ldi	r18, 0x01	; 1
    694a:	80 91 ce 06 	lds	r24, 0x06CE
    694e:	81 11       	cpse	r24, r1
    6950:	20 e0       	ldi	r18, 0x00	; 0
    6952:	83 e0       	ldi	r24, 0x03	; 3
    6954:	64 e5       	ldi	r22, 0x54	; 84
    6956:	03 ea       	ldi	r16, 0xA3	; 163
    6958:	1c e0       	ldi	r17, 0x0C	; 12
    695a:	bc e9       	ldi	r27, 0x9C	; 156
    695c:	eb 2e       	mov	r14, r27
    695e:	bc e0       	ldi	r27, 0x0C	; 12
    6960:	fb 2e       	mov	r15, r27
    6962:	a6 e0       	ldi	r26, 0x06	; 6
    6964:	ca 2e       	mov	r12, r26
    6966:	0e 94 43 2c 	call	0x5886	; 0x5886 <_helper_Words>
	}	
	_helper_DisplayBiStateText(4,84, strYes, strNo, (IS_MISC_SENSOR_SONAR_ENABLED ==true),(subpage==4));
    696a:	00 91 d2 06 	lds	r16, 0x06D2
    696e:	10 e0       	ldi	r17, 0x00	; 0
    6970:	01 70       	andi	r16, 0x01	; 1
    6972:	10 70       	andi	r17, 0x00	; 0
    6974:	91 e0       	ldi	r25, 0x01	; 1
    6976:	80 91 2e 05 	lds	r24, 0x052E
    697a:	84 30       	cpi	r24, 0x04	; 4
    697c:	09 f0       	breq	.+2      	; 0x6980 <_hModeSettings+0x1b8>
    697e:	90 e0       	ldi	r25, 0x00	; 0
    6980:	84 e0       	ldi	r24, 0x04	; 4
    6982:	64 e5       	ldi	r22, 0x54	; 84
    6984:	44 e9       	ldi	r20, 0x94	; 148
    6986:	5c e0       	ldi	r21, 0x0C	; 12
    6988:	28 e9       	ldi	r18, 0x98	; 152
    698a:	3c e0       	ldi	r19, 0x0C	; 12
    698c:	e9 2e       	mov	r14, r25
    698e:	0e 94 0a 2a 	call	0x5414	; 0x5414 <_helper_DisplayBiStateText>
}
    6992:	1f 91       	pop	r17
    6994:	0f 91       	pop	r16
    6996:	ff 90       	pop	r15
    6998:	ef 90       	pop	r14
    699a:	cf 90       	pop	r12
    699c:	08 95       	ret

0000699e <doMenu>:

/*
//	Draw the menu
*/
uint8_t doMenu(menu_t *menu)
{
    699e:	ef 92       	push	r14
    69a0:	ff 92       	push	r15
    69a2:	0f 93       	push	r16
    69a4:	1f 93       	push	r17
    69a6:	cf 93       	push	r28
    69a8:	df 93       	push	r29
    69aa:	ec 01       	movw	r28, r24
	UIEnableStickCommands=true;
    69ac:	81 e0       	ldi	r24, 0x01	; 1
    69ae:	80 93 d3 05 	sts	0x05D3, r24
	
	if (!_mykey) return 0;
    69b2:	80 91 a8 05 	lds	r24, 0x05A8
    69b6:	88 23       	and	r24, r24
    69b8:	09 f4       	brne	.+2      	; 0x69bc <doMenu+0x1e>
    69ba:	70 c0       	rjmp	.+224    	; 0x6a9c <doMenu+0xfe>
	
	// key handling
	if (KEY2)		// UP
    69bc:	86 ff       	sbrs	r24, 6
    69be:	06 c0       	rjmp	.+12     	; 0x69cc <doMenu+0x2e>
	{
		if (menu->marked > 0) 
    69c0:	8c 81       	ldd	r24, Y+4	; 0x04
    69c2:	88 23       	and	r24, r24
    69c4:	99 f0       	breq	.+38     	; 0x69ec <doMenu+0x4e>
			menu->marked--;
    69c6:	81 50       	subi	r24, 0x01	; 1
    69c8:	8c 83       	std	Y+4, r24	; 0x04
    69ca:	10 c0       	rjmp	.+32     	; 0x69ec <doMenu+0x4e>
	}
	else if (KEY3)		// DOWN
    69cc:	85 ff       	sbrs	r24, 5
    69ce:	0c c0       	rjmp	.+24     	; 0x69e8 <doMenu+0x4a>
	{
		if (menu->marked < menu->len - 1) 
    69d0:	4c 81       	ldd	r20, Y+4	; 0x04
    69d2:	24 2f       	mov	r18, r20
    69d4:	30 e0       	ldi	r19, 0x00	; 0
    69d6:	88 81       	ld	r24, Y
    69d8:	90 e0       	ldi	r25, 0x00	; 0
    69da:	01 97       	sbiw	r24, 0x01	; 1
    69dc:	28 17       	cp	r18, r24
    69de:	39 07       	cpc	r19, r25
    69e0:	2c f4       	brge	.+10     	; 0x69ec <doMenu+0x4e>
			menu->marked++;
    69e2:	4f 5f       	subi	r20, 0xFF	; 255
    69e4:	4c 83       	std	Y+4, r20	; 0x04
    69e6:	02 c0       	rjmp	.+4      	; 0x69ec <doMenu+0x4e>
	}
	else if (KEY4)		// ENTER
    69e8:	84 fd       	sbrc	r24, 4
    69ea:	56 c0       	rjmp	.+172    	; 0x6a98 <doMenu+0xfa>
		return 1;

	if (menu->marked < menu->top)
    69ec:	2c 81       	ldd	r18, Y+4	; 0x04
    69ee:	3b 81       	ldd	r19, Y+3	; 0x03
    69f0:	23 17       	cp	r18, r19
    69f2:	40 f0       	brcs	.+16     	; 0x6a04 <doMenu+0x66>
		menu->top = menu->marked;
	else if (menu->marked - menu->top >= 5)
    69f4:	82 2f       	mov	r24, r18
    69f6:	90 e0       	ldi	r25, 0x00	; 0
    69f8:	83 1b       	sub	r24, r19
    69fa:	91 09       	sbc	r25, r1
    69fc:	85 30       	cpi	r24, 0x05	; 5
    69fe:	91 05       	cpc	r25, r1
    6a00:	14 f0       	brlt	.+4      	; 0x6a06 <doMenu+0x68>
		menu->top = menu->marked - 4;
    6a02:	24 50       	subi	r18, 0x04	; 4
    6a04:	2b 83       	std	Y+3, r18	; 0x03
	
	// text output
	LCD_SetPos(0, 58);
    6a06:	80 e0       	ldi	r24, 0x00	; 0
    6a08:	6a e3       	ldi	r22, 0x3A	; 58
    6a0a:	0e 94 08 0c 	call	0x1810	; 0x1810 <LCD_SetPos>
	if (menu->top > 0)
    6a0e:	8b 81       	ldd	r24, Y+3	; 0x03
    6a10:	88 23       	and	r24, r24
    6a12:	29 f0       	breq	.+10     	; 0x6a1e <doMenu+0x80>
		lcdWriteGlyph_P(&glyArrowUp, 0);
    6a14:	85 e9       	ldi	r24, 0x95	; 149
    6a16:	99 e0       	ldi	r25, 0x09	; 9
    6a18:	60 e0       	ldi	r22, 0x00	; 0
    6a1a:	0e 94 c8 0c 	call	0x1990	; 0x1990 <lcdWriteGlyph_P>

/*
//	Draw the menu
*/
uint8_t doMenu(menu_t *menu)
{
    6a1e:	00 e0       	ldi	r16, 0x00	; 0
    6a20:	10 e0       	ldi	r17, 0x00	; 0
    6a22:	21 c0       	rjmp	.+66     	; 0x6a66 <doMenu+0xc8>
	if (menu->top > 0)
		lcdWriteGlyph_P(&glyArrowUp, 0);
		
	for (uint8_t i = 0; i < 5 && i < menu->len; i++)
	{
		LCD_SetPos(i + 1, 0);
    6a24:	8e 2d       	mov	r24, r14
    6a26:	8f 5f       	subi	r24, 0xFF	; 255
    6a28:	60 e0       	ldi	r22, 0x00	; 0
    6a2a:	0e 94 08 0c 	call	0x1810	; 0x1810 <LCD_SetPos>
		PGM_P item = menu->textSelector(menu->top + i);
    6a2e:	8b 81       	ldd	r24, Y+3	; 0x03
    6a30:	e9 81       	ldd	r30, Y+1	; 0x01
    6a32:	fa 81       	ldd	r31, Y+2	; 0x02
    6a34:	8e 0d       	add	r24, r14
    6a36:	09 95       	icall
    6a38:	7c 01       	movw	r14, r24
		lcdReverse(menu->top + i == menu->marked);
    6a3a:	8b 81       	ldd	r24, Y+3	; 0x03
    6a3c:	a8 01       	movw	r20, r16
    6a3e:	48 0f       	add	r20, r24
    6a40:	51 1d       	adc	r21, r1
    6a42:	2c 81       	ldd	r18, Y+4	; 0x04
    6a44:	30 e0       	ldi	r19, 0x00	; 0
    6a46:	81 e0       	ldi	r24, 0x01	; 1
    6a48:	42 17       	cp	r20, r18
    6a4a:	53 07       	cpc	r21, r19
    6a4c:	09 f0       	breq	.+2      	; 0x6a50 <doMenu+0xb2>
    6a4e:	80 e0       	ldi	r24, 0x00	; 0
    6a50:	0e 94 13 0d 	call	0x1a26	; 0x1a26 <lcdReverse>
		LCD_WritePadded_P(item, 21);
    6a54:	c7 01       	movw	r24, r14
    6a56:	65 e1       	ldi	r22, 0x15	; 21
    6a58:	0e 94 74 0d 	call	0x1ae8	; 0x1ae8 <LCD_WritePadded_P>
    6a5c:	0f 5f       	subi	r16, 0xFF	; 255
    6a5e:	1f 4f       	sbci	r17, 0xFF	; 255
	// text output
	LCD_SetPos(0, 58);
	if (menu->top > 0)
		lcdWriteGlyph_P(&glyArrowUp, 0);
		
	for (uint8_t i = 0; i < 5 && i < menu->len; i++)
    6a60:	05 30       	cpi	r16, 0x05	; 5
    6a62:	11 05       	cpc	r17, r1
    6a64:	21 f0       	breq	.+8      	; 0x6a6e <doMenu+0xd0>
    6a66:	e0 2e       	mov	r14, r16
    6a68:	88 81       	ld	r24, Y
    6a6a:	08 17       	cp	r16, r24
    6a6c:	d8 f2       	brcs	.-74     	; 0x6a24 <doMenu+0x86>
		PGM_P item = menu->textSelector(menu->top + i);
		lcdReverse(menu->top + i == menu->marked);
		LCD_WritePadded_P(item, 21);
	}

	lcdReverse(0);
    6a6e:	80 e0       	ldi	r24, 0x00	; 0
    6a70:	0e 94 13 0d 	call	0x1a26	; 0x1a26 <lcdReverse>


	LCD_SetPos(6, 58);
    6a74:	86 e0       	ldi	r24, 0x06	; 6
    6a76:	6a e3       	ldi	r22, 0x3A	; 58
    6a78:	0e 94 08 0c 	call	0x1810	; 0x1810 <LCD_SetPos>
	if (menu->top < menu->len - 5)
    6a7c:	2b 81       	ldd	r18, Y+3	; 0x03
    6a7e:	30 e0       	ldi	r19, 0x00	; 0
    6a80:	88 81       	ld	r24, Y
    6a82:	90 e0       	ldi	r25, 0x00	; 0
    6a84:	05 97       	sbiw	r24, 0x05	; 5
    6a86:	28 17       	cp	r18, r24
    6a88:	39 07       	cpc	r19, r25
    6a8a:	44 f4       	brge	.+16     	; 0x6a9c <doMenu+0xfe>
		lcdWriteGlyph_P(&glyArrowDown, 0);
    6a8c:	8f e9       	ldi	r24, 0x9F	; 159
    6a8e:	99 e0       	ldi	r25, 0x09	; 9
    6a90:	60 e0       	ldi	r22, 0x00	; 0
    6a92:	0e 94 c8 0c 	call	0x1990	; 0x1990 <lcdWriteGlyph_P>
    6a96:	02 c0       	rjmp	.+4      	; 0x6a9c <doMenu+0xfe>
	{
		if (menu->marked < menu->len - 1) 
			menu->marked++;
	}
	else if (KEY4)		// ENTER
		return 1;
    6a98:	81 e0       	ldi	r24, 0x01	; 1
    6a9a:	01 c0       	rjmp	.+2      	; 0x6a9e <doMenu+0x100>

	LCD_SetPos(6, 58);
	if (menu->top < menu->len - 5)
		lcdWriteGlyph_P(&glyArrowDown, 0);
	
	return 0;
    6a9c:	80 e0       	ldi	r24, 0x00	; 0
}
    6a9e:	df 91       	pop	r29
    6aa0:	cf 91       	pop	r28
    6aa2:	1f 91       	pop	r17
    6aa4:	0f 91       	pop	r16
    6aa6:	ff 90       	pop	r15
    6aa8:	ef 90       	pop	r14
    6aaa:	08 95       	ret

00006aac <_hMenu>:


void _hMenu()
{
	if (doMenu(&mnuMain))
    6aac:	8e e0       	ldi	r24, 0x0E	; 14
    6aae:	91 e0       	ldi	r25, 0x01	; 1
    6ab0:	0e 94 cf 34 	call	0x699e	; 0x699e <doMenu>
    6ab4:	88 23       	and	r24, r24
    6ab6:	91 f0       	breq	.+36     	; 0x6adc <_hMenu+0x30>
	{	// if menu item selected then open it if...
		if (menuEnabled[mnuMain.marked + MENU_START_INDEX]==1)
    6ab8:	80 91 12 01 	lds	r24, 0x0112
    6abc:	e8 2f       	mov	r30, r24
    6abe:	f0 e0       	ldi	r31, 0x00	; 0
    6ac0:	e0 55       	subi	r30, 0x50	; 80
    6ac2:	f8 4f       	sbci	r31, 0xF8	; 248
    6ac4:	95 81       	ldd	r25, Z+5	; 0x05
    6ac6:	91 30       	cpi	r25, 0x01	; 1
    6ac8:	21 f4       	brne	.+8      	; 0x6ad2 <_hMenu+0x26>
		{ //... the menu item is enabled 
			Menu_LoadPage(mnuMain.marked + MENU_START_INDEX);
    6aca:	8b 5f       	subi	r24, 0xFB	; 251
    6acc:	0e 94 59 2c 	call	0x58b2	; 0x58b2 <Menu_LoadPage>
    6ad0:	08 95       	ret
		}
		else
		{ //... else flash light and ignore command
			LED_FlashOrangeLED(LED_SHORT_TOGGLE,2);
    6ad2:	8e e1       	ldi	r24, 0x1E	; 30
    6ad4:	90 e0       	ldi	r25, 0x00	; 0
    6ad6:	62 e0       	ldi	r22, 0x02	; 2
    6ad8:	0e 94 93 0e 	call	0x1d26	; 0x1d26 <LED_FlashOrangeLED>
    6adc:	08 95       	ret

00006ade <Menu_MenuShow>:

void Menu_MenuShow()
{
	
	
	_mykey = Keyboard_Read();
    6ade:	0e 94 b8 0b 	call	0x1770	; 0x1770 <Keyboard_Read>
	_mykey = _mykey | _TXKeys;
    6ae2:	90 91 b4 06 	lds	r25, 0x06B4
    6ae6:	98 2b       	or	r25, r24
    6ae8:	90 93 a8 05 	sts	0x05A8, r25

	
	LCD_Disable();
    6aec:	0e 94 3d 0e 	call	0x1c7a	; 0x1c7a <LCD_Disable>
	if (oldPage != page)
    6af0:	90 91 2d 05 	lds	r25, 0x052D
    6af4:	80 91 2c 05 	lds	r24, 0x052C
    6af8:	89 17       	cp	r24, r25
    6afa:	59 f0       	breq	.+22     	; 0x6b12 <Menu_MenuShow+0x34>
	{	// if this is a new page then KEY_INIT = true
		_mykey |= KEY_INIT;
    6afc:	80 91 a8 05 	lds	r24, 0x05A8
    6b00:	81 60       	ori	r24, 0x01	; 1
    6b02:	80 93 a8 05 	sts	0x05A8, r24
		subpage = 0;
    6b06:	10 92 2e 05 	sts	0x052E, r1
		subindex = 0;
    6b0a:	10 92 2f 05 	sts	0x052F, r1
		oldPage = page;
    6b0e:	90 93 2c 05 	sts	0x052C, r25
	}
	defaultHandler();
    6b12:	0e 94 91 2d 	call	0x5b22	; 0x5b22 <defaultHandler>
	LCD_Enable();
    6b16:	0e 94 34 0e 	call	0x1c68	; 0x1c68 <LCD_Enable>

	
	
	if (KEY1 && !editMode)	// BACK
    6b1a:	80 91 a8 05 	lds	r24, 0x05A8
    6b1e:	87 ff       	sbrs	r24, 7
    6b20:	15 c0       	rjmp	.+42     	; 0x6b4c <Menu_MenuShow+0x6e>
    6b22:	80 91 c6 07 	lds	r24, 0x07C6
    6b26:	88 23       	and	r24, r24
    6b28:	89 f4       	brne	.+34     	; 0x6b4c <Menu_MenuShow+0x6e>
	{
		if (page > PAGE_MENU) // if any page then go to main menu
    6b2a:	80 91 2d 05 	lds	r24, 0x052D
    6b2e:	82 30       	cpi	r24, 0x02	; 2
    6b30:	10 f0       	brcs	.+4      	; 0x6b36 <Menu_MenuShow+0x58>
			Menu_LoadPage(PAGE_MENU);
    6b32:	81 e0       	ldi	r24, 0x01	; 1
    6b34:	09 c0       	rjmp	.+18     	; 0x6b48 <Menu_MenuShow+0x6a>
		else if (page == PAGE_MENU)  // if menu page then goto HomePage
    6b36:	81 30       	cpi	r24, 0x01	; 1
    6b38:	49 f4       	brne	.+18     	; 0x6b4c <Menu_MenuShow+0x6e>
			{
				if (IsArmed == true)
    6b3a:	80 91 96 07 	lds	r24, 0x0796
    6b3e:	81 30       	cpi	r24, 0x01	; 1
    6b40:	11 f4       	brne	.+4      	; 0x6b46 <Menu_MenuShow+0x68>
				{
					Menu_LoadPage(PAGE_HOME_ARMED);
    6b42:	82 e0       	ldi	r24, 0x02	; 2
    6b44:	01 c0       	rjmp	.+2      	; 0x6b48 <Menu_MenuShow+0x6a>
				}
				else
				{
					Menu_LoadPage(PAGE_HOME);
    6b46:	80 e0       	ldi	r24, 0x00	; 0
    6b48:	0e 94 59 2c 	call	0x58b2	; 0x58b2 <Menu_LoadPage>
				}
			}							
	}
	
	
	if (KEYPRESS)
    6b4c:	80 91 a8 05 	lds	r24, 0x05A8
    6b50:	80 7f       	andi	r24, 0xF0	; 240
    6b52:	29 f0       	breq	.+10     	; 0x6b5e <Menu_MenuShow+0x80>
		Beeper_Beep(BEEP_KEY,1);
    6b54:	86 e4       	ldi	r24, 0x46	; 70
    6b56:	90 e0       	ldi	r25, 0x00	; 0
    6b58:	61 e0       	ldi	r22, 0x01	; 1
    6b5a:	0e 94 91 0b 	call	0x1722	; 0x1722 <Beeper_Beep>
		
	_TXKeys = 0; // No Key Pressed
    6b5e:	10 92 b4 06 	sts	0x06B4, r1
}
    6b62:	08 95       	ret

00006b64 <Menu_MenuInit>:

void Menu_MenuInit()
{
	oldPage=0xff;
    6b64:	8f ef       	ldi	r24, 0xFF	; 255
    6b66:	80 93 2c 05 	sts	0x052C, r24
	Menu_LoadPage(PAGE_HOME);
    6b6a:	80 e0       	ldi	r24, 0x00	; 0
    6b6c:	0e 94 59 2c 	call	0x58b2	; 0x58b2 <Menu_LoadPage>
}
    6b70:	08 95       	ret

00006b72 <tsmLoadModelLayout>:
}

PGM_P tsmLoadModelLayout(uint8_t index)
{
	//return (PGM_P)pgm_read_word(&mixerTable[index].Name);
}
    6b72:	08 95       	ret

00006b74 <Menu_EnableAllItems>:


void Menu_EnableAllItems ()
{
    6b74:	e0 eb       	ldi	r30, 0xB0	; 176
    6b76:	f7 e0       	ldi	r31, 0x07	; 7
	
	for (int i=0;i <MENU_ITEMS_COUNT;++i)
	{
		
		menuEnabled[i]=1;
    6b78:	81 e0       	ldi	r24, 0x01	; 1
    6b7a:	81 93       	st	Z+, r24


void Menu_EnableAllItems ()
{
	
	for (int i=0;i <MENU_ITEMS_COUNT;++i)
    6b7c:	97 e0       	ldi	r25, 0x07	; 7
    6b7e:	e1 3c       	cpi	r30, 0xC1	; 193
    6b80:	f9 07       	cpc	r31, r25
    6b82:	d9 f7       	brne	.-10     	; 0x6b7a <Menu_EnableAllItems+0x6>
	{
		
		menuEnabled[i]=1;
	}
	menuEnabled[PAGE_DEBUG]=1;
    6b84:	80 93 bf 07 	sts	0x07BF, r24
	
    6b88:	08 95       	ret

00006b8a <__subsf3>:
    6b8a:	50 58       	subi	r21, 0x80	; 128

00006b8c <__addsf3>:
    6b8c:	bb 27       	eor	r27, r27
    6b8e:	aa 27       	eor	r26, r26
    6b90:	0e d0       	rcall	.+28     	; 0x6bae <__addsf3x>
    6b92:	75 c1       	rjmp	.+746    	; 0x6e7e <__fp_round>
    6b94:	66 d1       	rcall	.+716    	; 0x6e62 <__fp_pscA>
    6b96:	30 f0       	brcs	.+12     	; 0x6ba4 <__addsf3+0x18>
    6b98:	6b d1       	rcall	.+726    	; 0x6e70 <__fp_pscB>
    6b9a:	20 f0       	brcs	.+8      	; 0x6ba4 <__addsf3+0x18>
    6b9c:	31 f4       	brne	.+12     	; 0x6baa <__addsf3+0x1e>
    6b9e:	9f 3f       	cpi	r25, 0xFF	; 255
    6ba0:	11 f4       	brne	.+4      	; 0x6ba6 <__addsf3+0x1a>
    6ba2:	1e f4       	brtc	.+6      	; 0x6baa <__addsf3+0x1e>
    6ba4:	5b c1       	rjmp	.+694    	; 0x6e5c <__fp_nan>
    6ba6:	0e f4       	brtc	.+2      	; 0x6baa <__addsf3+0x1e>
    6ba8:	e0 95       	com	r30
    6baa:	e7 fb       	bst	r30, 7
    6bac:	51 c1       	rjmp	.+674    	; 0x6e50 <__fp_inf>

00006bae <__addsf3x>:
    6bae:	e9 2f       	mov	r30, r25
    6bb0:	77 d1       	rcall	.+750    	; 0x6ea0 <__fp_split3>
    6bb2:	80 f3       	brcs	.-32     	; 0x6b94 <__addsf3+0x8>
    6bb4:	ba 17       	cp	r27, r26
    6bb6:	62 07       	cpc	r22, r18
    6bb8:	73 07       	cpc	r23, r19
    6bba:	84 07       	cpc	r24, r20
    6bbc:	95 07       	cpc	r25, r21
    6bbe:	18 f0       	brcs	.+6      	; 0x6bc6 <__addsf3x+0x18>
    6bc0:	71 f4       	brne	.+28     	; 0x6bde <__addsf3x+0x30>
    6bc2:	9e f5       	brtc	.+102    	; 0x6c2a <__addsf3x+0x7c>
    6bc4:	8f c1       	rjmp	.+798    	; 0x6ee4 <__fp_zero>
    6bc6:	0e f4       	brtc	.+2      	; 0x6bca <__addsf3x+0x1c>
    6bc8:	e0 95       	com	r30
    6bca:	0b 2e       	mov	r0, r27
    6bcc:	ba 2f       	mov	r27, r26
    6bce:	a0 2d       	mov	r26, r0
    6bd0:	0b 01       	movw	r0, r22
    6bd2:	b9 01       	movw	r22, r18
    6bd4:	90 01       	movw	r18, r0
    6bd6:	0c 01       	movw	r0, r24
    6bd8:	ca 01       	movw	r24, r20
    6bda:	a0 01       	movw	r20, r0
    6bdc:	11 24       	eor	r1, r1
    6bde:	ff 27       	eor	r31, r31
    6be0:	59 1b       	sub	r21, r25
    6be2:	99 f0       	breq	.+38     	; 0x6c0a <__addsf3x+0x5c>
    6be4:	59 3f       	cpi	r21, 0xF9	; 249
    6be6:	50 f4       	brcc	.+20     	; 0x6bfc <__addsf3x+0x4e>
    6be8:	50 3e       	cpi	r21, 0xE0	; 224
    6bea:	68 f1       	brcs	.+90     	; 0x6c46 <__addsf3x+0x98>
    6bec:	1a 16       	cp	r1, r26
    6bee:	f0 40       	sbci	r31, 0x00	; 0
    6bf0:	a2 2f       	mov	r26, r18
    6bf2:	23 2f       	mov	r18, r19
    6bf4:	34 2f       	mov	r19, r20
    6bf6:	44 27       	eor	r20, r20
    6bf8:	58 5f       	subi	r21, 0xF8	; 248
    6bfa:	f3 cf       	rjmp	.-26     	; 0x6be2 <__addsf3x+0x34>
    6bfc:	46 95       	lsr	r20
    6bfe:	37 95       	ror	r19
    6c00:	27 95       	ror	r18
    6c02:	a7 95       	ror	r26
    6c04:	f0 40       	sbci	r31, 0x00	; 0
    6c06:	53 95       	inc	r21
    6c08:	c9 f7       	brne	.-14     	; 0x6bfc <__addsf3x+0x4e>
    6c0a:	7e f4       	brtc	.+30     	; 0x6c2a <__addsf3x+0x7c>
    6c0c:	1f 16       	cp	r1, r31
    6c0e:	ba 0b       	sbc	r27, r26
    6c10:	62 0b       	sbc	r22, r18
    6c12:	73 0b       	sbc	r23, r19
    6c14:	84 0b       	sbc	r24, r20
    6c16:	ba f0       	brmi	.+46     	; 0x6c46 <__addsf3x+0x98>
    6c18:	91 50       	subi	r25, 0x01	; 1
    6c1a:	a1 f0       	breq	.+40     	; 0x6c44 <__addsf3x+0x96>
    6c1c:	ff 0f       	add	r31, r31
    6c1e:	bb 1f       	adc	r27, r27
    6c20:	66 1f       	adc	r22, r22
    6c22:	77 1f       	adc	r23, r23
    6c24:	88 1f       	adc	r24, r24
    6c26:	c2 f7       	brpl	.-16     	; 0x6c18 <__addsf3x+0x6a>
    6c28:	0e c0       	rjmp	.+28     	; 0x6c46 <__addsf3x+0x98>
    6c2a:	ba 0f       	add	r27, r26
    6c2c:	62 1f       	adc	r22, r18
    6c2e:	73 1f       	adc	r23, r19
    6c30:	84 1f       	adc	r24, r20
    6c32:	48 f4       	brcc	.+18     	; 0x6c46 <__addsf3x+0x98>
    6c34:	87 95       	ror	r24
    6c36:	77 95       	ror	r23
    6c38:	67 95       	ror	r22
    6c3a:	b7 95       	ror	r27
    6c3c:	f7 95       	ror	r31
    6c3e:	9e 3f       	cpi	r25, 0xFE	; 254
    6c40:	08 f0       	brcs	.+2      	; 0x6c44 <__addsf3x+0x96>
    6c42:	b3 cf       	rjmp	.-154    	; 0x6baa <__addsf3+0x1e>
    6c44:	93 95       	inc	r25
    6c46:	88 0f       	add	r24, r24
    6c48:	08 f0       	brcs	.+2      	; 0x6c4c <__addsf3x+0x9e>
    6c4a:	99 27       	eor	r25, r25
    6c4c:	ee 0f       	add	r30, r30
    6c4e:	97 95       	ror	r25
    6c50:	87 95       	ror	r24
    6c52:	08 95       	ret

00006c54 <__cmpsf2>:
    6c54:	d9 d0       	rcall	.+434    	; 0x6e08 <__fp_cmp>
    6c56:	08 f4       	brcc	.+2      	; 0x6c5a <__cmpsf2+0x6>
    6c58:	81 e0       	ldi	r24, 0x01	; 1
    6c5a:	08 95       	ret

00006c5c <__divsf3>:
    6c5c:	0c d0       	rcall	.+24     	; 0x6c76 <__divsf3x>
    6c5e:	0f c1       	rjmp	.+542    	; 0x6e7e <__fp_round>
    6c60:	07 d1       	rcall	.+526    	; 0x6e70 <__fp_pscB>
    6c62:	40 f0       	brcs	.+16     	; 0x6c74 <__divsf3+0x18>
    6c64:	fe d0       	rcall	.+508    	; 0x6e62 <__fp_pscA>
    6c66:	30 f0       	brcs	.+12     	; 0x6c74 <__divsf3+0x18>
    6c68:	21 f4       	brne	.+8      	; 0x6c72 <__divsf3+0x16>
    6c6a:	5f 3f       	cpi	r21, 0xFF	; 255
    6c6c:	19 f0       	breq	.+6      	; 0x6c74 <__divsf3+0x18>
    6c6e:	f0 c0       	rjmp	.+480    	; 0x6e50 <__fp_inf>
    6c70:	51 11       	cpse	r21, r1
    6c72:	39 c1       	rjmp	.+626    	; 0x6ee6 <__fp_szero>
    6c74:	f3 c0       	rjmp	.+486    	; 0x6e5c <__fp_nan>

00006c76 <__divsf3x>:
    6c76:	14 d1       	rcall	.+552    	; 0x6ea0 <__fp_split3>
    6c78:	98 f3       	brcs	.-26     	; 0x6c60 <__divsf3+0x4>

00006c7a <__divsf3_pse>:
    6c7a:	99 23       	and	r25, r25
    6c7c:	c9 f3       	breq	.-14     	; 0x6c70 <__divsf3+0x14>
    6c7e:	55 23       	and	r21, r21
    6c80:	b1 f3       	breq	.-20     	; 0x6c6e <__divsf3+0x12>
    6c82:	95 1b       	sub	r25, r21
    6c84:	55 0b       	sbc	r21, r21
    6c86:	bb 27       	eor	r27, r27
    6c88:	aa 27       	eor	r26, r26
    6c8a:	62 17       	cp	r22, r18
    6c8c:	73 07       	cpc	r23, r19
    6c8e:	84 07       	cpc	r24, r20
    6c90:	38 f0       	brcs	.+14     	; 0x6ca0 <__divsf3_pse+0x26>
    6c92:	9f 5f       	subi	r25, 0xFF	; 255
    6c94:	5f 4f       	sbci	r21, 0xFF	; 255
    6c96:	22 0f       	add	r18, r18
    6c98:	33 1f       	adc	r19, r19
    6c9a:	44 1f       	adc	r20, r20
    6c9c:	aa 1f       	adc	r26, r26
    6c9e:	a9 f3       	breq	.-22     	; 0x6c8a <__divsf3_pse+0x10>
    6ca0:	33 d0       	rcall	.+102    	; 0x6d08 <__divsf3_pse+0x8e>
    6ca2:	0e 2e       	mov	r0, r30
    6ca4:	3a f0       	brmi	.+14     	; 0x6cb4 <__divsf3_pse+0x3a>
    6ca6:	e0 e8       	ldi	r30, 0x80	; 128
    6ca8:	30 d0       	rcall	.+96     	; 0x6d0a <__divsf3_pse+0x90>
    6caa:	91 50       	subi	r25, 0x01	; 1
    6cac:	50 40       	sbci	r21, 0x00	; 0
    6cae:	e6 95       	lsr	r30
    6cb0:	00 1c       	adc	r0, r0
    6cb2:	ca f7       	brpl	.-14     	; 0x6ca6 <__divsf3_pse+0x2c>
    6cb4:	29 d0       	rcall	.+82     	; 0x6d08 <__divsf3_pse+0x8e>
    6cb6:	fe 2f       	mov	r31, r30
    6cb8:	27 d0       	rcall	.+78     	; 0x6d08 <__divsf3_pse+0x8e>
    6cba:	66 0f       	add	r22, r22
    6cbc:	77 1f       	adc	r23, r23
    6cbe:	88 1f       	adc	r24, r24
    6cc0:	bb 1f       	adc	r27, r27
    6cc2:	26 17       	cp	r18, r22
    6cc4:	37 07       	cpc	r19, r23
    6cc6:	48 07       	cpc	r20, r24
    6cc8:	ab 07       	cpc	r26, r27
    6cca:	b0 e8       	ldi	r27, 0x80	; 128
    6ccc:	09 f0       	breq	.+2      	; 0x6cd0 <__divsf3_pse+0x56>
    6cce:	bb 0b       	sbc	r27, r27
    6cd0:	80 2d       	mov	r24, r0
    6cd2:	bf 01       	movw	r22, r30
    6cd4:	ff 27       	eor	r31, r31
    6cd6:	93 58       	subi	r25, 0x83	; 131
    6cd8:	5f 4f       	sbci	r21, 0xFF	; 255
    6cda:	2a f0       	brmi	.+10     	; 0x6ce6 <__divsf3_pse+0x6c>
    6cdc:	9e 3f       	cpi	r25, 0xFE	; 254
    6cde:	51 05       	cpc	r21, r1
    6ce0:	68 f0       	brcs	.+26     	; 0x6cfc <__divsf3_pse+0x82>
    6ce2:	b6 c0       	rjmp	.+364    	; 0x6e50 <__fp_inf>
    6ce4:	00 c1       	rjmp	.+512    	; 0x6ee6 <__fp_szero>
    6ce6:	5f 3f       	cpi	r21, 0xFF	; 255
    6ce8:	ec f3       	brlt	.-6      	; 0x6ce4 <__divsf3_pse+0x6a>
    6cea:	98 3e       	cpi	r25, 0xE8	; 232
    6cec:	dc f3       	brlt	.-10     	; 0x6ce4 <__divsf3_pse+0x6a>
    6cee:	86 95       	lsr	r24
    6cf0:	77 95       	ror	r23
    6cf2:	67 95       	ror	r22
    6cf4:	b7 95       	ror	r27
    6cf6:	f7 95       	ror	r31
    6cf8:	9f 5f       	subi	r25, 0xFF	; 255
    6cfa:	c9 f7       	brne	.-14     	; 0x6cee <__divsf3_pse+0x74>
    6cfc:	88 0f       	add	r24, r24
    6cfe:	91 1d       	adc	r25, r1
    6d00:	96 95       	lsr	r25
    6d02:	87 95       	ror	r24
    6d04:	97 f9       	bld	r25, 7
    6d06:	08 95       	ret
    6d08:	e1 e0       	ldi	r30, 0x01	; 1
    6d0a:	66 0f       	add	r22, r22
    6d0c:	77 1f       	adc	r23, r23
    6d0e:	88 1f       	adc	r24, r24
    6d10:	bb 1f       	adc	r27, r27
    6d12:	62 17       	cp	r22, r18
    6d14:	73 07       	cpc	r23, r19
    6d16:	84 07       	cpc	r24, r20
    6d18:	ba 07       	cpc	r27, r26
    6d1a:	20 f0       	brcs	.+8      	; 0x6d24 <__divsf3_pse+0xaa>
    6d1c:	62 1b       	sub	r22, r18
    6d1e:	73 0b       	sbc	r23, r19
    6d20:	84 0b       	sbc	r24, r20
    6d22:	ba 0b       	sbc	r27, r26
    6d24:	ee 1f       	adc	r30, r30
    6d26:	88 f7       	brcc	.-30     	; 0x6d0a <__divsf3_pse+0x90>
    6d28:	e0 95       	com	r30
    6d2a:	08 95       	ret

00006d2c <__fixsfsi>:
    6d2c:	04 d0       	rcall	.+8      	; 0x6d36 <__fixunssfsi>
    6d2e:	68 94       	set
    6d30:	b1 11       	cpse	r27, r1
    6d32:	d9 c0       	rjmp	.+434    	; 0x6ee6 <__fp_szero>
    6d34:	08 95       	ret

00006d36 <__fixunssfsi>:
    6d36:	bc d0       	rcall	.+376    	; 0x6eb0 <__fp_splitA>
    6d38:	88 f0       	brcs	.+34     	; 0x6d5c <__fixunssfsi+0x26>
    6d3a:	9f 57       	subi	r25, 0x7F	; 127
    6d3c:	90 f0       	brcs	.+36     	; 0x6d62 <__fixunssfsi+0x2c>
    6d3e:	b9 2f       	mov	r27, r25
    6d40:	99 27       	eor	r25, r25
    6d42:	b7 51       	subi	r27, 0x17	; 23
    6d44:	a0 f0       	brcs	.+40     	; 0x6d6e <__fixunssfsi+0x38>
    6d46:	d1 f0       	breq	.+52     	; 0x6d7c <__fixunssfsi+0x46>
    6d48:	66 0f       	add	r22, r22
    6d4a:	77 1f       	adc	r23, r23
    6d4c:	88 1f       	adc	r24, r24
    6d4e:	99 1f       	adc	r25, r25
    6d50:	1a f0       	brmi	.+6      	; 0x6d58 <__fixunssfsi+0x22>
    6d52:	ba 95       	dec	r27
    6d54:	c9 f7       	brne	.-14     	; 0x6d48 <__fixunssfsi+0x12>
    6d56:	12 c0       	rjmp	.+36     	; 0x6d7c <__fixunssfsi+0x46>
    6d58:	b1 30       	cpi	r27, 0x01	; 1
    6d5a:	81 f0       	breq	.+32     	; 0x6d7c <__fixunssfsi+0x46>
    6d5c:	c3 d0       	rcall	.+390    	; 0x6ee4 <__fp_zero>
    6d5e:	b1 e0       	ldi	r27, 0x01	; 1
    6d60:	08 95       	ret
    6d62:	c0 c0       	rjmp	.+384    	; 0x6ee4 <__fp_zero>
    6d64:	67 2f       	mov	r22, r23
    6d66:	78 2f       	mov	r23, r24
    6d68:	88 27       	eor	r24, r24
    6d6a:	b8 5f       	subi	r27, 0xF8	; 248
    6d6c:	39 f0       	breq	.+14     	; 0x6d7c <__fixunssfsi+0x46>
    6d6e:	b9 3f       	cpi	r27, 0xF9	; 249
    6d70:	cc f3       	brlt	.-14     	; 0x6d64 <__fixunssfsi+0x2e>
    6d72:	86 95       	lsr	r24
    6d74:	77 95       	ror	r23
    6d76:	67 95       	ror	r22
    6d78:	b3 95       	inc	r27
    6d7a:	d9 f7       	brne	.-10     	; 0x6d72 <__fixunssfsi+0x3c>
    6d7c:	3e f4       	brtc	.+14     	; 0x6d8c <__fixunssfsi+0x56>
    6d7e:	90 95       	com	r25
    6d80:	80 95       	com	r24
    6d82:	70 95       	com	r23
    6d84:	61 95       	neg	r22
    6d86:	7f 4f       	sbci	r23, 0xFF	; 255
    6d88:	8f 4f       	sbci	r24, 0xFF	; 255
    6d8a:	9f 4f       	sbci	r25, 0xFF	; 255
    6d8c:	08 95       	ret

00006d8e <__floatunsisf>:
    6d8e:	e8 94       	clt
    6d90:	09 c0       	rjmp	.+18     	; 0x6da4 <__floatsisf+0x12>

00006d92 <__floatsisf>:
    6d92:	97 fb       	bst	r25, 7
    6d94:	3e f4       	brtc	.+14     	; 0x6da4 <__floatsisf+0x12>
    6d96:	90 95       	com	r25
    6d98:	80 95       	com	r24
    6d9a:	70 95       	com	r23
    6d9c:	61 95       	neg	r22
    6d9e:	7f 4f       	sbci	r23, 0xFF	; 255
    6da0:	8f 4f       	sbci	r24, 0xFF	; 255
    6da2:	9f 4f       	sbci	r25, 0xFF	; 255
    6da4:	99 23       	and	r25, r25
    6da6:	a9 f0       	breq	.+42     	; 0x6dd2 <__floatsisf+0x40>
    6da8:	f9 2f       	mov	r31, r25
    6daa:	96 e9       	ldi	r25, 0x96	; 150
    6dac:	bb 27       	eor	r27, r27
    6dae:	93 95       	inc	r25
    6db0:	f6 95       	lsr	r31
    6db2:	87 95       	ror	r24
    6db4:	77 95       	ror	r23
    6db6:	67 95       	ror	r22
    6db8:	b7 95       	ror	r27
    6dba:	f1 11       	cpse	r31, r1
    6dbc:	f8 cf       	rjmp	.-16     	; 0x6dae <__floatsisf+0x1c>
    6dbe:	fa f4       	brpl	.+62     	; 0x6dfe <__floatsisf+0x6c>
    6dc0:	bb 0f       	add	r27, r27
    6dc2:	11 f4       	brne	.+4      	; 0x6dc8 <__floatsisf+0x36>
    6dc4:	60 ff       	sbrs	r22, 0
    6dc6:	1b c0       	rjmp	.+54     	; 0x6dfe <__floatsisf+0x6c>
    6dc8:	6f 5f       	subi	r22, 0xFF	; 255
    6dca:	7f 4f       	sbci	r23, 0xFF	; 255
    6dcc:	8f 4f       	sbci	r24, 0xFF	; 255
    6dce:	9f 4f       	sbci	r25, 0xFF	; 255
    6dd0:	16 c0       	rjmp	.+44     	; 0x6dfe <__floatsisf+0x6c>
    6dd2:	88 23       	and	r24, r24
    6dd4:	11 f0       	breq	.+4      	; 0x6dda <__floatsisf+0x48>
    6dd6:	96 e9       	ldi	r25, 0x96	; 150
    6dd8:	11 c0       	rjmp	.+34     	; 0x6dfc <__floatsisf+0x6a>
    6dda:	77 23       	and	r23, r23
    6ddc:	21 f0       	breq	.+8      	; 0x6de6 <__floatsisf+0x54>
    6dde:	9e e8       	ldi	r25, 0x8E	; 142
    6de0:	87 2f       	mov	r24, r23
    6de2:	76 2f       	mov	r23, r22
    6de4:	05 c0       	rjmp	.+10     	; 0x6df0 <__floatsisf+0x5e>
    6de6:	66 23       	and	r22, r22
    6de8:	71 f0       	breq	.+28     	; 0x6e06 <__floatsisf+0x74>
    6dea:	96 e8       	ldi	r25, 0x86	; 134
    6dec:	86 2f       	mov	r24, r22
    6dee:	70 e0       	ldi	r23, 0x00	; 0
    6df0:	60 e0       	ldi	r22, 0x00	; 0
    6df2:	2a f0       	brmi	.+10     	; 0x6dfe <__floatsisf+0x6c>
    6df4:	9a 95       	dec	r25
    6df6:	66 0f       	add	r22, r22
    6df8:	77 1f       	adc	r23, r23
    6dfa:	88 1f       	adc	r24, r24
    6dfc:	da f7       	brpl	.-10     	; 0x6df4 <__floatsisf+0x62>
    6dfe:	88 0f       	add	r24, r24
    6e00:	96 95       	lsr	r25
    6e02:	87 95       	ror	r24
    6e04:	97 f9       	bld	r25, 7
    6e06:	08 95       	ret

00006e08 <__fp_cmp>:
    6e08:	99 0f       	add	r25, r25
    6e0a:	00 08       	sbc	r0, r0
    6e0c:	55 0f       	add	r21, r21
    6e0e:	aa 0b       	sbc	r26, r26
    6e10:	e0 e8       	ldi	r30, 0x80	; 128
    6e12:	fe ef       	ldi	r31, 0xFE	; 254
    6e14:	16 16       	cp	r1, r22
    6e16:	17 06       	cpc	r1, r23
    6e18:	e8 07       	cpc	r30, r24
    6e1a:	f9 07       	cpc	r31, r25
    6e1c:	c0 f0       	brcs	.+48     	; 0x6e4e <__fp_cmp+0x46>
    6e1e:	12 16       	cp	r1, r18
    6e20:	13 06       	cpc	r1, r19
    6e22:	e4 07       	cpc	r30, r20
    6e24:	f5 07       	cpc	r31, r21
    6e26:	98 f0       	brcs	.+38     	; 0x6e4e <__fp_cmp+0x46>
    6e28:	62 1b       	sub	r22, r18
    6e2a:	73 0b       	sbc	r23, r19
    6e2c:	84 0b       	sbc	r24, r20
    6e2e:	95 0b       	sbc	r25, r21
    6e30:	39 f4       	brne	.+14     	; 0x6e40 <__fp_cmp+0x38>
    6e32:	0a 26       	eor	r0, r26
    6e34:	61 f0       	breq	.+24     	; 0x6e4e <__fp_cmp+0x46>
    6e36:	23 2b       	or	r18, r19
    6e38:	24 2b       	or	r18, r20
    6e3a:	25 2b       	or	r18, r21
    6e3c:	21 f4       	brne	.+8      	; 0x6e46 <__fp_cmp+0x3e>
    6e3e:	08 95       	ret
    6e40:	0a 26       	eor	r0, r26
    6e42:	09 f4       	brne	.+2      	; 0x6e46 <__fp_cmp+0x3e>
    6e44:	a1 40       	sbci	r26, 0x01	; 1
    6e46:	a6 95       	lsr	r26
    6e48:	8f ef       	ldi	r24, 0xFF	; 255
    6e4a:	81 1d       	adc	r24, r1
    6e4c:	81 1d       	adc	r24, r1
    6e4e:	08 95       	ret

00006e50 <__fp_inf>:
    6e50:	97 f9       	bld	r25, 7
    6e52:	9f 67       	ori	r25, 0x7F	; 127
    6e54:	80 e8       	ldi	r24, 0x80	; 128
    6e56:	70 e0       	ldi	r23, 0x00	; 0
    6e58:	60 e0       	ldi	r22, 0x00	; 0
    6e5a:	08 95       	ret

00006e5c <__fp_nan>:
    6e5c:	9f ef       	ldi	r25, 0xFF	; 255
    6e5e:	80 ec       	ldi	r24, 0xC0	; 192
    6e60:	08 95       	ret

00006e62 <__fp_pscA>:
    6e62:	00 24       	eor	r0, r0
    6e64:	0a 94       	dec	r0
    6e66:	16 16       	cp	r1, r22
    6e68:	17 06       	cpc	r1, r23
    6e6a:	18 06       	cpc	r1, r24
    6e6c:	09 06       	cpc	r0, r25
    6e6e:	08 95       	ret

00006e70 <__fp_pscB>:
    6e70:	00 24       	eor	r0, r0
    6e72:	0a 94       	dec	r0
    6e74:	12 16       	cp	r1, r18
    6e76:	13 06       	cpc	r1, r19
    6e78:	14 06       	cpc	r1, r20
    6e7a:	05 06       	cpc	r0, r21
    6e7c:	08 95       	ret

00006e7e <__fp_round>:
    6e7e:	09 2e       	mov	r0, r25
    6e80:	03 94       	inc	r0
    6e82:	00 0c       	add	r0, r0
    6e84:	11 f4       	brne	.+4      	; 0x6e8a <__fp_round+0xc>
    6e86:	88 23       	and	r24, r24
    6e88:	52 f0       	brmi	.+20     	; 0x6e9e <__fp_round+0x20>
    6e8a:	bb 0f       	add	r27, r27
    6e8c:	40 f4       	brcc	.+16     	; 0x6e9e <__fp_round+0x20>
    6e8e:	bf 2b       	or	r27, r31
    6e90:	11 f4       	brne	.+4      	; 0x6e96 <__fp_round+0x18>
    6e92:	60 ff       	sbrs	r22, 0
    6e94:	04 c0       	rjmp	.+8      	; 0x6e9e <__fp_round+0x20>
    6e96:	6f 5f       	subi	r22, 0xFF	; 255
    6e98:	7f 4f       	sbci	r23, 0xFF	; 255
    6e9a:	8f 4f       	sbci	r24, 0xFF	; 255
    6e9c:	9f 4f       	sbci	r25, 0xFF	; 255
    6e9e:	08 95       	ret

00006ea0 <__fp_split3>:
    6ea0:	57 fd       	sbrc	r21, 7
    6ea2:	90 58       	subi	r25, 0x80	; 128
    6ea4:	44 0f       	add	r20, r20
    6ea6:	55 1f       	adc	r21, r21
    6ea8:	59 f0       	breq	.+22     	; 0x6ec0 <__fp_splitA+0x10>
    6eaa:	5f 3f       	cpi	r21, 0xFF	; 255
    6eac:	71 f0       	breq	.+28     	; 0x6eca <__fp_splitA+0x1a>
    6eae:	47 95       	ror	r20

00006eb0 <__fp_splitA>:
    6eb0:	88 0f       	add	r24, r24
    6eb2:	97 fb       	bst	r25, 7
    6eb4:	99 1f       	adc	r25, r25
    6eb6:	61 f0       	breq	.+24     	; 0x6ed0 <__fp_splitA+0x20>
    6eb8:	9f 3f       	cpi	r25, 0xFF	; 255
    6eba:	79 f0       	breq	.+30     	; 0x6eda <__fp_splitA+0x2a>
    6ebc:	87 95       	ror	r24
    6ebe:	08 95       	ret
    6ec0:	12 16       	cp	r1, r18
    6ec2:	13 06       	cpc	r1, r19
    6ec4:	14 06       	cpc	r1, r20
    6ec6:	55 1f       	adc	r21, r21
    6ec8:	f2 cf       	rjmp	.-28     	; 0x6eae <__fp_split3+0xe>
    6eca:	46 95       	lsr	r20
    6ecc:	f1 df       	rcall	.-30     	; 0x6eb0 <__fp_splitA>
    6ece:	08 c0       	rjmp	.+16     	; 0x6ee0 <__fp_splitA+0x30>
    6ed0:	16 16       	cp	r1, r22
    6ed2:	17 06       	cpc	r1, r23
    6ed4:	18 06       	cpc	r1, r24
    6ed6:	99 1f       	adc	r25, r25
    6ed8:	f1 cf       	rjmp	.-30     	; 0x6ebc <__fp_splitA+0xc>
    6eda:	86 95       	lsr	r24
    6edc:	71 05       	cpc	r23, r1
    6ede:	61 05       	cpc	r22, r1
    6ee0:	08 94       	sec
    6ee2:	08 95       	ret

00006ee4 <__fp_zero>:
    6ee4:	e8 94       	clt

00006ee6 <__fp_szero>:
    6ee6:	bb 27       	eor	r27, r27
    6ee8:	66 27       	eor	r22, r22
    6eea:	77 27       	eor	r23, r23
    6eec:	cb 01       	movw	r24, r22
    6eee:	97 f9       	bld	r25, 7
    6ef0:	08 95       	ret

00006ef2 <__gesf2>:
    6ef2:	8a df       	rcall	.-236    	; 0x6e08 <__fp_cmp>
    6ef4:	08 f4       	brcc	.+2      	; 0x6ef8 <__gesf2+0x6>
    6ef6:	8f ef       	ldi	r24, 0xFF	; 255
    6ef8:	08 95       	ret

00006efa <__mulsf3>:
    6efa:	0b d0       	rcall	.+22     	; 0x6f12 <__mulsf3x>
    6efc:	c0 cf       	rjmp	.-128    	; 0x6e7e <__fp_round>
    6efe:	b1 df       	rcall	.-158    	; 0x6e62 <__fp_pscA>
    6f00:	28 f0       	brcs	.+10     	; 0x6f0c <__mulsf3+0x12>
    6f02:	b6 df       	rcall	.-148    	; 0x6e70 <__fp_pscB>
    6f04:	18 f0       	brcs	.+6      	; 0x6f0c <__mulsf3+0x12>
    6f06:	95 23       	and	r25, r21
    6f08:	09 f0       	breq	.+2      	; 0x6f0c <__mulsf3+0x12>
    6f0a:	a2 cf       	rjmp	.-188    	; 0x6e50 <__fp_inf>
    6f0c:	a7 cf       	rjmp	.-178    	; 0x6e5c <__fp_nan>
    6f0e:	11 24       	eor	r1, r1
    6f10:	ea cf       	rjmp	.-44     	; 0x6ee6 <__fp_szero>

00006f12 <__mulsf3x>:
    6f12:	c6 df       	rcall	.-116    	; 0x6ea0 <__fp_split3>
    6f14:	a0 f3       	brcs	.-24     	; 0x6efe <__mulsf3+0x4>

00006f16 <__mulsf3_pse>:
    6f16:	95 9f       	mul	r25, r21
    6f18:	d1 f3       	breq	.-12     	; 0x6f0e <__mulsf3+0x14>
    6f1a:	95 0f       	add	r25, r21
    6f1c:	50 e0       	ldi	r21, 0x00	; 0
    6f1e:	55 1f       	adc	r21, r21
    6f20:	62 9f       	mul	r22, r18
    6f22:	f0 01       	movw	r30, r0
    6f24:	72 9f       	mul	r23, r18
    6f26:	bb 27       	eor	r27, r27
    6f28:	f0 0d       	add	r31, r0
    6f2a:	b1 1d       	adc	r27, r1
    6f2c:	63 9f       	mul	r22, r19
    6f2e:	aa 27       	eor	r26, r26
    6f30:	f0 0d       	add	r31, r0
    6f32:	b1 1d       	adc	r27, r1
    6f34:	aa 1f       	adc	r26, r26
    6f36:	64 9f       	mul	r22, r20
    6f38:	66 27       	eor	r22, r22
    6f3a:	b0 0d       	add	r27, r0
    6f3c:	a1 1d       	adc	r26, r1
    6f3e:	66 1f       	adc	r22, r22
    6f40:	82 9f       	mul	r24, r18
    6f42:	22 27       	eor	r18, r18
    6f44:	b0 0d       	add	r27, r0
    6f46:	a1 1d       	adc	r26, r1
    6f48:	62 1f       	adc	r22, r18
    6f4a:	73 9f       	mul	r23, r19
    6f4c:	b0 0d       	add	r27, r0
    6f4e:	a1 1d       	adc	r26, r1
    6f50:	62 1f       	adc	r22, r18
    6f52:	83 9f       	mul	r24, r19
    6f54:	a0 0d       	add	r26, r0
    6f56:	61 1d       	adc	r22, r1
    6f58:	22 1f       	adc	r18, r18
    6f5a:	74 9f       	mul	r23, r20
    6f5c:	33 27       	eor	r19, r19
    6f5e:	a0 0d       	add	r26, r0
    6f60:	61 1d       	adc	r22, r1
    6f62:	23 1f       	adc	r18, r19
    6f64:	84 9f       	mul	r24, r20
    6f66:	60 0d       	add	r22, r0
    6f68:	21 1d       	adc	r18, r1
    6f6a:	82 2f       	mov	r24, r18
    6f6c:	76 2f       	mov	r23, r22
    6f6e:	6a 2f       	mov	r22, r26
    6f70:	11 24       	eor	r1, r1
    6f72:	9f 57       	subi	r25, 0x7F	; 127
    6f74:	50 40       	sbci	r21, 0x00	; 0
    6f76:	8a f0       	brmi	.+34     	; 0x6f9a <__mulsf3_pse+0x84>
    6f78:	e1 f0       	breq	.+56     	; 0x6fb2 <__mulsf3_pse+0x9c>
    6f7a:	88 23       	and	r24, r24
    6f7c:	4a f0       	brmi	.+18     	; 0x6f90 <__mulsf3_pse+0x7a>
    6f7e:	ee 0f       	add	r30, r30
    6f80:	ff 1f       	adc	r31, r31
    6f82:	bb 1f       	adc	r27, r27
    6f84:	66 1f       	adc	r22, r22
    6f86:	77 1f       	adc	r23, r23
    6f88:	88 1f       	adc	r24, r24
    6f8a:	91 50       	subi	r25, 0x01	; 1
    6f8c:	50 40       	sbci	r21, 0x00	; 0
    6f8e:	a9 f7       	brne	.-22     	; 0x6f7a <__mulsf3_pse+0x64>
    6f90:	9e 3f       	cpi	r25, 0xFE	; 254
    6f92:	51 05       	cpc	r21, r1
    6f94:	70 f0       	brcs	.+28     	; 0x6fb2 <__mulsf3_pse+0x9c>
    6f96:	5c cf       	rjmp	.-328    	; 0x6e50 <__fp_inf>
    6f98:	a6 cf       	rjmp	.-180    	; 0x6ee6 <__fp_szero>
    6f9a:	5f 3f       	cpi	r21, 0xFF	; 255
    6f9c:	ec f3       	brlt	.-6      	; 0x6f98 <__mulsf3_pse+0x82>
    6f9e:	98 3e       	cpi	r25, 0xE8	; 232
    6fa0:	dc f3       	brlt	.-10     	; 0x6f98 <__mulsf3_pse+0x82>
    6fa2:	86 95       	lsr	r24
    6fa4:	77 95       	ror	r23
    6fa6:	67 95       	ror	r22
    6fa8:	b7 95       	ror	r27
    6faa:	f7 95       	ror	r31
    6fac:	e7 95       	ror	r30
    6fae:	9f 5f       	subi	r25, 0xFF	; 255
    6fb0:	c1 f7       	brne	.-16     	; 0x6fa2 <__mulsf3_pse+0x8c>
    6fb2:	fe 2b       	or	r31, r30
    6fb4:	88 0f       	add	r24, r24
    6fb6:	91 1d       	adc	r25, r1
    6fb8:	96 95       	lsr	r25
    6fba:	87 95       	ror	r24
    6fbc:	97 f9       	bld	r25, 7
    6fbe:	08 95       	ret

00006fc0 <__udivmodhi4>:
    6fc0:	aa 1b       	sub	r26, r26
    6fc2:	bb 1b       	sub	r27, r27
    6fc4:	51 e1       	ldi	r21, 0x11	; 17
    6fc6:	07 c0       	rjmp	.+14     	; 0x6fd6 <__udivmodhi4_ep>

00006fc8 <__udivmodhi4_loop>:
    6fc8:	aa 1f       	adc	r26, r26
    6fca:	bb 1f       	adc	r27, r27
    6fcc:	a6 17       	cp	r26, r22
    6fce:	b7 07       	cpc	r27, r23
    6fd0:	10 f0       	brcs	.+4      	; 0x6fd6 <__udivmodhi4_ep>
    6fd2:	a6 1b       	sub	r26, r22
    6fd4:	b7 0b       	sbc	r27, r23

00006fd6 <__udivmodhi4_ep>:
    6fd6:	88 1f       	adc	r24, r24
    6fd8:	99 1f       	adc	r25, r25
    6fda:	5a 95       	dec	r21
    6fdc:	a9 f7       	brne	.-22     	; 0x6fc8 <__udivmodhi4_loop>
    6fde:	80 95       	com	r24
    6fe0:	90 95       	com	r25
    6fe2:	bc 01       	movw	r22, r24
    6fe4:	cd 01       	movw	r24, r26
    6fe6:	08 95       	ret

00006fe8 <__divmodhi4>:
    6fe8:	97 fb       	bst	r25, 7
    6fea:	09 2e       	mov	r0, r25
    6fec:	07 26       	eor	r0, r23
    6fee:	0a d0       	rcall	.+20     	; 0x7004 <__divmodhi4_neg1>
    6ff0:	77 fd       	sbrc	r23, 7
    6ff2:	04 d0       	rcall	.+8      	; 0x6ffc <__divmodhi4_neg2>
    6ff4:	e5 df       	rcall	.-54     	; 0x6fc0 <__udivmodhi4>
    6ff6:	06 d0       	rcall	.+12     	; 0x7004 <__divmodhi4_neg1>
    6ff8:	00 20       	and	r0, r0
    6ffa:	1a f4       	brpl	.+6      	; 0x7002 <__divmodhi4_exit>

00006ffc <__divmodhi4_neg2>:
    6ffc:	70 95       	com	r23
    6ffe:	61 95       	neg	r22
    7000:	7f 4f       	sbci	r23, 0xFF	; 255

00007002 <__divmodhi4_exit>:
    7002:	08 95       	ret

00007004 <__divmodhi4_neg1>:
    7004:	f6 f7       	brtc	.-4      	; 0x7002 <__divmodhi4_exit>
    7006:	90 95       	com	r25
    7008:	81 95       	neg	r24
    700a:	9f 4f       	sbci	r25, 0xFF	; 255
    700c:	08 95       	ret

0000700e <abs>:
    700e:	28 2f       	mov	r18, r24
    7010:	39 2f       	mov	r19, r25
    7012:	37 ff       	sbrs	r19, 7
    7014:	03 c0       	rjmp	.+6      	; 0x701c <abs+0xe>
    7016:	30 95       	com	r19
    7018:	21 95       	neg	r18
    701a:	3f 4f       	sbci	r19, 0xFF	; 255
    701c:	c9 01       	movw	r24, r18
    701e:	08 95       	ret

00007020 <dtostrf>:
    7020:	ef 92       	push	r14
    7022:	ff 92       	push	r15
    7024:	0f 93       	push	r16
    7026:	1f 93       	push	r17
    7028:	32 2f       	mov	r19, r18
    702a:	f0 2e       	mov	r15, r16
    702c:	47 ff       	sbrs	r20, 7
    702e:	02 c0       	rjmp	.+4      	; 0x7034 <dtostrf+0x14>
    7030:	a4 e1       	ldi	r26, 0x14	; 20
    7032:	01 c0       	rjmp	.+2      	; 0x7036 <dtostrf+0x16>
    7034:	a4 e0       	ldi	r26, 0x04	; 4
    7036:	e4 2f       	mov	r30, r20
    7038:	ff 27       	eor	r31, r31
    703a:	e7 fd       	sbrc	r30, 7
    703c:	f0 95       	com	r31
    703e:	f7 ff       	sbrs	r31, 7
    7040:	03 c0       	rjmp	.+6      	; 0x7048 <dtostrf+0x28>
    7042:	f0 95       	com	r31
    7044:	e1 95       	neg	r30
    7046:	ff 4f       	sbci	r31, 0xFF	; 255
    7048:	4f 2d       	mov	r20, r15
    704a:	51 2f       	mov	r21, r17
    704c:	2e 2f       	mov	r18, r30
    704e:	03 2f       	mov	r16, r19
    7050:	ea 2e       	mov	r14, r26
    7052:	0e 94 bc 38 	call	0x7178	; 0x7178 <dtoa_prf>
    7056:	8f 2d       	mov	r24, r15
    7058:	91 2f       	mov	r25, r17
    705a:	1f 91       	pop	r17
    705c:	0f 91       	pop	r16
    705e:	ff 90       	pop	r15
    7060:	ef 90       	pop	r14
    7062:	08 95       	ret

00007064 <memcpy_P>:
    7064:	fb 01       	movw	r30, r22
    7066:	dc 01       	movw	r26, r24
    7068:	02 c0       	rjmp	.+4      	; 0x706e <memcpy_P+0xa>
    706a:	05 90       	lpm	r0, Z+
    706c:	0d 92       	st	X+, r0
    706e:	41 50       	subi	r20, 0x01	; 1
    7070:	50 40       	sbci	r21, 0x00	; 0
    7072:	d8 f7       	brcc	.-10     	; 0x706a <memcpy_P+0x6>
    7074:	08 95       	ret

00007076 <strcpy_P>:
    7076:	fb 01       	movw	r30, r22
    7078:	dc 01       	movw	r26, r24
    707a:	05 90       	lpm	r0, Z+
    707c:	0d 92       	st	X+, r0
    707e:	00 20       	and	r0, r0
    7080:	e1 f7       	brne	.-8      	; 0x707a <strcpy_P+0x4>
    7082:	08 95       	ret

00007084 <strlen_P>:
    7084:	fc 01       	movw	r30, r24
    7086:	05 90       	lpm	r0, Z+
    7088:	00 20       	and	r0, r0
    708a:	e9 f7       	brne	.-6      	; 0x7086 <strlen_P+0x2>
    708c:	80 95       	com	r24
    708e:	90 95       	com	r25
    7090:	8e 0f       	add	r24, r30
    7092:	9f 1f       	adc	r25, r31
    7094:	08 95       	ret

00007096 <memcpy>:
    7096:	fb 01       	movw	r30, r22
    7098:	dc 01       	movw	r26, r24
    709a:	02 c0       	rjmp	.+4      	; 0x70a0 <memcpy+0xa>
    709c:	01 90       	ld	r0, Z+
    709e:	0d 92       	st	X+, r0
    70a0:	41 50       	subi	r20, 0x01	; 1
    70a2:	50 40       	sbci	r21, 0x00	; 0
    70a4:	d8 f7       	brcc	.-10     	; 0x709c <memcpy+0x6>
    70a6:	08 95       	ret

000070a8 <strcat>:
    70a8:	fb 01       	movw	r30, r22
    70aa:	dc 01       	movw	r26, r24
    70ac:	0d 90       	ld	r0, X+
    70ae:	00 20       	and	r0, r0
    70b0:	e9 f7       	brne	.-6      	; 0x70ac <strcat+0x4>
    70b2:	11 97       	sbiw	r26, 0x01	; 1
    70b4:	01 90       	ld	r0, Z+
    70b6:	0d 92       	st	X+, r0
    70b8:	00 20       	and	r0, r0
    70ba:	e1 f7       	brne	.-8      	; 0x70b4 <strcat+0xc>
    70bc:	08 95       	ret

000070be <itoa>:
    70be:	fb 01       	movw	r30, r22
    70c0:	9f 01       	movw	r18, r30
    70c2:	e8 94       	clt
    70c4:	42 30       	cpi	r20, 0x02	; 2
    70c6:	c4 f0       	brlt	.+48     	; 0x70f8 <itoa+0x3a>
    70c8:	45 32       	cpi	r20, 0x25	; 37
    70ca:	b4 f4       	brge	.+44     	; 0x70f8 <itoa+0x3a>
    70cc:	4a 30       	cpi	r20, 0x0A	; 10
    70ce:	29 f4       	brne	.+10     	; 0x70da <itoa+0x1c>
    70d0:	97 fb       	bst	r25, 7
    70d2:	1e f4       	brtc	.+6      	; 0x70da <itoa+0x1c>
    70d4:	90 95       	com	r25
    70d6:	81 95       	neg	r24
    70d8:	9f 4f       	sbci	r25, 0xFF	; 255
    70da:	64 2f       	mov	r22, r20
    70dc:	77 27       	eor	r23, r23
    70de:	0e 94 e0 37 	call	0x6fc0	; 0x6fc0 <__udivmodhi4>
    70e2:	80 5d       	subi	r24, 0xD0	; 208
    70e4:	8a 33       	cpi	r24, 0x3A	; 58
    70e6:	0c f0       	brlt	.+2      	; 0x70ea <itoa+0x2c>
    70e8:	89 5d       	subi	r24, 0xD9	; 217
    70ea:	81 93       	st	Z+, r24
    70ec:	cb 01       	movw	r24, r22
    70ee:	00 97       	sbiw	r24, 0x00	; 0
    70f0:	a1 f7       	brne	.-24     	; 0x70da <itoa+0x1c>
    70f2:	16 f4       	brtc	.+4      	; 0x70f8 <itoa+0x3a>
    70f4:	5d e2       	ldi	r21, 0x2D	; 45
    70f6:	51 93       	st	Z+, r21
    70f8:	10 82       	st	Z, r1
    70fa:	c9 01       	movw	r24, r18
    70fc:	0c 94 eb 3a 	jmp	0x75d6	; 0x75d6 <strrev>

00007100 <utoa>:
    7100:	fb 01       	movw	r30, r22
    7102:	9f 01       	movw	r18, r30
    7104:	42 30       	cpi	r20, 0x02	; 2
    7106:	74 f0       	brlt	.+28     	; 0x7124 <utoa+0x24>
    7108:	45 32       	cpi	r20, 0x25	; 37
    710a:	64 f4       	brge	.+24     	; 0x7124 <utoa+0x24>
    710c:	64 2f       	mov	r22, r20
    710e:	77 27       	eor	r23, r23
    7110:	0e 94 e0 37 	call	0x6fc0	; 0x6fc0 <__udivmodhi4>
    7114:	80 5d       	subi	r24, 0xD0	; 208
    7116:	8a 33       	cpi	r24, 0x3A	; 58
    7118:	0c f0       	brlt	.+2      	; 0x711c <utoa+0x1c>
    711a:	89 5d       	subi	r24, 0xD9	; 217
    711c:	81 93       	st	Z+, r24
    711e:	cb 01       	movw	r24, r22
    7120:	00 97       	sbiw	r24, 0x00	; 0
    7122:	a1 f7       	brne	.-24     	; 0x710c <utoa+0xc>
    7124:	10 82       	st	Z, r1
    7126:	c9 01       	movw	r24, r18
    7128:	0c 94 eb 3a 	jmp	0x75d6	; 0x75d6 <strrev>

0000712c <__eerd_block_m324pa>:
    712c:	dc 01       	movw	r26, r24
    712e:	cb 01       	movw	r24, r22

00007130 <__eerd_blraw_m324pa>:
    7130:	fc 01       	movw	r30, r24
    7132:	f9 99       	sbic	0x1f, 1	; 31
    7134:	fe cf       	rjmp	.-4      	; 0x7132 <__eerd_blraw_m324pa+0x2>
    7136:	06 c0       	rjmp	.+12     	; 0x7144 <__eerd_blraw_m324pa+0x14>
    7138:	f2 bd       	out	0x22, r31	; 34
    713a:	e1 bd       	out	0x21, r30	; 33
    713c:	f8 9a       	sbi	0x1f, 0	; 31
    713e:	31 96       	adiw	r30, 0x01	; 1
    7140:	00 b4       	in	r0, 0x20	; 32
    7142:	0d 92       	st	X+, r0
    7144:	41 50       	subi	r20, 0x01	; 1
    7146:	50 40       	sbci	r21, 0x00	; 0
    7148:	b8 f7       	brcc	.-18     	; 0x7138 <__eerd_blraw_m324pa+0x8>
    714a:	08 95       	ret

0000714c <__eerd_byte_m324pa>:
    714c:	f9 99       	sbic	0x1f, 1	; 31
    714e:	fe cf       	rjmp	.-4      	; 0x714c <__eerd_byte_m324pa>
    7150:	92 bd       	out	0x22, r25	; 34
    7152:	81 bd       	out	0x21, r24	; 33
    7154:	f8 9a       	sbi	0x1f, 0	; 31
    7156:	99 27       	eor	r25, r25
    7158:	80 b5       	in	r24, 0x20	; 32
    715a:	08 95       	ret

0000715c <__eewr_byte_m324pa>:
    715c:	26 2f       	mov	r18, r22

0000715e <__eewr_r18_m324pa>:
    715e:	f9 99       	sbic	0x1f, 1	; 31
    7160:	fe cf       	rjmp	.-4      	; 0x715e <__eewr_r18_m324pa>
    7162:	1f ba       	out	0x1f, r1	; 31
    7164:	92 bd       	out	0x22, r25	; 34
    7166:	81 bd       	out	0x21, r24	; 33
    7168:	20 bd       	out	0x20, r18	; 32
    716a:	0f b6       	in	r0, 0x3f	; 63
    716c:	f8 94       	cli
    716e:	fa 9a       	sbi	0x1f, 2	; 31
    7170:	f9 9a       	sbi	0x1f, 1	; 31
    7172:	0f be       	out	0x3f, r0	; 63
    7174:	01 96       	adiw	r24, 0x01	; 1
    7176:	08 95       	ret

00007178 <dtoa_prf>:
    7178:	a9 e0       	ldi	r26, 0x09	; 9
    717a:	b0 e0       	ldi	r27, 0x00	; 0
    717c:	e2 ec       	ldi	r30, 0xC2	; 194
    717e:	f8 e3       	ldi	r31, 0x38	; 56
    7180:	0c 94 03 3b 	jmp	0x7606	; 0x7606 <__prologue_saves__+0x10>
    7184:	6a 01       	movw	r12, r20
    7186:	f2 2e       	mov	r15, r18
    7188:	10 2f       	mov	r17, r16
    718a:	0c 33       	cpi	r16, 0x3C	; 60
    718c:	18 f4       	brcc	.+6      	; 0x7194 <dtoa_prf+0x1c>
    718e:	b0 2e       	mov	r11, r16
    7190:	b3 94       	inc	r11
    7192:	02 c0       	rjmp	.+4      	; 0x7198 <dtoa_prf+0x20>
    7194:	ec e3       	ldi	r30, 0x3C	; 60
    7196:	be 2e       	mov	r11, r30
    7198:	ae 01       	movw	r20, r28
    719a:	4f 5f       	subi	r20, 0xFF	; 255
    719c:	5f 4f       	sbci	r21, 0xFF	; 255
    719e:	27 e0       	ldi	r18, 0x07	; 7
    71a0:	0b 2d       	mov	r16, r11
    71a2:	0e 94 13 3a 	call	0x7426	; 0x7426 <__ftoa_engine>
    71a6:	29 81       	ldd	r18, Y+1	; 0x01
    71a8:	30 e0       	ldi	r19, 0x00	; 0
    71aa:	a9 01       	movw	r20, r18
    71ac:	49 70       	andi	r20, 0x09	; 9
    71ae:	50 70       	andi	r21, 0x00	; 0
    71b0:	41 30       	cpi	r20, 0x01	; 1
    71b2:	51 05       	cpc	r21, r1
    71b4:	31 f0       	breq	.+12     	; 0x71c2 <dtoa_prf+0x4a>
    71b6:	e1 fc       	sbrc	r14, 1
    71b8:	06 c0       	rjmp	.+12     	; 0x71c6 <dtoa_prf+0x4e>
    71ba:	e0 fe       	sbrs	r14, 0
    71bc:	06 c0       	rjmp	.+12     	; 0x71ca <dtoa_prf+0x52>
    71be:	e0 e2       	ldi	r30, 0x20	; 32
    71c0:	05 c0       	rjmp	.+10     	; 0x71cc <dtoa_prf+0x54>
    71c2:	ed e2       	ldi	r30, 0x2D	; 45
    71c4:	03 c0       	rjmp	.+6      	; 0x71cc <dtoa_prf+0x54>
    71c6:	eb e2       	ldi	r30, 0x2B	; 43
    71c8:	01 c0       	rjmp	.+2      	; 0x71cc <dtoa_prf+0x54>
    71ca:	e0 e0       	ldi	r30, 0x00	; 0
    71cc:	23 ff       	sbrs	r18, 3
    71ce:	37 c0       	rjmp	.+110    	; 0x723e <dtoa_prf+0xc6>
    71d0:	ee 23       	and	r30, r30
    71d2:	11 f0       	breq	.+4      	; 0x71d8 <dtoa_prf+0x60>
    71d4:	84 e0       	ldi	r24, 0x04	; 4
    71d6:	01 c0       	rjmp	.+2      	; 0x71da <dtoa_prf+0x62>
    71d8:	83 e0       	ldi	r24, 0x03	; 3
    71da:	8f 15       	cp	r24, r15
    71dc:	18 f4       	brcc	.+6      	; 0x71e4 <dtoa_prf+0x6c>
    71de:	f8 1a       	sub	r15, r24
    71e0:	8f 2d       	mov	r24, r15
    71e2:	01 c0       	rjmp	.+2      	; 0x71e6 <dtoa_prf+0x6e>
    71e4:	80 e0       	ldi	r24, 0x00	; 0
    71e6:	e4 fc       	sbrc	r14, 4
    71e8:	0b c0       	rjmp	.+22     	; 0x7200 <dtoa_prf+0x88>
    71ea:	98 2f       	mov	r25, r24
    71ec:	d6 01       	movw	r26, r12
    71ee:	20 e2       	ldi	r18, 0x20	; 32
    71f0:	02 c0       	rjmp	.+4      	; 0x71f6 <dtoa_prf+0x7e>
    71f2:	2d 93       	st	X+, r18
    71f4:	91 50       	subi	r25, 0x01	; 1
    71f6:	99 23       	and	r25, r25
    71f8:	e1 f7       	brne	.-8      	; 0x71f2 <dtoa_prf+0x7a>
    71fa:	c8 0e       	add	r12, r24
    71fc:	d1 1c       	adc	r13, r1
    71fe:	80 e0       	ldi	r24, 0x00	; 0
    7200:	ee 23       	and	r30, r30
    7202:	19 f0       	breq	.+6      	; 0x720a <dtoa_prf+0x92>
    7204:	d6 01       	movw	r26, r12
    7206:	ed 93       	st	X+, r30
    7208:	6d 01       	movw	r12, r26
    720a:	f6 01       	movw	r30, r12
    720c:	31 96       	adiw	r30, 0x01	; 1
    720e:	e2 fe       	sbrs	r14, 2
    7210:	05 c0       	rjmp	.+10     	; 0x721c <dtoa_prf+0xa4>
    7212:	9e e4       	ldi	r25, 0x4E	; 78
    7214:	d6 01       	movw	r26, r12
    7216:	9c 93       	st	X, r25
    7218:	21 e4       	ldi	r18, 0x41	; 65
    721a:	04 c0       	rjmp	.+8      	; 0x7224 <dtoa_prf+0xac>
    721c:	9e e6       	ldi	r25, 0x6E	; 110
    721e:	d6 01       	movw	r26, r12
    7220:	9c 93       	st	X, r25
    7222:	21 e6       	ldi	r18, 0x61	; 97
    7224:	11 96       	adiw	r26, 0x01	; 1
    7226:	2c 93       	st	X, r18
    7228:	91 83       	std	Z+1, r25	; 0x01
    722a:	32 96       	adiw	r30, 0x02	; 2
    722c:	98 2f       	mov	r25, r24
    722e:	df 01       	movw	r26, r30
    7230:	20 e2       	ldi	r18, 0x20	; 32
    7232:	02 c0       	rjmp	.+4      	; 0x7238 <dtoa_prf+0xc0>
    7234:	2d 93       	st	X+, r18
    7236:	91 50       	subi	r25, 0x01	; 1
    7238:	99 23       	and	r25, r25
    723a:	e1 f7       	brne	.-8      	; 0x7234 <dtoa_prf+0xbc>
    723c:	3d c0       	rjmp	.+122    	; 0x72b8 <dtoa_prf+0x140>
    723e:	22 ff       	sbrs	r18, 2
    7240:	41 c0       	rjmp	.+130    	; 0x72c4 <dtoa_prf+0x14c>
    7242:	ee 23       	and	r30, r30
    7244:	11 f0       	breq	.+4      	; 0x724a <dtoa_prf+0xd2>
    7246:	84 e0       	ldi	r24, 0x04	; 4
    7248:	01 c0       	rjmp	.+2      	; 0x724c <dtoa_prf+0xd4>
    724a:	83 e0       	ldi	r24, 0x03	; 3
    724c:	8f 15       	cp	r24, r15
    724e:	18 f4       	brcc	.+6      	; 0x7256 <dtoa_prf+0xde>
    7250:	f8 1a       	sub	r15, r24
    7252:	8f 2d       	mov	r24, r15
    7254:	01 c0       	rjmp	.+2      	; 0x7258 <dtoa_prf+0xe0>
    7256:	80 e0       	ldi	r24, 0x00	; 0
    7258:	e4 fc       	sbrc	r14, 4
    725a:	0b c0       	rjmp	.+22     	; 0x7272 <dtoa_prf+0xfa>
    725c:	98 2f       	mov	r25, r24
    725e:	d6 01       	movw	r26, r12
    7260:	20 e2       	ldi	r18, 0x20	; 32
    7262:	02 c0       	rjmp	.+4      	; 0x7268 <dtoa_prf+0xf0>
    7264:	2d 93       	st	X+, r18
    7266:	91 50       	subi	r25, 0x01	; 1
    7268:	99 23       	and	r25, r25
    726a:	e1 f7       	brne	.-8      	; 0x7264 <dtoa_prf+0xec>
    726c:	c8 0e       	add	r12, r24
    726e:	d1 1c       	adc	r13, r1
    7270:	80 e0       	ldi	r24, 0x00	; 0
    7272:	ee 23       	and	r30, r30
    7274:	19 f0       	breq	.+6      	; 0x727c <dtoa_prf+0x104>
    7276:	d6 01       	movw	r26, r12
    7278:	ed 93       	st	X+, r30
    727a:	6d 01       	movw	r12, r26
    727c:	f6 01       	movw	r30, r12
    727e:	31 96       	adiw	r30, 0x01	; 1
    7280:	e2 fe       	sbrs	r14, 2
    7282:	09 c0       	rjmp	.+18     	; 0x7296 <dtoa_prf+0x11e>
    7284:	99 e4       	ldi	r25, 0x49	; 73
    7286:	d6 01       	movw	r26, r12
    7288:	9c 93       	st	X, r25
    728a:	9e e4       	ldi	r25, 0x4E	; 78
    728c:	11 96       	adiw	r26, 0x01	; 1
    728e:	9c 93       	st	X, r25
    7290:	11 97       	sbiw	r26, 0x01	; 1
    7292:	96 e4       	ldi	r25, 0x46	; 70
    7294:	07 c0       	rjmp	.+14     	; 0x72a4 <dtoa_prf+0x12c>
    7296:	99 e6       	ldi	r25, 0x69	; 105
    7298:	d6 01       	movw	r26, r12
    729a:	9c 93       	st	X, r25
    729c:	9e e6       	ldi	r25, 0x6E	; 110
    729e:	11 96       	adiw	r26, 0x01	; 1
    72a0:	9c 93       	st	X, r25
    72a2:	96 e6       	ldi	r25, 0x66	; 102
    72a4:	91 83       	std	Z+1, r25	; 0x01
    72a6:	32 96       	adiw	r30, 0x02	; 2
    72a8:	98 2f       	mov	r25, r24
    72aa:	df 01       	movw	r26, r30
    72ac:	20 e2       	ldi	r18, 0x20	; 32
    72ae:	02 c0       	rjmp	.+4      	; 0x72b4 <dtoa_prf+0x13c>
    72b0:	2d 93       	st	X+, r18
    72b2:	91 50       	subi	r25, 0x01	; 1
    72b4:	99 23       	and	r25, r25
    72b6:	e1 f7       	brne	.-8      	; 0x72b0 <dtoa_prf+0x138>
    72b8:	e8 0f       	add	r30, r24
    72ba:	f1 1d       	adc	r31, r1
    72bc:	10 82       	st	Z, r1
    72be:	2e ef       	ldi	r18, 0xFE	; 254
    72c0:	3f ef       	ldi	r19, 0xFF	; 255
    72c2:	ac c0       	rjmp	.+344    	; 0x741c <dtoa_prf+0x2a4>
    72c4:	41 e0       	ldi	r20, 0x01	; 1
    72c6:	50 e0       	ldi	r21, 0x00	; 0
    72c8:	ee 23       	and	r30, r30
    72ca:	11 f4       	brne	.+4      	; 0x72d0 <dtoa_prf+0x158>
    72cc:	40 e0       	ldi	r20, 0x00	; 0
    72ce:	50 e0       	ldi	r21, 0x00	; 0
    72d0:	18 16       	cp	r1, r24
    72d2:	19 06       	cpc	r1, r25
    72d4:	24 f4       	brge	.+8      	; 0x72de <dtoa_prf+0x166>
    72d6:	bc 01       	movw	r22, r24
    72d8:	6f 5f       	subi	r22, 0xFF	; 255
    72da:	7f 4f       	sbci	r23, 0xFF	; 255
    72dc:	02 c0       	rjmp	.+4      	; 0x72e2 <dtoa_prf+0x16a>
    72de:	61 e0       	ldi	r22, 0x01	; 1
    72e0:	70 e0       	ldi	r23, 0x00	; 0
    72e2:	64 0f       	add	r22, r20
    72e4:	75 1f       	adc	r23, r21
    72e6:	11 23       	and	r17, r17
    72e8:	29 f0       	breq	.+10     	; 0x72f4 <dtoa_prf+0x17c>
    72ea:	41 2f       	mov	r20, r17
    72ec:	50 e0       	ldi	r21, 0x00	; 0
    72ee:	4f 5f       	subi	r20, 0xFF	; 255
    72f0:	5f 4f       	sbci	r21, 0xFF	; 255
    72f2:	02 c0       	rjmp	.+4      	; 0x72f8 <dtoa_prf+0x180>
    72f4:	40 e0       	ldi	r20, 0x00	; 0
    72f6:	50 e0       	ldi	r21, 0x00	; 0
    72f8:	46 0f       	add	r20, r22
    72fa:	57 1f       	adc	r21, r23
    72fc:	6f 2d       	mov	r22, r15
    72fe:	70 e0       	ldi	r23, 0x00	; 0
    7300:	46 17       	cp	r20, r22
    7302:	57 07       	cpc	r21, r23
    7304:	1c f4       	brge	.+6      	; 0x730c <dtoa_prf+0x194>
    7306:	0f 2d       	mov	r16, r15
    7308:	04 1b       	sub	r16, r20
    730a:	01 c0       	rjmp	.+2      	; 0x730e <dtoa_prf+0x196>
    730c:	00 e0       	ldi	r16, 0x00	; 0
    730e:	ff 24       	eor	r15, r15
    7310:	a7 01       	movw	r20, r14
    7312:	40 71       	andi	r20, 0x10	; 16
    7314:	50 70       	andi	r21, 0x00	; 0
    7316:	e4 fc       	sbrc	r14, 4
    7318:	0d c0       	rjmp	.+26     	; 0x7334 <dtoa_prf+0x1bc>
    731a:	e3 fc       	sbrc	r14, 3
    731c:	0b c0       	rjmp	.+22     	; 0x7334 <dtoa_prf+0x1bc>
    731e:	60 2f       	mov	r22, r16
    7320:	d6 01       	movw	r26, r12
    7322:	70 e2       	ldi	r23, 0x20	; 32
    7324:	02 c0       	rjmp	.+4      	; 0x732a <dtoa_prf+0x1b2>
    7326:	7d 93       	st	X+, r23
    7328:	61 50       	subi	r22, 0x01	; 1
    732a:	66 23       	and	r22, r22
    732c:	e1 f7       	brne	.-8      	; 0x7326 <dtoa_prf+0x1ae>
    732e:	c0 0e       	add	r12, r16
    7330:	d1 1c       	adc	r13, r1
    7332:	00 e0       	ldi	r16, 0x00	; 0
    7334:	ee 23       	and	r30, r30
    7336:	19 f0       	breq	.+6      	; 0x733e <dtoa_prf+0x1c6>
    7338:	d6 01       	movw	r26, r12
    733a:	ed 93       	st	X+, r30
    733c:	6d 01       	movw	r12, r26
    733e:	41 15       	cp	r20, r1
    7340:	51 05       	cpc	r21, r1
    7342:	59 f4       	brne	.+22     	; 0x735a <dtoa_prf+0x1e2>
    7344:	40 2f       	mov	r20, r16
    7346:	f6 01       	movw	r30, r12
    7348:	50 e3       	ldi	r21, 0x30	; 48
    734a:	02 c0       	rjmp	.+4      	; 0x7350 <dtoa_prf+0x1d8>
    734c:	51 93       	st	Z+, r21
    734e:	41 50       	subi	r20, 0x01	; 1
    7350:	44 23       	and	r20, r20
    7352:	e1 f7       	brne	.-8      	; 0x734c <dtoa_prf+0x1d4>
    7354:	c0 0e       	add	r12, r16
    7356:	d1 1c       	adc	r13, r1
    7358:	00 e0       	ldi	r16, 0x00	; 0
    735a:	b8 0e       	add	r11, r24
    735c:	fa 80       	ldd	r15, Y+2	; 0x02
    735e:	a9 01       	movw	r20, r18
    7360:	40 71       	andi	r20, 0x10	; 16
    7362:	50 70       	andi	r21, 0x00	; 0
    7364:	24 ff       	sbrs	r18, 4
    7366:	04 c0       	rjmp	.+8      	; 0x7370 <dtoa_prf+0x1f8>
    7368:	bf 2d       	mov	r27, r15
    736a:	b1 33       	cpi	r27, 0x31	; 49
    736c:	09 f4       	brne	.+2      	; 0x7370 <dtoa_prf+0x1f8>
    736e:	ba 94       	dec	r11
    7370:	1b 14       	cp	r1, r11
    7372:	2c f4       	brge	.+10     	; 0x737e <dtoa_prf+0x206>
    7374:	ab 2d       	mov	r26, r11
    7376:	a9 30       	cpi	r26, 0x09	; 9
    7378:	18 f0       	brcs	.+6      	; 0x7380 <dtoa_prf+0x208>
    737a:	a8 e0       	ldi	r26, 0x08	; 8
    737c:	01 c0       	rjmp	.+2      	; 0x7380 <dtoa_prf+0x208>
    737e:	a1 e0       	ldi	r26, 0x01	; 1
    7380:	9c 01       	movw	r18, r24
    7382:	97 ff       	sbrs	r25, 7
    7384:	02 c0       	rjmp	.+4      	; 0x738a <dtoa_prf+0x212>
    7386:	20 e0       	ldi	r18, 0x00	; 0
    7388:	30 e0       	ldi	r19, 0x00	; 0
    738a:	bc 01       	movw	r22, r24
    738c:	6f 5f       	subi	r22, 0xFF	; 255
    738e:	7f 4f       	sbci	r23, 0xFF	; 255
    7390:	62 1b       	sub	r22, r18
    7392:	73 0b       	sbc	r23, r19
    7394:	fe 01       	movw	r30, r28
    7396:	31 96       	adiw	r30, 0x01	; 1
    7398:	e6 0f       	add	r30, r22
    739a:	f7 1f       	adc	r31, r23
    739c:	6e e2       	ldi	r22, 0x2E	; 46
    739e:	e6 2e       	mov	r14, r22
    73a0:	bc 01       	movw	r22, r24
    73a2:	6a 1b       	sub	r22, r26
    73a4:	71 09       	sbc	r23, r1
    73a6:	a1 2f       	mov	r26, r17
    73a8:	b0 e0       	ldi	r27, 0x00	; 0
    73aa:	aa 24       	eor	r10, r10
    73ac:	bb 24       	eor	r11, r11
    73ae:	aa 1a       	sub	r10, r26
    73b0:	bb 0a       	sbc	r11, r27
    73b2:	1f ef       	ldi	r17, 0xFF	; 255
    73b4:	2f 3f       	cpi	r18, 0xFF	; 255
    73b6:	31 07       	cpc	r19, r17
    73b8:	19 f4       	brne	.+6      	; 0x73c0 <dtoa_prf+0x248>
    73ba:	d6 01       	movw	r26, r12
    73bc:	ed 92       	st	X+, r14
    73be:	6d 01       	movw	r12, r26
    73c0:	82 17       	cp	r24, r18
    73c2:	93 07       	cpc	r25, r19
    73c4:	2c f0       	brlt	.+10     	; 0x73d0 <dtoa_prf+0x258>
    73c6:	62 17       	cp	r22, r18
    73c8:	73 07       	cpc	r23, r19
    73ca:	14 f4       	brge	.+4      	; 0x73d0 <dtoa_prf+0x258>
    73cc:	10 81       	ld	r17, Z
    73ce:	01 c0       	rjmp	.+2      	; 0x73d2 <dtoa_prf+0x25a>
    73d0:	10 e3       	ldi	r17, 0x30	; 48
    73d2:	21 50       	subi	r18, 0x01	; 1
    73d4:	30 40       	sbci	r19, 0x00	; 0
    73d6:	31 96       	adiw	r30, 0x01	; 1
    73d8:	2a 15       	cp	r18, r10
    73da:	3b 05       	cpc	r19, r11
    73dc:	24 f0       	brlt	.+8      	; 0x73e6 <dtoa_prf+0x26e>
    73de:	d6 01       	movw	r26, r12
    73e0:	1d 93       	st	X+, r17
    73e2:	6d 01       	movw	r12, r26
    73e4:	e6 cf       	rjmp	.-52     	; 0x73b2 <dtoa_prf+0x23a>
    73e6:	28 17       	cp	r18, r24
    73e8:	39 07       	cpc	r19, r25
    73ea:	49 f4       	brne	.+18     	; 0x73fe <dtoa_prf+0x286>
    73ec:	bf 2d       	mov	r27, r15
    73ee:	b6 33       	cpi	r27, 0x36	; 54
    73f0:	28 f4       	brcc	.+10     	; 0x73fc <dtoa_prf+0x284>
    73f2:	b5 33       	cpi	r27, 0x35	; 53
    73f4:	21 f4       	brne	.+8      	; 0x73fe <dtoa_prf+0x286>
    73f6:	41 15       	cp	r20, r1
    73f8:	51 05       	cpc	r21, r1
    73fa:	09 f4       	brne	.+2      	; 0x73fe <dtoa_prf+0x286>
    73fc:	11 e3       	ldi	r17, 0x31	; 49
    73fe:	f6 01       	movw	r30, r12
    7400:	11 93       	st	Z+, r17
    7402:	80 2f       	mov	r24, r16
    7404:	df 01       	movw	r26, r30
    7406:	90 e2       	ldi	r25, 0x20	; 32
    7408:	02 c0       	rjmp	.+4      	; 0x740e <dtoa_prf+0x296>
    740a:	9d 93       	st	X+, r25
    740c:	81 50       	subi	r24, 0x01	; 1
    740e:	88 23       	and	r24, r24
    7410:	e1 f7       	brne	.-8      	; 0x740a <dtoa_prf+0x292>
    7412:	e0 0f       	add	r30, r16
    7414:	f1 1d       	adc	r31, r1
    7416:	10 82       	st	Z, r1
    7418:	20 e0       	ldi	r18, 0x00	; 0
    741a:	30 e0       	ldi	r19, 0x00	; 0
    741c:	c9 01       	movw	r24, r18
    741e:	29 96       	adiw	r28, 0x09	; 9
    7420:	ea e0       	ldi	r30, 0x0A	; 10
    7422:	0c 94 1f 3b 	jmp	0x763e	; 0x763e <__epilogue_restores__+0x10>

00007426 <__ftoa_engine>:
    7426:	28 30       	cpi	r18, 0x08	; 8
    7428:	08 f0       	brcs	.+2      	; 0x742c <__ftoa_engine+0x6>
    742a:	27 e0       	ldi	r18, 0x07	; 7
    742c:	33 27       	eor	r19, r19
    742e:	da 01       	movw	r26, r20
    7430:	99 0f       	add	r25, r25
    7432:	31 1d       	adc	r19, r1
    7434:	87 fd       	sbrc	r24, 7
    7436:	91 60       	ori	r25, 0x01	; 1
    7438:	00 96       	adiw	r24, 0x00	; 0
    743a:	61 05       	cpc	r22, r1
    743c:	71 05       	cpc	r23, r1
    743e:	39 f4       	brne	.+14     	; 0x744e <__ftoa_engine+0x28>
    7440:	32 60       	ori	r19, 0x02	; 2
    7442:	2e 5f       	subi	r18, 0xFE	; 254
    7444:	3d 93       	st	X+, r19
    7446:	30 e3       	ldi	r19, 0x30	; 48
    7448:	2a 95       	dec	r18
    744a:	e1 f7       	brne	.-8      	; 0x7444 <__ftoa_engine+0x1e>
    744c:	08 95       	ret
    744e:	9f 3f       	cpi	r25, 0xFF	; 255
    7450:	30 f0       	brcs	.+12     	; 0x745e <__ftoa_engine+0x38>
    7452:	80 38       	cpi	r24, 0x80	; 128
    7454:	71 05       	cpc	r23, r1
    7456:	61 05       	cpc	r22, r1
    7458:	09 f0       	breq	.+2      	; 0x745c <__ftoa_engine+0x36>
    745a:	3c 5f       	subi	r19, 0xFC	; 252
    745c:	3c 5f       	subi	r19, 0xFC	; 252
    745e:	3d 93       	st	X+, r19
    7460:	91 30       	cpi	r25, 0x01	; 1
    7462:	08 f0       	brcs	.+2      	; 0x7466 <__ftoa_engine+0x40>
    7464:	80 68       	ori	r24, 0x80	; 128
    7466:	91 1d       	adc	r25, r1
    7468:	df 93       	push	r29
    746a:	cf 93       	push	r28
    746c:	1f 93       	push	r17
    746e:	0f 93       	push	r16
    7470:	ff 92       	push	r15
    7472:	ef 92       	push	r14
    7474:	19 2f       	mov	r17, r25
    7476:	98 7f       	andi	r25, 0xF8	; 248
    7478:	96 95       	lsr	r25
    747a:	e9 2f       	mov	r30, r25
    747c:	96 95       	lsr	r25
    747e:	96 95       	lsr	r25
    7480:	e9 0f       	add	r30, r25
    7482:	ff 27       	eor	r31, r31
    7484:	eb 51       	subi	r30, 0x1B	; 27
    7486:	fe 4e       	sbci	r31, 0xEE	; 238
    7488:	99 27       	eor	r25, r25
    748a:	33 27       	eor	r19, r19
    748c:	ee 24       	eor	r14, r14
    748e:	ff 24       	eor	r15, r15
    7490:	a7 01       	movw	r20, r14
    7492:	e7 01       	movw	r28, r14
    7494:	05 90       	lpm	r0, Z+
    7496:	08 94       	sec
    7498:	07 94       	ror	r0
    749a:	28 f4       	brcc	.+10     	; 0x74a6 <__ftoa_engine+0x80>
    749c:	36 0f       	add	r19, r22
    749e:	e7 1e       	adc	r14, r23
    74a0:	f8 1e       	adc	r15, r24
    74a2:	49 1f       	adc	r20, r25
    74a4:	51 1d       	adc	r21, r1
    74a6:	66 0f       	add	r22, r22
    74a8:	77 1f       	adc	r23, r23
    74aa:	88 1f       	adc	r24, r24
    74ac:	99 1f       	adc	r25, r25
    74ae:	06 94       	lsr	r0
    74b0:	a1 f7       	brne	.-24     	; 0x749a <__ftoa_engine+0x74>
    74b2:	05 90       	lpm	r0, Z+
    74b4:	07 94       	ror	r0
    74b6:	28 f4       	brcc	.+10     	; 0x74c2 <__ftoa_engine+0x9c>
    74b8:	e7 0e       	add	r14, r23
    74ba:	f8 1e       	adc	r15, r24
    74bc:	49 1f       	adc	r20, r25
    74be:	56 1f       	adc	r21, r22
    74c0:	c1 1d       	adc	r28, r1
    74c2:	77 0f       	add	r23, r23
    74c4:	88 1f       	adc	r24, r24
    74c6:	99 1f       	adc	r25, r25
    74c8:	66 1f       	adc	r22, r22
    74ca:	06 94       	lsr	r0
    74cc:	a1 f7       	brne	.-24     	; 0x74b6 <__ftoa_engine+0x90>
    74ce:	05 90       	lpm	r0, Z+
    74d0:	07 94       	ror	r0
    74d2:	28 f4       	brcc	.+10     	; 0x74de <__ftoa_engine+0xb8>
    74d4:	f8 0e       	add	r15, r24
    74d6:	49 1f       	adc	r20, r25
    74d8:	56 1f       	adc	r21, r22
    74da:	c7 1f       	adc	r28, r23
    74dc:	d1 1d       	adc	r29, r1
    74de:	88 0f       	add	r24, r24
    74e0:	99 1f       	adc	r25, r25
    74e2:	66 1f       	adc	r22, r22
    74e4:	77 1f       	adc	r23, r23
    74e6:	06 94       	lsr	r0
    74e8:	a1 f7       	brne	.-24     	; 0x74d2 <__ftoa_engine+0xac>
    74ea:	05 90       	lpm	r0, Z+
    74ec:	07 94       	ror	r0
    74ee:	20 f4       	brcc	.+8      	; 0x74f8 <__ftoa_engine+0xd2>
    74f0:	49 0f       	add	r20, r25
    74f2:	56 1f       	adc	r21, r22
    74f4:	c7 1f       	adc	r28, r23
    74f6:	d8 1f       	adc	r29, r24
    74f8:	99 0f       	add	r25, r25
    74fa:	66 1f       	adc	r22, r22
    74fc:	77 1f       	adc	r23, r23
    74fe:	88 1f       	adc	r24, r24
    7500:	06 94       	lsr	r0
    7502:	a9 f7       	brne	.-22     	; 0x74ee <__ftoa_engine+0xc8>
    7504:	84 91       	lpm	r24, Z+
    7506:	10 95       	com	r17
    7508:	17 70       	andi	r17, 0x07	; 7
    750a:	41 f0       	breq	.+16     	; 0x751c <__ftoa_engine+0xf6>
    750c:	d6 95       	lsr	r29
    750e:	c7 95       	ror	r28
    7510:	57 95       	ror	r21
    7512:	47 95       	ror	r20
    7514:	f7 94       	ror	r15
    7516:	e7 94       	ror	r14
    7518:	1a 95       	dec	r17
    751a:	c1 f7       	brne	.-16     	; 0x750c <__ftoa_engine+0xe6>
    751c:	eb e8       	ldi	r30, 0x8B	; 139
    751e:	f1 e1       	ldi	r31, 0x11	; 17
    7520:	68 94       	set
    7522:	15 90       	lpm	r1, Z+
    7524:	15 91       	lpm	r17, Z+
    7526:	35 91       	lpm	r19, Z+
    7528:	65 91       	lpm	r22, Z+
    752a:	95 91       	lpm	r25, Z+
    752c:	05 90       	lpm	r0, Z+
    752e:	7f e2       	ldi	r23, 0x2F	; 47
    7530:	73 95       	inc	r23
    7532:	e1 18       	sub	r14, r1
    7534:	f1 0a       	sbc	r15, r17
    7536:	43 0b       	sbc	r20, r19
    7538:	56 0b       	sbc	r21, r22
    753a:	c9 0b       	sbc	r28, r25
    753c:	d0 09       	sbc	r29, r0
    753e:	c0 f7       	brcc	.-16     	; 0x7530 <__ftoa_engine+0x10a>
    7540:	e1 0c       	add	r14, r1
    7542:	f1 1e       	adc	r15, r17
    7544:	43 1f       	adc	r20, r19
    7546:	56 1f       	adc	r21, r22
    7548:	c9 1f       	adc	r28, r25
    754a:	d0 1d       	adc	r29, r0
    754c:	7e f4       	brtc	.+30     	; 0x756c <__ftoa_engine+0x146>
    754e:	70 33       	cpi	r23, 0x30	; 48
    7550:	11 f4       	brne	.+4      	; 0x7556 <__ftoa_engine+0x130>
    7552:	8a 95       	dec	r24
    7554:	e6 cf       	rjmp	.-52     	; 0x7522 <__ftoa_engine+0xfc>
    7556:	e8 94       	clt
    7558:	01 50       	subi	r16, 0x01	; 1
    755a:	30 f0       	brcs	.+12     	; 0x7568 <__ftoa_engine+0x142>
    755c:	08 0f       	add	r16, r24
    755e:	0a f4       	brpl	.+2      	; 0x7562 <__ftoa_engine+0x13c>
    7560:	00 27       	eor	r16, r16
    7562:	02 17       	cp	r16, r18
    7564:	08 f4       	brcc	.+2      	; 0x7568 <__ftoa_engine+0x142>
    7566:	20 2f       	mov	r18, r16
    7568:	23 95       	inc	r18
    756a:	02 2f       	mov	r16, r18
    756c:	7a 33       	cpi	r23, 0x3A	; 58
    756e:	28 f0       	brcs	.+10     	; 0x757a <__ftoa_engine+0x154>
    7570:	79 e3       	ldi	r23, 0x39	; 57
    7572:	7d 93       	st	X+, r23
    7574:	2a 95       	dec	r18
    7576:	e9 f7       	brne	.-6      	; 0x7572 <__ftoa_engine+0x14c>
    7578:	10 c0       	rjmp	.+32     	; 0x759a <__ftoa_engine+0x174>
    757a:	7d 93       	st	X+, r23
    757c:	2a 95       	dec	r18
    757e:	89 f6       	brne	.-94     	; 0x7522 <__ftoa_engine+0xfc>
    7580:	06 94       	lsr	r0
    7582:	97 95       	ror	r25
    7584:	67 95       	ror	r22
    7586:	37 95       	ror	r19
    7588:	17 95       	ror	r17
    758a:	17 94       	ror	r1
    758c:	e1 18       	sub	r14, r1
    758e:	f1 0a       	sbc	r15, r17
    7590:	43 0b       	sbc	r20, r19
    7592:	56 0b       	sbc	r21, r22
    7594:	c9 0b       	sbc	r28, r25
    7596:	d0 09       	sbc	r29, r0
    7598:	98 f0       	brcs	.+38     	; 0x75c0 <__ftoa_engine+0x19a>
    759a:	23 95       	inc	r18
    759c:	7e 91       	ld	r23, -X
    759e:	73 95       	inc	r23
    75a0:	7a 33       	cpi	r23, 0x3A	; 58
    75a2:	08 f0       	brcs	.+2      	; 0x75a6 <__ftoa_engine+0x180>
    75a4:	70 e3       	ldi	r23, 0x30	; 48
    75a6:	7c 93       	st	X, r23
    75a8:	20 13       	cpse	r18, r16
    75aa:	b8 f7       	brcc	.-18     	; 0x759a <__ftoa_engine+0x174>
    75ac:	7e 91       	ld	r23, -X
    75ae:	70 61       	ori	r23, 0x10	; 16
    75b0:	7d 93       	st	X+, r23
    75b2:	30 f0       	brcs	.+12     	; 0x75c0 <__ftoa_engine+0x19a>
    75b4:	83 95       	inc	r24
    75b6:	71 e3       	ldi	r23, 0x31	; 49
    75b8:	7d 93       	st	X+, r23
    75ba:	70 e3       	ldi	r23, 0x30	; 48
    75bc:	2a 95       	dec	r18
    75be:	e1 f7       	brne	.-8      	; 0x75b8 <__ftoa_engine+0x192>
    75c0:	11 24       	eor	r1, r1
    75c2:	ef 90       	pop	r14
    75c4:	ff 90       	pop	r15
    75c6:	0f 91       	pop	r16
    75c8:	1f 91       	pop	r17
    75ca:	cf 91       	pop	r28
    75cc:	df 91       	pop	r29
    75ce:	99 27       	eor	r25, r25
    75d0:	87 fd       	sbrc	r24, 7
    75d2:	90 95       	com	r25
    75d4:	08 95       	ret

000075d6 <strrev>:
    75d6:	dc 01       	movw	r26, r24
    75d8:	fc 01       	movw	r30, r24
    75da:	67 2f       	mov	r22, r23
    75dc:	71 91       	ld	r23, Z+
    75de:	77 23       	and	r23, r23
    75e0:	e1 f7       	brne	.-8      	; 0x75da <strrev+0x4>
    75e2:	32 97       	sbiw	r30, 0x02	; 2
    75e4:	04 c0       	rjmp	.+8      	; 0x75ee <strrev+0x18>
    75e6:	7c 91       	ld	r23, X
    75e8:	6d 93       	st	X+, r22
    75ea:	70 83       	st	Z, r23
    75ec:	62 91       	ld	r22, -Z
    75ee:	ae 17       	cp	r26, r30
    75f0:	bf 07       	cpc	r27, r31
    75f2:	c8 f3       	brcs	.-14     	; 0x75e6 <strrev+0x10>
    75f4:	08 95       	ret

000075f6 <__prologue_saves__>:
    75f6:	2f 92       	push	r2
    75f8:	3f 92       	push	r3
    75fa:	4f 92       	push	r4
    75fc:	5f 92       	push	r5
    75fe:	6f 92       	push	r6
    7600:	7f 92       	push	r7
    7602:	8f 92       	push	r8
    7604:	9f 92       	push	r9
    7606:	af 92       	push	r10
    7608:	bf 92       	push	r11
    760a:	cf 92       	push	r12
    760c:	df 92       	push	r13
    760e:	ef 92       	push	r14
    7610:	ff 92       	push	r15
    7612:	0f 93       	push	r16
    7614:	1f 93       	push	r17
    7616:	cf 93       	push	r28
    7618:	df 93       	push	r29
    761a:	cd b7       	in	r28, 0x3d	; 61
    761c:	de b7       	in	r29, 0x3e	; 62
    761e:	ca 1b       	sub	r28, r26
    7620:	db 0b       	sbc	r29, r27
    7622:	0f b6       	in	r0, 0x3f	; 63
    7624:	f8 94       	cli
    7626:	de bf       	out	0x3e, r29	; 62
    7628:	0f be       	out	0x3f, r0	; 63
    762a:	cd bf       	out	0x3d, r28	; 61
    762c:	09 94       	ijmp

0000762e <__epilogue_restores__>:
    762e:	2a 88       	ldd	r2, Y+18	; 0x12
    7630:	39 88       	ldd	r3, Y+17	; 0x11
    7632:	48 88       	ldd	r4, Y+16	; 0x10
    7634:	5f 84       	ldd	r5, Y+15	; 0x0f
    7636:	6e 84       	ldd	r6, Y+14	; 0x0e
    7638:	7d 84       	ldd	r7, Y+13	; 0x0d
    763a:	8c 84       	ldd	r8, Y+12	; 0x0c
    763c:	9b 84       	ldd	r9, Y+11	; 0x0b
    763e:	aa 84       	ldd	r10, Y+10	; 0x0a
    7640:	b9 84       	ldd	r11, Y+9	; 0x09
    7642:	c8 84       	ldd	r12, Y+8	; 0x08
    7644:	df 80       	ldd	r13, Y+7	; 0x07
    7646:	ee 80       	ldd	r14, Y+6	; 0x06
    7648:	fd 80       	ldd	r15, Y+5	; 0x05
    764a:	0c 81       	ldd	r16, Y+4	; 0x04
    764c:	1b 81       	ldd	r17, Y+3	; 0x03
    764e:	aa 81       	ldd	r26, Y+2	; 0x02
    7650:	b9 81       	ldd	r27, Y+1	; 0x01
    7652:	ce 0f       	add	r28, r30
    7654:	d1 1d       	adc	r29, r1
    7656:	0f b6       	in	r0, 0x3f	; 63
    7658:	f8 94       	cli
    765a:	de bf       	out	0x3e, r29	; 62
    765c:	0f be       	out	0x3f, r0	; 63
    765e:	cd bf       	out	0x3d, r28	; 61
    7660:	ed 01       	movw	r28, r26
    7662:	08 95       	ret

00007664 <_exit>:
    7664:	f8 94       	cli

00007666 <__stop_program>:
    7666:	ff cf       	rjmp	.-2      	; 0x7666 <__stop_program>
